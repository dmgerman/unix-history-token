begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Common subexpression elimination for GNU compiler.    Copyright (C) 1987, 88, 89, 92-7, 1998, 1999 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_comment
comment|/* stdio.h must precede rtl.h for FFS.  */
end_comment

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"splay-tree.h"
end_include

begin_comment
comment|/* The basic idea of common subexpression elimination is to go    through the code, keeping a record of expressions that would    have the same value at the current scan point, and replacing    expressions encountered with the cheapest equivalent expression.     It is too complicated to keep track of the different possibilities    when control paths merge; so, at each label, we forget all that is    known and start fresh.  This can be described as processing each    basic block separately.  Note, however, that these are not quite    the same as the basic blocks found by a later pass and used for    data flow analysis and register packing.  We do not need to start fresh    after a conditional jump instruction if there is no label there.     We use two data structures to record the equivalent expressions:    a hash table for most expressions, and several vectors together    with "quantity numbers" to record equivalent (pseudo) registers.     The use of the special data structure for registers is desirable    because it is faster.  It is possible because registers references    contain a fairly small number, the register number, taken from    a contiguously allocated series, and two register references are    identical if they have the same number.  General expressions    do not have any such thing, so the only way to retrieve the    information recorded on an expression other than a register    is to keep it in a hash table.  Registers and "quantity numbers":        At the start of each basic block, all of the (hardware and pseudo)    registers used in the function are given distinct quantity    numbers to indicate their contents.  During scan, when the code    copies one register into another, we copy the quantity number.    When a register is loaded in any other way, we allocate a new    quantity number to describe the value generated by this operation.    `reg_qty' records what quantity a register is currently thought    of as containing.     All real quantity numbers are greater than or equal to `max_reg'.    If register N has not been assigned a quantity, reg_qty[N] will equal N.     Quantity numbers below `max_reg' do not exist and none of the `qty_...'    variables should be referenced with an index below `max_reg'.     We also maintain a bidirectional chain of registers for each    quantity number.  `qty_first_reg', `qty_last_reg',    `reg_next_eqv' and `reg_prev_eqv' hold these chains.     The first register in a chain is the one whose lifespan is least local.    Among equals, it is the one that was seen first.    We replace any equivalent register with that one.     If two registers have the same quantity number, it must be true that    REG expressions with `qty_mode' must be in the hash table for both    registers and must be in the same class.     The converse is not true.  Since hard registers may be referenced in    any mode, two REG expressions might be equivalent in the hash table    but not have the same quantity number if the quantity number of one    of the registers is not the same mode as those expressions.     Constants and quantity numbers     When a quantity has a known constant value, that value is stored    in the appropriate element of qty_const.  This is in addition to    putting the constant in the hash table as is usual for non-regs.     Whether a reg or a constant is preferred is determined by the configuration    macro CONST_COSTS and will often depend on the constant value.  In any    event, expressions containing constants can be simplified, by fold_rtx.     When a quantity has a known nearly constant value (such as an address    of a stack slot), that value is stored in the appropriate element    of qty_const.     Integer constants don't have a machine mode.  However, cse    determines the intended machine mode from the destination    of the instruction that moves the constant.  The machine mode    is recorded in the hash table along with the actual RTL    constant expression so that different modes are kept separate.  Other expressions:     To record known equivalences among expressions in general    we use a hash table called `table'.  It has a fixed number of buckets    that contain chains of `struct table_elt' elements for expressions.    These chains connect the elements whose expressions have the same    hash codes.     Other chains through the same elements connect the elements which    currently have equivalent values.     Register references in an expression are canonicalized before hashing    the expression.  This is done using `reg_qty' and `qty_first_reg'.    The hash code of a register reference is computed using the quantity    number, not the register number.     When the value of an expression changes, it is necessary to remove from the    hash table not just that expression but all expressions whose values    could be different as a result.       1. If the value changing is in memory, except in special cases      ANYTHING referring to memory could be changed.  That is because      nobody knows where a pointer does not point.      The function `invalidate_memory' removes what is necessary.       The special cases are when the address is constant or is      a constant plus a fixed register such as the frame pointer      or a static chain pointer.  When such addresses are stored in,      we can tell exactly which other such addresses must be invalidated      due to overlap.  `invalidate' does this.      All expressions that refer to non-constant      memory addresses are also invalidated.  `invalidate_memory' does this.       2. If the value changing is a register, all expressions      containing references to that register, and only those,      must be removed.     Because searching the entire hash table for expressions that contain    a register is very slow, we try to figure out when it isn't necessary.    Precisely, this is necessary only when expressions have been    entered in the hash table using this register, and then the value has    changed, and then another expression wants to be added to refer to    the register's new value.  This sequence of circumstances is rare    within any one basic block.     The vectors `reg_tick' and `reg_in_table' are used to detect this case.    reg_tick[i] is incremented whenever a value is stored in register i.    reg_in_table[i] holds -1 if no references to register i have been    entered in the table; otherwise, it contains the value reg_tick[i] had    when the references were entered.  If we want to enter a reference    and reg_in_table[i] != reg_tick[i], we must scan and remove old references.    Until we want to enter a new entry, the mere fact that the two vectors    don't match makes the entries be ignored if anyone tries to match them.     Registers themselves are entered in the hash table as well as in    the equivalent-register chains.  However, the vectors `reg_tick'    and `reg_in_table' do not apply to expressions which are simple    register references.  These expressions are removed from the table    immediately when they become invalid, and this can be done even if    we do not immediately search for all the expressions that refer to    the register.     A CLOBBER rtx in an instruction invalidates its operand for further    reuse.  A CLOBBER or SET rtx whose operand is a MEM:BLK    invalidates everything that resides in memory.  Related expressions:     Constant expressions that differ only by an additive integer    are called related.  When a constant expression is put in    the table, the related expression with no constant term    is also entered.  These are made to point at each other    so that it is possible to find out if there exists any    register equivalent to an expression related to a given expression.  */
end_comment

begin_comment
comment|/* One plus largest register number used in this function.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_reg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* One plus largest instruction UID used in this function at time of    cse_main call.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_insn_uid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Length of vectors indexed by quantity number.    We know in advance we will not need a quantity number this big.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_qty
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Next quantity number to be allocated.    This is 1 + the largest number needed so far.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|next_qty
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by quantity number, gives the first (or last) register     in the chain of registers that currently contain this quantity.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|qty_first_reg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
modifier|*
name|qty_last_reg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index by quantity number, gives the mode of the quantity.  */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|machine_mode
modifier|*
name|qty_mode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by quantity number, gives the rtx of the constant value of the    quantity, or zero if it does not have a known value.    A sum of the frame pointer (or arg pointer) plus a constant    can also be entered here.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|qty_const
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by qty number, gives the insn that stored the constant value    recorded in `qty_const'.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|qty_const_insn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The next three variables are used to track when a comparison between a    quantity and some constant or register has been passed.  In that case, we    know the results of the comparison in case we see it again.  These variables    record a comparison that is known to be true.  */
end_comment

begin_comment
comment|/* Indexed by qty number, gives the rtx code of a comparison with a known    result involving this quantity.  If none, it is UNKNOWN.  */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|rtx_code
modifier|*
name|qty_comparison_code
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by qty number, gives the constant being compared against in a    comparison of known result.  If no such comparison, it is undefined.    If the comparison is not with a constant, it is zero.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|qty_comparison_const
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by qty number, gives the quantity being compared against in a    comparison of known result.  If no such comparison, if it undefined.    If the comparison is not with a register, it is -1.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|qty_comparison_qty
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_cc0
end_ifdef

begin_comment
comment|/* For machines that have a CC0, we do not record its value in the hash    table since its use is guaranteed to be the insn immediately following    its definition and any other insn is presumed to invalidate it.     Instead, we store below the value last assigned to CC0.  If it should    happen to be a constant, it is stored in preference to the actual    assigned value.  In case it is a constant, we store the mode in which    the constant should be interpreted.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|prev_insn_cc0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|machine_mode
name|prev_insn_cc0_mode
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Previous actual insn.  0 if at first insn of basic block.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|prev_insn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Insn being scanned.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|this_insn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index by register number, gives the number of the next (or    previous) register in the chain of registers sharing the same    value.     Or -1 if this register is at the end of the chain.     If reg_qty[N] == N, reg_next_eqv[N] is undefined.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|reg_next_eqv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
modifier|*
name|reg_prev_eqv
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|cse_reg_info
block|{
union|union
block|{
comment|/* The number of times the register has been altered in the current        basic block.  */
name|int
name|reg_tick
decl_stmt|;
comment|/* The next cse_reg_info structure in the free list.  */
name|struct
name|cse_reg_info
modifier|*
name|next
decl_stmt|;
block|}
name|variant
union|;
comment|/* The REG_TICK value at which rtx's containing this register are      valid in the hash table.  If this does not equal the current      reg_tick value, such expressions existing in the hash table are      invalid.  */
name|int
name|reg_in_table
decl_stmt|;
comment|/* The quantity number of the register's current contents.  */
name|int
name|reg_qty
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A free list of cse_reg_info entries.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cse_reg_info
modifier|*
name|cse_reg_info_free_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A mapping from registers to cse_reg_info data structures.  */
end_comment

begin_decl_stmt
specifier|static
name|splay_tree
name|cse_reg_info_tree
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The last lookup we did into the cse_reg_info_tree.  This allows us    to cache repeated lookups.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cached_regno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cse_reg_info
modifier|*
name|cached_cse_reg_info
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A HARD_REG_SET containing all the hard registers for which there is     currently a REG expression in the hash table.  Note the difference    from the above variables, which indicate if the REG is mentioned in some    expression in the table.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|hard_regs_in_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A HARD_REG_SET containing all the hard registers that are invalidated    by a CALL_INSN.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|regs_invalidated_by_call
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* CUID of insn that starts the basic block currently being cse-processed.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cse_basic_block_start
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* CUID of insn that ends the basic block currently being cse-processed.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cse_basic_block_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Vector mapping INSN_UIDs to cuids.    The cuids are like uids but increase monotonically always.    We use them to see whether a reg is used outside a given basic block.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|uid_cuid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Highest UID in UID_CUID.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_uid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Get the cuid of an insn.  */
end_comment

begin_define
define|#
directive|define
name|INSN_CUID
parameter_list|(
name|INSN
parameter_list|)
value|(uid_cuid[INSN_UID (INSN)])
end_define

begin_comment
comment|/* Nonzero if cse has altered conditional jump insns    in such a way that jump optimization should be redone.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cse_jumps_altered
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we put a LABEL_REF into the hash table.  Since we may have put    it into an INSN without a REG_LABEL, we have to rerun jump after CSE    to put in the note.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|recorded_label_ref
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* canon_hash stores 1 in do_not_record    if it notices a reference to CC0, PC, or some other volatile    subexpression.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|do_not_record
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|LOAD_EXTEND_OP
end_ifdef

begin_comment
comment|/* Scratch rtl used when looking for load-extended copy of a MEM.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|memory_extend_rtx
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* canon_hash stores 1 in hash_arg_in_memory    if it notices a reference to memory within the expression being hashed.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|hash_arg_in_memory
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* canon_hash stores 1 in hash_arg_in_struct    if it notices a reference to memory that's part of a structure.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|hash_arg_in_struct
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The hash table contains buckets which are chains of `struct table_elt's,    each recording one expression's information.    That expression is in the `exp' field.     Those elements with the same hash code are chained in both directions    through the `next_same_hash' and `prev_same_hash' fields.     Each set of expressions with equivalent values    are on a two-way chain through the `next_same_value'    and `prev_same_value' fields, and all point with    the `first_same_value' field at the first element in    that chain.  The chain is in order of increasing cost.    Each element's cost value is in its `cost' field.     The `in_memory' field is nonzero for elements that    involve any reference to memory.  These elements are removed    whenever a write is done to an unidentified location in memory.    To be safe, we assume that a memory address is unidentified unless    the address is either a symbol constant or a constant plus    the frame pointer or argument pointer.     The `in_struct' field is nonzero for elements that    involve any reference to memory inside a structure or array.     The `related_value' field is used to connect related expressions    (that differ by adding an integer).    The related expressions are chained in a circular fashion.    `related_value' is zero for expressions for which this    chain is not useful.     The `cost' field stores the cost of this element's expression.     The `is_const' flag is set if the element is a constant (including    a fixed address).     The `flag' field is used as a temporary during some search routines.     The `mode' field is usually the same as GET_MODE (`exp'), but    if `exp' is a CONST_INT and has no machine mode then the `mode'    field is the mode it was being used as.  Each constant is    recorded separately for each mode it is used with.  */
end_comment

begin_struct
struct|struct
name|table_elt
block|{
name|rtx
name|exp
decl_stmt|;
name|struct
name|table_elt
modifier|*
name|next_same_hash
decl_stmt|;
name|struct
name|table_elt
modifier|*
name|prev_same_hash
decl_stmt|;
name|struct
name|table_elt
modifier|*
name|next_same_value
decl_stmt|;
name|struct
name|table_elt
modifier|*
name|prev_same_value
decl_stmt|;
name|struct
name|table_elt
modifier|*
name|first_same_value
decl_stmt|;
name|struct
name|table_elt
modifier|*
name|related_value
decl_stmt|;
name|int
name|cost
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|char
name|in_memory
decl_stmt|;
name|char
name|in_struct
decl_stmt|;
name|char
name|is_const
decl_stmt|;
name|char
name|flag
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* We don't want a lot of buckets, because we rarely have very many    things stored in the hash table, and a lot of buckets slows    down a lot of loops that happen frequently.  */
end_comment

begin_define
define|#
directive|define
name|NBUCKETS
value|31
end_define

begin_comment
comment|/* Compute hash code of X in mode M.  Special-case case where X is a pseudo    register (hard registers may require `do_not_record' to be set).  */
end_comment

begin_define
define|#
directive|define
name|HASH
parameter_list|(
name|X
parameter_list|,
name|M
parameter_list|)
define|\
value|(GET_CODE (X) == REG&& REGNO (X)>= FIRST_PSEUDO_REGISTER	\   ? (((unsigned) REG<< 7) + (unsigned) REG_QTY (REGNO (X))) % NBUCKETS	\   : canon_hash (X, M) % NBUCKETS)
end_define

begin_comment
comment|/* Determine whether register number N is considered a fixed register for CSE.    It is desirable to replace other regs with fixed regs, to reduce need for    non-fixed hard regs.    A reg wins if it is either the frame pointer or designated as fixed,    but not if it is an overlapping register.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OVERLAPPING_REGNO_P
end_ifdef

begin_define
define|#
directive|define
name|FIXED_REGNO_P
parameter_list|(
name|N
parameter_list|)
define|\
value|(((N) == FRAME_POINTER_REGNUM || (N) == HARD_FRAME_POINTER_REGNUM \     || fixed_regs[N] || global_regs[N])	  \&& ! OVERLAPPING_REGNO_P ((N)))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|FIXED_REGNO_P
parameter_list|(
name|N
parameter_list|)
define|\
value|((N) == FRAME_POINTER_REGNUM || (N) == HARD_FRAME_POINTER_REGNUM \    || fixed_regs[N] || global_regs[N])
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Compute cost of X, as stored in the `cost' field of a table_elt.  Fixed    hard registers and pointers into the frame are the cheapest with a cost    of 0.  Next come pseudos with a cost of one and other hard registers with    a cost of 2.  Aside from these special cases, call `rtx_cost'.  */
end_comment

begin_define
define|#
directive|define
name|CHEAP_REGNO
parameter_list|(
name|N
parameter_list|)
define|\
value|((N) == FRAME_POINTER_REGNUM || (N) == HARD_FRAME_POINTER_REGNUM 	\    || (N) == STACK_POINTER_REGNUM || (N) == ARG_POINTER_REGNUM	     	\    || ((N)>= FIRST_VIRTUAL_REGISTER&& (N)<= LAST_VIRTUAL_REGISTER) 	\    || ((N)< FIRST_PSEUDO_REGISTER					\&& FIXED_REGNO_P (N)&& REGNO_REG_CLASS (N) != NO_REGS))
end_define

begin_comment
comment|/* A register is cheap if it is a user variable assigned to the register    or if its register number always corresponds to a cheap register.  */
end_comment

begin_define
define|#
directive|define
name|CHEAP_REG
parameter_list|(
name|N
parameter_list|)
define|\
value|((REG_USERVAR_P (N)&& REGNO (N)< FIRST_PSEUDO_REGISTER)	\    || CHEAP_REGNO (REGNO (N)))
end_define

begin_define
define|#
directive|define
name|COST
parameter_list|(
name|X
parameter_list|)
define|\
value|(GET_CODE (X) == REG							\    ? (CHEAP_REG (X) ? 0							\       : REGNO (X)>= FIRST_PSEUDO_REGISTER ? 1				\       : 2)								\    : notreg_cost(X))
end_define

begin_comment
comment|/* Get the info associated with register N.  */
end_comment

begin_define
define|#
directive|define
name|GET_CSE_REG_INFO
parameter_list|(
name|N
parameter_list|)
define|\
value|(((N) == cached_regno&& cached_cse_reg_info)	\    ? cached_cse_reg_info : get_cse_reg_info ((N)))
end_define

begin_comment
comment|/* Get the number of times this register has been updated in this    basic block.  */
end_comment

begin_define
define|#
directive|define
name|REG_TICK
parameter_list|(
name|N
parameter_list|)
value|((GET_CSE_REG_INFO (N))->variant.reg_tick)
end_define

begin_comment
comment|/* Get the point at which REG was recorded in the table.  */
end_comment

begin_define
define|#
directive|define
name|REG_IN_TABLE
parameter_list|(
name|N
parameter_list|)
value|((GET_CSE_REG_INFO (N))->reg_in_table)
end_define

begin_comment
comment|/* Get the quantity number for REG.  */
end_comment

begin_define
define|#
directive|define
name|REG_QTY
parameter_list|(
name|N
parameter_list|)
value|((GET_CSE_REG_INFO (N))->reg_qty)
end_define

begin_comment
comment|/* Determine if the quantity number for register X represents a valid index    into the `qty_...' variables.  */
end_comment

begin_define
define|#
directive|define
name|REGNO_QTY_VALID_P
parameter_list|(
name|N
parameter_list|)
value|(REG_QTY (N) != (N))
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|ADDRESS_COST
end_ifdef

begin_comment
comment|/* The ADDRESS_COST macro does not deal with ADDRESSOF nodes.  But,    during CSE, such nodes are present.  Using an ADDRESSOF node which    refers to the address of a REG is a good thing because we can then    turn (MEM (ADDRESSSOF (REG))) into just plain REG.  */
end_comment

begin_define
define|#
directive|define
name|CSE_ADDRESS_COST
parameter_list|(
name|RTX
parameter_list|)
define|\
value|((GET_CODE (RTX) == ADDRESSOF&& REG_P (XEXP ((RTX), 0)))	\    ? -1 : ADDRESS_COST(RTX))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|table_elt
modifier|*
name|table
index|[
name|NBUCKETS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain of `struct table_elt's made so far for this function    but currently removed from the table.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|table_elt
modifier|*
name|free_element_chain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of `struct table_elt' structures made so far for this function.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|n_elements_made
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maximum value `n_elements_made' has had so far in this compilation    for functions previously processed.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_elements_made
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Surviving equivalence class when two equivalence classes are merged     by recording the effects of a jump in the last insn.  Zero if the    last insn was not a conditional jump.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|table_elt
modifier|*
name|last_jump_equiv_class
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to the cost of a constant pool reference if one was found for a    symbolic constant.  If this was found, it means we should try to    convert constants into constant pool entries if they don't fit in    the insn.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|constant_pool_entries_cost
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define maximum length of a branch path.  */
end_comment

begin_define
define|#
directive|define
name|PATHLENGTH
value|10
end_define

begin_comment
comment|/* This data describes a block that will be processed by cse_basic_block.  */
end_comment

begin_struct
struct|struct
name|cse_basic_block_data
block|{
comment|/* Lowest CUID value of insns in block.  */
name|int
name|low_cuid
decl_stmt|;
comment|/* Highest CUID value of insns in block.  */
name|int
name|high_cuid
decl_stmt|;
comment|/* Total number of SETs in block.  */
name|int
name|nsets
decl_stmt|;
comment|/* Last insn in the block.  */
name|rtx
name|last
decl_stmt|;
comment|/* Size of current branch path, if any.  */
name|int
name|path_size
decl_stmt|;
comment|/* Current branch path, indicating which branches will be taken.  */
struct|struct
name|branch_path
block|{
comment|/* The branch insn.  */
name|rtx
name|branch
decl_stmt|;
comment|/* Whether it should be taken or not.  AROUND is the same as taken        except that it is used when the destination label is not preceded        by a BARRIER.  */
enum|enum
name|taken
block|{
name|TAKEN
block|,
name|NOT_TAKEN
block|,
name|AROUND
block|}
name|status
enum|;
block|}
name|path
index|[
name|PATHLENGTH
index|]
struct|;
block|}
struct|;
end_struct

begin_comment
comment|/* Nonzero if X has the form (PLUS frame-pointer integer).  We check for    virtual regs here because the simplify_*_operation routines are called    by integrate.c, which is called before virtual register instantiation.  */
end_comment

begin_define
define|#
directive|define
name|FIXED_BASE_PLUS_P
parameter_list|(
name|X
parameter_list|)
define|\
value|((X) == frame_pointer_rtx || (X) == hard_frame_pointer_rtx	\    || (X) == arg_pointer_rtx					\    || (X) == virtual_stack_vars_rtx				\    || (X) == virtual_incoming_args_rtx				\    || (GET_CODE (X) == PLUS&& GET_CODE (XEXP (X, 1)) == CONST_INT \&& (XEXP (X, 0) == frame_pointer_rtx			\ 	   || XEXP (X, 0) == hard_frame_pointer_rtx		\ 	   || XEXP (X, 0) == arg_pointer_rtx			\ 	   || XEXP (X, 0) == virtual_stack_vars_rtx		\ 	   || XEXP (X, 0) == virtual_incoming_args_rtx))	\    || GET_CODE (X) == ADDRESSOF)
end_define

begin_comment
comment|/* Similar, but also allows reference to the stack pointer.     This used to include FIXED_BASE_PLUS_P, however, we can't assume that    arg_pointer_rtx by itself is nonzero, because on at least one machine,    the i960, the arg pointer is zero when it is unused.  */
end_comment

begin_define
define|#
directive|define
name|NONZERO_BASE_PLUS_P
parameter_list|(
name|X
parameter_list|)
define|\
value|((X) == frame_pointer_rtx || (X) == hard_frame_pointer_rtx	\    || (X) == virtual_stack_vars_rtx				\    || (X) == virtual_incoming_args_rtx				\    || (GET_CODE (X) == PLUS&& GET_CODE (XEXP (X, 1)) == CONST_INT \&& (XEXP (X, 0) == frame_pointer_rtx			\ 	   || XEXP (X, 0) == hard_frame_pointer_rtx		\ 	   || XEXP (X, 0) == arg_pointer_rtx			\ 	   || XEXP (X, 0) == virtual_stack_vars_rtx		\ 	   || XEXP (X, 0) == virtual_incoming_args_rtx))	\    || (X) == stack_pointer_rtx					\    || (X) == virtual_stack_dynamic_rtx				\    || (X) == virtual_outgoing_args_rtx				\    || (GET_CODE (X) == PLUS&& GET_CODE (XEXP (X, 1)) == CONST_INT \&& (XEXP (X, 0) == stack_pointer_rtx			\ 	   || XEXP (X, 0) == virtual_stack_dynamic_rtx		\ 	   || XEXP (X, 0) == virtual_outgoing_args_rtx))	\    || GET_CODE (X) == ADDRESSOF)
end_define

begin_decl_stmt
specifier|static
name|int
name|notreg_cost
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|new_basic_block
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|make_new_qty
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|make_regs_eqv
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|delete_reg_equiv
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mention_regs
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|insert_regs
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
expr|struct
name|table_elt
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_element
name|PROTO
argument_list|(
operator|(
expr|struct
name|table_elt
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remove_from_table
name|PROTO
argument_list|(
operator|(
expr|struct
name|table_elt
operator|*
operator|,
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|table_elt
modifier|*
name|get_element
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|table_elt
modifier|*
name|lookup
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|unsigned
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|,
modifier|*
name|lookup_for_remove
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|unsigned
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|lookup_as_function
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
expr|enum
name|rtx_code
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|table_elt
modifier|*
name|insert
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
expr|struct
name|table_elt
operator|*
operator|,
name|unsigned
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|merge_equiv_classes
name|PROTO
argument_list|(
operator|(
expr|struct
name|table_elt
operator|*
operator|,
expr|struct
name|table_elt
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|invalidate
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cse_rtx_varies_p
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remove_invalid_refs
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remove_invalid_subreg_refs
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|rehash_using_reg
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|invalidate_memory
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|invalidate_for_call
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|use_related_value
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
expr|struct
name|table_elt
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|canon_hash
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|safe_hash
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|exp_equiv_p
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_nonvarying_address_components
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|,
name|rtx
operator|*
operator|,
name|HOST_WIDE_INT
operator|*
operator|,
name|HOST_WIDE_INT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|refers_to_p
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|canon_reg
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|find_best_addr
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|rtx_code
name|find_comparison_args
name|PROTO
argument_list|(
operator|(
expr|enum
name|rtx_code
operator|,
name|rtx
operator|*
operator|,
name|rtx
operator|*
operator|,
expr|enum
name|machine_mode
operator|*
operator|,
expr|enum
name|machine_mode
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|cse_gen_binary
name|PROTO
argument_list|(
operator|(
expr|enum
name|rtx_code
operator|,
expr|enum
name|machine_mode
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|simplify_plus_minus
name|PROTO
argument_list|(
operator|(
expr|enum
name|rtx_code
operator|,
expr|enum
name|machine_mode
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|fold_rtx
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|equiv_constant
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|record_jump_equiv
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|record_jump_cond
name|PROTO
argument_list|(
operator|(
expr|enum
name|rtx_code
operator|,
expr|enum
name|machine_mode
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cse_insn
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|note_mem_written
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|invalidate_from_clobbers
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|cse_process_notes
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cse_around_loop
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|invalidate_skipped_set
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|invalidate_skipped_block
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cse_check_loop_start
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cse_set_around_loop
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|cse_basic_block
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
expr|struct
name|branch_path
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|count_reg_usage
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|*
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|dump_class
name|PROTO
argument_list|(
operator|(
expr|struct
name|table_elt
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|check_fold_consts
name|PROTO
argument_list|(
operator|(
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cse_reg_info
modifier|*
name|get_cse_reg_info
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_cse_reg_info
name|PROTO
argument_list|(
operator|(
name|splay_tree_value
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|flush_hash_table
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|rtx_equal_function_value_matters
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Dump the expressions in the equivalence class indicated by CLASSP.    This function is used only for debugging.  */
end_comment

begin_function
name|void
name|dump_class
parameter_list|(
name|classp
parameter_list|)
name|struct
name|table_elt
modifier|*
name|classp
decl_stmt|;
block|{
name|struct
name|table_elt
modifier|*
name|elt
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Equivalence chain for "
argument_list|)
expr_stmt|;
name|print_rtl
argument_list|(
name|stderr
argument_list|,
name|classp
operator|->
name|exp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|": \n"
argument_list|)
expr_stmt|;
for|for
control|(
name|elt
operator|=
name|classp
operator|->
name|first_same_value
init|;
name|elt
condition|;
name|elt
operator|=
name|elt
operator|->
name|next_same_value
control|)
block|{
name|print_rtl
argument_list|(
name|stderr
argument_list|,
name|elt
operator|->
name|exp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return an estimate of the cost of computing rtx X.    One use is in cse, to decide which expression to keep in the hash table.    Another is in rtl generation, to pick the cheapest way to multiply.    Other uses like the latter are expected in the future.  */
end_comment

begin_comment
comment|/* Internal function, to compute cost when X is not a register; called    from COST macro to keep it simple.  */
end_comment

begin_function
specifier|static
name|int
name|notreg_cost
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
name|subreg_lowpart_p
argument_list|(
name|x
argument_list|)
operator|&&
name|TRULY_NOOP_TRUNCATION
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|?
operator|(
name|CHEAP_REG
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
condition|?
literal|0
else|:
operator|(
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|?
literal|1
else|:
literal|2
operator|)
operator|)
else|:
name|rtx_cost
argument_list|(
name|x
argument_list|,
name|SET
argument_list|)
operator|*
literal|2
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the right cost to give to an operation    to make the cost of the corresponding register-to-register instruction    N times that of a fast register-to-register instruction.  */
end_comment

begin_define
define|#
directive|define
name|COSTS_N_INSNS
parameter_list|(
name|N
parameter_list|)
value|((N) * 4 - 2)
end_define

begin_function
name|int
name|rtx_cost
parameter_list|(
name|x
parameter_list|,
name|outer_code
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|enum
name|rtx_code
name|outer_code
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
specifier|register
name|int
name|total
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Compute the default costs of certain things.      Note that RTX_COSTS can override the defaults.  */
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|MULT
case|:
comment|/* Count multiplication by 2**n as a shift, 	 because if we are considering it, we would output it as a shift.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
name|total
operator|=
literal|2
expr_stmt|;
else|else
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|5
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIV
case|:
case|case
name|UDIV
case|:
case|case
name|MOD
case|:
case|case
name|UMOD
case|:
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|7
argument_list|)
expr_stmt|;
break|break;
case|case
name|USE
case|:
comment|/* Used in loop.c and combine.c as a marker.  */
name|total
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ASM_OPERANDS
case|:
comment|/* We don't want these to be used in substitutions because 	 we have no way of validating the resulting insn.  So assign 	 anything containing an ASM_OPERANDS a very high cost.  */
name|total
operator|=
literal|1000
expr_stmt|;
break|break;
default|default:
name|total
operator|=
literal|2
expr_stmt|;
block|}
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
return|return
operator|!
name|CHEAP_REG
argument_list|(
name|x
argument_list|)
return|;
case|case
name|SUBREG
case|:
comment|/* If we can't tie these modes, make this expensive.  The larger 	 the mode, the more expensive it is.  */
if|if
condition|(
operator|!
name|MODES_TIEABLE_P
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|COSTS_N_INSNS
argument_list|(
literal|2
operator|+
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|/
name|UNITS_PER_WORD
argument_list|)
return|;
return|return
literal|2
return|;
ifdef|#
directive|ifdef
name|RTX_COSTS
name|RTX_COSTS
argument_list|(
name|x
argument_list|,
name|code
argument_list|,
name|outer_code
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CONST_COSTS
name|CONST_COSTS
argument_list|(
name|x
argument_list|,
name|code
argument_list|,
name|outer_code
argument_list|)
expr_stmt|;
endif|#
directive|endif
default|default:
ifdef|#
directive|ifdef
name|DEFAULT_RTX_COSTS
name|DEFAULT_RTX_COSTS
argument_list|(
name|x
argument_list|,
name|code
argument_list|,
name|outer_code
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
comment|/* Sum the costs of the sub-rtx's, plus cost of this operation,      which is already in total.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|total
operator|+=
name|rtx_cost
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|total
operator|+=
name|rtx_cost
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
return|return
name|total
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|struct
name|cse_reg_info
modifier|*
name|get_cse_reg_info
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|struct
name|cse_reg_info
modifier|*
name|cri
decl_stmt|;
name|splay_tree_node
name|n
decl_stmt|;
comment|/* See if we already have this entry.  */
name|n
operator|=
name|splay_tree_lookup
argument_list|(
name|cse_reg_info_tree
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
name|cri
operator|=
operator|(
expr|struct
name|cse_reg_info
operator|*
operator|)
operator|(
name|n
operator|->
name|value
operator|)
expr_stmt|;
else|else
block|{
comment|/* Get a new cse_reg_info structure.  */
if|if
condition|(
name|cse_reg_info_free_list
condition|)
block|{
name|cri
operator|=
name|cse_reg_info_free_list
expr_stmt|;
name|cse_reg_info_free_list
operator|=
name|cri
operator|->
name|variant
operator|.
name|next
expr_stmt|;
block|}
else|else
name|cri
operator|=
operator|(
expr|struct
name|cse_reg_info
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cse_reg_info
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize it.  */
name|cri
operator|->
name|variant
operator|.
name|reg_tick
operator|=
literal|0
expr_stmt|;
name|cri
operator|->
name|reg_in_table
operator|=
operator|-
literal|1
expr_stmt|;
name|cri
operator|->
name|reg_qty
operator|=
name|regno
expr_stmt|;
name|splay_tree_insert
argument_list|(
name|cse_reg_info_tree
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|regno
argument_list|,
operator|(
name|splay_tree_value
operator|)
name|cri
argument_list|)
expr_stmt|;
block|}
comment|/* Cache this lookup; we tend to be looking up information about the      same register several times in a row.  */
name|cached_regno
operator|=
name|regno
expr_stmt|;
name|cached_cse_reg_info
operator|=
name|cri
expr_stmt|;
return|return
name|cri
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_cse_reg_info
parameter_list|(
name|v
parameter_list|)
name|splay_tree_value
name|v
decl_stmt|;
block|{
name|struct
name|cse_reg_info
modifier|*
name|cri
init|=
operator|(
expr|struct
name|cse_reg_info
operator|*
operator|)
name|v
decl_stmt|;
name|cri
operator|->
name|variant
operator|.
name|next
operator|=
name|cse_reg_info_free_list
expr_stmt|;
name|cse_reg_info_free_list
operator|=
name|cri
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clear the hash table and initialize each register with its own quantity,    for a new basic block.  */
end_comment

begin_function
specifier|static
name|void
name|new_basic_block
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|next_qty
operator|=
name|max_reg
expr_stmt|;
if|if
condition|(
name|cse_reg_info_tree
condition|)
block|{
name|splay_tree_delete
argument_list|(
name|cse_reg_info_tree
argument_list|)
expr_stmt|;
name|cached_cse_reg_info
operator|=
literal|0
expr_stmt|;
block|}
name|cse_reg_info_tree
operator|=
name|splay_tree_new
argument_list|(
name|splay_tree_compare_ints
argument_list|,
literal|0
argument_list|,
name|free_cse_reg_info
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|hard_regs_in_table
argument_list|)
expr_stmt|;
comment|/* The per-quantity values used to be initialized here, but it is      much faster to initialize each as it is made in `make_new_qty'.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBUCKETS
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|struct
name|table_elt
modifier|*
name|this
decl_stmt|,
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|this
operator|=
name|table
index|[
name|i
index|]
init|;
name|this
condition|;
name|this
operator|=
name|next
control|)
block|{
name|next
operator|=
name|this
operator|->
name|next_same_hash
expr_stmt|;
name|free_element
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|table
argument_list|,
sizeof|sizeof
name|table
argument_list|)
expr_stmt|;
name|prev_insn
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
name|prev_insn_cc0
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Say that register REG contains a quantity not in any register before    and initialize that quantity.  */
end_comment

begin_function
specifier|static
name|void
name|make_new_qty
parameter_list|(
name|reg
parameter_list|)
specifier|register
name|int
name|reg
decl_stmt|;
block|{
specifier|register
name|int
name|q
decl_stmt|;
if|if
condition|(
name|next_qty
operator|>=
name|max_qty
condition|)
name|abort
argument_list|()
expr_stmt|;
name|q
operator|=
name|REG_QTY
argument_list|(
name|reg
argument_list|)
operator|=
name|next_qty
operator|++
expr_stmt|;
name|qty_first_reg
index|[
name|q
index|]
operator|=
name|reg
expr_stmt|;
name|qty_last_reg
index|[
name|q
index|]
operator|=
name|reg
expr_stmt|;
name|qty_const
index|[
name|q
index|]
operator|=
name|qty_const_insn
index|[
name|q
index|]
operator|=
literal|0
expr_stmt|;
name|qty_comparison_code
index|[
name|q
index|]
operator|=
name|UNKNOWN
expr_stmt|;
name|reg_next_eqv
index|[
name|reg
index|]
operator|=
name|reg_prev_eqv
index|[
name|reg
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make reg NEW equivalent to reg OLD.    OLD is not changing; NEW is.  */
end_comment

begin_function
specifier|static
name|void
name|make_regs_eqv
parameter_list|(
name|new
parameter_list|,
name|old
parameter_list|)
specifier|register
name|int
name|new
decl_stmt|,
name|old
decl_stmt|;
block|{
specifier|register
name|int
name|lastr
decl_stmt|,
name|firstr
decl_stmt|;
specifier|register
name|int
name|q
init|=
name|REG_QTY
argument_list|(
name|old
argument_list|)
decl_stmt|;
comment|/* Nothing should become eqv until it has a "non-invalid" qty number.  */
if|if
condition|(
operator|!
name|REGNO_QTY_VALID_P
argument_list|(
name|old
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|REG_QTY
argument_list|(
name|new
argument_list|)
operator|=
name|q
expr_stmt|;
name|firstr
operator|=
name|qty_first_reg
index|[
name|q
index|]
expr_stmt|;
name|lastr
operator|=
name|qty_last_reg
index|[
name|q
index|]
expr_stmt|;
comment|/* Prefer fixed hard registers to anything.  Prefer pseudo regs to other      hard regs.  Among pseudos, if NEW will live longer than any other reg      of the same qty, and that is beyond the current basic block,      make it the new canonical replacement for this qty.  */
if|if
condition|(
operator|!
operator|(
name|firstr
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|FIXED_REGNO_P
argument_list|(
name|firstr
argument_list|)
operator|)
comment|/* Certain fixed registers might be of the class NO_REGS.  This means 	 that not only can they not be allocated by the compiler, but 	 they cannot be used in substitutions or canonicalizations 	 either.  */
operator|&&
operator|(
name|new
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
name|REGNO_REG_CLASS
argument_list|(
name|new
argument_list|)
operator|!=
name|NO_REGS
operator|)
operator|&&
operator|(
operator|(
name|new
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|FIXED_REGNO_P
argument_list|(
name|new
argument_list|)
operator|)
operator|||
operator|(
name|new
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|(
name|firstr
operator|<
name|FIRST_PSEUDO_REGISTER
operator|||
operator|(
operator|(
name|uid_cuid
index|[
name|REGNO_LAST_UID
argument_list|(
name|new
argument_list|)
index|]
operator|>
name|cse_basic_block_end
operator|||
operator|(
name|uid_cuid
index|[
name|REGNO_FIRST_UID
argument_list|(
name|new
argument_list|)
index|]
operator|<
name|cse_basic_block_start
operator|)
operator|)
operator|&&
operator|(
name|uid_cuid
index|[
name|REGNO_LAST_UID
argument_list|(
name|new
argument_list|)
index|]
operator|>
name|uid_cuid
index|[
name|REGNO_LAST_UID
argument_list|(
name|firstr
argument_list|)
index|]
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
name|reg_prev_eqv
index|[
name|firstr
index|]
operator|=
name|new
expr_stmt|;
name|reg_next_eqv
index|[
name|new
index|]
operator|=
name|firstr
expr_stmt|;
name|reg_prev_eqv
index|[
name|new
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|qty_first_reg
index|[
name|q
index|]
operator|=
name|new
expr_stmt|;
block|}
else|else
block|{
comment|/* If NEW is a hard reg (known to be non-fixed), insert at end. 	 Otherwise, insert before any non-fixed hard regs that are at the 	 end.  Registers of class NO_REGS cannot be used as an 	 equivalent for anything.  */
while|while
condition|(
name|lastr
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_prev_eqv
index|[
name|lastr
index|]
operator|>=
literal|0
operator|&&
operator|(
name|REGNO_REG_CLASS
argument_list|(
name|lastr
argument_list|)
operator|==
name|NO_REGS
operator|||
operator|!
name|FIXED_REGNO_P
argument_list|(
name|lastr
argument_list|)
operator|)
operator|&&
name|new
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|lastr
operator|=
name|reg_prev_eqv
index|[
name|lastr
index|]
expr_stmt|;
name|reg_next_eqv
index|[
name|new
index|]
operator|=
name|reg_next_eqv
index|[
name|lastr
index|]
expr_stmt|;
if|if
condition|(
name|reg_next_eqv
index|[
name|lastr
index|]
operator|>=
literal|0
condition|)
name|reg_prev_eqv
index|[
name|reg_next_eqv
index|[
name|lastr
index|]
index|]
operator|=
name|new
expr_stmt|;
else|else
name|qty_last_reg
index|[
name|q
index|]
operator|=
name|new
expr_stmt|;
name|reg_next_eqv
index|[
name|lastr
index|]
operator|=
name|new
expr_stmt|;
name|reg_prev_eqv
index|[
name|new
index|]
operator|=
name|lastr
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Remove REG from its equivalence class.  */
end_comment

begin_function
specifier|static
name|void
name|delete_reg_equiv
parameter_list|(
name|reg
parameter_list|)
specifier|register
name|int
name|reg
decl_stmt|;
block|{
specifier|register
name|int
name|q
init|=
name|REG_QTY
argument_list|(
name|reg
argument_list|)
decl_stmt|;
specifier|register
name|int
name|p
decl_stmt|,
name|n
decl_stmt|;
comment|/* If invalid, do nothing.  */
if|if
condition|(
name|q
operator|==
name|reg
condition|)
return|return;
name|p
operator|=
name|reg_prev_eqv
index|[
name|reg
index|]
expr_stmt|;
name|n
operator|=
name|reg_next_eqv
index|[
name|reg
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|!=
operator|-
literal|1
condition|)
name|reg_prev_eqv
index|[
name|n
index|]
operator|=
name|p
expr_stmt|;
else|else
name|qty_last_reg
index|[
name|q
index|]
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|p
operator|!=
operator|-
literal|1
condition|)
name|reg_next_eqv
index|[
name|p
index|]
operator|=
name|n
expr_stmt|;
else|else
name|qty_first_reg
index|[
name|q
index|]
operator|=
name|n
expr_stmt|;
name|REG_QTY
argument_list|(
name|reg
argument_list|)
operator|=
name|reg
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove any invalid expressions from the hash table    that refer to any of the registers contained in expression X.     Make sure that newly inserted references to those registers    as subexpressions will be considered valid.     mention_regs is not called when a register itself    is being stored in the table.     Return 1 if we have done something that may have changed the hash code    of X.  */
end_comment

begin_function
specifier|static
name|int
name|mention_regs
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
specifier|register
name|int
name|changed
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|REG
condition|)
block|{
specifier|register
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
specifier|register
name|int
name|endregno
init|=
name|regno
operator|+
operator|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|?
literal|1
else|:
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|regno
init|;
name|i
operator|<
name|endregno
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|REG_IN_TABLE
argument_list|(
name|i
argument_list|)
operator|>=
literal|0
operator|&&
name|REG_IN_TABLE
argument_list|(
name|i
argument_list|)
operator|!=
name|REG_TICK
argument_list|(
name|i
argument_list|)
condition|)
name|remove_invalid_refs
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|REG_IN_TABLE
argument_list|(
name|i
argument_list|)
operator|=
name|REG_TICK
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
comment|/* If this is a SUBREG, we don't want to discard other SUBREGs of the same      pseudo if they don't use overlapping words.  We handle only pseudos      here for simplicity.  */
if|if
condition|(
name|code
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|i
init|=
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|REG_IN_TABLE
argument_list|(
name|i
argument_list|)
operator|>=
literal|0
operator|&&
name|REG_IN_TABLE
argument_list|(
name|i
argument_list|)
operator|!=
name|REG_TICK
argument_list|(
name|i
argument_list|)
condition|)
block|{
comment|/* If reg_tick has been incremented more than once since 	     reg_in_table was last set, that means that the entire 	     register has been set before, so discard anything memorized 	     for the entrire register, including all SUBREG expressions.  */
if|if
condition|(
name|REG_IN_TABLE
argument_list|(
name|i
argument_list|)
operator|!=
name|REG_TICK
argument_list|(
name|i
argument_list|)
operator|-
literal|1
condition|)
name|remove_invalid_refs
argument_list|(
name|i
argument_list|)
expr_stmt|;
else|else
name|remove_invalid_subreg_refs
argument_list|(
name|i
argument_list|,
name|SUBREG_WORD
argument_list|(
name|x
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|REG_IN_TABLE
argument_list|(
name|i
argument_list|)
operator|=
name|REG_TICK
argument_list|(
name|i
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* If X is a comparison or a COMPARE and either operand is a register      that does not have a quantity, give it one.  This is so that a later      call to record_jump_equiv won't cause X to be assigned a different      hash code and not found in the table after that call.       It is not necessary to do this here, since rehash_using_reg can      fix up the table later, but doing this here eliminates the need to      call that expensive function in the most common case where the only      use of the register is in the comparison.  */
if|if
condition|(
name|code
operator|==
name|COMPARE
operator|||
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'<'
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|!
name|REGNO_QTY_VALID_P
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
if|if
condition|(
name|insert_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_PTR
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|rehash_using_reg
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|!
name|REGNO_QTY_VALID_P
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
condition|)
if|if
condition|(
name|insert_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL_PTR
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|rehash_using_reg
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|changed
operator||=
name|mention_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|changed
operator||=
name|mention_regs
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|changed
return|;
block|}
end_function

begin_comment
comment|/* Update the register quantities for inserting X into the hash table    with a value equivalent to CLASSP.    (If the class does not contain a REG, it is irrelevant.)    If MODIFIED is nonzero, X is a destination; it is being modified.    Note that delete_reg_equiv should be called on a register    before insert_regs is done on that register with MODIFIED != 0.     Nonzero value means that elements of reg_qty have changed    so X's hash code may be different.  */
end_comment

begin_function
specifier|static
name|int
name|insert_regs
parameter_list|(
name|x
parameter_list|,
name|classp
parameter_list|,
name|modified
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|struct
name|table_elt
modifier|*
name|classp
decl_stmt|;
name|int
name|modified
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
block|{
specifier|register
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
comment|/* If REGNO is in the equivalence table already but is of the 	 wrong mode for that equivalence, don't do anything here.  */
if|if
condition|(
name|REGNO_QTY_VALID_P
argument_list|(
name|regno
argument_list|)
operator|&&
name|qty_mode
index|[
name|REG_QTY
argument_list|(
name|regno
argument_list|)
index|]
operator|!=
name|GET_MODE
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|modified
operator|||
operator|!
name|REGNO_QTY_VALID_P
argument_list|(
name|regno
argument_list|)
condition|)
block|{
if|if
condition|(
name|classp
condition|)
for|for
control|(
name|classp
operator|=
name|classp
operator|->
name|first_same_value
init|;
name|classp
operator|!=
literal|0
condition|;
name|classp
operator|=
name|classp
operator|->
name|next_same_value
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|classp
operator|->
name|exp
argument_list|)
operator|==
name|REG
operator|&&
name|GET_MODE
argument_list|(
name|classp
operator|->
name|exp
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|make_regs_eqv
argument_list|(
name|regno
argument_list|,
name|REGNO
argument_list|(
name|classp
operator|->
name|exp
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|make_new_qty
argument_list|(
name|regno
argument_list|)
expr_stmt|;
name|qty_mode
index|[
name|REG_QTY
argument_list|(
name|regno
argument_list|)
index|]
operator|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
comment|/* If X is a SUBREG, we will likely be inserting the inner register in the      table.  If that register doesn't have an assigned quantity number at      this point but does later, the insertion that we will be doing now will      not be accessible because its hash code will have changed.  So assign      a quantity number now.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|!
name|REGNO_QTY_VALID_P
argument_list|(
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
name|insert_regs
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
name|NULL_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Mention_regs checks if REG_TICK is exactly one larger than 	 REG_IN_TABLE to find out if there was only a single preceding 	 invalidation - for the SUBREG - or another one, which would be 	 for the full register.  Since we don't invalidate the SUBREG 	 here first, we might have to bump up REG_TICK so that mention_regs 	 will do the right thing.  */
if|if
condition|(
name|REG_IN_TABLE
argument_list|(
name|regno
argument_list|)
operator|>=
literal|0
operator|&&
name|REG_TICK
argument_list|(
name|regno
argument_list|)
operator|==
name|REG_IN_TABLE
argument_list|(
name|regno
argument_list|)
operator|+
literal|1
condition|)
name|REG_TICK
argument_list|(
name|regno
argument_list|)
operator|++
expr_stmt|;
name|mention_regs
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
name|mention_regs
argument_list|(
name|x
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Look in or update the hash table.  */
end_comment

begin_comment
comment|/* Put the element ELT on the list of free elements.  */
end_comment

begin_function
specifier|static
name|void
name|free_element
parameter_list|(
name|elt
parameter_list|)
name|struct
name|table_elt
modifier|*
name|elt
decl_stmt|;
block|{
name|elt
operator|->
name|next_same_hash
operator|=
name|free_element_chain
expr_stmt|;
name|free_element_chain
operator|=
name|elt
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return an element that is free for use.  */
end_comment

begin_function
specifier|static
name|struct
name|table_elt
modifier|*
name|get_element
parameter_list|()
block|{
name|struct
name|table_elt
modifier|*
name|elt
init|=
name|free_element_chain
decl_stmt|;
if|if
condition|(
name|elt
condition|)
block|{
name|free_element_chain
operator|=
name|elt
operator|->
name|next_same_hash
expr_stmt|;
return|return
name|elt
return|;
block|}
name|n_elements_made
operator|++
expr_stmt|;
return|return
operator|(
expr|struct
name|table_elt
operator|*
operator|)
name|oballoc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|table_elt
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Remove table element ELT from use in the table.    HASH is its hash code, made using the HASH macro.    It's an argument because often that is known in advance    and we save much time not recomputing it.  */
end_comment

begin_function
specifier|static
name|void
name|remove_from_table
parameter_list|(
name|elt
parameter_list|,
name|hash
parameter_list|)
specifier|register
name|struct
name|table_elt
modifier|*
name|elt
decl_stmt|;
name|unsigned
name|hash
decl_stmt|;
block|{
if|if
condition|(
name|elt
operator|==
literal|0
condition|)
return|return;
comment|/* Mark this element as removed.  See cse_insn.  */
name|elt
operator|->
name|first_same_value
operator|=
literal|0
expr_stmt|;
comment|/* Remove the table element from its equivalence class.  */
block|{
specifier|register
name|struct
name|table_elt
modifier|*
name|prev
init|=
name|elt
operator|->
name|prev_same_value
decl_stmt|;
specifier|register
name|struct
name|table_elt
modifier|*
name|next
init|=
name|elt
operator|->
name|next_same_value
decl_stmt|;
if|if
condition|(
name|next
condition|)
name|next
operator|->
name|prev_same_value
operator|=
name|prev
expr_stmt|;
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|next_same_value
operator|=
name|next
expr_stmt|;
else|else
block|{
specifier|register
name|struct
name|table_elt
modifier|*
name|newfirst
init|=
name|next
decl_stmt|;
while|while
condition|(
name|next
condition|)
block|{
name|next
operator|->
name|first_same_value
operator|=
name|newfirst
expr_stmt|;
name|next
operator|=
name|next
operator|->
name|next_same_value
expr_stmt|;
block|}
block|}
block|}
comment|/* Remove the table element from its hash bucket.  */
block|{
specifier|register
name|struct
name|table_elt
modifier|*
name|prev
init|=
name|elt
operator|->
name|prev_same_hash
decl_stmt|;
specifier|register
name|struct
name|table_elt
modifier|*
name|next
init|=
name|elt
operator|->
name|next_same_hash
decl_stmt|;
if|if
condition|(
name|next
condition|)
name|next
operator|->
name|prev_same_hash
operator|=
name|prev
expr_stmt|;
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|next_same_hash
operator|=
name|next
expr_stmt|;
elseif|else
if|if
condition|(
name|table
index|[
name|hash
index|]
operator|==
name|elt
condition|)
name|table
index|[
name|hash
index|]
operator|=
name|next
expr_stmt|;
else|else
block|{
comment|/* This entry is not in the proper hash bucket.  This can happen 	   when two classes were merged by `merge_equiv_classes'.  Search 	   for the hash bucket that it heads.  This happens only very 	   rarely, so the cost is acceptable.  */
for|for
control|(
name|hash
operator|=
literal|0
init|;
name|hash
operator|<
name|NBUCKETS
condition|;
name|hash
operator|++
control|)
if|if
condition|(
name|table
index|[
name|hash
index|]
operator|==
name|elt
condition|)
name|table
index|[
name|hash
index|]
operator|=
name|next
expr_stmt|;
block|}
block|}
comment|/* Remove the table element from its related-value circular chain.  */
if|if
condition|(
name|elt
operator|->
name|related_value
operator|!=
literal|0
operator|&&
name|elt
operator|->
name|related_value
operator|!=
name|elt
condition|)
block|{
specifier|register
name|struct
name|table_elt
modifier|*
name|p
init|=
name|elt
operator|->
name|related_value
decl_stmt|;
while|while
condition|(
name|p
operator|->
name|related_value
operator|!=
name|elt
condition|)
name|p
operator|=
name|p
operator|->
name|related_value
expr_stmt|;
name|p
operator|->
name|related_value
operator|=
name|elt
operator|->
name|related_value
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|related_value
operator|==
name|p
condition|)
name|p
operator|->
name|related_value
operator|=
literal|0
expr_stmt|;
block|}
name|free_element
argument_list|(
name|elt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Look up X in the hash table and return its table element,    or 0 if X is not in the table.     MODE is the machine-mode of X, or if X is an integer constant    with VOIDmode then MODE is the mode with which X will be used.     Here we are satisfied to find an expression whose tree structure    looks like X.  */
end_comment

begin_function
specifier|static
name|struct
name|table_elt
modifier|*
name|lookup
parameter_list|(
name|x
parameter_list|,
name|hash
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|unsigned
name|hash
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
specifier|register
name|struct
name|table_elt
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|table
index|[
name|hash
index|]
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next_same_hash
control|)
if|if
condition|(
name|mode
operator|==
name|p
operator|->
name|mode
operator|&&
operator|(
operator|(
name|x
operator|==
name|p
operator|->
name|exp
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|)
operator|||
name|exp_equiv_p
argument_list|(
name|x
argument_list|,
name|p
operator|->
name|exp
argument_list|,
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
return|return
name|p
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Like `lookup' but don't care whether the table element uses invalid regs.    Also ignore discrepancies in the machine mode of a register.  */
end_comment

begin_function
specifier|static
name|struct
name|table_elt
modifier|*
name|lookup_for_remove
parameter_list|(
name|x
parameter_list|,
name|hash
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|unsigned
name|hash
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
specifier|register
name|struct
name|table_elt
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
comment|/* Don't check the machine mode when comparing registers; 	 invalidating (REG:SI 0) also invalidates (REG:DF 0).  */
for|for
control|(
name|p
operator|=
name|table
index|[
name|hash
index|]
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next_same_hash
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
operator|->
name|exp
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|p
operator|->
name|exp
argument_list|)
operator|==
name|regno
condition|)
return|return
name|p
return|;
block|}
else|else
block|{
for|for
control|(
name|p
operator|=
name|table
index|[
name|hash
index|]
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next_same_hash
control|)
if|if
condition|(
name|mode
operator|==
name|p
operator|->
name|mode
operator|&&
operator|(
name|x
operator|==
name|p
operator|->
name|exp
operator|||
name|exp_equiv_p
argument_list|(
name|x
argument_list|,
name|p
operator|->
name|exp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
return|return
name|p
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Look for an expression equivalent to X and with code CODE.    If one is found, return that expression.  */
end_comment

begin_function
specifier|static
name|rtx
name|lookup_as_function
parameter_list|(
name|x
parameter_list|,
name|code
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
block|{
specifier|register
name|struct
name|table_elt
modifier|*
name|p
init|=
name|lookup
argument_list|(
name|x
argument_list|,
name|safe_hash
argument_list|(
name|x
argument_list|,
name|VOIDmode
argument_list|)
operator|%
name|NBUCKETS
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
comment|/* If we are looking for a CONST_INT, the mode doesn't really matter, as      long as we are narrowing.  So if we looked in vain for a mode narrower      than word_mode before, look for word_mode now.  */
if|if
condition|(
name|p
operator|==
literal|0
operator|&&
name|code
operator|==
name|CONST_INT
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|word_mode
argument_list|)
condition|)
block|{
name|x
operator|=
name|copy_rtx
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|x
argument_list|,
name|word_mode
argument_list|)
expr_stmt|;
name|p
operator|=
name|lookup
argument_list|(
name|x
argument_list|,
name|safe_hash
argument_list|(
name|x
argument_list|,
name|VOIDmode
argument_list|)
operator|%
name|NBUCKETS
argument_list|,
name|word_mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|==
literal|0
condition|)
return|return
literal|0
return|;
for|for
control|(
name|p
operator|=
name|p
operator|->
name|first_same_value
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next_same_value
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
operator|->
name|exp
argument_list|)
operator|==
name|code
comment|/* Make sure this is a valid entry in the table.  */
operator|&&
name|exp_equiv_p
argument_list|(
name|p
operator|->
name|exp
argument_list|,
name|p
operator|->
name|exp
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|p
operator|->
name|exp
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Insert X in the hash table, assuming HASH is its hash code    and CLASSP is an element of the class it should go in    (or 0 if a new class should be made).    It is inserted at the proper position to keep the class in    the order cheapest first.     MODE is the machine-mode of X, or if X is an integer constant    with VOIDmode then MODE is the mode with which X will be used.     For elements of equal cheapness, the most recent one    goes in front, except that the first element in the list    remains first unless a cheaper element is added.  The order of    pseudo-registers does not matter, as canon_reg will be called to    find the cheapest when a register is retrieved from the table.     The in_memory field in the hash table element is set to 0.    The caller must set it nonzero if appropriate.     You should call insert_regs (X, CLASSP, MODIFY) before calling here,    and if insert_regs returns a nonzero value    you must then recompute its hash code before calling here.     If necessary, update table showing constant values of quantities.  */
end_comment

begin_define
define|#
directive|define
name|CHEAPER
parameter_list|(
name|X
parameter_list|,
name|Y
parameter_list|)
value|((X)->cost< (Y)->cost)
end_define

begin_function
specifier|static
name|struct
name|table_elt
modifier|*
name|insert
parameter_list|(
name|x
parameter_list|,
name|classp
parameter_list|,
name|hash
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|x
decl_stmt|;
specifier|register
name|struct
name|table_elt
modifier|*
name|classp
decl_stmt|;
name|unsigned
name|hash
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
specifier|register
name|struct
name|table_elt
modifier|*
name|elt
decl_stmt|;
comment|/* If X is a register and we haven't made a quantity for it,      something is wrong.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
operator|!
name|REGNO_QTY_VALID_P
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If X is a hard register, show it is being put in the table.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|endregno
init|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|regno
init|;
name|i
operator|<
name|endregno
condition|;
name|i
operator|++
control|)
name|SET_HARD_REG_BIT
argument_list|(
name|hard_regs_in_table
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* If X is a label, show we recorded it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LABEL_REF
operator|||
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|)
condition|)
name|recorded_label_ref
operator|=
literal|1
expr_stmt|;
comment|/* Put an element for X into the right hash bucket.  */
name|elt
operator|=
name|get_element
argument_list|()
expr_stmt|;
name|elt
operator|->
name|exp
operator|=
name|x
expr_stmt|;
name|elt
operator|->
name|cost
operator|=
name|COST
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|elt
operator|->
name|next_same_value
operator|=
literal|0
expr_stmt|;
name|elt
operator|->
name|prev_same_value
operator|=
literal|0
expr_stmt|;
name|elt
operator|->
name|next_same_hash
operator|=
name|table
index|[
name|hash
index|]
expr_stmt|;
name|elt
operator|->
name|prev_same_hash
operator|=
literal|0
expr_stmt|;
name|elt
operator|->
name|related_value
operator|=
literal|0
expr_stmt|;
name|elt
operator|->
name|in_memory
operator|=
literal|0
expr_stmt|;
name|elt
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
name|elt
operator|->
name|is_const
operator|=
operator|(
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
comment|/* GNU C++ takes advantage of this for `this' 		      (and other const values).  */
operator|||
operator|(
name|RTX_UNCHANGING_P
argument_list|(
name|x
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|||
name|FIXED_BASE_PLUS_P
argument_list|(
name|x
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|table
index|[
name|hash
index|]
condition|)
name|table
index|[
name|hash
index|]
operator|->
name|prev_same_hash
operator|=
name|elt
expr_stmt|;
name|table
index|[
name|hash
index|]
operator|=
name|elt
expr_stmt|;
comment|/* Put it into the proper value-class.  */
if|if
condition|(
name|classp
condition|)
block|{
name|classp
operator|=
name|classp
operator|->
name|first_same_value
expr_stmt|;
if|if
condition|(
name|CHEAPER
argument_list|(
name|elt
argument_list|,
name|classp
argument_list|)
condition|)
comment|/* Insert at the head of the class */
block|{
specifier|register
name|struct
name|table_elt
modifier|*
name|p
decl_stmt|;
name|elt
operator|->
name|next_same_value
operator|=
name|classp
expr_stmt|;
name|classp
operator|->
name|prev_same_value
operator|=
name|elt
expr_stmt|;
name|elt
operator|->
name|first_same_value
operator|=
name|elt
expr_stmt|;
for|for
control|(
name|p
operator|=
name|classp
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next_same_value
control|)
name|p
operator|->
name|first_same_value
operator|=
name|elt
expr_stmt|;
block|}
else|else
block|{
comment|/* Insert not at head of the class.  */
comment|/* Put it after the last element cheaper than X.  */
specifier|register
name|struct
name|table_elt
modifier|*
name|p
decl_stmt|,
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|p
operator|=
name|classp
init|;
operator|(
name|next
operator|=
name|p
operator|->
name|next_same_value
operator|)
operator|&&
name|CHEAPER
argument_list|(
name|next
argument_list|,
name|elt
argument_list|)
condition|;
name|p
operator|=
name|next
control|)
empty_stmt|;
comment|/* Put it after P and before NEXT.  */
name|elt
operator|->
name|next_same_value
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|next
condition|)
name|next
operator|->
name|prev_same_value
operator|=
name|elt
expr_stmt|;
name|elt
operator|->
name|prev_same_value
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|next_same_value
operator|=
name|elt
expr_stmt|;
name|elt
operator|->
name|first_same_value
operator|=
name|classp
expr_stmt|;
block|}
block|}
else|else
name|elt
operator|->
name|first_same_value
operator|=
name|elt
expr_stmt|;
comment|/* If this is a constant being set equivalent to a register or a register      being set equivalent to a constant, note the constant equivalence.       If this is a constant, it cannot be equivalent to a different constant,      and a constant is the only thing that can be cheaper than a register.  So      we know the register is the head of the class (before the constant was      inserted).       If this is a register that is not already known equivalent to a      constant, we must check the entire class.       If this is a register that is already known equivalent to an insn,      update `qty_const_insn' to show that `this_insn' is the latest      insn making that quantity equivalent to the constant.  */
if|if
condition|(
name|elt
operator|->
name|is_const
operator|&&
name|classp
operator|&&
name|GET_CODE
argument_list|(
name|classp
operator|->
name|exp
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
condition|)
block|{
name|qty_const
index|[
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|classp
operator|->
name|exp
argument_list|)
argument_list|)
index|]
operator|=
name|gen_lowpart_if_possible
argument_list|(
name|qty_mode
index|[
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|classp
operator|->
name|exp
argument_list|)
argument_list|)
index|]
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|qty_const_insn
index|[
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|classp
operator|->
name|exp
argument_list|)
argument_list|)
index|]
operator|=
name|this_insn
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
name|classp
operator|&&
operator|!
name|qty_const
index|[
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
index|]
operator|&&
operator|!
name|elt
operator|->
name|is_const
condition|)
block|{
specifier|register
name|struct
name|table_elt
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|classp
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|p
operator|->
name|next_same_value
control|)
block|{
if|if
condition|(
name|p
operator|->
name|is_const
operator|&&
name|GET_CODE
argument_list|(
name|p
operator|->
name|exp
argument_list|)
operator|!=
name|REG
condition|)
block|{
name|qty_const
index|[
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
index|]
operator|=
name|gen_lowpart_if_possible
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|p
operator|->
name|exp
argument_list|)
expr_stmt|;
name|qty_const_insn
index|[
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
index|]
operator|=
name|this_insn
expr_stmt|;
break|break;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
name|qty_const
index|[
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
index|]
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|qty_mode
index|[
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
index|]
condition|)
name|qty_const_insn
index|[
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
index|]
operator|=
name|this_insn
expr_stmt|;
comment|/* If this is a constant with symbolic value,      and it has a term with an explicit integer value,      link it up with related expressions.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
condition|)
block|{
name|rtx
name|subexp
init|=
name|get_related_value
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|unsigned
name|subhash
decl_stmt|;
name|struct
name|table_elt
modifier|*
name|subelt
decl_stmt|,
modifier|*
name|subelt_prev
decl_stmt|;
if|if
condition|(
name|subexp
operator|!=
literal|0
condition|)
block|{
comment|/* Get the integer-free subexpression in the hash table.  */
name|subhash
operator|=
name|safe_hash
argument_list|(
name|subexp
argument_list|,
name|mode
argument_list|)
operator|%
name|NBUCKETS
expr_stmt|;
name|subelt
operator|=
name|lookup
argument_list|(
name|subexp
argument_list|,
name|subhash
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|subelt
operator|==
literal|0
condition|)
name|subelt
operator|=
name|insert
argument_list|(
name|subexp
argument_list|,
name|NULL_PTR
argument_list|,
name|subhash
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* Initialize SUBELT's circular chain if it has none.  */
if|if
condition|(
name|subelt
operator|->
name|related_value
operator|==
literal|0
condition|)
name|subelt
operator|->
name|related_value
operator|=
name|subelt
expr_stmt|;
comment|/* Find the element in the circular chain that precedes SUBELT.  */
name|subelt_prev
operator|=
name|subelt
expr_stmt|;
while|while
condition|(
name|subelt_prev
operator|->
name|related_value
operator|!=
name|subelt
condition|)
name|subelt_prev
operator|=
name|subelt_prev
operator|->
name|related_value
expr_stmt|;
comment|/* Put new ELT into SUBELT's circular chain just before SUBELT. 	     This way the element that follows SUBELT is the oldest one.  */
name|elt
operator|->
name|related_value
operator|=
name|subelt_prev
operator|->
name|related_value
expr_stmt|;
name|subelt_prev
operator|->
name|related_value
operator|=
name|elt
expr_stmt|;
block|}
block|}
return|return
name|elt
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given two equivalence classes, CLASS1 and CLASS2, put all the entries from    CLASS2 into CLASS1.  This is done when we have reached an insn which makes    the two classes equivalent.     CLASS1 will be the surviving class; CLASS2 should not be used after this    call.     Any invalid entries in CLASS2 will not be copied.  */
end_comment

begin_function
specifier|static
name|void
name|merge_equiv_classes
parameter_list|(
name|class1
parameter_list|,
name|class2
parameter_list|)
name|struct
name|table_elt
modifier|*
name|class1
decl_stmt|,
decl|*
name|class2
decl_stmt|;
end_function

begin_block
block|{
name|struct
name|table_elt
modifier|*
name|elt
decl_stmt|,
modifier|*
name|next
decl_stmt|,
modifier|*
name|new
decl_stmt|;
comment|/* Ensure we start with the head of the classes.  */
name|class1
operator|=
name|class1
operator|->
name|first_same_value
expr_stmt|;
name|class2
operator|=
name|class2
operator|->
name|first_same_value
expr_stmt|;
comment|/* If they were already equal, forget it.  */
if|if
condition|(
name|class1
operator|==
name|class2
condition|)
return|return;
for|for
control|(
name|elt
operator|=
name|class2
init|;
name|elt
condition|;
name|elt
operator|=
name|next
control|)
block|{
name|unsigned
name|hash
decl_stmt|;
name|rtx
name|exp
init|=
name|elt
operator|->
name|exp
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|elt
operator|->
name|mode
decl_stmt|;
name|next
operator|=
name|elt
operator|->
name|next_same_value
expr_stmt|;
comment|/* Remove old entry, make a new one in CLASS1's class. 	 Don't do this for invalid entries as we cannot find their 	 hash code (it also isn't necessary).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|REG
operator|||
name|exp_equiv_p
argument_list|(
name|exp
argument_list|,
name|exp
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|hash_arg_in_memory
operator|=
literal|0
expr_stmt|;
name|hash_arg_in_struct
operator|=
literal|0
expr_stmt|;
name|hash
operator|=
name|HASH
argument_list|(
name|exp
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|REG
condition|)
name|delete_reg_equiv
argument_list|(
name|REGNO
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
name|remove_from_table
argument_list|(
name|elt
argument_list|,
name|hash
argument_list|)
expr_stmt|;
if|if
condition|(
name|insert_regs
argument_list|(
name|exp
argument_list|,
name|class1
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|rehash_using_reg
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|hash
operator|=
name|HASH
argument_list|(
name|exp
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
name|new
operator|=
name|insert
argument_list|(
name|exp
argument_list|,
name|class1
argument_list|,
name|hash
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|new
operator|->
name|in_memory
operator|=
name|hash_arg_in_memory
expr_stmt|;
name|new
operator|->
name|in_struct
operator|=
name|hash_arg_in_struct
expr_stmt|;
block|}
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Flush the entire hash table.  */
end_comment

begin_function
specifier|static
name|void
name|flush_hash_table
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|struct
name|table_elt
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBUCKETS
condition|;
name|i
operator|++
control|)
for|for
control|(
name|p
operator|=
name|table
index|[
name|i
index|]
init|;
name|p
condition|;
name|p
operator|=
name|table
index|[
name|i
index|]
control|)
block|{
comment|/* Note that invalidate can remove elements 	   after P in the current hash chain.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
operator|->
name|exp
argument_list|)
operator|==
name|REG
condition|)
name|invalidate
argument_list|(
name|p
operator|->
name|exp
argument_list|,
name|p
operator|->
name|mode
argument_list|)
expr_stmt|;
else|else
name|remove_from_table
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Remove from the hash table, or mark as invalid,    all expressions whose values could be altered by storing in X.    X is a register, a subreg, or a memory reference with nonvarying address    (because, when a memory reference with a varying address is stored in,    all memory references are removed by invalidate_memory    so specific invalidation is superfluous).    FULL_MODE, if not VOIDmode, indicates that this much should be invalidated    instead of just the amount indicated by the mode of X.  This is only used    for bitfield stores into memory.     A nonvarying address may be just a register or just    a symbol reference, or it may be either of those plus    a numeric offset.  */
end_comment

begin_function
specifier|static
name|void
name|invalidate
parameter_list|(
name|x
parameter_list|,
name|full_mode
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|enum
name|machine_mode
name|full_mode
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|table_elt
modifier|*
name|p
decl_stmt|;
comment|/* If X is a register, dependencies on its contents      are recorded through the qty number mechanism.      Just change the qty number of the register,      mark it as invalid for expressions that refer to it,      and remove it itself.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
block|{
specifier|register
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
specifier|register
name|unsigned
name|hash
init|=
name|HASH
argument_list|(
name|x
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Remove REGNO from any quantity list it might be on and indicate 	 that its value might have changed.  If it is a pseudo, remove its 	 entry from the hash table.  	 For a hard register, we do the first two actions above for any 	 additional hard registers corresponding to X.  Then, if any of these 	 registers are in the table, we must remove any REG entries that 	 overlap these registers.  */
name|delete_reg_equiv
argument_list|(
name|regno
argument_list|)
expr_stmt|;
name|REG_TICK
argument_list|(
name|regno
argument_list|)
operator|++
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
comment|/* Because a register can be referenced in more than one mode, 	     we might have to remove more than one table entry.  */
name|struct
name|table_elt
modifier|*
name|elt
decl_stmt|;
while|while
condition|(
operator|(
name|elt
operator|=
name|lookup_for_remove
argument_list|(
name|x
argument_list|,
name|hash
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
condition|)
name|remove_from_table
argument_list|(
name|elt
argument_list|,
name|hash
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|HOST_WIDE_INT
name|in_table
init|=
name|TEST_HARD_REG_BIT
argument_list|(
name|hard_regs_in_table
argument_list|,
name|regno
argument_list|)
decl_stmt|;
name|int
name|endregno
init|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|tregno
decl_stmt|,
name|tendregno
decl_stmt|;
specifier|register
name|struct
name|table_elt
modifier|*
name|p
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|CLEAR_HARD_REG_BIT
argument_list|(
name|hard_regs_in_table
argument_list|,
name|regno
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|regno
operator|+
literal|1
init|;
name|i
operator|<
name|endregno
condition|;
name|i
operator|++
control|)
block|{
name|in_table
operator||=
name|TEST_HARD_REG_BIT
argument_list|(
name|hard_regs_in_table
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_BIT
argument_list|(
name|hard_regs_in_table
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|delete_reg_equiv
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|REG_TICK
argument_list|(
name|i
argument_list|)
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|in_table
condition|)
for|for
control|(
name|hash
operator|=
literal|0
init|;
name|hash
operator|<
name|NBUCKETS
condition|;
name|hash
operator|++
control|)
for|for
control|(
name|p
operator|=
name|table
index|[
name|hash
index|]
init|;
name|p
condition|;
name|p
operator|=
name|next
control|)
block|{
name|next
operator|=
name|p
operator|->
name|next_same_hash
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
operator|->
name|exp
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|p
operator|->
name|exp
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
continue|continue;
name|tregno
operator|=
name|REGNO
argument_list|(
name|p
operator|->
name|exp
argument_list|)
expr_stmt|;
name|tendregno
operator|=
name|tregno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|tregno
argument_list|,
name|GET_MODE
argument_list|(
name|p
operator|->
name|exp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tendregno
operator|>
name|regno
operator|&&
name|tregno
operator|<
name|endregno
condition|)
name|remove_from_table
argument_list|(
name|p
argument_list|,
name|hash
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
name|abort
argument_list|()
expr_stmt|;
name|invalidate
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If X is a parallel, invalidate all of its elements.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
name|invalidate
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If X is an expr_list, this is part of a disjoint return value;      extract the location in question ignoring the offset.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|EXPR_LIST
condition|)
block|{
name|invalidate
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* X is not a register; it must be a memory reference with      a nonvarying address.  Remove all hash table elements      that refer to overlapping pieces of memory.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|full_mode
operator|==
name|VOIDmode
condition|)
name|full_mode
operator|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBUCKETS
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|struct
name|table_elt
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|p
operator|=
name|table
index|[
name|i
index|]
init|;
name|p
condition|;
name|p
operator|=
name|next
control|)
block|{
name|next
operator|=
name|p
operator|->
name|next_same_hash
expr_stmt|;
comment|/* Invalidate ASM_OPERANDS which reference memory (this is easier 	     than checking all the aliases).  */
if|if
condition|(
name|p
operator|->
name|in_memory
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|p
operator|->
name|exp
argument_list|)
operator|!=
name|MEM
operator|||
name|true_dependence
argument_list|(
name|x
argument_list|,
name|full_mode
argument_list|,
name|p
operator|->
name|exp
argument_list|,
name|cse_rtx_varies_p
argument_list|)
operator|)
condition|)
name|remove_from_table
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Remove all expressions that refer to register REGNO,    since they are already invalid, and we are about to    mark that register valid again and don't want the old    expressions to reappear as valid.  */
end_comment

begin_function
specifier|static
name|void
name|remove_invalid_refs
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|table_elt
modifier|*
name|p
decl_stmt|,
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBUCKETS
condition|;
name|i
operator|++
control|)
for|for
control|(
name|p
operator|=
name|table
index|[
name|i
index|]
init|;
name|p
condition|;
name|p
operator|=
name|next
control|)
block|{
name|next
operator|=
name|p
operator|->
name|next_same_hash
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
operator|->
name|exp
argument_list|)
operator|!=
name|REG
operator|&&
name|refers_to_regno_p
argument_list|(
name|regno
argument_list|,
name|regno
operator|+
literal|1
argument_list|,
name|p
operator|->
name|exp
argument_list|,
name|NULL_PTR
argument_list|)
condition|)
name|remove_from_table
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Likewise for a subreg with subreg_reg WORD and mode MODE.  */
end_comment

begin_function
specifier|static
name|void
name|remove_invalid_subreg_refs
parameter_list|(
name|regno
parameter_list|,
name|word
parameter_list|,
name|mode
parameter_list|)
name|int
name|regno
decl_stmt|;
name|int
name|word
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|table_elt
modifier|*
name|p
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|int
name|end
init|=
name|word
operator|+
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBUCKETS
condition|;
name|i
operator|++
control|)
for|for
control|(
name|p
operator|=
name|table
index|[
name|i
index|]
init|;
name|p
condition|;
name|p
operator|=
name|next
control|)
block|{
name|rtx
name|exp
decl_stmt|;
name|next
operator|=
name|p
operator|->
name|next_same_hash
expr_stmt|;
name|exp
operator|=
name|p
operator|->
name|exp
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
operator|->
name|exp
argument_list|)
operator|!=
name|REG
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|!=
name|regno
operator|||
operator|(
operator|(
operator|(
name|SUBREG_WORD
argument_list|(
name|exp
argument_list|)
operator|+
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|>=
name|word
operator|)
operator|&&
name|SUBREG_WORD
argument_list|(
name|exp
argument_list|)
operator|<=
name|end
operator|)
operator|)
operator|&&
name|refers_to_regno_p
argument_list|(
name|regno
argument_list|,
name|regno
operator|+
literal|1
argument_list|,
name|p
operator|->
name|exp
argument_list|,
name|NULL_PTR
argument_list|)
condition|)
name|remove_from_table
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Recompute the hash codes of any valid entries in the hash table that    reference X, if X is a register, or SUBREG_REG (X) if X is a SUBREG.     This is called when we make a jump equivalence.  */
end_comment

begin_function
specifier|static
name|void
name|rehash_using_reg
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|table_elt
modifier|*
name|p
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|unsigned
name|hash
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
condition|)
name|x
operator|=
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* If X is not a register or if the register is known not to be in any      valid entries in the table, we have no work to do.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
operator|||
name|REG_IN_TABLE
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<
literal|0
operator|||
name|REG_IN_TABLE
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|REG_TICK
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
return|return;
comment|/* Scan all hash chains looking for valid entries that mention X.      If we find one and it is in the wrong hash chain, move it.  We can skip      objects that are registers, since they are handled specially.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBUCKETS
condition|;
name|i
operator|++
control|)
for|for
control|(
name|p
operator|=
name|table
index|[
name|i
index|]
init|;
name|p
condition|;
name|p
operator|=
name|next
control|)
block|{
name|next
operator|=
name|p
operator|->
name|next_same_hash
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
operator|->
name|exp
argument_list|)
operator|!=
name|REG
operator|&&
name|reg_mentioned_p
argument_list|(
name|x
argument_list|,
name|p
operator|->
name|exp
argument_list|)
operator|&&
name|exp_equiv_p
argument_list|(
name|p
operator|->
name|exp
argument_list|,
name|p
operator|->
name|exp
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
operator|&&
name|i
operator|!=
operator|(
name|hash
operator|=
name|safe_hash
argument_list|(
name|p
operator|->
name|exp
argument_list|,
name|p
operator|->
name|mode
argument_list|)
operator|%
name|NBUCKETS
operator|)
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|next_same_hash
condition|)
name|p
operator|->
name|next_same_hash
operator|->
name|prev_same_hash
operator|=
name|p
operator|->
name|prev_same_hash
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|prev_same_hash
condition|)
name|p
operator|->
name|prev_same_hash
operator|->
name|next_same_hash
operator|=
name|p
operator|->
name|next_same_hash
expr_stmt|;
else|else
name|table
index|[
name|i
index|]
operator|=
name|p
operator|->
name|next_same_hash
expr_stmt|;
name|p
operator|->
name|next_same_hash
operator|=
name|table
index|[
name|hash
index|]
expr_stmt|;
name|p
operator|->
name|prev_same_hash
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|table
index|[
name|hash
index|]
condition|)
name|table
index|[
name|hash
index|]
operator|->
name|prev_same_hash
operator|=
name|p
expr_stmt|;
name|table
index|[
name|hash
index|]
operator|=
name|p
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Remove from the hash table any expression that is a call-clobbered    register.  Also update their TICK values.  */
end_comment

begin_function
specifier|static
name|void
name|invalidate_for_call
parameter_list|()
block|{
name|int
name|regno
decl_stmt|,
name|endregno
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|hash
decl_stmt|;
name|struct
name|table_elt
modifier|*
name|p
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|int
name|in_table
init|=
literal|0
decl_stmt|;
comment|/* Go through all the hard registers.  For each that is clobbered in      a CALL_INSN, remove the register from quantity chains and update      reg_tick if defined.  Also see if any of these registers is currently      in the table.  */
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|regs_invalidated_by_call
argument_list|,
name|regno
argument_list|)
condition|)
block|{
name|delete_reg_equiv
argument_list|(
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_TICK
argument_list|(
name|regno
argument_list|)
operator|>=
literal|0
condition|)
name|REG_TICK
argument_list|(
name|regno
argument_list|)
operator|++
expr_stmt|;
name|in_table
operator||=
operator|(
name|TEST_HARD_REG_BIT
argument_list|(
name|hard_regs_in_table
argument_list|,
name|regno
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
comment|/* In the case where we have no call-clobbered hard registers in the      table, we are done.  Otherwise, scan the table and remove any      entry that overlaps a call-clobbered register.  */
if|if
condition|(
name|in_table
condition|)
for|for
control|(
name|hash
operator|=
literal|0
init|;
name|hash
operator|<
name|NBUCKETS
condition|;
name|hash
operator|++
control|)
for|for
control|(
name|p
operator|=
name|table
index|[
name|hash
index|]
init|;
name|p
condition|;
name|p
operator|=
name|next
control|)
block|{
name|next
operator|=
name|p
operator|->
name|next_same_hash
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|in_memory
condition|)
block|{
name|remove_from_table
argument_list|(
name|p
argument_list|,
name|hash
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
operator|->
name|exp
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|p
operator|->
name|exp
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
continue|continue;
name|regno
operator|=
name|REGNO
argument_list|(
name|p
operator|->
name|exp
argument_list|)
expr_stmt|;
name|endregno
operator|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|p
operator|->
name|exp
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|regno
init|;
name|i
operator|<
name|endregno
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|regs_invalidated_by_call
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|remove_from_table
argument_list|(
name|p
argument_list|,
name|hash
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given an expression X of type CONST,    and ELT which is its table entry (or 0 if it    is not in the hash table),    return an alternate expression for X as a register plus integer.    If none can be found, return 0.  */
end_comment

begin_function
specifier|static
name|rtx
name|use_related_value
parameter_list|(
name|x
parameter_list|,
name|elt
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|struct
name|table_elt
modifier|*
name|elt
decl_stmt|;
block|{
specifier|register
name|struct
name|table_elt
modifier|*
name|relt
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|table_elt
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|HOST_WIDE_INT
name|offset
decl_stmt|;
comment|/* First, is there anything related known?      If we have a table element, we can tell from that.      Otherwise, must look it up.  */
if|if
condition|(
name|elt
operator|!=
literal|0
operator|&&
name|elt
operator|->
name|related_value
operator|!=
literal|0
condition|)
name|relt
operator|=
name|elt
expr_stmt|;
elseif|else
if|if
condition|(
name|elt
operator|==
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
condition|)
block|{
name|rtx
name|subexp
init|=
name|get_related_value
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|subexp
operator|!=
literal|0
condition|)
name|relt
operator|=
name|lookup
argument_list|(
name|subexp
argument_list|,
name|safe_hash
argument_list|(
name|subexp
argument_list|,
name|GET_MODE
argument_list|(
name|subexp
argument_list|)
argument_list|)
operator|%
name|NBUCKETS
argument_list|,
name|GET_MODE
argument_list|(
name|subexp
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|relt
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Search all related table entries for one that has an      equivalent register.  */
name|p
operator|=
name|relt
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* This loop is strange in that it is executed in two different cases. 	 The first is when X is already in the table.  Then it is searching 	 the RELATED_VALUE list of X's class (RELT).  The second case is when 	 X is not in the table.  Then RELT points to a class for the related 	 value.  	 Ensure that, whatever case we are in, that we ignore classes that have 	 the same value as X.  */
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|x
argument_list|,
name|p
operator|->
name|exp
argument_list|)
condition|)
name|q
operator|=
literal|0
expr_stmt|;
else|else
for|for
control|(
name|q
operator|=
name|p
operator|->
name|first_same_value
init|;
name|q
condition|;
name|q
operator|=
name|q
operator|->
name|next_same_value
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|q
operator|->
name|exp
argument_list|)
operator|==
name|REG
condition|)
break|break;
if|if
condition|(
name|q
condition|)
break|break;
name|p
operator|=
name|p
operator|->
name|related_value
expr_stmt|;
comment|/* We went all the way around, so there is nothing to be found. 	 Alternatively, perhaps RELT was in the table for some other reason 	 and it has no related values recorded.  */
if|if
condition|(
name|p
operator|==
name|relt
operator|||
name|p
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|q
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|offset
operator|=
operator|(
name|get_integer_term
argument_list|(
name|x
argument_list|)
operator|-
name|get_integer_term
argument_list|(
name|p
operator|->
name|exp
argument_list|)
operator|)
expr_stmt|;
comment|/* Note: OFFSET may be 0 if P->xexp and X are related by commutativity.  */
return|return
name|plus_constant
argument_list|(
name|q
operator|->
name|exp
argument_list|,
name|offset
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Hash an rtx.  We are careful to make sure the value is never negative.    Equivalent registers hash identically.    MODE is used in hashing for CONST_INTs only;    otherwise the mode of X is used.     Store 1 in do_not_record if any subexpression is volatile.     Store 1 in hash_arg_in_memory if X contains a MEM rtx    which does not have the RTX_UNCHANGING_P bit set.    In this case, also store 1 in hash_arg_in_struct    if there is a MEM rtx which has the MEM_IN_STRUCT_P bit set.     Note that cse_insn knows that the hash code of a MEM expression    is just (int) MEM plus the hash code of the address.  */
end_comment

begin_function
specifier|static
name|unsigned
name|canon_hash
parameter_list|(
name|x
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|unsigned
name|hash
init|=
literal|0
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
comment|/* repeat is used to turn tail-recursion into iteration.  */
name|repeat
label|:
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
name|hash
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
block|{
specifier|register
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
comment|/* On some machines, we can't record any non-fixed hard register, 	   because extending its life will cause reload problems.  We 	   consider ap, fp, and sp to be fixed for this purpose.   	   We also consider CCmode registers to be fixed for this purpose; 	   failure to do so leads to failure to simplify 0<100 type of 	   conditionals.  	   On all machines, we can't record any global registers.  */
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|(
name|global_regs
index|[
name|regno
index|]
operator|||
operator|(
name|SMALL_REGISTER_CLASSES
operator|&&
operator|!
name|fixed_regs
index|[
name|regno
index|]
operator|&&
name|regno
operator|!=
name|FRAME_POINTER_REGNUM
operator|&&
name|regno
operator|!=
name|HARD_FRAME_POINTER_REGNUM
operator|&&
name|regno
operator|!=
name|ARG_POINTER_REGNUM
operator|&&
name|regno
operator|!=
name|STACK_POINTER_REGNUM
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|MODE_CC
operator|)
operator|)
condition|)
block|{
name|do_not_record
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
name|hash
operator|+=
operator|(
operator|(
name|unsigned
operator|)
name|REG
operator|<<
literal|7
operator|)
operator|+
operator|(
name|unsigned
operator|)
name|REG_QTY
argument_list|(
name|regno
argument_list|)
expr_stmt|;
return|return
name|hash
return|;
block|}
comment|/* We handle SUBREG of a REG specially because the underlying        reg changes its hash value with every value change; we don't        want to have to forget unrelated subregs when one subreg changes.  */
case|case
name|SUBREG
case|:
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|hash
operator|+=
operator|(
operator|(
operator|(
name|unsigned
operator|)
name|SUBREG
operator|<<
literal|7
operator|)
operator|+
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|+
name|SUBREG_WORD
argument_list|(
name|x
argument_list|)
operator|)
expr_stmt|;
return|return
name|hash
return|;
block|}
break|break;
block|}
case|case
name|CONST_INT
case|:
block|{
name|unsigned
name|HOST_WIDE_INT
name|tem
init|=
name|INTVAL
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|hash
operator|+=
operator|(
operator|(
name|unsigned
operator|)
name|CONST_INT
operator|<<
literal|7
operator|)
operator|+
operator|(
name|unsigned
operator|)
name|mode
operator|+
name|tem
expr_stmt|;
return|return
name|hash
return|;
block|}
case|case
name|CONST_DOUBLE
case|:
comment|/* This is like the general case, except that it only counts 	 the integers representing the constant.  */
name|hash
operator|+=
operator|(
name|unsigned
operator|)
name|code
operator|+
operator|(
name|unsigned
operator|)
name|GET_MODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|VOIDmode
condition|)
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|CONST_DOUBLE
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|tem
init|=
name|XINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|hash
operator|+=
name|tem
expr_stmt|;
block|}
else|else
name|hash
operator|+=
operator|(
operator|(
name|unsigned
operator|)
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
operator|+
operator|(
name|unsigned
operator|)
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
operator|)
expr_stmt|;
return|return
name|hash
return|;
comment|/* Assume there is only one rtx object for any given label.  */
case|case
name|LABEL_REF
case|:
name|hash
operator|+=
operator|(
operator|(
name|unsigned
operator|)
name|LABEL_REF
operator|<<
literal|7
operator|)
operator|+
operator|(
name|unsigned
name|long
operator|)
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|hash
return|;
case|case
name|SYMBOL_REF
case|:
name|hash
operator|+=
operator|(
operator|(
name|unsigned
operator|)
name|SYMBOL_REF
operator|<<
literal|7
operator|)
operator|+
operator|(
name|unsigned
name|long
operator|)
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|hash
return|;
case|case
name|MEM
case|:
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|do_not_record
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|RTX_UNCHANGING_P
argument_list|(
name|x
argument_list|)
operator|||
name|FIXED_BASE_PLUS_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|hash_arg_in_memory
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|MEM_IN_STRUCT_P
argument_list|(
name|x
argument_list|)
condition|)
name|hash_arg_in_struct
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Now that we have already found this special case, 	 might as well speed it up as much as possible.  */
name|hash
operator|+=
operator|(
name|unsigned
operator|)
name|MEM
expr_stmt|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|repeat
goto|;
case|case
name|PRE_DEC
case|:
case|case
name|PRE_INC
case|:
case|case
name|POST_DEC
case|:
case|case
name|POST_INC
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|CALL
case|:
case|case
name|UNSPEC_VOLATILE
case|:
name|do_not_record
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
case|case
name|ASM_OPERANDS
case|:
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|do_not_record
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
default|default:
break|break;
block|}
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
expr_stmt|;
name|hash
operator|+=
operator|(
name|unsigned
operator|)
name|code
operator|+
operator|(
name|unsigned
operator|)
name|GET_MODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
name|rtx
name|tem
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
decl_stmt|;
comment|/* If we are about to do the last recursive call 	     needed at this level, change it into iteration. 	     This function  is called enough to be worth it.  */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|x
operator|=
name|tem
expr_stmt|;
goto|goto
name|repeat
goto|;
block|}
name|hash
operator|+=
name|canon_hash
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|hash
operator|+=
name|canon_hash
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'s'
condition|)
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|p
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|XSTR
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
condition|)
while|while
condition|(
operator|*
name|p
condition|)
name|hash
operator|+=
operator|*
name|p
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'i'
condition|)
block|{
specifier|register
name|unsigned
name|tem
init|=
name|XINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|hash
operator|+=
name|tem
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'0'
condition|)
comment|/* unused */
empty_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|hash
return|;
block|}
end_function

begin_comment
comment|/* Like canon_hash but with no side effects.  */
end_comment

begin_function
specifier|static
name|unsigned
name|safe_hash
parameter_list|(
name|x
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|int
name|save_do_not_record
init|=
name|do_not_record
decl_stmt|;
name|int
name|save_hash_arg_in_memory
init|=
name|hash_arg_in_memory
decl_stmt|;
name|int
name|save_hash_arg_in_struct
init|=
name|hash_arg_in_struct
decl_stmt|;
name|unsigned
name|hash
init|=
name|canon_hash
argument_list|(
name|x
argument_list|,
name|mode
argument_list|)
decl_stmt|;
name|hash_arg_in_memory
operator|=
name|save_hash_arg_in_memory
expr_stmt|;
name|hash_arg_in_struct
operator|=
name|save_hash_arg_in_struct
expr_stmt|;
name|do_not_record
operator|=
name|save_do_not_record
expr_stmt|;
return|return
name|hash
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 iff X and Y would canonicalize into the same thing,    without actually constructing the canonicalization of either one.    If VALIDATE is nonzero,    we assume X is an expression being processed from the rtl    and Y was found in the hash table.  We check register refs    in Y for being marked as valid.     If EQUAL_VALUES is nonzero, we allow a register to match a constant value    that is known to be in the register.  Ordinarily, we don't allow them    to match, because letting them match would cause unpredictable results    in all the places that search a hash table chain for an equivalent    for a given value.  A possible equivalent that has different structure    has its hash code computed from different data.  Whether the hash code    is the same as that of the given value is pure luck.  */
end_comment

begin_function
specifier|static
name|int
name|exp_equiv_p
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|validate
parameter_list|,
name|equal_values
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
name|int
name|validate
decl_stmt|;
name|int
name|equal_values
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
comment|/* Note: it is incorrect to assume an expression is equivalent to itself      if VALIDATE is nonzero.  */
if|if
condition|(
name|x
operator|==
name|y
operator|&&
operator|!
name|validate
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|x
operator|==
literal|0
operator|||
name|y
operator|==
literal|0
condition|)
return|return
name|x
operator|==
name|y
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|GET_CODE
argument_list|(
name|y
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|equal_values
condition|)
return|return
literal|0
return|;
comment|/* If X is a constant and Y is a register or vice versa, they may be 	 equivalent.  We only have to validate if Y is a register.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO_QTY_VALID_P
argument_list|(
name|REGNO
argument_list|(
name|y
argument_list|)
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|y
argument_list|)
operator|==
name|qty_mode
index|[
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|y
argument_list|)
argument_list|)
index|]
operator|&&
name|rtx_equal_p
argument_list|(
name|x
argument_list|,
name|qty_const
index|[
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|y
argument_list|)
argument_list|)
index|]
argument_list|)
operator|&&
operator|(
operator|!
name|validate
operator|||
name|REG_IN_TABLE
argument_list|(
name|REGNO
argument_list|(
name|y
argument_list|)
argument_list|)
operator|==
name|REG_TICK
argument_list|(
name|REGNO
argument_list|(
name|y
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|y
argument_list|)
operator|&&
name|code
operator|==
name|REG
operator|&&
name|REGNO_QTY_VALID_P
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|qty_mode
index|[
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
index|]
operator|&&
name|rtx_equal_p
argument_list|(
name|y
argument_list|,
name|qty_const
index|[
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
index|]
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
comment|/* (MULT:SI x y) and (MULT:HI x y) are NOT equivalent.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PC
case|:
case|case
name|CC0
case|:
return|return
name|x
operator|==
name|y
return|;
case|case
name|CONST_INT
case|:
return|return
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|==
name|INTVAL
argument_list|(
name|y
argument_list|)
return|;
case|case
name|LABEL_REF
case|:
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|SYMBOL_REF
case|:
return|return
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|XSTR
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|REG
case|:
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|y
argument_list|)
decl_stmt|;
name|int
name|endregno
init|=
name|regno
operator|+
operator|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|?
literal|1
else|:
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|y
argument_list|)
argument_list|)
operator|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* If the quantities are not the same, the expressions are not 	   equivalent.  If there are and we are not to validate, they 	   are equivalent.  Otherwise, ensure all regs are up-to-date.  */
if|if
condition|(
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|REG_QTY
argument_list|(
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|validate
condition|)
return|return
literal|1
return|;
for|for
control|(
name|i
operator|=
name|regno
init|;
name|i
operator|<
name|endregno
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|REG_IN_TABLE
argument_list|(
name|i
argument_list|)
operator|!=
name|REG_TICK
argument_list|(
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
comment|/*  For commutative operations, check both orders.  */
case|case
name|PLUS
case|:
case|case
name|MULT
case|:
case|case
name|AND
case|:
case|case
name|IOR
case|:
case|case
name|XOR
case|:
case|case
name|NE
case|:
case|case
name|EQ
case|:
return|return
operator|(
operator|(
name|exp_equiv_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|,
name|validate
argument_list|,
name|equal_values
argument_list|)
operator|&&
name|exp_equiv_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|,
name|validate
argument_list|,
name|equal_values
argument_list|)
operator|)
operator|||
operator|(
name|exp_equiv_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|,
name|validate
argument_list|,
name|equal_values
argument_list|)
operator|&&
name|exp_equiv_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|,
name|validate
argument_list|,
name|equal_values
argument_list|)
operator|)
operator|)
return|;
default|default:
break|break;
block|}
comment|/* Compare the elements.  If any pair of corresponding elements      fail to match, return 0 for the whole things.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
switch|switch
condition|(
name|fmt
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'e'
case|:
if|if
condition|(
operator|!
name|exp_equiv_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
argument_list|,
name|validate
argument_list|,
name|equal_values
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'E'
case|:
if|if
condition|(
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XVECLEN
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|exp_equiv_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|XVECEXP
argument_list|(
name|y
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|validate
argument_list|,
name|equal_values
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|XSTR
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'i'
case|:
if|if
condition|(
name|XINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XINT
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'w'
case|:
if|if
condition|(
name|XWINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XWINT
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'0'
case|:
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 iff any subexpression of X matches Y.    Here we do not require that X or Y be valid (for registers referred to)    for being in the hash table.  */
end_comment

begin_function
specifier|static
name|int
name|refers_to_p
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
name|repeat
label|:
if|if
condition|(
name|x
operator|==
name|y
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|x
operator|==
literal|0
operator|||
name|y
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* If X as a whole has the same code as Y, they may match.      If so, return 1.  */
if|if
condition|(
name|code
operator|==
name|GET_CODE
argument_list|(
name|y
argument_list|)
condition|)
block|{
if|if
condition|(
name|exp_equiv_p
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
comment|/* X does not match, so try its subexpressions.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|repeat
goto|;
block|}
elseif|else
if|if
condition|(
name|refers_to_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|y
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|refers_to_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|y
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given ADDR and SIZE (a memory address, and the size of the memory reference),    set PBASE, PSTART, and PEND which correspond to the base of the address,    the starting offset, and ending offset respectively.     ADDR is known to be a nonvarying address.  */
end_comment

begin_comment
comment|/* ??? Despite what the comments say, this function is in fact frequently    passed varying addresses.  This does not appear to cause any problems.  */
end_comment

begin_function
specifier|static
name|void
name|set_nonvarying_address_components
parameter_list|(
name|addr
parameter_list|,
name|size
parameter_list|,
name|pbase
parameter_list|,
name|pstart
parameter_list|,
name|pend
parameter_list|)
name|rtx
name|addr
decl_stmt|;
name|int
name|size
decl_stmt|;
name|rtx
modifier|*
name|pbase
decl_stmt|;
name|HOST_WIDE_INT
modifier|*
name|pstart
decl_stmt|,
decl|*
name|pend
decl_stmt|;
end_function

begin_block
block|{
name|rtx
name|base
decl_stmt|;
name|HOST_WIDE_INT
name|start
decl_stmt|,
name|end
decl_stmt|;
name|base
operator|=
name|addr
expr_stmt|;
name|start
operator|=
literal|0
expr_stmt|;
name|end
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flag_pic
operator|&&
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
operator|==
name|pic_offset_table_rtx
condition|)
name|base
operator|=
name|XEXP
argument_list|(
name|base
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Registers with nonvarying addresses usually have constant equivalents;      but the frame pointer register is also possible.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|REG
operator|&&
name|qty_const
operator|!=
literal|0
operator|&&
name|REGNO_QTY_VALID_P
argument_list|(
name|REGNO
argument_list|(
name|base
argument_list|)
argument_list|)
operator|&&
name|qty_mode
index|[
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|base
argument_list|)
argument_list|)
index|]
operator|==
name|GET_MODE
argument_list|(
name|base
argument_list|)
operator|&&
name|qty_const
index|[
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|base
argument_list|)
argument_list|)
index|]
operator|!=
literal|0
condition|)
name|base
operator|=
name|qty_const
index|[
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|base
argument_list|)
argument_list|)
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|base
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|qty_const
operator|!=
literal|0
operator|&&
name|REGNO_QTY_VALID_P
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|(
name|qty_mode
index|[
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
index|]
operator|==
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|&&
name|qty_const
index|[
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
index|]
condition|)
block|{
name|start
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|base
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|base
operator|=
name|qty_const
index|[
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
index|]
expr_stmt|;
block|}
comment|/* This can happen as the result of virtual register instantiation,      if the initial offset is too large to be a valid address.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|base
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|qty_const
operator|!=
literal|0
operator|&&
name|REGNO_QTY_VALID_P
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|(
name|qty_mode
index|[
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
index|]
operator|==
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|&&
name|qty_const
index|[
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
index|]
operator|&&
name|REGNO_QTY_VALID_P
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|base
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|(
name|qty_mode
index|[
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|base
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
index|]
operator|==
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|base
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|&&
name|qty_const
index|[
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|base
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
index|]
condition|)
block|{
name|rtx
name|tem
init|=
name|qty_const
index|[
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|base
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
index|]
decl_stmt|;
name|base
operator|=
name|qty_const
index|[
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
index|]
expr_stmt|;
comment|/* One of the two values must be a constant.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|!=
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|abort
argument_list|()
expr_stmt|;
name|start
operator|=
name|INTVAL
argument_list|(
name|tem
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|start
operator|=
name|INTVAL
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|base
operator|=
name|tem
expr_stmt|;
block|}
block|}
comment|/* Handle everything that we can find inside an address that has been      viewed as constant.  */
while|while
condition|(
literal|1
condition|)
block|{
comment|/* If no part of this switch does a "continue", the code outside 	 will exit this loop.  */
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
condition|)
block|{
case|case
name|LO_SUM
case|:
comment|/* By definition, operand1 of a LO_SUM is the associated constant 	     address.  Use the associated constant address as the base 	     instead.  */
name|base
operator|=
name|XEXP
argument_list|(
name|base
argument_list|,
literal|1
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|CONST
case|:
comment|/* Strip off CONST.  */
name|base
operator|=
name|XEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|PLUS
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|base
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|start
operator|+=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|base
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|base
operator|=
name|XEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
name|AND
case|:
comment|/* Handle the case of an AND which is the negative of a power of 	     two.  This is used to represent unaligned memory operations.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|base
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|exact_log2
argument_list|(
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|base
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|>
literal|0
condition|)
block|{
name|set_nonvarying_address_components
argument_list|(
name|XEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
argument_list|,
name|size
argument_list|,
name|pbase
argument_list|,
name|pstart
argument_list|,
name|pend
argument_list|)
expr_stmt|;
comment|/* Assume the worst misalignment.  START is affected, but not 		 END, so compensate but adjusting SIZE.  Don't lose any 		 constant we already had.  */
name|size
operator|=
operator|*
name|pend
operator|-
operator|*
name|pstart
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|base
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|-
literal|1
expr_stmt|;
name|start
operator|+=
operator|*
name|pstart
operator|+
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|base
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|+
literal|1
expr_stmt|;
name|end
operator|+=
operator|*
name|pend
expr_stmt|;
name|base
operator|=
operator|*
name|pbase
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
break|break;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|start
operator|+=
name|INTVAL
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|base
operator|=
name|const0_rtx
expr_stmt|;
block|}
name|end
operator|=
name|start
operator|+
name|size
expr_stmt|;
comment|/* Set the return values.  */
operator|*
name|pbase
operator|=
name|base
expr_stmt|;
operator|*
name|pstart
operator|=
name|start
expr_stmt|;
operator|*
name|pend
operator|=
name|end
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Return 1 if X has a value that can vary even between two    executions of the program.  0 means X can be compared reliably    against certain constants or near-constants.  */
end_comment

begin_function
specifier|static
name|int
name|cse_rtx_varies_p
parameter_list|(
name|x
parameter_list|)
specifier|register
name|rtx
name|x
decl_stmt|;
block|{
comment|/* We need not check for X and the equivalence class being of the same      mode because if X is equivalent to a constant in some mode, it      doesn't vary in any mode.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO_QTY_VALID_P
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|qty_mode
index|[
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
index|]
operator|&&
name|qty_const
index|[
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
index|]
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO_QTY_VALID_P
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|qty_mode
index|[
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
index|]
operator|)
operator|&&
name|qty_const
index|[
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
index|]
condition|)
return|return
literal|0
return|;
comment|/* This can happen as the result of virtual register instantiation, if      the initial constant is too large to be a valid address.  This gives      us a three instruction sequence, load large offset into a register,      load fp minus a constant into a register, then a MEM which is the      sum of the two `constant' registers.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO_QTY_VALID_P
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|qty_mode
index|[
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
index|]
operator|)
operator|&&
name|qty_const
index|[
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
index|]
operator|&&
name|REGNO_QTY_VALID_P
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|qty_mode
index|[
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
index|]
operator|)
operator|&&
name|qty_const
index|[
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
index|]
condition|)
return|return
literal|0
return|;
return|return
name|rtx_varies_p
argument_list|(
name|x
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Canonicalize an expression:    replace each register reference inside it    with the "oldest" equivalent register.     If INSN is non-zero and we are replacing a pseudo with a hard register    or vice versa, validate_change is used to ensure that INSN remains valid    after we make our substitution.  The calls are made with IN_GROUP non-zero    so apply_change_group must be called upon the outermost return from this    function (unless INSN is zero).  The result of apply_change_group can    generally be discarded since the changes we are making are optional.  */
end_comment

begin_function
specifier|static
name|rtx
name|canon_reg
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
name|x
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|CONST
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
return|return
name|x
return|;
case|case
name|REG
case|:
block|{
specifier|register
name|int
name|first
decl_stmt|;
comment|/* Never replace a hard reg, because hard regs can appear 	   in more than one machine mode, and we must preserve the mode 	   of each occurrence.  Also, some hard regs appear in 	   MEMs that are shared and mustn't be altered.  Don't try to 	   replace any reg that maps to a reg of class NO_REGS.  */
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|||
operator|!
name|REGNO_QTY_VALID_P
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
return|return
name|x
return|;
name|first
operator|=
name|qty_first_reg
index|[
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
index|]
expr_stmt|;
return|return
operator|(
name|first
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|?
name|regno_reg_rtx
index|[
name|first
index|]
else|:
name|REGNO_REG_CLASS
argument_list|(
name|first
argument_list|)
operator|==
name|NO_REGS
condition|?
name|x
else|:
name|gen_rtx_REG
argument_list|(
name|qty_mode
index|[
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
index|]
argument_list|,
name|first
argument_list|)
operator|)
return|;
block|}
default|default:
break|break;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
name|rtx
name|new
init|=
name|canon_reg
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|)
decl_stmt|;
name|int
name|insn_code
decl_stmt|;
comment|/* If replacing pseudo with hard reg or vice versa, ensure the 	     insn remains valid.  Likewise if the insn has MATCH_DUPs.  */
if|if
condition|(
name|insn
operator|!=
literal|0
operator|&&
name|new
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|new
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
operator|(
operator|(
name|REGNO
argument_list|(
name|new
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
operator|!=
operator|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
operator|)
operator|||
operator|(
name|insn_code
operator|=
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|)
operator|<
literal|0
operator|||
name|insn_n_dups
index|[
name|insn_code
index|]
operator|>
literal|0
operator|)
condition|)
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|new
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|=
name|new
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|=
name|canon_reg
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* LOC is a location within INSN that is an operand address (the contents of    a MEM).  Find the best equivalent address to use that is valid for this    insn.     On most CISC machines, complicated address modes are costly, and rtx_cost    is a good approximation for that cost.  However, most RISC machines have    only a few (usually only one) memory reference formats.  If an address is    valid at all, it is often just as cheap as any other address.  Hence, for    RISC machines, we use the configuration macro `ADDRESS_COST' to compare the    costs of various addresses.  For two addresses of equal cost, choose the one    with the highest `rtx_cost' value as that has the potential of eliminating    the most insns.  For equal costs, we choose the first in the equivalence    class.  Note that we ignore the fact that pseudo registers are cheaper    than hard registers here because we would also prefer the pseudo registers.   */
end_comment

begin_function
specifier|static
name|void
name|find_best_addr
parameter_list|(
name|insn
parameter_list|,
name|loc
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
modifier|*
name|loc
decl_stmt|;
block|{
name|struct
name|table_elt
modifier|*
name|elt
decl_stmt|;
name|rtx
name|addr
init|=
operator|*
name|loc
decl_stmt|;
ifdef|#
directive|ifdef
name|ADDRESS_COST
name|struct
name|table_elt
modifier|*
name|p
decl_stmt|;
name|int
name|found_better
init|=
literal|1
decl_stmt|;
endif|#
directive|endif
name|int
name|save_do_not_record
init|=
name|do_not_record
decl_stmt|;
name|int
name|save_hash_arg_in_memory
init|=
name|hash_arg_in_memory
decl_stmt|;
name|int
name|save_hash_arg_in_struct
init|=
name|hash_arg_in_struct
decl_stmt|;
name|int
name|addr_volatile
decl_stmt|;
name|int
name|regno
decl_stmt|;
name|unsigned
name|hash
decl_stmt|;
comment|/* Do not try to replace constant addresses or addresses of local and      argument slots.  These MEM expressions are made only once and inserted      in many instructions, as well as being used to control symbol table      output.  It is not safe to clobber them.       There are some uncommon cases where the address is already in a register      for some reason, but we cannot take advantage of that because we have      no easy way to unshare the MEM.  In addition, looking up all stack      addresses is costly.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|regno
operator|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|,
name|regno
operator|==
name|FRAME_POINTER_REGNUM
operator|||
name|regno
operator|==
name|HARD_FRAME_POINTER_REGNUM
operator|||
name|regno
operator|==
name|ARG_POINTER_REGNUM
operator|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|regno
operator|=
name|REGNO
argument_list|(
name|addr
argument_list|)
operator|,
name|regno
operator|==
name|FRAME_POINTER_REGNUM
operator|||
name|regno
operator|==
name|HARD_FRAME_POINTER_REGNUM
operator|||
name|regno
operator|==
name|ARG_POINTER_REGNUM
operator|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|ADDRESSOF
operator|||
name|CONSTANT_ADDRESS_P
argument_list|(
name|addr
argument_list|)
condition|)
return|return;
comment|/* If this address is not simply a register, try to fold it.  This will      sometimes simplify the expression.  Many simplifications      will not be valid, but some, usually applying the associative rule, will      be valid and produce better code.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|!=
name|REG
condition|)
block|{
name|rtx
name|folded
init|=
name|fold_rtx
argument_list|(
name|copy_rtx
argument_list|(
name|addr
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
if|if
condition|(
literal|1
ifdef|#
directive|ifdef
name|ADDRESS_COST
operator|&&
operator|(
name|CSE_ADDRESS_COST
argument_list|(
name|folded
argument_list|)
operator|<
name|CSE_ADDRESS_COST
argument_list|(
name|addr
argument_list|)
operator|||
operator|(
name|CSE_ADDRESS_COST
argument_list|(
name|folded
argument_list|)
operator|==
name|CSE_ADDRESS_COST
argument_list|(
name|addr
argument_list|)
operator|&&
name|rtx_cost
argument_list|(
name|folded
argument_list|,
name|MEM
argument_list|)
operator|>
name|rtx_cost
argument_list|(
name|addr
argument_list|,
name|MEM
argument_list|)
operator|)
operator|)
else|#
directive|else
operator|&&
name|rtx_cost
argument_list|(
name|folded
argument_list|,
name|MEM
argument_list|)
operator|<
name|rtx_cost
argument_list|(
name|addr
argument_list|,
name|MEM
argument_list|)
endif|#
directive|endif
operator|&&
name|validate_change
argument_list|(
name|insn
argument_list|,
name|loc
argument_list|,
name|folded
argument_list|,
literal|0
argument_list|)
condition|)
name|addr
operator|=
name|folded
expr_stmt|;
block|}
comment|/* If this address is not in the hash table, we can't look for equivalences      of the whole address.  Also, ignore if volatile.  */
name|do_not_record
operator|=
literal|0
expr_stmt|;
name|hash
operator|=
name|HASH
argument_list|(
name|addr
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
name|addr_volatile
operator|=
name|do_not_record
expr_stmt|;
name|do_not_record
operator|=
name|save_do_not_record
expr_stmt|;
name|hash_arg_in_memory
operator|=
name|save_hash_arg_in_memory
expr_stmt|;
name|hash_arg_in_struct
operator|=
name|save_hash_arg_in_struct
expr_stmt|;
if|if
condition|(
name|addr_volatile
condition|)
return|return;
name|elt
operator|=
name|lookup
argument_list|(
name|addr
argument_list|,
name|hash
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ADDRESS_COST
if|if
condition|(
name|elt
condition|)
block|{
name|int
name|our_cost
init|=
name|elt
operator|->
name|cost
decl_stmt|;
comment|/* Find the lowest cost below ours that works.  */
for|for
control|(
name|elt
operator|=
name|elt
operator|->
name|first_same_value
init|;
name|elt
condition|;
name|elt
operator|=
name|elt
operator|->
name|next_same_value
control|)
if|if
condition|(
name|elt
operator|->
name|cost
operator|<
name|our_cost
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|elt
operator|->
name|exp
argument_list|)
operator|==
name|REG
operator|||
name|exp_equiv_p
argument_list|(
name|elt
operator|->
name|exp
argument_list|,
name|elt
operator|->
name|exp
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
operator|)
operator|&&
name|validate_change
argument_list|(
name|insn
argument_list|,
name|loc
argument_list|,
name|canon_reg
argument_list|(
name|copy_rtx
argument_list|(
name|elt
operator|->
name|exp
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return;
block|}
else|#
directive|else
if|if
condition|(
name|elt
condition|)
block|{
comment|/* We need to find the best (under the criteria documented above) entry 	 in the class that is valid.  We use the `flag' field to indicate 	 choices that were invalid and iterate until we can't find a better 	 one that hasn't already been tried.  */
for|for
control|(
name|p
operator|=
name|elt
operator|->
name|first_same_value
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next_same_value
control|)
name|p
operator|->
name|flag
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|found_better
condition|)
block|{
name|int
name|best_addr_cost
init|=
name|CSE_ADDRESS_COST
argument_list|(
operator|*
name|loc
argument_list|)
decl_stmt|;
name|int
name|best_rtx_cost
init|=
operator|(
name|elt
operator|->
name|cost
operator|+
literal|1
operator|)
operator|>>
literal|1
decl_stmt|;
name|struct
name|table_elt
modifier|*
name|best_elt
init|=
name|elt
decl_stmt|;
name|found_better
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|elt
operator|->
name|first_same_value
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next_same_value
control|)
if|if
condition|(
operator|!
name|p
operator|->
name|flag
condition|)
block|{
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|p
operator|->
name|exp
argument_list|)
operator|==
name|REG
operator|||
name|exp_equiv_p
argument_list|(
name|p
operator|->
name|exp
argument_list|,
name|p
operator|->
name|exp
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
operator|)
operator|&&
operator|(
name|CSE_ADDRESS_COST
argument_list|(
name|p
operator|->
name|exp
argument_list|)
operator|<
name|best_addr_cost
operator|||
operator|(
name|CSE_ADDRESS_COST
argument_list|(
name|p
operator|->
name|exp
argument_list|)
operator|==
name|best_addr_cost
operator|&&
operator|(
name|p
operator|->
name|cost
operator|+
literal|1
operator|)
operator|>>
literal|1
operator|>
name|best_rtx_cost
operator|)
operator|)
condition|)
block|{
name|found_better
operator|=
literal|1
expr_stmt|;
name|best_addr_cost
operator|=
name|CSE_ADDRESS_COST
argument_list|(
name|p
operator|->
name|exp
argument_list|)
expr_stmt|;
name|best_rtx_cost
operator|=
operator|(
name|p
operator|->
name|cost
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
name|best_elt
operator|=
name|p
expr_stmt|;
block|}
block|}
if|if
condition|(
name|found_better
condition|)
block|{
if|if
condition|(
name|validate_change
argument_list|(
name|insn
argument_list|,
name|loc
argument_list|,
name|canon_reg
argument_list|(
name|copy_rtx
argument_list|(
name|best_elt
operator|->
name|exp
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return;
else|else
name|best_elt
operator|->
name|flag
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* If the address is a binary operation with the first operand a register      and the second a constant, do the same as above, but looking for      equivalences of the register.  Then try to simplify before checking for      the best address to use.  This catches a few cases:  First is when we      have REG+const and the register is another REG+const.  We can often merge      the constants and eliminate one insn and one register.  It may also be      that a machine has a cheap REG+REG+const.  Finally, this improves the      code on the Alpha for unaligned byte stores.  */
if|if
condition|(
name|flag_expensive_optimizations
operator|&&
operator|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
operator|*
name|loc
argument_list|)
argument_list|)
operator|==
literal|'2'
operator|||
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
operator|*
name|loc
argument_list|)
argument_list|)
operator|==
literal|'c'
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
operator|*
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
operator|*
name|loc
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|rtx
name|c
init|=
name|XEXP
argument_list|(
operator|*
name|loc
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|do_not_record
operator|=
literal|0
expr_stmt|;
name|hash
operator|=
name|HASH
argument_list|(
name|XEXP
argument_list|(
operator|*
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
name|do_not_record
operator|=
name|save_do_not_record
expr_stmt|;
name|hash_arg_in_memory
operator|=
name|save_hash_arg_in_memory
expr_stmt|;
name|hash_arg_in_struct
operator|=
name|save_hash_arg_in_struct
expr_stmt|;
name|elt
operator|=
name|lookup
argument_list|(
name|XEXP
argument_list|(
operator|*
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|,
name|hash
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|elt
operator|==
literal|0
condition|)
return|return;
comment|/* We need to find the best (under the criteria documented above) entry 	 in the class that is valid.  We use the `flag' field to indicate 	 choices that were invalid and iterate until we can't find a better 	 one that hasn't already been tried.  */
for|for
control|(
name|p
operator|=
name|elt
operator|->
name|first_same_value
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next_same_value
control|)
name|p
operator|->
name|flag
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|found_better
condition|)
block|{
name|int
name|best_addr_cost
init|=
name|CSE_ADDRESS_COST
argument_list|(
operator|*
name|loc
argument_list|)
decl_stmt|;
name|int
name|best_rtx_cost
init|=
operator|(
name|COST
argument_list|(
operator|*
name|loc
argument_list|)
operator|+
literal|1
operator|)
operator|>>
literal|1
decl_stmt|;
name|struct
name|table_elt
modifier|*
name|best_elt
init|=
name|elt
decl_stmt|;
name|rtx
name|best_rtx
init|=
operator|*
name|loc
decl_stmt|;
name|int
name|count
decl_stmt|;
comment|/* This is at worst case an O(n^2) algorithm, so limit our search 	     to the first 32 elements on the list.  This avoids trouble 	     compiling code with very long basic blocks that can easily 	     call cse_gen_binary so many times that we run out of memory.  */
name|found_better
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|elt
operator|->
name|first_same_value
operator|,
name|count
operator|=
literal|0
init|;
name|p
operator|&&
name|count
operator|<
literal|32
condition|;
name|p
operator|=
name|p
operator|->
name|next_same_value
operator|,
name|count
operator|++
control|)
if|if
condition|(
operator|!
name|p
operator|->
name|flag
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|p
operator|->
name|exp
argument_list|)
operator|==
name|REG
operator|||
name|exp_equiv_p
argument_list|(
name|p
operator|->
name|exp
argument_list|,
name|p
operator|->
name|exp
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|new
init|=
name|cse_gen_binary
argument_list|(
name|GET_CODE
argument_list|(
operator|*
name|loc
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|p
operator|->
name|exp
argument_list|,
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|CSE_ADDRESS_COST
argument_list|(
name|new
argument_list|)
operator|<
name|best_addr_cost
operator|||
operator|(
name|CSE_ADDRESS_COST
argument_list|(
name|new
argument_list|)
operator|==
name|best_addr_cost
operator|&&
operator|(
name|COST
argument_list|(
name|new
argument_list|)
operator|+
literal|1
operator|)
operator|>>
literal|1
operator|>
name|best_rtx_cost
operator|)
operator|)
condition|)
block|{
name|found_better
operator|=
literal|1
expr_stmt|;
name|best_addr_cost
operator|=
name|CSE_ADDRESS_COST
argument_list|(
name|new
argument_list|)
expr_stmt|;
name|best_rtx_cost
operator|=
operator|(
name|COST
argument_list|(
name|new
argument_list|)
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
name|best_elt
operator|=
name|p
expr_stmt|;
name|best_rtx
operator|=
name|new
expr_stmt|;
block|}
block|}
if|if
condition|(
name|found_better
condition|)
block|{
if|if
condition|(
name|validate_change
argument_list|(
name|insn
argument_list|,
name|loc
argument_list|,
name|canon_reg
argument_list|(
name|copy_rtx
argument_list|(
name|best_rtx
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return;
else|else
name|best_elt
operator|->
name|flag
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given an operation (CODE, *PARG1, *PARG2), where code is a comparison    operation (EQ, NE, GT, etc.), follow it back through the hash table and    what values are being compared.     *PARG1 and *PARG2 are updated to contain the rtx representing the values    actually being compared.  For example, if *PARG1 was (cc0) and *PARG2    was (const_int 0), *PARG1 and *PARG2 will be set to the objects that were    compared to produce cc0.     The return value is the comparison operator and is either the code of    A or the code corresponding to the inverse of the comparison.  */
end_comment

begin_function
specifier|static
name|enum
name|rtx_code
name|find_comparison_args
parameter_list|(
name|code
parameter_list|,
name|parg1
parameter_list|,
name|parg2
parameter_list|,
name|pmode1
parameter_list|,
name|pmode2
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
name|rtx
modifier|*
name|parg1
decl_stmt|,
decl|*
name|parg2
decl_stmt|;
end_function

begin_decl_stmt
name|enum
name|machine_mode
modifier|*
name|pmode1
decl_stmt|,
modifier|*
name|pmode2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|rtx
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
name|arg1
operator|=
operator|*
name|parg1
operator|,
name|arg2
operator|=
operator|*
name|parg2
expr_stmt|;
comment|/* If ARG2 is const0_rtx, see what ARG1 is equivalent to.  */
while|while
condition|(
name|arg2
operator|==
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Set non-zero when we find something of interest.  */
name|rtx
name|x
init|=
literal|0
decl_stmt|;
name|int
name|reverse_code
init|=
literal|0
decl_stmt|;
name|struct
name|table_elt
modifier|*
name|p
init|=
literal|0
decl_stmt|;
comment|/* If arg1 is a COMPARE, extract the comparison arguments from it. 	 On machines with CC0, this is the only case that can occur, since 	 fold_rtx will return the COMPARE or item being compared with zero 	 when given CC0.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|COMPARE
operator|&&
name|arg2
operator|==
name|const0_rtx
condition|)
name|x
operator|=
name|arg1
expr_stmt|;
comment|/* If ARG1 is a comparison operator and CODE is testing for 	 STORE_FLAG_VALUE, get the inner arguments.  */
elseif|else
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
literal|'<'
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|NE
operator|||
operator|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|code
operator|==
name|LT
operator|&&
name|STORE_FLAG_VALUE
operator|==
operator|-
literal|1
operator|)
ifdef|#
directive|ifdef
name|FLOAT_STORE_FLAG_VALUE
operator|||
operator|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|FLOAT_STORE_FLAG_VALUE
operator|<
literal|0
operator|)
endif|#
directive|endif
condition|)
name|x
operator|=
name|arg1
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|EQ
operator|||
operator|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|code
operator|==
name|GE
operator|&&
name|STORE_FLAG_VALUE
operator|==
operator|-
literal|1
operator|)
ifdef|#
directive|ifdef
name|FLOAT_STORE_FLAG_VALUE
operator|||
operator|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|FLOAT_STORE_FLAG_VALUE
operator|<
literal|0
operator|)
endif|#
directive|endif
condition|)
name|x
operator|=
name|arg1
operator|,
name|reverse_code
operator|=
literal|1
expr_stmt|;
block|}
comment|/* ??? We could also check for  	 (ne (and (eq (...) (const_int 1))) (const_int 0))  	 and related forms, but let's wait until we see them occurring.  */
if|if
condition|(
name|x
operator|==
literal|0
condition|)
comment|/* Look up ARG1 in the hash table and see if it has an equivalence 	   that lets us see what is being compared.  */
name|p
operator|=
name|lookup
argument_list|(
name|arg1
argument_list|,
name|safe_hash
argument_list|(
name|arg1
argument_list|,
name|GET_MODE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|%
name|NBUCKETS
argument_list|,
name|GET_MODE
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|p
operator|=
name|p
operator|->
name|first_same_value
expr_stmt|;
for|for
control|(
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next_same_value
control|)
block|{
name|enum
name|machine_mode
name|inner_mode
init|=
name|GET_MODE
argument_list|(
name|p
operator|->
name|exp
argument_list|)
decl_stmt|;
comment|/* If the entry isn't valid, skip it.  */
if|if
condition|(
operator|!
name|exp_equiv_p
argument_list|(
name|p
operator|->
name|exp
argument_list|,
name|p
operator|->
name|exp
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
operator|->
name|exp
argument_list|)
operator|==
name|COMPARE
comment|/* Another possibility is that this machine has a compare insn 		 that includes the comparison code.  In that case, ARG1 would 		 be equivalent to a comparison operation that would set ARG1 to 		 either STORE_FLAG_VALUE or zero.  If this is an NE operation, 		 ORIG_CODE is the actual comparison being done; if it is an EQ, 		 we must reverse ORIG_CODE.  On machine with a negative value 		 for STORE_FLAG_VALUE, also look at LT and GE operations.  */
operator|||
operator|(
operator|(
name|code
operator|==
name|NE
operator|||
operator|(
name|code
operator|==
name|LT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|inner_mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|inner_mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|&&
operator|(
name|STORE_FLAG_VALUE
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|inner_mode
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|)
operator|)
ifdef|#
directive|ifdef
name|FLOAT_STORE_FLAG_VALUE
operator|||
operator|(
name|code
operator|==
name|LT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|inner_mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|FLOAT_STORE_FLAG_VALUE
operator|<
literal|0
operator|)
endif|#
directive|endif
operator|)
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|p
operator|->
name|exp
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|)
condition|)
block|{
name|x
operator|=
name|p
operator|->
name|exp
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
name|code
operator|==
name|EQ
operator|||
operator|(
name|code
operator|==
name|GE
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|inner_mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|inner_mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|&&
operator|(
name|STORE_FLAG_VALUE
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|inner_mode
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|)
operator|)
ifdef|#
directive|ifdef
name|FLOAT_STORE_FLAG_VALUE
operator|||
operator|(
name|code
operator|==
name|GE
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|inner_mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|FLOAT_STORE_FLAG_VALUE
operator|<
literal|0
operator|)
endif|#
directive|endif
operator|)
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|p
operator|->
name|exp
argument_list|)
argument_list|)
operator|==
literal|'<'
condition|)
block|{
name|reverse_code
operator|=
literal|1
expr_stmt|;
name|x
operator|=
name|p
operator|->
name|exp
expr_stmt|;
break|break;
block|}
comment|/* If this is fp + constant, the equivalent is a better operand since 	     it may let us predict the value of the comparison.  */
elseif|else
if|if
condition|(
name|NONZERO_BASE_PLUS_P
argument_list|(
name|p
operator|->
name|exp
argument_list|)
condition|)
block|{
name|arg1
operator|=
name|p
operator|->
name|exp
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* If we didn't find a useful equivalence for ARG1, we are done. 	 Otherwise, set up for the next iteration.  */
if|if
condition|(
name|x
operator|==
literal|0
condition|)
break|break;
name|arg1
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|,
name|arg2
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
literal|'<'
condition|)
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|reverse_code
condition|)
name|code
operator|=
name|reverse_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
comment|/* Return our results.  Return the modes from before fold_rtx      because fold_rtx might produce const_int, and then it's too late.  */
operator|*
name|pmode1
operator|=
name|GET_MODE
argument_list|(
name|arg1
argument_list|)
operator|,
operator|*
name|pmode2
operator|=
name|GET_MODE
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
operator|*
name|parg1
operator|=
name|fold_rtx
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
operator|,
operator|*
name|parg2
operator|=
name|fold_rtx
argument_list|(
name|arg2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|code
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Try to simplify a unary operation CODE whose output mode is to be    MODE with input operand OP whose mode was originally OP_MODE.    Return zero if no simplification can be made.  */
end_comment

begin_function
name|rtx
name|simplify_unary_operation
parameter_list|(
name|code
parameter_list|,
name|mode
parameter_list|,
name|op
parameter_list|,
name|op_mode
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|op_mode
decl_stmt|;
block|{
specifier|register
name|int
name|width
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
comment|/* The order of these tests is critical so that, for example, we don't      check the wrong mode (input vs. output) for a conversion operation,      such as FIX.  At some point, this should be simplified.  */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|REAL_IS_NOT_DOUBLE
argument_list|)
operator|||
name|defined
argument_list|(
name|REAL_ARITHMETIC
argument_list|)
if|if
condition|(
name|code
operator|==
name|FLOAT
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|)
condition|)
block|{
name|HOST_WIDE_INT
name|hv
decl_stmt|,
name|lv
decl_stmt|;
name|REAL_VALUE_TYPE
name|d
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
name|lv
operator|=
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|,
name|hv
operator|=
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
literal|0
expr_stmt|;
else|else
name|lv
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
operator|,
name|hv
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|REAL_ARITHMETIC
name|REAL_VALUE_FROM_INT
argument_list|(
name|d
argument_list|,
name|lv
argument_list|,
name|hv
argument_list|,
name|mode
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|hv
operator|<
literal|0
condition|)
block|{
name|d
operator|=
call|(
name|double
call|)
argument_list|(
operator|~
name|hv
argument_list|)
expr_stmt|;
name|d
operator|*=
operator|(
call|(
name|double
call|)
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|/
literal|2
operator|)
argument_list|)
operator|*
call|(
name|double
call|)
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|/
literal|2
operator|)
argument_list|)
operator|)
expr_stmt|;
name|d
operator|+=
operator|(
name|double
operator|)
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
operator|~
name|lv
argument_list|)
expr_stmt|;
name|d
operator|=
operator|(
operator|-
name|d
operator|-
literal|1.0
operator|)
expr_stmt|;
block|}
else|else
block|{
name|d
operator|=
operator|(
name|double
operator|)
name|hv
expr_stmt|;
name|d
operator|*=
operator|(
call|(
name|double
call|)
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|/
literal|2
operator|)
argument_list|)
operator|*
call|(
name|double
call|)
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|/
literal|2
operator|)
argument_list|)
operator|)
expr_stmt|;
name|d
operator|+=
operator|(
name|double
operator|)
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|lv
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* REAL_ARITHMETIC */
name|d
operator|=
name|real_value_truncate
argument_list|(
name|mode
argument_list|,
name|d
argument_list|)
expr_stmt|;
return|return
name|CONST_DOUBLE_FROM_REAL_VALUE
argument_list|(
name|d
argument_list|,
name|mode
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|UNSIGNED_FLOAT
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|)
condition|)
block|{
name|HOST_WIDE_INT
name|hv
decl_stmt|,
name|lv
decl_stmt|;
name|REAL_VALUE_TYPE
name|d
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
name|lv
operator|=
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|,
name|hv
operator|=
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
literal|0
expr_stmt|;
else|else
name|lv
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
operator|,
name|hv
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_mode
operator|==
name|VOIDmode
condition|)
block|{
comment|/* We don't know how to interpret negative-looking numbers in 	     this case, so don't try to fold those.  */
if|if
condition|(
name|hv
operator|<
literal|0
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|op_mode
argument_list|)
operator|>=
name|HOST_BITS_PER_WIDE_INT
operator|*
literal|2
condition|)
empty_stmt|;
else|else
name|hv
operator|=
literal|0
operator|,
name|lv
operator|&=
name|GET_MODE_MASK
argument_list|(
name|op_mode
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|REAL_ARITHMETIC
name|REAL_VALUE_FROM_UNSIGNED_INT
argument_list|(
name|d
argument_list|,
name|lv
argument_list|,
name|hv
argument_list|,
name|mode
argument_list|)
expr_stmt|;
else|#
directive|else
name|d
operator|=
operator|(
name|double
operator|)
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|hv
expr_stmt|;
name|d
operator|*=
operator|(
call|(
name|double
call|)
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|/
literal|2
operator|)
argument_list|)
operator|*
call|(
name|double
call|)
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|/
literal|2
operator|)
argument_list|)
operator|)
expr_stmt|;
name|d
operator|+=
operator|(
name|double
operator|)
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|lv
expr_stmt|;
endif|#
directive|endif
comment|/* REAL_ARITHMETIC */
name|d
operator|=
name|real_value_truncate
argument_list|(
name|mode
argument_list|,
name|d
argument_list|)
expr_stmt|;
return|return
name|CONST_DOUBLE_FROM_REAL_VALUE
argument_list|(
name|d
argument_list|,
name|mode
argument_list|)
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|width
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|width
operator|>
literal|0
condition|)
block|{
specifier|register
name|HOST_WIDE_INT
name|arg0
init|=
name|INTVAL
argument_list|(
name|op
argument_list|)
decl_stmt|;
specifier|register
name|HOST_WIDE_INT
name|val
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|NOT
case|:
name|val
operator|=
operator|~
name|arg0
expr_stmt|;
break|break;
case|case
name|NEG
case|:
name|val
operator|=
operator|-
name|arg0
expr_stmt|;
break|break;
case|case
name|ABS
case|:
name|val
operator|=
operator|(
name|arg0
operator|>=
literal|0
condition|?
name|arg0
else|:
operator|-
name|arg0
operator|)
expr_stmt|;
break|break;
case|case
name|FFS
case|:
comment|/* Don't use ffs here.  Instead, get low order bit and then its 	     number.  If arg0 is zero, this will return 0, as desired.  */
name|arg0
operator|&=
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|val
operator|=
name|exact_log2
argument_list|(
name|arg0
operator|&
operator|(
operator|-
name|arg0
operator|)
argument_list|)
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|TRUNCATE
case|:
name|val
operator|=
name|arg0
expr_stmt|;
break|break;
case|case
name|ZERO_EXTEND
case|:
if|if
condition|(
name|op_mode
operator|==
name|VOIDmode
condition|)
name|op_mode
operator|=
name|mode
expr_stmt|;
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|op_mode
argument_list|)
operator|==
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
comment|/* If we were really extending the mode, 		 we would have to distinguish between zero-extension 		 and sign-extension.  */
if|if
condition|(
name|width
operator|!=
name|GET_MODE_BITSIZE
argument_list|(
name|op_mode
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|val
operator|=
name|arg0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|op_mode
argument_list|)
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
name|val
operator|=
name|arg0
operator|&
operator|~
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
name|GET_MODE_BITSIZE
argument_list|(
name|op_mode
argument_list|)
operator|)
expr_stmt|;
else|else
return|return
literal|0
return|;
break|break;
case|case
name|SIGN_EXTEND
case|:
if|if
condition|(
name|op_mode
operator|==
name|VOIDmode
condition|)
name|op_mode
operator|=
name|mode
expr_stmt|;
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|op_mode
argument_list|)
operator|==
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
comment|/* If we were really extending the mode, 		 we would have to distinguish between zero-extension 		 and sign-extension.  */
if|if
condition|(
name|width
operator|!=
name|GET_MODE_BITSIZE
argument_list|(
name|op_mode
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|val
operator|=
name|arg0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|op_mode
argument_list|)
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|val
operator|=
name|arg0
operator|&
operator|~
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
name|GET_MODE_BITSIZE
argument_list|(
name|op_mode
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|op_mode
argument_list|)
operator|-
literal|1
operator|)
operator|)
condition|)
name|val
operator|-=
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|GET_MODE_BITSIZE
argument_list|(
name|op_mode
argument_list|)
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
break|break;
case|case
name|SQRT
case|:
return|return
literal|0
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Clear the bits that don't belong in our mode, 	 unless they and our sign bit are all one. 	 So we get either a reasonable negative value or a reasonable 	 unsigned value for this mode.  */
if|if
condition|(
name|width
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
operator|(
name|val
operator|&
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
operator|)
operator|!=
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
name|val
operator|&=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|width
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* If this would be an entire word for the target, but is not for 	 the host, then sign-extend on the host so that the number will look 	 the same way on the host that it would on the target.  	 For example, when building a 64 bit alpha hosted 32 bit sparc 	 targeted compiler, then we want the 32 bit unsigned value -1 to be 	 represented as a 64 bit value -1, and not as 0x00000000ffffffff. 	 The later confuses the sparc backend.  */
if|if
condition|(
name|BITS_PER_WORD
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|BITS_PER_WORD
operator|==
name|width
operator|&&
operator|(
name|val
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
name|val
operator||=
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
name|width
operator|)
expr_stmt|;
return|return
name|GEN_INT
argument_list|(
name|val
argument_list|)
return|;
block|}
comment|/* We can do some operations on integer CONST_DOUBLEs.  Also allow      for a DImode operation on a CONST_INT.  */
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|&&
name|width
operator|<=
name|HOST_BITS_PER_INT
operator|*
literal|2
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|)
condition|)
block|{
name|HOST_WIDE_INT
name|l1
decl_stmt|,
name|h1
decl_stmt|,
name|lv
decl_stmt|,
name|hv
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
name|l1
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
operator|,
name|h1
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
expr_stmt|;
else|else
name|l1
operator|=
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|,
name|h1
operator|=
name|l1
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
literal|0
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|NOT
case|:
name|lv
operator|=
operator|~
name|l1
expr_stmt|;
name|hv
operator|=
operator|~
name|h1
expr_stmt|;
break|break;
case|case
name|NEG
case|:
name|neg_double
argument_list|(
name|l1
argument_list|,
name|h1
argument_list|,
operator|&
name|lv
argument_list|,
operator|&
name|hv
argument_list|)
expr_stmt|;
break|break;
case|case
name|ABS
case|:
if|if
condition|(
name|h1
operator|<
literal|0
condition|)
name|neg_double
argument_list|(
name|l1
argument_list|,
name|h1
argument_list|,
operator|&
name|lv
argument_list|,
operator|&
name|hv
argument_list|)
expr_stmt|;
else|else
name|lv
operator|=
name|l1
operator|,
name|hv
operator|=
name|h1
expr_stmt|;
break|break;
case|case
name|FFS
case|:
name|hv
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|l1
operator|==
literal|0
condition|)
name|lv
operator|=
name|HOST_BITS_PER_WIDE_INT
operator|+
name|exact_log2
argument_list|(
name|h1
operator|&
operator|(
operator|-
name|h1
operator|)
argument_list|)
operator|+
literal|1
expr_stmt|;
else|else
name|lv
operator|=
name|exact_log2
argument_list|(
name|l1
operator|&
operator|(
operator|-
name|l1
operator|)
argument_list|)
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|TRUNCATE
case|:
comment|/* This is just a change-of-mode, so do nothing.  */
name|lv
operator|=
name|l1
operator|,
name|hv
operator|=
name|h1
expr_stmt|;
break|break;
case|case
name|ZERO_EXTEND
case|:
if|if
condition|(
name|op_mode
operator|==
name|VOIDmode
operator|||
name|GET_MODE_BITSIZE
argument_list|(
name|op_mode
argument_list|)
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
return|return
literal|0
return|;
name|hv
operator|=
literal|0
expr_stmt|;
name|lv
operator|=
name|l1
operator|&
name|GET_MODE_MASK
argument_list|(
name|op_mode
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIGN_EXTEND
case|:
if|if
condition|(
name|op_mode
operator|==
name|VOIDmode
operator|||
name|GET_MODE_BITSIZE
argument_list|(
name|op_mode
argument_list|)
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
return|return
literal|0
return|;
else|else
block|{
name|lv
operator|=
name|l1
operator|&
name|GET_MODE_MASK
argument_list|(
name|op_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|op_mode
argument_list|)
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
name|lv
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|op_mode
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|)
operator|!=
literal|0
condition|)
name|lv
operator|-=
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|GET_MODE_BITSIZE
argument_list|(
name|op_mode
argument_list|)
expr_stmt|;
name|hv
operator|=
operator|(
name|lv
operator|<
literal|0
operator|)
condition|?
operator|~
operator|(
name|HOST_WIDE_INT
operator|)
literal|0
else|:
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|SQRT
case|:
return|return
literal|0
return|;
default|default:
return|return
literal|0
return|;
block|}
return|return
name|immed_double_const
argument_list|(
name|lv
argument_list|,
name|hv
argument_list|,
name|mode
argument_list|)
return|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|REAL_IS_NOT_DOUBLE
argument_list|)
operator|||
name|defined
argument_list|(
name|REAL_ARITHMETIC
argument_list|)
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
block|{
name|REAL_VALUE_TYPE
name|d
decl_stmt|;
name|jmp_buf
name|handler
decl_stmt|;
name|rtx
name|x
decl_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|handler
argument_list|)
condition|)
comment|/* There used to be a warning here, but that is inadvisable. 	   People may want to cause traps, and the natural way 	   to do it should not get a warning.  */
return|return
literal|0
return|;
name|set_float_handler
argument_list|(
name|handler
argument_list|)
expr_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|d
argument_list|,
name|op
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|NEG
case|:
name|d
operator|=
name|REAL_VALUE_NEGATE
argument_list|(
name|d
argument_list|)
expr_stmt|;
break|break;
case|case
name|ABS
case|:
if|if
condition|(
name|REAL_VALUE_NEGATIVE
argument_list|(
name|d
argument_list|)
condition|)
name|d
operator|=
name|REAL_VALUE_NEGATE
argument_list|(
name|d
argument_list|)
expr_stmt|;
break|break;
case|case
name|FLOAT_TRUNCATE
case|:
name|d
operator|=
name|real_value_truncate
argument_list|(
name|mode
argument_list|,
name|d
argument_list|)
expr_stmt|;
break|break;
case|case
name|FLOAT_EXTEND
case|:
comment|/* All this does is change the mode.  */
break|break;
case|case
name|FIX
case|:
name|d
operator|=
name|REAL_VALUE_RNDZINT
argument_list|(
name|d
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSIGNED_FIX
case|:
name|d
operator|=
name|REAL_VALUE_UNSIGNED_RNDZINT
argument_list|(
name|d
argument_list|)
expr_stmt|;
break|break;
case|case
name|SQRT
case|:
return|return
literal|0
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|x
operator|=
name|CONST_DOUBLE_FROM_REAL_VALUE
argument_list|(
name|d
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|set_float_handler
argument_list|(
name|NULL_PTR
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|width
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|width
operator|>
literal|0
condition|)
block|{
name|REAL_VALUE_TYPE
name|d
decl_stmt|;
name|jmp_buf
name|handler
decl_stmt|;
name|HOST_WIDE_INT
name|val
decl_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|handler
argument_list|)
condition|)
return|return
literal|0
return|;
name|set_float_handler
argument_list|(
name|handler
argument_list|)
expr_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|d
argument_list|,
name|op
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|FIX
case|:
name|val
operator|=
name|REAL_VALUE_FIX
argument_list|(
name|d
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSIGNED_FIX
case|:
name|val
operator|=
name|REAL_VALUE_UNSIGNED_FIX
argument_list|(
name|d
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|set_float_handler
argument_list|(
name|NULL_PTR
argument_list|)
expr_stmt|;
comment|/* Clear the bits that don't belong in our mode, 	 unless they and our sign bit are all one. 	 So we get either a reasonable negative value or a reasonable 	 unsigned value for this mode.  */
if|if
condition|(
name|width
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
operator|(
name|val
operator|&
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
operator|)
operator|!=
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
name|val
operator|&=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|width
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* If this would be an entire word for the target, but is not for 	 the host, then sign-extend on the host so that the number will look 	 the same way on the host that it would on the target.  	 For example, when building a 64 bit alpha hosted 32 bit sparc 	 targeted compiler, then we want the 32 bit unsigned value -1 to be 	 represented as a 64 bit value -1, and not as 0x00000000ffffffff. 	 The later confuses the sparc backend.  */
if|if
condition|(
name|BITS_PER_WORD
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|BITS_PER_WORD
operator|==
name|width
operator|&&
operator|(
name|val
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
name|val
operator||=
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
name|width
operator|)
expr_stmt|;
return|return
name|GEN_INT
argument_list|(
name|val
argument_list|)
return|;
block|}
endif|#
directive|endif
comment|/* This was formerly used only for non-IEEE float.      eggert@twinsun.com says it is safe for IEEE also.  */
else|else
block|{
comment|/* There are some simplifications we can do even if the operands 	 aren't constant.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|NEG
case|:
case|case
name|NOT
case|:
comment|/* (not (not X)) == X, similarly for NEG.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|code
condition|)
return|return
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
return|;
break|break;
case|case
name|SIGN_EXTEND
case|:
comment|/* (sign_extend (truncate (minus (label_ref L1) (label_ref L2)))) 	     becomes just the MINUS if its mode is MODE.  This allows 	     folding switch statements on machines using casesi (such as 	     the Vax).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|TRUNCATE
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|mode
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MINUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
return|return
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
return|;
ifdef|#
directive|ifdef
name|POINTERS_EXTEND_UNSIGNED
if|if
condition|(
operator|!
name|POINTERS_EXTEND_UNSIGNED
operator|&&
name|mode
operator|==
name|Pmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|ptr_mode
operator|&&
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
condition|)
return|return
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|op
argument_list|)
return|;
endif|#
directive|endif
break|break;
ifdef|#
directive|ifdef
name|POINTERS_EXTEND_UNSIGNED
case|case
name|ZERO_EXTEND
case|:
if|if
condition|(
name|POINTERS_EXTEND_UNSIGNED
operator|&&
name|mode
operator|==
name|Pmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|ptr_mode
operator|&&
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
condition|)
return|return
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|op
argument_list|)
return|;
break|break;
endif|#
directive|endif
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Simplify a binary operation CODE with result mode MODE, operating on OP0    and OP1.  Return 0 if no simplification is possible.     Don't use this for relational operations such as EQ or LT.    Use simplify_relational_operation instead.  */
end_comment

begin_function
name|rtx
name|simplify_binary_operation
parameter_list|(
name|code
parameter_list|,
name|mode
parameter_list|,
name|op0
parameter_list|,
name|op1
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
block|{
specifier|register
name|HOST_WIDE_INT
name|arg0
decl_stmt|,
name|arg1
decl_stmt|,
name|arg0s
decl_stmt|,
name|arg1s
decl_stmt|;
name|HOST_WIDE_INT
name|val
decl_stmt|;
name|int
name|width
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
comment|/* Relational operations don't work here.  We must know the mode      of the operands in order to do the comparison correctly.      Assuming a full word can give incorrect results.      Consider comparing 128 with -128 in QImode.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'<'
condition|)
name|abort
argument_list|()
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|REAL_IS_NOT_DOUBLE
argument_list|)
operator|||
name|defined
argument_list|(
name|REAL_ARITHMETIC
argument_list|)
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|mode
operator|==
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|&&
name|mode
operator|==
name|GET_MODE
argument_list|(
name|op1
argument_list|)
condition|)
block|{
name|REAL_VALUE_TYPE
name|f0
decl_stmt|,
name|f1
decl_stmt|,
name|value
decl_stmt|;
name|jmp_buf
name|handler
decl_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|handler
argument_list|)
condition|)
return|return
literal|0
return|;
name|set_float_handler
argument_list|(
name|handler
argument_list|)
expr_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|f0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|f1
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|f0
operator|=
name|real_value_truncate
argument_list|(
name|mode
argument_list|,
name|f0
argument_list|)
expr_stmt|;
name|f1
operator|=
name|real_value_truncate
argument_list|(
name|mode
argument_list|,
name|f1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|REAL_ARITHMETIC
ifndef|#
directive|ifndef
name|REAL_INFINITY
if|if
condition|(
name|code
operator|==
name|DIV
operator|&&
name|REAL_VALUES_EQUAL
argument_list|(
name|f1
argument_list|,
name|dconst0
argument_list|)
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
name|REAL_ARITHMETIC
argument_list|(
name|value
argument_list|,
name|rtx_to_tree_code
argument_list|(
name|code
argument_list|)
argument_list|,
name|f0
argument_list|,
name|f1
argument_list|)
expr_stmt|;
else|#
directive|else
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS
case|:
name|value
operator|=
name|f0
operator|+
name|f1
expr_stmt|;
break|break;
case|case
name|MINUS
case|:
name|value
operator|=
name|f0
operator|-
name|f1
expr_stmt|;
break|break;
case|case
name|MULT
case|:
name|value
operator|=
name|f0
operator|*
name|f1
expr_stmt|;
break|break;
case|case
name|DIV
case|:
ifndef|#
directive|ifndef
name|REAL_INFINITY
if|if
condition|(
name|f1
operator|==
literal|0
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
name|value
operator|=
name|f0
operator|/
name|f1
expr_stmt|;
break|break;
case|case
name|SMIN
case|:
name|value
operator|=
name|MIN
argument_list|(
name|f0
argument_list|,
name|f1
argument_list|)
expr_stmt|;
break|break;
case|case
name|SMAX
case|:
name|value
operator|=
name|MAX
argument_list|(
name|f0
argument_list|,
name|f1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
name|value
operator|=
name|real_value_truncate
argument_list|(
name|mode
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|set_float_handler
argument_list|(
name|NULL_PTR
argument_list|)
expr_stmt|;
return|return
name|CONST_DOUBLE_FROM_REAL_VALUE
argument_list|(
name|value
argument_list|,
name|mode
argument_list|)
return|;
block|}
endif|#
directive|endif
comment|/* not REAL_IS_NOT_DOUBLE, or REAL_ARITHMETIC */
comment|/* We can fold some multi-word operations.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|width
operator|==
name|HOST_BITS_PER_WIDE_INT
operator|*
literal|2
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CONST_DOUBLE
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_DOUBLE
operator|||
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|)
condition|)
block|{
name|HOST_WIDE_INT
name|l1
decl_stmt|,
name|l2
decl_stmt|,
name|h1
decl_stmt|,
name|h2
decl_stmt|,
name|lv
decl_stmt|,
name|hv
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
name|l1
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|op0
argument_list|)
operator|,
name|h1
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|op0
argument_list|)
expr_stmt|;
else|else
name|l1
operator|=
name|INTVAL
argument_list|(
name|op0
argument_list|)
operator|,
name|h1
operator|=
name|l1
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
name|l2
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|op1
argument_list|)
operator|,
name|h2
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|op1
argument_list|)
expr_stmt|;
else|else
name|l2
operator|=
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|,
name|h2
operator|=
name|l2
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
literal|0
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|MINUS
case|:
comment|/* A - B == A + (-B).  */
name|neg_double
argument_list|(
name|l2
argument_list|,
name|h2
argument_list|,
operator|&
name|lv
argument_list|,
operator|&
name|hv
argument_list|)
expr_stmt|;
name|l2
operator|=
name|lv
operator|,
name|h2
operator|=
name|hv
expr_stmt|;
comment|/* .. fall through ...  */
case|case
name|PLUS
case|:
name|add_double
argument_list|(
name|l1
argument_list|,
name|h1
argument_list|,
name|l2
argument_list|,
name|h2
argument_list|,
operator|&
name|lv
argument_list|,
operator|&
name|hv
argument_list|)
expr_stmt|;
break|break;
case|case
name|MULT
case|:
name|mul_double
argument_list|(
name|l1
argument_list|,
name|h1
argument_list|,
name|l2
argument_list|,
name|h2
argument_list|,
operator|&
name|lv
argument_list|,
operator|&
name|hv
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIV
case|:
case|case
name|MOD
case|:
case|case
name|UDIV
case|:
case|case
name|UMOD
case|:
comment|/* We'd need to include tree.h to do this and it doesn't seem worth 	     it.  */
return|return
literal|0
return|;
case|case
name|AND
case|:
name|lv
operator|=
name|l1
operator|&
name|l2
operator|,
name|hv
operator|=
name|h1
operator|&
name|h2
expr_stmt|;
break|break;
case|case
name|IOR
case|:
name|lv
operator|=
name|l1
operator||
name|l2
operator|,
name|hv
operator|=
name|h1
operator||
name|h2
expr_stmt|;
break|break;
case|case
name|XOR
case|:
name|lv
operator|=
name|l1
operator|^
name|l2
operator|,
name|hv
operator|=
name|h1
operator|^
name|h2
expr_stmt|;
break|break;
case|case
name|SMIN
case|:
if|if
condition|(
name|h1
operator|<
name|h2
operator|||
operator|(
name|h1
operator|==
name|h2
operator|&&
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|l1
operator|<
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|l2
operator|)
operator|)
condition|)
name|lv
operator|=
name|l1
operator|,
name|hv
operator|=
name|h1
expr_stmt|;
else|else
name|lv
operator|=
name|l2
operator|,
name|hv
operator|=
name|h2
expr_stmt|;
break|break;
case|case
name|SMAX
case|:
if|if
condition|(
name|h1
operator|>
name|h2
operator|||
operator|(
name|h1
operator|==
name|h2
operator|&&
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|l1
operator|>
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|l2
operator|)
operator|)
condition|)
name|lv
operator|=
name|l1
operator|,
name|hv
operator|=
name|h1
expr_stmt|;
else|else
name|lv
operator|=
name|l2
operator|,
name|hv
operator|=
name|h2
expr_stmt|;
break|break;
case|case
name|UMIN
case|:
if|if
condition|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|h1
operator|<
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|h2
operator|||
operator|(
name|h1
operator|==
name|h2
operator|&&
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|l1
operator|<
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|l2
operator|)
operator|)
condition|)
name|lv
operator|=
name|l1
operator|,
name|hv
operator|=
name|h1
expr_stmt|;
else|else
name|lv
operator|=
name|l2
operator|,
name|hv
operator|=
name|h2
expr_stmt|;
break|break;
case|case
name|UMAX
case|:
if|if
condition|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|h1
operator|>
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|h2
operator|||
operator|(
name|h1
operator|==
name|h2
operator|&&
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|l1
operator|>
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|l2
operator|)
operator|)
condition|)
name|lv
operator|=
name|l1
operator|,
name|hv
operator|=
name|h1
expr_stmt|;
else|else
name|lv
operator|=
name|l2
operator|,
name|hv
operator|=
name|h2
expr_stmt|;
break|break;
case|case
name|LSHIFTRT
case|:
case|case
name|ASHIFTRT
case|:
case|case
name|ASHIFT
case|:
case|case
name|ROTATE
case|:
case|case
name|ROTATERT
case|:
ifdef|#
directive|ifdef
name|SHIFT_COUNT_TRUNCATED
if|if
condition|(
name|SHIFT_COUNT_TRUNCATED
condition|)
name|l2
operator|&=
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
operator|)
operator|,
name|h2
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|h2
operator|!=
literal|0
operator|||
name|l2
operator|<
literal|0
operator|||
name|l2
operator|>=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|code
operator|==
name|LSHIFTRT
operator|||
name|code
operator|==
name|ASHIFTRT
condition|)
name|rshift_double
argument_list|(
name|l1
argument_list|,
name|h1
argument_list|,
name|l2
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
operator|&
name|lv
argument_list|,
operator|&
name|hv
argument_list|,
name|code
operator|==
name|ASHIFTRT
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|ASHIFT
condition|)
name|lshift_double
argument_list|(
name|l1
argument_list|,
name|h1
argument_list|,
name|l2
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
operator|&
name|lv
argument_list|,
operator|&
name|hv
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|ROTATE
condition|)
name|lrotate_double
argument_list|(
name|l1
argument_list|,
name|h1
argument_list|,
name|l2
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
operator|&
name|lv
argument_list|,
operator|&
name|hv
argument_list|)
expr_stmt|;
else|else
comment|/* code == ROTATERT */
name|rrotate_double
argument_list|(
name|l1
argument_list|,
name|h1
argument_list|,
name|l2
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
operator|&
name|lv
argument_list|,
operator|&
name|hv
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
return|return
name|immed_double_const
argument_list|(
name|lv
argument_list|,
name|hv
argument_list|,
name|mode
argument_list|)
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|width
operator|>
name|HOST_BITS_PER_WIDE_INT
operator|||
name|width
operator|==
literal|0
condition|)
block|{
comment|/* Even if we can't compute a constant result, 	 there are some cases worth simplifying.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS
case|:
comment|/* In IEEE floating point, x+0 is not the same as x.  Similarly 	     for the other optimizations below.  */
if|if
condition|(
name|TARGET_FLOAT_FORMAT
operator|==
name|IEEE_FLOAT_FORMAT
operator|&&
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
name|flag_fast_math
condition|)
break|break;
if|if
condition|(
name|op1
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|op0
return|;
comment|/* ((-a) + b) -> (b - a) and similarly for (a + (-b)) */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|NEG
condition|)
return|return
name|cse_gen_binary
argument_list|(
name|MINUS
argument_list|,
name|mode
argument_list|,
name|op1
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|NEG
condition|)
return|return
name|cse_gen_binary
argument_list|(
name|MINUS
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
comment|/* Handle both-operands-constant cases.  We can only add 	     CONST_INTs to constants since the sum of relocatable symbols 	     can't be handled by most assemblers.  Don't add CONST_INT 	     to CONST_INT since overflow won't be computed properly if wider 	     than HOST_BITS_PER_WIDE_INT.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op0
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|plus_constant
argument_list|(
name|op0
argument_list|,
name|INTVAL
argument_list|(
name|op1
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op1
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|plus_constant
argument_list|(
name|op1
argument_list|,
name|INTVAL
argument_list|(
name|op0
argument_list|)
argument_list|)
return|;
comment|/* See if this is something like X * C - X or vice versa or 	     if the multiplication is written as a shift.  If so, we can 	     distribute and make a new multiply, shift, or maybe just 	     have X (if C is 2 in the example above).  But don't make 	     real multiply if we didn't have one before.  */
if|if
condition|(
operator|!
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|HOST_WIDE_INT
name|coeff0
init|=
literal|1
decl_stmt|,
name|coeff1
init|=
literal|1
decl_stmt|;
name|rtx
name|lhs
init|=
name|op0
decl_stmt|,
name|rhs
init|=
name|op1
decl_stmt|;
name|int
name|had_mult
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|NEG
condition|)
name|coeff0
operator|=
operator|-
literal|1
operator|,
name|lhs
operator|=
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|MULT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|coeff0
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|,
name|lhs
operator|=
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|had_mult
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|ASHIFT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>=
literal|0
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|coeff0
operator|=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|)
operator|<<
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|lhs
operator|=
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|NEG
condition|)
name|coeff1
operator|=
operator|-
literal|1
operator|,
name|rhs
operator|=
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|MULT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|coeff1
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|,
name|rhs
operator|=
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|had_mult
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|ASHIFT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>=
literal|0
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|coeff1
operator|=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|)
operator|<<
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|rhs
operator|=
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|)
condition|)
block|{
name|tem
operator|=
name|cse_gen_binary
argument_list|(
name|MULT
argument_list|,
name|mode
argument_list|,
name|lhs
argument_list|,
name|GEN_INT
argument_list|(
name|coeff0
operator|+
name|coeff1
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|MULT
operator|&&
operator|!
name|had_mult
operator|)
condition|?
literal|0
else|:
name|tem
return|;
block|}
block|}
comment|/* If one of the operands is a PLUS or a MINUS, see if we can 	     simplify this by the associative law.  	     Don't use the associative law for floating point. 	     The inaccuracy makes it nonassociative, 	     and subtle programs can break if operations are associated.  */
if|if
condition|(
name|INTEGRAL_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MINUS
operator|||
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|MINUS
operator|)
operator|&&
operator|(
name|tem
operator|=
name|simplify_plus_minus
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|tem
return|;
break|break;
case|case
name|COMPARE
case|:
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* Convert (compare FOO (const_int 0)) to FOO unless we aren't 	     using cc0, in which case we want to leave it as a COMPARE 	     so we can distinguish it from a register-register-copy.  	     In IEEE floating point, x-0 is not the same as x.  */
if|if
condition|(
operator|(
name|TARGET_FLOAT_FORMAT
operator|!=
name|IEEE_FLOAT_FORMAT
operator|||
operator|!
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
operator|||
name|flag_fast_math
operator|)
operator|&&
name|op1
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|op0
return|;
else|#
directive|else
comment|/* Do nothing here.  */
endif|#
directive|endif
break|break;
case|case
name|MINUS
case|:
comment|/* None of these optimizations can be done for IEEE 	     floating point.  */
if|if
condition|(
name|TARGET_FLOAT_FORMAT
operator|==
name|IEEE_FLOAT_FORMAT
operator|&&
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
name|flag_fast_math
condition|)
break|break;
comment|/* We can't assume x-x is 0 even with non-IEEE floating point, 	     but since it is zero except in very strange circumstances, we 	     will treat it as zero with -ffast-math.  */
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
operator|&&
operator|(
operator|!
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
operator|||
name|flag_fast_math
operator|)
condition|)
return|return
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
return|;
comment|/* Change subtraction from zero into negation.  */
if|if
condition|(
name|op0
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|gen_rtx_NEG
argument_list|(
name|mode
argument_list|,
name|op1
argument_list|)
return|;
comment|/* (-1 - a) is ~a.  */
if|if
condition|(
name|op0
operator|==
name|constm1_rtx
condition|)
return|return
name|gen_rtx_NOT
argument_list|(
name|mode
argument_list|,
name|op1
argument_list|)
return|;
comment|/* Subtracting 0 has no effect.  */
if|if
condition|(
name|op1
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|op0
return|;
comment|/* See if this is something like X * C - X or vice versa or 	     if the multiplication is written as a shift.  If so, we can 	     distribute and make a new multiply, shift, or maybe just 	     have X (if C is 2 in the example above).  But don't make 	     real multiply if we didn't have one before.  */
if|if
condition|(
operator|!
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|HOST_WIDE_INT
name|coeff0
init|=
literal|1
decl_stmt|,
name|coeff1
init|=
literal|1
decl_stmt|;
name|rtx
name|lhs
init|=
name|op0
decl_stmt|,
name|rhs
init|=
name|op1
decl_stmt|;
name|int
name|had_mult
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|NEG
condition|)
name|coeff0
operator|=
operator|-
literal|1
operator|,
name|lhs
operator|=
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|MULT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|coeff0
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|,
name|lhs
operator|=
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|had_mult
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|ASHIFT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>=
literal|0
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|coeff0
operator|=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|)
operator|<<
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|lhs
operator|=
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|NEG
condition|)
name|coeff1
operator|=
operator|-
literal|1
operator|,
name|rhs
operator|=
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|MULT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|coeff1
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|,
name|rhs
operator|=
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|had_mult
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|ASHIFT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>=
literal|0
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|coeff1
operator|=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|)
operator|<<
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|rhs
operator|=
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|)
condition|)
block|{
name|tem
operator|=
name|cse_gen_binary
argument_list|(
name|MULT
argument_list|,
name|mode
argument_list|,
name|lhs
argument_list|,
name|GEN_INT
argument_list|(
name|coeff0
operator|-
name|coeff1
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|MULT
operator|&&
operator|!
name|had_mult
operator|)
condition|?
literal|0
else|:
name|tem
return|;
block|}
block|}
comment|/* (a - (-b)) -> (a + b).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|NEG
condition|)
return|return
name|cse_gen_binary
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
comment|/* If one of the operands is a PLUS or a MINUS, see if we can 	     simplify this by the associative law.  	     Don't use the associative law for floating point. 	     The inaccuracy makes it nonassociative, 	     and subtle programs can break if operations are associated.  */
if|if
condition|(
name|INTEGRAL_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MINUS
operator|||
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|MINUS
operator|)
operator|&&
operator|(
name|tem
operator|=
name|simplify_plus_minus
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|tem
return|;
comment|/* Don't let a relocatable value get a negative coeff.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|VOIDmode
condition|)
return|return
name|plus_constant
argument_list|(
name|op0
argument_list|,
operator|-
name|INTVAL
argument_list|(
name|op1
argument_list|)
argument_list|)
return|;
comment|/* (x - (x& y)) -> (x& ~y) */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|AND
condition|)
block|{
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|op0
argument_list|,
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|cse_gen_binary
argument_list|(
name|AND
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|gen_rtx_NOT
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|op0
argument_list|,
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|cse_gen_binary
argument_list|(
name|AND
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|gen_rtx_NOT
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
break|break;
case|case
name|MULT
case|:
if|if
condition|(
name|op1
operator|==
name|constm1_rtx
condition|)
block|{
name|tem
operator|=
name|simplify_unary_operation
argument_list|(
name|NEG
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
name|tem
condition|?
name|tem
else|:
name|gen_rtx_NEG
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
return|;
block|}
comment|/* In IEEE floating point, x*0 is not always 0.  */
if|if
condition|(
operator|(
name|TARGET_FLOAT_FORMAT
operator|!=
name|IEEE_FLOAT_FORMAT
operator|||
operator|!
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
operator|||
name|flag_fast_math
operator|)
operator|&&
name|op1
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
condition|)
return|return
name|op1
return|;
comment|/* In IEEE floating point, x*1 is not equivalent to x for nans. 	     However, ANSI says we can drop signals, 	     so we can do this anyway.  */
if|if
condition|(
name|op1
operator|==
name|CONST1_RTX
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|op0
return|;
comment|/* Convert multiply by constant power of two into shift unless 	     we are still generating RTL.  This test is a kludge.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|val
operator|=
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|)
operator|>=
literal|0
comment|/* If the mode is larger than the host word size, and the 		 uppermost bit is set, then this isn't a power of two due 		 to implicit sign extension.  */
operator|&&
operator|(
name|width
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|||
name|val
operator|!=
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
operator|&&
operator|!
name|rtx_equal_function_value_matters
condition|)
return|return
name|gen_rtx_ASHIFT
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|GEN_INT
argument_list|(
name|val
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
block|{
name|REAL_VALUE_TYPE
name|d
decl_stmt|;
name|jmp_buf
name|handler
decl_stmt|;
name|int
name|op1is2
decl_stmt|,
name|op1ism1
decl_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|handler
argument_list|)
condition|)
return|return
literal|0
return|;
name|set_float_handler
argument_list|(
name|handler
argument_list|)
expr_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|d
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|op1is2
operator|=
name|REAL_VALUES_EQUAL
argument_list|(
name|d
argument_list|,
name|dconst2
argument_list|)
expr_stmt|;
name|op1ism1
operator|=
name|REAL_VALUES_EQUAL
argument_list|(
name|d
argument_list|,
name|dconstm1
argument_list|)
expr_stmt|;
name|set_float_handler
argument_list|(
name|NULL_PTR
argument_list|)
expr_stmt|;
comment|/* x*2 is x+x and x*(-1) is -x */
if|if
condition|(
name|op1is2
operator|&&
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|mode
condition|)
return|return
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|copy_rtx
argument_list|(
name|op0
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|op1ism1
operator|&&
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|mode
condition|)
return|return
name|gen_rtx_NEG
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
return|;
block|}
break|break;
case|case
name|IOR
case|:
if|if
condition|(
name|op1
operator|==
name|const0_rtx
condition|)
return|return
name|op0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|&
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|)
operator|==
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|op1
return|;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
condition|)
return|return
name|op0
return|;
comment|/* A | (~A) -> -1 */
if|if
condition|(
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|NOT
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op1
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|NOT
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op0
argument_list|)
operator|)
operator|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_CC
condition|)
return|return
name|constm1_rtx
return|;
break|break;
case|case
name|XOR
case|:
if|if
condition|(
name|op1
operator|==
name|const0_rtx
condition|)
return|return
name|op0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|&
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|)
operator|==
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|gen_rtx_NOT
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
return|;
if|if
condition|(
name|op0
operator|==
name|op1
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_CC
condition|)
return|return
name|const0_rtx
return|;
break|break;
case|case
name|AND
case|:
if|if
condition|(
name|op1
operator|==
name|const0_rtx
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
condition|)
return|return
name|const0_rtx
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|&
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|)
operator|==
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|op0
return|;
if|if
condition|(
name|op0
operator|==
name|op1
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_CC
condition|)
return|return
name|op0
return|;
comment|/* A& (~A) -> 0 */
if|if
condition|(
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|NOT
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op1
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|NOT
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op0
argument_list|)
operator|)
operator|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_CC
condition|)
return|return
name|const0_rtx
return|;
break|break;
case|case
name|UDIV
case|:
comment|/* Convert divide by power of two into shift (divide by 1 handled 	     below).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|arg1
operator|=
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|)
operator|>
literal|0
condition|)
return|return
name|gen_rtx_LSHIFTRT
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|GEN_INT
argument_list|(
name|arg1
argument_list|)
argument_list|)
return|;
comment|/* ... fall through ...  */
case|case
name|DIV
case|:
if|if
condition|(
name|op1
operator|==
name|CONST1_RTX
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|op0
return|;
comment|/* In IEEE floating point, 0/x is not always 0.  */
if|if
condition|(
operator|(
name|TARGET_FLOAT_FORMAT
operator|!=
name|IEEE_FLOAT_FORMAT
operator|||
operator|!
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
operator|||
name|flag_fast_math
operator|)
operator|&&
name|op0
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op1
argument_list|)
condition|)
return|return
name|op0
return|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|REAL_IS_NOT_DOUBLE
argument_list|)
operator|||
name|defined
argument_list|(
name|REAL_ARITHMETIC
argument_list|)
comment|/* Change division by a constant into multiplication.  Only do 	     this with -ffast-math until an expert says it is safe in 	     general.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|op1
operator|!=
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
operator|&&
name|flag_fast_math
condition|)
block|{
name|REAL_VALUE_TYPE
name|d
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|d
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|REAL_VALUES_EQUAL
argument_list|(
name|d
argument_list|,
name|dconst0
argument_list|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|REAL_ARITHMETIC
argument_list|)
name|REAL_ARITHMETIC
argument_list|(
name|d
argument_list|,
name|rtx_to_tree_code
argument_list|(
name|DIV
argument_list|)
argument_list|,
name|dconst1
argument_list|,
name|d
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_MULT
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|CONST_DOUBLE_FROM_REAL_VALUE
argument_list|(
name|d
argument_list|,
name|mode
argument_list|)
argument_list|)
return|;
else|#
directive|else
return|return
name|gen_rtx_MULT
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|CONST_DOUBLE_FROM_REAL_VALUE
argument_list|(
literal|1.
operator|/
name|d
argument_list|,
name|mode
argument_list|)
argument_list|)
return|;
endif|#
directive|endif
block|}
block|}
endif|#
directive|endif
break|break;
case|case
name|UMOD
case|:
comment|/* Handle modulus by power of two (mod with 1 handled below).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|>
literal|0
condition|)
return|return
name|gen_rtx_AND
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
return|;
comment|/* ... fall through ...  */
case|case
name|MOD
case|:
if|if
condition|(
operator|(
name|op0
operator|==
name|const0_rtx
operator|||
name|op1
operator|==
name|const1_rtx
operator|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op1
argument_list|)
condition|)
return|return
name|const0_rtx
return|;
break|break;
case|case
name|ROTATERT
case|:
case|case
name|ROTATE
case|:
comment|/* Rotating ~0 always results in ~0.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|width
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|INTVAL
argument_list|(
name|op0
argument_list|)
operator|==
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op1
argument_list|)
condition|)
return|return
name|op0
return|;
comment|/* ... fall through ...  */
case|case
name|ASHIFT
case|:
case|case
name|ASHIFTRT
case|:
case|case
name|LSHIFTRT
case|:
if|if
condition|(
name|op1
operator|==
name|const0_rtx
condition|)
return|return
name|op0
return|;
if|if
condition|(
name|op0
operator|==
name|const0_rtx
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op1
argument_list|)
condition|)
return|return
name|op0
return|;
break|break;
case|case
name|SMIN
case|:
if|if
condition|(
name|width
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|==
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
condition|)
return|return
name|op1
return|;
elseif|else
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
condition|)
return|return
name|op0
return|;
break|break;
case|case
name|SMAX
case|:
if|if
condition|(
name|width
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|==
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|>>
literal|1
operator|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
condition|)
return|return
name|op1
return|;
elseif|else
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
condition|)
return|return
name|op0
return|;
break|break;
case|case
name|UMIN
case|:
if|if
condition|(
name|op1
operator|==
name|const0_rtx
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
condition|)
return|return
name|op1
return|;
elseif|else
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
condition|)
return|return
name|op0
return|;
break|break;
case|case
name|UMAX
case|:
if|if
condition|(
name|op1
operator|==
name|constm1_rtx
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
condition|)
return|return
name|op1
return|;
elseif|else
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
condition|)
return|return
name|op0
return|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
comment|/* Get the integer argument values in two forms:      zero-extended in ARG0, ARG1 and sign-extended in ARG0S, ARG1S.  */
name|arg0
operator|=
name|INTVAL
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|INTVAL
argument_list|(
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|arg0
operator|&=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|width
operator|)
operator|-
literal|1
expr_stmt|;
name|arg1
operator|&=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|width
operator|)
operator|-
literal|1
expr_stmt|;
name|arg0s
operator|=
name|arg0
expr_stmt|;
if|if
condition|(
name|arg0s
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
condition|)
name|arg0s
operator||=
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
name|width
operator|)
expr_stmt|;
name|arg1s
operator|=
name|arg1
expr_stmt|;
if|if
condition|(
name|arg1s
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
condition|)
name|arg1s
operator||=
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
name|width
operator|)
expr_stmt|;
block|}
else|else
block|{
name|arg0s
operator|=
name|arg0
expr_stmt|;
name|arg1s
operator|=
name|arg1
expr_stmt|;
block|}
comment|/* Compute the value of the arithmetic.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS
case|:
name|val
operator|=
name|arg0s
operator|+
name|arg1s
expr_stmt|;
break|break;
case|case
name|MINUS
case|:
name|val
operator|=
name|arg0s
operator|-
name|arg1s
expr_stmt|;
break|break;
case|case
name|MULT
case|:
name|val
operator|=
name|arg0s
operator|*
name|arg1s
expr_stmt|;
break|break;
case|case
name|DIV
case|:
if|if
condition|(
name|arg1s
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|val
operator|=
name|arg0s
operator|/
name|arg1s
expr_stmt|;
break|break;
case|case
name|MOD
case|:
if|if
condition|(
name|arg1s
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|val
operator|=
name|arg0s
operator|%
name|arg1s
expr_stmt|;
break|break;
case|case
name|UDIV
case|:
if|if
condition|(
name|arg1
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|val
operator|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|arg0
operator|/
name|arg1
expr_stmt|;
break|break;
case|case
name|UMOD
case|:
if|if
condition|(
name|arg1
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|val
operator|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|arg0
operator|%
name|arg1
expr_stmt|;
break|break;
case|case
name|AND
case|:
name|val
operator|=
name|arg0
operator|&
name|arg1
expr_stmt|;
break|break;
case|case
name|IOR
case|:
name|val
operator|=
name|arg0
operator||
name|arg1
expr_stmt|;
break|break;
case|case
name|XOR
case|:
name|val
operator|=
name|arg0
operator|^
name|arg1
expr_stmt|;
break|break;
case|case
name|LSHIFTRT
case|:
comment|/* If shift count is undefined, don't fold it; let the machine do 	 what it wants.  But truncate it if the machine will do that.  */
if|if
condition|(
name|arg1
operator|<
literal|0
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|SHIFT_COUNT_TRUNCATED
if|if
condition|(
name|SHIFT_COUNT_TRUNCATED
condition|)
name|arg1
operator|%=
name|width
expr_stmt|;
endif|#
directive|endif
name|val
operator|=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|arg0
operator|)
operator|>>
name|arg1
expr_stmt|;
break|break;
case|case
name|ASHIFT
case|:
if|if
condition|(
name|arg1
operator|<
literal|0
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|SHIFT_COUNT_TRUNCATED
if|if
condition|(
name|SHIFT_COUNT_TRUNCATED
condition|)
name|arg1
operator|%=
name|width
expr_stmt|;
endif|#
directive|endif
name|val
operator|=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|arg0
operator|)
operator|<<
name|arg1
expr_stmt|;
break|break;
case|case
name|ASHIFTRT
case|:
if|if
condition|(
name|arg1
operator|<
literal|0
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|SHIFT_COUNT_TRUNCATED
if|if
condition|(
name|SHIFT_COUNT_TRUNCATED
condition|)
name|arg1
operator|%=
name|width
expr_stmt|;
endif|#
directive|endif
name|val
operator|=
name|arg0s
operator|>>
name|arg1
expr_stmt|;
comment|/* Bootstrap compiler may not have sign extended the right shift. 	 Manually extend the sign to insure bootstrap cc matches gcc.  */
if|if
condition|(
name|arg0s
operator|<
literal|0
operator|&&
name|arg1
operator|>
literal|0
condition|)
name|val
operator||=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
operator|-
literal|1
operator|)
operator|<<
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
name|arg1
operator|)
expr_stmt|;
break|break;
case|case
name|ROTATERT
case|:
if|if
condition|(
name|arg1
operator|<
literal|0
condition|)
return|return
literal|0
return|;
name|arg1
operator|%=
name|width
expr_stmt|;
name|val
operator|=
operator|(
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|arg0
operator|)
operator|<<
operator|(
name|width
operator|-
name|arg1
operator|)
operator|)
operator||
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|arg0
operator|)
operator|>>
name|arg1
operator|)
operator|)
expr_stmt|;
break|break;
case|case
name|ROTATE
case|:
if|if
condition|(
name|arg1
operator|<
literal|0
condition|)
return|return
literal|0
return|;
name|arg1
operator|%=
name|width
expr_stmt|;
name|val
operator|=
operator|(
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|arg0
operator|)
operator|<<
name|arg1
operator|)
operator||
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|arg0
operator|)
operator|>>
operator|(
name|width
operator|-
name|arg1
operator|)
operator|)
operator|)
expr_stmt|;
break|break;
case|case
name|COMPARE
case|:
comment|/* Do nothing here.  */
return|return
literal|0
return|;
case|case
name|SMIN
case|:
name|val
operator|=
name|arg0s
operator|<=
name|arg1s
condition|?
name|arg0s
else|:
name|arg1s
expr_stmt|;
break|break;
case|case
name|UMIN
case|:
name|val
operator|=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|arg0
operator|<=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|arg1
condition|?
name|arg0
else|:
name|arg1
operator|)
expr_stmt|;
break|break;
case|case
name|SMAX
case|:
name|val
operator|=
name|arg0s
operator|>
name|arg1s
condition|?
name|arg0s
else|:
name|arg1s
expr_stmt|;
break|break;
case|case
name|UMAX
case|:
name|val
operator|=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|arg0
operator|>
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|arg1
condition|?
name|arg0
else|:
name|arg1
operator|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Clear the bits that don't belong in our mode, unless they and our sign      bit are all one.  So we get either a reasonable negative value or a      reasonable unsigned value for this mode.  */
if|if
condition|(
name|width
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
operator|(
name|val
operator|&
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
operator|)
operator|!=
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
name|val
operator|&=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|width
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* If this would be an entire word for the target, but is not for      the host, then sign-extend on the host so that the number will look      the same way on the host that it would on the target.       For example, when building a 64 bit alpha hosted 32 bit sparc      targeted compiler, then we want the 32 bit unsigned value -1 to be      represented as a 64 bit value -1, and not as 0x00000000ffffffff.      The later confuses the sparc backend.  */
if|if
condition|(
name|BITS_PER_WORD
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|BITS_PER_WORD
operator|==
name|width
operator|&&
operator|(
name|val
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
name|val
operator||=
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
name|width
operator|)
expr_stmt|;
return|return
name|GEN_INT
argument_list|(
name|val
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Simplify a PLUS or MINUS, at least one of whose operands may be another    PLUS or MINUS.     Rather than test for specific case, we do this by a brute-force method    and do all possible simplifications until no more changes occur.  Then    we rebuild the operation.  */
end_comment

begin_function
specifier|static
name|rtx
name|simplify_plus_minus
parameter_list|(
name|code
parameter_list|,
name|mode
parameter_list|,
name|op0
parameter_list|,
name|op1
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
block|{
name|rtx
name|ops
index|[
literal|8
index|]
decl_stmt|;
name|int
name|negs
index|[
literal|8
index|]
decl_stmt|;
name|rtx
name|result
decl_stmt|,
name|tem
decl_stmt|;
name|int
name|n_ops
init|=
literal|2
decl_stmt|,
name|input_ops
init|=
literal|2
decl_stmt|,
name|input_consts
init|=
literal|0
decl_stmt|,
name|n_consts
init|=
literal|0
decl_stmt|;
name|int
name|first
init|=
literal|1
decl_stmt|,
name|negate
init|=
literal|0
decl_stmt|,
name|changed
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ops
argument_list|,
sizeof|sizeof
name|ops
argument_list|)
expr_stmt|;
comment|/* Set up the two operands and then expand them until nothing has been      changed.  If we run out of room in our array, give up; this should      almost never happen.  */
name|ops
index|[
literal|0
index|]
operator|=
name|op0
operator|,
name|ops
index|[
literal|1
index|]
operator|=
name|op1
operator|,
name|negs
index|[
literal|0
index|]
operator|=
literal|0
operator|,
name|negs
index|[
literal|1
index|]
operator|=
operator|(
name|code
operator|==
name|MINUS
operator|)
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|changed
condition|)
block|{
name|changed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_ops
condition|;
name|i
operator|++
control|)
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|ops
index|[
name|i
index|]
argument_list|)
condition|)
block|{
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
if|if
condition|(
name|n_ops
operator|==
literal|7
condition|)
return|return
literal|0
return|;
name|ops
index|[
name|n_ops
index|]
operator|=
name|XEXP
argument_list|(
name|ops
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|negs
index|[
name|n_ops
operator|++
index|]
operator|=
name|GET_CODE
argument_list|(
name|ops
index|[
name|i
index|]
argument_list|)
operator|==
name|MINUS
condition|?
operator|!
name|negs
index|[
name|i
index|]
else|:
name|negs
index|[
name|i
index|]
expr_stmt|;
name|ops
index|[
name|i
index|]
operator|=
name|XEXP
argument_list|(
name|ops
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|input_ops
operator|++
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|NEG
case|:
name|ops
index|[
name|i
index|]
operator|=
name|XEXP
argument_list|(
name|ops
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|negs
index|[
name|i
index|]
operator|=
operator|!
name|negs
index|[
name|i
index|]
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|CONST
case|:
name|ops
index|[
name|i
index|]
operator|=
name|XEXP
argument_list|(
name|ops
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|input_consts
operator|++
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|NOT
case|:
comment|/* ~a -> (-a - 1) */
if|if
condition|(
name|n_ops
operator|!=
literal|7
condition|)
block|{
name|ops
index|[
name|n_ops
index|]
operator|=
name|constm1_rtx
expr_stmt|;
name|negs
index|[
name|n_ops
operator|++
index|]
operator|=
name|negs
index|[
name|i
index|]
expr_stmt|;
name|ops
index|[
name|i
index|]
operator|=
name|XEXP
argument_list|(
name|ops
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|negs
index|[
name|i
index|]
operator|=
operator|!
name|negs
index|[
name|i
index|]
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|CONST_INT
case|:
if|if
condition|(
name|negs
index|[
name|i
index|]
condition|)
name|ops
index|[
name|i
index|]
operator|=
name|GEN_INT
argument_list|(
operator|-
name|INTVAL
argument_list|(
name|ops
index|[
name|i
index|]
argument_list|)
argument_list|)
operator|,
name|negs
index|[
name|i
index|]
operator|=
literal|0
operator|,
name|changed
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
comment|/* If we only have two operands, we can't do anything.  */
if|if
condition|(
name|n_ops
operator|<=
literal|2
condition|)
return|return
literal|0
return|;
comment|/* Now simplify each pair of operands until nothing changes.  The first      time through just simplify constants against each other.  */
name|changed
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|changed
condition|)
block|{
name|changed
operator|=
name|first
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_ops
operator|-
literal|1
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|n_ops
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|ops
index|[
name|i
index|]
operator|!=
literal|0
operator|&&
name|ops
index|[
name|j
index|]
operator|!=
literal|0
operator|&&
operator|(
operator|!
name|first
operator|||
operator|(
name|CONSTANT_P
argument_list|(
name|ops
index|[
name|i
index|]
argument_list|)
operator|&&
name|CONSTANT_P
argument_list|(
name|ops
index|[
name|j
index|]
argument_list|)
operator|)
operator|)
condition|)
block|{
name|rtx
name|lhs
init|=
name|ops
index|[
name|i
index|]
decl_stmt|,
name|rhs
init|=
name|ops
index|[
name|j
index|]
decl_stmt|;
name|enum
name|rtx_code
name|ncode
init|=
name|PLUS
decl_stmt|;
if|if
condition|(
name|negs
index|[
name|i
index|]
operator|&&
operator|!
name|negs
index|[
name|j
index|]
condition|)
name|lhs
operator|=
name|ops
index|[
name|j
index|]
operator|,
name|rhs
operator|=
name|ops
index|[
name|i
index|]
operator|,
name|ncode
operator|=
name|MINUS
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|negs
index|[
name|i
index|]
operator|&&
name|negs
index|[
name|j
index|]
condition|)
name|ncode
operator|=
name|MINUS
expr_stmt|;
name|tem
operator|=
name|simplify_binary_operation
argument_list|(
name|ncode
argument_list|,
name|mode
argument_list|,
name|lhs
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
block|{
name|ops
index|[
name|i
index|]
operator|=
name|tem
operator|,
name|ops
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
name|negs
index|[
name|i
index|]
operator|=
name|negs
index|[
name|i
index|]
operator|&&
name|negs
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|NEG
condition|)
name|ops
index|[
name|i
index|]
operator|=
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
operator|,
name|negs
index|[
name|i
index|]
operator|=
operator|!
name|negs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|ops
index|[
name|i
index|]
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|negs
index|[
name|i
index|]
condition|)
name|ops
index|[
name|i
index|]
operator|=
name|GEN_INT
argument_list|(
operator|-
name|INTVAL
argument_list|(
name|ops
index|[
name|i
index|]
argument_list|)
argument_list|)
operator|,
name|negs
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|first
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Pack all the operands to the lower-numbered entries and give up if      we didn't reduce the number of operands we had.  Make sure we      count a CONST as two operands.  If we have the same number of      operands, but have made more CONSTs than we had, this is also      an improvement, so accept it.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_ops
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|ops
index|[
name|j
index|]
operator|!=
literal|0
condition|)
block|{
name|ops
index|[
name|i
index|]
operator|=
name|ops
index|[
name|j
index|]
operator|,
name|negs
index|[
name|i
operator|++
index|]
operator|=
name|negs
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|ops
index|[
name|j
index|]
argument_list|)
operator|==
name|CONST
condition|)
name|n_consts
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|+
name|n_consts
operator|>
name|input_ops
operator|||
operator|(
name|i
operator|+
name|n_consts
operator|==
name|input_ops
operator|&&
name|n_consts
operator|<=
name|input_consts
operator|)
condition|)
return|return
literal|0
return|;
name|n_ops
operator|=
name|i
expr_stmt|;
comment|/* If we have a CONST_INT, put it last.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_ops
operator|-
literal|1
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|ops
index|[
name|i
index|]
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|tem
operator|=
name|ops
index|[
name|n_ops
operator|-
literal|1
index|]
operator|,
name|ops
index|[
name|n_ops
operator|-
literal|1
index|]
operator|=
name|ops
index|[
name|i
index|]
operator|,
name|ops
index|[
name|i
index|]
operator|=
name|tem
expr_stmt|;
name|j
operator|=
name|negs
index|[
name|n_ops
operator|-
literal|1
index|]
operator|,
name|negs
index|[
name|n_ops
operator|-
literal|1
index|]
operator|=
name|negs
index|[
name|i
index|]
operator|,
name|negs
index|[
name|i
index|]
operator|=
name|j
expr_stmt|;
block|}
comment|/* Put a non-negated operand first.  If there aren't any, make all      operands positive and negate the whole thing later.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_ops
operator|&&
name|negs
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|==
name|n_ops
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_ops
condition|;
name|i
operator|++
control|)
name|negs
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|negate
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
name|tem
operator|=
name|ops
index|[
literal|0
index|]
operator|,
name|ops
index|[
literal|0
index|]
operator|=
name|ops
index|[
name|i
index|]
operator|,
name|ops
index|[
name|i
index|]
operator|=
name|tem
expr_stmt|;
name|j
operator|=
name|negs
index|[
literal|0
index|]
operator|,
name|negs
index|[
literal|0
index|]
operator|=
name|negs
index|[
name|i
index|]
operator|,
name|negs
index|[
name|i
index|]
operator|=
name|j
expr_stmt|;
block|}
comment|/* Now make the result by performing the requested operations.  */
name|result
operator|=
name|ops
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|n_ops
condition|;
name|i
operator|++
control|)
name|result
operator|=
name|cse_gen_binary
argument_list|(
name|negs
index|[
name|i
index|]
condition|?
name|MINUS
else|:
name|PLUS
argument_list|,
name|mode
argument_list|,
name|result
argument_list|,
name|ops
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
name|negate
condition|?
name|gen_rtx_NEG
argument_list|(
name|mode
argument_list|,
name|result
argument_list|)
else|:
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make a binary operation by properly ordering the operands and     seeing if the expression folds.  */
end_comment

begin_function
specifier|static
name|rtx
name|cse_gen_binary
parameter_list|(
name|code
parameter_list|,
name|mode
parameter_list|,
name|op0
parameter_list|,
name|op1
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
block|{
name|rtx
name|tem
decl_stmt|;
comment|/* Put complex operands first and constants second if commutative.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'c'
operator|&&
operator|(
operator|(
name|CONSTANT_P
argument_list|(
name|op0
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|CONST_INT
operator|)
operator|||
operator|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|==
literal|'o'
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|!=
literal|'o'
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op0
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'o'
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|!=
literal|'o'
operator|)
operator|)
condition|)
name|tem
operator|=
name|op0
operator|,
name|op0
operator|=
name|op1
operator|,
name|op1
operator|=
name|tem
expr_stmt|;
comment|/* If this simplifies, do it.  */
name|tem
operator|=
name|simplify_binary_operation
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
return|return
name|tem
return|;
comment|/* Handle addition and subtraction of CONST_INT specially.  Otherwise,      just form the operation.  */
if|if
condition|(
name|code
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|VOIDmode
condition|)
return|return
name|plus_constant
argument_list|(
name|op0
argument_list|,
name|INTVAL
argument_list|(
name|op1
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|code
operator|==
name|MINUS
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|VOIDmode
condition|)
return|return
name|plus_constant
argument_list|(
name|op0
argument_list|,
operator|-
name|INTVAL
argument_list|(
name|op1
argument_list|)
argument_list|)
return|;
else|else
return|return
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_struct
struct|struct
name|cfc_args
block|{
comment|/* Input */
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
comment|/* Output */
name|int
name|equal
decl_stmt|,
name|op0lt
decl_stmt|,
name|op1lt
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|check_fold_consts
parameter_list|(
name|data
parameter_list|)
name|PTR
name|data
decl_stmt|;
block|{
name|struct
name|cfc_args
modifier|*
name|args
init|=
operator|(
expr|struct
name|cfc_args
operator|*
operator|)
name|data
decl_stmt|;
name|REAL_VALUE_TYPE
name|d0
decl_stmt|,
name|d1
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|d0
argument_list|,
name|args
operator|->
name|op0
argument_list|)
expr_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|d1
argument_list|,
name|args
operator|->
name|op1
argument_list|)
expr_stmt|;
name|args
operator|->
name|equal
operator|=
name|REAL_VALUES_EQUAL
argument_list|(
name|d0
argument_list|,
name|d1
argument_list|)
expr_stmt|;
name|args
operator|->
name|op0lt
operator|=
name|REAL_VALUES_LESS
argument_list|(
name|d0
argument_list|,
name|d1
argument_list|)
expr_stmt|;
name|args
operator|->
name|op1lt
operator|=
name|REAL_VALUES_LESS
argument_list|(
name|d1
argument_list|,
name|d0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Like simplify_binary_operation except used for relational operators.    MODE is the mode of the operands, not that of the result.  If MODE    is VOIDmode, both operands must also be VOIDmode and we compare the    operands in "infinite precision".     If no simplification is possible, this function returns zero.  Otherwise,    it returns either const_true_rtx or const0_rtx.  */
end_comment

begin_function
name|rtx
name|simplify_relational_operation
parameter_list|(
name|code
parameter_list|,
name|mode
parameter_list|,
name|op0
parameter_list|,
name|op1
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
block|{
name|int
name|equal
decl_stmt|,
name|op0lt
decl_stmt|,
name|op0ltu
decl_stmt|,
name|op1lt
decl_stmt|,
name|op1ltu
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
comment|/* If op0 is a compare, extract the comparison arguments from it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|COMPARE
operator|&&
name|op1
operator|==
name|const0_rtx
condition|)
name|op1
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
operator|,
name|op0
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* We can't simplify MODE_CC values since we don't know what the      actual comparison is.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|==
name|MODE_CC
ifdef|#
directive|ifdef
name|HAVE_cc0
operator|||
name|op0
operator|==
name|cc0_rtx
endif|#
directive|endif
condition|)
return|return
literal|0
return|;
comment|/* For integer comparisons of A and B maybe we can simplify A - B and can      then simplify a comparison of that with zero.  If A and B are both either      a register or a CONST_INT, this can't help; testing for these cases will      prevent infinite recursion here and speed things up.       If CODE is an unsigned comparison, then we can never do this optimization,      because it gives an incorrect result if the subtraction wraps around zero.      ANSI C defines unsigned operations such that they never overflow, and      thus such cases can not be ignored.  */
if|if
condition|(
name|INTEGRAL_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
name|op1
operator|!=
name|const0_rtx
operator|&&
operator|!
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|)
operator|&&
literal|0
operator|!=
operator|(
name|tem
operator|=
name|simplify_binary_operation
argument_list|(
name|MINUS
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
operator|)
operator|&&
name|code
operator|!=
name|GTU
operator|&&
name|code
operator|!=
name|GEU
operator|&&
name|code
operator|!=
name|LTU
operator|&&
name|code
operator|!=
name|LEU
condition|)
return|return
name|simplify_relational_operation
argument_list|(
name|signed_condition
argument_list|(
name|code
argument_list|)
argument_list|,
name|mode
argument_list|,
name|tem
argument_list|,
name|const0_rtx
argument_list|)
return|;
comment|/* For non-IEEE floating-point, if the two operands are equal, we know the      result.  */
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
operator|&&
operator|(
name|TARGET_FLOAT_FORMAT
operator|!=
name|IEEE_FLOAT_FORMAT
operator|||
operator|!
name|FLOAT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|||
name|flag_fast_math
operator|)
condition|)
name|equal
operator|=
literal|1
operator|,
name|op0lt
operator|=
literal|0
operator|,
name|op0ltu
operator|=
literal|0
operator|,
name|op1lt
operator|=
literal|0
operator|,
name|op1ltu
operator|=
literal|0
expr_stmt|;
comment|/* If the operands are floating-point constants, see if we can fold      the result.  */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|REAL_IS_NOT_DOUBLE
argument_list|)
operator|||
name|defined
argument_list|(
name|REAL_ARITHMETIC
argument_list|)
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
block|{
name|struct
name|cfc_args
name|args
decl_stmt|;
comment|/* Setup input for check_fold_consts() */
name|args
operator|.
name|op0
operator|=
name|op0
expr_stmt|;
name|args
operator|.
name|op1
operator|=
name|op1
expr_stmt|;
if|if
condition|(
name|do_float_handler
argument_list|(
name|check_fold_consts
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|args
argument_list|)
operator|==
literal|0
condition|)
comment|/* We got an exception from check_fold_consts() */
return|return
literal|0
return|;
comment|/* Receive output from check_fold_consts() */
name|equal
operator|=
name|args
operator|.
name|equal
expr_stmt|;
name|op0lt
operator|=
name|op0ltu
operator|=
name|args
operator|.
name|op0lt
expr_stmt|;
name|op1lt
operator|=
name|op1ltu
operator|=
name|args
operator|.
name|op1lt
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* not REAL_IS_NOT_DOUBLE, or REAL_ARITHMETIC */
comment|/* Otherwise, see if the operands are both integers.  */
elseif|else
if|if
condition|(
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|||
name|mode
operator|==
name|VOIDmode
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CONST_DOUBLE
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_DOUBLE
operator|||
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|)
condition|)
block|{
name|int
name|width
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|l0s
decl_stmt|,
name|h0s
decl_stmt|,
name|l1s
decl_stmt|,
name|h1s
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|l0u
decl_stmt|,
name|h0u
decl_stmt|,
name|l1u
decl_stmt|,
name|h1u
decl_stmt|;
comment|/* Get the two words comprising each integer constant.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|l0u
operator|=
name|l0s
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|h0u
operator|=
name|h0s
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|op0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|l0u
operator|=
name|l0s
operator|=
name|INTVAL
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|h0u
operator|=
name|h0s
operator|=
name|l0s
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|l1u
operator|=
name|l1s
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|h1u
operator|=
name|h1s
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|op1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|l1u
operator|=
name|l1s
operator|=
name|INTVAL
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|h1u
operator|=
name|h1s
operator|=
name|l1s
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
literal|0
expr_stmt|;
block|}
comment|/* If WIDTH is nonzero and smaller than HOST_BITS_PER_WIDE_INT, 	 we have to sign or zero-extend the values.  */
if|if
condition|(
name|width
operator|!=
literal|0
operator|&&
name|width
operator|<=
name|HOST_BITS_PER_WIDE_INT
condition|)
name|h0u
operator|=
name|h1u
operator|=
literal|0
operator|,
name|h0s
operator|=
name|l0s
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
literal|0
operator|,
name|h1s
operator|=
name|l1s
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|width
operator|!=
literal|0
operator|&&
name|width
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|l0u
operator|&=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|width
operator|)
operator|-
literal|1
expr_stmt|;
name|l1u
operator|&=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|width
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|l0s
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
condition|)
name|l0s
operator||=
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
name|width
operator|)
expr_stmt|;
if|if
condition|(
name|l1s
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
condition|)
name|l1s
operator||=
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
name|width
operator|)
expr_stmt|;
block|}
name|equal
operator|=
operator|(
name|h0u
operator|==
name|h1u
operator|&&
name|l0u
operator|==
name|l1u
operator|)
expr_stmt|;
name|op0lt
operator|=
operator|(
name|h0s
operator|<
name|h1s
operator|||
operator|(
name|h0s
operator|==
name|h1s
operator|&&
name|l0s
operator|<
name|l1s
operator|)
operator|)
expr_stmt|;
name|op1lt
operator|=
operator|(
name|h1s
operator|<
name|h0s
operator|||
operator|(
name|h1s
operator|==
name|h0s
operator|&&
name|l1s
operator|<
name|l0s
operator|)
operator|)
expr_stmt|;
name|op0ltu
operator|=
operator|(
name|h0u
operator|<
name|h1u
operator|||
operator|(
name|h0u
operator|==
name|h1u
operator|&&
name|l0u
operator|<
name|l1u
operator|)
operator|)
expr_stmt|;
name|op1ltu
operator|=
operator|(
name|h1u
operator|<
name|h0u
operator|||
operator|(
name|h1u
operator|==
name|h0u
operator|&&
name|l1u
operator|<
name|l0u
operator|)
operator|)
expr_stmt|;
block|}
comment|/* Otherwise, there are some code-specific tests we can make.  */
else|else
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ
case|:
comment|/* References to the frame plus a constant or labels cannot 	     be zero, but a SYMBOL_REF can due to #pragma weak.  */
if|if
condition|(
operator|(
operator|(
name|NONZERO_BASE_PLUS_P
argument_list|(
name|op0
argument_list|)
operator|&&
name|op1
operator|==
name|const0_rtx
operator|)
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|LABEL_REF
operator|)
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|ARG_POINTER_REGNUM
comment|/* On some machines, the ap reg can be 0 sometimes.  */
operator|&&
name|op0
operator|!=
name|arg_pointer_rtx
endif|#
directive|endif
condition|)
return|return
name|const0_rtx
return|;
break|break;
case|case
name|NE
case|:
if|if
condition|(
operator|(
operator|(
name|NONZERO_BASE_PLUS_P
argument_list|(
name|op0
argument_list|)
operator|&&
name|op1
operator|==
name|const0_rtx
operator|)
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|LABEL_REF
operator|)
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|ARG_POINTER_REGNUM
operator|&&
name|op0
operator|!=
name|arg_pointer_rtx
endif|#
directive|endif
condition|)
return|return
name|const_true_rtx
return|;
break|break;
case|case
name|GEU
case|:
comment|/* Unsigned values are never negative.  */
if|if
condition|(
name|op1
operator|==
name|const0_rtx
condition|)
return|return
name|const_true_rtx
return|;
break|break;
case|case
name|LTU
case|:
if|if
condition|(
name|op1
operator|==
name|const0_rtx
condition|)
return|return
name|const0_rtx
return|;
break|break;
case|case
name|LEU
case|:
comment|/* Unsigned values are never greater than the largest 	     unsigned value.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|==
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|&&
name|INTEGRAL_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|const_true_rtx
return|;
break|break;
case|case
name|GTU
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|==
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|&&
name|INTEGRAL_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|const0_rtx
return|;
break|break;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
comment|/* If we reach here, EQUAL, OP0LT, OP0LTU, OP1LT, and OP1LTU are set      as appropriate.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ
case|:
return|return
name|equal
condition|?
name|const_true_rtx
else|:
name|const0_rtx
return|;
case|case
name|NE
case|:
return|return
operator|!
name|equal
condition|?
name|const_true_rtx
else|:
name|const0_rtx
return|;
case|case
name|LT
case|:
return|return
name|op0lt
condition|?
name|const_true_rtx
else|:
name|const0_rtx
return|;
case|case
name|GT
case|:
return|return
name|op1lt
condition|?
name|const_true_rtx
else|:
name|const0_rtx
return|;
case|case
name|LTU
case|:
return|return
name|op0ltu
condition|?
name|const_true_rtx
else|:
name|const0_rtx
return|;
case|case
name|GTU
case|:
return|return
name|op1ltu
condition|?
name|const_true_rtx
else|:
name|const0_rtx
return|;
case|case
name|LE
case|:
return|return
name|equal
operator|||
name|op0lt
condition|?
name|const_true_rtx
else|:
name|const0_rtx
return|;
case|case
name|GE
case|:
return|return
name|equal
operator|||
name|op1lt
condition|?
name|const_true_rtx
else|:
name|const0_rtx
return|;
case|case
name|LEU
case|:
return|return
name|equal
operator|||
name|op0ltu
condition|?
name|const_true_rtx
else|:
name|const0_rtx
return|;
case|case
name|GEU
case|:
return|return
name|equal
operator|||
name|op1ltu
condition|?
name|const_true_rtx
else|:
name|const0_rtx
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Simplify CODE, an operation with result mode MODE and three operands,    OP0, OP1, and OP2.  OP0_MODE was the mode of OP0 before it became    a constant.  Return 0 if no simplifications is possible.  */
end_comment

begin_function
name|rtx
name|simplify_ternary_operation
parameter_list|(
name|code
parameter_list|,
name|mode
parameter_list|,
name|op0_mode
parameter_list|,
name|op0
parameter_list|,
name|op1
parameter_list|,
name|op2
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|,
name|op0_mode
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|,
name|op2
decl_stmt|;
block|{
name|int
name|width
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
comment|/* VOIDmode means "infinite" precision.  */
if|if
condition|(
name|width
operator|==
literal|0
condition|)
name|width
operator|=
name|HOST_BITS_PER_WIDE_INT
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|SIGN_EXTRACT
case|:
case|case
name|ZERO_EXTRACT
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|op2
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|+
name|INTVAL
argument_list|(
name|op2
argument_list|)
operator|<=
name|GET_MODE_BITSIZE
argument_list|(
name|op0_mode
argument_list|)
operator|&&
name|width
operator|<=
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
comment|/* Extracting a bit-field from a constant */
name|HOST_WIDE_INT
name|val
init|=
name|INTVAL
argument_list|(
name|op0
argument_list|)
decl_stmt|;
if|if
condition|(
name|BITS_BIG_ENDIAN
condition|)
name|val
operator|>>=
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|op0_mode
argument_list|)
operator|-
name|INTVAL
argument_list|(
name|op2
argument_list|)
operator|-
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|)
expr_stmt|;
else|else
name|val
operator|>>=
name|INTVAL
argument_list|(
name|op2
argument_list|)
expr_stmt|;
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|!=
name|INTVAL
argument_list|(
name|op1
argument_list|)
condition|)
block|{
comment|/* First zero-extend.  */
name|val
operator|&=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* If desired, propagate sign bit.  */
if|if
condition|(
name|code
operator|==
name|SIGN_EXTRACT
operator|&&
operator|(
name|val
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
name|val
operator||=
operator|~
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
block|}
comment|/* Clear the bits that don't belong in our mode, 	     unless they and our sign bit are all one. 	     So we get either a reasonable negative value or a reasonable 	     unsigned value for this mode.  */
if|if
condition|(
name|width
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
operator|(
name|val
operator|&
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
operator|)
operator|!=
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
name|val
operator|&=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|width
operator|)
operator|-
literal|1
expr_stmt|;
return|return
name|GEN_INT
argument_list|(
name|val
argument_list|)
return|;
block|}
break|break;
case|case
name|IF_THEN_ELSE
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|op0
operator|!=
name|const0_rtx
condition|?
name|op1
else|:
name|op2
return|;
comment|/* Convert a == b ? b : a to "a".  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|NE
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op1
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|op2
argument_list|)
condition|)
return|return
name|op1
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|EQ
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|op1
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op2
argument_list|)
condition|)
return|return
name|op2
return|;
elseif|else
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op0
argument_list|)
condition|)
block|{
name|rtx
name|temp
decl_stmt|;
name|temp
operator|=
name|simplify_relational_operation
argument_list|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
argument_list|,
name|op0_mode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* See if any simplifications were possible.  */
if|if
condition|(
name|temp
operator|==
name|const0_rtx
condition|)
return|return
name|op2
return|;
elseif|else
if|if
condition|(
name|temp
operator|==
name|const1_rtx
condition|)
return|return
name|op1
return|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If X is a nontrivial arithmetic operation on an argument    for which a constant value can be determined, return    the result of operating on that value, as a constant.    Otherwise, return X, possibly with one or more operands    modified by recursive calls to this function.     If X is a register whose contents are known, we do NOT    return those contents here.  equiv_constant is called to    perform that task.     INSN is the insn that we may be modifying.  If it is 0, make a copy    of X before modifying it.  */
end_comment

begin_function
specifier|static
name|rtx
name|fold_rtx
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|enum
name|machine_mode
name|mode
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|rtx
name|new
init|=
literal|0
decl_stmt|;
name|int
name|copied
init|=
literal|0
decl_stmt|;
name|int
name|must_swap
init|=
literal|0
decl_stmt|;
comment|/* Folded equivalents of first two operands of X.  */
name|rtx
name|folded_arg0
decl_stmt|;
name|rtx
name|folded_arg1
decl_stmt|;
comment|/* Constant equivalents of first three operands of X;      0 when no such equivalent is known.  */
name|rtx
name|const_arg0
decl_stmt|;
name|rtx
name|const_arg1
decl_stmt|;
name|rtx
name|const_arg2
decl_stmt|;
comment|/* The mode of the first operand of X.  We need this for sign and zero      extends.  */
name|enum
name|machine_mode
name|mode_arg0
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
name|x
return|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|REG
case|:
comment|/* No use simplifying an EXPR_LIST 	 since they are used only for lists of args 	 in a function call's REG_EQUAL note.  */
case|case
name|EXPR_LIST
case|:
comment|/* Changing anything inside an ADDRESSOF is incorrect; we don't 	 want to (e.g.,) make (addressof (const_int 0)) just because 	 the location is known to be zero.  */
case|case
name|ADDRESSOF
case|:
return|return
name|x
return|;
ifdef|#
directive|ifdef
name|HAVE_cc0
case|case
name|CC0
case|:
return|return
name|prev_insn_cc0
return|;
endif|#
directive|endif
case|case
name|PC
case|:
comment|/* If the next insn is a CODE_LABEL followed by a jump table, 	 PC's value is a LABEL_REF pointing to that label.  That 	 lets us fold switch statements on the Vax.  */
if|if
condition|(
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
name|rtx
name|next
init|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|next
operator|&&
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|CODE_LABEL
operator|&&
name|NEXT_INSN
argument_list|(
name|next
argument_list|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|NEXT_INSN
argument_list|(
name|next
argument_list|)
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|NEXT_INSN
argument_list|(
name|next
argument_list|)
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
operator|)
condition|)
return|return
name|gen_rtx_LABEL_REF
argument_list|(
name|Pmode
argument_list|,
name|next
argument_list|)
return|;
block|}
break|break;
case|case
name|SUBREG
case|:
comment|/* See if we previously assigned a constant value to this SUBREG.  */
if|if
condition|(
operator|(
name|new
operator|=
name|lookup_as_function
argument_list|(
name|x
argument_list|,
name|CONST_INT
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|new
operator|=
name|lookup_as_function
argument_list|(
name|x
argument_list|,
name|CONST_DOUBLE
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|new
return|;
comment|/* If this is a paradoxical SUBREG, we have no idea what value the 	 extra bits would have.  However, if the operand is equivalent 	 to a SUBREG whose operand is the same as our mode, and all the 	 modes are within a word, we can just use the inner operand 	 because these SUBREGs just say how to treat the register.  	 Similarly if we find an integer constant.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|enum
name|machine_mode
name|imode
init|=
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|table_elt
modifier|*
name|elt
decl_stmt|;
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|UNITS_PER_WORD
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|imode
argument_list|)
operator|<=
name|UNITS_PER_WORD
operator|&&
operator|(
name|elt
operator|=
name|lookup
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
name|HASH
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
name|imode
argument_list|)
argument_list|,
name|imode
argument_list|)
operator|)
operator|!=
literal|0
condition|)
for|for
control|(
name|elt
operator|=
name|elt
operator|->
name|first_same_value
init|;
name|elt
condition|;
name|elt
operator|=
name|elt
operator|->
name|next_same_value
control|)
block|{
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|elt
operator|->
name|exp
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|elt
operator|->
name|exp
argument_list|)
operator|==
name|VOIDmode
condition|)
return|return
name|elt
operator|->
name|exp
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|elt
operator|->
name|exp
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|elt
operator|->
name|exp
argument_list|)
argument_list|)
operator|==
name|mode
operator|&&
name|exp_equiv_p
argument_list|(
name|elt
operator|->
name|exp
argument_list|,
name|elt
operator|->
name|exp
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|copy_rtx
argument_list|(
name|SUBREG_REG
argument_list|(
name|elt
operator|->
name|exp
argument_list|)
argument_list|)
return|;
block|}
return|return
name|x
return|;
block|}
comment|/* Fold SUBREG_REG.  If it changed, see if we can simplify the SUBREG. 	 We might be able to if the SUBREG is extracting a single word in an 	 integral mode or extracting the low part.  */
name|folded_arg0
operator|=
name|fold_rtx
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|const_arg0
operator|=
name|equiv_constant
argument_list|(
name|folded_arg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|const_arg0
condition|)
name|folded_arg0
operator|=
name|const_arg0
expr_stmt|;
if|if
condition|(
name|folded_arg0
operator|!=
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|new
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|==
name|UNITS_PER_WORD
operator|&&
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|VOIDmode
condition|)
name|new
operator|=
name|operand_subword
argument_list|(
name|folded_arg0
argument_list|,
name|SUBREG_WORD
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|==
literal|0
operator|&&
name|subreg_lowpart_p
argument_list|(
name|x
argument_list|)
condition|)
name|new
operator|=
name|gen_lowpart_if_possible
argument_list|(
name|mode
argument_list|,
name|folded_arg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
condition|)
return|return
name|new
return|;
block|}
comment|/* If this is a narrowing SUBREG and our operand is a REG, see if 	 we can find an equivalence for REG that is an arithmetic operation 	 in a wider mode where both operands are paradoxical SUBREGs 	 from objects of our result mode.  In that case, we couldn't report 	 an equivalent value for that operation, since we don't know what the 	 extra bits will be.  But we can find an equivalence for this SUBREG 	 by folding that operation is the narrow mode.  This allows us to 	 fold arithmetic in narrow modes when the machine only supports 	 word-sized arithmetic.    	 Also look for a case where we have a SUBREG whose operand is the 	 same as our result.  If both modes are smaller than a word, we 	 are simply interpreting a register in different modes and we 	 can use the inner value.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|folded_arg0
argument_list|)
operator|==
name|REG
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|folded_arg0
argument_list|)
argument_list|)
operator|&&
name|subreg_lowpart_p
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|struct
name|table_elt
modifier|*
name|elt
decl_stmt|;
comment|/* We can use HASH here since we know that canon_hash won't be 	     called.  */
name|elt
operator|=
name|lookup
argument_list|(
name|folded_arg0
argument_list|,
name|HASH
argument_list|(
name|folded_arg0
argument_list|,
name|GET_MODE
argument_list|(
name|folded_arg0
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|folded_arg0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|elt
condition|)
name|elt
operator|=
name|elt
operator|->
name|first_same_value
expr_stmt|;
for|for
control|(
init|;
name|elt
condition|;
name|elt
operator|=
name|elt
operator|->
name|next_same_value
control|)
block|{
name|enum
name|rtx_code
name|eltcode
init|=
name|GET_CODE
argument_list|(
name|elt
operator|->
name|exp
argument_list|)
decl_stmt|;
comment|/* Just check for unary and binary operations.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|elt
operator|->
name|exp
argument_list|)
argument_list|)
operator|==
literal|'1'
operator|&&
name|GET_CODE
argument_list|(
name|elt
operator|->
name|exp
argument_list|)
operator|!=
name|SIGN_EXTEND
operator|&&
name|GET_CODE
argument_list|(
name|elt
operator|->
name|exp
argument_list|)
operator|!=
name|ZERO_EXTEND
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|elt
operator|->
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|elt
operator|->
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|mode
condition|)
block|{
name|rtx
name|op0
init|=
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|elt
operator|->
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|REG
operator|&&
operator|!
name|CONSTANT_P
argument_list|(
name|op0
argument_list|)
condition|)
name|op0
operator|=
name|fold_rtx
argument_list|(
name|op0
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|op0
operator|=
name|equiv_constant
argument_list|(
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
condition|)
name|new
operator|=
name|simplify_unary_operation
argument_list|(
name|GET_CODE
argument_list|(
name|elt
operator|->
name|exp
argument_list|)
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|elt
operator|->
name|exp
argument_list|)
argument_list|)
operator|==
literal|'2'
operator|||
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|elt
operator|->
name|exp
argument_list|)
argument_list|)
operator|==
literal|'c'
operator|)
operator|&&
name|eltcode
operator|!=
name|DIV
operator|&&
name|eltcode
operator|!=
name|MOD
operator|&&
name|eltcode
operator|!=
name|UDIV
operator|&&
name|eltcode
operator|!=
name|UMOD
operator|&&
name|eltcode
operator|!=
name|ASHIFTRT
operator|&&
name|eltcode
operator|!=
name|LSHIFTRT
operator|&&
name|eltcode
operator|!=
name|ROTATE
operator|&&
name|eltcode
operator|!=
name|ROTATERT
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|elt
operator|->
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|elt
operator|->
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|mode
operator|)
operator|)
operator|||
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|elt
operator|->
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|elt
operator|->
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|elt
operator|->
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|==
name|mode
operator|)
operator|)
operator|||
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|elt
operator|->
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|op0
init|=
name|gen_lowpart_common
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|elt
operator|->
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|gen_lowpart_common
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|elt
operator|->
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|op0
operator|&&
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|REG
operator|&&
operator|!
name|CONSTANT_P
argument_list|(
name|op0
argument_list|)
condition|)
name|op0
operator|=
name|fold_rtx
argument_list|(
name|op0
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
condition|)
name|op0
operator|=
name|equiv_constant
argument_list|(
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|REG
operator|&&
operator|!
name|CONSTANT_P
argument_list|(
name|op1
argument_list|)
condition|)
name|op1
operator|=
name|fold_rtx
argument_list|(
name|op1
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
condition|)
name|op1
operator|=
name|equiv_constant
argument_list|(
name|op1
argument_list|)
expr_stmt|;
comment|/* If we are looking for the low SImode part of  		     (ashift:DI c (const_int 32)), it doesn't work 		     to compute that in SImode, because a 32-bit shift 		     in SImode is unpredictable.  We know the value is 0.  */
if|if
condition|(
name|op0
operator|&&
name|op1
operator|&&
name|GET_CODE
argument_list|(
name|elt
operator|->
name|exp
argument_list|)
operator|==
name|ASHIFT
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|>=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|<
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|elt
operator|->
name|exp
argument_list|)
argument_list|)
condition|)
comment|/* If the count fits in the inner mode's width, 			   but exceeds the outer mode's width, 			   the value will get truncated to 0 			   by the subreg.  */
name|new
operator|=
name|const0_rtx
expr_stmt|;
else|else
comment|/* If the count exceeds even the inner mode's width, 			   don't fold this expression.  */
name|new
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op0
operator|&&
name|op1
condition|)
name|new
operator|=
name|simplify_binary_operation
argument_list|(
name|GET_CODE
argument_list|(
name|elt
operator|->
name|exp
argument_list|)
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|elt
operator|->
name|exp
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|elt
operator|->
name|exp
argument_list|)
argument_list|)
operator|==
name|mode
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|folded_arg0
argument_list|)
argument_list|)
operator|<=
name|UNITS_PER_WORD
operator|)
operator|&&
name|exp_equiv_p
argument_list|(
name|elt
operator|->
name|exp
argument_list|,
name|elt
operator|->
name|exp
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
name|new
operator|=
name|copy_rtx
argument_list|(
name|SUBREG_REG
argument_list|(
name|elt
operator|->
name|exp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
condition|)
return|return
name|new
return|;
block|}
block|}
return|return
name|x
return|;
case|case
name|NOT
case|:
case|case
name|NEG
case|:
comment|/* If we have (NOT Y), see if Y is known to be (NOT Z). 	 If so, (NOT Y) simplifies to Z.  Similarly for NEG.  */
name|new
operator|=
name|lookup_as_function
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
condition|)
return|return
name|fold_rtx
argument_list|(
name|copy_rtx
argument_list|(
name|XEXP
argument_list|(
name|new
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
return|;
break|break;
case|case
name|MEM
case|:
comment|/* If we are not actually processing an insn, don't try to find the 	 best address.  Not only don't we care, but we could modify the 	 MEM in an invalid way since we have no insn to validate against.  */
if|if
condition|(
name|insn
operator|!=
literal|0
condition|)
name|find_best_addr
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|{
comment|/* Even if we don't fold in the insn itself, 	   we can safely do so here, in hopes of getting a constant.  */
name|rtx
name|addr
init|=
name|fold_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
name|rtx
name|base
init|=
literal|0
decl_stmt|;
name|HOST_WIDE_INT
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO_QTY_VALID_P
argument_list|(
name|REGNO
argument_list|(
name|addr
argument_list|)
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|addr
argument_list|)
operator|==
name|qty_mode
index|[
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|addr
argument_list|)
argument_list|)
index|]
operator|&&
name|qty_const
index|[
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|addr
argument_list|)
argument_list|)
index|]
operator|!=
literal|0
condition|)
name|addr
operator|=
name|qty_const
index|[
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|addr
argument_list|)
argument_list|)
index|]
expr_stmt|;
comment|/* If address is constant, split it into a base and integer offset.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|base
operator|=
name|addr
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|base
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|LO_SUM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
name|base
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|ADDRESSOF
condition|)
return|return
name|change_address
argument_list|(
name|x
argument_list|,
name|VOIDmode
argument_list|,
name|addr
argument_list|)
return|;
comment|/* If this is a constant pool reference, we can fold it into its 	   constant to allow better value tracking.  */
if|if
condition|(
name|base
operator|&&
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|base
argument_list|)
condition|)
block|{
name|rtx
name|constant
init|=
name|get_pool_constant
argument_list|(
name|base
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|const_mode
init|=
name|get_pool_mode
argument_list|(
name|base
argument_list|)
decl_stmt|;
name|rtx
name|new
decl_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|constant
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|constant
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|constant_pool_entries_cost
operator|=
name|COST
argument_list|(
name|constant
argument_list|)
expr_stmt|;
comment|/* If we are loading the full constant, we have an equivalence.  */
if|if
condition|(
name|offset
operator|==
literal|0
operator|&&
name|mode
operator|==
name|const_mode
condition|)
return|return
name|constant
return|;
comment|/* If this actually isn't a constant (weird!), we can't do 	       anything.  Otherwise, handle the two most common cases: 	       extracting a word from a multi-word constant, and extracting 	       the low-order bits.  Other cases don't seem common enough to 	       worry about.  */
if|if
condition|(
operator|!
name|CONSTANT_P
argument_list|(
name|constant
argument_list|)
condition|)
return|return
name|x
return|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|==
name|UNITS_PER_WORD
operator|&&
name|offset
operator|%
name|UNITS_PER_WORD
operator|==
literal|0
operator|&&
operator|(
name|new
operator|=
name|operand_subword
argument_list|(
name|constant
argument_list|,
name|offset
operator|/
name|UNITS_PER_WORD
argument_list|,
literal|0
argument_list|,
name|const_mode
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|new
return|;
if|if
condition|(
operator|(
operator|(
name|BYTES_BIG_ENDIAN
operator|&&
name|offset
operator|==
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|constant
argument_list|)
argument_list|)
operator|-
literal|1
operator|)
operator|||
operator|(
operator|!
name|BYTES_BIG_ENDIAN
operator|&&
name|offset
operator|==
literal|0
operator|)
operator|)
operator|&&
operator|(
name|new
operator|=
name|gen_lowpart_if_possible
argument_list|(
name|mode
argument_list|,
name|constant
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|new
return|;
block|}
comment|/* If this is a reference to a label at a known position in a jump 	   table, we also know its value.  */
if|if
condition|(
name|base
operator|&&
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|LABEL_REF
condition|)
block|{
name|rtx
name|label
init|=
name|XEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|table_insn
init|=
name|NEXT_INSN
argument_list|(
name|label
argument_list|)
decl_stmt|;
if|if
condition|(
name|table_insn
operator|&&
name|GET_CODE
argument_list|(
name|table_insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|table_insn
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
condition|)
block|{
name|rtx
name|table
init|=
name|PATTERN
argument_list|(
name|table_insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|offset
operator|>=
literal|0
operator|&&
operator|(
name|offset
operator|/
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|table
argument_list|)
argument_list|)
operator|<
name|XVECLEN
argument_list|(
name|table
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
return|return
name|XVECEXP
argument_list|(
name|table
argument_list|,
literal|0
argument_list|,
name|offset
operator|/
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|table
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|table_insn
operator|&&
name|GET_CODE
argument_list|(
name|table_insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|table_insn
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
condition|)
block|{
name|rtx
name|table
init|=
name|PATTERN
argument_list|(
name|table_insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|offset
operator|>=
literal|0
operator|&&
operator|(
name|offset
operator|/
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|table
argument_list|)
argument_list|)
operator|<
name|XVECLEN
argument_list|(
name|table
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
block|{
name|offset
operator|/=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|table
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_MINUS
argument_list|(
name|Pmode
argument_list|,
name|XVECEXP
argument_list|(
name|table
argument_list|,
literal|1
argument_list|,
name|offset
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|table
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|table
argument_list|)
operator|!=
name|Pmode
condition|)
name|new
operator|=
name|gen_rtx_TRUNCATE
argument_list|(
name|GET_MODE
argument_list|(
name|table
argument_list|)
argument_list|,
name|new
argument_list|)
expr_stmt|;
comment|/* Indicate this is a constant.  This isn't a  		       valid form of CONST, but it will only be used 		       to fold the next insns and then discarded, so 		       it should be safe.  		       Note this expression must be explicitly discarded, 		       by cse_insn, else it may end up in a REG_EQUAL note 		       and "escape" to cause problems elsewhere.  */
return|return
name|gen_rtx_CONST
argument_list|(
name|GET_MODE
argument_list|(
name|new
argument_list|)
argument_list|,
name|new
argument_list|)
return|;
block|}
block|}
block|}
return|return
name|x
return|;
block|}
case|case
name|ASM_OPERANDS
case|:
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|3
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|3
argument_list|,
name|i
argument_list|)
argument_list|,
name|fold_rtx
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|3
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|const_arg0
operator|=
literal|0
expr_stmt|;
name|const_arg1
operator|=
literal|0
expr_stmt|;
name|const_arg2
operator|=
literal|0
expr_stmt|;
name|mode_arg0
operator|=
name|VOIDmode
expr_stmt|;
comment|/* Try folding our operands.      Then see which ones have constant values known.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
name|rtx
name|arg
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|rtx
name|folded_arg
init|=
name|arg
decl_stmt|,
name|const_arg
init|=
literal|0
decl_stmt|;
name|enum
name|machine_mode
name|mode_arg
init|=
name|GET_MODE
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|rtx
name|cheap_arg
decl_stmt|,
name|expensive_arg
decl_stmt|;
name|rtx
name|replacements
index|[
literal|2
index|]
decl_stmt|;
name|int
name|j
decl_stmt|;
comment|/* Most arguments are cheap, so handle them specially.  */
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|arg
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
comment|/* This is the same as calling equiv_constant; it is duplicated 	       here for speed.  */
if|if
condition|(
name|REGNO_QTY_VALID_P
argument_list|(
name|REGNO
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|&&
name|qty_const
index|[
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|arg
argument_list|)
argument_list|)
index|]
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|qty_const
index|[
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|arg
argument_list|)
argument_list|)
index|]
argument_list|)
operator|!=
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|qty_const
index|[
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|arg
argument_list|)
argument_list|)
index|]
argument_list|)
operator|!=
name|PLUS
condition|)
name|const_arg
operator|=
name|gen_lowpart_if_possible
argument_list|(
name|GET_MODE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|qty_const
index|[
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|arg
argument_list|)
argument_list|)
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST
case|:
case|case
name|CONST_INT
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|CONST_DOUBLE
case|:
name|const_arg
operator|=
name|arg
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|HAVE_cc0
case|case
name|CC0
case|:
name|folded_arg
operator|=
name|prev_insn_cc0
expr_stmt|;
name|mode_arg
operator|=
name|prev_insn_cc0_mode
expr_stmt|;
name|const_arg
operator|=
name|equiv_constant
argument_list|(
name|folded_arg
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|folded_arg
operator|=
name|fold_rtx
argument_list|(
name|arg
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|const_arg
operator|=
name|equiv_constant
argument_list|(
name|folded_arg
argument_list|)
expr_stmt|;
block|}
comment|/* For the first three operands, see if the operand 	   is constant or equivalent to a constant.  */
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|0
case|:
name|folded_arg0
operator|=
name|folded_arg
expr_stmt|;
name|const_arg0
operator|=
name|const_arg
expr_stmt|;
name|mode_arg0
operator|=
name|mode_arg
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|folded_arg1
operator|=
name|folded_arg
expr_stmt|;
name|const_arg1
operator|=
name|const_arg
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|const_arg2
operator|=
name|const_arg
expr_stmt|;
break|break;
block|}
comment|/* Pick the least expensive of the folded argument and an 	   equivalent constant argument.  */
if|if
condition|(
name|const_arg
operator|==
literal|0
operator|||
name|const_arg
operator|==
name|folded_arg
operator|||
name|COST
argument_list|(
name|const_arg
argument_list|)
operator|>
name|COST
argument_list|(
name|folded_arg
argument_list|)
condition|)
name|cheap_arg
operator|=
name|folded_arg
operator|,
name|expensive_arg
operator|=
name|const_arg
expr_stmt|;
else|else
name|cheap_arg
operator|=
name|const_arg
operator|,
name|expensive_arg
operator|=
name|folded_arg
expr_stmt|;
comment|/* Try to replace the operand with the cheapest of the two 	   possibilities.  If it doesn't work and this is either of the first 	   two operands of a commutative operation, try swapping them. 	   If THAT fails, try the more expensive, provided it is cheaper 	   than what is already there.  */
if|if
condition|(
name|cheap_arg
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|insn
operator|==
literal|0
operator|&&
operator|!
name|copied
condition|)
block|{
name|x
operator|=
name|copy_rtx
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|copied
operator|=
literal|1
expr_stmt|;
block|}
name|replacements
index|[
literal|0
index|]
operator|=
name|cheap_arg
operator|,
name|replacements
index|[
literal|1
index|]
operator|=
name|expensive_arg
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|2
operator|&&
name|replacements
index|[
name|j
index|]
operator|&&
name|COST
argument_list|(
name|replacements
index|[
name|j
index|]
argument_list|)
operator|<
name|COST
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|replacements
index|[
name|j
index|]
argument_list|,
literal|0
argument_list|)
condition|)
break|break;
if|if
condition|(
name|code
operator|==
name|NE
operator|||
name|code
operator|==
name|EQ
operator|||
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'c'
condition|)
block|{
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
operator|-
name|i
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
operator|-
name|i
argument_list|)
argument_list|,
name|replacements
index|[
name|j
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|apply_change_group
argument_list|()
condition|)
block|{
comment|/* Swap them back to be invalid so that this loop can 		       continue and flag them to be swapped back later.  */
name|rtx
name|tem
decl_stmt|;
name|tem
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|=
name|tem
expr_stmt|;
name|must_swap
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
comment|/* Don't try to fold inside of a vector of expressions. 	     Doing nothing is harmless.  */
block|{
empty_stmt|;
block|}
block|}
comment|/* If a commutative operation, place a constant integer as the second      operand unless the first operand is also a constant integer.  Otherwise,      place any constant second unless the first operand is also a constant.  */
if|if
condition|(
name|code
operator|==
name|EQ
operator|||
name|code
operator|==
name|NE
operator|||
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'c'
condition|)
block|{
if|if
condition|(
name|must_swap
operator|||
operator|(
name|const_arg0
operator|&&
operator|(
name|const_arg1
operator|==
literal|0
operator|||
operator|(
name|GET_CODE
argument_list|(
name|const_arg0
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|const_arg1
argument_list|)
operator|!=
name|CONST_INT
operator|)
operator|)
operator|)
condition|)
block|{
specifier|register
name|rtx
name|tem
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|insn
operator|==
literal|0
operator|&&
operator|!
name|copied
condition|)
block|{
name|x
operator|=
name|copy_rtx
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|copied
operator|=
literal|1
expr_stmt|;
block|}
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|tem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|apply_change_group
argument_list|()
condition|)
block|{
name|tem
operator|=
name|const_arg0
operator|,
name|const_arg0
operator|=
name|const_arg1
operator|,
name|const_arg1
operator|=
name|tem
expr_stmt|;
name|tem
operator|=
name|folded_arg0
operator|,
name|folded_arg0
operator|=
name|folded_arg1
operator|,
name|folded_arg1
operator|=
name|tem
expr_stmt|;
block|}
block|}
block|}
comment|/* If X is an arithmetic operation, see if we can simplify it.  */
switch|switch
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
literal|'1'
case|:
block|{
name|int
name|is_const
init|=
literal|0
decl_stmt|;
comment|/* We can't simplify extension ops unless we know the 	   original mode.  */
if|if
condition|(
operator|(
name|code
operator|==
name|ZERO_EXTEND
operator|||
name|code
operator|==
name|SIGN_EXTEND
operator|)
operator|&&
name|mode_arg0
operator|==
name|VOIDmode
condition|)
break|break;
comment|/* If we had a CONST, strip it off and put it back later if we 	   fold.  */
if|if
condition|(
name|const_arg0
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|const_arg0
argument_list|)
operator|==
name|CONST
condition|)
name|is_const
operator|=
literal|1
operator|,
name|const_arg0
operator|=
name|XEXP
argument_list|(
name|const_arg0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|new
operator|=
name|simplify_unary_operation
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|const_arg0
condition|?
name|const_arg0
else|:
name|folded_arg0
argument_list|,
name|mode_arg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|!=
literal|0
operator|&&
name|is_const
condition|)
name|new
operator|=
name|gen_rtx_CONST
argument_list|(
name|mode
argument_list|,
name|new
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'<'
case|:
comment|/* See what items are actually being compared and set FOLDED_ARG[01] 	 to those values and CODE to the actual comparison code.  If any are 	 constant, set CONST_ARG0 and CONST_ARG1 appropriately.  We needn't 	 do anything if both operands are already known to be constant.  */
if|if
condition|(
name|const_arg0
operator|==
literal|0
operator|||
name|const_arg1
operator|==
literal|0
condition|)
block|{
name|struct
name|table_elt
modifier|*
name|p0
decl_stmt|,
modifier|*
name|p1
decl_stmt|;
name|rtx
name|true
init|=
name|const_true_rtx
decl_stmt|,
name|false
init|=
name|const0_rtx
decl_stmt|;
name|enum
name|machine_mode
name|mode_arg1
decl_stmt|;
ifdef|#
directive|ifdef
name|FLOAT_STORE_FLAG_VALUE
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
block|{
name|true
operator|=
name|CONST_DOUBLE_FROM_REAL_VALUE
argument_list|(
name|FLOAT_STORE_FLAG_VALUE
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|false
operator|=
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|code
operator|=
name|find_comparison_args
argument_list|(
name|code
argument_list|,
operator|&
name|folded_arg0
argument_list|,
operator|&
name|folded_arg1
argument_list|,
operator|&
name|mode_arg0
argument_list|,
operator|&
name|mode_arg1
argument_list|)
expr_stmt|;
name|const_arg0
operator|=
name|equiv_constant
argument_list|(
name|folded_arg0
argument_list|)
expr_stmt|;
name|const_arg1
operator|=
name|equiv_constant
argument_list|(
name|folded_arg1
argument_list|)
expr_stmt|;
comment|/* If the mode is VOIDmode or a MODE_CC mode, we don't know 	     what kinds of things are being compared, so we can't do 	     anything with this comparison.  */
if|if
condition|(
name|mode_arg0
operator|==
name|VOIDmode
operator|||
name|GET_MODE_CLASS
argument_list|(
name|mode_arg0
argument_list|)
operator|==
name|MODE_CC
condition|)
break|break;
comment|/* If we do not now have two constants being compared, see 	     if we can nevertheless deduce some things about the 	     comparison.  */
if|if
condition|(
name|const_arg0
operator|==
literal|0
operator|||
name|const_arg1
operator|==
literal|0
condition|)
block|{
comment|/* Is FOLDED_ARG0 frame-pointer plus a constant?  Or 		 non-explicit constant?  These aren't zero, but we 		 don't know their sign.  */
if|if
condition|(
name|const_arg1
operator|==
name|const0_rtx
operator|&&
operator|(
name|NONZERO_BASE_PLUS_P
argument_list|(
name|folded_arg0
argument_list|)
if|#
directive|if
literal|0
comment|/* Sad to say, on sysvr4, #pragma weak can make a symbol address 	  come out as 0.  */
expr||| GET_CODE (folded_arg0) == SYMBOL_REF
endif|#
directive|endif
operator|||
name|GET_CODE
argument_list|(
name|folded_arg0
argument_list|)
operator|==
name|LABEL_REF
operator|||
name|GET_CODE
argument_list|(
name|folded_arg0
argument_list|)
operator|==
name|CONST
operator|)
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|EQ
condition|)
return|return
name|false
return|;
elseif|else
if|if
condition|(
name|code
operator|==
name|NE
condition|)
return|return
name|true
return|;
block|}
comment|/* See if the two operands are the same.  We don't do this 		 for IEEE floating-point since we can't assume x == x 		 since x might be a NaN.  */
if|if
condition|(
operator|(
name|TARGET_FLOAT_FORMAT
operator|!=
name|IEEE_FLOAT_FORMAT
operator|||
operator|!
name|FLOAT_MODE_P
argument_list|(
name|mode_arg0
argument_list|)
operator|||
name|flag_fast_math
operator|)
operator|&&
operator|(
name|folded_arg0
operator|==
name|folded_arg1
operator|||
operator|(
name|GET_CODE
argument_list|(
name|folded_arg0
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|folded_arg1
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|folded_arg0
argument_list|)
argument_list|)
operator|==
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|folded_arg1
argument_list|)
argument_list|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|p0
operator|=
name|lookup
argument_list|(
name|folded_arg0
argument_list|,
operator|(
name|safe_hash
argument_list|(
name|folded_arg0
argument_list|,
name|mode_arg0
argument_list|)
operator|%
name|NBUCKETS
operator|)
argument_list|,
name|mode_arg0
argument_list|)
operator|)
operator|&&
operator|(
name|p1
operator|=
name|lookup
argument_list|(
name|folded_arg1
argument_list|,
operator|(
name|safe_hash
argument_list|(
name|folded_arg1
argument_list|,
name|mode_arg0
argument_list|)
operator|%
name|NBUCKETS
operator|)
argument_list|,
name|mode_arg0
argument_list|)
operator|)
operator|&&
name|p0
operator|->
name|first_same_value
operator|==
name|p1
operator|->
name|first_same_value
operator|)
operator|)
condition|)
return|return
operator|(
operator|(
name|code
operator|==
name|EQ
operator|||
name|code
operator|==
name|LE
operator|||
name|code
operator|==
name|GE
operator|||
name|code
operator|==
name|LEU
operator|||
name|code
operator|==
name|GEU
operator|)
condition|?
name|true
else|:
name|false
operator|)
return|;
comment|/* If FOLDED_ARG0 is a register, see if the comparison we are 		 doing now is either the same as we did before or the reverse 		 (we only check the reverse if not floating-point).  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|folded_arg0
argument_list|)
operator|==
name|REG
condition|)
block|{
name|int
name|qty
init|=
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|folded_arg0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|REGNO_QTY_VALID_P
argument_list|(
name|REGNO
argument_list|(
name|folded_arg0
argument_list|)
argument_list|)
operator|&&
operator|(
name|comparison_dominates_p
argument_list|(
name|qty_comparison_code
index|[
name|qty
index|]
argument_list|,
name|code
argument_list|)
operator|||
operator|(
name|comparison_dominates_p
argument_list|(
name|qty_comparison_code
index|[
name|qty
index|]
argument_list|,
name|reverse_condition
argument_list|(
name|code
argument_list|)
argument_list|)
operator|&&
operator|!
name|FLOAT_MODE_P
argument_list|(
name|mode_arg0
argument_list|)
operator|)
operator|)
operator|&&
operator|(
name|rtx_equal_p
argument_list|(
name|qty_comparison_const
index|[
name|qty
index|]
argument_list|,
name|folded_arg1
argument_list|)
operator|||
operator|(
name|const_arg1
operator|&&
name|rtx_equal_p
argument_list|(
name|qty_comparison_const
index|[
name|qty
index|]
argument_list|,
name|const_arg1
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|folded_arg1
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|folded_arg1
argument_list|)
argument_list|)
operator|==
name|qty_comparison_qty
index|[
name|qty
index|]
operator|)
operator|)
operator|)
condition|)
return|return
operator|(
name|comparison_dominates_p
argument_list|(
name|qty_comparison_code
index|[
name|qty
index|]
argument_list|,
name|code
argument_list|)
condition|?
name|true
else|:
name|false
operator|)
return|;
block|}
block|}
block|}
comment|/* If we are comparing against zero, see if the first operand is 	 equivalent to an IOR with a constant.  If so, we may be able to 	 determine the result of this comparison.  */
if|if
condition|(
name|const_arg1
operator|==
name|const0_rtx
condition|)
block|{
name|rtx
name|y
init|=
name|lookup_as_function
argument_list|(
name|folded_arg0
argument_list|,
name|IOR
argument_list|)
decl_stmt|;
name|rtx
name|inner_const
decl_stmt|;
if|if
condition|(
name|y
operator|!=
literal|0
operator|&&
operator|(
name|inner_const
operator|=
name|equiv_constant
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|inner_const
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|inner_const
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|int
name|sign_bitnum
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode_arg0
argument_list|)
operator|-
literal|1
decl_stmt|;
name|int
name|has_sign
init|=
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|>=
name|sign_bitnum
operator|&&
operator|(
name|INTVAL
argument_list|(
name|inner_const
argument_list|)
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|sign_bitnum
operator|)
operator|)
operator|)
decl_stmt|;
name|rtx
name|true
init|=
name|const_true_rtx
decl_stmt|,
name|false
init|=
name|const0_rtx
decl_stmt|;
ifdef|#
directive|ifdef
name|FLOAT_STORE_FLAG_VALUE
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
block|{
name|true
operator|=
name|CONST_DOUBLE_FROM_REAL_VALUE
argument_list|(
name|FLOAT_STORE_FLAG_VALUE
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|false
operator|=
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ
case|:
return|return
name|false
return|;
case|case
name|NE
case|:
return|return
name|true
return|;
case|case
name|LT
case|:
case|case
name|LE
case|:
if|if
condition|(
name|has_sign
condition|)
return|return
name|true
return|;
break|break;
case|case
name|GT
case|:
case|case
name|GE
case|:
if|if
condition|(
name|has_sign
condition|)
return|return
name|false
return|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
name|new
operator|=
name|simplify_relational_operation
argument_list|(
name|code
argument_list|,
name|mode_arg0
argument_list|,
name|const_arg0
condition|?
name|const_arg0
else|:
name|folded_arg0
argument_list|,
name|const_arg1
condition|?
name|const_arg1
else|:
name|folded_arg1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FLOAT_STORE_FLAG_VALUE
if|if
condition|(
name|new
operator|!=
literal|0
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
name|new
operator|=
operator|(
operator|(
name|new
operator|==
name|const0_rtx
operator|)
condition|?
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
else|:
name|CONST_DOUBLE_FROM_REAL_VALUE
argument_list|(
name|FLOAT_STORE_FLAG_VALUE
argument_list|,
name|mode
argument_list|)
operator|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'2'
case|:
case|case
literal|'c'
case|:
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS
case|:
comment|/* If the second operand is a LABEL_REF, see if the first is a MINUS 	     with that LABEL_REF as its second operand.  If so, the result is 	     the first operand of that MINUS.  This handles switches with an 	     ADDR_DIFF_VEC table.  */
if|if
condition|(
name|const_arg1
operator|&&
name|GET_CODE
argument_list|(
name|const_arg1
argument_list|)
operator|==
name|LABEL_REF
condition|)
block|{
name|rtx
name|y
init|=
name|GET_CODE
argument_list|(
name|folded_arg0
argument_list|)
operator|==
name|MINUS
condition|?
name|folded_arg0
else|:
name|lookup_as_function
argument_list|(
name|folded_arg0
argument_list|,
name|MINUS
argument_list|)
decl_stmt|;
if|if
condition|(
name|y
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|XEXP
argument_list|(
name|const_arg1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
return|;
comment|/* Now try for a CONST of a MINUS like the above.  */
if|if
condition|(
operator|(
name|y
operator|=
operator|(
name|GET_CODE
argument_list|(
name|folded_arg0
argument_list|)
operator|==
name|CONST
condition|?
name|folded_arg0
else|:
name|lookup_as_function
argument_list|(
name|folded_arg0
argument_list|,
name|CONST
argument_list|)
operator|)
operator|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MINUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|XEXP
argument_list|(
name|const_arg1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/* Likewise if the operands are in the other order.  */
if|if
condition|(
name|const_arg0
operator|&&
name|GET_CODE
argument_list|(
name|const_arg0
argument_list|)
operator|==
name|LABEL_REF
condition|)
block|{
name|rtx
name|y
init|=
name|GET_CODE
argument_list|(
name|folded_arg1
argument_list|)
operator|==
name|MINUS
condition|?
name|folded_arg1
else|:
name|lookup_as_function
argument_list|(
name|folded_arg1
argument_list|,
name|MINUS
argument_list|)
decl_stmt|;
if|if
condition|(
name|y
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|XEXP
argument_list|(
name|const_arg0
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
return|;
comment|/* Now try for a CONST of a MINUS like the above.  */
if|if
condition|(
operator|(
name|y
operator|=
operator|(
name|GET_CODE
argument_list|(
name|folded_arg1
argument_list|)
operator|==
name|CONST
condition|?
name|folded_arg1
else|:
name|lookup_as_function
argument_list|(
name|folded_arg1
argument_list|,
name|CONST
argument_list|)
operator|)
operator|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MINUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|XEXP
argument_list|(
name|const_arg0
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/* If second operand is a register equivalent to a negative 	     CONST_INT, see if we can find a register equivalent to the 	     positive constant.  Make a MINUS if so.  Don't do this for 	     a non-negative constant since we might then alternate between 	     chosing positive and negative constants.  Having the positive 	     constant previously-used is the more common case.  Be sure 	     the resulting constant is non-negative; if const_arg1 were 	     the smallest negative number this would overflow: depending 	     on the mode, this would either just be the same value (and 	     hence not save anything) or be incorrect.  */
if|if
condition|(
name|const_arg1
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|const_arg1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|const_arg1
argument_list|)
operator|<
literal|0
comment|/* This used to test  	         - INTVAL (const_arg1)>= 0  		 But The Sun V5.0 compilers mis-compiled that test.  So 		 instead we test for the problematic value in a more direct 		 manner and hope the Sun compilers get it correct.  */
operator|&&
name|INTVAL
argument_list|(
name|const_arg1
argument_list|)
operator|!=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|folded_arg1
argument_list|)
operator|==
name|REG
condition|)
block|{
name|rtx
name|new_const
init|=
name|GEN_INT
argument_list|(
operator|-
name|INTVAL
argument_list|(
name|const_arg1
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|table_elt
modifier|*
name|p
init|=
name|lookup
argument_list|(
name|new_const
argument_list|,
name|safe_hash
argument_list|(
name|new_const
argument_list|,
name|mode
argument_list|)
operator|%
name|NBUCKETS
argument_list|,
name|mode
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
condition|)
for|for
control|(
name|p
operator|=
name|p
operator|->
name|first_same_value
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next_same_value
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
operator|->
name|exp
argument_list|)
operator|==
name|REG
condition|)
return|return
name|cse_gen_binary
argument_list|(
name|MINUS
argument_list|,
name|mode
argument_list|,
name|folded_arg0
argument_list|,
name|canon_reg
argument_list|(
name|p
operator|->
name|exp
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|)
return|;
block|}
goto|goto
name|from_plus
goto|;
case|case
name|MINUS
case|:
comment|/* If we have (MINUS Y C), see if Y is known to be (PLUS Z C2). 	     If so, produce (PLUS Z C2-C).  */
if|if
condition|(
name|const_arg1
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|const_arg1
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|rtx
name|y
init|=
name|lookup_as_function
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|PLUS
argument_list|)
decl_stmt|;
if|if
condition|(
name|y
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|fold_rtx
argument_list|(
name|plus_constant
argument_list|(
name|copy_rtx
argument_list|(
name|y
argument_list|)
argument_list|,
operator|-
name|INTVAL
argument_list|(
name|const_arg1
argument_list|)
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
return|;
block|}
comment|/* ... fall through ...  */
name|from_plus
label|:
case|case
name|SMIN
case|:
case|case
name|SMAX
case|:
case|case
name|UMIN
case|:
case|case
name|UMAX
case|:
case|case
name|IOR
case|:
case|case
name|AND
case|:
case|case
name|XOR
case|:
case|case
name|MULT
case|:
case|case
name|DIV
case|:
case|case
name|UDIV
case|:
case|case
name|ASHIFT
case|:
case|case
name|LSHIFTRT
case|:
case|case
name|ASHIFTRT
case|:
comment|/* If we have (<op><reg><const_int>) for an associative OP and REG 	     is known to be of similar form, we may be able to replace the 	     operation with a combined operation.  This may eliminate the 	     intermediate operation if every use is simplified in this way. 	     Note that the similar optimization done by combine.c only works 	     if the intermediate operation's result has only one reference.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|folded_arg0
argument_list|)
operator|==
name|REG
operator|&&
name|const_arg1
operator|&&
name|GET_CODE
argument_list|(
name|const_arg1
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|int
name|is_shift
init|=
operator|(
name|code
operator|==
name|ASHIFT
operator|||
name|code
operator|==
name|ASHIFTRT
operator|||
name|code
operator|==
name|LSHIFTRT
operator|)
decl_stmt|;
name|rtx
name|y
init|=
name|lookup_as_function
argument_list|(
name|folded_arg0
argument_list|,
name|code
argument_list|)
decl_stmt|;
name|rtx
name|inner_const
decl_stmt|;
name|enum
name|rtx_code
name|associate_code
decl_stmt|;
name|rtx
name|new_const
decl_stmt|;
if|if
condition|(
name|y
operator|==
literal|0
operator|||
literal|0
operator|==
operator|(
name|inner_const
operator|=
name|equiv_constant
argument_list|(
name|fold_rtx
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|inner_const
argument_list|)
operator|!=
name|CONST_INT
comment|/* If we have compiled a statement like 		     "if (x == (x& mask1))", and now are looking at 		     "x& mask2", we will have a case where the first operand 		     of Y is the same as our first operand.  Unless we detect 		     this case, an infinite loop will result.  */
operator|||
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
operator|==
name|folded_arg0
condition|)
break|break;
comment|/* Don't associate these operations if they are a PLUS with the 		 same constant and it is a power of two.  These might be doable 		 with a pre- or post-increment.  Similarly for two subtracts of 		 identical powers of two with post decrement.  */
if|if
condition|(
name|code
operator|==
name|PLUS
operator|&&
name|INTVAL
argument_list|(
name|const_arg1
argument_list|)
operator|==
name|INTVAL
argument_list|(
name|inner_const
argument_list|)
operator|&&
operator|(
operator|(
name|HAVE_PRE_INCREMENT
operator|&&
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|const_arg1
argument_list|)
argument_list|)
operator|>=
literal|0
operator|)
operator|||
operator|(
name|HAVE_POST_INCREMENT
operator|&&
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|const_arg1
argument_list|)
argument_list|)
operator|>=
literal|0
operator|)
operator|||
operator|(
name|HAVE_PRE_DECREMENT
operator|&&
name|exact_log2
argument_list|(
operator|-
name|INTVAL
argument_list|(
name|const_arg1
argument_list|)
argument_list|)
operator|>=
literal|0
operator|)
operator|||
operator|(
name|HAVE_POST_DECREMENT
operator|&&
name|exact_log2
argument_list|(
operator|-
name|INTVAL
argument_list|(
name|const_arg1
argument_list|)
argument_list|)
operator|>=
literal|0
operator|)
operator|)
condition|)
break|break;
comment|/* Compute the code used to compose the constants.  For example, 		 A/C1/C2 is A/(C1 * C2), so if CODE == DIV, we want MULT.  */
name|associate_code
operator|=
operator|(
name|code
operator|==
name|MULT
operator|||
name|code
operator|==
name|DIV
operator|||
name|code
operator|==
name|UDIV
condition|?
name|MULT
else|:
name|is_shift
operator|||
name|code
operator|==
name|PLUS
operator|||
name|code
operator|==
name|MINUS
condition|?
name|PLUS
else|:
name|code
operator|)
expr_stmt|;
name|new_const
operator|=
name|simplify_binary_operation
argument_list|(
name|associate_code
argument_list|,
name|mode
argument_list|,
name|const_arg1
argument_list|,
name|inner_const
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_const
operator|==
literal|0
condition|)
break|break;
comment|/* If we are associating shift operations, don't let this 		 produce a shift of the size of the object or larger. 		 This could occur when we follow a sign-extend by a right 		 shift on a machine that does a sign-extend as a pair 		 of shifts.  */
if|if
condition|(
name|is_shift
operator|&&
name|GET_CODE
argument_list|(
name|new_const
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|new_const
argument_list|)
operator|>=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
condition|)
block|{
comment|/* As an exception, we can turn an ASHIFTRT of this 		     form into a shift of the number of bits - 1.  */
if|if
condition|(
name|code
operator|==
name|ASHIFTRT
condition|)
name|new_const
operator|=
name|GEN_INT
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
name|y
operator|=
name|copy_rtx
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If Y contains our first operand (the most common way this 		 can happen is if Y is a MEM), we would do into an infinite 		 loop if we tried to fold it.  So don't in that case.  */
if|if
condition|(
operator|!
name|reg_mentioned_p
argument_list|(
name|folded_arg0
argument_list|,
name|y
argument_list|)
condition|)
name|y
operator|=
name|fold_rtx
argument_list|(
name|y
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return
name|cse_gen_binary
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|y
argument_list|,
name|new_const
argument_list|)
return|;
block|}
break|break;
default|default:
break|break;
block|}
name|new
operator|=
name|simplify_binary_operation
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|const_arg0
condition|?
name|const_arg0
else|:
name|folded_arg0
argument_list|,
name|const_arg1
condition|?
name|const_arg1
else|:
name|folded_arg1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
comment|/* (lo_sum (high X) X) is simply X.  */
if|if
condition|(
name|code
operator|==
name|LO_SUM
operator|&&
name|const_arg0
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|const_arg0
argument_list|)
operator|==
name|HIGH
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|const_arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|const_arg1
argument_list|)
condition|)
return|return
name|const_arg1
return|;
break|break;
case|case
literal|'3'
case|:
case|case
literal|'b'
case|:
name|new
operator|=
name|simplify_ternary_operation
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|mode_arg0
argument_list|,
name|const_arg0
condition|?
name|const_arg0
else|:
name|folded_arg0
argument_list|,
name|const_arg1
condition|?
name|const_arg1
else|:
name|folded_arg1
argument_list|,
name|const_arg2
condition|?
name|const_arg2
else|:
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
comment|/* Always eliminate CONSTANT_P_RTX at this stage. */
if|if
condition|(
name|code
operator|==
name|CONSTANT_P_RTX
condition|)
return|return
operator|(
name|const_arg0
condition|?
name|const1_rtx
else|:
name|const0_rtx
operator|)
return|;
break|break;
block|}
return|return
name|new
condition|?
name|new
else|:
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a constant value currently equivalent to X.    Return 0 if we don't know one.  */
end_comment

begin_function
specifier|static
name|rtx
name|equiv_constant
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO_QTY_VALID_P
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&&
name|qty_const
index|[
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
index|]
condition|)
name|x
operator|=
name|gen_lowpart_if_possible
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|qty_const
index|[
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
operator|||
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|x
return|;
comment|/* If X is a MEM, try to fold it outside the context of any insn to see if      it might be equivalent to a constant.  That handles the case where it      is a constant-pool reference.  Then try to look it up in the hash table      in case it is something whose value we have seen before.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|struct
name|table_elt
modifier|*
name|elt
decl_stmt|;
name|x
operator|=
name|fold_rtx
argument_list|(
name|x
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|x
return|;
name|elt
operator|=
name|lookup
argument_list|(
name|x
argument_list|,
name|safe_hash
argument_list|(
name|x
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|%
name|NBUCKETS
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|elt
operator|==
literal|0
condition|)
return|return
literal|0
return|;
for|for
control|(
name|elt
operator|=
name|elt
operator|->
name|first_same_value
init|;
name|elt
condition|;
name|elt
operator|=
name|elt
operator|->
name|next_same_value
control|)
if|if
condition|(
name|elt
operator|->
name|is_const
operator|&&
name|CONSTANT_P
argument_list|(
name|elt
operator|->
name|exp
argument_list|)
condition|)
return|return
name|elt
operator|->
name|exp
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Assuming that X is an rtx (e.g., MEM, REG or SUBREG) for a fixed-point    number, return an rtx (MEM, SUBREG, or CONST_INT) that refers to the    least-significant part of X.    MODE specifies how big a part of X to return.       If the requested operation cannot be done, 0 is returned.     This is similar to gen_lowpart in emit-rtl.c.  */
end_comment

begin_function
name|rtx
name|gen_lowpart_if_possible
parameter_list|(
name|mode
parameter_list|,
name|x
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
specifier|register
name|rtx
name|x
decl_stmt|;
block|{
name|rtx
name|result
init|=
name|gen_lowpart_common
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
condition|)
return|return
name|result
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
block|{
comment|/* This is the only other case we handle.  */
specifier|register
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|rtx
name|new
decl_stmt|;
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
name|offset
operator|=
operator|(
name|MAX
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|UNITS_PER_WORD
argument_list|)
operator|-
name|MAX
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
name|UNITS_PER_WORD
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
comment|/* Adjust the address so that the address-after-the-data is 	   unchanged.  */
name|offset
operator|-=
operator|(
name|MIN
argument_list|(
name|UNITS_PER_WORD
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
operator|-
name|MIN
argument_list|(
name|UNITS_PER_WORD
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|new
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|RTX_UNCHANGING_P
argument_list|(
name|new
argument_list|)
operator|=
name|RTX_UNCHANGING_P
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|MEM_COPY_ATTRIBUTES
argument_list|(
name|new
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given INSN, a jump insn, TAKEN indicates if we are following the "taken"    branch.  It will be zero if not.     In certain cases, this can cause us to add an equivalence.  For example,    if we are following the taken case of     	if (i == 2)    we can add the fact that `i' and '2' are now equivalent.     In any case, we can record that this comparison was passed.  If the same    comparison is seen later, we will know its value.  */
end_comment

begin_function
specifier|static
name|void
name|record_jump_equiv
parameter_list|(
name|insn
parameter_list|,
name|taken
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|int
name|taken
decl_stmt|;
block|{
name|int
name|cond_known_true
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|,
name|mode0
decl_stmt|,
name|mode1
decl_stmt|;
name|int
name|reversed_nonequality
init|=
literal|0
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
comment|/* Ensure this is the right kind of insn.  */
if|if
condition|(
operator|!
name|condjump_p
argument_list|(
name|insn
argument_list|)
operator|||
name|simplejump_p
argument_list|(
name|insn
argument_list|)
condition|)
return|return;
comment|/* See if this jump condition is known true or false.  */
if|if
condition|(
name|taken
condition|)
name|cond_known_true
operator|=
operator|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
literal|2
argument_list|)
operator|==
name|pc_rtx
operator|)
expr_stmt|;
else|else
name|cond_known_true
operator|=
operator|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|pc_rtx
operator|)
expr_stmt|;
comment|/* Get the type of comparison being done and the operands being compared.      If we had to reverse a non-equality condition, record that fact so we      know that it isn't valid for floating-point.  */
name|code
operator|=
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|fold_rtx
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|op1
operator|=
name|fold_rtx
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|code
operator|=
name|find_comparison_args
argument_list|(
name|code
argument_list|,
operator|&
name|op0
argument_list|,
operator|&
name|op1
argument_list|,
operator|&
name|mode0
argument_list|,
operator|&
name|mode1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cond_known_true
condition|)
block|{
name|reversed_nonequality
operator|=
operator|(
name|code
operator|!=
name|EQ
operator|&&
name|code
operator|!=
name|NE
operator|)
expr_stmt|;
name|code
operator|=
name|reverse_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
comment|/* The mode is the mode of the non-constant.  */
name|mode
operator|=
name|mode0
expr_stmt|;
if|if
condition|(
name|mode1
operator|!=
name|VOIDmode
condition|)
name|mode
operator|=
name|mode1
expr_stmt|;
name|record_jump_cond
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|reversed_nonequality
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We know that comparison CODE applied to OP0 and OP1 in MODE is true.    REVERSED_NONEQUALITY is nonzero if CODE had to be swapped.    Make any useful entries we can with that information.  Called from    above function and called recursively.  */
end_comment

begin_function
specifier|static
name|void
name|record_jump_cond
parameter_list|(
name|code
parameter_list|,
name|mode
parameter_list|,
name|op0
parameter_list|,
name|op1
parameter_list|,
name|reversed_nonequality
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
name|int
name|reversed_nonequality
decl_stmt|;
block|{
name|unsigned
name|op0_hash
decl_stmt|,
name|op1_hash
decl_stmt|;
name|int
name|op0_in_memory
decl_stmt|,
name|op0_in_struct
decl_stmt|,
name|op1_in_memory
decl_stmt|,
name|op1_in_struct
decl_stmt|;
name|struct
name|table_elt
modifier|*
name|op0_elt
decl_stmt|,
modifier|*
name|op1_elt
decl_stmt|;
comment|/* If OP0 and OP1 are known equal, and either is a paradoxical SUBREG,      we know that they are also equal in the smaller mode (this is also      true for all smaller modes whether or not there is a SUBREG, but      is not worth testing for with no SUBREG).  */
comment|/* Note that GET_MODE (op0) may not equal MODE.  */
if|if
condition|(
name|code
operator|==
name|EQ
operator|&&
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op0
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|enum
name|machine_mode
name|inner_mode
init|=
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op0
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|tem
init|=
name|gen_lowpart_if_possible
argument_list|(
name|inner_mode
argument_list|,
name|op1
argument_list|)
decl_stmt|;
name|record_jump_cond
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|SUBREG_REG
argument_list|(
name|op0
argument_list|)
argument_list|,
name|tem
condition|?
name|tem
else|:
name|gen_rtx_SUBREG
argument_list|(
name|inner_mode
argument_list|,
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|reversed_nonequality
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
name|EQ
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op1
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|enum
name|machine_mode
name|inner_mode
init|=
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op1
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|tem
init|=
name|gen_lowpart_if_possible
argument_list|(
name|inner_mode
argument_list|,
name|op0
argument_list|)
decl_stmt|;
name|record_jump_cond
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|SUBREG_REG
argument_list|(
name|op1
argument_list|)
argument_list|,
name|tem
condition|?
name|tem
else|:
name|gen_rtx_SUBREG
argument_list|(
name|inner_mode
argument_list|,
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|reversed_nonequality
argument_list|)
expr_stmt|;
block|}
comment|/* Similarly, if this is an NE comparison, and either is a SUBREG       making a smaller mode, we know the whole thing is also NE.  */
comment|/* Note that GET_MODE (op0) may not equal MODE;      if we test MODE instead, we can get an infinite recursion      alternating between two modes each wider than MODE.  */
if|if
condition|(
name|code
operator|==
name|NE
operator|&&
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SUBREG
operator|&&
name|subreg_lowpart_p
argument_list|(
name|op0
argument_list|)
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op0
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|enum
name|machine_mode
name|inner_mode
init|=
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op0
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|tem
init|=
name|gen_lowpart_if_possible
argument_list|(
name|inner_mode
argument_list|,
name|op1
argument_list|)
decl_stmt|;
name|record_jump_cond
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|SUBREG_REG
argument_list|(
name|op0
argument_list|)
argument_list|,
name|tem
condition|?
name|tem
else|:
name|gen_rtx_SUBREG
argument_list|(
name|inner_mode
argument_list|,
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|reversed_nonequality
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
name|NE
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|SUBREG
operator|&&
name|subreg_lowpart_p
argument_list|(
name|op1
argument_list|)
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op1
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|enum
name|machine_mode
name|inner_mode
init|=
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op1
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|tem
init|=
name|gen_lowpart_if_possible
argument_list|(
name|inner_mode
argument_list|,
name|op0
argument_list|)
decl_stmt|;
name|record_jump_cond
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|SUBREG_REG
argument_list|(
name|op1
argument_list|)
argument_list|,
name|tem
condition|?
name|tem
else|:
name|gen_rtx_SUBREG
argument_list|(
name|inner_mode
argument_list|,
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|reversed_nonequality
argument_list|)
expr_stmt|;
block|}
comment|/* Hash both operands.  */
name|do_not_record
operator|=
literal|0
expr_stmt|;
name|hash_arg_in_memory
operator|=
literal|0
expr_stmt|;
name|hash_arg_in_struct
operator|=
literal|0
expr_stmt|;
name|op0_hash
operator|=
name|HASH
argument_list|(
name|op0
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|op0_in_memory
operator|=
name|hash_arg_in_memory
expr_stmt|;
name|op0_in_struct
operator|=
name|hash_arg_in_struct
expr_stmt|;
if|if
condition|(
name|do_not_record
condition|)
return|return;
name|do_not_record
operator|=
literal|0
expr_stmt|;
name|hash_arg_in_memory
operator|=
literal|0
expr_stmt|;
name|hash_arg_in_struct
operator|=
literal|0
expr_stmt|;
name|op1_hash
operator|=
name|HASH
argument_list|(
name|op1
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|op1_in_memory
operator|=
name|hash_arg_in_memory
expr_stmt|;
name|op1_in_struct
operator|=
name|hash_arg_in_struct
expr_stmt|;
if|if
condition|(
name|do_not_record
condition|)
return|return;
comment|/* Look up both operands.  */
name|op0_elt
operator|=
name|lookup
argument_list|(
name|op0
argument_list|,
name|op0_hash
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|op1_elt
operator|=
name|lookup
argument_list|(
name|op1
argument_list|,
name|op1_hash
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* If both operands are already equivalent or if they are not in the      table but are identical, do nothing.  */
if|if
condition|(
operator|(
name|op0_elt
operator|!=
literal|0
operator|&&
name|op1_elt
operator|!=
literal|0
operator|&&
name|op0_elt
operator|->
name|first_same_value
operator|==
name|op1_elt
operator|->
name|first_same_value
operator|)
operator|||
name|op0
operator|==
name|op1
operator|||
name|rtx_equal_p
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
condition|)
return|return;
comment|/* If we aren't setting two things equal all we can do is save this      comparison.   Similarly if this is floating-point.  In the latter      case, OP1 might be zero and both -0.0 and 0.0 are equal to it.      If we record the equality, we might inadvertently delete code      whose intent was to change -0 to +0.  */
if|if
condition|(
name|code
operator|!=
name|EQ
operator|||
name|FLOAT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
condition|)
block|{
comment|/* If we reversed a floating-point comparison, if OP0 is not a 	 register, or if OP1 is neither a register or constant, we can't 	 do anything.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|REG
condition|)
name|op1
operator|=
name|equiv_constant
argument_list|(
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reversed_nonequality
operator|&&
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|REG
operator|||
name|op1
operator|==
literal|0
condition|)
return|return;
comment|/* Put OP0 in the hash table if it isn't already.  This gives it a 	 new quantity number.  */
if|if
condition|(
name|op0_elt
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|insert_regs
argument_list|(
name|op0
argument_list|,
name|NULL_PTR
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|rehash_using_reg
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|op0_hash
operator|=
name|HASH
argument_list|(
name|op0
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* If OP0 is contained in OP1, this changes its hash code 		 as well.  Faster to rehash than to check, except 		 for the simple case of a constant.  */
if|if
condition|(
operator|!
name|CONSTANT_P
argument_list|(
name|op1
argument_list|)
condition|)
name|op1_hash
operator|=
name|HASH
argument_list|(
name|op1
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
name|op0_elt
operator|=
name|insert
argument_list|(
name|op0
argument_list|,
name|NULL_PTR
argument_list|,
name|op0_hash
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|op0_elt
operator|->
name|in_memory
operator|=
name|op0_in_memory
expr_stmt|;
name|op0_elt
operator|->
name|in_struct
operator|=
name|op0_in_struct
expr_stmt|;
block|}
name|qty_comparison_code
index|[
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|op0
argument_list|)
argument_list|)
index|]
operator|=
name|code
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|REG
condition|)
block|{
comment|/* Look it up again--in case op0 and op1 are the same.  */
name|op1_elt
operator|=
name|lookup
argument_list|(
name|op1
argument_list|,
name|op1_hash
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* Put OP1 in the hash table so it gets a new quantity number.  */
if|if
condition|(
name|op1_elt
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|insert_regs
argument_list|(
name|op1
argument_list|,
name|NULL_PTR
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|rehash_using_reg
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|op1_hash
operator|=
name|HASH
argument_list|(
name|op1
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
name|op1_elt
operator|=
name|insert
argument_list|(
name|op1
argument_list|,
name|NULL_PTR
argument_list|,
name|op1_hash
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|op1_elt
operator|->
name|in_memory
operator|=
name|op1_in_memory
expr_stmt|;
name|op1_elt
operator|->
name|in_struct
operator|=
name|op1_in_struct
expr_stmt|;
block|}
name|qty_comparison_qty
index|[
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|op0
argument_list|)
argument_list|)
index|]
operator|=
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|qty_comparison_const
index|[
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|op0
argument_list|)
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|qty_comparison_qty
index|[
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|op0
argument_list|)
argument_list|)
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|qty_comparison_const
index|[
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|op0
argument_list|)
argument_list|)
index|]
operator|=
name|op1
expr_stmt|;
block|}
return|return;
block|}
comment|/* If either side is still missing an equivalence, make it now,      then merge the equivalences.  */
if|if
condition|(
name|op0_elt
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|insert_regs
argument_list|(
name|op0
argument_list|,
name|NULL_PTR
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|rehash_using_reg
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|op0_hash
operator|=
name|HASH
argument_list|(
name|op0
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
name|op0_elt
operator|=
name|insert
argument_list|(
name|op0
argument_list|,
name|NULL_PTR
argument_list|,
name|op0_hash
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|op0_elt
operator|->
name|in_memory
operator|=
name|op0_in_memory
expr_stmt|;
name|op0_elt
operator|->
name|in_struct
operator|=
name|op0_in_struct
expr_stmt|;
block|}
if|if
condition|(
name|op1_elt
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|insert_regs
argument_list|(
name|op1
argument_list|,
name|NULL_PTR
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|rehash_using_reg
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|op1_hash
operator|=
name|HASH
argument_list|(
name|op1
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
name|op1_elt
operator|=
name|insert
argument_list|(
name|op1
argument_list|,
name|NULL_PTR
argument_list|,
name|op1_hash
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|op1_elt
operator|->
name|in_memory
operator|=
name|op1_in_memory
expr_stmt|;
name|op1_elt
operator|->
name|in_struct
operator|=
name|op1_in_struct
expr_stmt|;
block|}
name|merge_equiv_classes
argument_list|(
name|op0_elt
argument_list|,
name|op1_elt
argument_list|)
expr_stmt|;
name|last_jump_equiv_class
operator|=
name|op0_elt
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* CSE processing for one instruction.    First simplify sources and addresses of all assignments    in the instruction, using previously-computed equivalents values.    Then install the new sources and destinations in the table    of available values.      If LIBCALL_INSN is nonzero, don't record any equivalence made in    the insn.  It means that INSN is inside libcall block.  In this    case LIBCALL_INSN is the corresponding insn with REG_LIBCALL. */
end_comment

begin_comment
comment|/* Data on one SET contained in the instruction.  */
end_comment

begin_struct
struct|struct
name|set
block|{
comment|/* The SET rtx itself.  */
name|rtx
name|rtl
decl_stmt|;
comment|/* The SET_SRC of the rtx (the original value, if it is changing).  */
name|rtx
name|src
decl_stmt|;
comment|/* The hash-table element for the SET_SRC of the SET.  */
name|struct
name|table_elt
modifier|*
name|src_elt
decl_stmt|;
comment|/* Hash value for the SET_SRC.  */
name|unsigned
name|src_hash
decl_stmt|;
comment|/* Hash value for the SET_DEST.  */
name|unsigned
name|dest_hash
decl_stmt|;
comment|/* The SET_DEST, with SUBREG, etc., stripped.  */
name|rtx
name|inner_dest
decl_stmt|;
comment|/* Place where the pointer to the INNER_DEST was found.  */
name|rtx
modifier|*
name|inner_dest_loc
decl_stmt|;
comment|/* Nonzero if the SET_SRC is in memory.  */
name|char
name|src_in_memory
decl_stmt|;
comment|/* Nonzero if the SET_SRC is in a structure.  */
name|char
name|src_in_struct
decl_stmt|;
comment|/* Nonzero if the SET_SRC contains something      whose value cannot be predicted and understood.  */
name|char
name|src_volatile
decl_stmt|;
comment|/* Original machine mode, in case it becomes a CONST_INT.  */
name|enum
name|machine_mode
name|mode
decl_stmt|;
comment|/* A constant equivalent for SET_SRC, if any.  */
name|rtx
name|src_const
decl_stmt|;
comment|/* Hash value of constant equivalent for SET_SRC.  */
name|unsigned
name|src_const_hash
decl_stmt|;
comment|/* Table entry for constant equivalent for SET_SRC, if any.  */
name|struct
name|table_elt
modifier|*
name|src_const_elt
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|cse_insn
parameter_list|(
name|insn
parameter_list|,
name|libcall_insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|libcall_insn
decl_stmt|;
block|{
specifier|register
name|rtx
name|x
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
specifier|register
name|int
name|n_sets
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* Records what this insn does to set CC0.  */
name|rtx
name|this_insn_cc0
init|=
literal|0
decl_stmt|;
name|enum
name|machine_mode
name|this_insn_cc0_mode
init|=
name|VOIDmode
decl_stmt|;
endif|#
directive|endif
name|rtx
name|src_eqv
init|=
literal|0
decl_stmt|;
name|struct
name|table_elt
modifier|*
name|src_eqv_elt
init|=
literal|0
decl_stmt|;
name|int
name|src_eqv_volatile
decl_stmt|;
name|int
name|src_eqv_in_memory
decl_stmt|;
name|int
name|src_eqv_in_struct
decl_stmt|;
name|unsigned
name|src_eqv_hash
decl_stmt|;
name|struct
name|set
modifier|*
name|sets
decl_stmt|;
name|this_insn
operator|=
name|insn
expr_stmt|;
comment|/* Find all the SETs and CLOBBERs in this instruction.      Record all the SETs in the array `set' and count them.      Also determine whether there is a CLOBBER that invalidates      all memory references, or all references at varying addresses.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
for|for
control|(
name|tem
operator|=
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
init|;
name|tem
condition|;
name|tem
operator|=
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
name|invalidate
argument_list|(
name|SET_DEST
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
condition|)
block|{
name|sets
operator|=
operator|(
expr|struct
name|set
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|set
argument_list|)
argument_list|)
expr_stmt|;
name|sets
index|[
literal|0
index|]
operator|.
name|rtl
operator|=
name|x
expr_stmt|;
comment|/* Ignore SETs that are unconditional jumps. 	 They never need cse processing, so this does not hurt. 	 The reason is not efficiency but rather 	 so that we can test at the end for instructions 	 that have been simplified to unconditional jumps 	 and not be misled by unchanged instructions 	 that were unconditional jumps to begin with.  */
if|if
condition|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|==
name|pc_rtx
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
empty_stmt|;
comment|/* Don't count call-insns, (set (reg 0) (call ...)), as a set. 	 The hard function value register is used only once, to copy to 	 someplace else, so it isn't worth cse'ing (and on 80386 is unsafe)! 	 Ensure we invalidate the destination register.  On the 80386 no 	 other code would invalidate it since it is a fixed_reg. 	 We need not check the return of apply_change_group; see canon_reg.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|CALL
condition|)
block|{
name|canon_reg
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|apply_change_group
argument_list|()
expr_stmt|;
name|fold_rtx
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|invalidate
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
block|}
else|else
name|n_sets
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
specifier|register
name|int
name|lim
init|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|sets
operator|=
operator|(
expr|struct
name|set
operator|*
operator|)
name|alloca
argument_list|(
name|lim
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|set
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Find all regs explicitly clobbered in this insn, 	 and ensure they are not replaced with any other regs 	 elsewhere in this insn. 	 When a reg that is clobbered is also used for input, 	 we should presume that that is for a reason, 	 and we should not substitute some other register 	 which is not supposed to be clobbered. 	 Therefore, this loop cannot be merged into the one below 	 because a CALL may precede a CLOBBER and refer to the 	 value clobbered.  We must not let a canonicalization do 	 anything in that case.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lim
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|rtx
name|y
init|=
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|CLOBBER
condition|)
block|{
name|rtx
name|clobbered
init|=
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|clobbered
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|clobbered
argument_list|)
operator|==
name|SUBREG
condition|)
name|invalidate
argument_list|(
name|clobbered
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|clobbered
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|clobbered
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
name|invalidate
argument_list|(
name|XEXP
argument_list|(
name|clobbered
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|clobbered
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lim
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|rtx
name|y
init|=
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|SET
condition|)
block|{
comment|/* As above, we ignore unconditional jumps and call-insns and 		 ignore the result of apply_change_group.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|y
argument_list|)
argument_list|)
operator|==
name|CALL
condition|)
block|{
name|canon_reg
argument_list|(
name|SET_SRC
argument_list|(
name|y
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|apply_change_group
argument_list|()
expr_stmt|;
name|fold_rtx
argument_list|(
name|SET_SRC
argument_list|(
name|y
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|invalidate
argument_list|(
name|SET_DEST
argument_list|(
name|y
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SET_DEST
argument_list|(
name|y
argument_list|)
operator|==
name|pc_rtx
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|y
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
empty_stmt|;
else|else
name|sets
index|[
name|n_sets
operator|++
index|]
operator|.
name|rtl
operator|=
name|y
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|CLOBBER
condition|)
block|{
comment|/* If we clobber memory, canon the address. 		 This does nothing when a register is clobbered 		 because we have already invalidated the reg.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
name|canon_reg
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|USE
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
name|canon_reg
argument_list|(
name|y
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|CALL
condition|)
block|{
comment|/* The result of apply_change_group can be ignored; see 		 canon_reg.  */
name|canon_reg
argument_list|(
name|y
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|apply_change_group
argument_list|()
expr_stmt|;
name|fold_rtx
argument_list|(
name|y
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CLOBBER
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
name|canon_reg
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
comment|/* Canonicalize a USE of a pseudo register or memory location.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|USE
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
name|canon_reg
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CALL
condition|)
block|{
comment|/* The result of apply_change_group can be ignored; see canon_reg.  */
name|canon_reg
argument_list|(
name|x
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|apply_change_group
argument_list|()
expr_stmt|;
name|fold_rtx
argument_list|(
name|x
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* Store the equivalent value in SRC_EQV, if different, or if the DEST      is a STRICT_LOW_PART.  The latter condition is necessary because SRC_EQV      is handled specially for this case, and if it isn't set, then there will      be no equivalence for the destination.  */
if|if
condition|(
name|n_sets
operator|==
literal|1
operator|&&
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|tem
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|!
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|sets
index|[
literal|0
index|]
operator|.
name|rtl
argument_list|)
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|sets
index|[
literal|0
index|]
operator|.
name|rtl
argument_list|)
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|)
condition|)
name|src_eqv
operator|=
name|canon_reg
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
comment|/* Canonicalize sources and addresses of destinations.      We do this in a separate pass to avoid problems when a MATCH_DUP is      present in the insn pattern.  In that case, we want to ensure that      we don't break the duplicate nature of the pattern.  So we will replace      both operands at the same time.  Otherwise, we would fail to find an      equivalent substitution in the loop calling validate_change below.       We used to suppress canonicalization of DEST if it appears in SRC,      but we don't do this any more.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_sets
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
decl_stmt|;
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
decl_stmt|;
name|rtx
name|new
init|=
name|canon_reg
argument_list|(
name|src
argument_list|,
name|insn
argument_list|)
decl_stmt|;
name|int
name|insn_code
decl_stmt|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|new
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|REG
operator|&&
operator|(
operator|(
name|REGNO
argument_list|(
name|new
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
operator|!=
operator|(
name|REGNO
argument_list|(
name|src
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
operator|)
operator|)
operator|||
operator|(
name|insn_code
operator|=
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|)
operator|<
literal|0
operator|||
name|insn_n_dups
index|[
name|insn_code
index|]
operator|>
literal|0
condition|)
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
argument_list|,
name|new
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|SET_SRC
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
operator|=
name|new
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SIGN_EXTRACT
condition|)
block|{
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|1
argument_list|)
argument_list|,
name|canon_reg
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|1
argument_list|)
argument_list|,
name|insn
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|2
argument_list|)
argument_list|,
name|canon_reg
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|2
argument_list|)
argument_list|,
name|insn
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SIGN_EXTRACT
condition|)
name|dest
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
condition|)
name|canon_reg
argument_list|(
name|dest
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* Now that we have done all the replacements, we can apply the change      group and see if they all work.  Note that this will cause some      canonicalizations that would have worked individually not to be applied      because some other canonicalization didn't work, but this should not      occur often.        The result of apply_change_group can be ignored; see canon_reg.  */
name|apply_change_group
argument_list|()
expr_stmt|;
comment|/* Set sets[i].src_elt to the class each source belongs to.      Detect assignments from or to volatile things      and set set[i] to zero so they will be ignored      in the rest of this function.       Nothing in this loop changes the hash table or the register chains.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_sets
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|rtx
name|src
decl_stmt|,
name|dest
decl_stmt|;
specifier|register
name|rtx
name|src_folded
decl_stmt|;
specifier|register
name|struct
name|table_elt
modifier|*
name|elt
init|=
literal|0
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|src_eqv_here
decl_stmt|;
name|rtx
name|src_const
init|=
literal|0
decl_stmt|;
name|rtx
name|src_related
init|=
literal|0
decl_stmt|;
name|struct
name|table_elt
modifier|*
name|src_const_elt
init|=
literal|0
decl_stmt|;
name|int
name|src_cost
init|=
literal|10000
decl_stmt|,
name|src_eqv_cost
init|=
literal|10000
decl_stmt|,
name|src_folded_cost
init|=
literal|10000
decl_stmt|;
name|int
name|src_related_cost
init|=
literal|10000
decl_stmt|,
name|src_elt_cost
init|=
literal|10000
decl_stmt|;
comment|/* Set non-zero if we need to call force_const_mem on with the 	 contents of src_folded before using it.  */
name|int
name|src_folded_force_flag
init|=
literal|0
decl_stmt|;
name|dest
operator|=
name|SET_DEST
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
expr_stmt|;
name|src
operator|=
name|SET_SRC
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
expr_stmt|;
comment|/* If SRC is a constant that has no machine mode, 	 hash it with the destination's machine mode. 	 This way we can keep different modes separate.  */
name|mode
operator|=
name|GET_MODE
argument_list|(
name|src
argument_list|)
operator|==
name|VOIDmode
condition|?
name|GET_MODE
argument_list|(
name|dest
argument_list|)
else|:
name|GET_MODE
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|sets
index|[
name|i
index|]
operator|.
name|mode
operator|=
name|mode
expr_stmt|;
if|if
condition|(
name|src_eqv
condition|)
block|{
name|enum
name|machine_mode
name|eqvmode
init|=
name|mode
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|eqvmode
operator|=
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|do_not_record
operator|=
literal|0
expr_stmt|;
name|hash_arg_in_memory
operator|=
literal|0
expr_stmt|;
name|hash_arg_in_struct
operator|=
literal|0
expr_stmt|;
name|src_eqv
operator|=
name|fold_rtx
argument_list|(
name|src_eqv
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|src_eqv_hash
operator|=
name|HASH
argument_list|(
name|src_eqv
argument_list|,
name|eqvmode
argument_list|)
expr_stmt|;
comment|/* Find the equivalence class for the equivalent expression.  */
if|if
condition|(
operator|!
name|do_not_record
condition|)
name|src_eqv_elt
operator|=
name|lookup
argument_list|(
name|src_eqv
argument_list|,
name|src_eqv_hash
argument_list|,
name|eqvmode
argument_list|)
expr_stmt|;
name|src_eqv_volatile
operator|=
name|do_not_record
expr_stmt|;
name|src_eqv_in_memory
operator|=
name|hash_arg_in_memory
expr_stmt|;
name|src_eqv_in_struct
operator|=
name|hash_arg_in_struct
expr_stmt|;
block|}
comment|/* If this is a STRICT_LOW_PART assignment, src_eqv corresponds to the 	 value of the INNER register, not the destination.  So it is not 	 a valid substitution for the source.  But save it for later.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|src_eqv_here
operator|=
literal|0
expr_stmt|;
else|else
name|src_eqv_here
operator|=
name|src_eqv
expr_stmt|;
comment|/* Simplify and foldable subexpressions in SRC.  Then get the fully- 	 simplified result, which may not necessarily be valid.  */
name|src_folded
operator|=
name|fold_rtx
argument_list|(
name|src
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* ??? This caused bad code to be generated for the m68k port with -O2. 	 Suppose src is (CONST_INT -1), and that after truncation src_folded 	 is (CONST_INT 3).  Suppose src_folded is then used for src_const. 	 At the end we will add src and src_const to the same equivalence 	 class.  We now have 3 and -1 on the same equivalence class.  This 	 causes later instructions to be mis-optimized.  */
comment|/* If storing a constant in a bitfield, pre-truncate the constant 	 so we will be able to record it later.  */
block|if (GET_CODE (SET_DEST (sets[i].rtl)) == ZERO_EXTRACT 	  || GET_CODE (SET_DEST (sets[i].rtl)) == SIGN_EXTRACT) 	{ 	  rtx width = XEXP (SET_DEST (sets[i].rtl), 1);  	  if (GET_CODE (src) == CONST_INT&& GET_CODE (width) == CONST_INT&& INTVAL (width)< HOST_BITS_PER_WIDE_INT&& (INTVAL (src)& ((HOST_WIDE_INT) (-1)<< INTVAL (width)))) 	    src_folded 	      = GEN_INT (INTVAL (src)& (((HOST_WIDE_INT) 1<< INTVAL (width)) - 1)); 	}
endif|#
directive|endif
comment|/* Compute SRC's hash code, and also notice if it 	 should not be recorded at all.  In that case, 	 prevent any further processing of this assignment.  */
name|do_not_record
operator|=
literal|0
expr_stmt|;
name|hash_arg_in_memory
operator|=
literal|0
expr_stmt|;
name|hash_arg_in_struct
operator|=
literal|0
expr_stmt|;
name|sets
index|[
name|i
index|]
operator|.
name|src
operator|=
name|src
expr_stmt|;
name|sets
index|[
name|i
index|]
operator|.
name|src_hash
operator|=
name|HASH
argument_list|(
name|src
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|sets
index|[
name|i
index|]
operator|.
name|src_volatile
operator|=
name|do_not_record
expr_stmt|;
name|sets
index|[
name|i
index|]
operator|.
name|src_in_memory
operator|=
name|hash_arg_in_memory
expr_stmt|;
name|sets
index|[
name|i
index|]
operator|.
name|src_in_struct
operator|=
name|hash_arg_in_struct
expr_stmt|;
comment|/* If SRC is a MEM, there is a REG_EQUIV note for SRC, and DEST is 	 a pseudo that is set more than once, do not record SRC.  Using 	 SRC as a replacement for anything else will be incorrect in that 	 situation.  Note that this usually occurs only for stack slots, 	 in which case all the RTL would be referring to SRC, so we don't 	 lose any optimization opportunities by not having SRC in the 	 hash table.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|MEM
operator|&&
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUIV
argument_list|,
name|src
argument_list|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|REG_N_SETS
argument_list|(
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|!=
literal|1
condition|)
name|sets
index|[
name|i
index|]
operator|.
name|src_volatile
operator|=
literal|1
expr_stmt|;
if|#
directive|if
literal|0
comment|/* It is no longer clear why we used to do this, but it doesn't 	 appear to still be needed.  So let's try without it since this 	 code hurts cse'ing widened ops.  */
comment|/* If source is a perverse subreg (such as QI treated as an SI), 	 treat it as volatile.  It may do the work of an SI in one context 	 where the extra bits are not being used, but cannot replace an SI 	 in general.  */
block|if (GET_CODE (src) == SUBREG&& (GET_MODE_SIZE (GET_MODE (src))> GET_MODE_SIZE (GET_MODE (SUBREG_REG (src))))) 	sets[i].src_volatile = 1;
endif|#
directive|endif
comment|/* Locate all possible equivalent forms for SRC.  Try to replace          SRC in the insn with each cheaper equivalent.           We have the following types of equivalents: SRC itself, a folded          version, a value given in a REG_EQUAL note, or a value related 	 to a constant.           Each of these equivalents may be part of an additional class          of equivalents (if more than one is in the table, they must be in          the same class; we check for this).  	 If the source is volatile, we don't do any table lookups.           We note any constant equivalent for possible later use in a          REG_NOTE.  */
if|if
condition|(
operator|!
name|sets
index|[
name|i
index|]
operator|.
name|src_volatile
condition|)
name|elt
operator|=
name|lookup
argument_list|(
name|src
argument_list|,
name|sets
index|[
name|i
index|]
operator|.
name|src_hash
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|sets
index|[
name|i
index|]
operator|.
name|src_elt
operator|=
name|elt
expr_stmt|;
if|if
condition|(
name|elt
operator|&&
name|src_eqv_here
operator|&&
name|src_eqv_elt
condition|)
block|{
if|if
condition|(
name|elt
operator|->
name|first_same_value
operator|!=
name|src_eqv_elt
operator|->
name|first_same_value
condition|)
block|{
comment|/* The REG_EQUAL is indicating that two formerly distinct 		 classes are now equivalent.  So merge them.  */
name|merge_equiv_classes
argument_list|(
name|elt
argument_list|,
name|src_eqv_elt
argument_list|)
expr_stmt|;
name|src_eqv_hash
operator|=
name|HASH
argument_list|(
name|src_eqv
argument_list|,
name|elt
operator|->
name|mode
argument_list|)
expr_stmt|;
name|src_eqv_elt
operator|=
name|lookup
argument_list|(
name|src_eqv
argument_list|,
name|src_eqv_hash
argument_list|,
name|elt
operator|->
name|mode
argument_list|)
expr_stmt|;
block|}
name|src_eqv_here
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|src_eqv_elt
condition|)
name|elt
operator|=
name|src_eqv_elt
expr_stmt|;
comment|/* Try to find a constant somewhere and record it in `src_const'. 	 Record its table element, if any, in `src_const_elt'.  Look in 	 any known equivalences first.  (If the constant is not in the 	 table, also set `sets[i].src_const_hash').  */
if|if
condition|(
name|elt
condition|)
for|for
control|(
name|p
operator|=
name|elt
operator|->
name|first_same_value
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next_same_value
control|)
if|if
condition|(
name|p
operator|->
name|is_const
condition|)
block|{
name|src_const
operator|=
name|p
operator|->
name|exp
expr_stmt|;
name|src_const_elt
operator|=
name|elt
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|src_const
operator|==
literal|0
operator|&&
operator|(
name|CONSTANT_P
argument_list|(
name|src_folded
argument_list|)
comment|/* Consider (minus (label_ref L1) (label_ref L2)) as  		 "constant" here so we will record it. This allows us 		 to fold switch statements when an ADDR_DIFF_VEC is used.  */
operator|||
operator|(
name|GET_CODE
argument_list|(
name|src_folded
argument_list|)
operator|==
name|MINUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src_folded
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src_folded
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|)
operator|)
condition|)
name|src_const
operator|=
name|src_folded
operator|,
name|src_const_elt
operator|=
name|elt
expr_stmt|;
elseif|else
if|if
condition|(
name|src_const
operator|==
literal|0
operator|&&
name|src_eqv_here
operator|&&
name|CONSTANT_P
argument_list|(
name|src_eqv_here
argument_list|)
condition|)
name|src_const
operator|=
name|src_eqv_here
operator|,
name|src_const_elt
operator|=
name|src_eqv_elt
expr_stmt|;
comment|/* If we don't know if the constant is in the table, get its 	 hash code and look it up.  */
if|if
condition|(
name|src_const
operator|&&
name|src_const_elt
operator|==
literal|0
condition|)
block|{
name|sets
index|[
name|i
index|]
operator|.
name|src_const_hash
operator|=
name|HASH
argument_list|(
name|src_const
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|src_const_elt
operator|=
name|lookup
argument_list|(
name|src_const
argument_list|,
name|sets
index|[
name|i
index|]
operator|.
name|src_const_hash
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
name|sets
index|[
name|i
index|]
operator|.
name|src_const
operator|=
name|src_const
expr_stmt|;
name|sets
index|[
name|i
index|]
operator|.
name|src_const_elt
operator|=
name|src_const_elt
expr_stmt|;
comment|/* If the constant and our source are both in the table, mark them as 	 equivalent.  Otherwise, if a constant is in the table but the source 	 isn't, set ELT to it.  */
if|if
condition|(
name|src_const_elt
operator|&&
name|elt
operator|&&
name|src_const_elt
operator|->
name|first_same_value
operator|!=
name|elt
operator|->
name|first_same_value
condition|)
name|merge_equiv_classes
argument_list|(
name|elt
argument_list|,
name|src_const_elt
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|src_const_elt
operator|&&
name|elt
operator|==
literal|0
condition|)
name|elt
operator|=
name|src_const_elt
expr_stmt|;
comment|/* See if there is a register linearly related to a constant          equivalent of SRC.  */
if|if
condition|(
name|src_const
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|src_const
argument_list|)
operator|==
name|CONST
operator|||
operator|(
name|src_const_elt
operator|&&
name|src_const_elt
operator|->
name|related_value
operator|!=
literal|0
operator|)
operator|)
condition|)
block|{
name|src_related
operator|=
name|use_related_value
argument_list|(
name|src_const
argument_list|,
name|src_const_elt
argument_list|)
expr_stmt|;
if|if
condition|(
name|src_related
condition|)
block|{
name|struct
name|table_elt
modifier|*
name|src_related_elt
init|=
name|lookup
argument_list|(
name|src_related
argument_list|,
name|HASH
argument_list|(
name|src_related
argument_list|,
name|mode
argument_list|)
argument_list|,
name|mode
argument_list|)
decl_stmt|;
if|if
condition|(
name|src_related_elt
operator|&&
name|elt
condition|)
block|{
if|if
condition|(
name|elt
operator|->
name|first_same_value
operator|!=
name|src_related_elt
operator|->
name|first_same_value
condition|)
comment|/* This can occur when we previously saw a CONST  		       involving a SYMBOL_REF and then see the SYMBOL_REF 		       twice.  Merge the involved classes.  */
name|merge_equiv_classes
argument_list|(
name|elt
argument_list|,
name|src_related_elt
argument_list|)
expr_stmt|;
name|src_related
operator|=
literal|0
expr_stmt|;
name|src_related_elt
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|src_related_elt
operator|&&
name|elt
operator|==
literal|0
condition|)
name|elt
operator|=
name|src_related_elt
expr_stmt|;
block|}
block|}
comment|/* See if we have a CONST_INT that is already in a register in a 	 wider mode.  */
if|if
condition|(
name|src_const
operator|&&
name|src_related
operator|==
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|src_const
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<
name|BITS_PER_WORD
condition|)
block|{
name|enum
name|machine_mode
name|wider_mode
decl_stmt|;
for|for
control|(
name|wider_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
init|;
name|GET_MODE_BITSIZE
argument_list|(
name|wider_mode
argument_list|)
operator|<=
name|BITS_PER_WORD
operator|&&
name|src_related
operator|==
literal|0
condition|;
name|wider_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|wider_mode
argument_list|)
control|)
block|{
name|struct
name|table_elt
modifier|*
name|const_elt
init|=
name|lookup
argument_list|(
name|src_const
argument_list|,
name|HASH
argument_list|(
name|src_const
argument_list|,
name|wider_mode
argument_list|)
argument_list|,
name|wider_mode
argument_list|)
decl_stmt|;
if|if
condition|(
name|const_elt
operator|==
literal|0
condition|)
continue|continue;
for|for
control|(
name|const_elt
operator|=
name|const_elt
operator|->
name|first_same_value
init|;
name|const_elt
condition|;
name|const_elt
operator|=
name|const_elt
operator|->
name|next_same_value
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|const_elt
operator|->
name|exp
argument_list|)
operator|==
name|REG
condition|)
block|{
name|src_related
operator|=
name|gen_lowpart_if_possible
argument_list|(
name|mode
argument_list|,
name|const_elt
operator|->
name|exp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* Another possibility is that we have an AND with a constant in 	 a mode narrower than a word.  If so, it might have been generated 	 as part of an "if" which would narrow the AND.  If we already 	 have done the AND in a wider mode, we can use a SUBREG of that 	 value.  */
if|if
condition|(
name|flag_expensive_optimizations
operator|&&
operator|!
name|src_related
operator|&&
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|AND
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<
name|UNITS_PER_WORD
condition|)
block|{
name|enum
name|machine_mode
name|tmode
decl_stmt|;
name|rtx
name|new_and
init|=
name|gen_rtx_AND
argument_list|(
name|VOIDmode
argument_list|,
name|NULL_RTX
argument_list|,
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|tmode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
init|;
name|GET_MODE_SIZE
argument_list|(
name|tmode
argument_list|)
operator|<=
name|UNITS_PER_WORD
condition|;
name|tmode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|tmode
argument_list|)
control|)
block|{
name|rtx
name|inner
init|=
name|gen_lowpart_if_possible
argument_list|(
name|tmode
argument_list|,
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|table_elt
modifier|*
name|larger_elt
decl_stmt|;
if|if
condition|(
name|inner
condition|)
block|{
name|PUT_MODE
argument_list|(
name|new_and
argument_list|,
name|tmode
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|new_and
argument_list|,
literal|0
argument_list|)
operator|=
name|inner
expr_stmt|;
name|larger_elt
operator|=
name|lookup
argument_list|(
name|new_and
argument_list|,
name|HASH
argument_list|(
name|new_and
argument_list|,
name|tmode
argument_list|)
argument_list|,
name|tmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|larger_elt
operator|==
literal|0
condition|)
continue|continue;
for|for
control|(
name|larger_elt
operator|=
name|larger_elt
operator|->
name|first_same_value
init|;
name|larger_elt
condition|;
name|larger_elt
operator|=
name|larger_elt
operator|->
name|next_same_value
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|larger_elt
operator|->
name|exp
argument_list|)
operator|==
name|REG
condition|)
block|{
name|src_related
operator|=
name|gen_lowpart_if_possible
argument_list|(
name|mode
argument_list|,
name|larger_elt
operator|->
name|exp
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|src_related
condition|)
break|break;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|LOAD_EXTEND_OP
comment|/* See if a MEM has already been loaded with a widening operation; 	 if it has, we can use a subreg of that.  Many CISC machines 	 also have such operations, but this is only likely to be 	 beneficial these machines.  */
if|if
condition|(
name|flag_expensive_optimizations
operator|&&
name|src_related
operator|==
literal|0
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<
name|UNITS_PER_WORD
operator|)
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|do_not_record
operator|&&
name|LOAD_EXTEND_OP
argument_list|(
name|mode
argument_list|)
operator|!=
name|NIL
condition|)
block|{
name|enum
name|machine_mode
name|tmode
decl_stmt|;
comment|/* Set what we are trying to extend and the operation it might 	     have been extended with.  */
name|PUT_CODE
argument_list|(
name|memory_extend_rtx
argument_list|,
name|LOAD_EXTEND_OP
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|memory_extend_rtx
argument_list|,
literal|0
argument_list|)
operator|=
name|src
expr_stmt|;
for|for
control|(
name|tmode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
init|;
name|GET_MODE_SIZE
argument_list|(
name|tmode
argument_list|)
operator|<=
name|UNITS_PER_WORD
condition|;
name|tmode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|tmode
argument_list|)
control|)
block|{
name|struct
name|table_elt
modifier|*
name|larger_elt
decl_stmt|;
name|PUT_MODE
argument_list|(
name|memory_extend_rtx
argument_list|,
name|tmode
argument_list|)
expr_stmt|;
name|larger_elt
operator|=
name|lookup
argument_list|(
name|memory_extend_rtx
argument_list|,
name|HASH
argument_list|(
name|memory_extend_rtx
argument_list|,
name|tmode
argument_list|)
argument_list|,
name|tmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|larger_elt
operator|==
literal|0
condition|)
continue|continue;
for|for
control|(
name|larger_elt
operator|=
name|larger_elt
operator|->
name|first_same_value
init|;
name|larger_elt
condition|;
name|larger_elt
operator|=
name|larger_elt
operator|->
name|next_same_value
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|larger_elt
operator|->
name|exp
argument_list|)
operator|==
name|REG
condition|)
block|{
name|src_related
operator|=
name|gen_lowpart_if_possible
argument_list|(
name|mode
argument_list|,
name|larger_elt
operator|->
name|exp
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|src_related
condition|)
break|break;
block|}
block|}
endif|#
directive|endif
comment|/* LOAD_EXTEND_OP */
if|if
condition|(
name|src
operator|==
name|src_folded
condition|)
name|src_folded
operator|=
literal|0
expr_stmt|;
comment|/* At this point, ELT, if non-zero, points to a class of expressions          equivalent to the source of this SET and SRC, SRC_EQV, SRC_FOLDED, 	 and SRC_RELATED, if non-zero, each contain additional equivalent 	 expressions.  Prune these latter expressions by deleting expressions 	 already in the equivalence class.  	 Check for an equivalent identical to the destination.  If found, 	 this is the preferred equivalent since it will likely lead to 	 elimination of the insn.  Indicate this by placing it in 	 `src_related'.  */
if|if
condition|(
name|elt
condition|)
name|elt
operator|=
name|elt
operator|->
name|first_same_value
expr_stmt|;
for|for
control|(
name|p
operator|=
name|elt
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next_same_value
control|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|p
operator|->
name|exp
argument_list|)
decl_stmt|;
comment|/* If the expression is not valid, ignore it.  Then we do not 	     have to check for validity below.  In most cases, we can use 	     `rtx_equal_p', since canonicalization has already been done.  */
if|if
condition|(
name|code
operator|!=
name|REG
operator|&&
operator|!
name|exp_equiv_p
argument_list|(
name|p
operator|->
name|exp
argument_list|,
name|p
operator|->
name|exp
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
continue|continue;
comment|/* Also skip paradoxical subregs, unless that's what we're 	     looking for.  */
if|if
condition|(
name|code
operator|==
name|SUBREG
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|p
operator|->
name|exp
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|p
operator|->
name|exp
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
operator|!
operator|(
name|src
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_MODE
argument_list|(
name|src
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|p
operator|->
name|exp
argument_list|)
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|src
argument_list|)
argument_list|)
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|p
operator|->
name|exp
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
continue|continue;
if|if
condition|(
name|src
operator|&&
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|code
operator|&&
name|rtx_equal_p
argument_list|(
name|src
argument_list|,
name|p
operator|->
name|exp
argument_list|)
condition|)
name|src
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|src_folded
operator|&&
name|GET_CODE
argument_list|(
name|src_folded
argument_list|)
operator|==
name|code
operator|&&
name|rtx_equal_p
argument_list|(
name|src_folded
argument_list|,
name|p
operator|->
name|exp
argument_list|)
condition|)
name|src_folded
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|src_eqv_here
operator|&&
name|GET_CODE
argument_list|(
name|src_eqv_here
argument_list|)
operator|==
name|code
operator|&&
name|rtx_equal_p
argument_list|(
name|src_eqv_here
argument_list|,
name|p
operator|->
name|exp
argument_list|)
condition|)
name|src_eqv_here
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|src_related
operator|&&
name|GET_CODE
argument_list|(
name|src_related
argument_list|)
operator|==
name|code
operator|&&
name|rtx_equal_p
argument_list|(
name|src_related
argument_list|,
name|p
operator|->
name|exp
argument_list|)
condition|)
name|src_related
operator|=
literal|0
expr_stmt|;
comment|/* This is the same as the destination of the insns, we want 	     to prefer it.  Copy it to src_related.  The code below will 	     then give it a negative cost.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|code
operator|&&
name|rtx_equal_p
argument_list|(
name|p
operator|->
name|exp
argument_list|,
name|dest
argument_list|)
condition|)
name|src_related
operator|=
name|dest
expr_stmt|;
block|}
comment|/* Find the cheapest valid equivalent, trying all the available          possibilities.  Prefer items not in the hash table to ones          that are when they are equal cost.  Note that we can never          worsen an insn as the current contents will also succeed. 	 If we find an equivalent identical to the destination, use it as best, 	 since this insn will probably be eliminated in that case.  */
if|if
condition|(
name|src
condition|)
block|{
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|src
argument_list|,
name|dest
argument_list|)
condition|)
name|src_cost
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|src_cost
operator|=
name|COST
argument_list|(
name|src
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|src_eqv_here
condition|)
block|{
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|src_eqv_here
argument_list|,
name|dest
argument_list|)
condition|)
name|src_eqv_cost
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|src_eqv_cost
operator|=
name|COST
argument_list|(
name|src_eqv_here
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|src_folded
condition|)
block|{
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|src_folded
argument_list|,
name|dest
argument_list|)
condition|)
name|src_folded_cost
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|src_folded_cost
operator|=
name|COST
argument_list|(
name|src_folded
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|src_related
condition|)
block|{
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|src_related
argument_list|,
name|dest
argument_list|)
condition|)
name|src_related_cost
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|src_related_cost
operator|=
name|COST
argument_list|(
name|src_related
argument_list|)
expr_stmt|;
block|}
comment|/* If this was an indirect jump insn, a known label will really be 	 cheaper even though it looks more expensive.  */
if|if
condition|(
name|dest
operator|==
name|pc_rtx
operator|&&
name|src_const
operator|&&
name|GET_CODE
argument_list|(
name|src_const
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|src_folded
operator|=
name|src_const
operator|,
name|src_folded_cost
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Terminate loop when replacement made.  This must terminate since          the current contents will be tested and will always be valid.  */
while|while
condition|(
literal|1
condition|)
block|{
name|rtx
name|trial
decl_stmt|,
name|old_src
decl_stmt|;
comment|/* Skip invalid entries.  */
while|while
condition|(
name|elt
operator|&&
name|GET_CODE
argument_list|(
name|elt
operator|->
name|exp
argument_list|)
operator|!=
name|REG
operator|&&
operator|!
name|exp_equiv_p
argument_list|(
name|elt
operator|->
name|exp
argument_list|,
name|elt
operator|->
name|exp
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
name|elt
operator|=
name|elt
operator|->
name|next_same_value
expr_stmt|;
comment|/* A paradoxical subreg would be bad here: it'll be the right 	     size, but later may be adjusted so that the upper bits aren't 	     what we want.  So reject it.  */
if|if
condition|(
name|elt
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|elt
operator|->
name|exp
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|elt
operator|->
name|exp
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|elt
operator|->
name|exp
argument_list|)
argument_list|)
argument_list|)
operator|)
comment|/* It is okay, though, if the rtx we're trying to match 		 will ignore any of the bits we can't predict.  */
operator|&&
operator|!
operator|(
name|src
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_MODE
argument_list|(
name|src
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|elt
operator|->
name|exp
argument_list|)
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|src
argument_list|)
argument_list|)
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|elt
operator|->
name|exp
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
block|{
name|elt
operator|=
name|elt
operator|->
name|next_same_value
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|elt
condition|)
name|src_elt_cost
operator|=
name|elt
operator|->
name|cost
expr_stmt|;
comment|/* Find cheapest and skip it for the next time.   For items 	     of equal cost, use this order: 	     src_folded, src, src_eqv, src_related and hash table entry.  */
if|if
condition|(
name|src_folded_cost
operator|<=
name|src_cost
operator|&&
name|src_folded_cost
operator|<=
name|src_eqv_cost
operator|&&
name|src_folded_cost
operator|<=
name|src_related_cost
operator|&&
name|src_folded_cost
operator|<=
name|src_elt_cost
condition|)
block|{
name|trial
operator|=
name|src_folded
operator|,
name|src_folded_cost
operator|=
literal|10000
expr_stmt|;
if|if
condition|(
name|src_folded_force_flag
condition|)
name|trial
operator|=
name|force_const_mem
argument_list|(
name|mode
argument_list|,
name|trial
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|src_cost
operator|<=
name|src_eqv_cost
operator|&&
name|src_cost
operator|<=
name|src_related_cost
operator|&&
name|src_cost
operator|<=
name|src_elt_cost
condition|)
name|trial
operator|=
name|src
operator|,
name|src_cost
operator|=
literal|10000
expr_stmt|;
elseif|else
if|if
condition|(
name|src_eqv_cost
operator|<=
name|src_related_cost
operator|&&
name|src_eqv_cost
operator|<=
name|src_elt_cost
condition|)
name|trial
operator|=
name|copy_rtx
argument_list|(
name|src_eqv_here
argument_list|)
operator|,
name|src_eqv_cost
operator|=
literal|10000
expr_stmt|;
elseif|else
if|if
condition|(
name|src_related_cost
operator|<=
name|src_elt_cost
condition|)
name|trial
operator|=
name|copy_rtx
argument_list|(
name|src_related
argument_list|)
operator|,
name|src_related_cost
operator|=
literal|10000
expr_stmt|;
else|else
block|{
name|trial
operator|=
name|copy_rtx
argument_list|(
name|elt
operator|->
name|exp
argument_list|)
expr_stmt|;
name|elt
operator|=
name|elt
operator|->
name|next_same_value
expr_stmt|;
name|src_elt_cost
operator|=
literal|10000
expr_stmt|;
block|}
comment|/* We don't normally have an insn matching (set (pc) (pc)), so 	     check for this separately here.  We will delete such an 	     insn below.  	     Tablejump insns contain a USE of the table, so simply replacing 	     the operand with the constant won't match.  This is simply an 	     unconditional branch, however, and is therefore valid.  Just 	     insert the substitution here and we will delete and re-emit 	     the insn later.  */
comment|/* Keep track of the original SET_SRC so that we can fix notes 	     on libcall instructions.  */
name|old_src
operator|=
name|SET_SRC
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_sets
operator|==
literal|1
operator|&&
name|dest
operator|==
name|pc_rtx
operator|&&
operator|(
name|trial
operator|==
name|pc_rtx
operator|||
operator|(
name|GET_CODE
argument_list|(
name|trial
argument_list|)
operator|==
name|LABEL_REF
operator|&&
operator|!
name|condjump_p
argument_list|(
name|insn
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* If TRIAL is a label in front of a jump table, we are 		 really falling through the switch (this is how casesi 		 insns work), so we must branch around the table.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|trial
argument_list|)
operator|==
name|CODE_LABEL
operator|&&
name|NEXT_INSN
argument_list|(
name|trial
argument_list|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|trial
argument_list|)
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|NEXT_INSN
argument_list|(
name|trial
argument_list|)
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|NEXT_INSN
argument_list|(
name|trial
argument_list|)
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
operator|)
condition|)
name|trial
operator|=
name|gen_rtx_LABEL_REF
argument_list|(
name|Pmode
argument_list|,
name|get_label_after
argument_list|(
name|trial
argument_list|)
argument_list|)
expr_stmt|;
name|SET_SRC
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
operator|=
name|trial
expr_stmt|;
name|cse_jumps_altered
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* Look for a substitution that makes a valid insn.  */
elseif|else
if|if
condition|(
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
argument_list|,
name|trial
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* If we just made a substitution inside a libcall, then we 		 need to make the same substitution in any notes attached 		 to the RETVAL insn.  */
if|if
condition|(
name|libcall_insn
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|old_src
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|old_src
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|old_src
argument_list|)
operator|==
name|MEM
operator|)
condition|)
name|replace_rtx
argument_list|(
name|REG_NOTES
argument_list|(
name|libcall_insn
argument_list|)
argument_list|,
name|old_src
argument_list|,
name|canon_reg
argument_list|(
name|SET_SRC
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
argument_list|,
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The result of apply_change_group can be ignored; see 		 canon_reg.  */
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
argument_list|,
name|canon_reg
argument_list|(
name|SET_SRC
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
argument_list|,
name|insn
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|apply_change_group
argument_list|()
expr_stmt|;
break|break;
block|}
comment|/* If we previously found constant pool entries for  	     constants and this is a constant, try making a 	     pool entry.  Put it in src_folded unless we already have done 	     this since that is where it likely came from.  */
elseif|else
if|if
condition|(
name|constant_pool_entries_cost
operator|&&
name|CONSTANT_P
argument_list|(
name|trial
argument_list|)
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|trial
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|trial
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|TRUNCATE
operator|)
operator|&&
operator|(
name|src_folded
operator|==
literal|0
operator|||
operator|(
name|GET_CODE
argument_list|(
name|src_folded
argument_list|)
operator|!=
name|MEM
operator|&&
operator|!
name|src_folded_force_flag
operator|)
operator|)
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_CC
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
block|{
name|src_folded_force_flag
operator|=
literal|1
expr_stmt|;
name|src_folded
operator|=
name|trial
expr_stmt|;
name|src_folded_cost
operator|=
name|constant_pool_entries_cost
expr_stmt|;
block|}
block|}
name|src
operator|=
name|SET_SRC
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
expr_stmt|;
comment|/* In general, it is good to have a SET with SET_SRC == SET_DEST. 	 However, there is an important exception:  If both are registers 	 that are not the head of their equivalence class, replace SET_SRC 	 with the head of the class.  If we do not do this, we will have 	 both registers live over a portion of the basic block.  This way, 	 their lifetimes will likely abut instead of overlapping.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO_QTY_VALID_P
argument_list|(
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|&&
name|qty_mode
index|[
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
index|]
operator|==
name|GET_MODE
argument_list|(
name|dest
argument_list|)
operator|&&
name|qty_first_reg
index|[
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
index|]
operator|!=
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|src
argument_list|)
operator|==
name|REGNO
argument_list|(
name|dest
argument_list|)
comment|/* Don't do this if the original insn had a hard reg as 	     SET_SRC.  */
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|src
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|src
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
comment|/* We can't call canon_reg here because it won't do anything if 	   SRC is a hard register.  */
block|{
name|int
name|first
init|=
name|qty_first_reg
index|[
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|)
index|]
decl_stmt|;
name|rtx
name|new_src
init|=
operator|(
name|first
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|?
name|regno_reg_rtx
index|[
name|first
index|]
else|:
name|gen_rtx_REG
argument_list|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|,
name|first
argument_list|)
operator|)
decl_stmt|;
comment|/* We must use validate-change even for this, because this 	     might be a special no-op instruction, suitable only to 	     tag notes onto.  */
if|if
condition|(
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
argument_list|,
name|new_src
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|src
operator|=
name|new_src
expr_stmt|;
comment|/* If we had a constant that is cheaper than what we are now 		 setting SRC to, use that constant.  We ignored it when we 		 thought we could make this into a no-op.  */
if|if
condition|(
name|src_const
operator|&&
name|COST
argument_list|(
name|src_const
argument_list|)
operator|<
name|COST
argument_list|(
name|src
argument_list|)
operator|&&
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
argument_list|,
name|src_const
argument_list|,
literal|0
argument_list|)
condition|)
name|src
operator|=
name|src_const
expr_stmt|;
block|}
block|}
comment|/* If we made a change, recompute SRC values.  */
if|if
condition|(
name|src
operator|!=
name|sets
index|[
name|i
index|]
operator|.
name|src
condition|)
block|{
name|do_not_record
operator|=
literal|0
expr_stmt|;
name|hash_arg_in_memory
operator|=
literal|0
expr_stmt|;
name|hash_arg_in_struct
operator|=
literal|0
expr_stmt|;
name|sets
index|[
name|i
index|]
operator|.
name|src
operator|=
name|src
expr_stmt|;
name|sets
index|[
name|i
index|]
operator|.
name|src_hash
operator|=
name|HASH
argument_list|(
name|src
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|sets
index|[
name|i
index|]
operator|.
name|src_volatile
operator|=
name|do_not_record
expr_stmt|;
name|sets
index|[
name|i
index|]
operator|.
name|src_in_memory
operator|=
name|hash_arg_in_memory
expr_stmt|;
name|sets
index|[
name|i
index|]
operator|.
name|src_in_struct
operator|=
name|hash_arg_in_struct
expr_stmt|;
name|sets
index|[
name|i
index|]
operator|.
name|src_elt
operator|=
name|lookup
argument_list|(
name|src
argument_list|,
name|sets
index|[
name|i
index|]
operator|.
name|src_hash
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
comment|/* If this is a single SET, we are setting a register, and we have an 	 equivalent constant, we want to add a REG_NOTE.   We don't want 	 to write a REG_EQUAL note for a constant pseudo since verifying that 	 that pseudo hasn't been eliminated is a pain.  Such a note also 	 won't help anything.   	 Avoid a REG_EQUAL note for (CONST (MINUS (LABEL_REF) (LABEL_REF))) 	 which can be created for a reference to a compile time computable 	 entry in a jump table.  */
if|if
condition|(
name|n_sets
operator|==
literal|1
operator|&&
name|src_const
operator|&&
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|src_const
argument_list|)
operator|!=
name|REG
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|src_const
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src_const
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MINUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|src_const
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|src_const
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|)
condition|)
block|{
name|tem
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
comment|/* Make sure that the rtx is not shared with any other insn.  */
name|src_const
operator|=
name|copy_rtx
argument_list|(
name|src_const
argument_list|)
expr_stmt|;
comment|/* Record the actual constant value in a REG_EQUAL note, making 	     a new one if one does not already exist.  */
if|if
condition|(
name|tem
condition|)
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
operator|=
name|src_const
expr_stmt|;
else|else
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_EQUAL
argument_list|,
name|src_const
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If storing a constant value in a register that 	     previously held the constant value 0, 	     record this fact with a REG_WAS_0 note on this insn.  	     Note that the *register* is required to have previously held 0, 	     not just any register in the quantity and we must point to the 	     insn that set that register to zero.  	     Rather than track each register individually, we just see if 	     the last set for this quantity was for this register.  */
if|if
condition|(
name|REGNO_QTY_VALID_P
argument_list|(
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|&&
name|qty_const
index|[
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
index|]
operator|==
name|const0_rtx
condition|)
block|{
comment|/* See if we previously had a REG_WAS_0 note.  */
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_WAS_0
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
name|rtx
name|const_insn
init|=
name|qty_const_insn
index|[
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|tem
operator|=
name|single_set
argument_list|(
name|const_insn
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_DEST
argument_list|(
name|tem
argument_list|)
argument_list|,
name|dest
argument_list|)
condition|)
block|{
if|if
condition|(
name|note
condition|)
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
operator|=
name|const_insn
expr_stmt|;
else|else
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_INSN_LIST
argument_list|(
name|REG_WAS_0
argument_list|,
name|const_insn
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Now deal with the destination.  */
name|do_not_record
operator|=
literal|0
expr_stmt|;
name|sets
index|[
name|i
index|]
operator|.
name|inner_dest_loc
operator|=
operator|&
name|SET_DEST
argument_list|(
name|sets
index|[
literal|0
index|]
operator|.
name|rtl
argument_list|)
expr_stmt|;
comment|/* Look within any SIGN_EXTRACT or ZERO_EXTRACT 	 to the MEM or REG within it.  */
while|while
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
block|{
name|sets
index|[
name|i
index|]
operator|.
name|inner_dest_loc
operator|=
operator|&
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dest
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|sets
index|[
name|i
index|]
operator|.
name|inner_dest
operator|=
name|dest
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
condition|)
block|{
ifdef|#
directive|ifdef
name|PUSH_ROUNDING
comment|/* Stack pushes invalidate the stack pointer.  */
name|rtx
name|addr
init|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PRE_DEC
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|POST_DEC
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|POST_INC
operator|)
operator|&&
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
operator|==
name|stack_pointer_rtx
condition|)
name|invalidate
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dest
operator|=
name|fold_rtx
argument_list|(
name|dest
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* Compute the hash code of the destination now, 	 before the effects of this instruction are recorded, 	 since the register values used in the address computation 	 are those before this instruction.  */
name|sets
index|[
name|i
index|]
operator|.
name|dest_hash
operator|=
name|HASH
argument_list|(
name|dest
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* Don't enter a bit-field in the hash table 	 because the value in it after the store 	 may not equal what was stored, due to truncation.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
argument_list|)
operator|==
name|SIGN_EXTRACT
condition|)
block|{
name|rtx
name|width
init|=
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|src_const
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|src_const
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|width
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|width
argument_list|)
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|!
operator|(
name|INTVAL
argument_list|(
name|src_const
argument_list|)
operator|&
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
name|INTVAL
argument_list|(
name|width
argument_list|)
operator|)
operator|)
condition|)
comment|/* Exception: if the value is constant, 	       and it won't be truncated, record it.  */
empty_stmt|;
else|else
block|{
comment|/* This is chosen so that the destination will be invalidated 		 but no new value will be recorded. 		 We must invalidate because sometimes constant 		 values can be recorded for bitfields.  */
name|sets
index|[
name|i
index|]
operator|.
name|src_elt
operator|=
literal|0
expr_stmt|;
name|sets
index|[
name|i
index|]
operator|.
name|src_volatile
operator|=
literal|1
expr_stmt|;
name|src_eqv
operator|=
literal|0
expr_stmt|;
name|src_eqv_elt
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* If only one set in a JUMP_INSN and it is now a no-op, we can delete 	 the insn.  */
elseif|else
if|if
condition|(
name|n_sets
operator|==
literal|1
operator|&&
name|dest
operator|==
name|pc_rtx
operator|&&
name|src
operator|==
name|pc_rtx
condition|)
block|{
name|PUT_CODE
argument_list|(
name|insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
name|cse_jumps_altered
operator|=
literal|1
expr_stmt|;
comment|/* One less use of the label this insn used to jump to.  */
if|if
condition|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|!=
literal|0
condition|)
operator|--
name|LABEL_NUSES
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* No more processing for this set.  */
name|sets
index|[
name|i
index|]
operator|.
name|rtl
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If this SET is now setting PC to a label, we know it used to 	 be a conditional or computed branch.  So we see if we can follow 	 it.  If it was a computed branch, delete it and re-emit.  */
elseif|else
if|if
condition|(
name|dest
operator|==
name|pc_rtx
operator|&&
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|LABEL_REF
condition|)
block|{
name|rtx
name|p
decl_stmt|;
comment|/* If this is not in the format for a simple branch and 	     we are the only SET in it, re-emit it.  */
if|if
condition|(
operator|!
name|simplejump_p
argument_list|(
name|insn
argument_list|)
operator|&&
name|n_sets
operator|==
literal|1
condition|)
block|{
name|rtx
name|new
init|=
name|emit_jump_insn_before
argument_list|(
name|gen_jump
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
decl_stmt|;
name|JUMP_LABEL
argument_list|(
name|new
argument_list|)
operator|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|++
expr_stmt|;
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|insn
operator|=
name|new
expr_stmt|;
block|}
else|else
comment|/* Otherwise, force rerecognition, since it probably had 	       a different pattern before. 	       This shouldn't really be necessary, since whatever 	       changed the source value above should have done this. 	       Until the right place is found, might as well do this here.  */
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Now that we've converted this jump to an unconditional jump, 	     there is dead code after it.  Delete the dead code until we 	     reach a BARRIER, the end of the function, or a label.  Do 	     not delete NOTEs except for NOTE_INSN_DELETED since later 	     phases assume these notes are retained.  */
name|p
operator|=
name|insn
expr_stmt|;
while|while
condition|(
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
argument_list|)
operator|!=
name|BARRIER
operator|&&
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
block|{
comment|/* Note, we must update P with the return value from 		 delete_insn, otherwise we could get an infinite loop 		 if NEXT_INSN (p) had INSN_DELETED_P set.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
argument_list|)
operator|!=
name|NOTE
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
name|NOTE_INSN_DELETED
condition|)
name|p
operator|=
name|PREV_INSN
argument_list|(
name|delete_insn
argument_list|(
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* If we don't have a BARRIER immediately after INSN, put one there. 	     Much code assumes that there are no NOTEs between a JUMP_INSN and 	     BARRIER.  */
if|if
condition|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|BARRIER
condition|)
name|emit_barrier_before
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We might have two BARRIERs separated by notes.  Delete the second 	     one if so.  */
if|if
condition|(
name|p
operator|!=
name|insn
operator|&&
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
name|BARRIER
condition|)
name|delete_insn
argument_list|(
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|cse_jumps_altered
operator|=
literal|1
expr_stmt|;
name|sets
index|[
name|i
index|]
operator|.
name|rtl
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If destination is volatile, invalidate it and then do no further 	 processing for this assignment.  */
elseif|else
if|if
condition|(
name|do_not_record
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
condition|)
name|invalidate
argument_list|(
name|dest
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
name|invalidate
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
name|sets
index|[
name|i
index|]
operator|.
name|rtl
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
operator|!=
literal|0
operator|&&
name|dest
operator|!=
name|SET_DEST
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
condition|)
name|sets
index|[
name|i
index|]
operator|.
name|dest_hash
operator|=
name|HASH
argument_list|(
name|SET_DEST
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* If setting CC0, record what it was set to, or a constant, if it 	 is equivalent to a constant.  If it is being set to a floating-point 	 value, make a COMPARE with the appropriate constant of 0.  If we 	 don't do this, later code can interpret this as a test against 	 const0_rtx, which can cause problems if we try to put it into an 	 insn as a floating-point operand.  */
if|if
condition|(
name|dest
operator|==
name|cc0_rtx
condition|)
block|{
name|this_insn_cc0
operator|=
name|src_const
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|?
name|src_const
else|:
name|src
expr_stmt|;
name|this_insn_cc0_mode
operator|=
name|mode
expr_stmt|;
if|if
condition|(
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
name|this_insn_cc0
operator|=
name|gen_rtx_COMPARE
argument_list|(
name|VOIDmode
argument_list|,
name|this_insn_cc0
argument_list|,
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
comment|/* Now enter all non-volatile source expressions in the hash table      if they are not already present.      Record their equivalence classes in src_elt.      This way we can insert the corresponding destinations into      the same classes even if the actual sources are no longer in them      (having been invalidated).  */
if|if
condition|(
name|src_eqv
operator|&&
name|src_eqv_elt
operator|==
literal|0
operator|&&
name|sets
index|[
literal|0
index|]
operator|.
name|rtl
operator|!=
literal|0
operator|&&
operator|!
name|src_eqv_volatile
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|src_eqv
argument_list|,
name|SET_DEST
argument_list|(
name|sets
index|[
literal|0
index|]
operator|.
name|rtl
argument_list|)
argument_list|)
condition|)
block|{
specifier|register
name|struct
name|table_elt
modifier|*
name|elt
decl_stmt|;
specifier|register
name|struct
name|table_elt
modifier|*
name|classp
init|=
name|sets
index|[
literal|0
index|]
operator|.
name|src_elt
decl_stmt|;
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|sets
index|[
literal|0
index|]
operator|.
name|rtl
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|eqvmode
init|=
name|GET_MODE
argument_list|(
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
block|{
name|eqvmode
operator|=
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|classp
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|insert_regs
argument_list|(
name|src_eqv
argument_list|,
name|classp
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|rehash_using_reg
argument_list|(
name|src_eqv
argument_list|)
expr_stmt|;
name|src_eqv_hash
operator|=
name|HASH
argument_list|(
name|src_eqv
argument_list|,
name|eqvmode
argument_list|)
expr_stmt|;
block|}
name|elt
operator|=
name|insert
argument_list|(
name|src_eqv
argument_list|,
name|classp
argument_list|,
name|src_eqv_hash
argument_list|,
name|eqvmode
argument_list|)
expr_stmt|;
name|elt
operator|->
name|in_memory
operator|=
name|src_eqv_in_memory
expr_stmt|;
name|elt
operator|->
name|in_struct
operator|=
name|src_eqv_in_struct
expr_stmt|;
name|src_eqv_elt
operator|=
name|elt
expr_stmt|;
comment|/* Check to see if src_eqv_elt is the same as a set source which 	 does not yet have an elt, and if so set the elt of the set source 	 to src_eqv_elt.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_sets
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
operator|&&
name|sets
index|[
name|i
index|]
operator|.
name|src_elt
operator|==
literal|0
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_SRC
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
argument_list|,
name|src_eqv
argument_list|)
condition|)
name|sets
index|[
name|i
index|]
operator|.
name|src_elt
operator|=
name|src_eqv_elt
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_sets
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
operator|&&
operator|!
name|sets
index|[
name|i
index|]
operator|.
name|src_volatile
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|SET_SRC
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
argument_list|,
name|SET_DEST
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
block|{
comment|/* REG_EQUAL in setting a STRICT_LOW_PART 	       gives an equivalent for the entire destination register, 	       not just for the subreg being stored in now. 	       This is a more interesting equivalence, so we arrange later 	       to treat the entire reg as the destination.  */
name|sets
index|[
name|i
index|]
operator|.
name|src_elt
operator|=
name|src_eqv_elt
expr_stmt|;
name|sets
index|[
name|i
index|]
operator|.
name|src_hash
operator|=
name|src_eqv_hash
expr_stmt|;
block|}
else|else
block|{
comment|/* Insert source and constant equivalent into hash table, if not 	       already present.  */
specifier|register
name|struct
name|table_elt
modifier|*
name|classp
init|=
name|src_eqv_elt
decl_stmt|;
specifier|register
name|rtx
name|src
init|=
name|sets
index|[
name|i
index|]
operator|.
name|src
decl_stmt|;
specifier|register
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|src
argument_list|)
operator|==
name|VOIDmode
condition|?
name|GET_MODE
argument_list|(
name|dest
argument_list|)
else|:
name|GET_MODE
argument_list|(
name|src
argument_list|)
decl_stmt|;
comment|/* Don't put a hard register source into the table if this is 	       the last insn of a libcall.  */
if|if
condition|(
name|sets
index|[
name|i
index|]
operator|.
name|src_elt
operator|==
literal|0
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|src
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
operator|!
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
condition|)
block|{
specifier|register
name|struct
name|table_elt
modifier|*
name|elt
decl_stmt|;
comment|/* Note that these insert_regs calls cannot remove 		   any of the src_elt's, because they would have failed to 		   match if not still valid.  */
if|if
condition|(
name|insert_regs
argument_list|(
name|src
argument_list|,
name|classp
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|rehash_using_reg
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|sets
index|[
name|i
index|]
operator|.
name|src_hash
operator|=
name|HASH
argument_list|(
name|src
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
name|elt
operator|=
name|insert
argument_list|(
name|src
argument_list|,
name|classp
argument_list|,
name|sets
index|[
name|i
index|]
operator|.
name|src_hash
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|elt
operator|->
name|in_memory
operator|=
name|sets
index|[
name|i
index|]
operator|.
name|src_in_memory
expr_stmt|;
name|elt
operator|->
name|in_struct
operator|=
name|sets
index|[
name|i
index|]
operator|.
name|src_in_struct
expr_stmt|;
name|sets
index|[
name|i
index|]
operator|.
name|src_elt
operator|=
name|classp
operator|=
name|elt
expr_stmt|;
block|}
if|if
condition|(
name|sets
index|[
name|i
index|]
operator|.
name|src_const
operator|&&
name|sets
index|[
name|i
index|]
operator|.
name|src_const_elt
operator|==
literal|0
operator|&&
name|src
operator|!=
name|sets
index|[
name|i
index|]
operator|.
name|src_const
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|src_const
argument_list|,
name|src
argument_list|)
condition|)
name|sets
index|[
name|i
index|]
operator|.
name|src_elt
operator|=
name|insert
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|src_const
argument_list|,
name|classp
argument_list|,
name|sets
index|[
name|i
index|]
operator|.
name|src_const_hash
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sets
index|[
name|i
index|]
operator|.
name|src_elt
operator|==
literal|0
condition|)
comment|/* If we did not insert the source into the hash table (e.g., it was 	 volatile), note the equivalence class for the REG_EQUAL value, if any, 	 so that the destination goes into that class.  */
name|sets
index|[
name|i
index|]
operator|.
name|src_elt
operator|=
name|src_eqv_elt
expr_stmt|;
name|invalidate_from_clobbers
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* Some registers are invalidated by subroutine calls.  Memory is       invalidated by non-constant calls.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
if|if
condition|(
operator|!
name|CONST_CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
name|invalidate_memory
argument_list|()
expr_stmt|;
name|invalidate_for_call
argument_list|()
expr_stmt|;
block|}
comment|/* Now invalidate everything set by this instruction.      If a SUBREG or other funny destination is being set,      sets[i].rtl is still nonzero, so here we invalidate the reg      a part of which is being set.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_sets
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
condition|)
block|{
comment|/* We can't use the inner dest, because the mode associated with 	   a ZERO_EXTRACT is significant.  */
specifier|register
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
decl_stmt|;
comment|/* Needed for registers to remove the register from its 	   previous quantity's chain. 	   Needed for memory if this is a nonvarying address, unless 	   we have just done an invalidate_memory that covers even those.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
condition|)
name|invalidate
argument_list|(
name|dest
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
name|invalidate
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* A volatile ASM invalidates everything.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ASM_OPERANDS
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
name|flush_hash_table
argument_list|()
expr_stmt|;
comment|/* Make sure registers mentioned in destinations      are safe for use in an expression to be inserted.      This removes from the hash table      any invalid entry that refers to one of these registers.       We don't care about the return value from mention_regs because      we are going to hash the SET_DEST values unconditionally.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_sets
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
condition|)
block|{
name|rtx
name|x
init|=
name|SET_DEST
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
condition|)
name|mention_regs
argument_list|(
name|x
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* We used to rely on all references to a register becoming 		 inaccessible when a register changes to a new quantity, 		 since that changes the hash code.  However, that is not 		 safe, since after NBUCKETS new quantities we get a 		 hash 'collision' of a register with its own invalid 		 entries.  And since SUBREGs have been changed not to 		 change their hash code with the hash code of the register, 		 it wouldn't work any longer at all.  So we have to check 		 for any invalid references lying around now. 		 This code is similar to the REG case in mention_regs, 		 but it knows that reg_tick has been incremented, and 		 it leaves reg_in_table as -1 .  */
specifier|register
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
specifier|register
name|int
name|endregno
init|=
name|regno
operator|+
operator|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|?
literal|1
else|:
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|regno
init|;
name|i
operator|<
name|endregno
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|REG_IN_TABLE
argument_list|(
name|i
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|remove_invalid_refs
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|REG_IN_TABLE
argument_list|(
name|i
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/* We may have just removed some of the src_elt's from the hash table.      So replace each one with the current head of the same class.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_sets
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
condition|)
block|{
if|if
condition|(
name|sets
index|[
name|i
index|]
operator|.
name|src_elt
operator|&&
name|sets
index|[
name|i
index|]
operator|.
name|src_elt
operator|->
name|first_same_value
operator|==
literal|0
condition|)
comment|/* If elt was removed, find current head of same class, 	     or 0 if nothing remains of that class.  */
block|{
specifier|register
name|struct
name|table_elt
modifier|*
name|elt
init|=
name|sets
index|[
name|i
index|]
operator|.
name|src_elt
decl_stmt|;
while|while
condition|(
name|elt
operator|&&
name|elt
operator|->
name|prev_same_value
condition|)
name|elt
operator|=
name|elt
operator|->
name|prev_same_value
expr_stmt|;
while|while
condition|(
name|elt
operator|&&
name|elt
operator|->
name|first_same_value
operator|==
literal|0
condition|)
name|elt
operator|=
name|elt
operator|->
name|next_same_value
expr_stmt|;
name|sets
index|[
name|i
index|]
operator|.
name|src_elt
operator|=
name|elt
condition|?
name|elt
operator|->
name|first_same_value
else|:
literal|0
expr_stmt|;
block|}
block|}
comment|/* Now insert the destinations into their equivalence classes.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_sets
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
condition|)
block|{
specifier|register
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
decl_stmt|;
name|rtx
name|inner_dest
init|=
name|sets
index|[
name|i
index|]
operator|.
name|inner_dest
decl_stmt|;
specifier|register
name|struct
name|table_elt
modifier|*
name|elt
decl_stmt|;
comment|/* Don't record value if we are not supposed to risk allocating 	   floating-point values in registers that might be wider than 	   memory.  */
if|if
condition|(
operator|(
name|flag_float_store
operator|&&
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
operator|&&
name|FLOAT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|)
comment|/* Don't record BLKmode values, because we don't know the 	       size of it, and can't be sure that other BLKmode values 	       have the same or smaller size.  */
operator|||
name|GET_MODE
argument_list|(
name|dest
argument_list|)
operator|==
name|BLKmode
comment|/* Don't record values of destinations set inside a libcall block 	       since we might delete the libcall.  Things should have been set 	       up so we won't want to reuse such a value, but we play it safe 	       here.  */
operator|||
name|libcall_insn
comment|/* If we didn't put a REG_EQUAL value or a source into the hash 	       table, there is no point is recording DEST.  */
operator|||
name|sets
index|[
name|i
index|]
operator|.
name|src_elt
operator|==
literal|0
comment|/* If DEST is a paradoxical SUBREG and SRC is a ZERO_EXTEND 	       or SIGN_EXTEND, don't record DEST since it can cause 	       some tracking to be wrong.  	       ??? Think about this more later.  */
operator|||
operator|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|src
argument_list|)
operator|==
name|SIGN_EXTEND
operator|||
name|GET_CODE
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|src
argument_list|)
operator|==
name|ZERO_EXTEND
operator|)
operator|)
condition|)
continue|continue;
comment|/* STRICT_LOW_PART isn't part of the value BEING set, 	   and neither is the SUBREG inside it. 	   Note that in this case SETS[I].SRC_ELT is really SRC_EQV_ELT.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|dest
operator|=
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
condition|)
comment|/* Registers must also be inserted into chains for quantities.  */
if|if
condition|(
name|insert_regs
argument_list|(
name|dest
argument_list|,
name|sets
index|[
name|i
index|]
operator|.
name|src_elt
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|/* If `insert_regs' changes something, the hash code must be 		 recalculated.  */
name|rehash_using_reg
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|sets
index|[
name|i
index|]
operator|.
name|dest_hash
operator|=
name|HASH
argument_list|(
name|dest
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|inner_dest
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|inner_dest
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDRESSOF
condition|)
comment|/* Given (SET (MEM (ADDRESSOF (X))) Y) we don't want to say 	     that (MEM (ADDRESSOF (X))) is equivalent to Y.  	     Consider the case in which the address of the MEM is 	     passed to a function, which alters the MEM.  Then, if we 	     later use Y instead of the MEM we'll miss the update.  */
name|elt
operator|=
name|insert
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|,
name|sets
index|[
name|i
index|]
operator|.
name|dest_hash
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|elt
operator|=
name|insert
argument_list|(
name|dest
argument_list|,
name|sets
index|[
name|i
index|]
operator|.
name|src_elt
argument_list|,
name|sets
index|[
name|i
index|]
operator|.
name|dest_hash
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
name|elt
operator|->
name|in_memory
operator|=
operator|(
name|GET_CODE
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|inner_dest
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
operator|!
name|RTX_UNCHANGING_P
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|inner_dest
argument_list|)
operator|||
name|FIXED_BASE_PLUS_P
argument_list|(
name|XEXP
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|inner_dest
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|elt
operator|->
name|in_memory
condition|)
block|{
comment|/* This implicitly assumes a whole struct 	       need not have MEM_IN_STRUCT_P. 	       But a whole struct is *supposed* to have MEM_IN_STRUCT_P.  */
name|elt
operator|->
name|in_struct
operator|=
operator|(
name|MEM_IN_STRUCT_P
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|inner_dest
argument_list|)
operator|||
name|sets
index|[
name|i
index|]
operator|.
name|inner_dest
operator|!=
name|SET_DEST
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
operator|)
expr_stmt|;
block|}
comment|/* If we have (set (subreg:m1 (reg:m2 foo) 0) (bar:m1)), M1 is no 	   narrower than M2, and both M1 and M2 are the same number of words, 	   we are also doing (set (reg:m2 foo) (subreg:m2 (bar:m1) 0)) so 	   make that equivalence as well.  	   However, BAR may have equivalences for which gen_lowpart_if_possible 	   will produce a simpler value than gen_lowpart_if_possible applied to 	   BAR (e.g., if BAR was ZERO_EXTENDed from M2), so we will scan all 	   BAR's equivalences.  If we don't get a simplified form, make  	   the SUBREG.  It will not be used in an equivalence, but will 	   cause two similar assignments to be detected.  	   Note the loop below will find SUBREG_REG (DEST) since we have 	   already entered SRC and DEST of the SET in the table.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
argument_list|)
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|==
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|>=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
name|sets
index|[
name|i
index|]
operator|.
name|src_elt
operator|!=
literal|0
condition|)
block|{
name|enum
name|machine_mode
name|new_mode
init|=
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|table_elt
modifier|*
name|elt
decl_stmt|,
modifier|*
name|classp
init|=
literal|0
decl_stmt|;
for|for
control|(
name|elt
operator|=
name|sets
index|[
name|i
index|]
operator|.
name|src_elt
operator|->
name|first_same_value
init|;
name|elt
condition|;
name|elt
operator|=
name|elt
operator|->
name|next_same_value
control|)
block|{
name|rtx
name|new_src
init|=
literal|0
decl_stmt|;
name|unsigned
name|src_hash
decl_stmt|;
name|struct
name|table_elt
modifier|*
name|src_elt
decl_stmt|;
comment|/* Ignore invalid entries.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|elt
operator|->
name|exp
argument_list|)
operator|!=
name|REG
operator|&&
operator|!
name|exp_equiv_p
argument_list|(
name|elt
operator|->
name|exp
argument_list|,
name|elt
operator|->
name|exp
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
continue|continue;
name|new_src
operator|=
name|gen_lowpart_if_possible
argument_list|(
name|new_mode
argument_list|,
name|elt
operator|->
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_src
operator|==
literal|0
condition|)
name|new_src
operator|=
name|gen_rtx_SUBREG
argument_list|(
name|new_mode
argument_list|,
name|elt
operator|->
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|src_hash
operator|=
name|HASH
argument_list|(
name|new_src
argument_list|,
name|new_mode
argument_list|)
expr_stmt|;
name|src_elt
operator|=
name|lookup
argument_list|(
name|new_src
argument_list|,
name|src_hash
argument_list|,
name|new_mode
argument_list|)
expr_stmt|;
comment|/* Put the new source in the hash table is if isn't 		   already.  */
if|if
condition|(
name|src_elt
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|insert_regs
argument_list|(
name|new_src
argument_list|,
name|classp
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|rehash_using_reg
argument_list|(
name|new_src
argument_list|)
expr_stmt|;
name|src_hash
operator|=
name|HASH
argument_list|(
name|new_src
argument_list|,
name|new_mode
argument_list|)
expr_stmt|;
block|}
name|src_elt
operator|=
name|insert
argument_list|(
name|new_src
argument_list|,
name|classp
argument_list|,
name|src_hash
argument_list|,
name|new_mode
argument_list|)
expr_stmt|;
name|src_elt
operator|->
name|in_memory
operator|=
name|elt
operator|->
name|in_memory
expr_stmt|;
name|src_elt
operator|->
name|in_struct
operator|=
name|elt
operator|->
name|in_struct
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|classp
operator|&&
name|classp
operator|!=
name|src_elt
operator|->
name|first_same_value
condition|)
comment|/* Show that two things that we've seen before are  		     actually the same.  */
name|merge_equiv_classes
argument_list|(
name|src_elt
argument_list|,
name|classp
argument_list|)
expr_stmt|;
name|classp
operator|=
name|src_elt
operator|->
name|first_same_value
expr_stmt|;
comment|/* Ignore invalid entries.  */
while|while
condition|(
name|classp
operator|&&
name|GET_CODE
argument_list|(
name|classp
operator|->
name|exp
argument_list|)
operator|!=
name|REG
operator|&&
operator|!
name|exp_equiv_p
argument_list|(
name|classp
operator|->
name|exp
argument_list|,
name|classp
operator|->
name|exp
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
name|classp
operator|=
name|classp
operator|->
name|next_same_value
expr_stmt|;
block|}
block|}
block|}
comment|/* Special handling for (set REG0 REG1)      where REG0 is the "cheapest", cheaper than REG1.      After cse, REG1 will probably not be used in the sequel,       so (if easily done) change this insn to (set REG1 REG0) and      replace REG1 with REG0 in the previous insn that computed their value.      Then REG1 will become a dead store and won't cloud the situation      for later optimizations.       Do not make this change if REG1 is a hard register, because it will      then be used in the sequel and we may be changing a two-operand insn      into a three-operand insn.       Also do not do this if we are operating on a copy of INSN.       Also don't do this if INSN ends a libcall; this would cause an unrelated      register to be set in the middle of a libcall, and we then get bad code      if the libcall is deleted.  */
if|if
condition|(
name|n_sets
operator|==
literal|1
operator|&&
name|sets
index|[
literal|0
index|]
operator|.
name|rtl
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|sets
index|[
literal|0
index|]
operator|.
name|rtl
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|NEXT_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|sets
index|[
literal|0
index|]
operator|.
name|rtl
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|sets
index|[
literal|0
index|]
operator|.
name|rtl
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|REGNO_QTY_VALID_P
argument_list|(
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|sets
index|[
literal|0
index|]
operator|.
name|rtl
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|(
name|qty_first_reg
index|[
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|sets
index|[
literal|0
index|]
operator|.
name|rtl
argument_list|)
argument_list|)
argument_list|)
index|]
operator|==
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|sets
index|[
literal|0
index|]
operator|.
name|rtl
argument_list|)
argument_list|)
operator|)
operator|&&
operator|!
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
block|{
name|rtx
name|prev
init|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
while|while
condition|(
name|prev
operator|&&
name|GET_CODE
argument_list|(
name|prev
argument_list|)
operator|==
name|NOTE
condition|)
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|prev
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|&&
name|GET_CODE
argument_list|(
name|prev
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|)
operator|==
name|SET_SRC
argument_list|(
name|sets
index|[
literal|0
index|]
operator|.
name|rtl
argument_list|)
condition|)
block|{
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|sets
index|[
literal|0
index|]
operator|.
name|rtl
argument_list|)
decl_stmt|;
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|prev
argument_list|,
name|REG_EQUIV
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
name|validate_change
argument_list|(
name|prev
argument_list|,
operator|&
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|)
argument_list|,
name|dest
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_DEST
argument_list|(
name|sets
index|[
literal|0
index|]
operator|.
name|rtl
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|sets
index|[
literal|0
index|]
operator|.
name|rtl
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|sets
index|[
literal|0
index|]
operator|.
name|rtl
argument_list|)
argument_list|,
name|dest
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|apply_change_group
argument_list|()
expr_stmt|;
comment|/* If REG1 was equivalent to a constant, REG0 is not.  */
if|if
condition|(
name|note
condition|)
name|PUT_REG_NOTE_KIND
argument_list|(
name|note
argument_list|,
name|REG_EQUAL
argument_list|)
expr_stmt|;
comment|/* If there was a REG_WAS_0 note on PREV, remove it.  Move 	     any REG_WAS_0 note on INSN to PREV.  */
name|note
operator|=
name|find_reg_note
argument_list|(
name|prev
argument_list|,
name|REG_WAS_0
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
condition|)
name|remove_note
argument_list|(
name|prev
argument_list|,
name|note
argument_list|)
expr_stmt|;
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_WAS_0
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
condition|)
block|{
name|remove_note
argument_list|(
name|insn
argument_list|,
name|note
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
operator|=
name|REG_NOTES
argument_list|(
name|prev
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|prev
argument_list|)
operator|=
name|note
expr_stmt|;
block|}
comment|/* If INSN has a REG_EQUAL note, and this note mentions REG0, 	     then we must delete it, because the value in REG0 has changed.  */
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
operator|&&
name|reg_mentioned_p
argument_list|(
name|dest
argument_list|,
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|remove_note
argument_list|(
name|insn
argument_list|,
name|note
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If this is a conditional jump insn, record any known equivalences due to      the condition being tested.  */
name|last_jump_equiv_class
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|n_sets
operator|==
literal|1
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|IF_THEN_ELSE
condition|)
name|record_jump_equiv
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* If the previous insn set CC0 and this insn no longer references CC0,      delete the previous insn.  Here we use the fact that nothing expects CC0      to be valid over an insn, which is true until the final pass.  */
if|if
condition|(
name|prev_insn
operator|&&
name|GET_CODE
argument_list|(
name|prev_insn
argument_list|)
operator|==
name|INSN
operator|&&
operator|(
name|tem
operator|=
name|single_set
argument_list|(
name|prev_insn
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|SET_DEST
argument_list|(
name|tem
argument_list|)
operator|==
name|cc0_rtx
operator|&&
operator|!
name|reg_mentioned_p
argument_list|(
name|cc0_rtx
argument_list|,
name|x
argument_list|)
condition|)
block|{
name|PUT_CODE
argument_list|(
name|prev_insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|prev_insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|prev_insn
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|prev_insn_cc0
operator|=
name|this_insn_cc0
expr_stmt|;
name|prev_insn_cc0_mode
operator|=
name|this_insn_cc0_mode
expr_stmt|;
endif|#
directive|endif
name|prev_insn
operator|=
name|insn
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Remove from the hash table all expressions that reference memory.  */
end_comment

begin_function
specifier|static
name|void
name|invalidate_memory
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|table_elt
modifier|*
name|p
decl_stmt|,
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBUCKETS
condition|;
name|i
operator|++
control|)
for|for
control|(
name|p
operator|=
name|table
index|[
name|i
index|]
init|;
name|p
condition|;
name|p
operator|=
name|next
control|)
block|{
name|next
operator|=
name|p
operator|->
name|next_same_hash
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|in_memory
condition|)
name|remove_from_table
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* XXX ??? The name of this function bears little resemblance to    what this function actually does.  FIXME.  */
end_comment

begin_function
specifier|static
name|int
name|note_mem_written
parameter_list|(
name|addr
parameter_list|)
specifier|register
name|rtx
name|addr
decl_stmt|;
block|{
comment|/* Pushing or popping the stack invalidates just the stack pointer.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PRE_DEC
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|POST_DEC
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|POST_INC
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|STACK_POINTER_REGNUM
condition|)
block|{
if|if
condition|(
name|REG_TICK
argument_list|(
name|STACK_POINTER_REGNUM
argument_list|)
operator|>=
literal|0
condition|)
name|REG_TICK
argument_list|(
name|STACK_POINTER_REGNUM
argument_list|)
operator|++
expr_stmt|;
comment|/* This should be *very* rare.  */
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|hard_regs_in_table
argument_list|,
name|STACK_POINTER_REGNUM
argument_list|)
condition|)
name|invalidate
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Perform invalidation on the basis of everything about an insn    except for invalidating the actual places that are SET in it.    This includes the places CLOBBERed, and anything that might    alias with something that is SET or CLOBBERed.     X is the pattern of the insn.  */
end_comment

begin_function
specifier|static
name|void
name|invalidate_from_clobbers
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CLOBBER
condition|)
block|{
name|rtx
name|ref
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|ref
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|MEM
condition|)
name|invalidate
argument_list|(
name|ref
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
name|invalidate
argument_list|(
name|XEXP
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|ref
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
specifier|register
name|rtx
name|y
init|=
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|CLOBBER
condition|)
block|{
name|rtx
name|ref
init|=
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|MEM
condition|)
name|invalidate
argument_list|(
name|ref
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
name|invalidate
argument_list|(
name|XEXP
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|ref
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Process X, part of the REG_NOTES of an insn.  Look at any REG_EQUAL notes    and replace any registers in them with either an equivalent constant    or the canonical form of the register.  If we are inside an address,    only do this if the address remains valid.     OBJECT is 0 except when within a MEM in which case it is the MEM.     Return the replacement for X.  */
end_comment

begin_function
specifier|static
name|rtx
name|cse_process_notes
parameter_list|(
name|x
parameter_list|,
name|object
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|object
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|char
modifier|*
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST_INT
case|:
case|case
name|CONST
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|LO_SUM
case|:
return|return
name|x
return|;
case|case
name|MEM
case|:
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|cse_process_notes
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
name|x
return|;
case|case
name|EXPR_LIST
case|:
case|case
name|INSN_LIST
case|:
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|x
argument_list|)
operator|==
name|REG_EQUAL
condition|)
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|cse_process_notes
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|=
name|cse_process_notes
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
return|return
name|x
return|;
case|case
name|SIGN_EXTEND
case|:
case|case
name|ZERO_EXTEND
case|:
case|case
name|SUBREG
case|:
block|{
name|rtx
name|new
init|=
name|cse_process_notes
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|object
argument_list|)
decl_stmt|;
comment|/* We don't substitute VOIDmode constants into these rtx, 	   since they would impede folding.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|new
argument_list|)
operator|!=
name|VOIDmode
condition|)
name|validate_change
argument_list|(
name|object
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|new
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
case|case
name|REG
case|:
name|i
operator|=
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Return a constant or a constant register.  */
if|if
condition|(
name|REGNO_QTY_VALID_P
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&&
name|qty_const
index|[
name|i
index|]
operator|!=
literal|0
operator|&&
operator|(
name|CONSTANT_P
argument_list|(
name|qty_const
index|[
name|i
index|]
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|qty_const
index|[
name|i
index|]
argument_list|)
operator|==
name|REG
operator|)
condition|)
block|{
name|rtx
name|new
init|=
name|gen_lowpart_if_possible
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|qty_const
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|new
condition|)
return|return
name|new
return|;
block|}
comment|/* Otherwise, canonicalize this register.  */
return|return
name|canon_reg
argument_list|(
name|x
argument_list|,
name|NULL_RTX
argument_list|)
return|;
default|default:
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|validate_change
argument_list|(
name|object
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|cse_process_notes
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|object
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find common subexpressions between the end test of a loop and the beginning    of the loop.  LOOP_START is the CODE_LABEL at the start of a loop.     Often we have a loop where an expression in the exit test is used    in the body of the loop.  For example "while (*p) *q++ = *p++;".    Because of the way we duplicate the loop exit test in front of the loop,    however, we don't detect that common subexpression.  This will be caught    when global cse is implemented, but this is a quite common case.     This function handles the most common cases of these common expressions.    It is called after we have processed the basic block ending with the    NOTE_INSN_LOOP_END note that ends a loop and the previous JUMP_INSN    jumps to a label used only once.  */
end_comment

begin_function
specifier|static
name|void
name|cse_around_loop
parameter_list|(
name|loop_start
parameter_list|)
name|rtx
name|loop_start
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|table_elt
modifier|*
name|p
decl_stmt|;
comment|/* If the jump at the end of the loop doesn't go to the start, we don't      do anything.  */
for|for
control|(
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|loop_start
argument_list|)
init|;
name|insn
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|>=
literal|0
operator|)
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
name|insn
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_LOOP_BEG
condition|)
return|return;
comment|/* If the last insn of the loop (the end test) was an NE comparison,      we will interpret it as an EQ comparison, since we fell through      the loop.  Any equivalences resulting from that comparison are      therefore not valid and must be invalidated.  */
if|if
condition|(
name|last_jump_equiv_class
condition|)
for|for
control|(
name|p
operator|=
name|last_jump_equiv_class
operator|->
name|first_same_value
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next_same_value
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
operator|->
name|exp
argument_list|)
operator|==
name|MEM
operator|||
name|GET_CODE
argument_list|(
name|p
operator|->
name|exp
argument_list|)
operator|==
name|REG
operator|||
operator|(
name|GET_CODE
argument_list|(
name|p
operator|->
name|exp
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|p
operator|->
name|exp
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
condition|)
name|invalidate
argument_list|(
name|p
operator|->
name|exp
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
operator|->
name|exp
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|p
operator|->
name|exp
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
name|invalidate
argument_list|(
name|XEXP
argument_list|(
name|p
operator|->
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|p
operator|->
name|exp
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Process insns starting after LOOP_START until we hit a CALL_INSN or      a CODE_LABEL (we could handle a CALL_INSN, but it isn't worth it).       The only thing we do with SET_DEST is invalidate entries, so we      can safely process each SET in order.  It is slightly less efficient      to do so, but we only want to handle the most common cases.       The gen_move_insn call in cse_set_around_loop may create new pseudos.      These pseudos won't have valid entries in any of the tables indexed      by register number, such as reg_qty.  We avoid out-of-range array      accesses by not processing any instructions created after cse started.  */
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|loop_start
argument_list|)
init|;
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|CALL_INSN
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|CODE_LABEL
operator|&&
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|<
name|max_insn_uid
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_END
operator|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
operator|)
condition|)
name|cse_set_around_loop
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
name|loop_start
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|)
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
name|cse_set_around_loop
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|,
name|loop_start
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Process one SET of an insn that was skipped.  We ignore CLOBBERs    since they are done elsewhere.  This function is called via note_stores.  */
end_comment

begin_function
specifier|static
name|void
name|invalidate_skipped_set
parameter_list|(
name|dest
parameter_list|,
name|set
parameter_list|)
name|rtx
name|set
decl_stmt|;
name|rtx
name|dest
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|MEM
operator|&&
operator|!
name|note_mem_written
argument_list|(
name|dest
argument_list|)
comment|/* If this is not a stack push ... */
comment|/* There are times when an address can appear varying and be a PLUS 	 during this scan when it would be a fixed address were we to know 	 the proper equivalences.  So invalidate all memory if there is 	 a BLKmode or nonscalar memory reference or a reference to a 	 variable address.  */
operator|&&
operator|(
name|MEM_IN_STRUCT_P
argument_list|(
name|dest
argument_list|)
operator|||
name|GET_MODE
argument_list|(
name|dest
argument_list|)
operator|==
name|BLKmode
operator|||
name|cse_rtx_varies_p
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|invalidate_memory
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|set
argument_list|)
operator|==
name|CLOBBER
ifdef|#
directive|ifdef
name|HAVE_cc0
operator|||
name|dest
operator|==
name|cc0_rtx
endif|#
directive|endif
operator|||
name|dest
operator|==
name|pc_rtx
condition|)
return|return;
if|if
condition|(
name|code
operator|==
name|STRICT_LOW_PART
operator|||
name|code
operator|==
name|ZERO_EXTRACT
condition|)
name|invalidate
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|REG
operator|||
name|code
operator|==
name|SUBREG
operator|||
name|code
operator|==
name|MEM
condition|)
name|invalidate
argument_list|(
name|dest
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Invalidate all insns from START up to the end of the function or the    next label.  This called when we wish to CSE around a block that is    conditionally executed.  */
end_comment

begin_function
specifier|static
name|void
name|invalidate_skipped_block
parameter_list|(
name|start
parameter_list|)
name|rtx
name|start
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|start
init|;
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|CODE_LABEL
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
literal|'i'
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
if|if
condition|(
operator|!
name|CONST_CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
name|invalidate_memory
argument_list|()
expr_stmt|;
name|invalidate_for_call
argument_list|()
expr_stmt|;
block|}
name|invalidate_from_clobbers
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|invalidate_skipped_set
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Used for communication between the following two routines; contains a    value to be checked for modification.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|cse_check_loop_start_value
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If modifying X will modify the value in CSE_CHECK_LOOP_START_VALUE,    indicate that fact by setting CSE_CHECK_LOOP_START_VALUE to 0.  */
end_comment

begin_function
specifier|static
name|void
name|cse_check_loop_start
parameter_list|(
name|x
parameter_list|,
name|set
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|set
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|cse_check_loop_start_value
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CC0
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PC
condition|)
return|return;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|cse_check_loop_start_value
argument_list|)
operator|==
name|MEM
operator|)
operator|||
name|reg_overlap_mentioned_p
argument_list|(
name|x
argument_list|,
name|cse_check_loop_start_value
argument_list|)
condition|)
name|cse_check_loop_start_value
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* X is a SET or CLOBBER contained in INSN that was found near the start of    a loop that starts with the label at LOOP_START.     If X is a SET, we see if its SET_SRC is currently in our hash table.    If so, we see if it has a value equal to some register used only in the    loop exit code (as marked by jump.c).     If those two conditions are true, we search backwards from the start of    the loop to see if that same value was loaded into a register that still    retains its value at the start of the loop.     If so, we insert an insn after the load to copy the destination of that    load into the equivalent register and (try to) replace our SET_SRC with that    register.     In any event, we invalidate whatever this SET or CLOBBER modifies.  */
end_comment

begin_function
specifier|static
name|void
name|cse_set_around_loop
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|,
name|loop_start
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|rtx
name|loop_start
decl_stmt|;
block|{
name|struct
name|table_elt
modifier|*
name|src_elt
decl_stmt|;
comment|/* If this is a SET, see if we can replace SET_SRC, but ignore SETs that      are setting PC or CC0 or whose SET_SRC is already a register.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|PC
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|CC0
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
block|{
name|src_elt
operator|=
name|lookup
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|HASH
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|src_elt
condition|)
for|for
control|(
name|src_elt
operator|=
name|src_elt
operator|->
name|first_same_value
init|;
name|src_elt
condition|;
name|src_elt
operator|=
name|src_elt
operator|->
name|next_same_value
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|src_elt
operator|->
name|exp
argument_list|)
operator|==
name|REG
operator|&&
name|REG_LOOP_TEST_P
argument_list|(
name|src_elt
operator|->
name|exp
argument_list|)
operator|&&
name|COST
argument_list|(
name|src_elt
operator|->
name|exp
argument_list|)
operator|<
name|COST
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|p
decl_stmt|,
name|set
decl_stmt|;
comment|/* Look for an insn in front of LOOP_START that sets 		 something in the desired mode to SET_SRC (x) before we hit 		 a label or CALL_INSN.  */
for|for
control|(
name|p
operator|=
name|prev_nonnote_insn
argument_list|(
name|loop_start
argument_list|)
init|;
name|p
operator|&&
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|!=
name|CALL_INSN
operator|&&
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|!=
name|CODE_LABEL
condition|;
name|p
operator|=
name|prev_nonnote_insn
argument_list|(
name|p
argument_list|)
control|)
if|if
condition|(
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|p
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|src_elt
operator|->
name|mode
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
comment|/* We now have to ensure that nothing between P 		       and LOOP_START modified anything referenced in 		       SET_SRC (x).  We know that nothing within the loop 		       can modify it, or we would have invalidated it in 		       the hash table.  */
name|rtx
name|q
decl_stmt|;
name|cse_check_loop_start_value
operator|=
name|SET_SRC
argument_list|(
name|x
argument_list|)
expr_stmt|;
for|for
control|(
name|q
operator|=
name|p
init|;
name|q
operator|!=
name|loop_start
condition|;
name|q
operator|=
name|NEXT_INSN
argument_list|(
name|q
argument_list|)
control|)
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|q
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|q
argument_list|)
argument_list|,
name|cse_check_loop_start
argument_list|)
expr_stmt|;
comment|/* If nothing was changed and we can replace our 		       SET_SRC, add an insn after P to copy its destination 		       to what we will be replacing SET_SRC with.  */
if|if
condition|(
name|cse_check_loop_start_value
operator|&&
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|src_elt
operator|->
name|exp
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* If this creates new pseudos, this is unsafe, 			   because the regno of new pseudo is unsuitable 			   to index into reg_qty when cse_insn processes 			   the new insn.  Therefore, if a new pseudo was 			   created, discard this optimization.  */
name|int
name|nregs
init|=
name|max_reg_num
argument_list|()
decl_stmt|;
name|rtx
name|move
init|=
name|gen_move_insn
argument_list|(
name|src_elt
operator|->
name|exp
argument_list|,
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|nregs
operator|!=
name|max_reg_num
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
name|emit_insn_after
argument_list|(
name|move
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
comment|/* Now invalidate anything modified by X.  */
name|note_mem_written
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
comment|/* See comment on similar code in cse_insn for explanation of these tests.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
name|invalidate
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
name|invalidate
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find the end of INSN's basic block and return its range,    the total number of SETs in all the insns of the block, the last insn of the    block, and the branch path.     The branch path indicates which branches should be followed.  If a non-zero    path size is specified, the block should be rescanned and a different set    of branches will be taken.  The branch path is only used if    FLAG_CSE_FOLLOW_JUMPS or FLAG_CSE_SKIP_BLOCKS is non-zero.     DATA is a pointer to a struct cse_basic_block_data, defined below, that is    used to describe the block.  It is filled in with the information about    the current block.  The incoming structure's branch path, if any, is used    to construct the output branch path.  */
end_comment

begin_function
name|void
name|cse_end_of_basic_block
parameter_list|(
name|insn
parameter_list|,
name|data
parameter_list|,
name|follow_jumps
parameter_list|,
name|after_loop
parameter_list|,
name|skip_blocks
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|struct
name|cse_basic_block_data
modifier|*
name|data
decl_stmt|;
name|int
name|follow_jumps
decl_stmt|;
name|int
name|after_loop
decl_stmt|;
name|int
name|skip_blocks
decl_stmt|;
block|{
name|rtx
name|p
init|=
name|insn
decl_stmt|,
name|q
decl_stmt|;
name|int
name|nsets
init|=
literal|0
decl_stmt|;
name|int
name|low_cuid
init|=
name|INSN_CUID
argument_list|(
name|insn
argument_list|)
decl_stmt|,
name|high_cuid
init|=
name|INSN_CUID
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|next
init|=
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|?
name|insn
else|:
name|next_real_insn
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|path_size
init|=
name|data
operator|->
name|path_size
decl_stmt|;
name|int
name|path_entry
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Update the previous branch path, if any.  If the last branch was      previously TAKEN, mark it NOT_TAKEN.  If it was previously NOT_TAKEN,      shorten the path by one and look at the previous branch.  We know that      at least one branch must have been taken if PATH_SIZE is non-zero.  */
while|while
condition|(
name|path_size
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|data
operator|->
name|path
index|[
name|path_size
operator|-
literal|1
index|]
operator|.
name|status
operator|!=
name|NOT_TAKEN
condition|)
block|{
name|data
operator|->
name|path
index|[
name|path_size
operator|-
literal|1
index|]
operator|.
name|status
operator|=
name|NOT_TAKEN
expr_stmt|;
break|break;
block|}
else|else
name|path_size
operator|--
expr_stmt|;
block|}
comment|/* Scan to end of this basic block.  */
while|while
condition|(
name|p
operator|&&
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
block|{
comment|/* Don't cse out the end of a loop.  This makes a difference 	 only for the unusual loops that always execute at least once; 	 all other loops have labels there so we will stop in any case. 	 Cse'ing out the end of the loop is dangerous because it 	 might cause an invariant expression inside the loop 	 to be reused after the end of the loop.  This would make it 	 hard to move the expression out of the loop in loop.c, 	 especially if it is one of several equivalent expressions 	 and loop.c would like to eliminate it.  	 If we are running after loop.c has finished, we can ignore 	 the NOTE_INSN_LOOP_END.  */
if|if
condition|(
operator|!
name|after_loop
operator|&&
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE_INSN_LOOP_END
condition|)
break|break;
comment|/* Don't cse over a call to setjmp; on some machines (eg vax) 	 the regs restored by the longjmp come from 	 a later time than the setjmp.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE_INSN_SETJMP
condition|)
break|break;
comment|/* A PARALLEL can have lots of SETs in it, 	 especially if it is really an ASM_OPERANDS.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|)
name|nsets
operator|+=
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|!=
name|NOTE
condition|)
name|nsets
operator|+=
literal|1
expr_stmt|;
comment|/* Ignore insns made by CSE; they cannot affect the boundaries of 	 the basic block.  */
if|if
condition|(
name|INSN_UID
argument_list|(
name|p
argument_list|)
operator|<=
name|max_uid
operator|&&
name|INSN_CUID
argument_list|(
name|p
argument_list|)
operator|>
name|high_cuid
condition|)
name|high_cuid
operator|=
name|INSN_CUID
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|INSN_UID
argument_list|(
name|p
argument_list|)
operator|<=
name|max_uid
operator|&&
name|INSN_CUID
argument_list|(
name|p
argument_list|)
operator|<
name|low_cuid
condition|)
name|low_cuid
operator|=
name|INSN_CUID
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* See if this insn is in our branch path.  If it is and we are to 	 take it, do so.  */
if|if
condition|(
name|path_entry
operator|<
name|path_size
operator|&&
name|data
operator|->
name|path
index|[
name|path_entry
index|]
operator|.
name|branch
operator|==
name|p
condition|)
block|{
if|if
condition|(
name|data
operator|->
name|path
index|[
name|path_entry
index|]
operator|.
name|status
operator|!=
name|NOT_TAKEN
condition|)
name|p
operator|=
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Point to next entry in path, if any.  */
name|path_entry
operator|++
expr_stmt|;
block|}
comment|/* If this is a conditional jump, we can follow it if -fcse-follow-jumps 	 was specified, we haven't reached our maximum path length, there are 	 insns following the target of the jump, this is the only use of the 	 jump label, and the target label is preceded by a BARRIER.  	 Alternatively, we can follow the jump if it branches around a 	 block of code and there are no other branches into the block. 	 In this case invalidate_skipped_block will be called to invalidate any 	 registers set in the block when following the jump.  */
elseif|else
if|if
condition|(
operator|(
name|follow_jumps
operator|||
name|skip_blocks
operator|)
operator|&&
name|path_size
operator|<
name|PATHLENGTH
operator|-
literal|1
operator|&&
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
operator|==
name|IF_THEN_ELSE
operator|&&
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
operator|!=
literal|0
operator|&&
name|LABEL_NUSES
argument_list|(
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
literal|1
operator|&&
name|NEXT_INSN
argument_list|(
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|q
operator|=
name|PREV_INSN
argument_list|(
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
argument_list|)
init|;
name|q
condition|;
name|q
operator|=
name|PREV_INSN
argument_list|(
name|q
argument_list|)
control|)
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|q
argument_list|)
operator|!=
name|NOTE
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|q
argument_list|)
operator|==
name|NOTE_INSN_LOOP_END
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|q
argument_list|)
operator|==
name|NOTE_INSN_SETJMP
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|q
argument_list|)
operator|!=
name|CODE_LABEL
operator|||
name|LABEL_NUSES
argument_list|(
name|q
argument_list|)
operator|!=
literal|0
operator|)
condition|)
break|break;
comment|/* If we ran into a BARRIER, this code is an extension of the 	     basic block when the branch is taken.  */
if|if
condition|(
name|follow_jumps
operator|&&
name|q
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|q
argument_list|)
operator|==
name|BARRIER
condition|)
block|{
comment|/* Don't allow ourself to keep walking around an 		 always-executed loop.  */
if|if
condition|(
name|next_real_insn
argument_list|(
name|q
argument_list|)
operator|==
name|next
condition|)
block|{
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Similarly, don't put a branch in our path more than once.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|path_entry
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|data
operator|->
name|path
index|[
name|i
index|]
operator|.
name|branch
operator|==
name|p
condition|)
break|break;
if|if
condition|(
name|i
operator|!=
name|path_entry
condition|)
break|break;
name|data
operator|->
name|path
index|[
name|path_entry
index|]
operator|.
name|branch
operator|=
name|p
expr_stmt|;
name|data
operator|->
name|path
index|[
name|path_entry
operator|++
index|]
operator|.
name|status
operator|=
name|TAKEN
expr_stmt|;
comment|/* This branch now ends our path.  It was possible that we 		 didn't see this branch the last time around (when the 		 insn in front of the target was a JUMP_INSN that was 		 turned into a no-op).  */
name|path_size
operator|=
name|path_entry
expr_stmt|;
name|p
operator|=
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Mark block so we won't scan it again later.  */
name|PUT_MODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
argument_list|,
name|QImode
argument_list|)
expr_stmt|;
block|}
comment|/* Detect a branch around a block of code.  */
elseif|else
if|if
condition|(
name|skip_blocks
operator|&&
name|q
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|q
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
block|{
specifier|register
name|rtx
name|tmp
decl_stmt|;
if|if
condition|(
name|next_real_insn
argument_list|(
name|q
argument_list|)
operator|==
name|next
condition|)
block|{
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|path_entry
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|data
operator|->
name|path
index|[
name|i
index|]
operator|.
name|branch
operator|==
name|p
condition|)
break|break;
if|if
condition|(
name|i
operator|!=
name|path_entry
condition|)
break|break;
comment|/* This is no_labels_between_p (p, q) with an added check for 		 reaching the end of a function (in case Q precedes P).  */
for|for
control|(
name|tmp
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
init|;
name|tmp
operator|&&
name|tmp
operator|!=
name|q
condition|;
name|tmp
operator|=
name|NEXT_INSN
argument_list|(
name|tmp
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|CODE_LABEL
condition|)
break|break;
if|if
condition|(
name|tmp
operator|==
name|q
condition|)
block|{
name|data
operator|->
name|path
index|[
name|path_entry
index|]
operator|.
name|branch
operator|=
name|p
expr_stmt|;
name|data
operator|->
name|path
index|[
name|path_entry
operator|++
index|]
operator|.
name|status
operator|=
name|AROUND
expr_stmt|;
name|path_size
operator|=
name|path_entry
expr_stmt|;
name|p
operator|=
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Mark block so we won't scan it again later.  */
name|PUT_MODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
argument_list|,
name|QImode
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|data
operator|->
name|low_cuid
operator|=
name|low_cuid
expr_stmt|;
name|data
operator|->
name|high_cuid
operator|=
name|high_cuid
expr_stmt|;
name|data
operator|->
name|nsets
operator|=
name|nsets
expr_stmt|;
name|data
operator|->
name|last
operator|=
name|p
expr_stmt|;
comment|/* If all jumps in the path are not taken, set our path length to zero      so a rescan won't be done.  */
for|for
control|(
name|i
operator|=
name|path_size
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|data
operator|->
name|path
index|[
name|i
index|]
operator|.
name|status
operator|!=
name|NOT_TAKEN
condition|)
break|break;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
name|data
operator|->
name|path_size
operator|=
literal|0
expr_stmt|;
else|else
name|data
operator|->
name|path_size
operator|=
name|path_size
expr_stmt|;
comment|/* End the current branch path.  */
name|data
operator|->
name|path
index|[
name|path_size
index|]
operator|.
name|branch
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Perform cse on the instructions of a function.    F is the first instruction.    NREGS is one plus the highest pseudo-reg number used in the instruction.     AFTER_LOOP is 1 if this is the cse call done after loop optimization    (only if -frerun-cse-after-loop).     Returns 1 if jump_optimize should be redone due to simplifications    in conditional jump instructions.  */
end_comment

begin_function
name|int
name|cse_main
parameter_list|(
name|f
parameter_list|,
name|nregs
parameter_list|,
name|after_loop
parameter_list|,
name|file
parameter_list|)
name|rtx
name|f
decl_stmt|;
name|int
name|nregs
decl_stmt|;
name|int
name|after_loop
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|struct
name|cse_basic_block_data
name|val
decl_stmt|;
specifier|register
name|rtx
name|insn
init|=
name|f
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|cse_jumps_altered
operator|=
literal|0
expr_stmt|;
name|recorded_label_ref
operator|=
literal|0
expr_stmt|;
name|constant_pool_entries_cost
operator|=
literal|0
expr_stmt|;
name|val
operator|.
name|path_size
operator|=
literal|0
expr_stmt|;
name|init_recog
argument_list|()
expr_stmt|;
name|init_alias_analysis
argument_list|()
expr_stmt|;
name|max_reg
operator|=
name|nregs
expr_stmt|;
name|max_insn_uid
operator|=
name|get_max_uid
argument_list|()
expr_stmt|;
name|reg_next_eqv
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|reg_prev_eqv
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOAD_EXTEND_OP
comment|/* Allocate scratch rtl here.  cse_insn will fill in the memory reference      and change the code and mode as appropriate.  */
name|memory_extend_rtx
operator|=
name|gen_rtx_ZERO_EXTEND
argument_list|(
name|VOIDmode
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Discard all the free elements of the previous function      since they are allocated in the temporarily obstack.  */
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|table
argument_list|,
sizeof|sizeof
name|table
argument_list|)
expr_stmt|;
name|free_element_chain
operator|=
literal|0
expr_stmt|;
name|n_elements_made
operator|=
literal|0
expr_stmt|;
comment|/* Find the largest uid.  */
name|max_uid
operator|=
name|get_max_uid
argument_list|()
expr_stmt|;
name|uid_cuid
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|max_uid
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|uid_cuid
argument_list|,
operator|(
name|max_uid
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Compute the mapping from uids to cuids.      CUIDs are numbers assigned to insns, like uids,      except that cuids increase monotonically through the code.      Don't assign cuids to line-number NOTEs, so that the distance in cuids      between two insns is not affected by -g.  */
for|for
control|(
name|insn
operator|=
name|f
operator|,
name|i
operator|=
literal|0
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|<
literal|0
condition|)
name|INSN_CUID
argument_list|(
name|insn
argument_list|)
operator|=
operator|++
name|i
expr_stmt|;
else|else
comment|/* Give a line number note the same cuid as preceding insn.  */
name|INSN_CUID
argument_list|(
name|insn
argument_list|)
operator|=
name|i
expr_stmt|;
block|}
comment|/* Initialize which registers are clobbered by calls.  */
name|CLEAR_HARD_REG_SET
argument_list|(
name|regs_invalidated_by_call
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|call_used_regs
index|[
name|i
index|]
comment|/* Used to check !fixed_regs[i] here, but that isn't safe; 	    fixed regs are still call-clobbered, and sched can get 	    confused if they can "live across calls".  	    The frame pointer is always preserved across calls.  The arg 	    pointer is if it is fixed.  The stack pointer usually is, unless 	    RETURN_POPS_ARGS, in which case an explicit CLOBBER 	    will be present.  If we are generating PIC code, the PIC offset 	    table register is preserved across calls.  */
operator|&&
name|i
operator|!=
name|STACK_POINTER_REGNUM
operator|&&
name|i
operator|!=
name|FRAME_POINTER_REGNUM
if|#
directive|if
name|HARD_FRAME_POINTER_REGNUM
operator|!=
name|FRAME_POINTER_REGNUM
operator|&&
name|i
operator|!=
name|HARD_FRAME_POINTER_REGNUM
endif|#
directive|endif
if|#
directive|if
name|ARG_POINTER_REGNUM
operator|!=
name|FRAME_POINTER_REGNUM
operator|&&
operator|!
operator|(
name|i
operator|==
name|ARG_POINTER_REGNUM
operator|&&
name|fixed_regs
index|[
name|i
index|]
operator|)
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PIC_OFFSET_TABLE_REGNUM
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|PIC_OFFSET_TABLE_REG_CALL_CLOBBERED
argument_list|)
operator|&&
operator|!
operator|(
name|i
operator|==
name|PIC_OFFSET_TABLE_REGNUM
operator|&&
name|flag_pic
operator|)
endif|#
directive|endif
operator|)
operator|||
name|global_regs
index|[
name|i
index|]
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|regs_invalidated_by_call
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Loop over basic blocks.      Compute the maximum number of qty's needed for each basic block      (which is 2 for each SET).  */
name|insn
operator|=
name|f
expr_stmt|;
while|while
condition|(
name|insn
condition|)
block|{
name|cse_end_of_basic_block
argument_list|(
name|insn
argument_list|,
operator|&
name|val
argument_list|,
name|flag_cse_follow_jumps
argument_list|,
name|after_loop
argument_list|,
name|flag_cse_skip_blocks
argument_list|)
expr_stmt|;
comment|/* If this basic block was already processed or has no sets, skip it.  */
if|if
condition|(
name|val
operator|.
name|nsets
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|insn
argument_list|)
operator|==
name|QImode
condition|)
block|{
name|PUT_MODE
argument_list|(
name|insn
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
name|insn
operator|=
operator|(
name|val
operator|.
name|last
condition|?
name|NEXT_INSN
argument_list|(
name|val
operator|.
name|last
argument_list|)
else|:
literal|0
operator|)
expr_stmt|;
name|val
operator|.
name|path_size
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|cse_basic_block_start
operator|=
name|val
operator|.
name|low_cuid
expr_stmt|;
name|cse_basic_block_end
operator|=
name|val
operator|.
name|high_cuid
expr_stmt|;
name|max_qty
operator|=
name|val
operator|.
name|nsets
operator|*
literal|2
expr_stmt|;
if|if
condition|(
name|file
condition|)
name|fnotice
argument_list|(
name|file
argument_list|,
literal|";; Processing block from %d to %d, %d sets.\n"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|val
operator|.
name|last
condition|?
name|INSN_UID
argument_list|(
name|val
operator|.
name|last
argument_list|)
else|:
literal|0
argument_list|,
name|val
operator|.
name|nsets
argument_list|)
expr_stmt|;
comment|/* Make MAX_QTY bigger to give us room to optimize 	 past the end of this basic block, if that should prove useful.  */
if|if
condition|(
name|max_qty
operator|<
literal|500
condition|)
name|max_qty
operator|=
literal|500
expr_stmt|;
name|max_qty
operator|+=
name|max_reg
expr_stmt|;
comment|/* If this basic block is being extended by following certain jumps,          (see `cse_end_of_basic_block'), we reprocess the code from the start.          Otherwise, we start after this basic block.  */
if|if
condition|(
name|val
operator|.
name|path_size
operator|>
literal|0
condition|)
name|cse_basic_block
argument_list|(
name|insn
argument_list|,
name|val
operator|.
name|last
argument_list|,
name|val
operator|.
name|path
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|old_cse_jumps_altered
init|=
name|cse_jumps_altered
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
comment|/* When cse changes a conditional jump to an unconditional 	     jump, we want to reprocess the block, since it will give 	     us a new branch path to investigate.  */
name|cse_jumps_altered
operator|=
literal|0
expr_stmt|;
name|temp
operator|=
name|cse_basic_block
argument_list|(
name|insn
argument_list|,
name|val
operator|.
name|last
argument_list|,
name|val
operator|.
name|path
argument_list|,
operator|!
name|after_loop
argument_list|)
expr_stmt|;
if|if
condition|(
name|cse_jumps_altered
operator|==
literal|0
operator|||
operator|(
name|flag_cse_follow_jumps
operator|==
literal|0
operator|&&
name|flag_cse_skip_blocks
operator|==
literal|0
operator|)
condition|)
name|insn
operator|=
name|temp
expr_stmt|;
name|cse_jumps_altered
operator||=
name|old_cse_jumps_altered
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|USE_C_ALLOCA
name|alloca
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Tell refers_to_mem_p that qty_const info is not available.  */
name|qty_const
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|max_elements_made
operator|<
name|n_elements_made
condition|)
name|max_elements_made
operator|=
name|n_elements_made
expr_stmt|;
return|return
name|cse_jumps_altered
operator|||
name|recorded_label_ref
return|;
block|}
end_function

begin_comment
comment|/* Process a single basic block.  FROM and TO and the limits of the basic    block.  NEXT_BRANCH points to the branch path when following jumps or    a null path when not following jumps.     AROUND_LOOP is non-zero if we are to try to cse around to the start of a    loop.  This is true when we are being called for the last time on a    block and this CSE pass is before loop.c.  */
end_comment

begin_function
specifier|static
name|rtx
name|cse_basic_block
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|,
name|next_branch
parameter_list|,
name|around_loop
parameter_list|)
specifier|register
name|rtx
name|from
decl_stmt|,
name|to
decl_stmt|;
name|struct
name|branch_path
modifier|*
name|next_branch
decl_stmt|;
name|int
name|around_loop
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
decl_stmt|;
name|int
name|to_usage
init|=
literal|0
decl_stmt|;
name|rtx
name|libcall_insn
init|=
name|NULL_RTX
decl_stmt|;
name|int
name|num_insns
init|=
literal|0
decl_stmt|;
comment|/* Each of these arrays is undefined before max_reg, so only allocate      the space actually needed and adjust the start below.  */
name|qty_first_reg
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|max_qty
operator|-
name|max_reg
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|qty_last_reg
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|max_qty
operator|-
name|max_reg
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|qty_mode
operator|=
operator|(
expr|enum
name|machine_mode
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|max_qty
operator|-
name|max_reg
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|enum
name|machine_mode
argument_list|)
argument_list|)
expr_stmt|;
name|qty_const
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|max_qty
operator|-
name|max_reg
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|qty_const_insn
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|max_qty
operator|-
name|max_reg
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|qty_comparison_code
operator|=
operator|(
expr|enum
name|rtx_code
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|max_qty
operator|-
name|max_reg
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|enum
name|rtx_code
argument_list|)
argument_list|)
expr_stmt|;
name|qty_comparison_qty
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|max_qty
operator|-
name|max_reg
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|qty_comparison_const
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|max_qty
operator|-
name|max_reg
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|qty_first_reg
operator|-=
name|max_reg
expr_stmt|;
name|qty_last_reg
operator|-=
name|max_reg
expr_stmt|;
name|qty_mode
operator|-=
name|max_reg
expr_stmt|;
name|qty_const
operator|-=
name|max_reg
expr_stmt|;
name|qty_const_insn
operator|-=
name|max_reg
expr_stmt|;
name|qty_comparison_code
operator|-=
name|max_reg
expr_stmt|;
name|qty_comparison_qty
operator|-=
name|max_reg
expr_stmt|;
name|qty_comparison_const
operator|-=
name|max_reg
expr_stmt|;
name|new_basic_block
argument_list|()
expr_stmt|;
comment|/* TO might be a label.  If so, protect it from being deleted.  */
if|if
condition|(
name|to
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|CODE_LABEL
condition|)
operator|++
name|LABEL_NUSES
argument_list|(
name|to
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|from
init|;
name|insn
operator|!=
name|to
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
specifier|register
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* If we have processed 1,000 insns, flush the hash table to 	 avoid extreme quadratic behavior.  We must not include NOTEs 	 in the count since there may be more or them when generating 	 debugging information.  If we clear the table at different 	 times, code generated with -g -O might be different than code 	 generated with -O but not -g.  	 ??? This is a real kludge and needs to be done some other way. 	 Perhaps for 2.9.  */
if|if
condition|(
name|code
operator|!=
name|NOTE
operator|&&
name|num_insns
operator|++
operator|>
literal|1000
condition|)
block|{
name|flush_hash_table
argument_list|()
expr_stmt|;
name|num_insns
operator|=
literal|0
expr_stmt|;
block|}
comment|/* See if this is a branch that is part of the path.  If so, and it is 	 to be taken, do so.  */
if|if
condition|(
name|next_branch
operator|->
name|branch
operator|==
name|insn
condition|)
block|{
name|enum
name|taken
name|status
init|=
name|next_branch
operator|++
operator|->
name|status
decl_stmt|;
if|if
condition|(
name|status
operator|!=
name|NOT_TAKEN
condition|)
block|{
if|if
condition|(
name|status
operator|==
name|TAKEN
condition|)
name|record_jump_equiv
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|invalidate_skipped_block
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set the last insn as the jump insn; it doesn't affect cc0. 		 Then follow this branch.  */
ifdef|#
directive|ifdef
name|HAVE_cc0
name|prev_insn_cc0
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|prev_insn
operator|=
name|insn
expr_stmt|;
name|insn
operator|=
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|GET_MODE
argument_list|(
name|insn
argument_list|)
operator|==
name|QImode
condition|)
name|PUT_MODE
argument_list|(
name|insn
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'i'
condition|)
block|{
name|rtx
name|p
decl_stmt|;
comment|/* Process notes first so we have all notes in canonical forms when 	     looking for duplicate operations.  */
if|if
condition|(
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
condition|)
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|cse_process_notes
argument_list|(
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
comment|/* Track when we are inside in LIBCALL block.  Inside such a block, 	     we do not want to record destinations.  The last insn of a 	     LIBCALL block is not considered to be part of the block, since 	     its destination is the result of the block and hence should be 	     recorded.  */
if|if
condition|(
operator|(
name|p
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_LIBCALL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
condition|)
name|libcall_insn
operator|=
name|XEXP
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
name|libcall_insn
operator|=
name|NULL_RTX
expr_stmt|;
name|cse_insn
argument_list|(
name|insn
argument_list|,
name|libcall_insn
argument_list|)
expr_stmt|;
block|}
comment|/* If INSN is now an unconditional jump, skip to the end of our 	 basic block by pretending that we just did the last insn in the 	 basic block.  If we are jumping to the end of our block, show 	 that we can have one usage of TO.  */
if|if
condition|(
name|simplejump_p
argument_list|(
name|insn
argument_list|)
condition|)
block|{
if|if
condition|(
name|to
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|==
name|to
condition|)
name|to_usage
operator|=
literal|1
expr_stmt|;
comment|/* Maybe TO was deleted because the jump is unconditional. 	     If so, there is nothing left in this basic block.  */
comment|/* ??? Perhaps it would be smarter to set TO 	     to whatever follows this insn,  	     and pretend the basic block had always ended here.  */
if|if
condition|(
name|INSN_DELETED_P
argument_list|(
name|to
argument_list|)
condition|)
break|break;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|to
argument_list|)
expr_stmt|;
block|}
comment|/* See if it is ok to keep on going past the label 	 which used to end our basic block.  Remember that we incremented 	 the count of that label, so we decrement it here.  If we made 	 a jump unconditional, TO_USAGE will be one; in that case, we don't 	 want to count the use in that jump.  */
if|if
condition|(
name|to
operator|!=
literal|0
operator|&&
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|==
name|to
operator|&&
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|CODE_LABEL
operator|&&
operator|--
name|LABEL_NUSES
argument_list|(
name|to
argument_list|)
operator|==
name|to_usage
condition|)
block|{
name|struct
name|cse_basic_block_data
name|val
decl_stmt|;
name|rtx
name|prev
decl_stmt|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|LABEL_NUSES
argument_list|(
name|to
argument_list|)
operator|==
literal|0
condition|)
name|insn
operator|=
name|delete_insn
argument_list|(
name|to
argument_list|)
expr_stmt|;
comment|/* If TO was the last insn in the function, we are done.  */
if|if
condition|(
name|insn
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* If TO was preceded by a BARRIER we are done with this block 	     because it has no continuation.  */
name|prev
operator|=
name|prev_nonnote_insn
argument_list|(
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|&&
name|GET_CODE
argument_list|(
name|prev
argument_list|)
operator|==
name|BARRIER
condition|)
return|return
name|insn
return|;
comment|/* Find the end of the following block.  Note that we won't be 	     following branches in this case.  */
name|to_usage
operator|=
literal|0
expr_stmt|;
name|val
operator|.
name|path_size
operator|=
literal|0
expr_stmt|;
name|cse_end_of_basic_block
argument_list|(
name|insn
argument_list|,
operator|&
name|val
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If the tables we allocated have enough space left 	     to handle all the SETs in the next basic block, 	     continue through it.  Otherwise, return, 	     and that block will be scanned individually.  */
if|if
condition|(
name|val
operator|.
name|nsets
operator|*
literal|2
operator|+
name|next_qty
operator|>
name|max_qty
condition|)
break|break;
name|cse_basic_block_start
operator|=
name|val
operator|.
name|low_cuid
expr_stmt|;
name|cse_basic_block_end
operator|=
name|val
operator|.
name|high_cuid
expr_stmt|;
name|to
operator|=
name|val
operator|.
name|last
expr_stmt|;
comment|/* Prevent TO from being deleted if it is a label.  */
if|if
condition|(
name|to
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|CODE_LABEL
condition|)
operator|++
name|LABEL_NUSES
argument_list|(
name|to
argument_list|)
expr_stmt|;
comment|/* Back up so we process the first insn in the extension.  */
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|next_qty
operator|>
name|max_qty
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If we are running before loop.c, we stopped on a NOTE_INSN_LOOP_END, and      the previous insn is the only insn that branches to the head of a loop,      we can cse into the loop.  Don't do this if we changed the jump      structure of a loop unless we aren't going to be following jumps.  */
if|if
condition|(
operator|(
name|cse_jumps_altered
operator|==
literal|0
operator|||
operator|(
name|flag_cse_follow_jumps
operator|==
literal|0
operator|&&
name|flag_cse_skip_blocks
operator|==
literal|0
operator|)
operator|)
operator|&&
name|around_loop
operator|&&
name|to
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|to
argument_list|)
operator|==
name|NOTE_INSN_LOOP_END
operator|&&
name|GET_CODE
argument_list|(
name|PREV_INSN
argument_list|(
name|to
argument_list|)
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|JUMP_LABEL
argument_list|(
name|PREV_INSN
argument_list|(
name|to
argument_list|)
argument_list|)
operator|!=
literal|0
operator|&&
name|LABEL_NUSES
argument_list|(
name|JUMP_LABEL
argument_list|(
name|PREV_INSN
argument_list|(
name|to
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|1
condition|)
name|cse_around_loop
argument_list|(
name|JUMP_LABEL
argument_list|(
name|PREV_INSN
argument_list|(
name|to
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|to
condition|?
name|NEXT_INSN
argument_list|(
name|to
argument_list|)
else|:
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Count the number of times registers are used (not set) in X.    COUNTS is an array in which we accumulate the count, INCR is how much    we count each register usage.       Don't count a usage of DEST, which is the SET_DEST of a SET which     contains X in its SET_SRC.  This is because such a SET does not    modify the liveness of DEST.  */
end_comment

begin_function
specifier|static
name|void
name|count_reg_usage
parameter_list|(
name|x
parameter_list|,
name|counts
parameter_list|,
name|dest
parameter_list|,
name|incr
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|int
modifier|*
name|counts
decl_stmt|;
name|rtx
name|dest
decl_stmt|;
name|int
name|incr
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
decl_stmt|;
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return;
switch|switch
condition|(
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
if|if
condition|(
name|x
operator|!=
name|dest
condition|)
name|counts
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
operator|+=
name|incr
expr_stmt|;
return|return;
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|CONST
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
return|return;
case|case
name|CLOBBER
case|:
comment|/* If we are clobbering a MEM, mark any registers inside the address          as being used.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
name|count_reg_usage
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|counts
argument_list|,
name|NULL_RTX
argument_list|,
name|incr
argument_list|)
expr_stmt|;
return|return;
case|case
name|SET
case|:
comment|/* Unless we are setting a REG, count everything in SET_DEST.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
name|count_reg_usage
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|counts
argument_list|,
name|NULL_RTX
argument_list|,
name|incr
argument_list|)
expr_stmt|;
comment|/* If SRC has side-effects, then we can't delete this insn, so the 	 usage of SET_DEST inside SRC counts.  	 ??? Strictly-speaking, we might be preserving this insn 	 because some other SET has side-effects, but that's hard 	 to do and can't happen now.  */
name|count_reg_usage
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|counts
argument_list|,
name|side_effects_p
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
condition|?
name|NULL_RTX
else|:
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|incr
argument_list|)
expr_stmt|;
return|return;
case|case
name|CALL_INSN
case|:
name|count_reg_usage
argument_list|(
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|x
argument_list|)
argument_list|,
name|counts
argument_list|,
name|NULL_RTX
argument_list|,
name|incr
argument_list|)
expr_stmt|;
comment|/* ... falls through ...  */
case|case
name|INSN
case|:
case|case
name|JUMP_INSN
case|:
name|count_reg_usage
argument_list|(
name|PATTERN
argument_list|(
name|x
argument_list|)
argument_list|,
name|counts
argument_list|,
name|NULL_RTX
argument_list|,
name|incr
argument_list|)
expr_stmt|;
comment|/* Things used in a REG_EQUAL note aren't dead since loop may try to 	 use them.  */
name|count_reg_usage
argument_list|(
name|REG_NOTES
argument_list|(
name|x
argument_list|)
argument_list|,
name|counts
argument_list|,
name|NULL_RTX
argument_list|,
name|incr
argument_list|)
expr_stmt|;
return|return;
case|case
name|EXPR_LIST
case|:
case|case
name|INSN_LIST
case|:
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|x
argument_list|)
operator|==
name|REG_EQUAL
operator|||
operator|(
name|REG_NOTE_KIND
argument_list|(
name|x
argument_list|)
operator|!=
name|REG_NONNEG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|USE
operator|)
condition|)
name|count_reg_usage
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|counts
argument_list|,
name|NULL_RTX
argument_list|,
name|incr
argument_list|)
expr_stmt|;
name|count_reg_usage
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|counts
argument_list|,
name|NULL_RTX
argument_list|,
name|incr
argument_list|)
expr_stmt|;
return|return;
default|default:
break|break;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|count_reg_usage
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|counts
argument_list|,
name|dest
argument_list|,
name|incr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|count_reg_usage
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|counts
argument_list|,
name|dest
argument_list|,
name|incr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Scan all the insns and delete any that are dead; i.e., they store a register    that is never used or they copy a register to itself.     This is used to remove insns made obviously dead by cse, loop or other    optimizations.  It improves the heuristics in loop since it won't try to    move dead invariants out of loops or make givs for dead quantities.  The    remaining passes of the compilation are also sped up.  */
end_comment

begin_function
name|void
name|delete_trivially_dead_insns
parameter_list|(
name|insns
parameter_list|,
name|nreg
parameter_list|)
name|rtx
name|insns
decl_stmt|;
name|int
name|nreg
decl_stmt|;
block|{
name|int
modifier|*
name|counts
init|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|nreg
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|insn
decl_stmt|,
name|prev
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
name|rtx
name|tem
decl_stmt|;
endif|#
directive|endif
name|int
name|i
decl_stmt|;
name|int
name|in_libcall
init|=
literal|0
decl_stmt|,
name|dead_libcall
init|=
literal|0
decl_stmt|;
comment|/* First count the number of times each register is used.  */
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|counts
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|nreg
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|next_real_insn
argument_list|(
name|insns
argument_list|)
init|;
name|insn
condition|;
name|insn
operator|=
name|next_real_insn
argument_list|(
name|insn
argument_list|)
control|)
name|count_reg_usage
argument_list|(
name|insn
argument_list|,
name|counts
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Go from the last insn to the first and delete insns that only set unused      registers or copy a register to itself.  As we delete an insn, remove      usage counts for registers it uses.  */
for|for
control|(
name|insn
operator|=
name|prev_real_insn
argument_list|(
name|get_last_insn
argument_list|()
argument_list|)
init|;
name|insn
condition|;
name|insn
operator|=
name|prev
control|)
block|{
name|int
name|live_insn
init|=
literal|0
decl_stmt|;
name|rtx
name|note
decl_stmt|;
name|prev
operator|=
name|prev_real_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Don't delete any insns that are part of a libcall block unless 	 we can delete the whole libcall block.  	 Flow or loop might get confused if we did that.  Remember 	 that we are scanning backwards.  */
if|if
condition|(
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
block|{
name|in_libcall
operator|=
literal|1
expr_stmt|;
name|live_insn
operator|=
literal|1
expr_stmt|;
name|dead_libcall
operator|=
literal|0
expr_stmt|;
comment|/* See if there's a REG_EQUAL note on this insn and try to 	     replace the source with the REG_EQUAL expression. 	 	     We assume that insns with REG_RETVALs can only be reg->reg 	     copies at this point.  */
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
condition|)
block|{
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|set
operator|&&
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|remove_note
argument_list|(
name|insn
argument_list|,
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|)
expr_stmt|;
name|dead_libcall
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|in_libcall
condition|)
name|live_insn
operator|=
operator|!
name|dead_libcall
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
empty_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|CC0
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|(
operator|(
name|tem
operator|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
operator|)
operator|==
literal|0
operator|||
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|!=
literal|'i'
operator|||
operator|!
name|reg_referenced_p
argument_list|(
name|cc0_rtx
argument_list|,
name|PATTERN
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|)
condition|)
empty_stmt|;
endif|#
directive|endif
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|||
name|counts
index|[
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
index|]
operator|!=
literal|0
operator|||
name|side_effects_p
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
condition|)
name|live_insn
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|)
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|rtx
name|elt
init|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|elt
argument_list|)
operator|==
name|SET
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|SET_DEST
argument_list|(
name|elt
argument_list|)
operator|==
name|SET_SRC
argument_list|(
name|elt
argument_list|)
condition|)
empty_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|==
name|CC0
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|&&
operator|(
operator|(
name|tem
operator|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
operator|)
operator|==
literal|0
operator|||
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|!=
literal|'i'
operator|||
operator|!
name|reg_referenced_p
argument_list|(
name|cc0_rtx
argument_list|,
name|PATTERN
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|)
condition|)
empty_stmt|;
endif|#
directive|endif
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|||
name|counts
index|[
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|)
index|]
operator|!=
literal|0
operator|||
name|side_effects_p
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|)
condition|)
name|live_insn
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|elt
argument_list|)
operator|!=
name|CLOBBER
operator|&&
name|GET_CODE
argument_list|(
name|elt
argument_list|)
operator|!=
name|USE
condition|)
name|live_insn
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|live_insn
operator|=
literal|1
expr_stmt|;
comment|/* If this is a dead insn, delete it and show registers in it aren't 	 being used.  */
if|if
condition|(
operator|!
name|live_insn
condition|)
block|{
name|count_reg_usage
argument_list|(
name|insn
argument_list|,
name|counts
argument_list|,
name|NULL_RTX
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_LIBCALL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
block|{
name|in_libcall
operator|=
literal|0
expr_stmt|;
name|dead_libcall
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

