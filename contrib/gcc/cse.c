begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Common subexpression elimination for GNU compiler.    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998    1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_comment
comment|/* stdio.h must precede rtl.h for FFS.  */
end_comment

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_comment
comment|/* The basic idea of common subexpression elimination is to go    through the code, keeping a record of expressions that would    have the same value at the current scan point, and replacing    expressions encountered with the cheapest equivalent expression.     It is too complicated to keep track of the different possibilities    when control paths merge in this code; so, at each label, we forget all    that is known and start fresh.  This can be described as processing each    extended basic block separately.  We have a separate pass to perform    global CSE.     Note CSE can turn a conditional or computed jump into a nop or    an unconditional jump.  When this occurs we arrange to run the jump    optimizer after CSE to delete the unreachable code.     We use two data structures to record the equivalent expressions:    a hash table for most expressions, and a vector of "quantity    numbers" to record equivalent (pseudo) registers.     The use of the special data structure for registers is desirable    because it is faster.  It is possible because registers references    contain a fairly small number, the register number, taken from    a contiguously allocated series, and two register references are    identical if they have the same number.  General expressions    do not have any such thing, so the only way to retrieve the    information recorded on an expression other than a register    is to keep it in a hash table.  Registers and "quantity numbers":     At the start of each basic block, all of the (hardware and pseudo)    registers used in the function are given distinct quantity    numbers to indicate their contents.  During scan, when the code    copies one register into another, we copy the quantity number.    When a register is loaded in any other way, we allocate a new    quantity number to describe the value generated by this operation.    `reg_qty' records what quantity a register is currently thought    of as containing.     All real quantity numbers are greater than or equal to zero.    If register N has not been assigned a quantity, reg_qty[N] will    equal -N - 1, which is always negative.     Quantity numbers below zero do not exist and none of the `qty_table'    entries should be referenced with a negative index.     We also maintain a bidirectional chain of registers for each    quantity number.  The `qty_table` members `first_reg' and `last_reg',    and `reg_eqv_table' members `next' and `prev' hold these chains.     The first register in a chain is the one whose lifespan is least local.    Among equals, it is the one that was seen first.    We replace any equivalent register with that one.     If two registers have the same quantity number, it must be true that    REG expressions with qty_table `mode' must be in the hash table for both    registers and must be in the same class.     The converse is not true.  Since hard registers may be referenced in    any mode, two REG expressions might be equivalent in the hash table    but not have the same quantity number if the quantity number of one    of the registers is not the same mode as those expressions.  Constants and quantity numbers     When a quantity has a known constant value, that value is stored    in the appropriate qty_table `const_rtx'.  This is in addition to    putting the constant in the hash table as is usual for non-regs.     Whether a reg or a constant is preferred is determined by the configuration    macro CONST_COSTS and will often depend on the constant value.  In any    event, expressions containing constants can be simplified, by fold_rtx.     When a quantity has a known nearly constant value (such as an address    of a stack slot), that value is stored in the appropriate qty_table    `const_rtx'.     Integer constants don't have a machine mode.  However, cse    determines the intended machine mode from the destination    of the instruction that moves the constant.  The machine mode    is recorded in the hash table along with the actual RTL    constant expression so that different modes are kept separate.  Other expressions:     To record known equivalences among expressions in general    we use a hash table called `table'.  It has a fixed number of buckets    that contain chains of `struct table_elt' elements for expressions.    These chains connect the elements whose expressions have the same    hash codes.     Other chains through the same elements connect the elements which    currently have equivalent values.     Register references in an expression are canonicalized before hashing    the expression.  This is done using `reg_qty' and qty_table `first_reg'.    The hash code of a register reference is computed using the quantity    number, not the register number.     When the value of an expression changes, it is necessary to remove from the    hash table not just that expression but all expressions whose values    could be different as a result.       1. If the value changing is in memory, except in special cases      ANYTHING referring to memory could be changed.  That is because      nobody knows where a pointer does not point.      The function `invalidate_memory' removes what is necessary.       The special cases are when the address is constant or is      a constant plus a fixed register such as the frame pointer      or a static chain pointer.  When such addresses are stored in,      we can tell exactly which other such addresses must be invalidated      due to overlap.  `invalidate' does this.      All expressions that refer to non-constant      memory addresses are also invalidated.  `invalidate_memory' does this.       2. If the value changing is a register, all expressions      containing references to that register, and only those,      must be removed.     Because searching the entire hash table for expressions that contain    a register is very slow, we try to figure out when it isn't necessary.    Precisely, this is necessary only when expressions have been    entered in the hash table using this register, and then the value has    changed, and then another expression wants to be added to refer to    the register's new value.  This sequence of circumstances is rare    within any one basic block.     The vectors `reg_tick' and `reg_in_table' are used to detect this case.    reg_tick[i] is incremented whenever a value is stored in register i.    reg_in_table[i] holds -1 if no references to register i have been    entered in the table; otherwise, it contains the value reg_tick[i] had    when the references were entered.  If we want to enter a reference    and reg_in_table[i] != reg_tick[i], we must scan and remove old references.    Until we want to enter a new entry, the mere fact that the two vectors    don't match makes the entries be ignored if anyone tries to match them.     Registers themselves are entered in the hash table as well as in    the equivalent-register chains.  However, the vectors `reg_tick'    and `reg_in_table' do not apply to expressions which are simple    register references.  These expressions are removed from the table    immediately when they become invalid, and this can be done even if    we do not immediately search for all the expressions that refer to    the register.     A CLOBBER rtx in an instruction invalidates its operand for further    reuse.  A CLOBBER or SET rtx whose operand is a MEM:BLK    invalidates everything that resides in memory.  Related expressions:     Constant expressions that differ only by an additive integer    are called related.  When a constant expression is put in    the table, the related expression with no constant term    is also entered.  These are made to point at each other    so that it is possible to find out if there exists any    register equivalent to an expression related to a given expression.  */
end_comment

begin_comment
comment|/* One plus largest register number used in this function.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_reg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* One plus largest instruction UID used in this function at time of    cse_main call.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_insn_uid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Length of qty_table vector.  We know in advance we will not need    a quantity number this big.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_qty
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Next quantity number to be allocated.    This is 1 + the largest number needed so far.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|next_qty
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Per-qty information tracking.     `first_reg' and `last_reg' track the head and tail of the    chain of registers which currently contain this quantity.     `mode' contains the machine mode of this quantity.     `const_rtx' holds the rtx of the constant value of this    quantity, if known.  A summations of the frame/arg pointer    and a constant can also be entered here.  When this holds    a known value, `const_insn' is the insn which stored the    constant value.     `comparison_{code,const,qty}' are used to track when a    comparison between a quantity and some constant or register has    been passed.  In such a case, we know the results of the comparison    in case we see it again.  These members record a comparison that    is known to be true.  `comparison_code' holds the rtx code of such    a comparison, else it is set to UNKNOWN and the other two    comparison members are undefined.  `comparison_const' holds    the constant being compared against, or zero if the comparison    is not against a constant.  `comparison_qty' holds the quantity    being compared against when the result is known.  If the comparison    is not with a register, `comparison_qty' is -1.  */
end_comment

begin_struct
struct|struct
name|qty_table_elem
block|{
name|rtx
name|const_rtx
decl_stmt|;
name|rtx
name|const_insn
decl_stmt|;
name|rtx
name|comparison_const
decl_stmt|;
name|int
name|comparison_qty
decl_stmt|;
name|unsigned
name|int
name|first_reg
decl_stmt|,
name|last_reg
decl_stmt|;
comment|/* The sizes of these fields should match the sizes of the      code and mode fields of struct rtx_def (see rtl.h).  */
name|ENUM_BITFIELD
argument_list|(
argument|rtx_code
argument_list|)
name|comparison_code
label|:
literal|16
expr_stmt|;
name|ENUM_BITFIELD
argument_list|(
argument|machine_mode
argument_list|)
name|mode
label|:
literal|8
expr_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The table of all qtys, indexed by qty number.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|qty_table_elem
modifier|*
name|qty_table
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_cc0
end_ifdef

begin_comment
comment|/* For machines that have a CC0, we do not record its value in the hash    table since its use is guaranteed to be the insn immediately following    its definition and any other insn is presumed to invalidate it.     Instead, we store below the value last assigned to CC0.  If it should    happen to be a constant, it is stored in preference to the actual    assigned value.  In case it is a constant, we store the mode in which    the constant should be interpreted.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|prev_insn_cc0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|machine_mode
name|prev_insn_cc0_mode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Previous actual insn.  0 if at first insn of basic block.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|prev_insn
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Insn being scanned.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|this_insn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index by register number, gives the number of the next (or    previous) register in the chain of registers sharing the same    value.     Or -1 if this register is at the end of the chain.     If reg_qty[N] == N, reg_eqv_table[N].next is undefined.  */
end_comment

begin_comment
comment|/* Per-register equivalence chain.  */
end_comment

begin_struct
struct|struct
name|reg_eqv_elem
block|{
name|int
name|next
decl_stmt|,
name|prev
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The table of all register equivalence chains.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|reg_eqv_elem
modifier|*
name|reg_eqv_table
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|cse_reg_info
block|{
comment|/* Next in hash chain.  */
name|struct
name|cse_reg_info
modifier|*
name|hash_next
decl_stmt|;
comment|/* The next cse_reg_info structure in the free or used list.  */
name|struct
name|cse_reg_info
modifier|*
name|next
decl_stmt|;
comment|/* Search key */
name|unsigned
name|int
name|regno
decl_stmt|;
comment|/* The quantity number of the register's current contents.  */
name|int
name|reg_qty
decl_stmt|;
comment|/* The number of times the register has been altered in the current      basic block.  */
name|int
name|reg_tick
decl_stmt|;
comment|/* The REG_TICK value at which rtx's containing this register are      valid in the hash table.  If this does not equal the current      reg_tick value, such expressions existing in the hash table are      invalid.  */
name|int
name|reg_in_table
decl_stmt|;
comment|/* The SUBREG that was set when REG_TICK was last incremented.  Set      to -1 if the last store was to the whole register, not a subreg.  */
name|unsigned
name|int
name|subreg_ticked
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A free list of cse_reg_info entries.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cse_reg_info
modifier|*
name|cse_reg_info_free_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A used list of cse_reg_info entries.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cse_reg_info
modifier|*
name|cse_reg_info_used_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cse_reg_info
modifier|*
name|cse_reg_info_used_list_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A mapping from registers to cse_reg_info data structures.  */
end_comment

begin_define
define|#
directive|define
name|REGHASH_SHIFT
value|7
end_define

begin_define
define|#
directive|define
name|REGHASH_SIZE
value|(1<< REGHASH_SHIFT)
end_define

begin_define
define|#
directive|define
name|REGHASH_MASK
value|(REGHASH_SIZE - 1)
end_define

begin_decl_stmt
specifier|static
name|struct
name|cse_reg_info
modifier|*
name|reg_hash
index|[
name|REGHASH_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|REGHASH_FN
parameter_list|(
name|REGNO
parameter_list|)
define|\
value|(((REGNO) ^ ((REGNO)>> REGHASH_SHIFT))& REGHASH_MASK)
end_define

begin_comment
comment|/* The last lookup we did into the cse_reg_info_tree.  This allows us    to cache repeated lookups.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|cached_regno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cse_reg_info
modifier|*
name|cached_cse_reg_info
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A HARD_REG_SET containing all the hard registers for which there is    currently a REG expression in the hash table.  Note the difference    from the above variables, which indicate if the REG is mentioned in some    expression in the table.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|hard_regs_in_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* CUID of insn that starts the basic block currently being cse-processed.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cse_basic_block_start
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* CUID of insn that ends the basic block currently being cse-processed.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cse_basic_block_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Vector mapping INSN_UIDs to cuids.    The cuids are like uids but increase monotonically always.    We use them to see whether a reg is used outside a given basic block.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|uid_cuid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Highest UID in UID_CUID.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_uid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Get the cuid of an insn.  */
end_comment

begin_define
define|#
directive|define
name|INSN_CUID
parameter_list|(
name|INSN
parameter_list|)
value|(uid_cuid[INSN_UID (INSN)])
end_define

begin_comment
comment|/* Nonzero if this pass has made changes, and therefore it's    worthwhile to run the garbage collector.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cse_altered
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if cse has altered conditional jump insns    in such a way that jump optimization should be redone.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cse_jumps_altered
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we put a LABEL_REF into the hash table for an INSN without a    REG_LABEL, we have to rerun jump after CSE to put in the note.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|recorded_label_ref
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* canon_hash stores 1 in do_not_record    if it notices a reference to CC0, PC, or some other volatile    subexpression.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|do_not_record
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|LOAD_EXTEND_OP
end_ifdef

begin_comment
comment|/* Scratch rtl used when looking for load-extended copy of a MEM.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|memory_extend_rtx
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* canon_hash stores 1 in hash_arg_in_memory    if it notices a reference to memory within the expression being hashed.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|hash_arg_in_memory
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The hash table contains buckets which are chains of `struct table_elt's,    each recording one expression's information.    That expression is in the `exp' field.     The canon_exp field contains a canonical (from the point of view of    alias analysis) version of the `exp' field.     Those elements with the same hash code are chained in both directions    through the `next_same_hash' and `prev_same_hash' fields.     Each set of expressions with equivalent values    are on a two-way chain through the `next_same_value'    and `prev_same_value' fields, and all point with    the `first_same_value' field at the first element in    that chain.  The chain is in order of increasing cost.    Each element's cost value is in its `cost' field.     The `in_memory' field is nonzero for elements that    involve any reference to memory.  These elements are removed    whenever a write is done to an unidentified location in memory.    To be safe, we assume that a memory address is unidentified unless    the address is either a symbol constant or a constant plus    the frame pointer or argument pointer.     The `related_value' field is used to connect related expressions    (that differ by adding an integer).    The related expressions are chained in a circular fashion.    `related_value' is zero for expressions for which this    chain is not useful.     The `cost' field stores the cost of this element's expression.    The `regcost' field stores the value returned by approx_reg_cost for    this element's expression.     The `is_const' flag is set if the element is a constant (including    a fixed address).     The `flag' field is used as a temporary during some search routines.     The `mode' field is usually the same as GET_MODE (`exp'), but    if `exp' is a CONST_INT and has no machine mode then the `mode'    field is the mode it was being used as.  Each constant is    recorded separately for each mode it is used with.  */
end_comment

begin_struct
struct|struct
name|table_elt
block|{
name|rtx
name|exp
decl_stmt|;
name|rtx
name|canon_exp
decl_stmt|;
name|struct
name|table_elt
modifier|*
name|next_same_hash
decl_stmt|;
name|struct
name|table_elt
modifier|*
name|prev_same_hash
decl_stmt|;
name|struct
name|table_elt
modifier|*
name|next_same_value
decl_stmt|;
name|struct
name|table_elt
modifier|*
name|prev_same_value
decl_stmt|;
name|struct
name|table_elt
modifier|*
name|first_same_value
decl_stmt|;
name|struct
name|table_elt
modifier|*
name|related_value
decl_stmt|;
name|int
name|cost
decl_stmt|;
name|int
name|regcost
decl_stmt|;
comment|/* The size of this field should match the size      of the mode field of struct rtx_def (see rtl.h).  */
name|ENUM_BITFIELD
argument_list|(
argument|machine_mode
argument_list|)
name|mode
label|:
literal|8
expr_stmt|;
name|char
name|in_memory
decl_stmt|;
name|char
name|is_const
decl_stmt|;
name|char
name|flag
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* We don't want a lot of buckets, because we rarely have very many    things stored in the hash table, and a lot of buckets slows    down a lot of loops that happen frequently.  */
end_comment

begin_define
define|#
directive|define
name|HASH_SHIFT
value|5
end_define

begin_define
define|#
directive|define
name|HASH_SIZE
value|(1<< HASH_SHIFT)
end_define

begin_define
define|#
directive|define
name|HASH_MASK
value|(HASH_SIZE - 1)
end_define

begin_comment
comment|/* Compute hash code of X in mode M.  Special-case case where X is a pseudo    register (hard registers may require `do_not_record' to be set).  */
end_comment

begin_define
define|#
directive|define
name|HASH
parameter_list|(
name|X
parameter_list|,
name|M
parameter_list|)
define|\
value|((GET_CODE (X) == REG&& REGNO (X)>= FIRST_PSEUDO_REGISTER	\   ? (((unsigned) REG<< 7) + (unsigned) REG_QTY (REGNO (X)))	\   : canon_hash (X, M))& HASH_MASK)
end_define

begin_comment
comment|/* Determine whether register number N is considered a fixed register for the    purpose of approximating register costs.    It is desirable to replace other regs with fixed regs, to reduce need for    non-fixed hard regs.    A reg wins if it is either the frame pointer or designated as fixed.  */
end_comment

begin_define
define|#
directive|define
name|FIXED_REGNO_P
parameter_list|(
name|N
parameter_list|)
define|\
value|((N) == FRAME_POINTER_REGNUM || (N) == HARD_FRAME_POINTER_REGNUM \    || fixed_regs[N] || global_regs[N])
end_define

begin_comment
comment|/* Compute cost of X, as stored in the `cost' field of a table_elt.  Fixed    hard registers and pointers into the frame are the cheapest with a cost    of 0.  Next come pseudos with a cost of one and other hard registers with    a cost of 2.  Aside from these special cases, call `rtx_cost'.  */
end_comment

begin_define
define|#
directive|define
name|CHEAP_REGNO
parameter_list|(
name|N
parameter_list|)
define|\
value|((N) == FRAME_POINTER_REGNUM || (N) == HARD_FRAME_POINTER_REGNUM	\    || (N) == STACK_POINTER_REGNUM || (N) == ARG_POINTER_REGNUM		\    || ((N)>= FIRST_VIRTUAL_REGISTER&& (N)<= LAST_VIRTUAL_REGISTER)	\    || ((N)< FIRST_PSEUDO_REGISTER					\&& FIXED_REGNO_P (N)&& REGNO_REG_CLASS (N) != NO_REGS))
end_define

begin_define
define|#
directive|define
name|COST
parameter_list|(
name|X
parameter_list|)
value|(GET_CODE (X) == REG ? 0 : notreg_cost (X, SET))
end_define

begin_define
define|#
directive|define
name|COST_IN
parameter_list|(
name|X
parameter_list|,
name|OUTER
parameter_list|)
value|(GET_CODE (X) == REG ? 0 : notreg_cost (X, OUTER))
end_define

begin_comment
comment|/* Get the info associated with register N.  */
end_comment

begin_define
define|#
directive|define
name|GET_CSE_REG_INFO
parameter_list|(
name|N
parameter_list|)
define|\
value|(((N) == cached_regno&& cached_cse_reg_info)	\    ? cached_cse_reg_info : get_cse_reg_info ((N)))
end_define

begin_comment
comment|/* Get the number of times this register has been updated in this    basic block.  */
end_comment

begin_define
define|#
directive|define
name|REG_TICK
parameter_list|(
name|N
parameter_list|)
value|((GET_CSE_REG_INFO (N))->reg_tick)
end_define

begin_comment
comment|/* Get the point at which REG was recorded in the table.  */
end_comment

begin_define
define|#
directive|define
name|REG_IN_TABLE
parameter_list|(
name|N
parameter_list|)
value|((GET_CSE_REG_INFO (N))->reg_in_table)
end_define

begin_comment
comment|/* Get the SUBREG set at the last increment to REG_TICK (-1 if not a    SUBREG).  */
end_comment

begin_define
define|#
directive|define
name|SUBREG_TICKED
parameter_list|(
name|N
parameter_list|)
value|((GET_CSE_REG_INFO (N))->subreg_ticked)
end_define

begin_comment
comment|/* Get the quantity number for REG.  */
end_comment

begin_define
define|#
directive|define
name|REG_QTY
parameter_list|(
name|N
parameter_list|)
value|((GET_CSE_REG_INFO (N))->reg_qty)
end_define

begin_comment
comment|/* Determine if the quantity number for register X represents a valid index    into the qty_table.  */
end_comment

begin_define
define|#
directive|define
name|REGNO_QTY_VALID_P
parameter_list|(
name|N
parameter_list|)
value|(REG_QTY (N)>= 0)
end_define

begin_decl_stmt
specifier|static
name|struct
name|table_elt
modifier|*
name|table
index|[
name|HASH_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain of `struct table_elt's made so far for this function    but currently removed from the table.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|table_elt
modifier|*
name|free_element_chain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of `struct table_elt' structures made so far for this function.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|n_elements_made
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maximum value `n_elements_made' has had so far in this compilation    for functions previously processed.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_elements_made
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Surviving equivalence class when two equivalence classes are merged    by recording the effects of a jump in the last insn.  Zero if the    last insn was not a conditional jump.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|table_elt
modifier|*
name|last_jump_equiv_class
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to the cost of a constant pool reference if one was found for a    symbolic constant.  If this was found, it means we should try to    convert constants into constant pool entries if they don't fit in    the insn.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|constant_pool_entries_cost
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|constant_pool_entries_regcost
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This data describes a block that will be processed by cse_basic_block.  */
end_comment

begin_struct
struct|struct
name|cse_basic_block_data
block|{
comment|/* Lowest CUID value of insns in block.  */
name|int
name|low_cuid
decl_stmt|;
comment|/* Highest CUID value of insns in block.  */
name|int
name|high_cuid
decl_stmt|;
comment|/* Total number of SETs in block.  */
name|int
name|nsets
decl_stmt|;
comment|/* Last insn in the block.  */
name|rtx
name|last
decl_stmt|;
comment|/* Size of current branch path, if any.  */
name|int
name|path_size
decl_stmt|;
comment|/* Current branch path, indicating which branches will be taken.  */
struct|struct
name|branch_path
block|{
comment|/* The branch insn.  */
name|rtx
name|branch
decl_stmt|;
comment|/* Whether it should be taken or not.  AROUND is the same as taken 	 except that it is used when the destination label is not preceded        by a BARRIER.  */
enum|enum
name|taken
block|{
name|TAKEN
block|,
name|NOT_TAKEN
block|,
name|AROUND
block|}
name|status
enum|;
block|}
modifier|*
name|path
struct|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|bool
name|fixed_base_plus_p
parameter_list|(
name|rtx
name|x
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|notreg_cost
parameter_list|(
name|rtx
parameter_list|,
name|enum
name|rtx_code
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|approx_reg_cost_1
parameter_list|(
name|rtx
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|approx_reg_cost
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|preferrable
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|new_basic_block
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|make_new_qty
parameter_list|(
name|unsigned
name|int
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|make_regs_eqv
parameter_list|(
name|unsigned
name|int
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|delete_reg_equiv
parameter_list|(
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mention_regs
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|insert_regs
parameter_list|(
name|rtx
parameter_list|,
name|struct
name|table_elt
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remove_from_table
parameter_list|(
name|struct
name|table_elt
modifier|*
parameter_list|,
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|table_elt
modifier|*
name|lookup
parameter_list|(
name|rtx
parameter_list|,
name|unsigned
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|table_elt
modifier|*
name|lookup_for_remove
parameter_list|(
name|rtx
parameter_list|,
name|unsigned
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|lookup_as_function
parameter_list|(
name|rtx
parameter_list|,
name|enum
name|rtx_code
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|table_elt
modifier|*
name|insert
parameter_list|(
name|rtx
parameter_list|,
name|struct
name|table_elt
modifier|*
parameter_list|,
name|unsigned
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|merge_equiv_classes
parameter_list|(
name|struct
name|table_elt
modifier|*
parameter_list|,
name|struct
name|table_elt
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|invalidate
parameter_list|(
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cse_rtx_varies_p
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remove_invalid_refs
parameter_list|(
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remove_invalid_subreg_refs
parameter_list|(
name|unsigned
name|int
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rehash_using_reg
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|invalidate_memory
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|invalidate_for_call
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|use_related_value
parameter_list|(
name|rtx
parameter_list|,
name|struct
name|table_elt
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|canon_hash
parameter_list|(
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|canon_hash_string
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|safe_hash
parameter_list|(
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|exp_equiv_p
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|canon_reg
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|find_best_addr
parameter_list|(
name|rtx
parameter_list|,
name|rtx
modifier|*
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|rtx_code
name|find_comparison_args
parameter_list|(
name|enum
name|rtx_code
parameter_list|,
name|rtx
modifier|*
parameter_list|,
name|rtx
modifier|*
parameter_list|,
name|enum
name|machine_mode
modifier|*
parameter_list|,
name|enum
name|machine_mode
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|fold_rtx
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|equiv_constant
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|record_jump_equiv
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|record_jump_cond
parameter_list|(
name|enum
name|rtx_code
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cse_insn
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|addr_affects_sp_p
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|invalidate_from_clobbers
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|cse_process_notes
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cse_around_loop
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|invalidate_skipped_set
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|invalidate_skipped_block
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cse_check_loop_start
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cse_set_around_loop
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|cse_basic_block
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|struct
name|branch_path
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|count_reg_usage
parameter_list|(
name|rtx
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|check_for_label_ref
parameter_list|(
name|rtx
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|dump_class
parameter_list|(
name|struct
name|table_elt
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|cse_reg_info
modifier|*
name|get_cse_reg_info
parameter_list|(
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|check_dependence
parameter_list|(
name|rtx
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|flush_hash_table
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|insn_live_p
parameter_list|(
name|rtx
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|set_live_p
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|dead_libcall_p
parameter_list|(
name|rtx
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cse_change_cc_mode
parameter_list|(
name|rtx
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cse_change_cc_mode_insns
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|machine_mode
name|cse_cc_succs
parameter_list|(
name|basic_block
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Nonzero if X has the form (PLUS frame-pointer integer).  We check for    virtual regs here because the simplify_*_operation routines are called    by integrate.c, which is called before virtual register instantiation.  */
end_comment

begin_function
specifier|static
name|bool
name|fixed_base_plus_p
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
if|if
condition|(
name|x
operator|==
name|frame_pointer_rtx
operator|||
name|x
operator|==
name|hard_frame_pointer_rtx
condition|)
return|return
name|true
return|;
if|if
condition|(
name|x
operator|==
name|arg_pointer_rtx
operator|&&
name|fixed_regs
index|[
name|ARG_POINTER_REGNUM
index|]
condition|)
return|return
name|true
return|;
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|>=
name|FIRST_VIRTUAL_REGISTER
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<=
name|LAST_VIRTUAL_REGISTER
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
case|case
name|PLUS
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
name|false
return|;
return|return
name|fixed_base_plus_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|ADDRESSOF
case|:
return|return
name|true
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
end_function

begin_comment
comment|/* Dump the expressions in the equivalence class indicated by CLASSP.    This function is used only for debugging.  */
end_comment

begin_function
name|void
name|dump_class
parameter_list|(
name|struct
name|table_elt
modifier|*
name|classp
parameter_list|)
block|{
name|struct
name|table_elt
modifier|*
name|elt
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Equivalence chain for "
argument_list|)
expr_stmt|;
name|print_rtl
argument_list|(
name|stderr
argument_list|,
name|classp
operator|->
name|exp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|": \n"
argument_list|)
expr_stmt|;
for|for
control|(
name|elt
operator|=
name|classp
operator|->
name|first_same_value
init|;
name|elt
condition|;
name|elt
operator|=
name|elt
operator|->
name|next_same_value
control|)
block|{
name|print_rtl
argument_list|(
name|stderr
argument_list|,
name|elt
operator|->
name|exp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Subroutine of approx_reg_cost; called through for_each_rtx.  */
end_comment

begin_function
specifier|static
name|int
name|approx_reg_cost_1
parameter_list|(
name|rtx
modifier|*
name|xp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|rtx
name|x
init|=
operator|*
name|xp
decl_stmt|;
name|int
modifier|*
name|cost_p
init|=
name|data
decl_stmt|;
if|if
condition|(
name|x
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
block|{
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|CHEAP_REGNO
argument_list|(
name|regno
argument_list|)
condition|)
block|{
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
if|if
condition|(
name|SMALL_REGISTER_CLASSES
condition|)
return|return
literal|1
return|;
operator|*
name|cost_p
operator|+=
literal|2
expr_stmt|;
block|}
else|else
operator|*
name|cost_p
operator|+=
literal|1
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return an estimate of the cost of the registers used in an rtx.    This is mostly the number of different REG expressions in the rtx;    however for some exceptions like fixed registers we use a cost of    0.  If any other hard register reference occurs, return MAX_COST.  */
end_comment

begin_function
specifier|static
name|int
name|approx_reg_cost
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|int
name|cost
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|for_each_rtx
argument_list|(
operator|&
name|x
argument_list|,
name|approx_reg_cost_1
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|cost
argument_list|)
condition|)
return|return
name|MAX_COST
return|;
return|return
name|cost
return|;
block|}
end_function

begin_comment
comment|/* Return a negative value if an rtx A, whose costs are given by COST_A    and REGCOST_A, is more desirable than an rtx B.    Return a positive value if A is less desirable, or 0 if the two are    equally good.  */
end_comment

begin_function
specifier|static
name|int
name|preferrable
parameter_list|(
name|int
name|cost_a
parameter_list|,
name|int
name|regcost_a
parameter_list|,
name|int
name|cost_b
parameter_list|,
name|int
name|regcost_b
parameter_list|)
block|{
comment|/* First, get rid of cases involving expressions that are entirely      unwanted.  */
if|if
condition|(
name|cost_a
operator|!=
name|cost_b
condition|)
block|{
if|if
condition|(
name|cost_a
operator|==
name|MAX_COST
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|cost_b
operator|==
name|MAX_COST
condition|)
return|return
operator|-
literal|1
return|;
block|}
comment|/* Avoid extending lifetimes of hardregs.  */
if|if
condition|(
name|regcost_a
operator|!=
name|regcost_b
condition|)
block|{
if|if
condition|(
name|regcost_a
operator|==
name|MAX_COST
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|regcost_b
operator|==
name|MAX_COST
condition|)
return|return
operator|-
literal|1
return|;
block|}
comment|/* Normal operation costs take precedence.  */
if|if
condition|(
name|cost_a
operator|!=
name|cost_b
condition|)
return|return
name|cost_a
operator|-
name|cost_b
return|;
comment|/* Only if these are identical consider effects on register pressure.  */
if|if
condition|(
name|regcost_a
operator|!=
name|regcost_b
condition|)
return|return
name|regcost_a
operator|-
name|regcost_b
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Internal function, to compute cost when X is not a register; called    from COST macro to keep it simple.  */
end_comment

begin_function
specifier|static
name|int
name|notreg_cost
parameter_list|(
name|rtx
name|x
parameter_list|,
name|enum
name|rtx_code
name|outer
parameter_list|)
block|{
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
name|subreg_lowpart_p
argument_list|(
name|x
argument_list|)
operator|&&
name|TRULY_NOOP_TRUNCATION
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|?
literal|0
else|:
name|rtx_cost
argument_list|(
name|x
argument_list|,
name|outer
argument_list|)
operator|*
literal|2
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return an estimate of the cost of computing rtx X.    One use is in cse, to decide which expression to keep in the hash table.    Another is in rtl generation, to pick the cheapest way to multiply.    Other uses like the latter are expected in the future.  */
end_comment

begin_function
name|int
name|rtx_cost
parameter_list|(
name|rtx
name|x
parameter_list|,
name|enum
name|rtx_code
name|outer_code
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|total
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Compute the default costs of certain things.      Note that targetm.rtx_costs can override the defaults.  */
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|MULT
case|:
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|5
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIV
case|:
case|case
name|UDIV
case|:
case|case
name|MOD
case|:
case|case
name|UMOD
case|:
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|7
argument_list|)
expr_stmt|;
break|break;
case|case
name|USE
case|:
comment|/* Used in loop.c and combine.c as a marker.  */
name|total
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
return|return
literal|0
return|;
case|case
name|SUBREG
case|:
comment|/* If we can't tie these modes, make this expensive.  The larger 	 the mode, the more expensive it is.  */
if|if
condition|(
operator|!
name|MODES_TIEABLE_P
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|COSTS_N_INSNS
argument_list|(
literal|2
operator|+
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|/
name|UNITS_PER_WORD
argument_list|)
return|;
break|break;
default|default:
if|if
condition|(
call|(
modifier|*
name|targetm
operator|.
name|rtx_costs
call|)
argument_list|(
name|x
argument_list|,
name|code
argument_list|,
name|outer_code
argument_list|,
operator|&
name|total
argument_list|)
condition|)
return|return
name|total
return|;
break|break;
block|}
comment|/* Sum the costs of the sub-rtx's, plus cost of this operation,      which is already in total.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|total
operator|+=
name|rtx_cost
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|total
operator|+=
name|rtx_cost
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
return|return
name|total
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return cost of address expression X.    Expect that X is properly formed address reference.  */
end_comment

begin_function
name|int
name|address_cost
parameter_list|(
name|rtx
name|x
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
comment|/* The address_cost target hook does not deal with ADDRESSOF nodes.  But,      during CSE, such nodes are present.  Using an ADDRESSOF node which      refers to the address of a REG is a good thing because we can then      turn (MEM (ADDRESSSOF (REG))) into just plain REG.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ADDRESSOF
operator|&&
name|REG_P
argument_list|(
name|XEXP
argument_list|(
operator|(
name|x
operator|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* We may be asked for cost of various unusual addresses, such as operands      of push instruction.  It is not worthwhile to complicate writing      of the target hook by such cases.  */
if|if
condition|(
operator|!
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
condition|)
return|return
literal|1000
return|;
return|return
call|(
modifier|*
name|targetm
operator|.
name|address_cost
call|)
argument_list|(
name|x
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If the target doesn't override, compute the cost as with arithmetic.  */
end_comment

begin_function
name|int
name|default_address_cost
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
return|return
name|rtx_cost
argument_list|(
name|x
argument_list|,
name|MEM
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|struct
name|cse_reg_info
modifier|*
name|get_cse_reg_info
parameter_list|(
name|unsigned
name|int
name|regno
parameter_list|)
block|{
name|struct
name|cse_reg_info
modifier|*
modifier|*
name|hash_head
init|=
operator|&
name|reg_hash
index|[
name|REGHASH_FN
argument_list|(
name|regno
argument_list|)
index|]
decl_stmt|;
name|struct
name|cse_reg_info
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
operator|*
name|hash_head
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|hash_next
control|)
if|if
condition|(
name|p
operator|->
name|regno
operator|==
name|regno
condition|)
break|break;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
comment|/* Get a new cse_reg_info structure.  */
if|if
condition|(
name|cse_reg_info_free_list
condition|)
block|{
name|p
operator|=
name|cse_reg_info_free_list
expr_stmt|;
name|cse_reg_info_free_list
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
else|else
name|p
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cse_reg_info
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Insert into hash table.  */
name|p
operator|->
name|hash_next
operator|=
operator|*
name|hash_head
expr_stmt|;
operator|*
name|hash_head
operator|=
name|p
expr_stmt|;
comment|/* Initialize it.  */
name|p
operator|->
name|reg_tick
operator|=
literal|1
expr_stmt|;
name|p
operator|->
name|reg_in_table
operator|=
operator|-
literal|1
expr_stmt|;
name|p
operator|->
name|subreg_ticked
operator|=
operator|-
literal|1
expr_stmt|;
name|p
operator|->
name|reg_qty
operator|=
operator|-
name|regno
operator|-
literal|1
expr_stmt|;
name|p
operator|->
name|regno
operator|=
name|regno
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|cse_reg_info_used_list
expr_stmt|;
name|cse_reg_info_used_list
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|!
name|cse_reg_info_used_list_end
condition|)
name|cse_reg_info_used_list_end
operator|=
name|p
expr_stmt|;
block|}
comment|/* Cache this lookup; we tend to be looking up information about the      same register several times in a row.  */
name|cached_regno
operator|=
name|regno
expr_stmt|;
name|cached_cse_reg_info
operator|=
name|p
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Clear the hash table and initialize each register with its own quantity,    for a new basic block.  */
end_comment

begin_function
specifier|static
name|void
name|new_basic_block
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|next_qty
operator|=
literal|0
expr_stmt|;
comment|/* Clear out hash table state for this pass.  */
name|memset
argument_list|(
name|reg_hash
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|reg_hash
argument_list|)
expr_stmt|;
if|if
condition|(
name|cse_reg_info_used_list
condition|)
block|{
name|cse_reg_info_used_list_end
operator|->
name|next
operator|=
name|cse_reg_info_free_list
expr_stmt|;
name|cse_reg_info_free_list
operator|=
name|cse_reg_info_used_list
expr_stmt|;
name|cse_reg_info_used_list
operator|=
name|cse_reg_info_used_list_end
operator|=
literal|0
expr_stmt|;
block|}
name|cached_cse_reg_info
operator|=
literal|0
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|hard_regs_in_table
argument_list|)
expr_stmt|;
comment|/* The per-quantity values used to be initialized here, but it is      much faster to initialize each as it is made in `make_new_qty'.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HASH_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|table_elt
modifier|*
name|first
decl_stmt|;
name|first
operator|=
name|table
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|first
operator|!=
name|NULL
condition|)
block|{
name|struct
name|table_elt
modifier|*
name|last
init|=
name|first
decl_stmt|;
name|table
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|last
operator|->
name|next_same_hash
operator|!=
name|NULL
condition|)
name|last
operator|=
name|last
operator|->
name|next_same_hash
expr_stmt|;
comment|/* Now relink this hash entire chain into 	     the free element list.  */
name|last
operator|->
name|next_same_hash
operator|=
name|free_element_chain
expr_stmt|;
name|free_element_chain
operator|=
name|first
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|HAVE_cc0
name|prev_insn
operator|=
literal|0
expr_stmt|;
name|prev_insn_cc0
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Say that register REG contains a quantity in mode MODE not in any    register before and initialize that quantity.  */
end_comment

begin_function
specifier|static
name|void
name|make_new_qty
parameter_list|(
name|unsigned
name|int
name|reg
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|int
name|q
decl_stmt|;
name|struct
name|qty_table_elem
modifier|*
name|ent
decl_stmt|;
name|struct
name|reg_eqv_elem
modifier|*
name|eqv
decl_stmt|;
if|if
condition|(
name|next_qty
operator|>=
name|max_qty
condition|)
name|abort
argument_list|()
expr_stmt|;
name|q
operator|=
name|REG_QTY
argument_list|(
name|reg
argument_list|)
operator|=
name|next_qty
operator|++
expr_stmt|;
name|ent
operator|=
operator|&
name|qty_table
index|[
name|q
index|]
expr_stmt|;
name|ent
operator|->
name|first_reg
operator|=
name|reg
expr_stmt|;
name|ent
operator|->
name|last_reg
operator|=
name|reg
expr_stmt|;
name|ent
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
name|ent
operator|->
name|const_rtx
operator|=
name|ent
operator|->
name|const_insn
operator|=
name|NULL_RTX
expr_stmt|;
name|ent
operator|->
name|comparison_code
operator|=
name|UNKNOWN
expr_stmt|;
name|eqv
operator|=
operator|&
name|reg_eqv_table
index|[
name|reg
index|]
expr_stmt|;
name|eqv
operator|->
name|next
operator|=
name|eqv
operator|->
name|prev
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make reg NEW equivalent to reg OLD.    OLD is not changing; NEW is.  */
end_comment

begin_function
specifier|static
name|void
name|make_regs_eqv
parameter_list|(
name|unsigned
name|int
name|new
parameter_list|,
name|unsigned
name|int
name|old
parameter_list|)
block|{
name|unsigned
name|int
name|lastr
decl_stmt|,
name|firstr
decl_stmt|;
name|int
name|q
init|=
name|REG_QTY
argument_list|(
name|old
argument_list|)
decl_stmt|;
name|struct
name|qty_table_elem
modifier|*
name|ent
decl_stmt|;
name|ent
operator|=
operator|&
name|qty_table
index|[
name|q
index|]
expr_stmt|;
comment|/* Nothing should become eqv until it has a "non-invalid" qty number.  */
if|if
condition|(
operator|!
name|REGNO_QTY_VALID_P
argument_list|(
name|old
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|REG_QTY
argument_list|(
name|new
argument_list|)
operator|=
name|q
expr_stmt|;
name|firstr
operator|=
name|ent
operator|->
name|first_reg
expr_stmt|;
name|lastr
operator|=
name|ent
operator|->
name|last_reg
expr_stmt|;
comment|/* Prefer fixed hard registers to anything.  Prefer pseudo regs to other      hard regs.  Among pseudos, if NEW will live longer than any other reg      of the same qty, and that is beyond the current basic block,      make it the new canonical replacement for this qty.  */
if|if
condition|(
operator|!
operator|(
name|firstr
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|FIXED_REGNO_P
argument_list|(
name|firstr
argument_list|)
operator|)
comment|/* Certain fixed registers might be of the class NO_REGS.  This means 	 that not only can they not be allocated by the compiler, but 	 they cannot be used in substitutions or canonicalizations 	 either.  */
operator|&&
operator|(
name|new
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
name|REGNO_REG_CLASS
argument_list|(
name|new
argument_list|)
operator|!=
name|NO_REGS
operator|)
operator|&&
operator|(
operator|(
name|new
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|FIXED_REGNO_P
argument_list|(
name|new
argument_list|)
operator|)
operator|||
operator|(
name|new
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|(
name|firstr
operator|<
name|FIRST_PSEUDO_REGISTER
operator|||
operator|(
operator|(
name|uid_cuid
index|[
name|REGNO_LAST_UID
argument_list|(
name|new
argument_list|)
index|]
operator|>
name|cse_basic_block_end
operator|||
operator|(
name|uid_cuid
index|[
name|REGNO_FIRST_UID
argument_list|(
name|new
argument_list|)
index|]
operator|<
name|cse_basic_block_start
operator|)
operator|)
operator|&&
operator|(
name|uid_cuid
index|[
name|REGNO_LAST_UID
argument_list|(
name|new
argument_list|)
index|]
operator|>
name|uid_cuid
index|[
name|REGNO_LAST_UID
argument_list|(
name|firstr
argument_list|)
index|]
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
name|reg_eqv_table
index|[
name|firstr
index|]
operator|.
name|prev
operator|=
name|new
expr_stmt|;
name|reg_eqv_table
index|[
name|new
index|]
operator|.
name|next
operator|=
name|firstr
expr_stmt|;
name|reg_eqv_table
index|[
name|new
index|]
operator|.
name|prev
operator|=
operator|-
literal|1
expr_stmt|;
name|ent
operator|->
name|first_reg
operator|=
name|new
expr_stmt|;
block|}
else|else
block|{
comment|/* If NEW is a hard reg (known to be non-fixed), insert at end. 	 Otherwise, insert before any non-fixed hard regs that are at the 	 end.  Registers of class NO_REGS cannot be used as an 	 equivalent for anything.  */
while|while
condition|(
name|lastr
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_eqv_table
index|[
name|lastr
index|]
operator|.
name|prev
operator|>=
literal|0
operator|&&
operator|(
name|REGNO_REG_CLASS
argument_list|(
name|lastr
argument_list|)
operator|==
name|NO_REGS
operator|||
operator|!
name|FIXED_REGNO_P
argument_list|(
name|lastr
argument_list|)
operator|)
operator|&&
name|new
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|lastr
operator|=
name|reg_eqv_table
index|[
name|lastr
index|]
operator|.
name|prev
expr_stmt|;
name|reg_eqv_table
index|[
name|new
index|]
operator|.
name|next
operator|=
name|reg_eqv_table
index|[
name|lastr
index|]
operator|.
name|next
expr_stmt|;
if|if
condition|(
name|reg_eqv_table
index|[
name|lastr
index|]
operator|.
name|next
operator|>=
literal|0
condition|)
name|reg_eqv_table
index|[
name|reg_eqv_table
index|[
name|lastr
index|]
operator|.
name|next
index|]
operator|.
name|prev
operator|=
name|new
expr_stmt|;
else|else
name|qty_table
index|[
name|q
index|]
operator|.
name|last_reg
operator|=
name|new
expr_stmt|;
name|reg_eqv_table
index|[
name|lastr
index|]
operator|.
name|next
operator|=
name|new
expr_stmt|;
name|reg_eqv_table
index|[
name|new
index|]
operator|.
name|prev
operator|=
name|lastr
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Remove REG from its equivalence class.  */
end_comment

begin_function
specifier|static
name|void
name|delete_reg_equiv
parameter_list|(
name|unsigned
name|int
name|reg
parameter_list|)
block|{
name|struct
name|qty_table_elem
modifier|*
name|ent
decl_stmt|;
name|int
name|q
init|=
name|REG_QTY
argument_list|(
name|reg
argument_list|)
decl_stmt|;
name|int
name|p
decl_stmt|,
name|n
decl_stmt|;
comment|/* If invalid, do nothing.  */
if|if
condition|(
operator|!
name|REGNO_QTY_VALID_P
argument_list|(
name|reg
argument_list|)
condition|)
return|return;
name|ent
operator|=
operator|&
name|qty_table
index|[
name|q
index|]
expr_stmt|;
name|p
operator|=
name|reg_eqv_table
index|[
name|reg
index|]
operator|.
name|prev
expr_stmt|;
name|n
operator|=
name|reg_eqv_table
index|[
name|reg
index|]
operator|.
name|next
expr_stmt|;
if|if
condition|(
name|n
operator|!=
operator|-
literal|1
condition|)
name|reg_eqv_table
index|[
name|n
index|]
operator|.
name|prev
operator|=
name|p
expr_stmt|;
else|else
name|ent
operator|->
name|last_reg
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|p
operator|!=
operator|-
literal|1
condition|)
name|reg_eqv_table
index|[
name|p
index|]
operator|.
name|next
operator|=
name|n
expr_stmt|;
else|else
name|ent
operator|->
name|first_reg
operator|=
name|n
expr_stmt|;
name|REG_QTY
argument_list|(
name|reg
argument_list|)
operator|=
operator|-
name|reg
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove any invalid expressions from the hash table    that refer to any of the registers contained in expression X.     Make sure that newly inserted references to those registers    as subexpressions will be considered valid.     mention_regs is not called when a register itself    is being stored in the table.     Return 1 if we have done something that may have changed the hash code    of X.  */
end_comment

begin_function
specifier|static
name|int
name|mention_regs
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|changed
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|REG
condition|)
block|{
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|endregno
init|=
name|regno
operator|+
operator|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|?
literal|1
else|:
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|regno
init|;
name|i
operator|<
name|endregno
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|REG_IN_TABLE
argument_list|(
name|i
argument_list|)
operator|>=
literal|0
operator|&&
name|REG_IN_TABLE
argument_list|(
name|i
argument_list|)
operator|!=
name|REG_TICK
argument_list|(
name|i
argument_list|)
condition|)
name|remove_invalid_refs
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|REG_IN_TABLE
argument_list|(
name|i
argument_list|)
operator|=
name|REG_TICK
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|SUBREG_TICKED
argument_list|(
name|i
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
comment|/* If this is a SUBREG, we don't want to discard other SUBREGs of the same      pseudo if they don't use overlapping words.  We handle only pseudos      here for simplicity.  */
if|if
condition|(
name|code
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|unsigned
name|int
name|i
init|=
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|REG_IN_TABLE
argument_list|(
name|i
argument_list|)
operator|>=
literal|0
operator|&&
name|REG_IN_TABLE
argument_list|(
name|i
argument_list|)
operator|!=
name|REG_TICK
argument_list|(
name|i
argument_list|)
condition|)
block|{
comment|/* If REG_IN_TABLE (i) differs from REG_TICK (i) by one, and 	     the last store to this register really stored into this 	     subreg, then remove the memory of this subreg. 	     Otherwise, remove any memory of the entire register and 	     all its subregs from the table.  */
if|if
condition|(
name|REG_TICK
argument_list|(
name|i
argument_list|)
operator|-
name|REG_IN_TABLE
argument_list|(
name|i
argument_list|)
operator|>
literal|1
operator|||
name|SUBREG_TICKED
argument_list|(
name|i
argument_list|)
operator|!=
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|remove_invalid_refs
argument_list|(
name|i
argument_list|)
expr_stmt|;
else|else
name|remove_invalid_subreg_refs
argument_list|(
name|i
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|x
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|REG_IN_TABLE
argument_list|(
name|i
argument_list|)
operator|=
name|REG_TICK
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|SUBREG_TICKED
argument_list|(
name|i
argument_list|)
operator|=
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* If X is a comparison or a COMPARE and either operand is a register      that does not have a quantity, give it one.  This is so that a later      call to record_jump_equiv won't cause X to be assigned a different      hash code and not found in the table after that call.       It is not necessary to do this here, since rehash_using_reg can      fix up the table later, but doing this here eliminates the need to      call that expensive function in the most common case where the only      use of the register is in the comparison.  */
if|if
condition|(
name|code
operator|==
name|COMPARE
operator|||
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'<'
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|!
name|REGNO_QTY_VALID_P
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
if|if
condition|(
name|insert_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|rehash_using_reg
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|!
name|REGNO_QTY_VALID_P
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
condition|)
if|if
condition|(
name|insert_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|rehash_using_reg
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|changed
operator||=
name|mention_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|changed
operator||=
name|mention_regs
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|changed
return|;
block|}
end_function

begin_comment
comment|/* Update the register quantities for inserting X into the hash table    with a value equivalent to CLASSP.    (If the class does not contain a REG, it is irrelevant.)    If MODIFIED is nonzero, X is a destination; it is being modified.    Note that delete_reg_equiv should be called on a register    before insert_regs is done on that register with MODIFIED != 0.     Nonzero value means that elements of reg_qty have changed    so X's hash code may be different.  */
end_comment

begin_function
specifier|static
name|int
name|insert_regs
parameter_list|(
name|rtx
name|x
parameter_list|,
name|struct
name|table_elt
modifier|*
name|classp
parameter_list|,
name|int
name|modified
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
block|{
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|qty_valid
decl_stmt|;
comment|/* If REGNO is in the equivalence table already but is of the 	 wrong mode for that equivalence, don't do anything here.  */
name|qty_valid
operator|=
name|REGNO_QTY_VALID_P
argument_list|(
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|qty_valid
condition|)
block|{
name|struct
name|qty_table_elem
modifier|*
name|ent
init|=
operator|&
name|qty_table
index|[
name|REG_QTY
argument_list|(
name|regno
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|ent
operator|->
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|modified
operator|||
operator|!
name|qty_valid
condition|)
block|{
if|if
condition|(
name|classp
condition|)
for|for
control|(
name|classp
operator|=
name|classp
operator|->
name|first_same_value
init|;
name|classp
operator|!=
literal|0
condition|;
name|classp
operator|=
name|classp
operator|->
name|next_same_value
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|classp
operator|->
name|exp
argument_list|)
operator|==
name|REG
operator|&&
name|GET_MODE
argument_list|(
name|classp
operator|->
name|exp
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|make_regs_eqv
argument_list|(
name|regno
argument_list|,
name|REGNO
argument_list|(
name|classp
operator|->
name|exp
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Mention_regs for a SUBREG checks if REG_TICK is exactly one larger 	     than REG_IN_TABLE to find out if there was only a single preceding 	     invalidation - for the SUBREG - or another one, which would be 	     for the full register.  However, if we find here that REG_TICK 	     indicates that the register is invalid, it means that it has 	     been invalidated in a separate operation.  The SUBREG might be used 	     now (then this is a recursive call), or we might use the full REG 	     now and a SUBREG of it later.  So bump up REG_TICK so that 	     mention_regs will do the right thing.  */
if|if
condition|(
operator|!
name|modified
operator|&&
name|REG_IN_TABLE
argument_list|(
name|regno
argument_list|)
operator|>=
literal|0
operator|&&
name|REG_TICK
argument_list|(
name|regno
argument_list|)
operator|==
name|REG_IN_TABLE
argument_list|(
name|regno
argument_list|)
operator|+
literal|1
condition|)
name|REG_TICK
argument_list|(
name|regno
argument_list|)
operator|++
expr_stmt|;
name|make_new_qty
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
comment|/* If X is a SUBREG, we will likely be inserting the inner register in the      table.  If that register doesn't have an assigned quantity number at      this point but does later, the insertion that we will be doing now will      not be accessible because its hash code will have changed.  So assign      a quantity number now.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|!
name|REGNO_QTY_VALID_P
argument_list|(
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|insert_regs
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mention_regs
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
name|mention_regs
argument_list|(
name|x
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Look in or update the hash table.  */
end_comment

begin_comment
comment|/* Remove table element ELT from use in the table.    HASH is its hash code, made using the HASH macro.    It's an argument because often that is known in advance    and we save much time not recomputing it.  */
end_comment

begin_function
specifier|static
name|void
name|remove_from_table
parameter_list|(
name|struct
name|table_elt
modifier|*
name|elt
parameter_list|,
name|unsigned
name|int
name|hash
parameter_list|)
block|{
if|if
condition|(
name|elt
operator|==
literal|0
condition|)
return|return;
comment|/* Mark this element as removed.  See cse_insn.  */
name|elt
operator|->
name|first_same_value
operator|=
literal|0
expr_stmt|;
comment|/* Remove the table element from its equivalence class.  */
block|{
name|struct
name|table_elt
modifier|*
name|prev
init|=
name|elt
operator|->
name|prev_same_value
decl_stmt|;
name|struct
name|table_elt
modifier|*
name|next
init|=
name|elt
operator|->
name|next_same_value
decl_stmt|;
if|if
condition|(
name|next
condition|)
name|next
operator|->
name|prev_same_value
operator|=
name|prev
expr_stmt|;
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|next_same_value
operator|=
name|next
expr_stmt|;
else|else
block|{
name|struct
name|table_elt
modifier|*
name|newfirst
init|=
name|next
decl_stmt|;
while|while
condition|(
name|next
condition|)
block|{
name|next
operator|->
name|first_same_value
operator|=
name|newfirst
expr_stmt|;
name|next
operator|=
name|next
operator|->
name|next_same_value
expr_stmt|;
block|}
block|}
block|}
comment|/* Remove the table element from its hash bucket.  */
block|{
name|struct
name|table_elt
modifier|*
name|prev
init|=
name|elt
operator|->
name|prev_same_hash
decl_stmt|;
name|struct
name|table_elt
modifier|*
name|next
init|=
name|elt
operator|->
name|next_same_hash
decl_stmt|;
if|if
condition|(
name|next
condition|)
name|next
operator|->
name|prev_same_hash
operator|=
name|prev
expr_stmt|;
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|next_same_hash
operator|=
name|next
expr_stmt|;
elseif|else
if|if
condition|(
name|table
index|[
name|hash
index|]
operator|==
name|elt
condition|)
name|table
index|[
name|hash
index|]
operator|=
name|next
expr_stmt|;
else|else
block|{
comment|/* This entry is not in the proper hash bucket.  This can happen 	   when two classes were merged by `merge_equiv_classes'.  Search 	   for the hash bucket that it heads.  This happens only very 	   rarely, so the cost is acceptable.  */
for|for
control|(
name|hash
operator|=
literal|0
init|;
name|hash
operator|<
name|HASH_SIZE
condition|;
name|hash
operator|++
control|)
if|if
condition|(
name|table
index|[
name|hash
index|]
operator|==
name|elt
condition|)
name|table
index|[
name|hash
index|]
operator|=
name|next
expr_stmt|;
block|}
block|}
comment|/* Remove the table element from its related-value circular chain.  */
if|if
condition|(
name|elt
operator|->
name|related_value
operator|!=
literal|0
operator|&&
name|elt
operator|->
name|related_value
operator|!=
name|elt
condition|)
block|{
name|struct
name|table_elt
modifier|*
name|p
init|=
name|elt
operator|->
name|related_value
decl_stmt|;
while|while
condition|(
name|p
operator|->
name|related_value
operator|!=
name|elt
condition|)
name|p
operator|=
name|p
operator|->
name|related_value
expr_stmt|;
name|p
operator|->
name|related_value
operator|=
name|elt
operator|->
name|related_value
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|related_value
operator|==
name|p
condition|)
name|p
operator|->
name|related_value
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Now add it to the free element chain.  */
name|elt
operator|->
name|next_same_hash
operator|=
name|free_element_chain
expr_stmt|;
name|free_element_chain
operator|=
name|elt
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Look up X in the hash table and return its table element,    or 0 if X is not in the table.     MODE is the machine-mode of X, or if X is an integer constant    with VOIDmode then MODE is the mode with which X will be used.     Here we are satisfied to find an expression whose tree structure    looks like X.  */
end_comment

begin_function
specifier|static
name|struct
name|table_elt
modifier|*
name|lookup
parameter_list|(
name|rtx
name|x
parameter_list|,
name|unsigned
name|int
name|hash
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|struct
name|table_elt
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|table
index|[
name|hash
index|]
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next_same_hash
control|)
if|if
condition|(
name|mode
operator|==
name|p
operator|->
name|mode
operator|&&
operator|(
operator|(
name|x
operator|==
name|p
operator|->
name|exp
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|)
operator|||
name|exp_equiv_p
argument_list|(
name|x
argument_list|,
name|p
operator|->
name|exp
argument_list|,
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
return|return
name|p
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Like `lookup' but don't care whether the table element uses invalid regs.    Also ignore discrepancies in the machine mode of a register.  */
end_comment

begin_function
specifier|static
name|struct
name|table_elt
modifier|*
name|lookup_for_remove
parameter_list|(
name|rtx
name|x
parameter_list|,
name|unsigned
name|int
name|hash
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|struct
name|table_elt
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
block|{
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
comment|/* Don't check the machine mode when comparing registers; 	 invalidating (REG:SI 0) also invalidates (REG:DF 0).  */
for|for
control|(
name|p
operator|=
name|table
index|[
name|hash
index|]
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next_same_hash
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
operator|->
name|exp
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|p
operator|->
name|exp
argument_list|)
operator|==
name|regno
condition|)
return|return
name|p
return|;
block|}
else|else
block|{
for|for
control|(
name|p
operator|=
name|table
index|[
name|hash
index|]
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next_same_hash
control|)
if|if
condition|(
name|mode
operator|==
name|p
operator|->
name|mode
operator|&&
operator|(
name|x
operator|==
name|p
operator|->
name|exp
operator|||
name|exp_equiv_p
argument_list|(
name|x
argument_list|,
name|p
operator|->
name|exp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
return|return
name|p
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Look for an expression equivalent to X and with code CODE.    If one is found, return that expression.  */
end_comment

begin_function
specifier|static
name|rtx
name|lookup_as_function
parameter_list|(
name|rtx
name|x
parameter_list|,
name|enum
name|rtx_code
name|code
parameter_list|)
block|{
name|struct
name|table_elt
modifier|*
name|p
init|=
name|lookup
argument_list|(
name|x
argument_list|,
name|safe_hash
argument_list|(
name|x
argument_list|,
name|VOIDmode
argument_list|)
operator|&
name|HASH_MASK
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
comment|/* If we are looking for a CONST_INT, the mode doesn't really matter, as      long as we are narrowing.  So if we looked in vain for a mode narrower      than word_mode before, look for word_mode now.  */
if|if
condition|(
name|p
operator|==
literal|0
operator|&&
name|code
operator|==
name|CONST_INT
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|word_mode
argument_list|)
condition|)
block|{
name|x
operator|=
name|copy_rtx
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|x
argument_list|,
name|word_mode
argument_list|)
expr_stmt|;
name|p
operator|=
name|lookup
argument_list|(
name|x
argument_list|,
name|safe_hash
argument_list|(
name|x
argument_list|,
name|VOIDmode
argument_list|)
operator|&
name|HASH_MASK
argument_list|,
name|word_mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|==
literal|0
condition|)
return|return
literal|0
return|;
for|for
control|(
name|p
operator|=
name|p
operator|->
name|first_same_value
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next_same_value
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
operator|->
name|exp
argument_list|)
operator|==
name|code
comment|/* Make sure this is a valid entry in the table.  */
operator|&&
name|exp_equiv_p
argument_list|(
name|p
operator|->
name|exp
argument_list|,
name|p
operator|->
name|exp
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|p
operator|->
name|exp
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Insert X in the hash table, assuming HASH is its hash code    and CLASSP is an element of the class it should go in    (or 0 if a new class should be made).    It is inserted at the proper position to keep the class in    the order cheapest first.     MODE is the machine-mode of X, or if X is an integer constant    with VOIDmode then MODE is the mode with which X will be used.     For elements of equal cheapness, the most recent one    goes in front, except that the first element in the list    remains first unless a cheaper element is added.  The order of    pseudo-registers does not matter, as canon_reg will be called to    find the cheapest when a register is retrieved from the table.     The in_memory field in the hash table element is set to 0.    The caller must set it nonzero if appropriate.     You should call insert_regs (X, CLASSP, MODIFY) before calling here,    and if insert_regs returns a nonzero value    you must then recompute its hash code before calling here.     If necessary, update table showing constant values of quantities.  */
end_comment

begin_define
define|#
directive|define
name|CHEAPER
parameter_list|(
name|X
parameter_list|,
name|Y
parameter_list|)
define|\
value|(preferrable ((X)->cost, (X)->regcost, (Y)->cost, (Y)->regcost)< 0)
end_define

begin_function
specifier|static
name|struct
name|table_elt
modifier|*
name|insert
parameter_list|(
name|rtx
name|x
parameter_list|,
name|struct
name|table_elt
modifier|*
name|classp
parameter_list|,
name|unsigned
name|int
name|hash
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|struct
name|table_elt
modifier|*
name|elt
decl_stmt|;
comment|/* If X is a register and we haven't made a quantity for it,      something is wrong.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
operator|!
name|REGNO_QTY_VALID_P
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If X is a hard register, show it is being put in the table.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|endregno
init|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|regno
init|;
name|i
operator|<
name|endregno
condition|;
name|i
operator|++
control|)
name|SET_HARD_REG_BIT
argument_list|(
name|hard_regs_in_table
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* Put an element for X into the right hash bucket.  */
name|elt
operator|=
name|free_element_chain
expr_stmt|;
if|if
condition|(
name|elt
condition|)
name|free_element_chain
operator|=
name|elt
operator|->
name|next_same_hash
expr_stmt|;
else|else
block|{
name|n_elements_made
operator|++
expr_stmt|;
name|elt
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|table_elt
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|elt
operator|->
name|exp
operator|=
name|x
expr_stmt|;
name|elt
operator|->
name|canon_exp
operator|=
name|NULL_RTX
expr_stmt|;
name|elt
operator|->
name|cost
operator|=
name|COST
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|elt
operator|->
name|regcost
operator|=
name|approx_reg_cost
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|elt
operator|->
name|next_same_value
operator|=
literal|0
expr_stmt|;
name|elt
operator|->
name|prev_same_value
operator|=
literal|0
expr_stmt|;
name|elt
operator|->
name|next_same_hash
operator|=
name|table
index|[
name|hash
index|]
expr_stmt|;
name|elt
operator|->
name|prev_same_hash
operator|=
literal|0
expr_stmt|;
name|elt
operator|->
name|related_value
operator|=
literal|0
expr_stmt|;
name|elt
operator|->
name|in_memory
operator|=
literal|0
expr_stmt|;
name|elt
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
name|elt
operator|->
name|is_const
operator|=
operator|(
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
comment|/* GNU C++ takes advantage of this for `this' 		      (and other const values).  */
operator|||
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
name|RTX_UNCHANGING_P
argument_list|(
name|x
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|||
name|fixed_base_plus_p
argument_list|(
name|x
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|table
index|[
name|hash
index|]
condition|)
name|table
index|[
name|hash
index|]
operator|->
name|prev_same_hash
operator|=
name|elt
expr_stmt|;
name|table
index|[
name|hash
index|]
operator|=
name|elt
expr_stmt|;
comment|/* Put it into the proper value-class.  */
if|if
condition|(
name|classp
condition|)
block|{
name|classp
operator|=
name|classp
operator|->
name|first_same_value
expr_stmt|;
if|if
condition|(
name|CHEAPER
argument_list|(
name|elt
argument_list|,
name|classp
argument_list|)
condition|)
comment|/* Insert at the head of the class.  */
block|{
name|struct
name|table_elt
modifier|*
name|p
decl_stmt|;
name|elt
operator|->
name|next_same_value
operator|=
name|classp
expr_stmt|;
name|classp
operator|->
name|prev_same_value
operator|=
name|elt
expr_stmt|;
name|elt
operator|->
name|first_same_value
operator|=
name|elt
expr_stmt|;
for|for
control|(
name|p
operator|=
name|classp
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next_same_value
control|)
name|p
operator|->
name|first_same_value
operator|=
name|elt
expr_stmt|;
block|}
else|else
block|{
comment|/* Insert not at head of the class.  */
comment|/* Put it after the last element cheaper than X.  */
name|struct
name|table_elt
modifier|*
name|p
decl_stmt|,
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|p
operator|=
name|classp
init|;
operator|(
name|next
operator|=
name|p
operator|->
name|next_same_value
operator|)
operator|&&
name|CHEAPER
argument_list|(
name|next
argument_list|,
name|elt
argument_list|)
condition|;
name|p
operator|=
name|next
control|)
empty_stmt|;
comment|/* Put it after P and before NEXT.  */
name|elt
operator|->
name|next_same_value
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|next
condition|)
name|next
operator|->
name|prev_same_value
operator|=
name|elt
expr_stmt|;
name|elt
operator|->
name|prev_same_value
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|next_same_value
operator|=
name|elt
expr_stmt|;
name|elt
operator|->
name|first_same_value
operator|=
name|classp
expr_stmt|;
block|}
block|}
else|else
name|elt
operator|->
name|first_same_value
operator|=
name|elt
expr_stmt|;
comment|/* If this is a constant being set equivalent to a register or a register      being set equivalent to a constant, note the constant equivalence.       If this is a constant, it cannot be equivalent to a different constant,      and a constant is the only thing that can be cheaper than a register.  So      we know the register is the head of the class (before the constant was      inserted).       If this is a register that is not already known equivalent to a      constant, we must check the entire class.       If this is a register that is already known equivalent to an insn,      update the qtys `const_insn' to show that `this_insn' is the latest      insn making that quantity equivalent to the constant.  */
if|if
condition|(
name|elt
operator|->
name|is_const
operator|&&
name|classp
operator|&&
name|GET_CODE
argument_list|(
name|classp
operator|->
name|exp
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
condition|)
block|{
name|int
name|exp_q
init|=
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|classp
operator|->
name|exp
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|qty_table_elem
modifier|*
name|exp_ent
init|=
operator|&
name|qty_table
index|[
name|exp_q
index|]
decl_stmt|;
name|exp_ent
operator|->
name|const_rtx
operator|=
name|gen_lowpart_if_possible
argument_list|(
name|exp_ent
operator|->
name|mode
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|exp_ent
operator|->
name|const_insn
operator|=
name|this_insn
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
name|classp
operator|&&
operator|!
name|qty_table
index|[
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
index|]
operator|.
name|const_rtx
operator|&&
operator|!
name|elt
operator|->
name|is_const
condition|)
block|{
name|struct
name|table_elt
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|classp
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|p
operator|->
name|next_same_value
control|)
block|{
if|if
condition|(
name|p
operator|->
name|is_const
operator|&&
name|GET_CODE
argument_list|(
name|p
operator|->
name|exp
argument_list|)
operator|!=
name|REG
condition|)
block|{
name|int
name|x_q
init|=
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|qty_table_elem
modifier|*
name|x_ent
init|=
operator|&
name|qty_table
index|[
name|x_q
index|]
decl_stmt|;
name|x_ent
operator|->
name|const_rtx
operator|=
name|gen_lowpart_if_possible
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|p
operator|->
name|exp
argument_list|)
expr_stmt|;
name|x_ent
operator|->
name|const_insn
operator|=
name|this_insn
expr_stmt|;
break|break;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
name|qty_table
index|[
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
index|]
operator|.
name|const_rtx
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|qty_table
index|[
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
index|]
operator|.
name|mode
condition|)
name|qty_table
index|[
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
index|]
operator|.
name|const_insn
operator|=
name|this_insn
expr_stmt|;
comment|/* If this is a constant with symbolic value,      and it has a term with an explicit integer value,      link it up with related expressions.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
condition|)
block|{
name|rtx
name|subexp
init|=
name|get_related_value
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|unsigned
name|subhash
decl_stmt|;
name|struct
name|table_elt
modifier|*
name|subelt
decl_stmt|,
modifier|*
name|subelt_prev
decl_stmt|;
if|if
condition|(
name|subexp
operator|!=
literal|0
condition|)
block|{
comment|/* Get the integer-free subexpression in the hash table.  */
name|subhash
operator|=
name|safe_hash
argument_list|(
name|subexp
argument_list|,
name|mode
argument_list|)
operator|&
name|HASH_MASK
expr_stmt|;
name|subelt
operator|=
name|lookup
argument_list|(
name|subexp
argument_list|,
name|subhash
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|subelt
operator|==
literal|0
condition|)
name|subelt
operator|=
name|insert
argument_list|(
name|subexp
argument_list|,
name|NULL
argument_list|,
name|subhash
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* Initialize SUBELT's circular chain if it has none.  */
if|if
condition|(
name|subelt
operator|->
name|related_value
operator|==
literal|0
condition|)
name|subelt
operator|->
name|related_value
operator|=
name|subelt
expr_stmt|;
comment|/* Find the element in the circular chain that precedes SUBELT.  */
name|subelt_prev
operator|=
name|subelt
expr_stmt|;
while|while
condition|(
name|subelt_prev
operator|->
name|related_value
operator|!=
name|subelt
condition|)
name|subelt_prev
operator|=
name|subelt_prev
operator|->
name|related_value
expr_stmt|;
comment|/* Put new ELT into SUBELT's circular chain just before SUBELT. 	     This way the element that follows SUBELT is the oldest one.  */
name|elt
operator|->
name|related_value
operator|=
name|subelt_prev
operator|->
name|related_value
expr_stmt|;
name|subelt_prev
operator|->
name|related_value
operator|=
name|elt
expr_stmt|;
block|}
block|}
return|return
name|elt
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given two equivalence classes, CLASS1 and CLASS2, put all the entries from    CLASS2 into CLASS1.  This is done when we have reached an insn which makes    the two classes equivalent.     CLASS1 will be the surviving class; CLASS2 should not be used after this    call.     Any invalid entries in CLASS2 will not be copied.  */
end_comment

begin_function
specifier|static
name|void
name|merge_equiv_classes
parameter_list|(
name|struct
name|table_elt
modifier|*
name|class1
parameter_list|,
name|struct
name|table_elt
modifier|*
name|class2
parameter_list|)
block|{
name|struct
name|table_elt
modifier|*
name|elt
decl_stmt|,
modifier|*
name|next
decl_stmt|,
modifier|*
name|new
decl_stmt|;
comment|/* Ensure we start with the head of the classes.  */
name|class1
operator|=
name|class1
operator|->
name|first_same_value
expr_stmt|;
name|class2
operator|=
name|class2
operator|->
name|first_same_value
expr_stmt|;
comment|/* If they were already equal, forget it.  */
if|if
condition|(
name|class1
operator|==
name|class2
condition|)
return|return;
for|for
control|(
name|elt
operator|=
name|class2
init|;
name|elt
condition|;
name|elt
operator|=
name|next
control|)
block|{
name|unsigned
name|int
name|hash
decl_stmt|;
name|rtx
name|exp
init|=
name|elt
operator|->
name|exp
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|elt
operator|->
name|mode
decl_stmt|;
name|next
operator|=
name|elt
operator|->
name|next_same_value
expr_stmt|;
comment|/* Remove old entry, make a new one in CLASS1's class. 	 Don't do this for invalid entries as we cannot find their 	 hash code (it also isn't necessary).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|REG
operator|||
name|exp_equiv_p
argument_list|(
name|exp
argument_list|,
name|exp
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|bool
name|need_rehash
init|=
name|false
decl_stmt|;
name|hash_arg_in_memory
operator|=
literal|0
expr_stmt|;
name|hash
operator|=
name|HASH
argument_list|(
name|exp
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|REG
condition|)
block|{
name|need_rehash
operator|=
name|REGNO_QTY_VALID_P
argument_list|(
name|REGNO
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
name|delete_reg_equiv
argument_list|(
name|REGNO
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|remove_from_table
argument_list|(
name|elt
argument_list|,
name|hash
argument_list|)
expr_stmt|;
if|if
condition|(
name|insert_regs
argument_list|(
name|exp
argument_list|,
name|class1
argument_list|,
literal|0
argument_list|)
operator|||
name|need_rehash
condition|)
block|{
name|rehash_using_reg
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|hash
operator|=
name|HASH
argument_list|(
name|exp
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
name|new
operator|=
name|insert
argument_list|(
name|exp
argument_list|,
name|class1
argument_list|,
name|hash
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|new
operator|->
name|in_memory
operator|=
name|hash_arg_in_memory
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Flush the entire hash table.  */
end_comment

begin_function
specifier|static
name|void
name|flush_hash_table
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|table_elt
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HASH_SIZE
condition|;
name|i
operator|++
control|)
for|for
control|(
name|p
operator|=
name|table
index|[
name|i
index|]
init|;
name|p
condition|;
name|p
operator|=
name|table
index|[
name|i
index|]
control|)
block|{
comment|/* Note that invalidate can remove elements 	   after P in the current hash chain.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
operator|->
name|exp
argument_list|)
operator|==
name|REG
condition|)
name|invalidate
argument_list|(
name|p
operator|->
name|exp
argument_list|,
name|p
operator|->
name|mode
argument_list|)
expr_stmt|;
else|else
name|remove_from_table
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Function called for each rtx to check whether true dependence exist.  */
end_comment

begin_struct
struct|struct
name|check_dependence_data
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|exp
decl_stmt|;
name|rtx
name|addr
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|check_dependence
parameter_list|(
name|rtx
modifier|*
name|x
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|check_dependence_data
modifier|*
name|d
init|=
operator|(
expr|struct
name|check_dependence_data
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
operator|*
name|x
operator|&&
name|GET_CODE
argument_list|(
operator|*
name|x
argument_list|)
operator|==
name|MEM
condition|)
return|return
name|canon_true_dependence
argument_list|(
name|d
operator|->
name|exp
argument_list|,
name|d
operator|->
name|mode
argument_list|,
name|d
operator|->
name|addr
argument_list|,
operator|*
name|x
argument_list|,
name|cse_rtx_varies_p
argument_list|)
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Remove from the hash table, or mark as invalid, all expressions whose    values could be altered by storing in X.  X is a register, a subreg, or    a memory reference with nonvarying address (because, when a memory    reference with a varying address is stored in, all memory references are    removed by invalidate_memory so specific invalidation is superfluous).    FULL_MODE, if not VOIDmode, indicates that this much should be    invalidated instead of just the amount indicated by the mode of X.  This    is only used for bitfield stores into memory.     A nonvarying address may be just a register or just a symbol reference,    or it may be either of those plus a numeric offset.  */
end_comment

begin_function
specifier|static
name|void
name|invalidate
parameter_list|(
name|rtx
name|x
parameter_list|,
name|enum
name|machine_mode
name|full_mode
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|table_elt
modifier|*
name|p
decl_stmt|;
name|rtx
name|addr
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
block|{
comment|/* If X is a register, dependencies on its contents are recorded 	   through the qty number mechanism.  Just change the qty number of 	   the register, mark it as invalid for expressions that refer to it, 	   and remove it itself.  */
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|hash
init|=
name|HASH
argument_list|(
name|x
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Remove REGNO from any quantity list it might be on and indicate 	   that its value might have changed.  If it is a pseudo, remove its 	   entry from the hash table.  	   For a hard register, we do the first two actions above for any 	   additional hard registers corresponding to X.  Then, if any of these 	   registers are in the table, we must remove any REG entries that 	   overlap these registers.  */
name|delete_reg_equiv
argument_list|(
name|regno
argument_list|)
expr_stmt|;
name|REG_TICK
argument_list|(
name|regno
argument_list|)
operator|++
expr_stmt|;
name|SUBREG_TICKED
argument_list|(
name|regno
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
comment|/* Because a register can be referenced in more than one mode, 	       we might have to remove more than one table entry.  */
name|struct
name|table_elt
modifier|*
name|elt
decl_stmt|;
while|while
condition|(
operator|(
name|elt
operator|=
name|lookup_for_remove
argument_list|(
name|x
argument_list|,
name|hash
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
condition|)
name|remove_from_table
argument_list|(
name|elt
argument_list|,
name|hash
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|HOST_WIDE_INT
name|in_table
init|=
name|TEST_HARD_REG_BIT
argument_list|(
name|hard_regs_in_table
argument_list|,
name|regno
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|endregno
init|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|tregno
decl_stmt|,
name|tendregno
decl_stmt|,
name|rn
decl_stmt|;
name|struct
name|table_elt
modifier|*
name|p
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|CLEAR_HARD_REG_BIT
argument_list|(
name|hard_regs_in_table
argument_list|,
name|regno
argument_list|)
expr_stmt|;
for|for
control|(
name|rn
operator|=
name|regno
operator|+
literal|1
init|;
name|rn
operator|<
name|endregno
condition|;
name|rn
operator|++
control|)
block|{
name|in_table
operator||=
name|TEST_HARD_REG_BIT
argument_list|(
name|hard_regs_in_table
argument_list|,
name|rn
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_BIT
argument_list|(
name|hard_regs_in_table
argument_list|,
name|rn
argument_list|)
expr_stmt|;
name|delete_reg_equiv
argument_list|(
name|rn
argument_list|)
expr_stmt|;
name|REG_TICK
argument_list|(
name|rn
argument_list|)
operator|++
expr_stmt|;
name|SUBREG_TICKED
argument_list|(
name|rn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|in_table
condition|)
for|for
control|(
name|hash
operator|=
literal|0
init|;
name|hash
operator|<
name|HASH_SIZE
condition|;
name|hash
operator|++
control|)
for|for
control|(
name|p
operator|=
name|table
index|[
name|hash
index|]
init|;
name|p
condition|;
name|p
operator|=
name|next
control|)
block|{
name|next
operator|=
name|p
operator|->
name|next_same_hash
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
operator|->
name|exp
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|p
operator|->
name|exp
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
continue|continue;
name|tregno
operator|=
name|REGNO
argument_list|(
name|p
operator|->
name|exp
argument_list|)
expr_stmt|;
name|tendregno
operator|=
name|tregno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|tregno
argument_list|,
name|GET_MODE
argument_list|(
name|p
operator|->
name|exp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tendregno
operator|>
name|regno
operator|&&
name|tregno
operator|<
name|endregno
condition|)
name|remove_from_table
argument_list|(
name|p
argument_list|,
name|hash
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return;
case|case
name|SUBREG
case|:
name|invalidate
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
return|return;
case|case
name|PARALLEL
case|:
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
name|invalidate
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
return|return;
case|case
name|EXPR_LIST
case|:
comment|/* This is part of a disjoint return value; extract the location in 	 question ignoring the offset.  */
name|invalidate
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
return|return;
case|case
name|MEM
case|:
name|addr
operator|=
name|canon_rtx
argument_list|(
name|get_addr
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Calculate the canonical version of X here so that 	 true_dependence doesn't generate new RTL for X on each call.  */
name|x
operator|=
name|canon_rtx
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* Remove all hash table elements that refer to overlapping pieces of 	 memory.  */
if|if
condition|(
name|full_mode
operator|==
name|VOIDmode
condition|)
name|full_mode
operator|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HASH_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|table_elt
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|p
operator|=
name|table
index|[
name|i
index|]
init|;
name|p
condition|;
name|p
operator|=
name|next
control|)
block|{
name|next
operator|=
name|p
operator|->
name|next_same_hash
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|in_memory
condition|)
block|{
name|struct
name|check_dependence_data
name|d
decl_stmt|;
comment|/* Just canonicalize the expression once; 		     otherwise each time we call invalidate 		     true_dependence will canonicalize the 		     expression again.  */
if|if
condition|(
operator|!
name|p
operator|->
name|canon_exp
condition|)
name|p
operator|->
name|canon_exp
operator|=
name|canon_rtx
argument_list|(
name|p
operator|->
name|exp
argument_list|)
expr_stmt|;
name|d
operator|.
name|exp
operator|=
name|x
expr_stmt|;
name|d
operator|.
name|addr
operator|=
name|addr
expr_stmt|;
name|d
operator|.
name|mode
operator|=
name|full_mode
expr_stmt|;
if|if
condition|(
name|for_each_rtx
argument_list|(
operator|&
name|p
operator|->
name|canon_exp
argument_list|,
name|check_dependence
argument_list|,
operator|&
name|d
argument_list|)
condition|)
name|remove_from_table
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Remove all expressions that refer to register REGNO,    since they are already invalid, and we are about to    mark that register valid again and don't want the old    expressions to reappear as valid.  */
end_comment

begin_function
specifier|static
name|void
name|remove_invalid_refs
parameter_list|(
name|unsigned
name|int
name|regno
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|table_elt
modifier|*
name|p
decl_stmt|,
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HASH_SIZE
condition|;
name|i
operator|++
control|)
for|for
control|(
name|p
operator|=
name|table
index|[
name|i
index|]
init|;
name|p
condition|;
name|p
operator|=
name|next
control|)
block|{
name|next
operator|=
name|p
operator|->
name|next_same_hash
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
operator|->
name|exp
argument_list|)
operator|!=
name|REG
operator|&&
name|refers_to_regno_p
argument_list|(
name|regno
argument_list|,
name|regno
operator|+
literal|1
argument_list|,
name|p
operator|->
name|exp
argument_list|,
operator|(
name|rtx
operator|*
operator|)
literal|0
argument_list|)
condition|)
name|remove_from_table
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Likewise for a subreg with subreg_reg REGNO, subreg_byte OFFSET,    and mode MODE.  */
end_comment

begin_function
specifier|static
name|void
name|remove_invalid_subreg_refs
parameter_list|(
name|unsigned
name|int
name|regno
parameter_list|,
name|unsigned
name|int
name|offset
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|table_elt
modifier|*
name|p
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|unsigned
name|int
name|end
init|=
name|offset
operator|+
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
operator|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HASH_SIZE
condition|;
name|i
operator|++
control|)
for|for
control|(
name|p
operator|=
name|table
index|[
name|i
index|]
init|;
name|p
condition|;
name|p
operator|=
name|next
control|)
block|{
name|rtx
name|exp
init|=
name|p
operator|->
name|exp
decl_stmt|;
name|next
operator|=
name|p
operator|->
name|next_same_hash
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|REG
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|!=
name|regno
operator|||
operator|(
operator|(
operator|(
name|SUBREG_BYTE
argument_list|(
name|exp
argument_list|)
operator|+
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|>=
name|offset
operator|)
operator|&&
name|SUBREG_BYTE
argument_list|(
name|exp
argument_list|)
operator|<=
name|end
operator|)
operator|)
operator|&&
name|refers_to_regno_p
argument_list|(
name|regno
argument_list|,
name|regno
operator|+
literal|1
argument_list|,
name|p
operator|->
name|exp
argument_list|,
operator|(
name|rtx
operator|*
operator|)
literal|0
argument_list|)
condition|)
name|remove_from_table
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Recompute the hash codes of any valid entries in the hash table that    reference X, if X is a register, or SUBREG_REG (X) if X is a SUBREG.     This is called when we make a jump equivalence.  */
end_comment

begin_function
specifier|static
name|void
name|rehash_using_reg
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|table_elt
modifier|*
name|p
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|unsigned
name|hash
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
condition|)
name|x
operator|=
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* If X is not a register or if the register is known not to be in any      valid entries in the table, we have no work to do.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
operator|||
name|REG_IN_TABLE
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<
literal|0
operator|||
name|REG_IN_TABLE
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|REG_TICK
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
return|return;
comment|/* Scan all hash chains looking for valid entries that mention X.      If we find one and it is in the wrong hash chain, move it.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HASH_SIZE
condition|;
name|i
operator|++
control|)
for|for
control|(
name|p
operator|=
name|table
index|[
name|i
index|]
init|;
name|p
condition|;
name|p
operator|=
name|next
control|)
block|{
name|next
operator|=
name|p
operator|->
name|next_same_hash
expr_stmt|;
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|x
argument_list|,
name|p
operator|->
name|exp
argument_list|)
operator|&&
name|exp_equiv_p
argument_list|(
name|p
operator|->
name|exp
argument_list|,
name|p
operator|->
name|exp
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
operator|&&
name|i
operator|!=
operator|(
name|hash
operator|=
name|safe_hash
argument_list|(
name|p
operator|->
name|exp
argument_list|,
name|p
operator|->
name|mode
argument_list|)
operator|&
name|HASH_MASK
operator|)
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|next_same_hash
condition|)
name|p
operator|->
name|next_same_hash
operator|->
name|prev_same_hash
operator|=
name|p
operator|->
name|prev_same_hash
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|prev_same_hash
condition|)
name|p
operator|->
name|prev_same_hash
operator|->
name|next_same_hash
operator|=
name|p
operator|->
name|next_same_hash
expr_stmt|;
else|else
name|table
index|[
name|i
index|]
operator|=
name|p
operator|->
name|next_same_hash
expr_stmt|;
name|p
operator|->
name|next_same_hash
operator|=
name|table
index|[
name|hash
index|]
expr_stmt|;
name|p
operator|->
name|prev_same_hash
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|table
index|[
name|hash
index|]
condition|)
name|table
index|[
name|hash
index|]
operator|->
name|prev_same_hash
operator|=
name|p
expr_stmt|;
name|table
index|[
name|hash
index|]
operator|=
name|p
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Remove from the hash table any expression that is a call-clobbered    register.  Also update their TICK values.  */
end_comment

begin_function
specifier|static
name|void
name|invalidate_for_call
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|regno
decl_stmt|,
name|endregno
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|hash
decl_stmt|;
name|struct
name|table_elt
modifier|*
name|p
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|int
name|in_table
init|=
literal|0
decl_stmt|;
comment|/* Go through all the hard registers.  For each that is clobbered in      a CALL_INSN, remove the register from quantity chains and update      reg_tick if defined.  Also see if any of these registers is currently      in the table.  */
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|regs_invalidated_by_call
argument_list|,
name|regno
argument_list|)
condition|)
block|{
name|delete_reg_equiv
argument_list|(
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_TICK
argument_list|(
name|regno
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|REG_TICK
argument_list|(
name|regno
argument_list|)
operator|++
expr_stmt|;
name|SUBREG_TICKED
argument_list|(
name|regno
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|in_table
operator||=
operator|(
name|TEST_HARD_REG_BIT
argument_list|(
name|hard_regs_in_table
argument_list|,
name|regno
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
comment|/* In the case where we have no call-clobbered hard registers in the      table, we are done.  Otherwise, scan the table and remove any      entry that overlaps a call-clobbered register.  */
if|if
condition|(
name|in_table
condition|)
for|for
control|(
name|hash
operator|=
literal|0
init|;
name|hash
operator|<
name|HASH_SIZE
condition|;
name|hash
operator|++
control|)
for|for
control|(
name|p
operator|=
name|table
index|[
name|hash
index|]
init|;
name|p
condition|;
name|p
operator|=
name|next
control|)
block|{
name|next
operator|=
name|p
operator|->
name|next_same_hash
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
operator|->
name|exp
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|p
operator|->
name|exp
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
continue|continue;
name|regno
operator|=
name|REGNO
argument_list|(
name|p
operator|->
name|exp
argument_list|)
expr_stmt|;
name|endregno
operator|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|p
operator|->
name|exp
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|regno
init|;
name|i
operator|<
name|endregno
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|regs_invalidated_by_call
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|remove_from_table
argument_list|(
name|p
argument_list|,
name|hash
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given an expression X of type CONST,    and ELT which is its table entry (or 0 if it    is not in the hash table),    return an alternate expression for X as a register plus integer.    If none can be found, return 0.  */
end_comment

begin_function
specifier|static
name|rtx
name|use_related_value
parameter_list|(
name|rtx
name|x
parameter_list|,
name|struct
name|table_elt
modifier|*
name|elt
parameter_list|)
block|{
name|struct
name|table_elt
modifier|*
name|relt
init|=
literal|0
decl_stmt|;
name|struct
name|table_elt
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|HOST_WIDE_INT
name|offset
decl_stmt|;
comment|/* First, is there anything related known?      If we have a table element, we can tell from that.      Otherwise, must look it up.  */
if|if
condition|(
name|elt
operator|!=
literal|0
operator|&&
name|elt
operator|->
name|related_value
operator|!=
literal|0
condition|)
name|relt
operator|=
name|elt
expr_stmt|;
elseif|else
if|if
condition|(
name|elt
operator|==
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
condition|)
block|{
name|rtx
name|subexp
init|=
name|get_related_value
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|subexp
operator|!=
literal|0
condition|)
name|relt
operator|=
name|lookup
argument_list|(
name|subexp
argument_list|,
name|safe_hash
argument_list|(
name|subexp
argument_list|,
name|GET_MODE
argument_list|(
name|subexp
argument_list|)
argument_list|)
operator|&
name|HASH_MASK
argument_list|,
name|GET_MODE
argument_list|(
name|subexp
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|relt
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Search all related table entries for one that has an      equivalent register.  */
name|p
operator|=
name|relt
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* This loop is strange in that it is executed in two different cases. 	 The first is when X is already in the table.  Then it is searching 	 the RELATED_VALUE list of X's class (RELT).  The second case is when 	 X is not in the table.  Then RELT points to a class for the related 	 value.  	 Ensure that, whatever case we are in, that we ignore classes that have 	 the same value as X.  */
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|x
argument_list|,
name|p
operator|->
name|exp
argument_list|)
condition|)
name|q
operator|=
literal|0
expr_stmt|;
else|else
for|for
control|(
name|q
operator|=
name|p
operator|->
name|first_same_value
init|;
name|q
condition|;
name|q
operator|=
name|q
operator|->
name|next_same_value
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|q
operator|->
name|exp
argument_list|)
operator|==
name|REG
condition|)
break|break;
if|if
condition|(
name|q
condition|)
break|break;
name|p
operator|=
name|p
operator|->
name|related_value
expr_stmt|;
comment|/* We went all the way around, so there is nothing to be found. 	 Alternatively, perhaps RELT was in the table for some other reason 	 and it has no related values recorded.  */
if|if
condition|(
name|p
operator|==
name|relt
operator|||
name|p
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|q
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|offset
operator|=
operator|(
name|get_integer_term
argument_list|(
name|x
argument_list|)
operator|-
name|get_integer_term
argument_list|(
name|p
operator|->
name|exp
argument_list|)
operator|)
expr_stmt|;
comment|/* Note: OFFSET may be 0 if P->xexp and X are related by commutativity.  */
return|return
name|plus_constant
argument_list|(
name|q
operator|->
name|exp
argument_list|,
name|offset
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Hash a string.  Just add its bytes up.  */
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|canon_hash_string
parameter_list|(
specifier|const
name|char
modifier|*
name|ps
parameter_list|)
block|{
name|unsigned
name|hash
init|=
literal|0
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|p
init|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|ps
decl_stmt|;
if|if
condition|(
name|p
condition|)
while|while
condition|(
operator|*
name|p
condition|)
name|hash
operator|+=
operator|*
name|p
operator|++
expr_stmt|;
return|return
name|hash
return|;
block|}
end_function

begin_comment
comment|/* Hash an rtx.  We are careful to make sure the value is never negative.    Equivalent registers hash identically.    MODE is used in hashing for CONST_INTs only;    otherwise the mode of X is used.     Store 1 in do_not_record if any subexpression is volatile.     Store 1 in hash_arg_in_memory if X contains a MEM rtx    which does not have the RTX_UNCHANGING_P bit set.     Note that cse_insn knows that the hash code of a MEM expression    is just (int) MEM plus the hash code of the address.  */
end_comment

begin_function
specifier|static
name|unsigned
name|canon_hash
parameter_list|(
name|rtx
name|x
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|unsigned
name|hash
init|=
literal|0
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
comment|/* repeat is used to turn tail-recursion into iteration.  */
name|repeat
label|:
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
name|hash
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
block|{
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|bool
name|record
decl_stmt|;
comment|/* On some machines, we can't record any non-fixed hard register, 	   because extending its life will cause reload problems.  We 	   consider ap, fp, sp, gp to be fixed for this purpose.  	   We also consider CCmode registers to be fixed for this purpose; 	   failure to do so leads to failure to simplify 0<100 type of 	   conditionals.  	   On all machines, we can't record any global registers. 	   Nor should we record any register that is in a small 	   class, as defined by CLASS_LIKELY_SPILLED_P.  */
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|record
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|==
name|frame_pointer_rtx
operator|||
name|x
operator|==
name|hard_frame_pointer_rtx
operator|||
name|x
operator|==
name|arg_pointer_rtx
operator|||
name|x
operator|==
name|stack_pointer_rtx
operator|||
name|x
operator|==
name|pic_offset_table_rtx
condition|)
name|record
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|global_regs
index|[
name|regno
index|]
condition|)
name|record
operator|=
name|false
expr_stmt|;
elseif|else
if|if
condition|(
name|fixed_regs
index|[
name|regno
index|]
condition|)
name|record
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MODE_CC
condition|)
name|record
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|SMALL_REGISTER_CLASSES
condition|)
name|record
operator|=
name|false
expr_stmt|;
elseif|else
if|if
condition|(
name|CLASS_LIKELY_SPILLED_P
argument_list|(
name|REGNO_REG_CLASS
argument_list|(
name|regno
argument_list|)
argument_list|)
condition|)
name|record
operator|=
name|false
expr_stmt|;
else|else
name|record
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|!
name|record
condition|)
block|{
name|do_not_record
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
name|hash
operator|+=
operator|(
operator|(
name|unsigned
operator|)
name|REG
operator|<<
literal|7
operator|)
operator|+
operator|(
name|unsigned
operator|)
name|REG_QTY
argument_list|(
name|regno
argument_list|)
expr_stmt|;
return|return
name|hash
return|;
block|}
comment|/* We handle SUBREG of a REG specially because the underlying        reg changes its hash value with every value change; we don't        want to have to forget unrelated subregs when one subreg changes.  */
case|case
name|SUBREG
case|:
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|hash
operator|+=
operator|(
operator|(
operator|(
name|unsigned
operator|)
name|SUBREG
operator|<<
literal|7
operator|)
operator|+
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|+
operator|(
name|SUBREG_BYTE
argument_list|(
name|x
argument_list|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|)
expr_stmt|;
return|return
name|hash
return|;
block|}
break|break;
block|}
case|case
name|CONST_INT
case|:
block|{
name|unsigned
name|HOST_WIDE_INT
name|tem
init|=
name|INTVAL
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|hash
operator|+=
operator|(
operator|(
name|unsigned
operator|)
name|CONST_INT
operator|<<
literal|7
operator|)
operator|+
operator|(
name|unsigned
operator|)
name|mode
operator|+
name|tem
expr_stmt|;
return|return
name|hash
return|;
block|}
case|case
name|CONST_DOUBLE
case|:
comment|/* This is like the general case, except that it only counts 	 the integers representing the constant.  */
name|hash
operator|+=
operator|(
name|unsigned
operator|)
name|code
operator|+
operator|(
name|unsigned
operator|)
name|GET_MODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|VOIDmode
condition|)
name|hash
operator|+=
name|real_hash
argument_list|(
name|CONST_DOUBLE_REAL_VALUE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|hash
operator|+=
operator|(
operator|(
name|unsigned
operator|)
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
operator|+
operator|(
name|unsigned
operator|)
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
operator|)
expr_stmt|;
return|return
name|hash
return|;
case|case
name|CONST_VECTOR
case|:
block|{
name|int
name|units
decl_stmt|;
name|rtx
name|elt
decl_stmt|;
name|units
operator|=
name|CONST_VECTOR_NUNITS
argument_list|(
name|x
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|units
condition|;
operator|++
name|i
control|)
block|{
name|elt
operator|=
name|CONST_VECTOR_ELT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|hash
operator|+=
name|canon_hash
argument_list|(
name|elt
argument_list|,
name|GET_MODE
argument_list|(
name|elt
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|hash
return|;
block|}
comment|/* Assume there is only one rtx object for any given label.  */
case|case
name|LABEL_REF
case|:
name|hash
operator|+=
operator|(
operator|(
name|unsigned
operator|)
name|LABEL_REF
operator|<<
literal|7
operator|)
operator|+
operator|(
name|unsigned
name|long
operator|)
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|hash
return|;
case|case
name|SYMBOL_REF
case|:
name|hash
operator|+=
operator|(
operator|(
name|unsigned
operator|)
name|SYMBOL_REF
operator|<<
literal|7
operator|)
operator|+
operator|(
name|unsigned
name|long
operator|)
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|hash
return|;
case|case
name|MEM
case|:
comment|/* We don't record if marked volatile or if BLKmode since we don't 	 know the size of the move.  */
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
operator|||
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|BLKmode
condition|)
block|{
name|do_not_record
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|RTX_UNCHANGING_P
argument_list|(
name|x
argument_list|)
operator|||
name|fixed_base_plus_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|hash_arg_in_memory
operator|=
literal|1
expr_stmt|;
comment|/* Now that we have already found this special case, 	 might as well speed it up as much as possible.  */
name|hash
operator|+=
operator|(
name|unsigned
operator|)
name|MEM
expr_stmt|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|repeat
goto|;
case|case
name|USE
case|:
comment|/* A USE that mentions non-volatile memory needs special 	 handling since the MEM may be BLKmode which normally 	 prevents an entry from being made.  Pure calls are 	 marked by a USE which mentions BLKmode memory.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|MEM_VOLATILE_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|hash
operator|+=
operator|(
name|unsigned
operator|)
name|USE
expr_stmt|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|RTX_UNCHANGING_P
argument_list|(
name|x
argument_list|)
operator|||
name|fixed_base_plus_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|hash_arg_in_memory
operator|=
literal|1
expr_stmt|;
comment|/* Now that we have already found this special case, 	     might as well speed it up as much as possible.  */
name|hash
operator|+=
operator|(
name|unsigned
operator|)
name|MEM
expr_stmt|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|repeat
goto|;
block|}
break|break;
case|case
name|PRE_DEC
case|:
case|case
name|PRE_INC
case|:
case|case
name|POST_DEC
case|:
case|case
name|POST_INC
case|:
case|case
name|PRE_MODIFY
case|:
case|case
name|POST_MODIFY
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|CALL
case|:
case|case
name|UNSPEC_VOLATILE
case|:
name|do_not_record
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
case|case
name|ASM_OPERANDS
case|:
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|do_not_record
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* We don't want to take the filename and line into account.  */
name|hash
operator|+=
operator|(
name|unsigned
operator|)
name|code
operator|+
operator|(
name|unsigned
operator|)
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|+
name|canon_hash_string
argument_list|(
name|ASM_OPERANDS_TEMPLATE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|+
name|canon_hash_string
argument_list|(
name|ASM_OPERANDS_OUTPUT_CONSTRAINT
argument_list|(
name|x
argument_list|)
argument_list|)
operator|+
operator|(
name|unsigned
operator|)
name|ASM_OPERANDS_OUTPUT_IDX
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|x
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|x
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|hash
operator|+=
operator|(
name|canon_hash
argument_list|(
name|ASM_OPERANDS_INPUT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|ASM_OPERANDS_INPUT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
operator|+
name|canon_hash_string
argument_list|(
name|ASM_OPERANDS_INPUT_CONSTRAINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
name|hash
operator|+=
name|canon_hash_string
argument_list|(
name|ASM_OPERANDS_INPUT_CONSTRAINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|ASM_OPERANDS_INPUT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
goto|goto
name|repeat
goto|;
block|}
return|return
name|hash
return|;
block|}
break|break;
default|default:
break|break;
block|}
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
expr_stmt|;
name|hash
operator|+=
operator|(
name|unsigned
operator|)
name|code
operator|+
operator|(
name|unsigned
operator|)
name|GET_MODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
name|rtx
name|tem
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
decl_stmt|;
comment|/* If we are about to do the last recursive call 	     needed at this level, change it into iteration. 	     This function  is called enough to be worth it.  */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|x
operator|=
name|tem
expr_stmt|;
goto|goto
name|repeat
goto|;
block|}
name|hash
operator|+=
name|canon_hash
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|hash
operator|+=
name|canon_hash
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'s'
condition|)
name|hash
operator|+=
name|canon_hash_string
argument_list|(
name|XSTR
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'i'
condition|)
block|{
name|unsigned
name|tem
init|=
name|XINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|hash
operator|+=
name|tem
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'0'
operator|||
name|fmt
index|[
name|i
index|]
operator|==
literal|'t'
condition|)
comment|/* Unused.  */
empty_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|hash
return|;
block|}
end_function

begin_comment
comment|/* Like canon_hash but with no side effects.  */
end_comment

begin_function
specifier|static
name|unsigned
name|safe_hash
parameter_list|(
name|rtx
name|x
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|int
name|save_do_not_record
init|=
name|do_not_record
decl_stmt|;
name|int
name|save_hash_arg_in_memory
init|=
name|hash_arg_in_memory
decl_stmt|;
name|unsigned
name|hash
init|=
name|canon_hash
argument_list|(
name|x
argument_list|,
name|mode
argument_list|)
decl_stmt|;
name|hash_arg_in_memory
operator|=
name|save_hash_arg_in_memory
expr_stmt|;
name|do_not_record
operator|=
name|save_do_not_record
expr_stmt|;
return|return
name|hash
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 iff X and Y would canonicalize into the same thing,    without actually constructing the canonicalization of either one.    If VALIDATE is nonzero,    we assume X is an expression being processed from the rtl    and Y was found in the hash table.  We check register refs    in Y for being marked as valid.     If EQUAL_VALUES is nonzero, we allow a register to match a constant value    that is known to be in the register.  Ordinarily, we don't allow them    to match, because letting them match would cause unpredictable results    in all the places that search a hash table chain for an equivalent    for a given value.  A possible equivalent that has different structure    has its hash code computed from different data.  Whether the hash code    is the same as that of the given value is pure luck.  */
end_comment

begin_function
specifier|static
name|int
name|exp_equiv_p
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|y
parameter_list|,
name|int
name|validate
parameter_list|,
name|int
name|equal_values
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
comment|/* Note: it is incorrect to assume an expression is equivalent to itself      if VALIDATE is nonzero.  */
if|if
condition|(
name|x
operator|==
name|y
operator|&&
operator|!
name|validate
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|x
operator|==
literal|0
operator|||
name|y
operator|==
literal|0
condition|)
return|return
name|x
operator|==
name|y
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|GET_CODE
argument_list|(
name|y
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|equal_values
condition|)
return|return
literal|0
return|;
comment|/* If X is a constant and Y is a register or vice versa, they may be 	 equivalent.  We only have to validate if Y is a register.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO_QTY_VALID_P
argument_list|(
name|REGNO
argument_list|(
name|y
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|y_q
init|=
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|y
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|qty_table_elem
modifier|*
name|y_ent
init|=
operator|&
name|qty_table
index|[
name|y_q
index|]
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|y
argument_list|)
operator|==
name|y_ent
operator|->
name|mode
operator|&&
name|rtx_equal_p
argument_list|(
name|x
argument_list|,
name|y_ent
operator|->
name|const_rtx
argument_list|)
operator|&&
operator|(
operator|!
name|validate
operator|||
name|REG_IN_TABLE
argument_list|(
name|REGNO
argument_list|(
name|y
argument_list|)
argument_list|)
operator|==
name|REG_TICK
argument_list|(
name|REGNO
argument_list|(
name|y
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
block|}
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|y
argument_list|)
operator|&&
name|code
operator|==
name|REG
operator|&&
name|REGNO_QTY_VALID_P
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|x_q
init|=
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|qty_table_elem
modifier|*
name|x_ent
init|=
operator|&
name|qty_table
index|[
name|x_q
index|]
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|x_ent
operator|->
name|mode
operator|&&
name|rtx_equal_p
argument_list|(
name|y
argument_list|,
name|x_ent
operator|->
name|const_rtx
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
comment|/* (MULT:SI x y) and (MULT:HI x y) are NOT equivalent.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|CONST_INT
case|:
return|return
name|x
operator|==
name|y
return|;
case|case
name|LABEL_REF
case|:
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|SYMBOL_REF
case|:
return|return
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|XSTR
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|REG
case|:
block|{
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|y
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|endregno
init|=
name|regno
operator|+
operator|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|?
literal|1
else|:
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|y
argument_list|)
argument_list|)
operator|)
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* If the quantities are not the same, the expressions are not 	   equivalent.  If there are and we are not to validate, they 	   are equivalent.  Otherwise, ensure all regs are up-to-date.  */
if|if
condition|(
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|REG_QTY
argument_list|(
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|validate
condition|)
return|return
literal|1
return|;
for|for
control|(
name|i
operator|=
name|regno
init|;
name|i
operator|<
name|endregno
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|REG_IN_TABLE
argument_list|(
name|i
argument_list|)
operator|!=
name|REG_TICK
argument_list|(
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
comment|/*  For commutative operations, check both orders.  */
case|case
name|PLUS
case|:
case|case
name|MULT
case|:
case|case
name|AND
case|:
case|case
name|IOR
case|:
case|case
name|XOR
case|:
case|case
name|NE
case|:
case|case
name|EQ
case|:
return|return
operator|(
operator|(
name|exp_equiv_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|,
name|validate
argument_list|,
name|equal_values
argument_list|)
operator|&&
name|exp_equiv_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|,
name|validate
argument_list|,
name|equal_values
argument_list|)
operator|)
operator|||
operator|(
name|exp_equiv_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|,
name|validate
argument_list|,
name|equal_values
argument_list|)
operator|&&
name|exp_equiv_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|,
name|validate
argument_list|,
name|equal_values
argument_list|)
operator|)
operator|)
return|;
case|case
name|ASM_OPERANDS
case|:
comment|/* We don't use the generic code below because we want to 	 disregard filename and line numbers.  */
comment|/* A volatile asm isn't equivalent to any other.  */
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
operator|||
name|MEM_VOLATILE_P
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|y
argument_list|)
operator|||
name|strcmp
argument_list|(
name|ASM_OPERANDS_TEMPLATE
argument_list|(
name|x
argument_list|)
argument_list|,
name|ASM_OPERANDS_TEMPLATE
argument_list|(
name|y
argument_list|)
argument_list|)
operator|||
name|strcmp
argument_list|(
name|ASM_OPERANDS_OUTPUT_CONSTRAINT
argument_list|(
name|x
argument_list|)
argument_list|,
name|ASM_OPERANDS_OUTPUT_CONSTRAINT
argument_list|(
name|y
argument_list|)
argument_list|)
operator|||
name|ASM_OPERANDS_OUTPUT_IDX
argument_list|(
name|x
argument_list|)
operator|!=
name|ASM_OPERANDS_OUTPUT_IDX
argument_list|(
name|y
argument_list|)
operator|||
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|x
argument_list|)
operator|!=
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|x
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|x
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
operator|!
name|exp_equiv_p
argument_list|(
name|ASM_OPERANDS_INPUT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|ASM_OPERANDS_INPUT
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
argument_list|,
name|validate
argument_list|,
name|equal_values
argument_list|)
operator|||
name|strcmp
argument_list|(
name|ASM_OPERANDS_INPUT_CONSTRAINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|ASM_OPERANDS_INPUT_CONSTRAINT
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
default|default:
break|break;
block|}
comment|/* Compare the elements.  If any pair of corresponding elements      fail to match, return 0 for the whole things.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
switch|switch
condition|(
name|fmt
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'e'
case|:
if|if
condition|(
operator|!
name|exp_equiv_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
argument_list|,
name|validate
argument_list|,
name|equal_values
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'E'
case|:
if|if
condition|(
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XVECLEN
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|exp_equiv_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|XVECEXP
argument_list|(
name|y
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|validate
argument_list|,
name|equal_values
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|XSTR
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'i'
case|:
if|if
condition|(
name|XINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XINT
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'w'
case|:
if|if
condition|(
name|XWINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XWINT
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'t'
case|:
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if X has a value that can vary even between two    executions of the program.  0 means X can be compared reliably    against certain constants or near-constants.  */
end_comment

begin_function
specifier|static
name|int
name|cse_rtx_varies_p
parameter_list|(
name|rtx
name|x
parameter_list|,
name|int
name|from_alias
parameter_list|)
block|{
comment|/* We need not check for X and the equivalence class being of the same      mode because if X is equivalent to a constant in some mode, it      doesn't vary in any mode.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO_QTY_VALID_P
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|x_q
init|=
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|qty_table_elem
modifier|*
name|x_ent
init|=
operator|&
name|qty_table
index|[
name|x_q
index|]
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|x_ent
operator|->
name|mode
operator|&&
name|x_ent
operator|->
name|const_rtx
operator|!=
name|NULL_RTX
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO_QTY_VALID_P
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|x0_q
init|=
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|qty_table_elem
modifier|*
name|x0_ent
init|=
operator|&
name|qty_table
index|[
name|x0_q
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|x0_ent
operator|->
name|mode
operator|)
operator|&&
name|x0_ent
operator|->
name|const_rtx
operator|!=
name|NULL_RTX
condition|)
return|return
literal|0
return|;
block|}
comment|/* This can happen as the result of virtual register instantiation, if      the initial constant is too large to be a valid address.  This gives      us a three instruction sequence, load large offset into a register,      load fp minus a constant into a register, then a MEM which is the      sum of the two `constant' registers.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO_QTY_VALID_P
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|REGNO_QTY_VALID_P
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|x0_q
init|=
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|x1_q
init|=
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|qty_table_elem
modifier|*
name|x0_ent
init|=
operator|&
name|qty_table
index|[
name|x0_q
index|]
decl_stmt|;
name|struct
name|qty_table_elem
modifier|*
name|x1_ent
init|=
operator|&
name|qty_table
index|[
name|x1_q
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|x0_ent
operator|->
name|mode
operator|)
operator|&&
name|x0_ent
operator|->
name|const_rtx
operator|!=
name|NULL_RTX
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|x1_ent
operator|->
name|mode
operator|)
operator|&&
name|x1_ent
operator|->
name|const_rtx
operator|!=
name|NULL_RTX
condition|)
return|return
literal|0
return|;
block|}
return|return
name|rtx_varies_p
argument_list|(
name|x
argument_list|,
name|from_alias
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Canonicalize an expression:    replace each register reference inside it    with the "oldest" equivalent register.     If INSN is nonzero and we are replacing a pseudo with a hard register    or vice versa, validate_change is used to ensure that INSN remains valid    after we make our substitution.  The calls are made with IN_GROUP nonzero    so apply_change_group must be called upon the outermost return from this    function (unless INSN is zero).  The result of apply_change_group can    generally be discarded since the changes we are making are optional.  */
end_comment

begin_function
specifier|static
name|rtx
name|canon_reg
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
name|x
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|CONST
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_VECTOR
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
return|return
name|x
return|;
case|case
name|REG
case|:
block|{
name|int
name|first
decl_stmt|;
name|int
name|q
decl_stmt|;
name|struct
name|qty_table_elem
modifier|*
name|ent
decl_stmt|;
comment|/* Never replace a hard reg, because hard regs can appear 	   in more than one machine mode, and we must preserve the mode 	   of each occurrence.  Also, some hard regs appear in 	   MEMs that are shared and mustn't be altered.  Don't try to 	   replace any reg that maps to a reg of class NO_REGS.  */
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|||
operator|!
name|REGNO_QTY_VALID_P
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
return|return
name|x
return|;
name|q
operator|=
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|ent
operator|=
operator|&
name|qty_table
index|[
name|q
index|]
expr_stmt|;
name|first
operator|=
name|ent
operator|->
name|first_reg
expr_stmt|;
return|return
operator|(
name|first
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|?
name|regno_reg_rtx
index|[
name|first
index|]
else|:
name|REGNO_REG_CLASS
argument_list|(
name|first
argument_list|)
operator|==
name|NO_REGS
condition|?
name|x
else|:
name|gen_rtx_REG
argument_list|(
name|ent
operator|->
name|mode
argument_list|,
name|first
argument_list|)
operator|)
return|;
block|}
default|default:
break|break;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|int
name|j
decl_stmt|;
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
name|rtx
name|new
init|=
name|canon_reg
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|)
decl_stmt|;
name|int
name|insn_code
decl_stmt|;
comment|/* If replacing pseudo with hard reg or vice versa, ensure the 	     insn remains valid.  Likewise if the insn has MATCH_DUPs.  */
if|if
condition|(
name|insn
operator|!=
literal|0
operator|&&
name|new
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|new
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
operator|(
operator|(
name|REGNO
argument_list|(
name|new
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
operator|!=
operator|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
operator|)
operator|||
operator|(
name|insn_code
operator|=
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|)
operator|<
literal|0
operator|||
name|insn_data
index|[
name|insn_code
index|]
operator|.
name|n_dups
operator|>
literal|0
operator|)
condition|)
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|new
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|=
name|new
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|=
name|canon_reg
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* LOC is a location within INSN that is an operand address (the contents of    a MEM).  Find the best equivalent address to use that is valid for this    insn.     On most CISC machines, complicated address modes are costly, and rtx_cost    is a good approximation for that cost.  However, most RISC machines have    only a few (usually only one) memory reference formats.  If an address is    valid at all, it is often just as cheap as any other address.  Hence, for    RISC machines, we use `address_cost' to compare the costs of various    addresses.  For two addresses of equal cost, choose the one with the    highest `rtx_cost' value as that has the potential of eliminating the    most insns.  For equal costs, we choose the first in the equivalence    class.  Note that we ignore the fact that pseudo registers are cheaper than    hard registers here because we would also prefer the pseudo registers.  */
end_comment

begin_function
specifier|static
name|void
name|find_best_addr
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
modifier|*
name|loc
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|struct
name|table_elt
modifier|*
name|elt
decl_stmt|;
name|rtx
name|addr
init|=
operator|*
name|loc
decl_stmt|;
name|struct
name|table_elt
modifier|*
name|p
decl_stmt|;
name|int
name|found_better
init|=
literal|1
decl_stmt|;
name|int
name|save_do_not_record
init|=
name|do_not_record
decl_stmt|;
name|int
name|save_hash_arg_in_memory
init|=
name|hash_arg_in_memory
decl_stmt|;
name|int
name|addr_volatile
decl_stmt|;
name|int
name|regno
decl_stmt|;
name|unsigned
name|hash
decl_stmt|;
comment|/* Do not try to replace constant addresses or addresses of local and      argument slots.  These MEM expressions are made only once and inserted      in many instructions, as well as being used to control symbol table      output.  It is not safe to clobber them.       There are some uncommon cases where the address is already in a register      for some reason, but we cannot take advantage of that because we have      no easy way to unshare the MEM.  In addition, looking up all stack      addresses is costly.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|regno
operator|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|,
name|regno
operator|==
name|FRAME_POINTER_REGNUM
operator|||
name|regno
operator|==
name|HARD_FRAME_POINTER_REGNUM
operator|||
name|regno
operator|==
name|ARG_POINTER_REGNUM
operator|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|regno
operator|=
name|REGNO
argument_list|(
name|addr
argument_list|)
operator|,
name|regno
operator|==
name|FRAME_POINTER_REGNUM
operator|||
name|regno
operator|==
name|HARD_FRAME_POINTER_REGNUM
operator|||
name|regno
operator|==
name|ARG_POINTER_REGNUM
operator|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|ADDRESSOF
operator|||
name|CONSTANT_ADDRESS_P
argument_list|(
name|addr
argument_list|)
condition|)
return|return;
comment|/* If this address is not simply a register, try to fold it.  This will      sometimes simplify the expression.  Many simplifications      will not be valid, but some, usually applying the associative rule, will      be valid and produce better code.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|!=
name|REG
condition|)
block|{
name|rtx
name|folded
init|=
name|fold_rtx
argument_list|(
name|copy_rtx
argument_list|(
name|addr
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
name|int
name|addr_folded_cost
init|=
name|address_cost
argument_list|(
name|folded
argument_list|,
name|mode
argument_list|)
decl_stmt|;
name|int
name|addr_cost
init|=
name|address_cost
argument_list|(
name|addr
argument_list|,
name|mode
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|addr_folded_cost
operator|<
name|addr_cost
operator|||
operator|(
name|addr_folded_cost
operator|==
name|addr_cost
comment|/* ??? The rtx_cost comparison is left over from an older 		  version of this code.  It is probably no longer helpful.  */
operator|&&
operator|(
name|rtx_cost
argument_list|(
name|folded
argument_list|,
name|MEM
argument_list|)
operator|>
name|rtx_cost
argument_list|(
name|addr
argument_list|,
name|MEM
argument_list|)
operator|||
name|approx_reg_cost
argument_list|(
name|folded
argument_list|)
operator|<
name|approx_reg_cost
argument_list|(
name|addr
argument_list|)
operator|)
operator|)
operator|)
operator|&&
name|validate_change
argument_list|(
name|insn
argument_list|,
name|loc
argument_list|,
name|folded
argument_list|,
literal|0
argument_list|)
condition|)
name|addr
operator|=
name|folded
expr_stmt|;
block|}
comment|/* If this address is not in the hash table, we can't look for equivalences      of the whole address.  Also, ignore if volatile.  */
name|do_not_record
operator|=
literal|0
expr_stmt|;
name|hash
operator|=
name|HASH
argument_list|(
name|addr
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
name|addr_volatile
operator|=
name|do_not_record
expr_stmt|;
name|do_not_record
operator|=
name|save_do_not_record
expr_stmt|;
name|hash_arg_in_memory
operator|=
name|save_hash_arg_in_memory
expr_stmt|;
if|if
condition|(
name|addr_volatile
condition|)
return|return;
name|elt
operator|=
name|lookup
argument_list|(
name|addr
argument_list|,
name|hash
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|elt
condition|)
block|{
comment|/* We need to find the best (under the criteria documented above) entry 	 in the class that is valid.  We use the `flag' field to indicate 	 choices that were invalid and iterate until we can't find a better 	 one that hasn't already been tried.  */
for|for
control|(
name|p
operator|=
name|elt
operator|->
name|first_same_value
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next_same_value
control|)
name|p
operator|->
name|flag
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|found_better
condition|)
block|{
name|int
name|best_addr_cost
init|=
name|address_cost
argument_list|(
operator|*
name|loc
argument_list|,
name|mode
argument_list|)
decl_stmt|;
name|int
name|best_rtx_cost
init|=
operator|(
name|elt
operator|->
name|cost
operator|+
literal|1
operator|)
operator|>>
literal|1
decl_stmt|;
name|int
name|exp_cost
decl_stmt|;
name|struct
name|table_elt
modifier|*
name|best_elt
init|=
name|elt
decl_stmt|;
name|found_better
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|elt
operator|->
name|first_same_value
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next_same_value
control|)
if|if
condition|(
operator|!
name|p
operator|->
name|flag
condition|)
block|{
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|p
operator|->
name|exp
argument_list|)
operator|==
name|REG
operator|||
name|exp_equiv_p
argument_list|(
name|p
operator|->
name|exp
argument_list|,
name|p
operator|->
name|exp
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|exp_cost
operator|=
name|address_cost
argument_list|(
name|p
operator|->
name|exp
argument_list|,
name|mode
argument_list|)
operator|)
operator|<
name|best_addr_cost
operator|||
operator|(
name|exp_cost
operator|==
name|best_addr_cost
operator|&&
operator|(
operator|(
name|p
operator|->
name|cost
operator|+
literal|1
operator|)
operator|>>
literal|1
operator|)
operator|>
name|best_rtx_cost
operator|)
operator|)
condition|)
block|{
name|found_better
operator|=
literal|1
expr_stmt|;
name|best_addr_cost
operator|=
name|exp_cost
expr_stmt|;
name|best_rtx_cost
operator|=
operator|(
name|p
operator|->
name|cost
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
name|best_elt
operator|=
name|p
expr_stmt|;
block|}
block|}
if|if
condition|(
name|found_better
condition|)
block|{
if|if
condition|(
name|validate_change
argument_list|(
name|insn
argument_list|,
name|loc
argument_list|,
name|canon_reg
argument_list|(
name|copy_rtx
argument_list|(
name|best_elt
operator|->
name|exp
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return;
else|else
name|best_elt
operator|->
name|flag
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* If the address is a binary operation with the first operand a register      and the second a constant, do the same as above, but looking for      equivalences of the register.  Then try to simplify before checking for      the best address to use.  This catches a few cases:  First is when we      have REG+const and the register is another REG+const.  We can often merge      the constants and eliminate one insn and one register.  It may also be      that a machine has a cheap REG+REG+const.  Finally, this improves the      code on the Alpha for unaligned byte stores.  */
if|if
condition|(
name|flag_expensive_optimizations
operator|&&
operator|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
operator|*
name|loc
argument_list|)
argument_list|)
operator|==
literal|'2'
operator|||
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
operator|*
name|loc
argument_list|)
argument_list|)
operator|==
literal|'c'
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
operator|*
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|rtx
name|op1
init|=
name|XEXP
argument_list|(
operator|*
name|loc
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|do_not_record
operator|=
literal|0
expr_stmt|;
name|hash
operator|=
name|HASH
argument_list|(
name|XEXP
argument_list|(
operator|*
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
name|do_not_record
operator|=
name|save_do_not_record
expr_stmt|;
name|hash_arg_in_memory
operator|=
name|save_hash_arg_in_memory
expr_stmt|;
name|elt
operator|=
name|lookup
argument_list|(
name|XEXP
argument_list|(
operator|*
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|,
name|hash
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|elt
operator|==
literal|0
condition|)
return|return;
comment|/* We need to find the best (under the criteria documented above) entry 	 in the class that is valid.  We use the `flag' field to indicate 	 choices that were invalid and iterate until we can't find a better 	 one that hasn't already been tried.  */
for|for
control|(
name|p
operator|=
name|elt
operator|->
name|first_same_value
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next_same_value
control|)
name|p
operator|->
name|flag
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|found_better
condition|)
block|{
name|int
name|best_addr_cost
init|=
name|address_cost
argument_list|(
operator|*
name|loc
argument_list|,
name|mode
argument_list|)
decl_stmt|;
name|int
name|best_rtx_cost
init|=
operator|(
name|COST
argument_list|(
operator|*
name|loc
argument_list|)
operator|+
literal|1
operator|)
operator|>>
literal|1
decl_stmt|;
name|struct
name|table_elt
modifier|*
name|best_elt
init|=
name|elt
decl_stmt|;
name|rtx
name|best_rtx
init|=
operator|*
name|loc
decl_stmt|;
name|int
name|count
decl_stmt|;
comment|/* This is at worst case an O(n^2) algorithm, so limit our search 	     to the first 32 elements on the list.  This avoids trouble 	     compiling code with very long basic blocks that can easily 	     call simplify_gen_binary so many times that we run out of 	     memory.  */
name|found_better
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|elt
operator|->
name|first_same_value
operator|,
name|count
operator|=
literal|0
init|;
name|p
operator|&&
name|count
operator|<
literal|32
condition|;
name|p
operator|=
name|p
operator|->
name|next_same_value
operator|,
name|count
operator|++
control|)
if|if
condition|(
operator|!
name|p
operator|->
name|flag
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|p
operator|->
name|exp
argument_list|)
operator|==
name|REG
operator|||
name|exp_equiv_p
argument_list|(
name|p
operator|->
name|exp
argument_list|,
name|p
operator|->
name|exp
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|new
init|=
name|simplify_gen_binary
argument_list|(
name|GET_CODE
argument_list|(
operator|*
name|loc
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|p
operator|->
name|exp
argument_list|,
name|op1
argument_list|)
decl_stmt|;
name|int
name|new_cost
decl_stmt|;
name|new_cost
operator|=
name|address_cost
argument_list|(
name|new
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_cost
operator|<
name|best_addr_cost
operator|||
operator|(
name|new_cost
operator|==
name|best_addr_cost
operator|&&
operator|(
name|COST
argument_list|(
name|new
argument_list|)
operator|+
literal|1
operator|)
operator|>>
literal|1
operator|>
name|best_rtx_cost
operator|)
condition|)
block|{
name|found_better
operator|=
literal|1
expr_stmt|;
name|best_addr_cost
operator|=
name|new_cost
expr_stmt|;
name|best_rtx_cost
operator|=
operator|(
name|COST
argument_list|(
name|new
argument_list|)
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
name|best_elt
operator|=
name|p
expr_stmt|;
name|best_rtx
operator|=
name|new
expr_stmt|;
block|}
block|}
if|if
condition|(
name|found_better
condition|)
block|{
if|if
condition|(
name|validate_change
argument_list|(
name|insn
argument_list|,
name|loc
argument_list|,
name|canon_reg
argument_list|(
name|copy_rtx
argument_list|(
name|best_rtx
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return;
else|else
name|best_elt
operator|->
name|flag
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given an operation (CODE, *PARG1, *PARG2), where code is a comparison    operation (EQ, NE, GT, etc.), follow it back through the hash table and    what values are being compared.     *PARG1 and *PARG2 are updated to contain the rtx representing the values    actually being compared.  For example, if *PARG1 was (cc0) and *PARG2    was (const_int 0), *PARG1 and *PARG2 will be set to the objects that were    compared to produce cc0.     The return value is the comparison operator and is either the code of    A or the code corresponding to the inverse of the comparison.  */
end_comment

begin_function
specifier|static
name|enum
name|rtx_code
name|find_comparison_args
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|rtx
modifier|*
name|parg1
parameter_list|,
name|rtx
modifier|*
name|parg2
parameter_list|,
name|enum
name|machine_mode
modifier|*
name|pmode1
parameter_list|,
name|enum
name|machine_mode
modifier|*
name|pmode2
parameter_list|)
block|{
name|rtx
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
name|arg1
operator|=
operator|*
name|parg1
operator|,
name|arg2
operator|=
operator|*
name|parg2
expr_stmt|;
comment|/* If ARG2 is const0_rtx, see what ARG1 is equivalent to.  */
while|while
condition|(
name|arg2
operator|==
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Set nonzero when we find something of interest.  */
name|rtx
name|x
init|=
literal|0
decl_stmt|;
name|int
name|reverse_code
init|=
literal|0
decl_stmt|;
name|struct
name|table_elt
modifier|*
name|p
init|=
literal|0
decl_stmt|;
comment|/* If arg1 is a COMPARE, extract the comparison arguments from it. 	 On machines with CC0, this is the only case that can occur, since 	 fold_rtx will return the COMPARE or item being compared with zero 	 when given CC0.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|COMPARE
operator|&&
name|arg2
operator|==
name|const0_rtx
condition|)
name|x
operator|=
name|arg1
expr_stmt|;
comment|/* If ARG1 is a comparison operator and CODE is testing for 	 STORE_FLAG_VALUE, get the inner arguments.  */
elseif|else
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
literal|'<'
condition|)
block|{
ifdef|#
directive|ifdef
name|FLOAT_STORE_FLAG_VALUE
name|REAL_VALUE_TYPE
name|fsfv
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|code
operator|==
name|NE
operator|||
operator|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|code
operator|==
name|LT
operator|&&
name|STORE_FLAG_VALUE
operator|==
operator|-
literal|1
operator|)
ifdef|#
directive|ifdef
name|FLOAT_STORE_FLAG_VALUE
operator|||
operator|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
operator|(
name|fsfv
operator|=
name|FLOAT_STORE_FLAG_VALUE
argument_list|(
name|GET_MODE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|,
name|REAL_VALUE_NEGATIVE
argument_list|(
name|fsfv
argument_list|)
operator|)
operator|)
endif|#
directive|endif
condition|)
name|x
operator|=
name|arg1
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|EQ
operator|||
operator|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|code
operator|==
name|GE
operator|&&
name|STORE_FLAG_VALUE
operator|==
operator|-
literal|1
operator|)
ifdef|#
directive|ifdef
name|FLOAT_STORE_FLAG_VALUE
operator|||
operator|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
operator|(
name|fsfv
operator|=
name|FLOAT_STORE_FLAG_VALUE
argument_list|(
name|GET_MODE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|,
name|REAL_VALUE_NEGATIVE
argument_list|(
name|fsfv
argument_list|)
operator|)
operator|)
endif|#
directive|endif
condition|)
name|x
operator|=
name|arg1
operator|,
name|reverse_code
operator|=
literal|1
expr_stmt|;
block|}
comment|/* ??? We could also check for  	 (ne (and (eq (...) (const_int 1))) (const_int 0))  	 and related forms, but let's wait until we see them occurring.  */
if|if
condition|(
name|x
operator|==
literal|0
condition|)
comment|/* Look up ARG1 in the hash table and see if it has an equivalence 	   that lets us see what is being compared.  */
name|p
operator|=
name|lookup
argument_list|(
name|arg1
argument_list|,
name|safe_hash
argument_list|(
name|arg1
argument_list|,
name|GET_MODE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|&
name|HASH_MASK
argument_list|,
name|GET_MODE
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|p
operator|=
name|p
operator|->
name|first_same_value
expr_stmt|;
comment|/* If what we compare is already known to be constant, that is as 	     good as it gets. 	     We need to break the loop in this case, because otherwise we 	     can have an infinite loop when looking at a reg that is known 	     to be a constant which is the same as a comparison of a reg 	     against zero which appears later in the insn stream, which in 	     turn is constant and the same as the comparison of the first reg 	     against zero...  */
if|if
condition|(
name|p
operator|->
name|is_const
condition|)
break|break;
block|}
for|for
control|(
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next_same_value
control|)
block|{
name|enum
name|machine_mode
name|inner_mode
init|=
name|GET_MODE
argument_list|(
name|p
operator|->
name|exp
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|FLOAT_STORE_FLAG_VALUE
name|REAL_VALUE_TYPE
name|fsfv
decl_stmt|;
endif|#
directive|endif
comment|/* If the entry isn't valid, skip it.  */
if|if
condition|(
operator|!
name|exp_equiv_p
argument_list|(
name|p
operator|->
name|exp
argument_list|,
name|p
operator|->
name|exp
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
operator|->
name|exp
argument_list|)
operator|==
name|COMPARE
comment|/* Another possibility is that this machine has a compare insn 		 that includes the comparison code.  In that case, ARG1 would 		 be equivalent to a comparison operation that would set ARG1 to 		 either STORE_FLAG_VALUE or zero.  If this is an NE operation, 		 ORIG_CODE is the actual comparison being done; if it is an EQ, 		 we must reverse ORIG_CODE.  On machine with a negative value 		 for STORE_FLAG_VALUE, also look at LT and GE operations.  */
operator|||
operator|(
operator|(
name|code
operator|==
name|NE
operator|||
operator|(
name|code
operator|==
name|LT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|inner_mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|inner_mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|&&
operator|(
name|STORE_FLAG_VALUE
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|inner_mode
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|)
operator|)
ifdef|#
directive|ifdef
name|FLOAT_STORE_FLAG_VALUE
operator|||
operator|(
name|code
operator|==
name|LT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|inner_mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
operator|(
name|fsfv
operator|=
name|FLOAT_STORE_FLAG_VALUE
argument_list|(
name|GET_MODE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|,
name|REAL_VALUE_NEGATIVE
argument_list|(
name|fsfv
argument_list|)
operator|)
operator|)
endif|#
directive|endif
operator|)
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|p
operator|->
name|exp
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|)
condition|)
block|{
name|x
operator|=
name|p
operator|->
name|exp
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
name|code
operator|==
name|EQ
operator|||
operator|(
name|code
operator|==
name|GE
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|inner_mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|inner_mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|&&
operator|(
name|STORE_FLAG_VALUE
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|inner_mode
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|)
operator|)
ifdef|#
directive|ifdef
name|FLOAT_STORE_FLAG_VALUE
operator|||
operator|(
name|code
operator|==
name|GE
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|inner_mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
operator|(
name|fsfv
operator|=
name|FLOAT_STORE_FLAG_VALUE
argument_list|(
name|GET_MODE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|,
name|REAL_VALUE_NEGATIVE
argument_list|(
name|fsfv
argument_list|)
operator|)
operator|)
endif|#
directive|endif
operator|)
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|p
operator|->
name|exp
argument_list|)
argument_list|)
operator|==
literal|'<'
condition|)
block|{
name|reverse_code
operator|=
literal|1
expr_stmt|;
name|x
operator|=
name|p
operator|->
name|exp
expr_stmt|;
break|break;
block|}
comment|/* If this non-trapping address, e.g. fp + constant, the 	     equivalent is a better operand since it may let us predict 	     the value of the comparison.  */
elseif|else
if|if
condition|(
operator|!
name|rtx_addr_can_trap_p
argument_list|(
name|p
operator|->
name|exp
argument_list|)
condition|)
block|{
name|arg1
operator|=
name|p
operator|->
name|exp
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* If we didn't find a useful equivalence for ARG1, we are done. 	 Otherwise, set up for the next iteration.  */
if|if
condition|(
name|x
operator|==
literal|0
condition|)
break|break;
comment|/* If we need to reverse the comparison, make sure that that is 	 possible -- we can't necessarily infer the value of GE from LT 	 with floating-point operands.  */
if|if
condition|(
name|reverse_code
condition|)
block|{
name|enum
name|rtx_code
name|reversed
init|=
name|reversed_comparison_code
argument_list|(
name|x
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
if|if
condition|(
name|reversed
operator|==
name|UNKNOWN
condition|)
break|break;
else|else
name|code
operator|=
name|reversed
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
literal|'<'
condition|)
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|,
name|arg2
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Return our results.  Return the modes from before fold_rtx      because fold_rtx might produce const_int, and then it's too late.  */
operator|*
name|pmode1
operator|=
name|GET_MODE
argument_list|(
name|arg1
argument_list|)
operator|,
operator|*
name|pmode2
operator|=
name|GET_MODE
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
operator|*
name|parg1
operator|=
name|fold_rtx
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
operator|,
operator|*
name|parg2
operator|=
name|fold_rtx
argument_list|(
name|arg2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|code
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If X is a nontrivial arithmetic operation on an argument    for which a constant value can be determined, return    the result of operating on that value, as a constant.    Otherwise, return X, possibly with one or more operands    modified by recursive calls to this function.     If X is a register whose contents are known, we do NOT    return those contents here.  equiv_constant is called to    perform that task.     INSN is the insn that we may be modifying.  If it is 0, make a copy    of X before modifying it.  */
end_comment

begin_function
specifier|static
name|rtx
name|fold_rtx
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rtx
name|new
init|=
literal|0
decl_stmt|;
name|int
name|copied
init|=
literal|0
decl_stmt|;
name|int
name|must_swap
init|=
literal|0
decl_stmt|;
comment|/* Folded equivalents of first two operands of X.  */
name|rtx
name|folded_arg0
decl_stmt|;
name|rtx
name|folded_arg1
decl_stmt|;
comment|/* Constant equivalents of first three operands of X;      0 when no such equivalent is known.  */
name|rtx
name|const_arg0
decl_stmt|;
name|rtx
name|const_arg1
decl_stmt|;
name|rtx
name|const_arg2
decl_stmt|;
comment|/* The mode of the first operand of X.  We need this for sign and zero      extends.  */
name|enum
name|machine_mode
name|mode_arg0
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
name|x
return|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_VECTOR
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|REG
case|:
comment|/* No use simplifying an EXPR_LIST 	 since they are used only for lists of args 	 in a function call's REG_EQUAL note.  */
case|case
name|EXPR_LIST
case|:
comment|/* Changing anything inside an ADDRESSOF is incorrect; we don't 	 want to (e.g.,) make (addressof (const_int 0)) just because 	 the location is known to be zero.  */
case|case
name|ADDRESSOF
case|:
return|return
name|x
return|;
ifdef|#
directive|ifdef
name|HAVE_cc0
case|case
name|CC0
case|:
return|return
name|prev_insn_cc0
return|;
endif|#
directive|endif
case|case
name|PC
case|:
comment|/* If the next insn is a CODE_LABEL followed by a jump table, 	 PC's value is a LABEL_REF pointing to that label.  That 	 lets us fold switch statements on the VAX.  */
block|{
name|rtx
name|next
decl_stmt|;
if|if
condition|(
name|insn
operator|&&
name|tablejump_p
argument_list|(
name|insn
argument_list|,
operator|&
name|next
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
name|gen_rtx_LABEL_REF
argument_list|(
name|Pmode
argument_list|,
name|next
argument_list|)
return|;
block|}
break|break;
case|case
name|SUBREG
case|:
comment|/* See if we previously assigned a constant value to this SUBREG.  */
if|if
condition|(
operator|(
name|new
operator|=
name|lookup_as_function
argument_list|(
name|x
argument_list|,
name|CONST_INT
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|new
operator|=
name|lookup_as_function
argument_list|(
name|x
argument_list|,
name|CONST_DOUBLE
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|new
return|;
comment|/* If this is a paradoxical SUBREG, we have no idea what value the 	 extra bits would have.  However, if the operand is equivalent 	 to a SUBREG whose operand is the same as our mode, and all the 	 modes are within a word, we can just use the inner operand 	 because these SUBREGs just say how to treat the register.  	 Similarly if we find an integer constant.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|enum
name|machine_mode
name|imode
init|=
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|table_elt
modifier|*
name|elt
decl_stmt|;
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|UNITS_PER_WORD
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|imode
argument_list|)
operator|<=
name|UNITS_PER_WORD
operator|&&
operator|(
name|elt
operator|=
name|lookup
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
name|HASH
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
name|imode
argument_list|)
argument_list|,
name|imode
argument_list|)
operator|)
operator|!=
literal|0
condition|)
for|for
control|(
name|elt
operator|=
name|elt
operator|->
name|first_same_value
init|;
name|elt
condition|;
name|elt
operator|=
name|elt
operator|->
name|next_same_value
control|)
block|{
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|elt
operator|->
name|exp
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|elt
operator|->
name|exp
argument_list|)
operator|==
name|VOIDmode
condition|)
return|return
name|elt
operator|->
name|exp
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|elt
operator|->
name|exp
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|elt
operator|->
name|exp
argument_list|)
argument_list|)
operator|==
name|mode
operator|&&
name|exp_equiv_p
argument_list|(
name|elt
operator|->
name|exp
argument_list|,
name|elt
operator|->
name|exp
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|copy_rtx
argument_list|(
name|SUBREG_REG
argument_list|(
name|elt
operator|->
name|exp
argument_list|)
argument_list|)
return|;
block|}
return|return
name|x
return|;
block|}
comment|/* Fold SUBREG_REG.  If it changed, see if we can simplify the SUBREG. 	 We might be able to if the SUBREG is extracting a single word in an 	 integral mode or extracting the low part.  */
name|folded_arg0
operator|=
name|fold_rtx
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|const_arg0
operator|=
name|equiv_constant
argument_list|(
name|folded_arg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|const_arg0
condition|)
name|folded_arg0
operator|=
name|const_arg0
expr_stmt|;
if|if
condition|(
name|folded_arg0
operator|!=
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|new
operator|=
name|simplify_subreg
argument_list|(
name|mode
argument_list|,
name|folded_arg0
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
condition|)
return|return
name|new
return|;
block|}
comment|/* If this is a narrowing SUBREG and our operand is a REG, see if 	 we can find an equivalence for REG that is an arithmetic operation 	 in a wider mode where both operands are paradoxical SUBREGs 	 from objects of our result mode.  In that case, we couldn't report 	 an equivalent value for that operation, since we don't know what the 	 extra bits will be.  But we can find an equivalence for this SUBREG 	 by folding that operation is the narrow mode.  This allows us to 	 fold arithmetic in narrow modes when the machine only supports 	 word-sized arithmetic.  	 Also look for a case where we have a SUBREG whose operand is the 	 same as our result.  If both modes are smaller than a word, we 	 are simply interpreting a register in different modes and we 	 can use the inner value.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|folded_arg0
argument_list|)
operator|==
name|REG
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|folded_arg0
argument_list|)
argument_list|)
operator|&&
name|subreg_lowpart_p
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|struct
name|table_elt
modifier|*
name|elt
decl_stmt|;
comment|/* We can use HASH here since we know that canon_hash won't be 	     called.  */
name|elt
operator|=
name|lookup
argument_list|(
name|folded_arg0
argument_list|,
name|HASH
argument_list|(
name|folded_arg0
argument_list|,
name|GET_MODE
argument_list|(
name|folded_arg0
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|folded_arg0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|elt
condition|)
name|elt
operator|=
name|elt
operator|->
name|first_same_value
expr_stmt|;
for|for
control|(
init|;
name|elt
condition|;
name|elt
operator|=
name|elt
operator|->
name|next_same_value
control|)
block|{
name|enum
name|rtx_code
name|eltcode
init|=
name|GET_CODE
argument_list|(
name|elt
operator|->
name|exp
argument_list|)
decl_stmt|;
comment|/* Just check for unary and binary operations.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|elt
operator|->
name|exp
argument_list|)
argument_list|)
operator|==
literal|'1'
operator|&&
name|GET_CODE
argument_list|(
name|elt
operator|->
name|exp
argument_list|)
operator|!=
name|SIGN_EXTEND
operator|&&
name|GET_CODE
argument_list|(
name|elt
operator|->
name|exp
argument_list|)
operator|!=
name|ZERO_EXTEND
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|elt
operator|->
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|elt
operator|->
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|mode
operator|&&
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|elt
operator|->
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|op0
init|=
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|elt
operator|->
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|REG
operator|&&
operator|!
name|CONSTANT_P
argument_list|(
name|op0
argument_list|)
condition|)
name|op0
operator|=
name|fold_rtx
argument_list|(
name|op0
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|op0
operator|=
name|equiv_constant
argument_list|(
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
condition|)
name|new
operator|=
name|simplify_unary_operation
argument_list|(
name|GET_CODE
argument_list|(
name|elt
operator|->
name|exp
argument_list|)
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|elt
operator|->
name|exp
argument_list|)
argument_list|)
operator|==
literal|'2'
operator|||
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|elt
operator|->
name|exp
argument_list|)
argument_list|)
operator|==
literal|'c'
operator|)
operator|&&
name|eltcode
operator|!=
name|DIV
operator|&&
name|eltcode
operator|!=
name|MOD
operator|&&
name|eltcode
operator|!=
name|UDIV
operator|&&
name|eltcode
operator|!=
name|UMOD
operator|&&
name|eltcode
operator|!=
name|ASHIFTRT
operator|&&
name|eltcode
operator|!=
name|LSHIFTRT
operator|&&
name|eltcode
operator|!=
name|ROTATE
operator|&&
name|eltcode
operator|!=
name|ROTATERT
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|elt
operator|->
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|elt
operator|->
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|mode
operator|)
operator|)
operator|||
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|elt
operator|->
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|elt
operator|->
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|elt
operator|->
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|==
name|mode
operator|)
operator|)
operator|||
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|elt
operator|->
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|op0
init|=
name|gen_lowpart_common
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|elt
operator|->
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|gen_lowpart_common
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|elt
operator|->
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|op0
operator|&&
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|REG
operator|&&
operator|!
name|CONSTANT_P
argument_list|(
name|op0
argument_list|)
condition|)
name|op0
operator|=
name|fold_rtx
argument_list|(
name|op0
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
condition|)
name|op0
operator|=
name|equiv_constant
argument_list|(
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|REG
operator|&&
operator|!
name|CONSTANT_P
argument_list|(
name|op1
argument_list|)
condition|)
name|op1
operator|=
name|fold_rtx
argument_list|(
name|op1
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
condition|)
name|op1
operator|=
name|equiv_constant
argument_list|(
name|op1
argument_list|)
expr_stmt|;
comment|/* If we are looking for the low SImode part of 		     (ashift:DI c (const_int 32)), it doesn't work 		     to compute that in SImode, because a 32-bit shift 		     in SImode is unpredictable.  We know the value is 0.  */
if|if
condition|(
name|op0
operator|&&
name|op1
operator|&&
name|GET_CODE
argument_list|(
name|elt
operator|->
name|exp
argument_list|)
operator|==
name|ASHIFT
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|>=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|<
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|elt
operator|->
name|exp
argument_list|)
argument_list|)
condition|)
comment|/* If the count fits in the inner mode's width, 			   but exceeds the outer mode's width, 			   the value will get truncated to 0 			   by the subreg.  */
name|new
operator|=
name|const0_rtx
expr_stmt|;
else|else
comment|/* If the count exceeds even the inner mode's width, 			   don't fold this expression.  */
name|new
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op0
operator|&&
name|op1
condition|)
name|new
operator|=
name|simplify_binary_operation
argument_list|(
name|GET_CODE
argument_list|(
name|elt
operator|->
name|exp
argument_list|)
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|elt
operator|->
name|exp
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|elt
operator|->
name|exp
argument_list|)
argument_list|)
operator|==
name|mode
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|folded_arg0
argument_list|)
argument_list|)
operator|<=
name|UNITS_PER_WORD
operator|)
operator|&&
name|exp_equiv_p
argument_list|(
name|elt
operator|->
name|exp
argument_list|,
name|elt
operator|->
name|exp
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
name|new
operator|=
name|copy_rtx
argument_list|(
name|SUBREG_REG
argument_list|(
name|elt
operator|->
name|exp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
condition|)
return|return
name|new
return|;
block|}
block|}
return|return
name|x
return|;
case|case
name|NOT
case|:
case|case
name|NEG
case|:
comment|/* If we have (NOT Y), see if Y is known to be (NOT Z). 	 If so, (NOT Y) simplifies to Z.  Similarly for NEG.  */
name|new
operator|=
name|lookup_as_function
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
condition|)
return|return
name|fold_rtx
argument_list|(
name|copy_rtx
argument_list|(
name|XEXP
argument_list|(
name|new
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
return|;
break|break;
case|case
name|MEM
case|:
comment|/* If we are not actually processing an insn, don't try to find the 	 best address.  Not only don't we care, but we could modify the 	 MEM in an invalid way since we have no insn to validate against.  */
if|if
condition|(
name|insn
operator|!=
literal|0
condition|)
name|find_best_addr
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|{
comment|/* Even if we don't fold in the insn itself, 	   we can safely do so here, in hopes of getting a constant.  */
name|rtx
name|addr
init|=
name|fold_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
name|rtx
name|base
init|=
literal|0
decl_stmt|;
name|HOST_WIDE_INT
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO_QTY_VALID_P
argument_list|(
name|REGNO
argument_list|(
name|addr
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|addr_q
init|=
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|addr
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|qty_table_elem
modifier|*
name|addr_ent
init|=
operator|&
name|qty_table
index|[
name|addr_q
index|]
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|addr
argument_list|)
operator|==
name|addr_ent
operator|->
name|mode
operator|&&
name|addr_ent
operator|->
name|const_rtx
operator|!=
name|NULL_RTX
condition|)
name|addr
operator|=
name|addr_ent
operator|->
name|const_rtx
expr_stmt|;
block|}
comment|/* If address is constant, split it into a base and integer offset.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|base
operator|=
name|addr
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|base
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|LO_SUM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
name|base
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|ADDRESSOF
condition|)
return|return
name|change_address
argument_list|(
name|x
argument_list|,
name|VOIDmode
argument_list|,
name|addr
argument_list|)
return|;
comment|/* If this is a constant pool reference, we can fold it into its 	   constant to allow better value tracking.  */
if|if
condition|(
name|base
operator|&&
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|base
argument_list|)
condition|)
block|{
name|rtx
name|constant
init|=
name|get_pool_constant
argument_list|(
name|base
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|const_mode
init|=
name|get_pool_mode
argument_list|(
name|base
argument_list|)
decl_stmt|;
name|rtx
name|new
decl_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|constant
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|constant
argument_list|)
operator|!=
name|CONST_INT
condition|)
block|{
name|constant_pool_entries_cost
operator|=
name|COST
argument_list|(
name|constant
argument_list|)
expr_stmt|;
name|constant_pool_entries_regcost
operator|=
name|approx_reg_cost
argument_list|(
name|constant
argument_list|)
expr_stmt|;
block|}
comment|/* If we are loading the full constant, we have an equivalence.  */
if|if
condition|(
name|offset
operator|==
literal|0
operator|&&
name|mode
operator|==
name|const_mode
condition|)
return|return
name|constant
return|;
comment|/* If this actually isn't a constant (weird!), we can't do 	       anything.  Otherwise, handle the two most common cases: 	       extracting a word from a multi-word constant, and extracting 	       the low-order bits.  Other cases don't seem common enough to 	       worry about.  */
if|if
condition|(
operator|!
name|CONSTANT_P
argument_list|(
name|constant
argument_list|)
condition|)
return|return
name|x
return|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|==
name|UNITS_PER_WORD
operator|&&
name|offset
operator|%
name|UNITS_PER_WORD
operator|==
literal|0
operator|&&
operator|(
name|new
operator|=
name|operand_subword
argument_list|(
name|constant
argument_list|,
name|offset
operator|/
name|UNITS_PER_WORD
argument_list|,
literal|0
argument_list|,
name|const_mode
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|new
return|;
if|if
condition|(
operator|(
operator|(
name|BYTES_BIG_ENDIAN
operator|&&
name|offset
operator|==
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|constant
argument_list|)
argument_list|)
operator|-
literal|1
operator|)
operator|||
operator|(
operator|!
name|BYTES_BIG_ENDIAN
operator|&&
name|offset
operator|==
literal|0
operator|)
operator|)
operator|&&
operator|(
name|new
operator|=
name|gen_lowpart_if_possible
argument_list|(
name|mode
argument_list|,
name|constant
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|new
return|;
block|}
comment|/* If this is a reference to a label at a known position in a jump 	   table, we also know its value.  */
if|if
condition|(
name|base
operator|&&
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|LABEL_REF
condition|)
block|{
name|rtx
name|label
init|=
name|XEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|table_insn
init|=
name|NEXT_INSN
argument_list|(
name|label
argument_list|)
decl_stmt|;
if|if
condition|(
name|table_insn
operator|&&
name|GET_CODE
argument_list|(
name|table_insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|table_insn
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
condition|)
block|{
name|rtx
name|table
init|=
name|PATTERN
argument_list|(
name|table_insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|offset
operator|>=
literal|0
operator|&&
operator|(
name|offset
operator|/
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|table
argument_list|)
argument_list|)
operator|<
name|XVECLEN
argument_list|(
name|table
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
return|return
name|XVECEXP
argument_list|(
name|table
argument_list|,
literal|0
argument_list|,
name|offset
operator|/
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|table
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|table_insn
operator|&&
name|GET_CODE
argument_list|(
name|table_insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|table_insn
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
condition|)
block|{
name|rtx
name|table
init|=
name|PATTERN
argument_list|(
name|table_insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|offset
operator|>=
literal|0
operator|&&
operator|(
name|offset
operator|/
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|table
argument_list|)
argument_list|)
operator|<
name|XVECLEN
argument_list|(
name|table
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
block|{
name|offset
operator|/=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|table
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_MINUS
argument_list|(
name|Pmode
argument_list|,
name|XVECEXP
argument_list|(
name|table
argument_list|,
literal|1
argument_list|,
name|offset
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|table
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|table
argument_list|)
operator|!=
name|Pmode
condition|)
name|new
operator|=
name|gen_rtx_TRUNCATE
argument_list|(
name|GET_MODE
argument_list|(
name|table
argument_list|)
argument_list|,
name|new
argument_list|)
expr_stmt|;
comment|/* Indicate this is a constant.  This isn't a 		       valid form of CONST, but it will only be used 		       to fold the next insns and then discarded, so 		       it should be safe.  		       Note this expression must be explicitly discarded, 		       by cse_insn, else it may end up in a REG_EQUAL note 		       and "escape" to cause problems elsewhere.  */
return|return
name|gen_rtx_CONST
argument_list|(
name|GET_MODE
argument_list|(
name|new
argument_list|)
argument_list|,
name|new
argument_list|)
return|;
block|}
block|}
block|}
return|return
name|x
return|;
block|}
ifdef|#
directive|ifdef
name|NO_FUNCTION_CSE
case|case
name|CALL
case|:
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|x
return|;
break|break;
endif|#
directive|endif
case|case
name|ASM_OPERANDS
case|:
for|for
control|(
name|i
operator|=
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|x
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|ASM_OPERANDS_INPUT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|fold_rtx
argument_list|(
name|ASM_OPERANDS_INPUT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|const_arg0
operator|=
literal|0
expr_stmt|;
name|const_arg1
operator|=
literal|0
expr_stmt|;
name|const_arg2
operator|=
literal|0
expr_stmt|;
name|mode_arg0
operator|=
name|VOIDmode
expr_stmt|;
comment|/* Try folding our operands.      Then see which ones have constant values known.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
name|rtx
name|arg
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|rtx
name|folded_arg
init|=
name|arg
decl_stmt|,
name|const_arg
init|=
literal|0
decl_stmt|;
name|enum
name|machine_mode
name|mode_arg
init|=
name|GET_MODE
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|rtx
name|cheap_arg
decl_stmt|,
name|expensive_arg
decl_stmt|;
name|rtx
name|replacements
index|[
literal|2
index|]
decl_stmt|;
name|int
name|j
decl_stmt|;
name|int
name|old_cost
init|=
name|COST_IN
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|code
argument_list|)
decl_stmt|;
comment|/* Most arguments are cheap, so handle them specially.  */
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|arg
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
comment|/* This is the same as calling equiv_constant; it is duplicated 	       here for speed.  */
if|if
condition|(
name|REGNO_QTY_VALID_P
argument_list|(
name|REGNO
argument_list|(
name|arg
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|arg_q
init|=
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|arg
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|qty_table_elem
modifier|*
name|arg_ent
init|=
operator|&
name|qty_table
index|[
name|arg_q
index|]
decl_stmt|;
if|if
condition|(
name|arg_ent
operator|->
name|const_rtx
operator|!=
name|NULL_RTX
operator|&&
name|GET_CODE
argument_list|(
name|arg_ent
operator|->
name|const_rtx
argument_list|)
operator|!=
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|arg_ent
operator|->
name|const_rtx
argument_list|)
operator|!=
name|PLUS
condition|)
name|const_arg
operator|=
name|gen_lowpart_if_possible
argument_list|(
name|GET_MODE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|arg_ent
operator|->
name|const_rtx
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CONST
case|:
case|case
name|CONST_INT
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_VECTOR
case|:
name|const_arg
operator|=
name|arg
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|HAVE_cc0
case|case
name|CC0
case|:
name|folded_arg
operator|=
name|prev_insn_cc0
expr_stmt|;
name|mode_arg
operator|=
name|prev_insn_cc0_mode
expr_stmt|;
name|const_arg
operator|=
name|equiv_constant
argument_list|(
name|folded_arg
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|folded_arg
operator|=
name|fold_rtx
argument_list|(
name|arg
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|const_arg
operator|=
name|equiv_constant
argument_list|(
name|folded_arg
argument_list|)
expr_stmt|;
block|}
comment|/* For the first three operands, see if the operand 	   is constant or equivalent to a constant.  */
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|0
case|:
name|folded_arg0
operator|=
name|folded_arg
expr_stmt|;
name|const_arg0
operator|=
name|const_arg
expr_stmt|;
name|mode_arg0
operator|=
name|mode_arg
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|folded_arg1
operator|=
name|folded_arg
expr_stmt|;
name|const_arg1
operator|=
name|const_arg
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|const_arg2
operator|=
name|const_arg
expr_stmt|;
break|break;
block|}
comment|/* Pick the least expensive of the folded argument and an 	   equivalent constant argument.  */
if|if
condition|(
name|const_arg
operator|==
literal|0
operator|||
name|const_arg
operator|==
name|folded_arg
operator|||
name|COST_IN
argument_list|(
name|const_arg
argument_list|,
name|code
argument_list|)
operator|>
name|COST_IN
argument_list|(
name|folded_arg
argument_list|,
name|code
argument_list|)
condition|)
name|cheap_arg
operator|=
name|folded_arg
operator|,
name|expensive_arg
operator|=
name|const_arg
expr_stmt|;
else|else
name|cheap_arg
operator|=
name|const_arg
operator|,
name|expensive_arg
operator|=
name|folded_arg
expr_stmt|;
comment|/* Try to replace the operand with the cheapest of the two 	   possibilities.  If it doesn't work and this is either of the first 	   two operands of a commutative operation, try swapping them. 	   If THAT fails, try the more expensive, provided it is cheaper 	   than what is already there.  */
if|if
condition|(
name|cheap_arg
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|insn
operator|==
literal|0
operator|&&
operator|!
name|copied
condition|)
block|{
name|x
operator|=
name|copy_rtx
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|copied
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Order the replacements from cheapest to most expensive.  */
name|replacements
index|[
literal|0
index|]
operator|=
name|cheap_arg
expr_stmt|;
name|replacements
index|[
literal|1
index|]
operator|=
name|expensive_arg
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|2
operator|&&
name|replacements
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
block|{
name|int
name|new_cost
init|=
name|COST_IN
argument_list|(
name|replacements
index|[
name|j
index|]
argument_list|,
name|code
argument_list|)
decl_stmt|;
comment|/* Stop if what existed before was cheaper.  Prefer constants 	       in the case of a tie.  */
if|if
condition|(
name|new_cost
operator|>
name|old_cost
operator|||
operator|(
name|new_cost
operator|==
name|old_cost
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
operator|)
condition|)
break|break;
comment|/* It's not safe to substitute the operand of a conversion 	       operator with a constant, as the conversion's identity 	       depends upon the mode of it's operand.  This optimization 	       is handled by the call to simplify_unary_operation.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'1'
operator|&&
name|GET_MODE
argument_list|(
name|replacements
index|[
name|j
index|]
argument_list|)
operator|!=
name|mode_arg0
operator|&&
operator|(
name|code
operator|==
name|ZERO_EXTEND
operator|||
name|code
operator|==
name|SIGN_EXTEND
operator|||
name|code
operator|==
name|TRUNCATE
operator|||
name|code
operator|==
name|FLOAT_TRUNCATE
operator|||
name|code
operator|==
name|FLOAT_EXTEND
operator|||
name|code
operator|==
name|FLOAT
operator|||
name|code
operator|==
name|FIX
operator|||
name|code
operator|==
name|UNSIGNED_FLOAT
operator|||
name|code
operator|==
name|UNSIGNED_FIX
operator|)
condition|)
continue|continue;
if|if
condition|(
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|replacements
index|[
name|j
index|]
argument_list|,
literal|0
argument_list|)
condition|)
break|break;
if|if
condition|(
name|code
operator|==
name|NE
operator|||
name|code
operator|==
name|EQ
operator|||
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'c'
operator|||
name|code
operator|==
name|LTGT
operator|||
name|code
operator|==
name|UNEQ
operator|||
name|code
operator|==
name|ORDERED
operator|||
name|code
operator|==
name|UNORDERED
condition|)
block|{
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
operator|-
name|i
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
operator|-
name|i
argument_list|)
argument_list|,
name|replacements
index|[
name|j
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|apply_change_group
argument_list|()
condition|)
block|{
comment|/* Swap them back to be invalid so that this loop can 		       continue and flag them to be swapped back later.  */
name|rtx
name|tem
decl_stmt|;
name|tem
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|=
name|tem
expr_stmt|;
name|must_swap
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
comment|/* Don't try to fold inside of a vector of expressions. 	     Doing nothing is harmless.  */
block|{
empty_stmt|;
block|}
block|}
comment|/* If a commutative operation, place a constant integer as the second      operand unless the first operand is also a constant integer.  Otherwise,      place any constant second unless the first operand is also a constant.  */
if|if
condition|(
name|code
operator|==
name|EQ
operator|||
name|code
operator|==
name|NE
operator|||
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'c'
operator|||
name|code
operator|==
name|LTGT
operator|||
name|code
operator|==
name|UNEQ
operator|||
name|code
operator|==
name|ORDERED
operator|||
name|code
operator|==
name|UNORDERED
condition|)
block|{
if|if
condition|(
name|must_swap
operator|||
name|swap_commutative_operands_p
argument_list|(
name|const_arg0
condition|?
name|const_arg0
else|:
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|const_arg1
condition|?
name|const_arg1
else|:
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|tem
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|insn
operator|==
literal|0
operator|&&
operator|!
name|copied
condition|)
block|{
name|x
operator|=
name|copy_rtx
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|copied
operator|=
literal|1
expr_stmt|;
block|}
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|tem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|apply_change_group
argument_list|()
condition|)
block|{
name|tem
operator|=
name|const_arg0
operator|,
name|const_arg0
operator|=
name|const_arg1
operator|,
name|const_arg1
operator|=
name|tem
expr_stmt|;
name|tem
operator|=
name|folded_arg0
operator|,
name|folded_arg0
operator|=
name|folded_arg1
operator|,
name|folded_arg1
operator|=
name|tem
expr_stmt|;
block|}
block|}
block|}
comment|/* If X is an arithmetic operation, see if we can simplify it.  */
switch|switch
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
literal|'1'
case|:
block|{
name|int
name|is_const
init|=
literal|0
decl_stmt|;
comment|/* We can't simplify extension ops unless we know the 	   original mode.  */
if|if
condition|(
operator|(
name|code
operator|==
name|ZERO_EXTEND
operator|||
name|code
operator|==
name|SIGN_EXTEND
operator|)
operator|&&
name|mode_arg0
operator|==
name|VOIDmode
condition|)
break|break;
comment|/* If we had a CONST, strip it off and put it back later if we 	   fold.  */
if|if
condition|(
name|const_arg0
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|const_arg0
argument_list|)
operator|==
name|CONST
condition|)
name|is_const
operator|=
literal|1
operator|,
name|const_arg0
operator|=
name|XEXP
argument_list|(
name|const_arg0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|new
operator|=
name|simplify_unary_operation
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|const_arg0
condition|?
name|const_arg0
else|:
name|folded_arg0
argument_list|,
name|mode_arg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|!=
literal|0
operator|&&
name|is_const
condition|)
name|new
operator|=
name|gen_rtx_CONST
argument_list|(
name|mode
argument_list|,
name|new
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'<'
case|:
comment|/* Don't perform any simplifications of vector mode comparisons.  */
if|if
condition|(
name|VECTOR_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
break|break;
comment|/* See what items are actually being compared and set FOLDED_ARG[01] 	 to those values and CODE to the actual comparison code.  If any are 	 constant, set CONST_ARG0 and CONST_ARG1 appropriately.  We needn't 	 do anything if both operands are already known to be constant.  */
if|if
condition|(
name|const_arg0
operator|==
literal|0
operator|||
name|const_arg1
operator|==
literal|0
condition|)
block|{
name|struct
name|table_elt
modifier|*
name|p0
decl_stmt|,
modifier|*
name|p1
decl_stmt|;
name|rtx
name|true_rtx
init|=
name|const_true_rtx
decl_stmt|,
name|false_rtx
init|=
name|const0_rtx
decl_stmt|;
name|enum
name|machine_mode
name|mode_arg1
decl_stmt|;
ifdef|#
directive|ifdef
name|FLOAT_STORE_FLAG_VALUE
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
block|{
name|true_rtx
operator|=
operator|(
name|CONST_DOUBLE_FROM_REAL_VALUE
argument_list|(
name|FLOAT_STORE_FLAG_VALUE
argument_list|(
name|mode
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|)
expr_stmt|;
name|false_rtx
operator|=
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|code
operator|=
name|find_comparison_args
argument_list|(
name|code
argument_list|,
operator|&
name|folded_arg0
argument_list|,
operator|&
name|folded_arg1
argument_list|,
operator|&
name|mode_arg0
argument_list|,
operator|&
name|mode_arg1
argument_list|)
expr_stmt|;
name|const_arg0
operator|=
name|equiv_constant
argument_list|(
name|folded_arg0
argument_list|)
expr_stmt|;
name|const_arg1
operator|=
name|equiv_constant
argument_list|(
name|folded_arg1
argument_list|)
expr_stmt|;
comment|/* If the mode is VOIDmode or a MODE_CC mode, we don't know 	     what kinds of things are being compared, so we can't do 	     anything with this comparison.  */
if|if
condition|(
name|mode_arg0
operator|==
name|VOIDmode
operator|||
name|GET_MODE_CLASS
argument_list|(
name|mode_arg0
argument_list|)
operator|==
name|MODE_CC
condition|)
break|break;
comment|/* If we do not now have two constants being compared, see 	     if we can nevertheless deduce some things about the 	     comparison.  */
if|if
condition|(
name|const_arg0
operator|==
literal|0
operator|||
name|const_arg1
operator|==
literal|0
condition|)
block|{
comment|/* Some addresses are known to be nonzero.  We don't know 		 their sign, but equality comparisons are known.  */
if|if
condition|(
name|const_arg1
operator|==
name|const0_rtx
operator|&&
name|nonzero_address_p
argument_list|(
name|folded_arg0
argument_list|)
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|EQ
condition|)
return|return
name|false_rtx
return|;
elseif|else
if|if
condition|(
name|code
operator|==
name|NE
condition|)
return|return
name|true_rtx
return|;
block|}
comment|/* See if the two operands are the same.  */
if|if
condition|(
name|folded_arg0
operator|==
name|folded_arg1
operator|||
operator|(
name|GET_CODE
argument_list|(
name|folded_arg0
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|folded_arg1
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|folded_arg0
argument_list|)
argument_list|)
operator|==
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|folded_arg1
argument_list|)
argument_list|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|p0
operator|=
name|lookup
argument_list|(
name|folded_arg0
argument_list|,
operator|(
name|safe_hash
argument_list|(
name|folded_arg0
argument_list|,
name|mode_arg0
argument_list|)
operator|&
name|HASH_MASK
operator|)
argument_list|,
name|mode_arg0
argument_list|)
operator|)
operator|&&
operator|(
name|p1
operator|=
name|lookup
argument_list|(
name|folded_arg1
argument_list|,
operator|(
name|safe_hash
argument_list|(
name|folded_arg1
argument_list|,
name|mode_arg0
argument_list|)
operator|&
name|HASH_MASK
operator|)
argument_list|,
name|mode_arg0
argument_list|)
operator|)
operator|&&
name|p0
operator|->
name|first_same_value
operator|==
name|p1
operator|->
name|first_same_value
operator|)
condition|)
block|{
comment|/* Sadly two equal NaNs are not equivalent.  */
if|if
condition|(
operator|!
name|HONOR_NANS
argument_list|(
name|mode_arg0
argument_list|)
condition|)
return|return
operator|(
operator|(
name|code
operator|==
name|EQ
operator|||
name|code
operator|==
name|LE
operator|||
name|code
operator|==
name|GE
operator|||
name|code
operator|==
name|LEU
operator|||
name|code
operator|==
name|GEU
operator|||
name|code
operator|==
name|UNEQ
operator|||
name|code
operator|==
name|UNLE
operator|||
name|code
operator|==
name|UNGE
operator|||
name|code
operator|==
name|ORDERED
operator|)
condition|?
name|true_rtx
else|:
name|false_rtx
operator|)
return|;
comment|/* Take care for the FP compares we can resolve.  */
if|if
condition|(
name|code
operator|==
name|UNEQ
operator|||
name|code
operator|==
name|UNLE
operator|||
name|code
operator|==
name|UNGE
condition|)
return|return
name|true_rtx
return|;
if|if
condition|(
name|code
operator|==
name|LTGT
operator|||
name|code
operator|==
name|LT
operator|||
name|code
operator|==
name|GT
condition|)
return|return
name|false_rtx
return|;
block|}
comment|/* If FOLDED_ARG0 is a register, see if the comparison we are 		 doing now is either the same as we did before or the reverse 		 (we only check the reverse if not floating-point).  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|folded_arg0
argument_list|)
operator|==
name|REG
condition|)
block|{
name|int
name|qty
init|=
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|folded_arg0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|REGNO_QTY_VALID_P
argument_list|(
name|REGNO
argument_list|(
name|folded_arg0
argument_list|)
argument_list|)
condition|)
block|{
name|struct
name|qty_table_elem
modifier|*
name|ent
init|=
operator|&
name|qty_table
index|[
name|qty
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|comparison_dominates_p
argument_list|(
name|ent
operator|->
name|comparison_code
argument_list|,
name|code
argument_list|)
operator|||
operator|(
operator|!
name|FLOAT_MODE_P
argument_list|(
name|mode_arg0
argument_list|)
operator|&&
name|comparison_dominates_p
argument_list|(
name|ent
operator|->
name|comparison_code
argument_list|,
name|reverse_condition
argument_list|(
name|code
argument_list|)
argument_list|)
operator|)
operator|)
operator|&&
operator|(
name|rtx_equal_p
argument_list|(
name|ent
operator|->
name|comparison_const
argument_list|,
name|folded_arg1
argument_list|)
operator|||
operator|(
name|const_arg1
operator|&&
name|rtx_equal_p
argument_list|(
name|ent
operator|->
name|comparison_const
argument_list|,
name|const_arg1
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|folded_arg1
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|folded_arg1
argument_list|)
argument_list|)
operator|==
name|ent
operator|->
name|comparison_qty
operator|)
operator|)
operator|)
condition|)
return|return
operator|(
name|comparison_dominates_p
argument_list|(
name|ent
operator|->
name|comparison_code
argument_list|,
name|code
argument_list|)
condition|?
name|true_rtx
else|:
name|false_rtx
operator|)
return|;
block|}
block|}
block|}
block|}
comment|/* If we are comparing against zero, see if the first operand is 	 equivalent to an IOR with a constant.  If so, we may be able to 	 determine the result of this comparison.  */
if|if
condition|(
name|const_arg1
operator|==
name|const0_rtx
condition|)
block|{
name|rtx
name|y
init|=
name|lookup_as_function
argument_list|(
name|folded_arg0
argument_list|,
name|IOR
argument_list|)
decl_stmt|;
name|rtx
name|inner_const
decl_stmt|;
if|if
condition|(
name|y
operator|!=
literal|0
operator|&&
operator|(
name|inner_const
operator|=
name|equiv_constant
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|inner_const
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|inner_const
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|int
name|sign_bitnum
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode_arg0
argument_list|)
operator|-
literal|1
decl_stmt|;
name|int
name|has_sign
init|=
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|>=
name|sign_bitnum
operator|&&
operator|(
name|INTVAL
argument_list|(
name|inner_const
argument_list|)
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|sign_bitnum
operator|)
operator|)
operator|)
decl_stmt|;
name|rtx
name|true_rtx
init|=
name|const_true_rtx
decl_stmt|,
name|false_rtx
init|=
name|const0_rtx
decl_stmt|;
ifdef|#
directive|ifdef
name|FLOAT_STORE_FLAG_VALUE
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
block|{
name|true_rtx
operator|=
operator|(
name|CONST_DOUBLE_FROM_REAL_VALUE
argument_list|(
name|FLOAT_STORE_FLAG_VALUE
argument_list|(
name|mode
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|)
expr_stmt|;
name|false_rtx
operator|=
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ
case|:
return|return
name|false_rtx
return|;
case|case
name|NE
case|:
return|return
name|true_rtx
return|;
case|case
name|LT
case|:
case|case
name|LE
case|:
if|if
condition|(
name|has_sign
condition|)
return|return
name|true_rtx
return|;
break|break;
case|case
name|GT
case|:
case|case
name|GE
case|:
if|if
condition|(
name|has_sign
condition|)
return|return
name|false_rtx
return|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
name|new
operator|=
name|simplify_relational_operation
argument_list|(
name|code
argument_list|,
operator|(
name|mode_arg0
operator|!=
name|VOIDmode
condition|?
name|mode_arg0
else|:
operator|(
name|GET_MODE
argument_list|(
name|const_arg0
condition|?
name|const_arg0
else|:
name|folded_arg0
argument_list|)
operator|!=
name|VOIDmode
operator|)
condition|?
name|GET_MODE
argument_list|(
name|const_arg0
condition|?
name|const_arg0
else|:
name|folded_arg0
argument_list|)
else|:
name|GET_MODE
argument_list|(
name|const_arg1
condition|?
name|const_arg1
else|:
name|folded_arg1
argument_list|)
operator|)
argument_list|,
name|const_arg0
condition|?
name|const_arg0
else|:
name|folded_arg0
argument_list|,
name|const_arg1
condition|?
name|const_arg1
else|:
name|folded_arg1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FLOAT_STORE_FLAG_VALUE
if|if
condition|(
name|new
operator|!=
literal|0
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
block|{
if|if
condition|(
name|new
operator|==
name|const0_rtx
condition|)
name|new
operator|=
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
expr_stmt|;
else|else
name|new
operator|=
operator|(
name|CONST_DOUBLE_FROM_REAL_VALUE
argument_list|(
name|FLOAT_STORE_FLAG_VALUE
argument_list|(
name|mode
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
case|case
literal|'2'
case|:
case|case
literal|'c'
case|:
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS
case|:
comment|/* If the second operand is a LABEL_REF, see if the first is a MINUS 	     with that LABEL_REF as its second operand.  If so, the result is 	     the first operand of that MINUS.  This handles switches with an 	     ADDR_DIFF_VEC table.  */
if|if
condition|(
name|const_arg1
operator|&&
name|GET_CODE
argument_list|(
name|const_arg1
argument_list|)
operator|==
name|LABEL_REF
condition|)
block|{
name|rtx
name|y
init|=
name|GET_CODE
argument_list|(
name|folded_arg0
argument_list|)
operator|==
name|MINUS
condition|?
name|folded_arg0
else|:
name|lookup_as_function
argument_list|(
name|folded_arg0
argument_list|,
name|MINUS
argument_list|)
decl_stmt|;
if|if
condition|(
name|y
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|XEXP
argument_list|(
name|const_arg1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
return|;
comment|/* Now try for a CONST of a MINUS like the above.  */
if|if
condition|(
operator|(
name|y
operator|=
operator|(
name|GET_CODE
argument_list|(
name|folded_arg0
argument_list|)
operator|==
name|CONST
condition|?
name|folded_arg0
else|:
name|lookup_as_function
argument_list|(
name|folded_arg0
argument_list|,
name|CONST
argument_list|)
operator|)
operator|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MINUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|XEXP
argument_list|(
name|const_arg1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/* Likewise if the operands are in the other order.  */
if|if
condition|(
name|const_arg0
operator|&&
name|GET_CODE
argument_list|(
name|const_arg0
argument_list|)
operator|==
name|LABEL_REF
condition|)
block|{
name|rtx
name|y
init|=
name|GET_CODE
argument_list|(
name|folded_arg1
argument_list|)
operator|==
name|MINUS
condition|?
name|folded_arg1
else|:
name|lookup_as_function
argument_list|(
name|folded_arg1
argument_list|,
name|MINUS
argument_list|)
decl_stmt|;
if|if
condition|(
name|y
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|XEXP
argument_list|(
name|const_arg0
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
return|;
comment|/* Now try for a CONST of a MINUS like the above.  */
if|if
condition|(
operator|(
name|y
operator|=
operator|(
name|GET_CODE
argument_list|(
name|folded_arg1
argument_list|)
operator|==
name|CONST
condition|?
name|folded_arg1
else|:
name|lookup_as_function
argument_list|(
name|folded_arg1
argument_list|,
name|CONST
argument_list|)
operator|)
operator|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MINUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|XEXP
argument_list|(
name|const_arg0
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/* If second operand is a register equivalent to a negative 	     CONST_INT, see if we can find a register equivalent to the 	     positive constant.  Make a MINUS if so.  Don't do this for 	     a non-negative constant since we might then alternate between 	     choosing positive and negative constants.  Having the positive 	     constant previously-used is the more common case.  Be sure 	     the resulting constant is non-negative; if const_arg1 were 	     the smallest negative number this would overflow: depending 	     on the mode, this would either just be the same value (and 	     hence not save anything) or be incorrect.  */
if|if
condition|(
name|const_arg1
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|const_arg1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|const_arg1
argument_list|)
operator|<
literal|0
comment|/* This used to test  	         -INTVAL (const_arg1)>= 0  		 But The Sun V5.0 compilers mis-compiled that test.  So 		 instead we test for the problematic value in a more direct 		 manner and hope the Sun compilers get it correct.  */
operator|&&
name|INTVAL
argument_list|(
name|const_arg1
argument_list|)
operator|!=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|folded_arg1
argument_list|)
operator|==
name|REG
condition|)
block|{
name|rtx
name|new_const
init|=
name|GEN_INT
argument_list|(
operator|-
name|INTVAL
argument_list|(
name|const_arg1
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|table_elt
modifier|*
name|p
init|=
name|lookup
argument_list|(
name|new_const
argument_list|,
name|safe_hash
argument_list|(
name|new_const
argument_list|,
name|mode
argument_list|)
operator|&
name|HASH_MASK
argument_list|,
name|mode
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
condition|)
for|for
control|(
name|p
operator|=
name|p
operator|->
name|first_same_value
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next_same_value
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
operator|->
name|exp
argument_list|)
operator|==
name|REG
condition|)
return|return
name|simplify_gen_binary
argument_list|(
name|MINUS
argument_list|,
name|mode
argument_list|,
name|folded_arg0
argument_list|,
name|canon_reg
argument_list|(
name|p
operator|->
name|exp
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|)
return|;
block|}
goto|goto
name|from_plus
goto|;
case|case
name|MINUS
case|:
comment|/* If we have (MINUS Y C), see if Y is known to be (PLUS Z C2). 	     If so, produce (PLUS Z C2-C).  */
if|if
condition|(
name|const_arg1
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|const_arg1
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|rtx
name|y
init|=
name|lookup_as_function
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|PLUS
argument_list|)
decl_stmt|;
if|if
condition|(
name|y
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|fold_rtx
argument_list|(
name|plus_constant
argument_list|(
name|copy_rtx
argument_list|(
name|y
argument_list|)
argument_list|,
operator|-
name|INTVAL
argument_list|(
name|const_arg1
argument_list|)
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
return|;
block|}
comment|/* Fall through.  */
name|from_plus
label|:
case|case
name|SMIN
case|:
case|case
name|SMAX
case|:
case|case
name|UMIN
case|:
case|case
name|UMAX
case|:
case|case
name|IOR
case|:
case|case
name|AND
case|:
case|case
name|XOR
case|:
case|case
name|MULT
case|:
case|case
name|ASHIFT
case|:
case|case
name|LSHIFTRT
case|:
case|case
name|ASHIFTRT
case|:
comment|/* If we have (<op><reg><const_int>) for an associative OP and REG 	     is known to be of similar form, we may be able to replace the 	     operation with a combined operation.  This may eliminate the 	     intermediate operation if every use is simplified in this way. 	     Note that the similar optimization done by combine.c only works 	     if the intermediate operation's result has only one reference.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|folded_arg0
argument_list|)
operator|==
name|REG
operator|&&
name|const_arg1
operator|&&
name|GET_CODE
argument_list|(
name|const_arg1
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|int
name|is_shift
init|=
operator|(
name|code
operator|==
name|ASHIFT
operator|||
name|code
operator|==
name|ASHIFTRT
operator|||
name|code
operator|==
name|LSHIFTRT
operator|)
decl_stmt|;
name|rtx
name|y
init|=
name|lookup_as_function
argument_list|(
name|folded_arg0
argument_list|,
name|code
argument_list|)
decl_stmt|;
name|rtx
name|inner_const
decl_stmt|;
name|enum
name|rtx_code
name|associate_code
decl_stmt|;
name|rtx
name|new_const
decl_stmt|;
if|if
condition|(
name|y
operator|==
literal|0
operator|||
literal|0
operator|==
operator|(
name|inner_const
operator|=
name|equiv_constant
argument_list|(
name|fold_rtx
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|inner_const
argument_list|)
operator|!=
name|CONST_INT
comment|/* If we have compiled a statement like 		     "if (x == (x& mask1))", and now are looking at 		     "x& mask2", we will have a case where the first operand 		     of Y is the same as our first operand.  Unless we detect 		     this case, an infinite loop will result.  */
operator|||
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
operator|==
name|folded_arg0
condition|)
break|break;
comment|/* Don't associate these operations if they are a PLUS with the 		 same constant and it is a power of two.  These might be doable 		 with a pre- or post-increment.  Similarly for two subtracts of 		 identical powers of two with post decrement.  */
if|if
condition|(
name|code
operator|==
name|PLUS
operator|&&
name|const_arg1
operator|==
name|inner_const
operator|&&
operator|(
operator|(
name|HAVE_PRE_INCREMENT
operator|&&
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|const_arg1
argument_list|)
argument_list|)
operator|>=
literal|0
operator|)
operator|||
operator|(
name|HAVE_POST_INCREMENT
operator|&&
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|const_arg1
argument_list|)
argument_list|)
operator|>=
literal|0
operator|)
operator|||
operator|(
name|HAVE_PRE_DECREMENT
operator|&&
name|exact_log2
argument_list|(
operator|-
name|INTVAL
argument_list|(
name|const_arg1
argument_list|)
argument_list|)
operator|>=
literal|0
operator|)
operator|||
operator|(
name|HAVE_POST_DECREMENT
operator|&&
name|exact_log2
argument_list|(
operator|-
name|INTVAL
argument_list|(
name|const_arg1
argument_list|)
argument_list|)
operator|>=
literal|0
operator|)
operator|)
condition|)
break|break;
comment|/* Compute the code used to compose the constants.  For example, 		 A-C1-C2 is A-(C1 + C2), so if CODE == MINUS, we want PLUS.  */
name|associate_code
operator|=
operator|(
name|is_shift
operator|||
name|code
operator|==
name|MINUS
condition|?
name|PLUS
else|:
name|code
operator|)
expr_stmt|;
name|new_const
operator|=
name|simplify_binary_operation
argument_list|(
name|associate_code
argument_list|,
name|mode
argument_list|,
name|const_arg1
argument_list|,
name|inner_const
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_const
operator|==
literal|0
condition|)
break|break;
comment|/* If we are associating shift operations, don't let this 		 produce a shift of the size of the object or larger. 		 This could occur when we follow a sign-extend by a right 		 shift on a machine that does a sign-extend as a pair 		 of shifts.  */
if|if
condition|(
name|is_shift
operator|&&
name|GET_CODE
argument_list|(
name|new_const
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|new_const
argument_list|)
operator|>=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
condition|)
block|{
comment|/* As an exception, we can turn an ASHIFTRT of this 		     form into a shift of the number of bits - 1.  */
if|if
condition|(
name|code
operator|==
name|ASHIFTRT
condition|)
name|new_const
operator|=
name|GEN_INT
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
name|y
operator|=
name|copy_rtx
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If Y contains our first operand (the most common way this 		 can happen is if Y is a MEM), we would do into an infinite 		 loop if we tried to fold it.  So don't in that case.  */
if|if
condition|(
operator|!
name|reg_mentioned_p
argument_list|(
name|folded_arg0
argument_list|,
name|y
argument_list|)
condition|)
name|y
operator|=
name|fold_rtx
argument_list|(
name|y
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return
name|simplify_gen_binary
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|y
argument_list|,
name|new_const
argument_list|)
return|;
block|}
break|break;
case|case
name|DIV
case|:
case|case
name|UDIV
case|:
comment|/* ??? The associative optimization performed immediately above is 	     also possible for DIV and UDIV using associate_code of MULT. 	     However, we would need extra code to verify that the 	     multiplication does not overflow, that is, there is no overflow 	     in the calculation of new_const.  */
break|break;
default|default:
break|break;
block|}
name|new
operator|=
name|simplify_binary_operation
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|const_arg0
condition|?
name|const_arg0
else|:
name|folded_arg0
argument_list|,
name|const_arg1
condition|?
name|const_arg1
else|:
name|folded_arg1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
comment|/* (lo_sum (high X) X) is simply X.  */
if|if
condition|(
name|code
operator|==
name|LO_SUM
operator|&&
name|const_arg0
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|const_arg0
argument_list|)
operator|==
name|HIGH
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|const_arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|const_arg1
argument_list|)
condition|)
return|return
name|const_arg1
return|;
break|break;
case|case
literal|'3'
case|:
case|case
literal|'b'
case|:
name|new
operator|=
name|simplify_ternary_operation
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|mode_arg0
argument_list|,
name|const_arg0
condition|?
name|const_arg0
else|:
name|folded_arg0
argument_list|,
name|const_arg1
condition|?
name|const_arg1
else|:
name|folded_arg1
argument_list|,
name|const_arg2
condition|?
name|const_arg2
else|:
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
comment|/* Eliminate CONSTANT_P_RTX if its constant.  */
if|if
condition|(
name|code
operator|==
name|CONSTANT_P_RTX
condition|)
block|{
if|if
condition|(
name|const_arg0
condition|)
return|return
name|const1_rtx
return|;
if|if
condition|(
name|optimize
operator|==
literal|0
operator|||
operator|!
name|flag_gcse
condition|)
return|return
name|const0_rtx
return|;
block|}
break|break;
block|}
return|return
name|new
condition|?
name|new
else|:
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a constant value currently equivalent to X.    Return 0 if we don't know one.  */
end_comment

begin_function
specifier|static
name|rtx
name|equiv_constant
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO_QTY_VALID_P
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|x_q
init|=
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|qty_table_elem
modifier|*
name|x_ent
init|=
operator|&
name|qty_table
index|[
name|x_q
index|]
decl_stmt|;
if|if
condition|(
name|x_ent
operator|->
name|const_rtx
condition|)
name|x
operator|=
name|gen_lowpart_if_possible
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|x_ent
operator|->
name|const_rtx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|x
operator|==
literal|0
operator|||
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|x
return|;
comment|/* If X is a MEM, try to fold it outside the context of any insn to see if      it might be equivalent to a constant.  That handles the case where it      is a constant-pool reference.  Then try to look it up in the hash table      in case it is something whose value we have seen before.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|struct
name|table_elt
modifier|*
name|elt
decl_stmt|;
name|x
operator|=
name|fold_rtx
argument_list|(
name|x
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|x
return|;
name|elt
operator|=
name|lookup
argument_list|(
name|x
argument_list|,
name|safe_hash
argument_list|(
name|x
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&
name|HASH_MASK
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|elt
operator|==
literal|0
condition|)
return|return
literal|0
return|;
for|for
control|(
name|elt
operator|=
name|elt
operator|->
name|first_same_value
init|;
name|elt
condition|;
name|elt
operator|=
name|elt
operator|->
name|next_same_value
control|)
if|if
condition|(
name|elt
operator|->
name|is_const
operator|&&
name|CONSTANT_P
argument_list|(
name|elt
operator|->
name|exp
argument_list|)
condition|)
return|return
name|elt
operator|->
name|exp
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Assuming that X is an rtx (e.g., MEM, REG or SUBREG) for a fixed-point    number, return an rtx (MEM, SUBREG, or CONST_INT) that refers to the    least-significant part of X.    MODE specifies how big a part of X to return.     If the requested operation cannot be done, 0 is returned.     This is similar to gen_lowpart in emit-rtl.c.  */
end_comment

begin_function
name|rtx
name|gen_lowpart_if_possible
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|x
parameter_list|)
block|{
name|rtx
name|result
init|=
name|gen_lowpart_common
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
condition|)
return|return
name|result
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
block|{
comment|/* This is the only other case we handle.  */
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|rtx
name|new
decl_stmt|;
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
name|offset
operator|=
operator|(
name|MAX
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|UNITS_PER_WORD
argument_list|)
operator|-
name|MAX
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
name|UNITS_PER_WORD
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
comment|/* Adjust the address so that the address-after-the-data is 	   unchanged.  */
name|offset
operator|-=
operator|(
name|MIN
argument_list|(
name|UNITS_PER_WORD
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
operator|-
name|MIN
argument_list|(
name|UNITS_PER_WORD
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|new
operator|=
name|adjust_address_nv
argument_list|(
name|x
argument_list|,
name|mode
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|new
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|new
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given INSN, a jump insn, TAKEN indicates if we are following the "taken"    branch.  It will be zero if not.     In certain cases, this can cause us to add an equivalence.  For example,    if we are following the taken case of 	if (i == 2)    we can add the fact that `i' and '2' are now equivalent.     In any case, we can record that this comparison was passed.  If the same    comparison is seen later, we will know its value.  */
end_comment

begin_function
specifier|static
name|void
name|record_jump_equiv
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|int
name|taken
parameter_list|)
block|{
name|int
name|cond_known_true
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
name|rtx
name|set
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|,
name|mode0
decl_stmt|,
name|mode1
decl_stmt|;
name|int
name|reversed_nonequality
init|=
literal|0
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
comment|/* Ensure this is the right kind of insn.  */
if|if
condition|(
operator|!
name|any_condjump_p
argument_list|(
name|insn
argument_list|)
condition|)
return|return;
name|set
operator|=
name|pc_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* See if this jump condition is known true or false.  */
if|if
condition|(
name|taken
condition|)
name|cond_known_true
operator|=
operator|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|2
argument_list|)
operator|==
name|pc_rtx
operator|)
expr_stmt|;
else|else
name|cond_known_true
operator|=
operator|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|pc_rtx
operator|)
expr_stmt|;
comment|/* Get the type of comparison being done and the operands being compared.      If we had to reverse a non-equality condition, record that fact so we      know that it isn't valid for floating-point.  */
name|code
operator|=
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|fold_rtx
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|op1
operator|=
name|fold_rtx
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|code
operator|=
name|find_comparison_args
argument_list|(
name|code
argument_list|,
operator|&
name|op0
argument_list|,
operator|&
name|op1
argument_list|,
operator|&
name|mode0
argument_list|,
operator|&
name|mode1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cond_known_true
condition|)
block|{
name|code
operator|=
name|reversed_comparison_code_parts
argument_list|(
name|code
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Don't remember if we can't find the inverse.  */
if|if
condition|(
name|code
operator|==
name|UNKNOWN
condition|)
return|return;
block|}
comment|/* The mode is the mode of the non-constant.  */
name|mode
operator|=
name|mode0
expr_stmt|;
if|if
condition|(
name|mode1
operator|!=
name|VOIDmode
condition|)
name|mode
operator|=
name|mode1
expr_stmt|;
name|record_jump_cond
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|reversed_nonequality
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We know that comparison CODE applied to OP0 and OP1 in MODE is true.    REVERSED_NONEQUALITY is nonzero if CODE had to be swapped.    Make any useful entries we can with that information.  Called from    above function and called recursively.  */
end_comment

begin_function
specifier|static
name|void
name|record_jump_cond
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|,
name|int
name|reversed_nonequality
parameter_list|)
block|{
name|unsigned
name|op0_hash
decl_stmt|,
name|op1_hash
decl_stmt|;
name|int
name|op0_in_memory
decl_stmt|,
name|op1_in_memory
decl_stmt|;
name|struct
name|table_elt
modifier|*
name|op0_elt
decl_stmt|,
modifier|*
name|op1_elt
decl_stmt|;
comment|/* If OP0 and OP1 are known equal, and either is a paradoxical SUBREG,      we know that they are also equal in the smaller mode (this is also      true for all smaller modes whether or not there is a SUBREG, but      is not worth testing for with no SUBREG).  */
comment|/* Note that GET_MODE (op0) may not equal MODE.  */
if|if
condition|(
name|code
operator|==
name|EQ
operator|&&
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op0
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|enum
name|machine_mode
name|inner_mode
init|=
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op0
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|tem
init|=
name|gen_lowpart_if_possible
argument_list|(
name|inner_mode
argument_list|,
name|op1
argument_list|)
decl_stmt|;
name|record_jump_cond
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|SUBREG_REG
argument_list|(
name|op0
argument_list|)
argument_list|,
name|tem
condition|?
name|tem
else|:
name|gen_rtx_SUBREG
argument_list|(
name|inner_mode
argument_list|,
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|reversed_nonequality
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
name|EQ
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op1
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|enum
name|machine_mode
name|inner_mode
init|=
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op1
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|tem
init|=
name|gen_lowpart_if_possible
argument_list|(
name|inner_mode
argument_list|,
name|op0
argument_list|)
decl_stmt|;
name|record_jump_cond
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|SUBREG_REG
argument_list|(
name|op1
argument_list|)
argument_list|,
name|tem
condition|?
name|tem
else|:
name|gen_rtx_SUBREG
argument_list|(
name|inner_mode
argument_list|,
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|reversed_nonequality
argument_list|)
expr_stmt|;
block|}
comment|/* Similarly, if this is an NE comparison, and either is a SUBREG      making a smaller mode, we know the whole thing is also NE.  */
comment|/* Note that GET_MODE (op0) may not equal MODE;      if we test MODE instead, we can get an infinite recursion      alternating between two modes each wider than MODE.  */
if|if
condition|(
name|code
operator|==
name|NE
operator|&&
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SUBREG
operator|&&
name|subreg_lowpart_p
argument_list|(
name|op0
argument_list|)
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op0
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|enum
name|machine_mode
name|inner_mode
init|=
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op0
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|tem
init|=
name|gen_lowpart_if_possible
argument_list|(
name|inner_mode
argument_list|,
name|op1
argument_list|)
decl_stmt|;
name|record_jump_cond
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|SUBREG_REG
argument_list|(
name|op0
argument_list|)
argument_list|,
name|tem
condition|?
name|tem
else|:
name|gen_rtx_SUBREG
argument_list|(
name|inner_mode
argument_list|,
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|reversed_nonequality
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
name|NE
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|SUBREG
operator|&&
name|subreg_lowpart_p
argument_list|(
name|op1
argument_list|)
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op1
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|enum
name|machine_mode
name|inner_mode
init|=
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op1
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|tem
init|=
name|gen_lowpart_if_possible
argument_list|(
name|inner_mode
argument_list|,
name|op0
argument_list|)
decl_stmt|;
name|record_jump_cond
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|SUBREG_REG
argument_list|(
name|op1
argument_list|)
argument_list|,
name|tem
condition|?
name|tem
else|:
name|gen_rtx_SUBREG
argument_list|(
name|inner_mode
argument_list|,
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|reversed_nonequality
argument_list|)
expr_stmt|;
block|}
comment|/* Hash both operands.  */
name|do_not_record
operator|=
literal|0
expr_stmt|;
name|hash_arg_in_memory
operator|=
literal|0
expr_stmt|;
name|op0_hash
operator|=
name|HASH
argument_list|(
name|op0
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|op0_in_memory
operator|=
name|hash_arg_in_memory
expr_stmt|;
if|if
condition|(
name|do_not_record
condition|)
return|return;
name|do_not_record
operator|=
literal|0
expr_stmt|;
name|hash_arg_in_memory
operator|=
literal|0
expr_stmt|;
name|op1_hash
operator|=
name|HASH
argument_list|(
name|op1
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|op1_in_memory
operator|=
name|hash_arg_in_memory
expr_stmt|;
if|if
condition|(
name|do_not_record
condition|)
return|return;
comment|/* Look up both operands.  */
name|op0_elt
operator|=
name|lookup
argument_list|(
name|op0
argument_list|,
name|op0_hash
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|op1_elt
operator|=
name|lookup
argument_list|(
name|op1
argument_list|,
name|op1_hash
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* If both operands are already equivalent or if they are not in the      table but are identical, do nothing.  */
if|if
condition|(
operator|(
name|op0_elt
operator|!=
literal|0
operator|&&
name|op1_elt
operator|!=
literal|0
operator|&&
name|op0_elt
operator|->
name|first_same_value
operator|==
name|op1_elt
operator|->
name|first_same_value
operator|)
operator|||
name|op0
operator|==
name|op1
operator|||
name|rtx_equal_p
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
condition|)
return|return;
comment|/* If we aren't setting two things equal all we can do is save this      comparison.   Similarly if this is floating-point.  In the latter      case, OP1 might be zero and both -0.0 and 0.0 are equal to it.      If we record the equality, we might inadvertently delete code      whose intent was to change -0 to +0.  */
if|if
condition|(
name|code
operator|!=
name|EQ
operator|||
name|FLOAT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
condition|)
block|{
name|struct
name|qty_table_elem
modifier|*
name|ent
decl_stmt|;
name|int
name|qty
decl_stmt|;
comment|/* If we reversed a floating-point comparison, if OP0 is not a 	 register, or if OP1 is neither a register or constant, we can't 	 do anything.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|REG
condition|)
name|op1
operator|=
name|equiv_constant
argument_list|(
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reversed_nonequality
operator|&&
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|REG
operator|||
name|op1
operator|==
literal|0
condition|)
return|return;
comment|/* Put OP0 in the hash table if it isn't already.  This gives it a 	 new quantity number.  */
if|if
condition|(
name|op0_elt
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|insert_regs
argument_list|(
name|op0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|rehash_using_reg
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|op0_hash
operator|=
name|HASH
argument_list|(
name|op0
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* If OP0 is contained in OP1, this changes its hash code 		 as well.  Faster to rehash than to check, except 		 for the simple case of a constant.  */
if|if
condition|(
operator|!
name|CONSTANT_P
argument_list|(
name|op1
argument_list|)
condition|)
name|op1_hash
operator|=
name|HASH
argument_list|(
name|op1
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
name|op0_elt
operator|=
name|insert
argument_list|(
name|op0
argument_list|,
name|NULL
argument_list|,
name|op0_hash
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|op0_elt
operator|->
name|in_memory
operator|=
name|op0_in_memory
expr_stmt|;
block|}
name|qty
operator|=
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
name|ent
operator|=
operator|&
name|qty_table
index|[
name|qty
index|]
expr_stmt|;
name|ent
operator|->
name|comparison_code
operator|=
name|code
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|REG
condition|)
block|{
comment|/* Look it up again--in case op0 and op1 are the same.  */
name|op1_elt
operator|=
name|lookup
argument_list|(
name|op1
argument_list|,
name|op1_hash
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* Put OP1 in the hash table so it gets a new quantity number.  */
if|if
condition|(
name|op1_elt
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|insert_regs
argument_list|(
name|op1
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|rehash_using_reg
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|op1_hash
operator|=
name|HASH
argument_list|(
name|op1
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
name|op1_elt
operator|=
name|insert
argument_list|(
name|op1
argument_list|,
name|NULL
argument_list|,
name|op1_hash
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|op1_elt
operator|->
name|in_memory
operator|=
name|op1_in_memory
expr_stmt|;
block|}
name|ent
operator|->
name|comparison_const
operator|=
name|NULL_RTX
expr_stmt|;
name|ent
operator|->
name|comparison_qty
operator|=
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|op1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ent
operator|->
name|comparison_const
operator|=
name|op1
expr_stmt|;
name|ent
operator|->
name|comparison_qty
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return;
block|}
comment|/* If either side is still missing an equivalence, make it now,      then merge the equivalences.  */
if|if
condition|(
name|op0_elt
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|insert_regs
argument_list|(
name|op0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|rehash_using_reg
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|op0_hash
operator|=
name|HASH
argument_list|(
name|op0
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
name|op0_elt
operator|=
name|insert
argument_list|(
name|op0
argument_list|,
name|NULL
argument_list|,
name|op0_hash
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|op0_elt
operator|->
name|in_memory
operator|=
name|op0_in_memory
expr_stmt|;
block|}
if|if
condition|(
name|op1_elt
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|insert_regs
argument_list|(
name|op1
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|rehash_using_reg
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|op1_hash
operator|=
name|HASH
argument_list|(
name|op1
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
name|op1_elt
operator|=
name|insert
argument_list|(
name|op1
argument_list|,
name|NULL
argument_list|,
name|op1_hash
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|op1_elt
operator|->
name|in_memory
operator|=
name|op1_in_memory
expr_stmt|;
block|}
name|merge_equiv_classes
argument_list|(
name|op0_elt
argument_list|,
name|op1_elt
argument_list|)
expr_stmt|;
name|last_jump_equiv_class
operator|=
name|op0_elt
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* CSE processing for one instruction.    First simplify sources and addresses of all assignments    in the instruction, using previously-computed equivalents values.    Then install the new sources and destinations in the table    of available values.     If LIBCALL_INSN is nonzero, don't record any equivalence made in    the insn.  It means that INSN is inside libcall block.  In this    case LIBCALL_INSN is the corresponding insn with REG_LIBCALL.  */
end_comment

begin_comment
comment|/* Data on one SET contained in the instruction.  */
end_comment

begin_struct
struct|struct
name|set
block|{
comment|/* The SET rtx itself.  */
name|rtx
name|rtl
decl_stmt|;
comment|/* The SET_SRC of the rtx (the original value, if it is changing).  */
name|rtx
name|src
decl_stmt|;
comment|/* The hash-table element for the SET_SRC of the SET.  */
name|struct
name|table_elt
modifier|*
name|src_elt
decl_stmt|;
comment|/* Hash value for the SET_SRC.  */
name|unsigned
name|src_hash
decl_stmt|;
comment|/* Hash value for the SET_DEST.  */
name|unsigned
name|dest_hash
decl_stmt|;
comment|/* The SET_DEST, with SUBREG, etc., stripped.  */
name|rtx
name|inner_dest
decl_stmt|;
comment|/* Nonzero if the SET_SRC is in memory.  */
name|char
name|src_in_memory
decl_stmt|;
comment|/* Nonzero if the SET_SRC contains something      whose value cannot be predicted and understood.  */
name|char
name|src_volatile
decl_stmt|;
comment|/* Original machine mode, in case it becomes a CONST_INT.      The size of this field should match the size of the mode      field of struct rtx_def (see rtl.h).  */
name|ENUM_BITFIELD
argument_list|(
argument|machine_mode
argument_list|)
name|mode
label|:
literal|8
expr_stmt|;
comment|/* A constant equivalent for SET_SRC, if any.  */
name|rtx
name|src_const
decl_stmt|;
comment|/* Original SET_SRC value used for libcall notes.  */
name|rtx
name|orig_src
decl_stmt|;
comment|/* Hash value of constant equivalent for SET_SRC.  */
name|unsigned
name|src_const_hash
decl_stmt|;
comment|/* Table entry for constant equivalent for SET_SRC, if any.  */
name|struct
name|table_elt
modifier|*
name|src_const_elt
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|cse_insn
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|libcall_insn
parameter_list|)
block|{
name|rtx
name|x
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
name|int
name|n_sets
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* Records what this insn does to set CC0.  */
name|rtx
name|this_insn_cc0
init|=
literal|0
decl_stmt|;
name|enum
name|machine_mode
name|this_insn_cc0_mode
init|=
name|VOIDmode
decl_stmt|;
endif|#
directive|endif
name|rtx
name|src_eqv
init|=
literal|0
decl_stmt|;
name|struct
name|table_elt
modifier|*
name|src_eqv_elt
init|=
literal|0
decl_stmt|;
name|int
name|src_eqv_volatile
init|=
literal|0
decl_stmt|;
name|int
name|src_eqv_in_memory
init|=
literal|0
decl_stmt|;
name|unsigned
name|src_eqv_hash
init|=
literal|0
decl_stmt|;
name|struct
name|set
modifier|*
name|sets
init|=
operator|(
expr|struct
name|set
operator|*
operator|)
literal|0
decl_stmt|;
name|this_insn
operator|=
name|insn
expr_stmt|;
comment|/* Find all the SETs and CLOBBERs in this instruction.      Record all the SETs in the array `set' and count them.      Also determine whether there is a CLOBBER that invalidates      all memory references, or all references at varying addresses.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
for|for
control|(
name|tem
operator|=
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
init|;
name|tem
condition|;
name|tem
operator|=
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
name|invalidate
argument_list|(
name|SET_DEST
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
operator|=
name|canon_reg
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
condition|)
block|{
name|sets
operator|=
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|set
argument_list|)
argument_list|)
expr_stmt|;
name|sets
index|[
literal|0
index|]
operator|.
name|rtl
operator|=
name|x
expr_stmt|;
comment|/* Ignore SETs that are unconditional jumps. 	 They never need cse processing, so this does not hurt. 	 The reason is not efficiency but rather 	 so that we can test at the end for instructions 	 that have been simplified to unconditional jumps 	 and not be misled by unchanged instructions 	 that were unconditional jumps to begin with.  */
if|if
condition|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|==
name|pc_rtx
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
empty_stmt|;
comment|/* Don't count call-insns, (set (reg 0) (call ...)), as a set. 	 The hard function value register is used only once, to copy to 	 someplace else, so it isn't worth cse'ing (and on 80386 is unsafe)! 	 Ensure we invalidate the destination register.  On the 80386 no 	 other code would invalidate it since it is a fixed_reg. 	 We need not check the return of apply_change_group; see canon_reg.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|CALL
condition|)
block|{
name|canon_reg
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|apply_change_group
argument_list|()
expr_stmt|;
name|fold_rtx
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|invalidate
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
block|}
else|else
name|n_sets
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|lim
init|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|sets
operator|=
name|alloca
argument_list|(
name|lim
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|set
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Find all regs explicitly clobbered in this insn, 	 and ensure they are not replaced with any other regs 	 elsewhere in this insn. 	 When a reg that is clobbered is also used for input, 	 we should presume that that is for a reason, 	 and we should not substitute some other register 	 which is not supposed to be clobbered. 	 Therefore, this loop cannot be merged into the one below 	 because a CALL may precede a CLOBBER and refer to the 	 value clobbered.  We must not let a canonicalization do 	 anything in that case.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lim
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|y
init|=
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|CLOBBER
condition|)
block|{
name|rtx
name|clobbered
init|=
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|clobbered
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|clobbered
argument_list|)
operator|==
name|SUBREG
condition|)
name|invalidate
argument_list|(
name|clobbered
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|clobbered
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|clobbered
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
name|invalidate
argument_list|(
name|XEXP
argument_list|(
name|clobbered
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|clobbered
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lim
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|y
init|=
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|SET
condition|)
block|{
comment|/* As above, we ignore unconditional jumps and call-insns and 		 ignore the result of apply_change_group.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|y
argument_list|)
argument_list|)
operator|==
name|CALL
condition|)
block|{
name|canon_reg
argument_list|(
name|SET_SRC
argument_list|(
name|y
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|apply_change_group
argument_list|()
expr_stmt|;
name|fold_rtx
argument_list|(
name|SET_SRC
argument_list|(
name|y
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|invalidate
argument_list|(
name|SET_DEST
argument_list|(
name|y
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SET_DEST
argument_list|(
name|y
argument_list|)
operator|==
name|pc_rtx
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|y
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
empty_stmt|;
else|else
name|sets
index|[
name|n_sets
operator|++
index|]
operator|.
name|rtl
operator|=
name|y
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|CLOBBER
condition|)
block|{
comment|/* If we clobber memory, canon the address. 		 This does nothing when a register is clobbered 		 because we have already invalidated the reg.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
name|canon_reg
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|USE
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
name|canon_reg
argument_list|(
name|y
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|CALL
condition|)
block|{
comment|/* The result of apply_change_group can be ignored; see 		 canon_reg.  */
name|canon_reg
argument_list|(
name|y
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|apply_change_group
argument_list|()
expr_stmt|;
name|fold_rtx
argument_list|(
name|y
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CLOBBER
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
name|canon_reg
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
comment|/* Canonicalize a USE of a pseudo register or memory location.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|USE
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
name|canon_reg
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CALL
condition|)
block|{
comment|/* The result of apply_change_group can be ignored; see canon_reg.  */
name|canon_reg
argument_list|(
name|x
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|apply_change_group
argument_list|()
expr_stmt|;
name|fold_rtx
argument_list|(
name|x
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* Store the equivalent value in SRC_EQV, if different, or if the DEST      is a STRICT_LOW_PART.  The latter condition is necessary because SRC_EQV      is handled specially for this case, and if it isn't set, then there will      be no equivalence for the destination.  */
if|if
condition|(
name|n_sets
operator|==
literal|1
operator|&&
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|tem
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|!
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|sets
index|[
literal|0
index|]
operator|.
name|rtl
argument_list|)
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|sets
index|[
literal|0
index|]
operator|.
name|rtl
argument_list|)
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|)
condition|)
block|{
name|src_eqv
operator|=
name|fold_rtx
argument_list|(
name|canon_reg
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
operator|=
name|src_eqv
expr_stmt|;
block|}
comment|/* Canonicalize sources and addresses of destinations.      We do this in a separate pass to avoid problems when a MATCH_DUP is      present in the insn pattern.  In that case, we want to ensure that      we don't break the duplicate nature of the pattern.  So we will replace      both operands at the same time.  Otherwise, we would fail to find an      equivalent substitution in the loop calling validate_change below.       We used to suppress canonicalization of DEST if it appears in SRC,      but we don't do this any more.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_sets
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
decl_stmt|;
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
decl_stmt|;
name|rtx
name|new
init|=
name|canon_reg
argument_list|(
name|src
argument_list|,
name|insn
argument_list|)
decl_stmt|;
name|int
name|insn_code
decl_stmt|;
name|sets
index|[
name|i
index|]
operator|.
name|orig_src
operator|=
name|src
expr_stmt|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|new
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|REG
operator|&&
operator|(
operator|(
name|REGNO
argument_list|(
name|new
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
operator|!=
operator|(
name|REGNO
argument_list|(
name|src
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
operator|)
operator|)
operator|||
operator|(
name|insn_code
operator|=
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|)
operator|<
literal|0
operator|||
name|insn_data
index|[
name|insn_code
index|]
operator|.
name|n_dups
operator|>
literal|0
condition|)
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
argument_list|,
name|new
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|SET_SRC
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
operator|=
name|new
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SIGN_EXTRACT
condition|)
block|{
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|1
argument_list|)
argument_list|,
name|canon_reg
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|1
argument_list|)
argument_list|,
name|insn
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|2
argument_list|)
argument_list|,
name|canon_reg
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|2
argument_list|)
argument_list|,
name|insn
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SIGN_EXTRACT
condition|)
name|dest
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
condition|)
name|canon_reg
argument_list|(
name|dest
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* Now that we have done all the replacements, we can apply the change      group and see if they all work.  Note that this will cause some      canonicalizations that would have worked individually not to be applied      because some other canonicalization didn't work, but this should not      occur often.       The result of apply_change_group can be ignored; see canon_reg.  */
name|apply_change_group
argument_list|()
expr_stmt|;
comment|/* Set sets[i].src_elt to the class each source belongs to.      Detect assignments from or to volatile things      and set set[i] to zero so they will be ignored      in the rest of this function.       Nothing in this loop changes the hash table or the register chains.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_sets
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|src
decl_stmt|,
name|dest
decl_stmt|;
name|rtx
name|src_folded
decl_stmt|;
name|struct
name|table_elt
modifier|*
name|elt
init|=
literal|0
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|src_eqv_here
decl_stmt|;
name|rtx
name|src_const
init|=
literal|0
decl_stmt|;
name|rtx
name|src_related
init|=
literal|0
decl_stmt|;
name|struct
name|table_elt
modifier|*
name|src_const_elt
init|=
literal|0
decl_stmt|;
name|int
name|src_cost
init|=
name|MAX_COST
decl_stmt|;
name|int
name|src_eqv_cost
init|=
name|MAX_COST
decl_stmt|;
name|int
name|src_folded_cost
init|=
name|MAX_COST
decl_stmt|;
name|int
name|src_related_cost
init|=
name|MAX_COST
decl_stmt|;
name|int
name|src_elt_cost
init|=
name|MAX_COST
decl_stmt|;
name|int
name|src_regcost
init|=
name|MAX_COST
decl_stmt|;
name|int
name|src_eqv_regcost
init|=
name|MAX_COST
decl_stmt|;
name|int
name|src_folded_regcost
init|=
name|MAX_COST
decl_stmt|;
name|int
name|src_related_regcost
init|=
name|MAX_COST
decl_stmt|;
name|int
name|src_elt_regcost
init|=
name|MAX_COST
decl_stmt|;
comment|/* Set nonzero if we need to call force_const_mem on with the 	 contents of src_folded before using it.  */
name|int
name|src_folded_force_flag
init|=
literal|0
decl_stmt|;
name|dest
operator|=
name|SET_DEST
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
expr_stmt|;
name|src
operator|=
name|SET_SRC
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
expr_stmt|;
comment|/* If SRC is a constant that has no machine mode, 	 hash it with the destination's machine mode. 	 This way we can keep different modes separate.  */
name|mode
operator|=
name|GET_MODE
argument_list|(
name|src
argument_list|)
operator|==
name|VOIDmode
condition|?
name|GET_MODE
argument_list|(
name|dest
argument_list|)
else|:
name|GET_MODE
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|sets
index|[
name|i
index|]
operator|.
name|mode
operator|=
name|mode
expr_stmt|;
if|if
condition|(
name|src_eqv
condition|)
block|{
name|enum
name|machine_mode
name|eqvmode
init|=
name|mode
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|eqvmode
operator|=
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|do_not_record
operator|=
literal|0
expr_stmt|;
name|hash_arg_in_memory
operator|=
literal|0
expr_stmt|;
name|src_eqv_hash
operator|=
name|HASH
argument_list|(
name|src_eqv
argument_list|,
name|eqvmode
argument_list|)
expr_stmt|;
comment|/* Find the equivalence class for the equivalent expression.  */
if|if
condition|(
operator|!
name|do_not_record
condition|)
name|src_eqv_elt
operator|=
name|lookup
argument_list|(
name|src_eqv
argument_list|,
name|src_eqv_hash
argument_list|,
name|eqvmode
argument_list|)
expr_stmt|;
name|src_eqv_volatile
operator|=
name|do_not_record
expr_stmt|;
name|src_eqv_in_memory
operator|=
name|hash_arg_in_memory
expr_stmt|;
block|}
comment|/* If this is a STRICT_LOW_PART assignment, src_eqv corresponds to the 	 value of the INNER register, not the destination.  So it is not 	 a valid substitution for the source.  But save it for later.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|src_eqv_here
operator|=
literal|0
expr_stmt|;
else|else
name|src_eqv_here
operator|=
name|src_eqv
expr_stmt|;
comment|/* Simplify and foldable subexpressions in SRC.  Then get the fully- 	 simplified result, which may not necessarily be valid.  */
name|src_folded
operator|=
name|fold_rtx
argument_list|(
name|src
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* ??? This caused bad code to be generated for the m68k port with -O2. 	 Suppose src is (CONST_INT -1), and that after truncation src_folded 	 is (CONST_INT 3).  Suppose src_folded is then used for src_const. 	 At the end we will add src and src_const to the same equivalence 	 class.  We now have 3 and -1 on the same equivalence class.  This 	 causes later instructions to be mis-optimized.  */
comment|/* If storing a constant in a bitfield, pre-truncate the constant 	 so we will be able to record it later.  */
block|if (GET_CODE (SET_DEST (sets[i].rtl)) == ZERO_EXTRACT 	  || GET_CODE (SET_DEST (sets[i].rtl)) == SIGN_EXTRACT) 	{ 	  rtx width = XEXP (SET_DEST (sets[i].rtl), 1);  	  if (GET_CODE (src) == CONST_INT&& GET_CODE (width) == CONST_INT&& INTVAL (width)< HOST_BITS_PER_WIDE_INT&& (INTVAL (src)& ((HOST_WIDE_INT) (-1)<< INTVAL (width)))) 	    src_folded 	      = GEN_INT (INTVAL (src)& (((HOST_WIDE_INT) 1<< INTVAL (width)) - 1)); 	}
endif|#
directive|endif
comment|/* Compute SRC's hash code, and also notice if it 	 should not be recorded at all.  In that case, 	 prevent any further processing of this assignment.  */
name|do_not_record
operator|=
literal|0
expr_stmt|;
name|hash_arg_in_memory
operator|=
literal|0
expr_stmt|;
name|sets
index|[
name|i
index|]
operator|.
name|src
operator|=
name|src
expr_stmt|;
name|sets
index|[
name|i
index|]
operator|.
name|src_hash
operator|=
name|HASH
argument_list|(
name|src
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|sets
index|[
name|i
index|]
operator|.
name|src_volatile
operator|=
name|do_not_record
expr_stmt|;
name|sets
index|[
name|i
index|]
operator|.
name|src_in_memory
operator|=
name|hash_arg_in_memory
expr_stmt|;
comment|/* If SRC is a MEM, there is a REG_EQUIV note for SRC, and DEST is 	 a pseudo, do not record SRC.  Using SRC as a replacement for 	 anything else will be incorrect in that situation.  Note that 	 this usually occurs only for stack slots, in which case all the 	 RTL would be referring to SRC, so we don't lose any optimization 	 opportunities by not having SRC in the hash table.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|MEM
operator|&&
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUIV
argument_list|,
name|NULL_RTX
argument_list|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|sets
index|[
name|i
index|]
operator|.
name|src_volatile
operator|=
literal|1
expr_stmt|;
if|#
directive|if
literal|0
comment|/* It is no longer clear why we used to do this, but it doesn't 	 appear to still be needed.  So let's try without it since this 	 code hurts cse'ing widened ops.  */
comment|/* If source is a perverse subreg (such as QI treated as an SI), 	 treat it as volatile.  It may do the work of an SI in one context 	 where the extra bits are not being used, but cannot replace an SI 	 in general.  */
block|if (GET_CODE (src) == SUBREG&& (GET_MODE_SIZE (GET_MODE (src))> GET_MODE_SIZE (GET_MODE (SUBREG_REG (src))))) 	sets[i].src_volatile = 1;
endif|#
directive|endif
comment|/* Locate all possible equivalent forms for SRC.  Try to replace          SRC in the insn with each cheaper equivalent.           We have the following types of equivalents: SRC itself, a folded          version, a value given in a REG_EQUAL note, or a value related 	 to a constant.           Each of these equivalents may be part of an additional class          of equivalents (if more than one is in the table, they must be in          the same class; we check for this).  	 If the source is volatile, we don't do any table lookups.           We note any constant equivalent for possible later use in a          REG_NOTE.  */
if|if
condition|(
operator|!
name|sets
index|[
name|i
index|]
operator|.
name|src_volatile
condition|)
name|elt
operator|=
name|lookup
argument_list|(
name|src
argument_list|,
name|sets
index|[
name|i
index|]
operator|.
name|src_hash
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|sets
index|[
name|i
index|]
operator|.
name|src_elt
operator|=
name|elt
expr_stmt|;
if|if
condition|(
name|elt
operator|&&
name|src_eqv_here
operator|&&
name|src_eqv_elt
condition|)
block|{
if|if
condition|(
name|elt
operator|->
name|first_same_value
operator|!=
name|src_eqv_elt
operator|->
name|first_same_value
condition|)
block|{
comment|/* The REG_EQUAL is indicating that two formerly distinct 		 classes are now equivalent.  So merge them.  */
name|merge_equiv_classes
argument_list|(
name|elt
argument_list|,
name|src_eqv_elt
argument_list|)
expr_stmt|;
name|src_eqv_hash
operator|=
name|HASH
argument_list|(
name|src_eqv
argument_list|,
name|elt
operator|->
name|mode
argument_list|)
expr_stmt|;
name|src_eqv_elt
operator|=
name|lookup
argument_list|(
name|src_eqv
argument_list|,
name|src_eqv_hash
argument_list|,
name|elt
operator|->
name|mode
argument_list|)
expr_stmt|;
block|}
name|src_eqv_here
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|src_eqv_elt
condition|)
name|elt
operator|=
name|src_eqv_elt
expr_stmt|;
comment|/* Try to find a constant somewhere and record it in `src_const'. 	 Record its table element, if any, in `src_const_elt'.  Look in 	 any known equivalences first.  (If the constant is not in the 	 table, also set `sets[i].src_const_hash').  */
if|if
condition|(
name|elt
condition|)
for|for
control|(
name|p
operator|=
name|elt
operator|->
name|first_same_value
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next_same_value
control|)
if|if
condition|(
name|p
operator|->
name|is_const
condition|)
block|{
name|src_const
operator|=
name|p
operator|->
name|exp
expr_stmt|;
name|src_const_elt
operator|=
name|elt
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|src_const
operator|==
literal|0
operator|&&
operator|(
name|CONSTANT_P
argument_list|(
name|src_folded
argument_list|)
comment|/* Consider (minus (label_ref L1) (label_ref L2)) as 		 "constant" here so we will record it. This allows us 		 to fold switch statements when an ADDR_DIFF_VEC is used.  */
operator|||
operator|(
name|GET_CODE
argument_list|(
name|src_folded
argument_list|)
operator|==
name|MINUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src_folded
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src_folded
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|)
operator|)
condition|)
name|src_const
operator|=
name|src_folded
operator|,
name|src_const_elt
operator|=
name|elt
expr_stmt|;
elseif|else
if|if
condition|(
name|src_const
operator|==
literal|0
operator|&&
name|src_eqv_here
operator|&&
name|CONSTANT_P
argument_list|(
name|src_eqv_here
argument_list|)
condition|)
name|src_const
operator|=
name|src_eqv_here
operator|,
name|src_const_elt
operator|=
name|src_eqv_elt
expr_stmt|;
comment|/* If we don't know if the constant is in the table, get its 	 hash code and look it up.  */
if|if
condition|(
name|src_const
operator|&&
name|src_const_elt
operator|==
literal|0
condition|)
block|{
name|sets
index|[
name|i
index|]
operator|.
name|src_const_hash
operator|=
name|HASH
argument_list|(
name|src_const
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|src_const_elt
operator|=
name|lookup
argument_list|(
name|src_const
argument_list|,
name|sets
index|[
name|i
index|]
operator|.
name|src_const_hash
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
name|sets
index|[
name|i
index|]
operator|.
name|src_const
operator|=
name|src_const
expr_stmt|;
name|sets
index|[
name|i
index|]
operator|.
name|src_const_elt
operator|=
name|src_const_elt
expr_stmt|;
comment|/* If the constant and our source are both in the table, mark them as 	 equivalent.  Otherwise, if a constant is in the table but the source 	 isn't, set ELT to it.  */
if|if
condition|(
name|src_const_elt
operator|&&
name|elt
operator|&&
name|src_const_elt
operator|->
name|first_same_value
operator|!=
name|elt
operator|->
name|first_same_value
condition|)
name|merge_equiv_classes
argument_list|(
name|elt
argument_list|,
name|src_const_elt
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|src_const_elt
operator|&&
name|elt
operator|==
literal|0
condition|)
name|elt
operator|=
name|src_const_elt
expr_stmt|;
comment|/* See if there is a register linearly related to a constant          equivalent of SRC.  */
if|if
condition|(
name|src_const
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|src_const
argument_list|)
operator|==
name|CONST
operator|||
operator|(
name|src_const_elt
operator|&&
name|src_const_elt
operator|->
name|related_value
operator|!=
literal|0
operator|)
operator|)
condition|)
block|{
name|src_related
operator|=
name|use_related_value
argument_list|(
name|src_const
argument_list|,
name|src_const_elt
argument_list|)
expr_stmt|;
if|if
condition|(
name|src_related
condition|)
block|{
name|struct
name|table_elt
modifier|*
name|src_related_elt
init|=
name|lookup
argument_list|(
name|src_related
argument_list|,
name|HASH
argument_list|(
name|src_related
argument_list|,
name|mode
argument_list|)
argument_list|,
name|mode
argument_list|)
decl_stmt|;
if|if
condition|(
name|src_related_elt
operator|&&
name|elt
condition|)
block|{
if|if
condition|(
name|elt
operator|->
name|first_same_value
operator|!=
name|src_related_elt
operator|->
name|first_same_value
condition|)
comment|/* This can occur when we previously saw a CONST 		       involving a SYMBOL_REF and then see the SYMBOL_REF 		       twice.  Merge the involved classes.  */
name|merge_equiv_classes
argument_list|(
name|elt
argument_list|,
name|src_related_elt
argument_list|)
expr_stmt|;
name|src_related
operator|=
literal|0
expr_stmt|;
name|src_related_elt
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|src_related_elt
operator|&&
name|elt
operator|==
literal|0
condition|)
name|elt
operator|=
name|src_related_elt
expr_stmt|;
block|}
block|}
comment|/* See if we have a CONST_INT that is already in a register in a 	 wider mode.  */
if|if
condition|(
name|src_const
operator|&&
name|src_related
operator|==
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|src_const
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<
name|BITS_PER_WORD
condition|)
block|{
name|enum
name|machine_mode
name|wider_mode
decl_stmt|;
for|for
control|(
name|wider_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
init|;
name|GET_MODE_BITSIZE
argument_list|(
name|wider_mode
argument_list|)
operator|<=
name|BITS_PER_WORD
operator|&&
name|src_related
operator|==
literal|0
condition|;
name|wider_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|wider_mode
argument_list|)
control|)
block|{
name|struct
name|table_elt
modifier|*
name|const_elt
init|=
name|lookup
argument_list|(
name|src_const
argument_list|,
name|HASH
argument_list|(
name|src_const
argument_list|,
name|wider_mode
argument_list|)
argument_list|,
name|wider_mode
argument_list|)
decl_stmt|;
if|if
condition|(
name|const_elt
operator|==
literal|0
condition|)
continue|continue;
for|for
control|(
name|const_elt
operator|=
name|const_elt
operator|->
name|first_same_value
init|;
name|const_elt
condition|;
name|const_elt
operator|=
name|const_elt
operator|->
name|next_same_value
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|const_elt
operator|->
name|exp
argument_list|)
operator|==
name|REG
condition|)
block|{
name|src_related
operator|=
name|gen_lowpart_if_possible
argument_list|(
name|mode
argument_list|,
name|const_elt
operator|->
name|exp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* Another possibility is that we have an AND with a constant in 	 a mode narrower than a word.  If so, it might have been generated 	 as part of an "if" which would narrow the AND.  If we already 	 have done the AND in a wider mode, we can use a SUBREG of that 	 value.  */
if|if
condition|(
name|flag_expensive_optimizations
operator|&&
operator|!
name|src_related
operator|&&
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|AND
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<
name|UNITS_PER_WORD
condition|)
block|{
name|enum
name|machine_mode
name|tmode
decl_stmt|;
name|rtx
name|new_and
init|=
name|gen_rtx_AND
argument_list|(
name|VOIDmode
argument_list|,
name|NULL_RTX
argument_list|,
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|tmode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
init|;
name|GET_MODE_SIZE
argument_list|(
name|tmode
argument_list|)
operator|<=
name|UNITS_PER_WORD
condition|;
name|tmode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|tmode
argument_list|)
control|)
block|{
name|rtx
name|inner
init|=
name|gen_lowpart_if_possible
argument_list|(
name|tmode
argument_list|,
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|table_elt
modifier|*
name|larger_elt
decl_stmt|;
if|if
condition|(
name|inner
condition|)
block|{
name|PUT_MODE
argument_list|(
name|new_and
argument_list|,
name|tmode
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|new_and
argument_list|,
literal|0
argument_list|)
operator|=
name|inner
expr_stmt|;
name|larger_elt
operator|=
name|lookup
argument_list|(
name|new_and
argument_list|,
name|HASH
argument_list|(
name|new_and
argument_list|,
name|tmode
argument_list|)
argument_list|,
name|tmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|larger_elt
operator|==
literal|0
condition|)
continue|continue;
for|for
control|(
name|larger_elt
operator|=
name|larger_elt
operator|->
name|first_same_value
init|;
name|larger_elt
condition|;
name|larger_elt
operator|=
name|larger_elt
operator|->
name|next_same_value
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|larger_elt
operator|->
name|exp
argument_list|)
operator|==
name|REG
condition|)
block|{
name|src_related
operator|=
name|gen_lowpart_if_possible
argument_list|(
name|mode
argument_list|,
name|larger_elt
operator|->
name|exp
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|src_related
condition|)
break|break;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|LOAD_EXTEND_OP
comment|/* See if a MEM has already been loaded with a widening operation; 	 if it has, we can use a subreg of that.  Many CISC machines 	 also have such operations, but this is only likely to be 	 beneficial these machines.  */
if|if
condition|(
name|flag_expensive_optimizations
operator|&&
name|src_related
operator|==
literal|0
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<
name|UNITS_PER_WORD
operator|)
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|do_not_record
operator|&&
name|LOAD_EXTEND_OP
argument_list|(
name|mode
argument_list|)
operator|!=
name|NIL
condition|)
block|{
name|enum
name|machine_mode
name|tmode
decl_stmt|;
comment|/* Set what we are trying to extend and the operation it might 	     have been extended with.  */
name|PUT_CODE
argument_list|(
name|memory_extend_rtx
argument_list|,
name|LOAD_EXTEND_OP
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|memory_extend_rtx
argument_list|,
literal|0
argument_list|)
operator|=
name|src
expr_stmt|;
for|for
control|(
name|tmode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
init|;
name|GET_MODE_SIZE
argument_list|(
name|tmode
argument_list|)
operator|<=
name|UNITS_PER_WORD
condition|;
name|tmode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|tmode
argument_list|)
control|)
block|{
name|struct
name|table_elt
modifier|*
name|larger_elt
decl_stmt|;
name|PUT_MODE
argument_list|(
name|memory_extend_rtx
argument_list|,
name|tmode
argument_list|)
expr_stmt|;
name|larger_elt
operator|=
name|lookup
argument_list|(
name|memory_extend_rtx
argument_list|,
name|HASH
argument_list|(
name|memory_extend_rtx
argument_list|,
name|tmode
argument_list|)
argument_list|,
name|tmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|larger_elt
operator|==
literal|0
condition|)
continue|continue;
for|for
control|(
name|larger_elt
operator|=
name|larger_elt
operator|->
name|first_same_value
init|;
name|larger_elt
condition|;
name|larger_elt
operator|=
name|larger_elt
operator|->
name|next_same_value
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|larger_elt
operator|->
name|exp
argument_list|)
operator|==
name|REG
condition|)
block|{
name|src_related
operator|=
name|gen_lowpart_if_possible
argument_list|(
name|mode
argument_list|,
name|larger_elt
operator|->
name|exp
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|src_related
condition|)
break|break;
block|}
block|}
endif|#
directive|endif
comment|/* LOAD_EXTEND_OP */
if|if
condition|(
name|src
operator|==
name|src_folded
condition|)
name|src_folded
operator|=
literal|0
expr_stmt|;
comment|/* At this point, ELT, if nonzero, points to a class of expressions          equivalent to the source of this SET and SRC, SRC_EQV, SRC_FOLDED, 	 and SRC_RELATED, if nonzero, each contain additional equivalent 	 expressions.  Prune these latter expressions by deleting expressions 	 already in the equivalence class.  	 Check for an equivalent identical to the destination.  If found, 	 this is the preferred equivalent since it will likely lead to 	 elimination of the insn.  Indicate this by placing it in 	 `src_related'.  */
if|if
condition|(
name|elt
condition|)
name|elt
operator|=
name|elt
operator|->
name|first_same_value
expr_stmt|;
for|for
control|(
name|p
operator|=
name|elt
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next_same_value
control|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|p
operator|->
name|exp
argument_list|)
decl_stmt|;
comment|/* If the expression is not valid, ignore it.  Then we do not 	     have to check for validity below.  In most cases, we can use 	     `rtx_equal_p', since canonicalization has already been done.  */
if|if
condition|(
name|code
operator|!=
name|REG
operator|&&
operator|!
name|exp_equiv_p
argument_list|(
name|p
operator|->
name|exp
argument_list|,
name|p
operator|->
name|exp
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
continue|continue;
comment|/* Also skip paradoxical subregs, unless that's what we're 	     looking for.  */
if|if
condition|(
name|code
operator|==
name|SUBREG
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|p
operator|->
name|exp
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|p
operator|->
name|exp
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
operator|!
operator|(
name|src
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_MODE
argument_list|(
name|src
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|p
operator|->
name|exp
argument_list|)
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|src
argument_list|)
argument_list|)
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|p
operator|->
name|exp
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
continue|continue;
if|if
condition|(
name|src
operator|&&
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|code
operator|&&
name|rtx_equal_p
argument_list|(
name|src
argument_list|,
name|p
operator|->
name|exp
argument_list|)
condition|)
name|src
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|src_folded
operator|&&
name|GET_CODE
argument_list|(
name|src_folded
argument_list|)
operator|==
name|code
operator|&&
name|rtx_equal_p
argument_list|(
name|src_folded
argument_list|,
name|p
operator|->
name|exp
argument_list|)
condition|)
name|src_folded
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|src_eqv_here
operator|&&
name|GET_CODE
argument_list|(
name|src_eqv_here
argument_list|)
operator|==
name|code
operator|&&
name|rtx_equal_p
argument_list|(
name|src_eqv_here
argument_list|,
name|p
operator|->
name|exp
argument_list|)
condition|)
name|src_eqv_here
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|src_related
operator|&&
name|GET_CODE
argument_list|(
name|src_related
argument_list|)
operator|==
name|code
operator|&&
name|rtx_equal_p
argument_list|(
name|src_related
argument_list|,
name|p
operator|->
name|exp
argument_list|)
condition|)
name|src_related
operator|=
literal|0
expr_stmt|;
comment|/* This is the same as the destination of the insns, we want 	     to prefer it.  Copy it to src_related.  The code below will 	     then give it a negative cost.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|code
operator|&&
name|rtx_equal_p
argument_list|(
name|p
operator|->
name|exp
argument_list|,
name|dest
argument_list|)
condition|)
name|src_related
operator|=
name|dest
expr_stmt|;
block|}
comment|/* Find the cheapest valid equivalent, trying all the available          possibilities.  Prefer items not in the hash table to ones          that are when they are equal cost.  Note that we can never          worsen an insn as the current contents will also succeed. 	 If we find an equivalent identical to the destination, use it as best, 	 since this insn will probably be eliminated in that case.  */
if|if
condition|(
name|src
condition|)
block|{
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|src
argument_list|,
name|dest
argument_list|)
condition|)
name|src_cost
operator|=
name|src_regcost
operator|=
operator|-
literal|1
expr_stmt|;
else|else
block|{
name|src_cost
operator|=
name|COST
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|src_regcost
operator|=
name|approx_reg_cost
argument_list|(
name|src
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|src_eqv_here
condition|)
block|{
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|src_eqv_here
argument_list|,
name|dest
argument_list|)
condition|)
name|src_eqv_cost
operator|=
name|src_eqv_regcost
operator|=
operator|-
literal|1
expr_stmt|;
else|else
block|{
name|src_eqv_cost
operator|=
name|COST
argument_list|(
name|src_eqv_here
argument_list|)
expr_stmt|;
name|src_eqv_regcost
operator|=
name|approx_reg_cost
argument_list|(
name|src_eqv_here
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|src_folded
condition|)
block|{
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|src_folded
argument_list|,
name|dest
argument_list|)
condition|)
name|src_folded_cost
operator|=
name|src_folded_regcost
operator|=
operator|-
literal|1
expr_stmt|;
else|else
block|{
name|src_folded_cost
operator|=
name|COST
argument_list|(
name|src_folded
argument_list|)
expr_stmt|;
name|src_folded_regcost
operator|=
name|approx_reg_cost
argument_list|(
name|src_folded
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|src_related
condition|)
block|{
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|src_related
argument_list|,
name|dest
argument_list|)
condition|)
name|src_related_cost
operator|=
name|src_related_regcost
operator|=
operator|-
literal|1
expr_stmt|;
else|else
block|{
name|src_related_cost
operator|=
name|COST
argument_list|(
name|src_related
argument_list|)
expr_stmt|;
name|src_related_regcost
operator|=
name|approx_reg_cost
argument_list|(
name|src_related
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If this was an indirect jump insn, a known label will really be 	 cheaper even though it looks more expensive.  */
if|if
condition|(
name|dest
operator|==
name|pc_rtx
operator|&&
name|src_const
operator|&&
name|GET_CODE
argument_list|(
name|src_const
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|src_folded
operator|=
name|src_const
operator|,
name|src_folded_cost
operator|=
name|src_folded_regcost
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Terminate loop when replacement made.  This must terminate since          the current contents will be tested and will always be valid.  */
while|while
condition|(
literal|1
condition|)
block|{
name|rtx
name|trial
decl_stmt|;
comment|/* Skip invalid entries.  */
while|while
condition|(
name|elt
operator|&&
name|GET_CODE
argument_list|(
name|elt
operator|->
name|exp
argument_list|)
operator|!=
name|REG
operator|&&
operator|!
name|exp_equiv_p
argument_list|(
name|elt
operator|->
name|exp
argument_list|,
name|elt
operator|->
name|exp
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
name|elt
operator|=
name|elt
operator|->
name|next_same_value
expr_stmt|;
comment|/* A paradoxical subreg would be bad here: it'll be the right 	     size, but later may be adjusted so that the upper bits aren't 	     what we want.  So reject it.  */
if|if
condition|(
name|elt
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|elt
operator|->
name|exp
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|elt
operator|->
name|exp
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|elt
operator|->
name|exp
argument_list|)
argument_list|)
argument_list|)
operator|)
comment|/* It is okay, though, if the rtx we're trying to match 		 will ignore any of the bits we can't predict.  */
operator|&&
operator|!
operator|(
name|src
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_MODE
argument_list|(
name|src
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|elt
operator|->
name|exp
argument_list|)
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|src
argument_list|)
argument_list|)
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|elt
operator|->
name|exp
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
block|{
name|elt
operator|=
name|elt
operator|->
name|next_same_value
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|elt
condition|)
block|{
name|src_elt_cost
operator|=
name|elt
operator|->
name|cost
expr_stmt|;
name|src_elt_regcost
operator|=
name|elt
operator|->
name|regcost
expr_stmt|;
block|}
comment|/* Find cheapest and skip it for the next time.   For items 	     of equal cost, use this order: 	     src_folded, src, src_eqv, src_related and hash table entry.  */
if|if
condition|(
name|src_folded
operator|&&
name|preferrable
argument_list|(
name|src_folded_cost
argument_list|,
name|src_folded_regcost
argument_list|,
name|src_cost
argument_list|,
name|src_regcost
argument_list|)
operator|<=
literal|0
operator|&&
name|preferrable
argument_list|(
name|src_folded_cost
argument_list|,
name|src_folded_regcost
argument_list|,
name|src_eqv_cost
argument_list|,
name|src_eqv_regcost
argument_list|)
operator|<=
literal|0
operator|&&
name|preferrable
argument_list|(
name|src_folded_cost
argument_list|,
name|src_folded_regcost
argument_list|,
name|src_related_cost
argument_list|,
name|src_related_regcost
argument_list|)
operator|<=
literal|0
operator|&&
name|preferrable
argument_list|(
name|src_folded_cost
argument_list|,
name|src_folded_regcost
argument_list|,
name|src_elt_cost
argument_list|,
name|src_elt_regcost
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|trial
operator|=
name|src_folded
operator|,
name|src_folded_cost
operator|=
name|MAX_COST
expr_stmt|;
if|if
condition|(
name|src_folded_force_flag
condition|)
block|{
name|rtx
name|forced
init|=
name|force_const_mem
argument_list|(
name|mode
argument_list|,
name|trial
argument_list|)
decl_stmt|;
if|if
condition|(
name|forced
condition|)
name|trial
operator|=
name|forced
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|src
operator|&&
name|preferrable
argument_list|(
name|src_cost
argument_list|,
name|src_regcost
argument_list|,
name|src_eqv_cost
argument_list|,
name|src_eqv_regcost
argument_list|)
operator|<=
literal|0
operator|&&
name|preferrable
argument_list|(
name|src_cost
argument_list|,
name|src_regcost
argument_list|,
name|src_related_cost
argument_list|,
name|src_related_regcost
argument_list|)
operator|<=
literal|0
operator|&&
name|preferrable
argument_list|(
name|src_cost
argument_list|,
name|src_regcost
argument_list|,
name|src_elt_cost
argument_list|,
name|src_elt_regcost
argument_list|)
operator|<=
literal|0
condition|)
name|trial
operator|=
name|src
operator|,
name|src_cost
operator|=
name|MAX_COST
expr_stmt|;
elseif|else
if|if
condition|(
name|src_eqv_here
operator|&&
name|preferrable
argument_list|(
name|src_eqv_cost
argument_list|,
name|src_eqv_regcost
argument_list|,
name|src_related_cost
argument_list|,
name|src_related_regcost
argument_list|)
operator|<=
literal|0
operator|&&
name|preferrable
argument_list|(
name|src_eqv_cost
argument_list|,
name|src_eqv_regcost
argument_list|,
name|src_elt_cost
argument_list|,
name|src_elt_regcost
argument_list|)
operator|<=
literal|0
condition|)
name|trial
operator|=
name|copy_rtx
argument_list|(
name|src_eqv_here
argument_list|)
operator|,
name|src_eqv_cost
operator|=
name|MAX_COST
expr_stmt|;
elseif|else
if|if
condition|(
name|src_related
operator|&&
name|preferrable
argument_list|(
name|src_related_cost
argument_list|,
name|src_related_regcost
argument_list|,
name|src_elt_cost
argument_list|,
name|src_elt_regcost
argument_list|)
operator|<=
literal|0
condition|)
name|trial
operator|=
name|copy_rtx
argument_list|(
name|src_related
argument_list|)
operator|,
name|src_related_cost
operator|=
name|MAX_COST
expr_stmt|;
else|else
block|{
name|trial
operator|=
name|copy_rtx
argument_list|(
name|elt
operator|->
name|exp
argument_list|)
expr_stmt|;
name|elt
operator|=
name|elt
operator|->
name|next_same_value
expr_stmt|;
name|src_elt_cost
operator|=
name|MAX_COST
expr_stmt|;
block|}
comment|/* We don't normally have an insn matching (set (pc) (pc)), so 	     check for this separately here.  We will delete such an 	     insn below.  	     For other cases such as a table jump or conditional jump 	     where we know the ultimate target, go ahead and replace the 	     operand.  While that may not make a valid insn, we will 	     reemit the jump below (and also insert any necessary 	     barriers).  */
if|if
condition|(
name|n_sets
operator|==
literal|1
operator|&&
name|dest
operator|==
name|pc_rtx
operator|&&
operator|(
name|trial
operator|==
name|pc_rtx
operator|||
operator|(
name|GET_CODE
argument_list|(
name|trial
argument_list|)
operator|==
name|LABEL_REF
operator|&&
operator|!
name|condjump_p
argument_list|(
name|insn
argument_list|)
operator|)
operator|)
condition|)
block|{
name|SET_SRC
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
operator|=
name|trial
expr_stmt|;
name|cse_jumps_altered
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* Look for a substitution that makes a valid insn.  */
elseif|else
if|if
condition|(
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
argument_list|,
name|trial
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|rtx
name|new
init|=
name|canon_reg
argument_list|(
name|SET_SRC
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
argument_list|,
name|insn
argument_list|)
decl_stmt|;
comment|/* If we just made a substitution inside a libcall, then we 		 need to make the same substitution in any notes attached 		 to the RETVAL insn.  */
if|if
condition|(
name|libcall_insn
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|orig_src
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|orig_src
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|orig_src
argument_list|)
operator|==
name|MEM
operator|)
condition|)
name|simplify_replace_rtx
argument_list|(
name|REG_NOTES
argument_list|(
name|libcall_insn
argument_list|)
argument_list|,
name|sets
index|[
name|i
index|]
operator|.
name|orig_src
argument_list|,
name|copy_rtx
argument_list|(
name|new
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The result of apply_change_group can be ignored; see 		 canon_reg.  */
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
argument_list|,
name|new
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|apply_change_group
argument_list|()
expr_stmt|;
break|break;
block|}
comment|/* If we previously found constant pool entries for 	     constants and this is a constant, try making a 	     pool entry.  Put it in src_folded unless we already have done 	     this since that is where it likely came from.  */
elseif|else
if|if
condition|(
name|constant_pool_entries_cost
operator|&&
name|CONSTANT_P
argument_list|(
name|trial
argument_list|)
comment|/* Reject cases that will abort in decode_rtx_const. 		      On the alpha when simplifying a switch, we get 		      (const (truncate (minus (label_ref) (label_ref)))).  */
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|trial
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|trial
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|TRUNCATE
operator|)
comment|/* Likewise on IA-64, except without the truncate.  */
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|trial
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|trial
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MINUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|trial
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|trial
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|)
operator|&&
operator|(
name|src_folded
operator|==
literal|0
operator|||
operator|(
name|GET_CODE
argument_list|(
name|src_folded
argument_list|)
operator|!=
name|MEM
operator|&&
operator|!
name|src_folded_force_flag
operator|)
operator|)
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_CC
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
block|{
name|src_folded_force_flag
operator|=
literal|1
expr_stmt|;
name|src_folded
operator|=
name|trial
expr_stmt|;
name|src_folded_cost
operator|=
name|constant_pool_entries_cost
expr_stmt|;
name|src_folded_regcost
operator|=
name|constant_pool_entries_regcost
expr_stmt|;
block|}
block|}
name|src
operator|=
name|SET_SRC
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
expr_stmt|;
comment|/* In general, it is good to have a SET with SET_SRC == SET_DEST. 	 However, there is an important exception:  If both are registers 	 that are not the head of their equivalence class, replace SET_SRC 	 with the head of the class.  If we do not do this, we will have 	 both registers live over a portion of the basic block.  This way, 	 their lifetimes will likely abut instead of overlapping.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO_QTY_VALID_P
argument_list|(
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|dest_q
init|=
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|qty_table_elem
modifier|*
name|dest_ent
init|=
operator|&
name|qty_table
index|[
name|dest_q
index|]
decl_stmt|;
if|if
condition|(
name|dest_ent
operator|->
name|mode
operator|==
name|GET_MODE
argument_list|(
name|dest
argument_list|)
operator|&&
name|dest_ent
operator|->
name|first_reg
operator|!=
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|src
argument_list|)
operator|==
name|REGNO
argument_list|(
name|dest
argument_list|)
comment|/* Don't do this if the original insn had a hard reg as 		 SET_SRC or SET_DEST.  */
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|src
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|src
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
comment|/* We can't call canon_reg here because it won't do anything if 	       SRC is a hard register.  */
block|{
name|int
name|src_q
init|=
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|qty_table_elem
modifier|*
name|src_ent
init|=
operator|&
name|qty_table
index|[
name|src_q
index|]
decl_stmt|;
name|int
name|first
init|=
name|src_ent
operator|->
name|first_reg
decl_stmt|;
name|rtx
name|new_src
init|=
operator|(
name|first
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|?
name|regno_reg_rtx
index|[
name|first
index|]
else|:
name|gen_rtx_REG
argument_list|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|,
name|first
argument_list|)
operator|)
decl_stmt|;
comment|/* We must use validate-change even for this, because this 		 might be a special no-op instruction, suitable only to 		 tag notes onto.  */
if|if
condition|(
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
argument_list|,
name|new_src
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|src
operator|=
name|new_src
expr_stmt|;
comment|/* If we had a constant that is cheaper than what we are now 		     setting SRC to, use that constant.  We ignored it when we 		     thought we could make this into a no-op.  */
if|if
condition|(
name|src_const
operator|&&
name|COST
argument_list|(
name|src_const
argument_list|)
operator|<
name|COST
argument_list|(
name|src
argument_list|)
operator|&&
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
argument_list|,
name|src_const
argument_list|,
literal|0
argument_list|)
condition|)
name|src
operator|=
name|src_const
expr_stmt|;
block|}
block|}
block|}
comment|/* If we made a change, recompute SRC values.  */
if|if
condition|(
name|src
operator|!=
name|sets
index|[
name|i
index|]
operator|.
name|src
condition|)
block|{
name|cse_altered
operator|=
literal|1
expr_stmt|;
name|do_not_record
operator|=
literal|0
expr_stmt|;
name|hash_arg_in_memory
operator|=
literal|0
expr_stmt|;
name|sets
index|[
name|i
index|]
operator|.
name|src
operator|=
name|src
expr_stmt|;
name|sets
index|[
name|i
index|]
operator|.
name|src_hash
operator|=
name|HASH
argument_list|(
name|src
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|sets
index|[
name|i
index|]
operator|.
name|src_volatile
operator|=
name|do_not_record
expr_stmt|;
name|sets
index|[
name|i
index|]
operator|.
name|src_in_memory
operator|=
name|hash_arg_in_memory
expr_stmt|;
name|sets
index|[
name|i
index|]
operator|.
name|src_elt
operator|=
name|lookup
argument_list|(
name|src
argument_list|,
name|sets
index|[
name|i
index|]
operator|.
name|src_hash
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
comment|/* If this is a single SET, we are setting a register, and we have an 	 equivalent constant, we want to add a REG_NOTE.   We don't want 	 to write a REG_EQUAL note for a constant pseudo since verifying that 	 that pseudo hasn't been eliminated is a pain.  Such a note also 	 won't help anything.  	 Avoid a REG_EQUAL note for (CONST (MINUS (LABEL_REF) (LABEL_REF))) 	 which can be created for a reference to a compile time computable 	 entry in a jump table.  */
if|if
condition|(
name|n_sets
operator|==
literal|1
operator|&&
name|src_const
operator|&&
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|src_const
argument_list|)
operator|!=
name|REG
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|src_const
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src_const
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MINUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|src_const
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|src_const
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|)
condition|)
block|{
comment|/* We only want a REG_EQUAL note if src_const != src.  */
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|src
argument_list|,
name|src_const
argument_list|)
condition|)
block|{
comment|/* Make sure that the rtx is not shared.  */
name|src_const
operator|=
name|copy_rtx
argument_list|(
name|src_const
argument_list|)
expr_stmt|;
comment|/* Record the actual constant value in a REG_EQUAL note, 		 making a new one if one does not already exist.  */
name|set_unique_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUAL
argument_list|,
name|src_const
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now deal with the destination.  */
name|do_not_record
operator|=
literal|0
expr_stmt|;
comment|/* Look within any SIGN_EXTRACT or ZERO_EXTRACT 	 to the MEM or REG within it.  */
while|while
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|dest
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sets
index|[
name|i
index|]
operator|.
name|inner_dest
operator|=
name|dest
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
condition|)
block|{
ifdef|#
directive|ifdef
name|PUSH_ROUNDING
comment|/* Stack pushes invalidate the stack pointer.  */
name|rtx
name|addr
init|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
argument_list|)
operator|==
literal|'a'
operator|&&
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
operator|==
name|stack_pointer_rtx
condition|)
name|invalidate
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dest
operator|=
name|fold_rtx
argument_list|(
name|dest
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* Compute the hash code of the destination now, 	 before the effects of this instruction are recorded, 	 since the register values used in the address computation 	 are those before this instruction.  */
name|sets
index|[
name|i
index|]
operator|.
name|dest_hash
operator|=
name|HASH
argument_list|(
name|dest
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* Don't enter a bit-field in the hash table 	 because the value in it after the store 	 may not equal what was stored, due to truncation.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
argument_list|)
operator|==
name|SIGN_EXTRACT
condition|)
block|{
name|rtx
name|width
init|=
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|src_const
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|src_const
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|width
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|width
argument_list|)
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|!
operator|(
name|INTVAL
argument_list|(
name|src_const
argument_list|)
operator|&
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
name|INTVAL
argument_list|(
name|width
argument_list|)
operator|)
operator|)
condition|)
comment|/* Exception: if the value is constant, 	       and it won't be truncated, record it.  */
empty_stmt|;
else|else
block|{
comment|/* This is chosen so that the destination will be invalidated 		 but no new value will be recorded. 		 We must invalidate because sometimes constant 		 values can be recorded for bitfields.  */
name|sets
index|[
name|i
index|]
operator|.
name|src_elt
operator|=
literal|0
expr_stmt|;
name|sets
index|[
name|i
index|]
operator|.
name|src_volatile
operator|=
literal|1
expr_stmt|;
name|src_eqv
operator|=
literal|0
expr_stmt|;
name|src_eqv_elt
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* If only one set in a JUMP_INSN and it is now a no-op, we can delete 	 the insn.  */
elseif|else
if|if
condition|(
name|n_sets
operator|==
literal|1
operator|&&
name|dest
operator|==
name|pc_rtx
operator|&&
name|src
operator|==
name|pc_rtx
condition|)
block|{
comment|/* One less use of the label this insn used to jump to.  */
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|cse_jumps_altered
operator|=
literal|1
expr_stmt|;
comment|/* No more processing for this set.  */
name|sets
index|[
name|i
index|]
operator|.
name|rtl
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If this SET is now setting PC to a label, we know it used to 	 be a conditional or computed branch.  */
elseif|else
if|if
condition|(
name|dest
operator|==
name|pc_rtx
operator|&&
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|LABEL_REF
condition|)
block|{
comment|/* Now emit a BARRIER after the unconditional jump.  */
if|if
condition|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|BARRIER
condition|)
name|emit_barrier_after
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* We reemit the jump in as many cases as possible just in 	     case the form of an unconditional jump is significantly 	     different than a computed jump or conditional jump.  	     If this insn has multiple sets, then reemitting the 	     jump is nontrivial.  So instead we just force rerecognition 	     and hope for the best.  */
if|if
condition|(
name|n_sets
operator|==
literal|1
condition|)
block|{
name|rtx
name|new
init|=
name|emit_jump_insn_after
argument_list|(
name|gen_jump
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
decl_stmt|;
name|JUMP_LABEL
argument_list|(
name|new
argument_list|)
operator|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|++
expr_stmt|;
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|insn
operator|=
name|new
expr_stmt|;
comment|/* Now emit a BARRIER after the unconditional jump.  */
if|if
condition|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|BARRIER
condition|)
name|emit_barrier_after
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
else|else
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|never_reached_warning
argument_list|(
name|insn
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Do not bother deleting any unreachable code, 	     let jump/flow do that.  */
name|cse_jumps_altered
operator|=
literal|1
expr_stmt|;
name|sets
index|[
name|i
index|]
operator|.
name|rtl
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If destination is volatile, invalidate it and then do no further 	 processing for this assignment.  */
elseif|else
if|if
condition|(
name|do_not_record
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
condition|)
name|invalidate
argument_list|(
name|dest
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
condition|)
block|{
comment|/* Outgoing arguments for a libcall don't 		 affect any recorded expressions.  */
if|if
condition|(
operator|!
name|libcall_insn
operator|||
name|insn
operator|==
name|libcall_insn
condition|)
name|invalidate
argument_list|(
name|dest
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
name|invalidate
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
name|sets
index|[
name|i
index|]
operator|.
name|rtl
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
operator|!=
literal|0
operator|&&
name|dest
operator|!=
name|SET_DEST
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
condition|)
name|sets
index|[
name|i
index|]
operator|.
name|dest_hash
operator|=
name|HASH
argument_list|(
name|SET_DEST
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* If setting CC0, record what it was set to, or a constant, if it 	 is equivalent to a constant.  If it is being set to a floating-point 	 value, make a COMPARE with the appropriate constant of 0.  If we 	 don't do this, later code can interpret this as a test against 	 const0_rtx, which can cause problems if we try to put it into an 	 insn as a floating-point operand.  */
if|if
condition|(
name|dest
operator|==
name|cc0_rtx
condition|)
block|{
name|this_insn_cc0
operator|=
name|src_const
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|?
name|src_const
else|:
name|src
expr_stmt|;
name|this_insn_cc0_mode
operator|=
name|mode
expr_stmt|;
if|if
condition|(
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
name|this_insn_cc0
operator|=
name|gen_rtx_COMPARE
argument_list|(
name|VOIDmode
argument_list|,
name|this_insn_cc0
argument_list|,
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
comment|/* Now enter all non-volatile source expressions in the hash table      if they are not already present.      Record their equivalence classes in src_elt.      This way we can insert the corresponding destinations into      the same classes even if the actual sources are no longer in them      (having been invalidated).  */
if|if
condition|(
name|src_eqv
operator|&&
name|src_eqv_elt
operator|==
literal|0
operator|&&
name|sets
index|[
literal|0
index|]
operator|.
name|rtl
operator|!=
literal|0
operator|&&
operator|!
name|src_eqv_volatile
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|src_eqv
argument_list|,
name|SET_DEST
argument_list|(
name|sets
index|[
literal|0
index|]
operator|.
name|rtl
argument_list|)
argument_list|)
condition|)
block|{
name|struct
name|table_elt
modifier|*
name|elt
decl_stmt|;
name|struct
name|table_elt
modifier|*
name|classp
init|=
name|sets
index|[
literal|0
index|]
operator|.
name|src_elt
decl_stmt|;
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|sets
index|[
literal|0
index|]
operator|.
name|rtl
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|eqvmode
init|=
name|GET_MODE
argument_list|(
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
block|{
name|eqvmode
operator|=
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|classp
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|insert_regs
argument_list|(
name|src_eqv
argument_list|,
name|classp
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|rehash_using_reg
argument_list|(
name|src_eqv
argument_list|)
expr_stmt|;
name|src_eqv_hash
operator|=
name|HASH
argument_list|(
name|src_eqv
argument_list|,
name|eqvmode
argument_list|)
expr_stmt|;
block|}
name|elt
operator|=
name|insert
argument_list|(
name|src_eqv
argument_list|,
name|classp
argument_list|,
name|src_eqv_hash
argument_list|,
name|eqvmode
argument_list|)
expr_stmt|;
name|elt
operator|->
name|in_memory
operator|=
name|src_eqv_in_memory
expr_stmt|;
name|src_eqv_elt
operator|=
name|elt
expr_stmt|;
comment|/* Check to see if src_eqv_elt is the same as a set source which 	 does not yet have an elt, and if so set the elt of the set source 	 to src_eqv_elt.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_sets
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
operator|&&
name|sets
index|[
name|i
index|]
operator|.
name|src_elt
operator|==
literal|0
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_SRC
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
argument_list|,
name|src_eqv
argument_list|)
condition|)
name|sets
index|[
name|i
index|]
operator|.
name|src_elt
operator|=
name|src_eqv_elt
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_sets
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
operator|&&
operator|!
name|sets
index|[
name|i
index|]
operator|.
name|src_volatile
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|SET_SRC
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
argument_list|,
name|SET_DEST
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
block|{
comment|/* REG_EQUAL in setting a STRICT_LOW_PART 	       gives an equivalent for the entire destination register, 	       not just for the subreg being stored in now. 	       This is a more interesting equivalence, so we arrange later 	       to treat the entire reg as the destination.  */
name|sets
index|[
name|i
index|]
operator|.
name|src_elt
operator|=
name|src_eqv_elt
expr_stmt|;
name|sets
index|[
name|i
index|]
operator|.
name|src_hash
operator|=
name|src_eqv_hash
expr_stmt|;
block|}
else|else
block|{
comment|/* Insert source and constant equivalent into hash table, if not 	       already present.  */
name|struct
name|table_elt
modifier|*
name|classp
init|=
name|src_eqv_elt
decl_stmt|;
name|rtx
name|src
init|=
name|sets
index|[
name|i
index|]
operator|.
name|src
decl_stmt|;
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|src
argument_list|)
operator|==
name|VOIDmode
condition|?
name|GET_MODE
argument_list|(
name|dest
argument_list|)
else|:
name|GET_MODE
argument_list|(
name|src
argument_list|)
decl_stmt|;
comment|/* It's possible that we have a source value known to be 	       constant but don't have a REG_EQUAL note on the insn. 	       Lack of a note will mean src_eqv_elt will be NULL.  This 	       can happen where we've generated a SUBREG to access a 	       CONST_INT that is already in a register in a wider mode. 	       Ensure that the source expression is put in the proper 	       constant class.  */
if|if
condition|(
operator|!
name|classp
condition|)
name|classp
operator|=
name|sets
index|[
name|i
index|]
operator|.
name|src_const_elt
expr_stmt|;
if|if
condition|(
name|sets
index|[
name|i
index|]
operator|.
name|src_elt
operator|==
literal|0
condition|)
block|{
comment|/* Don't put a hard register source into the table if this is 		   the last insn of a libcall.  In this case, we only need 		   to put src_eqv_elt in src_elt.  */
if|if
condition|(
operator|!
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
block|{
name|struct
name|table_elt
modifier|*
name|elt
decl_stmt|;
comment|/* Note that these insert_regs calls cannot remove 		       any of the src_elt's, because they would have failed to 		       match if not still valid.  */
if|if
condition|(
name|insert_regs
argument_list|(
name|src
argument_list|,
name|classp
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|rehash_using_reg
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|sets
index|[
name|i
index|]
operator|.
name|src_hash
operator|=
name|HASH
argument_list|(
name|src
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
name|elt
operator|=
name|insert
argument_list|(
name|src
argument_list|,
name|classp
argument_list|,
name|sets
index|[
name|i
index|]
operator|.
name|src_hash
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|elt
operator|->
name|in_memory
operator|=
name|sets
index|[
name|i
index|]
operator|.
name|src_in_memory
expr_stmt|;
name|sets
index|[
name|i
index|]
operator|.
name|src_elt
operator|=
name|classp
operator|=
name|elt
expr_stmt|;
block|}
else|else
name|sets
index|[
name|i
index|]
operator|.
name|src_elt
operator|=
name|classp
expr_stmt|;
block|}
if|if
condition|(
name|sets
index|[
name|i
index|]
operator|.
name|src_const
operator|&&
name|sets
index|[
name|i
index|]
operator|.
name|src_const_elt
operator|==
literal|0
operator|&&
name|src
operator|!=
name|sets
index|[
name|i
index|]
operator|.
name|src_const
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|src_const
argument_list|,
name|src
argument_list|)
condition|)
name|sets
index|[
name|i
index|]
operator|.
name|src_elt
operator|=
name|insert
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|src_const
argument_list|,
name|classp
argument_list|,
name|sets
index|[
name|i
index|]
operator|.
name|src_const_hash
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sets
index|[
name|i
index|]
operator|.
name|src_elt
operator|==
literal|0
condition|)
comment|/* If we did not insert the source into the hash table (e.g., it was 	 volatile), note the equivalence class for the REG_EQUAL value, if any, 	 so that the destination goes into that class.  */
name|sets
index|[
name|i
index|]
operator|.
name|src_elt
operator|=
name|src_eqv_elt
expr_stmt|;
name|invalidate_from_clobbers
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* Some registers are invalidated by subroutine calls.  Memory is      invalidated by non-constant calls.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
if|if
condition|(
operator|!
name|CONST_OR_PURE_CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
name|invalidate_memory
argument_list|()
expr_stmt|;
name|invalidate_for_call
argument_list|()
expr_stmt|;
block|}
comment|/* Now invalidate everything set by this instruction.      If a SUBREG or other funny destination is being set,      sets[i].rtl is still nonzero, so here we invalidate the reg      a part of which is being set.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_sets
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
condition|)
block|{
comment|/* We can't use the inner dest, because the mode associated with 	   a ZERO_EXTRACT is significant.  */
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
decl_stmt|;
comment|/* Needed for registers to remove the register from its 	   previous quantity's chain. 	   Needed for memory if this is a nonvarying address, unless 	   we have just done an invalidate_memory that covers even those.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
condition|)
name|invalidate
argument_list|(
name|dest
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
condition|)
block|{
comment|/* Outgoing arguments for a libcall don't 	       affect any recorded expressions.  */
if|if
condition|(
operator|!
name|libcall_insn
operator|||
name|insn
operator|==
name|libcall_insn
condition|)
name|invalidate
argument_list|(
name|dest
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
name|invalidate
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* A volatile ASM invalidates everything.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ASM_OPERANDS
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
name|flush_hash_table
argument_list|()
expr_stmt|;
comment|/* Make sure registers mentioned in destinations      are safe for use in an expression to be inserted.      This removes from the hash table      any invalid entry that refers to one of these registers.       We don't care about the return value from mention_regs because      we are going to hash the SET_DEST values unconditionally.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_sets
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
condition|)
block|{
name|rtx
name|x
init|=
name|SET_DEST
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
condition|)
name|mention_regs
argument_list|(
name|x
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* We used to rely on all references to a register becoming 		 inaccessible when a register changes to a new quantity, 		 since that changes the hash code.  However, that is not 		 safe, since after HASH_SIZE new quantities we get a 		 hash 'collision' of a register with its own invalid 		 entries.  And since SUBREGs have been changed not to 		 change their hash code with the hash code of the register, 		 it wouldn't work any longer at all.  So we have to check 		 for any invalid references lying around now. 		 This code is similar to the REG case in mention_regs, 		 but it knows that reg_tick has been incremented, and 		 it leaves reg_in_table as -1 .  */
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|endregno
init|=
name|regno
operator|+
operator|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|?
literal|1
else|:
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|regno
init|;
name|i
operator|<
name|endregno
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|REG_IN_TABLE
argument_list|(
name|i
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|remove_invalid_refs
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|REG_IN_TABLE
argument_list|(
name|i
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/* We may have just removed some of the src_elt's from the hash table.      So replace each one with the current head of the same class.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_sets
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
condition|)
block|{
if|if
condition|(
name|sets
index|[
name|i
index|]
operator|.
name|src_elt
operator|&&
name|sets
index|[
name|i
index|]
operator|.
name|src_elt
operator|->
name|first_same_value
operator|==
literal|0
condition|)
comment|/* If elt was removed, find current head of same class, 	     or 0 if nothing remains of that class.  */
block|{
name|struct
name|table_elt
modifier|*
name|elt
init|=
name|sets
index|[
name|i
index|]
operator|.
name|src_elt
decl_stmt|;
while|while
condition|(
name|elt
operator|&&
name|elt
operator|->
name|prev_same_value
condition|)
name|elt
operator|=
name|elt
operator|->
name|prev_same_value
expr_stmt|;
while|while
condition|(
name|elt
operator|&&
name|elt
operator|->
name|first_same_value
operator|==
literal|0
condition|)
name|elt
operator|=
name|elt
operator|->
name|next_same_value
expr_stmt|;
name|sets
index|[
name|i
index|]
operator|.
name|src_elt
operator|=
name|elt
condition|?
name|elt
operator|->
name|first_same_value
else|:
literal|0
expr_stmt|;
block|}
block|}
comment|/* Now insert the destinations into their equivalence classes.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_sets
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
condition|)
block|{
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|rtl
argument_list|)
decl_stmt|;
name|rtx
name|inner_dest
init|=
name|sets
index|[
name|i
index|]
operator|.
name|inner_dest
decl_stmt|;
name|struct
name|table_elt
modifier|*
name|elt
decl_stmt|;
comment|/* Don't record value if we are not supposed to risk allocating 	   floating-point values in registers that might be wider than 	   memory.  */
if|if
condition|(
operator|(
name|flag_float_store
operator|&&
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
operator|&&
name|FLOAT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|)
comment|/* Don't record BLKmode values, because we don't know the 	       size of it, and can't be sure that other BLKmode values 	       have the same or smaller size.  */
operator|||
name|GET_MODE
argument_list|(
name|dest
argument_list|)
operator|==
name|BLKmode
comment|/* Don't record values of destinations set inside a libcall block 	       since we might delete the libcall.  Things should have been set 	       up so we won't want to reuse such a value, but we play it safe 	       here.  */
operator|||
name|libcall_insn
comment|/* If we didn't put a REG_EQUAL value or a source into the hash 	       table, there is no point is recording DEST.  */
operator|||
name|sets
index|[
name|i
index|]
operator|.
name|src_elt
operator|==
literal|0
comment|/* If DEST is a paradoxical SUBREG and SRC is a ZERO_EXTEND 	       or SIGN_EXTEND, don't record DEST since it can cause 	       some tracking to be wrong.  	       ??? Think about this more later.  */
operator|||
operator|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|src
argument_list|)
operator|==
name|SIGN_EXTEND
operator|||
name|GET_CODE
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|src
argument_list|)
operator|==
name|ZERO_EXTEND
operator|)
operator|)
condition|)
continue|continue;
comment|/* STRICT_LOW_PART isn't part of the value BEING set, 	   and neither is the SUBREG inside it. 	   Note that in this case SETS[I].SRC_ELT is really SRC_EQV_ELT.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|dest
operator|=
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
condition|)
comment|/* Registers must also be inserted into chains for quantities.  */
if|if
condition|(
name|insert_regs
argument_list|(
name|dest
argument_list|,
name|sets
index|[
name|i
index|]
operator|.
name|src_elt
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|/* If `insert_regs' changes something, the hash code must be 		 recalculated.  */
name|rehash_using_reg
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|sets
index|[
name|i
index|]
operator|.
name|dest_hash
operator|=
name|HASH
argument_list|(
name|dest
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|inner_dest
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|inner_dest
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDRESSOF
condition|)
comment|/* Given (SET (MEM (ADDRESSOF (X))) Y) we don't want to say 	     that (MEM (ADDRESSOF (X))) is equivalent to Y. 	     Consider the case in which the address of the MEM is 	     passed to a function, which alters the MEM.  Then, if we 	     later use Y instead of the MEM we'll miss the update.  */
name|elt
operator|=
name|insert
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|,
name|sets
index|[
name|i
index|]
operator|.
name|dest_hash
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|elt
operator|=
name|insert
argument_list|(
name|dest
argument_list|,
name|sets
index|[
name|i
index|]
operator|.
name|src_elt
argument_list|,
name|sets
index|[
name|i
index|]
operator|.
name|dest_hash
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
name|elt
operator|->
name|in_memory
operator|=
operator|(
name|GET_CODE
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|inner_dest
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
operator|!
name|RTX_UNCHANGING_P
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|inner_dest
argument_list|)
operator|||
name|fixed_base_plus_p
argument_list|(
name|XEXP
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|inner_dest
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|)
expr_stmt|;
comment|/* If we have (set (subreg:m1 (reg:m2 foo) 0) (bar:m1)), M1 is no 	   narrower than M2, and both M1 and M2 are the same number of words, 	   we are also doing (set (reg:m2 foo) (subreg:m2 (bar:m1) 0)) so 	   make that equivalence as well.  	   However, BAR may have equivalences for which gen_lowpart_if_possible 	   will produce a simpler value than gen_lowpart_if_possible applied to 	   BAR (e.g., if BAR was ZERO_EXTENDed from M2), so we will scan all 	   BAR's equivalences.  If we don't get a simplified form, make 	   the SUBREG.  It will not be used in an equivalence, but will 	   cause two similar assignments to be detected.  	   Note the loop below will find SUBREG_REG (DEST) since we have 	   already entered SRC and DEST of the SET in the table.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
argument_list|)
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|==
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|>=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
name|sets
index|[
name|i
index|]
operator|.
name|src_elt
operator|!=
literal|0
condition|)
block|{
name|enum
name|machine_mode
name|new_mode
init|=
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|table_elt
modifier|*
name|elt
decl_stmt|,
modifier|*
name|classp
init|=
literal|0
decl_stmt|;
for|for
control|(
name|elt
operator|=
name|sets
index|[
name|i
index|]
operator|.
name|src_elt
operator|->
name|first_same_value
init|;
name|elt
condition|;
name|elt
operator|=
name|elt
operator|->
name|next_same_value
control|)
block|{
name|rtx
name|new_src
init|=
literal|0
decl_stmt|;
name|unsigned
name|src_hash
decl_stmt|;
name|struct
name|table_elt
modifier|*
name|src_elt
decl_stmt|;
name|int
name|byte
init|=
literal|0
decl_stmt|;
comment|/* Ignore invalid entries.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|elt
operator|->
name|exp
argument_list|)
operator|!=
name|REG
operator|&&
operator|!
name|exp_equiv_p
argument_list|(
name|elt
operator|->
name|exp
argument_list|,
name|elt
operator|->
name|exp
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
continue|continue;
comment|/* We may have already been playing subreg games.  If the 		   mode is already correct for the destination, use it.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|elt
operator|->
name|exp
argument_list|)
operator|==
name|new_mode
condition|)
name|new_src
operator|=
name|elt
operator|->
name|exp
expr_stmt|;
else|else
block|{
comment|/* Calculate big endian correction for the SUBREG_BYTE. 		       We have already checked that M1 (GET_MODE (dest)) 		       is not narrower than M2 (new_mode).  */
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
name|byte
operator|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|-
name|GET_MODE_SIZE
argument_list|(
name|new_mode
argument_list|)
operator|)
expr_stmt|;
name|new_src
operator|=
name|simplify_gen_subreg
argument_list|(
name|new_mode
argument_list|,
name|elt
operator|->
name|exp
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|,
name|byte
argument_list|)
expr_stmt|;
block|}
comment|/* The call to simplify_gen_subreg fails if the value 		   is VOIDmode, yet we can't do any simplification, e.g. 		   for EXPR_LISTs denoting function call results. 		   It is invalid to construct a SUBREG with a VOIDmode 		   SUBREG_REG, hence a zero new_src means we can't do 		   this substitution.  */
if|if
condition|(
operator|!
name|new_src
condition|)
continue|continue;
name|src_hash
operator|=
name|HASH
argument_list|(
name|new_src
argument_list|,
name|new_mode
argument_list|)
expr_stmt|;
name|src_elt
operator|=
name|lookup
argument_list|(
name|new_src
argument_list|,
name|src_hash
argument_list|,
name|new_mode
argument_list|)
expr_stmt|;
comment|/* Put the new source in the hash table is if isn't 		   already.  */
if|if
condition|(
name|src_elt
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|insert_regs
argument_list|(
name|new_src
argument_list|,
name|classp
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|rehash_using_reg
argument_list|(
name|new_src
argument_list|)
expr_stmt|;
name|src_hash
operator|=
name|HASH
argument_list|(
name|new_src
argument_list|,
name|new_mode
argument_list|)
expr_stmt|;
block|}
name|src_elt
operator|=
name|insert
argument_list|(
name|new_src
argument_list|,
name|classp
argument_list|,
name|src_hash
argument_list|,
name|new_mode
argument_list|)
expr_stmt|;
name|src_elt
operator|->
name|in_memory
operator|=
name|elt
operator|->
name|in_memory
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|classp
operator|&&
name|classp
operator|!=
name|src_elt
operator|->
name|first_same_value
condition|)
comment|/* Show that two things that we've seen before are 		     actually the same.  */
name|merge_equiv_classes
argument_list|(
name|src_elt
argument_list|,
name|classp
argument_list|)
expr_stmt|;
name|classp
operator|=
name|src_elt
operator|->
name|first_same_value
expr_stmt|;
comment|/* Ignore invalid entries.  */
while|while
condition|(
name|classp
operator|&&
name|GET_CODE
argument_list|(
name|classp
operator|->
name|exp
argument_list|)
operator|!=
name|REG
operator|&&
operator|!
name|exp_equiv_p
argument_list|(
name|classp
operator|->
name|exp
argument_list|,
name|classp
operator|->
name|exp
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
name|classp
operator|=
name|classp
operator|->
name|next_same_value
expr_stmt|;
block|}
block|}
block|}
comment|/* Special handling for (set REG0 REG1) where REG0 is the      "cheapest", cheaper than REG1.  After cse, REG1 will probably not      be used in the sequel, so (if easily done) change this insn to      (set REG1 REG0) and replace REG1 with REG0 in the previous insn      that computed their value.  Then REG1 will become a dead store      and won't cloud the situation for later optimizations.       Do not make this change if REG1 is a hard register, because it will      then be used in the sequel and we may be changing a two-operand insn      into a three-operand insn.       Also do not do this if we are operating on a copy of INSN.       Also don't do this if INSN ends a libcall; this would cause an unrelated      register to be set in the middle of a libcall, and we then get bad code      if the libcall is deleted.  */
if|if
condition|(
name|n_sets
operator|==
literal|1
operator|&&
name|sets
index|[
literal|0
index|]
operator|.
name|rtl
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|sets
index|[
literal|0
index|]
operator|.
name|rtl
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|NEXT_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|sets
index|[
literal|0
index|]
operator|.
name|rtl
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|sets
index|[
literal|0
index|]
operator|.
name|rtl
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|REGNO_QTY_VALID_P
argument_list|(
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|sets
index|[
literal|0
index|]
operator|.
name|rtl
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|src_q
init|=
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|sets
index|[
literal|0
index|]
operator|.
name|rtl
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|qty_table_elem
modifier|*
name|src_ent
init|=
operator|&
name|qty_table
index|[
name|src_q
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|src_ent
operator|->
name|first_reg
operator|==
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|sets
index|[
literal|0
index|]
operator|.
name|rtl
argument_list|)
argument_list|)
operator|)
operator|&&
operator|!
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
block|{
name|rtx
name|prev
init|=
name|insn
decl_stmt|;
comment|/* Scan for the previous nonnote insn, but stop at a basic 	     block boundary.  */
do|do
block|{
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|prev
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|prev
operator|&&
name|GET_CODE
argument_list|(
name|prev
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|prev
argument_list|)
operator|!=
name|NOTE_INSN_BASIC_BLOCK
condition|)
do|;
comment|/* Do not swap the registers around if the previous instruction 	     attaches a REG_EQUIV note to REG1.  	     ??? It's not entirely clear whether we can transfer a REG_EQUIV 	     from the pseudo that originally shadowed an incoming argument 	     to another register.  Some uses of REG_EQUIV might rely on it 	     being attached to REG1 rather than REG2.  	     This section previously turned the REG_EQUIV into a REG_EQUAL 	     note.  We cannot do that because REG_EQUIV may provide an 	     uninitialized stack slot when REG_PARM_STACK_SPACE is used.  */
if|if
condition|(
name|prev
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|prev
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|)
operator|==
name|SET_SRC
argument_list|(
name|sets
index|[
literal|0
index|]
operator|.
name|rtl
argument_list|)
operator|&&
operator|!
name|find_reg_note
argument_list|(
name|prev
argument_list|,
name|REG_EQUIV
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
block|{
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|sets
index|[
literal|0
index|]
operator|.
name|rtl
argument_list|)
decl_stmt|;
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|sets
index|[
literal|0
index|]
operator|.
name|rtl
argument_list|)
decl_stmt|;
name|rtx
name|note
decl_stmt|;
name|validate_change
argument_list|(
name|prev
argument_list|,
operator|&
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|)
argument_list|,
name|dest
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_DEST
argument_list|(
name|sets
index|[
literal|0
index|]
operator|.
name|rtl
argument_list|)
argument_list|,
name|src
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|sets
index|[
literal|0
index|]
operator|.
name|rtl
argument_list|)
argument_list|,
name|dest
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|apply_change_group
argument_list|()
expr_stmt|;
comment|/* If INSN has a REG_EQUAL note, and this note mentions 		 REG0, then we must delete it, because the value in 		 REG0 has changed.  If the note's value is REG1, we must 		 also delete it because that is now this insn's dest.  */
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
operator|!=
literal|0
operator|&&
operator|(
name|reg_mentioned_p
argument_list|(
name|dest
argument_list|,
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|rtx_equal_p
argument_list|(
name|src
argument_list|,
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
name|remove_note
argument_list|(
name|insn
argument_list|,
name|note
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* If this is a conditional jump insn, record any known equivalences due to      the condition being tested.  */
name|last_jump_equiv_class
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|n_sets
operator|==
literal|1
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|IF_THEN_ELSE
condition|)
name|record_jump_equiv
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* If the previous insn set CC0 and this insn no longer references CC0,      delete the previous insn.  Here we use the fact that nothing expects CC0      to be valid over an insn, which is true until the final pass.  */
if|if
condition|(
name|prev_insn
operator|&&
name|GET_CODE
argument_list|(
name|prev_insn
argument_list|)
operator|==
name|INSN
operator|&&
operator|(
name|tem
operator|=
name|single_set
argument_list|(
name|prev_insn
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|SET_DEST
argument_list|(
name|tem
argument_list|)
operator|==
name|cc0_rtx
operator|&&
operator|!
name|reg_mentioned_p
argument_list|(
name|cc0_rtx
argument_list|,
name|x
argument_list|)
condition|)
name|delete_insn
argument_list|(
name|prev_insn
argument_list|)
expr_stmt|;
name|prev_insn_cc0
operator|=
name|this_insn_cc0
expr_stmt|;
name|prev_insn_cc0_mode
operator|=
name|this_insn_cc0_mode
expr_stmt|;
name|prev_insn
operator|=
name|insn
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Remove from the hash table all expressions that reference memory.  */
end_comment

begin_function
specifier|static
name|void
name|invalidate_memory
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|table_elt
modifier|*
name|p
decl_stmt|,
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HASH_SIZE
condition|;
name|i
operator|++
control|)
for|for
control|(
name|p
operator|=
name|table
index|[
name|i
index|]
init|;
name|p
condition|;
name|p
operator|=
name|next
control|)
block|{
name|next
operator|=
name|p
operator|->
name|next_same_hash
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|in_memory
condition|)
name|remove_from_table
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* If ADDR is an address that implicitly affects the stack pointer, return    1 and update the register tables to show the effect.  Else, return 0.  */
end_comment

begin_function
specifier|static
name|int
name|addr_affects_sp_p
parameter_list|(
name|rtx
name|addr
parameter_list|)
block|{
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
argument_list|)
operator|==
literal|'a'
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|STACK_POINTER_REGNUM
condition|)
block|{
if|if
condition|(
name|REG_TICK
argument_list|(
name|STACK_POINTER_REGNUM
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|REG_TICK
argument_list|(
name|STACK_POINTER_REGNUM
argument_list|)
operator|++
expr_stmt|;
comment|/* Is it possible to use a subreg of SP?  */
name|SUBREG_TICKED
argument_list|(
name|STACK_POINTER_REGNUM
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* This should be *very* rare.  */
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|hard_regs_in_table
argument_list|,
name|STACK_POINTER_REGNUM
argument_list|)
condition|)
name|invalidate
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Perform invalidation on the basis of everything about an insn    except for invalidating the actual places that are SET in it.    This includes the places CLOBBERed, and anything that might    alias with something that is SET or CLOBBERed.     X is the pattern of the insn.  */
end_comment

begin_function
specifier|static
name|void
name|invalidate_from_clobbers
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CLOBBER
condition|)
block|{
name|rtx
name|ref
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|ref
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|MEM
condition|)
name|invalidate
argument_list|(
name|ref
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
name|invalidate
argument_list|(
name|XEXP
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|ref
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|rtx
name|y
init|=
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|CLOBBER
condition|)
block|{
name|rtx
name|ref
init|=
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|MEM
condition|)
name|invalidate
argument_list|(
name|ref
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
name|invalidate
argument_list|(
name|XEXP
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|ref
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Process X, part of the REG_NOTES of an insn.  Look at any REG_EQUAL notes    and replace any registers in them with either an equivalent constant    or the canonical form of the register.  If we are inside an address,    only do this if the address remains valid.     OBJECT is 0 except when within a MEM in which case it is the MEM.     Return the replacement for X.  */
end_comment

begin_function
specifier|static
name|rtx
name|cse_process_notes
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|object
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST_INT
case|:
case|case
name|CONST
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_VECTOR
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|LO_SUM
case|:
return|return
name|x
return|;
case|case
name|MEM
case|:
name|validate_change
argument_list|(
name|x
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|cse_process_notes
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|x
return|;
case|case
name|EXPR_LIST
case|:
case|case
name|INSN_LIST
case|:
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|x
argument_list|)
operator|==
name|REG_EQUAL
condition|)
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|cse_process_notes
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|=
name|cse_process_notes
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
return|return
name|x
return|;
case|case
name|SIGN_EXTEND
case|:
case|case
name|ZERO_EXTEND
case|:
case|case
name|SUBREG
case|:
block|{
name|rtx
name|new
init|=
name|cse_process_notes
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|object
argument_list|)
decl_stmt|;
comment|/* We don't substitute VOIDmode constants into these rtx, 	   since they would impede folding.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|new
argument_list|)
operator|!=
name|VOIDmode
condition|)
name|validate_change
argument_list|(
name|object
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|new
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
case|case
name|REG
case|:
name|i
operator|=
name|REG_QTY
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Return a constant or a constant register.  */
if|if
condition|(
name|REGNO_QTY_VALID_P
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
name|struct
name|qty_table_elem
modifier|*
name|ent
init|=
operator|&
name|qty_table
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|ent
operator|->
name|const_rtx
operator|!=
name|NULL_RTX
operator|&&
operator|(
name|CONSTANT_P
argument_list|(
name|ent
operator|->
name|const_rtx
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|ent
operator|->
name|const_rtx
argument_list|)
operator|==
name|REG
operator|)
condition|)
block|{
name|rtx
name|new
init|=
name|gen_lowpart_if_possible
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|ent
operator|->
name|const_rtx
argument_list|)
decl_stmt|;
if|if
condition|(
name|new
condition|)
return|return
name|new
return|;
block|}
block|}
comment|/* Otherwise, canonicalize this register.  */
return|return
name|canon_reg
argument_list|(
name|x
argument_list|,
name|NULL_RTX
argument_list|)
return|;
default|default:
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|validate_change
argument_list|(
name|object
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|cse_process_notes
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|object
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find common subexpressions between the end test of a loop and the beginning    of the loop.  LOOP_START is the CODE_LABEL at the start of a loop.     Often we have a loop where an expression in the exit test is used    in the body of the loop.  For example "while (*p) *q++ = *p++;".    Because of the way we duplicate the loop exit test in front of the loop,    however, we don't detect that common subexpression.  This will be caught    when global cse is implemented, but this is a quite common case.     This function handles the most common cases of these common expressions.    It is called after we have processed the basic block ending with the    NOTE_INSN_LOOP_END note that ends a loop and the previous JUMP_INSN    jumps to a label used only once.  */
end_comment

begin_function
specifier|static
name|void
name|cse_around_loop
parameter_list|(
name|rtx
name|loop_start
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|table_elt
modifier|*
name|p
decl_stmt|;
comment|/* If the jump at the end of the loop doesn't go to the start, we don't      do anything.  */
for|for
control|(
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|loop_start
argument_list|)
init|;
name|insn
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|>=
literal|0
operator|)
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
name|insn
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_LOOP_BEG
condition|)
return|return;
comment|/* If the last insn of the loop (the end test) was an NE comparison,      we will interpret it as an EQ comparison, since we fell through      the loop.  Any equivalences resulting from that comparison are      therefore not valid and must be invalidated.  */
if|if
condition|(
name|last_jump_equiv_class
condition|)
for|for
control|(
name|p
operator|=
name|last_jump_equiv_class
operator|->
name|first_same_value
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next_same_value
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
operator|->
name|exp
argument_list|)
operator|==
name|MEM
operator|||
name|GET_CODE
argument_list|(
name|p
operator|->
name|exp
argument_list|)
operator|==
name|REG
operator|||
operator|(
name|GET_CODE
argument_list|(
name|p
operator|->
name|exp
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|p
operator|->
name|exp
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
condition|)
name|invalidate
argument_list|(
name|p
operator|->
name|exp
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
operator|->
name|exp
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|p
operator|->
name|exp
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
name|invalidate
argument_list|(
name|XEXP
argument_list|(
name|p
operator|->
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|p
operator|->
name|exp
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Process insns starting after LOOP_START until we hit a CALL_INSN or      a CODE_LABEL (we could handle a CALL_INSN, but it isn't worth it).       The only thing we do with SET_DEST is invalidate entries, so we      can safely process each SET in order.  It is slightly less efficient      to do so, but we only want to handle the most common cases.       The gen_move_insn call in cse_set_around_loop may create new pseudos.      These pseudos won't have valid entries in any of the tables indexed      by register number, such as reg_qty.  We avoid out-of-range array      accesses by not processing any instructions created after cse started.  */
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|loop_start
argument_list|)
init|;
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|CALL_INSN
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|CODE_LABEL
operator|&&
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|<
name|max_insn_uid
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_END
operator|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
operator|)
condition|)
name|cse_set_around_loop
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
name|loop_start
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|)
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
name|cse_set_around_loop
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|,
name|loop_start
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Process one SET of an insn that was skipped.  We ignore CLOBBERs    since they are done elsewhere.  This function is called via note_stores.  */
end_comment

begin_function
specifier|static
name|void
name|invalidate_skipped_set
parameter_list|(
name|rtx
name|dest
parameter_list|,
name|rtx
name|set
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|MEM
operator|&&
operator|!
name|addr_affects_sp_p
argument_list|(
name|dest
argument_list|)
comment|/* If this is not a stack push ...  */
comment|/* There are times when an address can appear varying and be a PLUS 	 during this scan when it would be a fixed address were we to know 	 the proper equivalences.  So invalidate all memory if there is 	 a BLKmode or nonscalar memory reference or a reference to a 	 variable address.  */
operator|&&
operator|(
name|MEM_IN_STRUCT_P
argument_list|(
name|dest
argument_list|)
operator|||
name|GET_MODE
argument_list|(
name|dest
argument_list|)
operator|==
name|BLKmode
operator|||
name|cse_rtx_varies_p
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|invalidate_memory
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|set
argument_list|)
operator|==
name|CLOBBER
operator|||
name|CC0_P
argument_list|(
name|dest
argument_list|)
operator|||
name|dest
operator|==
name|pc_rtx
condition|)
return|return;
if|if
condition|(
name|code
operator|==
name|STRICT_LOW_PART
operator|||
name|code
operator|==
name|ZERO_EXTRACT
condition|)
name|invalidate
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|REG
operator|||
name|code
operator|==
name|SUBREG
operator|||
name|code
operator|==
name|MEM
condition|)
name|invalidate
argument_list|(
name|dest
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Invalidate all insns from START up to the end of the function or the    next label.  This called when we wish to CSE around a block that is    conditionally executed.  */
end_comment

begin_function
specifier|static
name|void
name|invalidate_skipped_block
parameter_list|(
name|rtx
name|start
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|start
init|;
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|CODE_LABEL
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
if|if
condition|(
operator|!
name|CONST_OR_PURE_CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
name|invalidate_memory
argument_list|()
expr_stmt|;
name|invalidate_for_call
argument_list|()
expr_stmt|;
block|}
name|invalidate_from_clobbers
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|invalidate_skipped_set
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If modifying X will modify the value in *DATA (which is really an    `rtx *'), indicate that fact by setting the pointed to value to    NULL_RTX.  */
end_comment

begin_function
specifier|static
name|void
name|cse_check_loop_start
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|set
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|rtx
modifier|*
name|cse_check_loop_start_value
init|=
operator|(
name|rtx
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
operator|*
name|cse_check_loop_start_value
operator|==
name|NULL_RTX
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CC0
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PC
condition|)
return|return;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
operator|*
name|cse_check_loop_start_value
argument_list|)
operator|==
name|MEM
operator|)
operator|||
name|reg_overlap_mentioned_p
argument_list|(
name|x
argument_list|,
operator|*
name|cse_check_loop_start_value
argument_list|)
condition|)
operator|*
name|cse_check_loop_start_value
operator|=
name|NULL_RTX
expr_stmt|;
block|}
end_function

begin_comment
comment|/* X is a SET or CLOBBER contained in INSN that was found near the start of    a loop that starts with the label at LOOP_START.     If X is a SET, we see if its SET_SRC is currently in our hash table.    If so, we see if it has a value equal to some register used only in the    loop exit code (as marked by jump.c).     If those two conditions are true, we search backwards from the start of    the loop to see if that same value was loaded into a register that still    retains its value at the start of the loop.     If so, we insert an insn after the load to copy the destination of that    load into the equivalent register and (try to) replace our SET_SRC with that    register.     In any event, we invalidate whatever this SET or CLOBBER modifies.  */
end_comment

begin_function
specifier|static
name|void
name|cse_set_around_loop
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|insn
parameter_list|,
name|rtx
name|loop_start
parameter_list|)
block|{
name|struct
name|table_elt
modifier|*
name|src_elt
decl_stmt|;
comment|/* If this is a SET, see if we can replace SET_SRC, but ignore SETs that      are setting PC or CC0 or whose SET_SRC is already a register.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|PC
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|CC0
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
block|{
name|src_elt
operator|=
name|lookup
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|HASH
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|src_elt
condition|)
for|for
control|(
name|src_elt
operator|=
name|src_elt
operator|->
name|first_same_value
init|;
name|src_elt
condition|;
name|src_elt
operator|=
name|src_elt
operator|->
name|next_same_value
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|src_elt
operator|->
name|exp
argument_list|)
operator|==
name|REG
operator|&&
name|REG_LOOP_TEST_P
argument_list|(
name|src_elt
operator|->
name|exp
argument_list|)
operator|&&
name|COST
argument_list|(
name|src_elt
operator|->
name|exp
argument_list|)
operator|<
name|COST
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|p
decl_stmt|,
name|set
decl_stmt|;
comment|/* Look for an insn in front of LOOP_START that sets 		 something in the desired mode to SET_SRC (x) before we hit 		 a label or CALL_INSN.  */
for|for
control|(
name|p
operator|=
name|prev_nonnote_insn
argument_list|(
name|loop_start
argument_list|)
init|;
name|p
operator|&&
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|!=
name|CALL_INSN
operator|&&
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|!=
name|CODE_LABEL
condition|;
name|p
operator|=
name|prev_nonnote_insn
argument_list|(
name|p
argument_list|)
control|)
if|if
condition|(
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|p
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|src_elt
operator|->
name|mode
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
comment|/* We now have to ensure that nothing between P 		       and LOOP_START modified anything referenced in 		       SET_SRC (x).  We know that nothing within the loop 		       can modify it, or we would have invalidated it in 		       the hash table.  */
name|rtx
name|q
decl_stmt|;
name|rtx
name|cse_check_loop_start_value
init|=
name|SET_SRC
argument_list|(
name|x
argument_list|)
decl_stmt|;
for|for
control|(
name|q
operator|=
name|p
init|;
name|q
operator|!=
name|loop_start
condition|;
name|q
operator|=
name|NEXT_INSN
argument_list|(
name|q
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|q
argument_list|)
condition|)
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|q
argument_list|)
argument_list|,
name|cse_check_loop_start
argument_list|,
operator|&
name|cse_check_loop_start_value
argument_list|)
expr_stmt|;
comment|/* If nothing was changed and we can replace our 		       SET_SRC, add an insn after P to copy its destination 		       to what we will be replacing SET_SRC with.  */
if|if
condition|(
name|cse_check_loop_start_value
operator|&&
name|single_set
argument_list|(
name|p
argument_list|)
operator|&&
operator|!
name|can_throw_internal
argument_list|(
name|insn
argument_list|)
operator|&&
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|src_elt
operator|->
name|exp
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* If this creates new pseudos, this is unsafe, 			   because the regno of new pseudo is unsuitable 			   to index into reg_qty when cse_insn processes 			   the new insn.  Therefore, if a new pseudo was 			   created, discard this optimization.  */
name|int
name|nregs
init|=
name|max_reg_num
argument_list|()
decl_stmt|;
name|rtx
name|move
init|=
name|gen_move_insn
argument_list|(
name|src_elt
operator|->
name|exp
argument_list|,
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|nregs
operator|!=
name|max_reg_num
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|&&
operator|!
name|find_reg_equal_equiv_note
argument_list|(
name|insn
argument_list|)
condition|)
name|set_unique_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUAL
argument_list|,
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|control_flow_insn_p
argument_list|(
name|p
argument_list|)
condition|)
comment|/* p can cause a control flow transfer so it 				 is the last insn of a basic block.  We can't 				 therefore use emit_insn_after.  */
name|emit_insn_before
argument_list|(
name|move
argument_list|,
name|next_nonnote_insn
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn_after
argument_list|(
name|move
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
block|}
comment|/* Deal with the destination of X affecting the stack pointer.  */
name|addr_affects_sp_p
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
comment|/* See comment on similar code in cse_insn for explanation of these      tests.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
name|invalidate
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
name|invalidate
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find the end of INSN's basic block and return its range,    the total number of SETs in all the insns of the block, the last insn of the    block, and the branch path.     The branch path indicates which branches should be followed.  If a nonzero    path size is specified, the block should be rescanned and a different set    of branches will be taken.  The branch path is only used if    FLAG_CSE_FOLLOW_JUMPS or FLAG_CSE_SKIP_BLOCKS is nonzero.     DATA is a pointer to a struct cse_basic_block_data, defined below, that is    used to describe the block.  It is filled in with the information about    the current block.  The incoming structure's branch path, if any, is used    to construct the output branch path.  */
end_comment

begin_function
name|void
name|cse_end_of_basic_block
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|struct
name|cse_basic_block_data
modifier|*
name|data
parameter_list|,
name|int
name|follow_jumps
parameter_list|,
name|int
name|after_loop
parameter_list|,
name|int
name|skip_blocks
parameter_list|)
block|{
name|rtx
name|p
init|=
name|insn
decl_stmt|,
name|q
decl_stmt|;
name|int
name|nsets
init|=
literal|0
decl_stmt|;
name|int
name|low_cuid
init|=
name|INSN_CUID
argument_list|(
name|insn
argument_list|)
decl_stmt|,
name|high_cuid
init|=
name|INSN_CUID
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|next
init|=
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|?
name|insn
else|:
name|next_real_insn
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|path_size
init|=
name|data
operator|->
name|path_size
decl_stmt|;
name|int
name|path_entry
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Update the previous branch path, if any.  If the last branch was      previously TAKEN, mark it NOT_TAKEN.  If it was previously NOT_TAKEN,      shorten the path by one and look at the previous branch.  We know that      at least one branch must have been taken if PATH_SIZE is nonzero.  */
while|while
condition|(
name|path_size
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|data
operator|->
name|path
index|[
name|path_size
operator|-
literal|1
index|]
operator|.
name|status
operator|!=
name|NOT_TAKEN
condition|)
block|{
name|data
operator|->
name|path
index|[
name|path_size
operator|-
literal|1
index|]
operator|.
name|status
operator|=
name|NOT_TAKEN
expr_stmt|;
break|break;
block|}
else|else
name|path_size
operator|--
expr_stmt|;
block|}
comment|/* If the first instruction is marked with QImode, that means we've      already processed this block.  Our caller will look at DATA->LAST      to figure out where to go next.  We want to return the next block      in the instruction stream, not some branched-to block somewhere      else.  We accomplish this by pretending our called forbid us to      follow jumps, or skip blocks.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|insn
argument_list|)
operator|==
name|QImode
condition|)
name|follow_jumps
operator|=
name|skip_blocks
operator|=
literal|0
expr_stmt|;
comment|/* Scan to end of this basic block.  */
while|while
condition|(
name|p
operator|&&
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
block|{
comment|/* Don't cse out the end of a loop.  This makes a difference 	 only for the unusual loops that always execute at least once; 	 all other loops have labels there so we will stop in any case. 	 Cse'ing out the end of the loop is dangerous because it 	 might cause an invariant expression inside the loop 	 to be reused after the end of the loop.  This would make it 	 hard to move the expression out of the loop in loop.c, 	 especially if it is one of several equivalent expressions 	 and loop.c would like to eliminate it.  	 If we are running after loop.c has finished, we can ignore 	 the NOTE_INSN_LOOP_END.  */
if|if
condition|(
operator|!
name|after_loop
operator|&&
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE_INSN_LOOP_END
condition|)
break|break;
comment|/* Don't cse over a call to setjmp; on some machines (eg VAX) 	 the regs restored by the longjmp come from 	 a later time than the setjmp.  */
if|if
condition|(
name|PREV_INSN
argument_list|(
name|p
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|PREV_INSN
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|find_reg_note
argument_list|(
name|PREV_INSN
argument_list|(
name|p
argument_list|)
argument_list|,
name|REG_SETJMP
argument_list|,
name|NULL
argument_list|)
condition|)
break|break;
comment|/* A PARALLEL can have lots of SETs in it, 	 especially if it is really an ASM_OPERANDS.  */
if|if
condition|(
name|INSN_P
argument_list|(
name|p
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|)
name|nsets
operator|+=
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|!=
name|NOTE
condition|)
name|nsets
operator|+=
literal|1
expr_stmt|;
comment|/* Ignore insns made by CSE; they cannot affect the boundaries of 	 the basic block.  */
if|if
condition|(
name|INSN_UID
argument_list|(
name|p
argument_list|)
operator|<=
name|max_uid
operator|&&
name|INSN_CUID
argument_list|(
name|p
argument_list|)
operator|>
name|high_cuid
condition|)
name|high_cuid
operator|=
name|INSN_CUID
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|INSN_UID
argument_list|(
name|p
argument_list|)
operator|<=
name|max_uid
operator|&&
name|INSN_CUID
argument_list|(
name|p
argument_list|)
operator|<
name|low_cuid
condition|)
name|low_cuid
operator|=
name|INSN_CUID
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* See if this insn is in our branch path.  If it is and we are to 	 take it, do so.  */
if|if
condition|(
name|path_entry
operator|<
name|path_size
operator|&&
name|data
operator|->
name|path
index|[
name|path_entry
index|]
operator|.
name|branch
operator|==
name|p
condition|)
block|{
if|if
condition|(
name|data
operator|->
name|path
index|[
name|path_entry
index|]
operator|.
name|status
operator|!=
name|NOT_TAKEN
condition|)
name|p
operator|=
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Point to next entry in path, if any.  */
name|path_entry
operator|++
expr_stmt|;
block|}
comment|/* If this is a conditional jump, we can follow it if -fcse-follow-jumps 	 was specified, we haven't reached our maximum path length, there are 	 insns following the target of the jump, this is the only use of the 	 jump label, and the target label is preceded by a BARRIER.  	 Alternatively, we can follow the jump if it branches around a 	 block of code and there are no other branches into the block. 	 In this case invalidate_skipped_block will be called to invalidate any 	 registers set in the block when following the jump.  */
elseif|else
if|if
condition|(
operator|(
name|follow_jumps
operator|||
name|skip_blocks
operator|)
operator|&&
name|path_size
operator|<
name|PARAM_VALUE
argument_list|(
name|PARAM_MAX_CSE_PATH_LENGTH
argument_list|)
operator|-
literal|1
operator|&&
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
operator|==
name|IF_THEN_ELSE
operator|&&
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
operator|!=
literal|0
operator|&&
name|LABEL_NUSES
argument_list|(
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
literal|1
operator|&&
name|NEXT_INSN
argument_list|(
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|q
operator|=
name|PREV_INSN
argument_list|(
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
argument_list|)
init|;
name|q
condition|;
name|q
operator|=
name|PREV_INSN
argument_list|(
name|q
argument_list|)
control|)
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|q
argument_list|)
operator|!=
name|NOTE
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|q
argument_list|)
operator|==
name|NOTE_INSN_LOOP_END
operator|||
operator|(
name|PREV_INSN
argument_list|(
name|q
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|PREV_INSN
argument_list|(
name|q
argument_list|)
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|find_reg_note
argument_list|(
name|PREV_INSN
argument_list|(
name|q
argument_list|)
argument_list|,
name|REG_SETJMP
argument_list|,
name|NULL
argument_list|)
operator|)
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|q
argument_list|)
operator|!=
name|CODE_LABEL
operator|||
name|LABEL_NUSES
argument_list|(
name|q
argument_list|)
operator|!=
literal|0
operator|)
condition|)
break|break;
comment|/* If we ran into a BARRIER, this code is an extension of the 	     basic block when the branch is taken.  */
if|if
condition|(
name|follow_jumps
operator|&&
name|q
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|q
argument_list|)
operator|==
name|BARRIER
condition|)
block|{
comment|/* Don't allow ourself to keep walking around an 		 always-executed loop.  */
if|if
condition|(
name|next_real_insn
argument_list|(
name|q
argument_list|)
operator|==
name|next
condition|)
block|{
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Similarly, don't put a branch in our path more than once.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|path_entry
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|data
operator|->
name|path
index|[
name|i
index|]
operator|.
name|branch
operator|==
name|p
condition|)
break|break;
if|if
condition|(
name|i
operator|!=
name|path_entry
condition|)
break|break;
name|data
operator|->
name|path
index|[
name|path_entry
index|]
operator|.
name|branch
operator|=
name|p
expr_stmt|;
name|data
operator|->
name|path
index|[
name|path_entry
operator|++
index|]
operator|.
name|status
operator|=
name|TAKEN
expr_stmt|;
comment|/* This branch now ends our path.  It was possible that we 		 didn't see this branch the last time around (when the 		 insn in front of the target was a JUMP_INSN that was 		 turned into a no-op).  */
name|path_size
operator|=
name|path_entry
expr_stmt|;
name|p
operator|=
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Mark block so we won't scan it again later.  */
name|PUT_MODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
argument_list|,
name|QImode
argument_list|)
expr_stmt|;
block|}
comment|/* Detect a branch around a block of code.  */
elseif|else
if|if
condition|(
name|skip_blocks
operator|&&
name|q
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|q
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
block|{
name|rtx
name|tmp
decl_stmt|;
if|if
condition|(
name|next_real_insn
argument_list|(
name|q
argument_list|)
operator|==
name|next
condition|)
block|{
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|path_entry
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|data
operator|->
name|path
index|[
name|i
index|]
operator|.
name|branch
operator|==
name|p
condition|)
break|break;
if|if
condition|(
name|i
operator|!=
name|path_entry
condition|)
break|break;
comment|/* This is no_labels_between_p (p, q) with an added check for 		 reaching the end of a function (in case Q precedes P).  */
for|for
control|(
name|tmp
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
init|;
name|tmp
operator|&&
name|tmp
operator|!=
name|q
condition|;
name|tmp
operator|=
name|NEXT_INSN
argument_list|(
name|tmp
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|CODE_LABEL
condition|)
break|break;
if|if
condition|(
name|tmp
operator|==
name|q
condition|)
block|{
name|data
operator|->
name|path
index|[
name|path_entry
index|]
operator|.
name|branch
operator|=
name|p
expr_stmt|;
name|data
operator|->
name|path
index|[
name|path_entry
operator|++
index|]
operator|.
name|status
operator|=
name|AROUND
expr_stmt|;
name|path_size
operator|=
name|path_entry
expr_stmt|;
name|p
operator|=
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Mark block so we won't scan it again later.  */
name|PUT_MODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
argument_list|,
name|QImode
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|data
operator|->
name|low_cuid
operator|=
name|low_cuid
expr_stmt|;
name|data
operator|->
name|high_cuid
operator|=
name|high_cuid
expr_stmt|;
name|data
operator|->
name|nsets
operator|=
name|nsets
expr_stmt|;
name|data
operator|->
name|last
operator|=
name|p
expr_stmt|;
comment|/* If all jumps in the path are not taken, set our path length to zero      so a rescan won't be done.  */
for|for
control|(
name|i
operator|=
name|path_size
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|data
operator|->
name|path
index|[
name|i
index|]
operator|.
name|status
operator|!=
name|NOT_TAKEN
condition|)
break|break;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
name|data
operator|->
name|path_size
operator|=
literal|0
expr_stmt|;
else|else
name|data
operator|->
name|path_size
operator|=
name|path_size
expr_stmt|;
comment|/* End the current branch path.  */
name|data
operator|->
name|path
index|[
name|path_size
index|]
operator|.
name|branch
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Perform cse on the instructions of a function.    F is the first instruction.    NREGS is one plus the highest pseudo-reg number used in the instruction.     AFTER_LOOP is 1 if this is the cse call done after loop optimization    (only if -frerun-cse-after-loop).     Returns 1 if jump_optimize should be redone due to simplifications    in conditional jump instructions.  */
end_comment

begin_function
name|int
name|cse_main
parameter_list|(
name|rtx
name|f
parameter_list|,
name|int
name|nregs
parameter_list|,
name|int
name|after_loop
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|cse_basic_block_data
name|val
decl_stmt|;
name|rtx
name|insn
init|=
name|f
decl_stmt|;
name|int
name|i
decl_stmt|;
name|val
operator|.
name|path
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|branch_path
argument_list|)
operator|*
name|PARAM_VALUE
argument_list|(
name|PARAM_MAX_CSE_PATH_LENGTH
argument_list|)
argument_list|)
expr_stmt|;
name|cse_jumps_altered
operator|=
literal|0
expr_stmt|;
name|recorded_label_ref
operator|=
literal|0
expr_stmt|;
name|constant_pool_entries_cost
operator|=
literal|0
expr_stmt|;
name|constant_pool_entries_regcost
operator|=
literal|0
expr_stmt|;
name|val
operator|.
name|path_size
operator|=
literal|0
expr_stmt|;
name|init_recog
argument_list|()
expr_stmt|;
name|init_alias_analysis
argument_list|()
expr_stmt|;
name|max_reg
operator|=
name|nregs
expr_stmt|;
name|max_insn_uid
operator|=
name|get_max_uid
argument_list|()
expr_stmt|;
name|reg_eqv_table
operator|=
name|xmalloc
argument_list|(
name|nregs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|reg_eqv_elem
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOAD_EXTEND_OP
comment|/* Allocate scratch rtl here.  cse_insn will fill in the memory reference      and change the code and mode as appropriate.  */
name|memory_extend_rtx
operator|=
name|gen_rtx_ZERO_EXTEND
argument_list|(
name|VOIDmode
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Reset the counter indicating how many elements have been made      thus far.  */
name|n_elements_made
operator|=
literal|0
expr_stmt|;
comment|/* Find the largest uid.  */
name|max_uid
operator|=
name|get_max_uid
argument_list|()
expr_stmt|;
name|uid_cuid
operator|=
name|xcalloc
argument_list|(
name|max_uid
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Compute the mapping from uids to cuids.      CUIDs are numbers assigned to insns, like uids,      except that cuids increase monotonically through the code.      Don't assign cuids to line-number NOTEs, so that the distance in cuids      between two insns is not affected by -g.  */
for|for
control|(
name|insn
operator|=
name|f
operator|,
name|i
operator|=
literal|0
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|<
literal|0
condition|)
name|INSN_CUID
argument_list|(
name|insn
argument_list|)
operator|=
operator|++
name|i
expr_stmt|;
else|else
comment|/* Give a line number note the same cuid as preceding insn.  */
name|INSN_CUID
argument_list|(
name|insn
argument_list|)
operator|=
name|i
expr_stmt|;
block|}
name|ggc_push_context
argument_list|()
expr_stmt|;
comment|/* Loop over basic blocks.      Compute the maximum number of qty's needed for each basic block      (which is 2 for each SET).  */
name|insn
operator|=
name|f
expr_stmt|;
while|while
condition|(
name|insn
condition|)
block|{
name|cse_altered
operator|=
literal|0
expr_stmt|;
name|cse_end_of_basic_block
argument_list|(
name|insn
argument_list|,
operator|&
name|val
argument_list|,
name|flag_cse_follow_jumps
argument_list|,
name|after_loop
argument_list|,
name|flag_cse_skip_blocks
argument_list|)
expr_stmt|;
comment|/* If this basic block was already processed or has no sets, skip it.  */
if|if
condition|(
name|val
operator|.
name|nsets
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|insn
argument_list|)
operator|==
name|QImode
condition|)
block|{
name|PUT_MODE
argument_list|(
name|insn
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
name|insn
operator|=
operator|(
name|val
operator|.
name|last
condition|?
name|NEXT_INSN
argument_list|(
name|val
operator|.
name|last
argument_list|)
else|:
literal|0
operator|)
expr_stmt|;
name|val
operator|.
name|path_size
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|cse_basic_block_start
operator|=
name|val
operator|.
name|low_cuid
expr_stmt|;
name|cse_basic_block_end
operator|=
name|val
operator|.
name|high_cuid
expr_stmt|;
name|max_qty
operator|=
name|val
operator|.
name|nsets
operator|*
literal|2
expr_stmt|;
if|if
condition|(
name|file
condition|)
name|fnotice
argument_list|(
name|file
argument_list|,
literal|";; Processing block from %d to %d, %d sets.\n"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|val
operator|.
name|last
condition|?
name|INSN_UID
argument_list|(
name|val
operator|.
name|last
argument_list|)
else|:
literal|0
argument_list|,
name|val
operator|.
name|nsets
argument_list|)
expr_stmt|;
comment|/* Make MAX_QTY bigger to give us room to optimize 	 past the end of this basic block, if that should prove useful.  */
if|if
condition|(
name|max_qty
operator|<
literal|500
condition|)
name|max_qty
operator|=
literal|500
expr_stmt|;
comment|/* If this basic block is being extended by following certain jumps,          (see `cse_end_of_basic_block'), we reprocess the code from the start.          Otherwise, we start after this basic block.  */
if|if
condition|(
name|val
operator|.
name|path_size
operator|>
literal|0
condition|)
name|cse_basic_block
argument_list|(
name|insn
argument_list|,
name|val
operator|.
name|last
argument_list|,
name|val
operator|.
name|path
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|old_cse_jumps_altered
init|=
name|cse_jumps_altered
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
comment|/* When cse changes a conditional jump to an unconditional 	     jump, we want to reprocess the block, since it will give 	     us a new branch path to investigate.  */
name|cse_jumps_altered
operator|=
literal|0
expr_stmt|;
name|temp
operator|=
name|cse_basic_block
argument_list|(
name|insn
argument_list|,
name|val
operator|.
name|last
argument_list|,
name|val
operator|.
name|path
argument_list|,
operator|!
name|after_loop
argument_list|)
expr_stmt|;
if|if
condition|(
name|cse_jumps_altered
operator|==
literal|0
operator|||
operator|(
name|flag_cse_follow_jumps
operator|==
literal|0
operator|&&
name|flag_cse_skip_blocks
operator|==
literal|0
operator|)
condition|)
name|insn
operator|=
name|temp
expr_stmt|;
name|cse_jumps_altered
operator||=
name|old_cse_jumps_altered
expr_stmt|;
block|}
if|if
condition|(
name|cse_altered
condition|)
name|ggc_collect
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_C_ALLOCA
name|alloca
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|ggc_pop_context
argument_list|()
expr_stmt|;
if|if
condition|(
name|max_elements_made
operator|<
name|n_elements_made
condition|)
name|max_elements_made
operator|=
name|n_elements_made
expr_stmt|;
comment|/* Clean up.  */
name|end_alias_analysis
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|uid_cuid
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reg_eqv_table
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|val
operator|.
name|path
argument_list|)
expr_stmt|;
return|return
name|cse_jumps_altered
operator|||
name|recorded_label_ref
return|;
block|}
end_function

begin_comment
comment|/* Process a single basic block.  FROM and TO and the limits of the basic    block.  NEXT_BRANCH points to the branch path when following jumps or    a null path when not following jumps.     AROUND_LOOP is nonzero if we are to try to cse around to the start of a    loop.  This is true when we are being called for the last time on a    block and this CSE pass is before loop.c.  */
end_comment

begin_function
specifier|static
name|rtx
name|cse_basic_block
parameter_list|(
name|rtx
name|from
parameter_list|,
name|rtx
name|to
parameter_list|,
name|struct
name|branch_path
modifier|*
name|next_branch
parameter_list|,
name|int
name|around_loop
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|int
name|to_usage
init|=
literal|0
decl_stmt|;
name|rtx
name|libcall_insn
init|=
name|NULL_RTX
decl_stmt|;
name|int
name|num_insns
init|=
literal|0
decl_stmt|;
name|int
name|no_conflict
init|=
literal|0
decl_stmt|;
comment|/* Allocate the space needed by qty_table.  */
name|qty_table
operator|=
name|xmalloc
argument_list|(
name|max_qty
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|qty_table_elem
argument_list|)
argument_list|)
expr_stmt|;
name|new_basic_block
argument_list|()
expr_stmt|;
comment|/* TO might be a label.  If so, protect it from being deleted.  */
if|if
condition|(
name|to
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|CODE_LABEL
condition|)
operator|++
name|LABEL_NUSES
argument_list|(
name|to
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|from
init|;
name|insn
operator|!=
name|to
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* If we have processed 1,000 insns, flush the hash table to 	 avoid extreme quadratic behavior.  We must not include NOTEs 	 in the count since there may be more of them when generating 	 debugging information.  If we clear the table at different 	 times, code generated with -g -O might be different than code 	 generated with -O but not -g.  	 ??? This is a real kludge and needs to be done some other way. 	 Perhaps for 2.9.  */
if|if
condition|(
name|code
operator|!=
name|NOTE
operator|&&
name|num_insns
operator|++
operator|>
literal|1000
condition|)
block|{
name|flush_hash_table
argument_list|()
expr_stmt|;
name|num_insns
operator|=
literal|0
expr_stmt|;
block|}
comment|/* See if this is a branch that is part of the path.  If so, and it is 	 to be taken, do so.  */
if|if
condition|(
name|next_branch
operator|->
name|branch
operator|==
name|insn
condition|)
block|{
name|enum
name|taken
name|status
init|=
name|next_branch
operator|++
operator|->
name|status
decl_stmt|;
if|if
condition|(
name|status
operator|!=
name|NOT_TAKEN
condition|)
block|{
if|if
condition|(
name|status
operator|==
name|TAKEN
condition|)
name|record_jump_equiv
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|invalidate_skipped_block
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set the last insn as the jump insn; it doesn't affect cc0. 		 Then follow this branch.  */
ifdef|#
directive|ifdef
name|HAVE_cc0
name|prev_insn_cc0
operator|=
literal|0
expr_stmt|;
name|prev_insn
operator|=
name|insn
expr_stmt|;
endif|#
directive|endif
name|insn
operator|=
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|GET_MODE
argument_list|(
name|insn
argument_list|)
operator|==
name|QImode
condition|)
name|PUT_MODE
argument_list|(
name|insn
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'i'
condition|)
block|{
name|rtx
name|p
decl_stmt|;
comment|/* Process notes first so we have all notes in canonical forms when 	     looking for duplicate operations.  */
if|if
condition|(
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
condition|)
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|cse_process_notes
argument_list|(
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
comment|/* Track when we are inside in LIBCALL block.  Inside such a block, 	     we do not want to record destinations.  The last insn of a 	     LIBCALL block is not considered to be part of the block, since 	     its destination is the result of the block and hence should be 	     recorded.  */
if|if
condition|(
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_LIBCALL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
condition|)
name|libcall_insn
operator|=
name|XEXP
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
block|{
comment|/* Keep libcall_insn for the last SET insn of a no-conflict 		     block to prevent changing the destination.  */
if|if
condition|(
operator|!
name|no_conflict
condition|)
name|libcall_insn
operator|=
literal|0
expr_stmt|;
else|else
name|no_conflict
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_NO_CONFLICT
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
name|no_conflict
operator|=
literal|1
expr_stmt|;
block|}
name|cse_insn
argument_list|(
name|insn
argument_list|,
name|libcall_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|no_conflict
operator|==
operator|-
literal|1
condition|)
block|{
name|libcall_insn
operator|=
literal|0
expr_stmt|;
name|no_conflict
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If we haven't already found an insn where we added a LABEL_REF, 	     check this one.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
operator|!
name|recorded_label_ref
operator|&&
name|for_each_rtx
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|check_for_label_ref
argument_list|,
operator|(
name|void
operator|*
operator|)
name|insn
argument_list|)
condition|)
name|recorded_label_ref
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If INSN is now an unconditional jump, skip to the end of our 	 basic block by pretending that we just did the last insn in the 	 basic block.  If we are jumping to the end of our block, show 	 that we can have one usage of TO.  */
if|if
condition|(
name|any_uncondjump_p
argument_list|(
name|insn
argument_list|)
condition|)
block|{
if|if
condition|(
name|to
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|qty_table
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|==
name|to
condition|)
name|to_usage
operator|=
literal|1
expr_stmt|;
comment|/* Maybe TO was deleted because the jump is unconditional. 	     If so, there is nothing left in this basic block.  */
comment|/* ??? Perhaps it would be smarter to set TO 	     to whatever follows this insn, 	     and pretend the basic block had always ended here.  */
if|if
condition|(
name|INSN_DELETED_P
argument_list|(
name|to
argument_list|)
condition|)
break|break;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|to
argument_list|)
expr_stmt|;
block|}
comment|/* See if it is ok to keep on going past the label 	 which used to end our basic block.  Remember that we incremented 	 the count of that label, so we decrement it here.  If we made 	 a jump unconditional, TO_USAGE will be one; in that case, we don't 	 want to count the use in that jump.  */
if|if
condition|(
name|to
operator|!=
literal|0
operator|&&
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|==
name|to
operator|&&
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|CODE_LABEL
operator|&&
operator|--
name|LABEL_NUSES
argument_list|(
name|to
argument_list|)
operator|==
name|to_usage
condition|)
block|{
name|struct
name|cse_basic_block_data
name|val
decl_stmt|;
name|rtx
name|prev
decl_stmt|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|to
argument_list|)
expr_stmt|;
comment|/* If TO was the last insn in the function, we are done.  */
if|if
condition|(
name|insn
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|qty_table
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* If TO was preceded by a BARRIER we are done with this block 	     because it has no continuation.  */
name|prev
operator|=
name|prev_nonnote_insn
argument_list|(
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|&&
name|GET_CODE
argument_list|(
name|prev
argument_list|)
operator|==
name|BARRIER
condition|)
block|{
name|free
argument_list|(
name|qty_table
argument_list|)
expr_stmt|;
return|return
name|insn
return|;
block|}
comment|/* Find the end of the following block.  Note that we won't be 	     following branches in this case.  */
name|to_usage
operator|=
literal|0
expr_stmt|;
name|val
operator|.
name|path_size
operator|=
literal|0
expr_stmt|;
name|val
operator|.
name|path
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|branch_path
argument_list|)
operator|*
name|PARAM_VALUE
argument_list|(
name|PARAM_MAX_CSE_PATH_LENGTH
argument_list|)
argument_list|)
expr_stmt|;
name|cse_end_of_basic_block
argument_list|(
name|insn
argument_list|,
operator|&
name|val
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|val
operator|.
name|path
argument_list|)
expr_stmt|;
comment|/* If the tables we allocated have enough space left 	     to handle all the SETs in the next basic block, 	     continue through it.  Otherwise, return, 	     and that block will be scanned individually.  */
if|if
condition|(
name|val
operator|.
name|nsets
operator|*
literal|2
operator|+
name|next_qty
operator|>
name|max_qty
condition|)
break|break;
name|cse_basic_block_start
operator|=
name|val
operator|.
name|low_cuid
expr_stmt|;
name|cse_basic_block_end
operator|=
name|val
operator|.
name|high_cuid
expr_stmt|;
name|to
operator|=
name|val
operator|.
name|last
expr_stmt|;
comment|/* Prevent TO from being deleted if it is a label.  */
if|if
condition|(
name|to
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|CODE_LABEL
condition|)
operator|++
name|LABEL_NUSES
argument_list|(
name|to
argument_list|)
expr_stmt|;
comment|/* Back up so we process the first insn in the extension.  */
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|next_qty
operator|>
name|max_qty
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If we are running before loop.c, we stopped on a NOTE_INSN_LOOP_END, and      the previous insn is the only insn that branches to the head of a loop,      we can cse into the loop.  Don't do this if we changed the jump      structure of a loop unless we aren't going to be following jumps.  */
name|insn
operator|=
name|prev_nonnote_insn
argument_list|(
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cse_jumps_altered
operator|==
literal|0
operator|||
operator|(
name|flag_cse_follow_jumps
operator|==
literal|0
operator|&&
name|flag_cse_skip_blocks
operator|==
literal|0
operator|)
operator|)
operator|&&
name|around_loop
operator|&&
name|to
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|to
argument_list|)
operator|==
name|NOTE_INSN_LOOP_END
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|!=
literal|0
operator|&&
name|LABEL_NUSES
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|1
condition|)
name|cse_around_loop
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|qty_table
argument_list|)
expr_stmt|;
return|return
name|to
condition|?
name|NEXT_INSN
argument_list|(
name|to
argument_list|)
else|:
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Called via for_each_rtx to see if an insn is using a LABEL_REF for which    there isn't a REG_LABEL note.  Return one if so.  DATA is the insn.  */
end_comment

begin_function
specifier|static
name|int
name|check_for_label_ref
parameter_list|(
name|rtx
modifier|*
name|rtl
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|rtx
name|insn
init|=
operator|(
name|rtx
operator|)
name|data
decl_stmt|;
comment|/* If this insn uses a LABEL_REF and there isn't a REG_LABEL note for it,      we must rerun jump since it needs to place the note.  If this is a      LABEL_REF for a CODE_LABEL that isn't in the insn chain, don't do this      since no REG_LABEL will be added.  */
return|return
operator|(
name|GET_CODE
argument_list|(
operator|*
name|rtl
argument_list|)
operator|==
name|LABEL_REF
operator|&&
operator|!
name|LABEL_REF_NONLOCAL_P
argument_list|(
operator|*
name|rtl
argument_list|)
operator|&&
name|LABEL_P
argument_list|(
name|XEXP
argument_list|(
operator|*
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|INSN_UID
argument_list|(
name|XEXP
argument_list|(
operator|*
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_LABEL
argument_list|,
name|XEXP
argument_list|(
operator|*
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Count the number of times registers are used (not set) in X.    COUNTS is an array in which we accumulate the count, INCR is how much    we count each register usage.  */
end_comment

begin_function
specifier|static
name|void
name|count_reg_usage
parameter_list|(
name|rtx
name|x
parameter_list|,
name|int
modifier|*
name|counts
parameter_list|,
name|int
name|incr
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
decl_stmt|;
name|rtx
name|note
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return;
switch|switch
condition|(
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
name|counts
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
operator|+=
name|incr
expr_stmt|;
return|return;
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|CONST
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_VECTOR
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
return|return;
case|case
name|CLOBBER
case|:
comment|/* If we are clobbering a MEM, mark any registers inside the address          as being used.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
name|count_reg_usage
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|counts
argument_list|,
name|incr
argument_list|)
expr_stmt|;
return|return;
case|case
name|SET
case|:
comment|/* Unless we are setting a REG, count everything in SET_DEST.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
name|count_reg_usage
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|counts
argument_list|,
name|incr
argument_list|)
expr_stmt|;
name|count_reg_usage
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|counts
argument_list|,
name|incr
argument_list|)
expr_stmt|;
return|return;
case|case
name|CALL_INSN
case|:
name|count_reg_usage
argument_list|(
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|x
argument_list|)
argument_list|,
name|counts
argument_list|,
name|incr
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|INSN
case|:
case|case
name|JUMP_INSN
case|:
name|count_reg_usage
argument_list|(
name|PATTERN
argument_list|(
name|x
argument_list|)
argument_list|,
name|counts
argument_list|,
name|incr
argument_list|)
expr_stmt|;
comment|/* Things used in a REG_EQUAL note aren't dead since loop may try to 	 use them.  */
name|note
operator|=
name|find_reg_equal_equiv_note
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
condition|)
block|{
name|rtx
name|eqv
init|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|eqv
argument_list|)
operator|==
name|EXPR_LIST
condition|)
comment|/* This REG_EQUAL note describes the result of a function call. 	     Process all the arguments.  */
do|do
block|{
name|count_reg_usage
argument_list|(
name|XEXP
argument_list|(
name|eqv
argument_list|,
literal|0
argument_list|)
argument_list|,
name|counts
argument_list|,
name|incr
argument_list|)
expr_stmt|;
name|eqv
operator|=
name|XEXP
argument_list|(
name|eqv
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|eqv
operator|&&
name|GET_CODE
argument_list|(
name|eqv
argument_list|)
operator|==
name|EXPR_LIST
condition|)
do|;
else|else
name|count_reg_usage
argument_list|(
name|eqv
argument_list|,
name|counts
argument_list|,
name|incr
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|EXPR_LIST
case|:
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|x
argument_list|)
operator|==
name|REG_EQUAL
operator|||
operator|(
name|REG_NOTE_KIND
argument_list|(
name|x
argument_list|)
operator|!=
name|REG_NONNEG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|USE
operator|)
comment|/* FUNCTION_USAGE expression lists may include (CLOBBER (mem /u)), 	     involving registers in the address.  */
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
name|count_reg_usage
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|counts
argument_list|,
name|incr
argument_list|)
expr_stmt|;
name|count_reg_usage
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|counts
argument_list|,
name|incr
argument_list|)
expr_stmt|;
return|return;
case|case
name|ASM_OPERANDS
case|:
comment|/* Iterate over just the inputs, not the constraints as well.  */
for|for
control|(
name|i
operator|=
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|x
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|count_reg_usage
argument_list|(
name|ASM_OPERANDS_INPUT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|counts
argument_list|,
name|incr
argument_list|)
expr_stmt|;
return|return;
case|case
name|INSN_LIST
case|:
name|abort
argument_list|()
expr_stmt|;
default|default:
break|break;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|count_reg_usage
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|counts
argument_list|,
name|incr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|count_reg_usage
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|counts
argument_list|,
name|incr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return true if set is live.  */
end_comment

begin_function
specifier|static
name|bool
name|set_live_p
parameter_list|(
name|rtx
name|set
parameter_list|,
name|rtx
name|insn
name|ATTRIBUTE_UNUSED
parameter_list|,
comment|/* Only used with HAVE_cc0.  */
name|int
modifier|*
name|counts
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_cc0
name|rtx
name|tem
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|set_noop_p
argument_list|(
name|set
argument_list|)
condition|)
empty_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|CC0
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|&&
operator|(
operator|(
name|tem
operator|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
operator|)
operator|==
literal|0
operator|||
operator|!
name|INSN_P
argument_list|(
name|tem
argument_list|)
operator|||
operator|!
name|reg_referenced_p
argument_list|(
name|cc0_rtx
argument_list|,
name|PATTERN
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
endif|#
directive|endif
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|||
name|counts
index|[
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
index|]
operator|!=
literal|0
operator|||
name|side_effects_p
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
comment|/* An ADDRESSOF expression can turn into a use of the 	      internal arg pointer, so always consider the 	      internal arg pointer live.  If it is truly dead, 	      flow will delete the initializing insn.  */
operator|||
operator|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|==
name|current_function_internal_arg_pointer
operator|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return true if insn is live.  */
end_comment

begin_function
specifier|static
name|bool
name|insn_live_p
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|int
modifier|*
name|counts
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|flag_non_call_exceptions
operator|&&
name|may_trap_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
return|return
name|set_live_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
name|counts
argument_list|)
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|rtx
name|elt
init|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|elt
argument_list|)
operator|==
name|SET
condition|)
block|{
if|if
condition|(
name|set_live_p
argument_list|(
name|elt
argument_list|,
name|insn
argument_list|,
name|counts
argument_list|)
condition|)
return|return
name|true
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|elt
argument_list|)
operator|!=
name|CLOBBER
operator|&&
name|GET_CODE
argument_list|(
name|elt
argument_list|)
operator|!=
name|USE
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
else|else
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Return true if libcall is dead as a whole.  */
end_comment

begin_function
specifier|static
name|bool
name|dead_libcall_p
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|int
modifier|*
name|counts
parameter_list|)
block|{
name|rtx
name|note
decl_stmt|,
name|set
decl_stmt|,
name|new
decl_stmt|;
comment|/* See if there's a REG_EQUAL note on this insn and try to      replace the source with the REG_EQUAL expression.       We assume that insns with REG_RETVALs can only be reg->reg      copies at this point.  */
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|note
condition|)
return|return
name|false
return|;
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set
condition|)
return|return
name|false
return|;
name|new
operator|=
name|simplify_rtx
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new
condition|)
name|new
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* While changing insn, we must update the counts accordingly.  */
name|count_reg_usage
argument_list|(
name|insn
argument_list|,
name|counts
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|new
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|count_reg_usage
argument_list|(
name|insn
argument_list|,
name|counts
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|remove_note
argument_list|(
name|insn
argument_list|,
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|)
expr_stmt|;
name|remove_note
argument_list|(
name|insn
argument_list|,
name|note
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|new
argument_list|)
condition|)
block|{
name|new
operator|=
name|force_const_mem
argument_list|(
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|,
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|&&
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|new
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|count_reg_usage
argument_list|(
name|insn
argument_list|,
name|counts
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|remove_note
argument_list|(
name|insn
argument_list|,
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|)
expr_stmt|;
name|remove_note
argument_list|(
name|insn
argument_list|,
name|note
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
name|count_reg_usage
argument_list|(
name|insn
argument_list|,
name|counts
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Scan all the insns and delete any that are dead; i.e., they store a register    that is never used or they copy a register to itself.     This is used to remove insns made obviously dead by cse, loop or other    optimizations.  It improves the heuristics in loop since it won't try to    move dead invariants out of loops or make givs for dead quantities.  The    remaining passes of the compilation are also sped up.  */
end_comment

begin_function
name|int
name|delete_trivially_dead_insns
parameter_list|(
name|rtx
name|insns
parameter_list|,
name|int
name|nreg
parameter_list|)
block|{
name|int
modifier|*
name|counts
decl_stmt|;
name|rtx
name|insn
decl_stmt|,
name|prev
decl_stmt|;
name|int
name|in_libcall
init|=
literal|0
decl_stmt|,
name|dead_libcall
init|=
literal|0
decl_stmt|;
name|int
name|ndead
init|=
literal|0
decl_stmt|,
name|nlastdead
decl_stmt|,
name|niterations
init|=
literal|0
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_DELETE_TRIVIALLY_DEAD
argument_list|)
expr_stmt|;
comment|/* First count the number of times each register is used.  */
name|counts
operator|=
name|xcalloc
argument_list|(
name|nreg
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|next_real_insn
argument_list|(
name|insns
argument_list|)
init|;
name|insn
condition|;
name|insn
operator|=
name|next_real_insn
argument_list|(
name|insn
argument_list|)
control|)
name|count_reg_usage
argument_list|(
name|insn
argument_list|,
name|counts
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|do
block|{
name|nlastdead
operator|=
name|ndead
expr_stmt|;
name|niterations
operator|++
expr_stmt|;
comment|/* Go from the last insn to the first and delete insns that only set unused 	 registers or copy a register to itself.  As we delete an insn, remove 	 usage counts for registers it uses.  	 The first jump optimization pass may leave a real insn as the last 	 insn in the function.   We must not skip that insn or we may end 	 up deleting code that is not really dead.  */
name|insn
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|insn
operator|=
name|prev_real_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|insn
condition|;
name|insn
operator|=
name|prev
control|)
block|{
name|int
name|live_insn
init|=
literal|0
decl_stmt|;
name|prev
operator|=
name|prev_real_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Don't delete any insns that are part of a libcall block unless 	     we can delete the whole libcall block.  	     Flow or loop might get confused if we did that.  Remember 	     that we are scanning backwards.  */
if|if
condition|(
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
block|{
name|in_libcall
operator|=
literal|1
expr_stmt|;
name|live_insn
operator|=
literal|1
expr_stmt|;
name|dead_libcall
operator|=
name|dead_libcall_p
argument_list|(
name|insn
argument_list|,
name|counts
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|in_libcall
condition|)
name|live_insn
operator|=
operator|!
name|dead_libcall
expr_stmt|;
else|else
name|live_insn
operator|=
name|insn_live_p
argument_list|(
name|insn
argument_list|,
name|counts
argument_list|)
expr_stmt|;
comment|/* If this is a dead insn, delete it and show registers in it aren't 	     being used.  */
if|if
condition|(
operator|!
name|live_insn
condition|)
block|{
name|count_reg_usage
argument_list|(
name|insn
argument_list|,
name|counts
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|delete_insn_and_edges
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|ndead
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_LIBCALL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
block|{
name|in_libcall
operator|=
literal|0
expr_stmt|;
name|dead_libcall
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|ndead
operator|!=
name|nlastdead
condition|)
do|;
if|if
condition|(
name|rtl_dump_file
operator|&&
name|ndead
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Deleted %i trivially dead insns; %i iterations\n"
argument_list|,
name|ndead
argument_list|,
name|niterations
argument_list|)
expr_stmt|;
comment|/* Clean up.  */
name|free
argument_list|(
name|counts
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_DELETE_TRIVIALLY_DEAD
argument_list|)
expr_stmt|;
return|return
name|ndead
return|;
block|}
end_function

begin_comment
comment|/* This function is called via for_each_rtx.  The argument, NEWREG, is    a condition code register with the desired mode.  If we are looking    at the same register in a different mode, replace it with    NEWREG.  */
end_comment

begin_function
specifier|static
name|int
name|cse_change_cc_mode
parameter_list|(
name|rtx
modifier|*
name|loc
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|rtx
name|newreg
init|=
operator|(
name|rtx
operator|)
name|data
decl_stmt|;
if|if
condition|(
operator|*
name|loc
operator|&&
name|GET_CODE
argument_list|(
operator|*
name|loc
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
operator|*
name|loc
argument_list|)
operator|==
name|REGNO
argument_list|(
name|newreg
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
operator|*
name|loc
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|newreg
argument_list|)
condition|)
block|{
operator|*
name|loc
operator|=
name|newreg
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Change the mode of any reference to the register REGNO (NEWREG) to    GET_MODE (NEWREG), starting at START.  Stop before END.  Stop at    any instruction which modifies NEWREG.  */
end_comment

begin_function
specifier|static
name|void
name|cse_change_cc_mode_insns
parameter_list|(
name|rtx
name|start
parameter_list|,
name|rtx
name|end
parameter_list|,
name|rtx
name|newreg
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|start
init|;
name|insn
operator|!=
name|end
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|reg_set_p
argument_list|(
name|newreg
argument_list|,
name|insn
argument_list|)
condition|)
return|return;
name|for_each_rtx
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|cse_change_cc_mode
argument_list|,
name|newreg
argument_list|)
expr_stmt|;
name|for_each_rtx
argument_list|(
operator|&
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|,
name|cse_change_cc_mode
argument_list|,
name|newreg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* BB is a basic block which finishes with CC_REG as a condition code    register which is set to CC_SRC.  Look through the successors of BB    to find blocks which have a single predecessor (i.e., this one),    and look through those blocks for an assignment to CC_REG which is    equivalent to CC_SRC.  CAN_CHANGE_MODE indicates whether we are    permitted to change the mode of CC_SRC to a compatible mode.  This    returns VOIDmode if no equivalent assignments were found.    Otherwise it returns the mode which CC_SRC should wind up with.     The main complexity in this function is handling the mode issues.    We may have more than one duplicate which we can eliminate, and we    try to find a mode which will work for multiple duplicates.  */
end_comment

begin_function
specifier|static
name|enum
name|machine_mode
name|cse_cc_succs
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|rtx
name|cc_reg
parameter_list|,
name|rtx
name|cc_src
parameter_list|,
name|bool
name|can_change_mode
parameter_list|)
block|{
name|bool
name|found_equiv
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|unsigned
name|int
name|insn_count
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|rtx
name|insns
index|[
literal|2
index|]
decl_stmt|;
name|enum
name|machine_mode
name|modes
index|[
literal|2
index|]
decl_stmt|;
name|rtx
name|last_insns
index|[
literal|2
index|]
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|rtx
name|newreg
decl_stmt|;
comment|/* We expect to have two successors.  Look at both before picking      the final mode for the comparison.  If we have more successors      (i.e., some sort of table jump, although that seems unlikely),      then we require all beyond the first two to use the same      mode.  */
name|found_equiv
operator|=
name|false
expr_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|cc_src
argument_list|)
expr_stmt|;
name|insn_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
block|{
name|rtx
name|insn
decl_stmt|;
name|rtx
name|end
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_COMPLEX
condition|)
continue|continue;
if|if
condition|(
operator|!
name|e
operator|->
name|dest
operator|->
name|pred
operator|||
name|e
operator|->
name|dest
operator|->
name|pred
operator|->
name|pred_next
operator|||
name|e
operator|->
name|dest
operator|==
name|EXIT_BLOCK_PTR
condition|)
continue|continue;
name|end
operator|=
name|NEXT_INSN
argument_list|(
name|BB_END
argument_list|(
name|e
operator|->
name|dest
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|BB_HEAD
argument_list|(
name|e
operator|->
name|dest
argument_list|)
init|;
name|insn
operator|!=
name|end
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|rtx
name|set
decl_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
comment|/* If CC_SRC is modified, we have to stop looking for 	     something which uses it.  */
if|if
condition|(
name|modified_in_p
argument_list|(
name|cc_src
argument_list|,
name|insn
argument_list|)
condition|)
break|break;
comment|/* Check whether INSN sets CC_REG to CC_SRC.  */
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REGNO
argument_list|(
name|cc_reg
argument_list|)
condition|)
block|{
name|bool
name|found
decl_stmt|;
name|enum
name|machine_mode
name|set_mode
decl_stmt|;
name|enum
name|machine_mode
name|comp_mode
decl_stmt|;
name|found
operator|=
name|false
expr_stmt|;
name|set_mode
operator|=
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
name|comp_mode
operator|=
name|set_mode
expr_stmt|;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|cc_src
argument_list|,
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
condition|)
name|found
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|cc_src
argument_list|)
operator|==
name|COMPARE
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|COMPARE
operator|&&
name|mode
operator|!=
name|set_mode
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|cc_src
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|cc_src
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|comp_mode
operator|=
call|(
modifier|*
name|targetm
operator|.
name|cc_modes_compatible
call|)
argument_list|(
name|mode
argument_list|,
name|set_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|comp_mode
operator|!=
name|VOIDmode
operator|&&
operator|(
name|can_change_mode
operator|||
name|comp_mode
operator|==
name|mode
operator|)
condition|)
name|found
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|found
condition|)
block|{
name|found_equiv
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|insn_count
operator|<
name|ARRAY_SIZE
argument_list|(
name|insns
argument_list|)
condition|)
block|{
name|insns
index|[
name|insn_count
index|]
operator|=
name|insn
expr_stmt|;
name|modes
index|[
name|insn_count
index|]
operator|=
name|set_mode
expr_stmt|;
name|last_insns
index|[
name|insn_count
index|]
operator|=
name|end
expr_stmt|;
operator|++
name|insn_count
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|comp_mode
condition|)
block|{
if|if
condition|(
operator|!
name|can_change_mode
condition|)
name|abort
argument_list|()
expr_stmt|;
name|mode
operator|=
name|comp_mode
expr_stmt|;
name|PUT_MODE
argument_list|(
name|cc_src
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|set_mode
operator|!=
name|mode
condition|)
block|{
comment|/* We found a matching expression in the 			     wrong mode, but we don't have room to 			     store it in the array.  Punt.  This case 			     should be rare.  */
break|break;
block|}
comment|/* INSN sets CC_REG to a value equal to CC_SRC 			 with the right mode.  We can simply delete 			 it.  */
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* We found an instruction to delete.  Keep looking, 		     in the hopes of finding a three-way jump.  */
continue|continue;
block|}
comment|/* We found an instruction which sets the condition 		 code, so don't look any farther.  */
break|break;
block|}
comment|/* If INSN sets CC_REG in some other way, don't look any 	     farther.  */
if|if
condition|(
name|reg_set_p
argument_list|(
name|cc_reg
argument_list|,
name|insn
argument_list|)
condition|)
break|break;
block|}
comment|/* If we fell off the bottom of the block, we can keep looking 	 through successors.  We pass CAN_CHANGE_MODE as false because 	 we aren't prepared to handle compatibility between the 	 further blocks and this block.  */
if|if
condition|(
name|insn
operator|==
name|end
condition|)
block|{
name|enum
name|machine_mode
name|submode
decl_stmt|;
name|submode
operator|=
name|cse_cc_succs
argument_list|(
name|e
operator|->
name|dest
argument_list|,
name|cc_reg
argument_list|,
name|cc_src
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|submode
operator|!=
name|VOIDmode
condition|)
block|{
if|if
condition|(
name|submode
operator|!=
name|mode
condition|)
name|abort
argument_list|()
expr_stmt|;
name|found_equiv
operator|=
name|true
expr_stmt|;
name|can_change_mode
operator|=
name|false
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|found_equiv
condition|)
return|return
name|VOIDmode
return|;
comment|/* Now INSN_COUNT is the number of instructions we found which set      CC_REG to a value equivalent to CC_SRC.  The instructions are in      INSNS.  The modes used by those instructions are in MODES.  */
name|newreg
operator|=
name|NULL_RTX
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|insn_count
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|modes
index|[
name|i
index|]
operator|!=
name|mode
condition|)
block|{
comment|/* We need to change the mode of CC_REG in INSNS[i] and 	     subsequent instructions.  */
if|if
condition|(
operator|!
name|newreg
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|cc_reg
argument_list|)
operator|==
name|mode
condition|)
name|newreg
operator|=
name|cc_reg
expr_stmt|;
else|else
name|newreg
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|REGNO
argument_list|(
name|cc_reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|cse_change_cc_mode_insns
argument_list|(
name|NEXT_INSN
argument_list|(
name|insns
index|[
name|i
index|]
argument_list|)
argument_list|,
name|last_insns
index|[
name|i
index|]
argument_list|,
name|newreg
argument_list|)
expr_stmt|;
block|}
name|delete_insn
argument_list|(
name|insns
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|mode
return|;
block|}
end_function

begin_comment
comment|/* If we have a fixed condition code register (or two), walk through    the instructions and try to eliminate duplicate assignments.  */
end_comment

begin_function
name|void
name|cse_condition_code_reg
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|cc_regno_1
decl_stmt|;
name|unsigned
name|int
name|cc_regno_2
decl_stmt|;
name|rtx
name|cc_reg_1
decl_stmt|;
name|rtx
name|cc_reg_2
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|targetm
operator|.
name|fixed_condition_code_regs
call|)
argument_list|(
operator|&
name|cc_regno_1
argument_list|,
operator|&
name|cc_regno_2
argument_list|)
condition|)
return|return;
name|cc_reg_1
operator|=
name|gen_rtx_REG
argument_list|(
name|CCmode
argument_list|,
name|cc_regno_1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc_regno_2
operator|!=
name|INVALID_REGNUM
condition|)
name|cc_reg_2
operator|=
name|gen_rtx_REG
argument_list|(
name|CCmode
argument_list|,
name|cc_regno_2
argument_list|)
expr_stmt|;
else|else
name|cc_reg_2
operator|=
name|NULL_RTX
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|rtx
name|last_insn
decl_stmt|;
name|rtx
name|cc_reg
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|rtx
name|cc_src_insn
decl_stmt|;
name|rtx
name|cc_src
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|orig_mode
decl_stmt|;
comment|/* Look for blocks which end with a conditional jump based on a 	 condition code register.  Then look for the instruction which 	 sets the condition code register.  Then look through the 	 successor blocks for instructions which set the condition 	 code register to the same value.  There are other possible 	 uses of the condition code register, but these are by far the 	 most common and the ones which we are most likely to be able 	 to optimize.  */
name|last_insn
operator|=
name|BB_END
argument_list|(
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|last_insn
argument_list|)
operator|!=
name|JUMP_INSN
condition|)
continue|continue;
if|if
condition|(
name|reg_referenced_p
argument_list|(
name|cc_reg_1
argument_list|,
name|PATTERN
argument_list|(
name|last_insn
argument_list|)
argument_list|)
condition|)
name|cc_reg
operator|=
name|cc_reg_1
expr_stmt|;
elseif|else
if|if
condition|(
name|cc_reg_2
operator|&&
name|reg_referenced_p
argument_list|(
name|cc_reg_2
argument_list|,
name|PATTERN
argument_list|(
name|last_insn
argument_list|)
argument_list|)
condition|)
name|cc_reg
operator|=
name|cc_reg_2
expr_stmt|;
else|else
continue|continue;
name|cc_src_insn
operator|=
name|NULL_RTX
expr_stmt|;
name|cc_src
operator|=
name|NULL_RTX
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|last_insn
argument_list|)
init|;
name|insn
operator|&&
name|insn
operator|!=
name|PREV_INSN
argument_list|(
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
argument_list|)
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|rtx
name|set
decl_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REGNO
argument_list|(
name|cc_reg
argument_list|)
condition|)
block|{
name|cc_src_insn
operator|=
name|insn
expr_stmt|;
name|cc_src
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|reg_set_p
argument_list|(
name|cc_reg
argument_list|,
name|insn
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|cc_src_insn
condition|)
continue|continue;
if|if
condition|(
name|modified_between_p
argument_list|(
name|cc_src
argument_list|,
name|cc_src_insn
argument_list|,
name|NEXT_INSN
argument_list|(
name|last_insn
argument_list|)
argument_list|)
condition|)
continue|continue;
comment|/* Now CC_REG is a condition code register used for a 	 conditional jump at the end of the block, and CC_SRC, in 	 CC_SRC_INSN, is the value to which that condition code 	 register is set, and CC_SRC is still meaningful at the end of 	 the basic block.  */
name|orig_mode
operator|=
name|GET_MODE
argument_list|(
name|cc_src
argument_list|)
expr_stmt|;
name|mode
operator|=
name|cse_cc_succs
argument_list|(
name|bb
argument_list|,
name|cc_reg
argument_list|,
name|cc_src
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
condition|)
block|{
if|if
condition|(
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|cc_src
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|orig_mode
condition|)
block|{
name|rtx
name|newreg
init|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|REGNO
argument_list|(
name|cc_reg
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Change the mode of CC_REG in CC_SRC_INSN to 		 GET_MODE (NEWREG).  */
name|for_each_rtx
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|cc_src_insn
argument_list|)
argument_list|,
name|cse_change_cc_mode
argument_list|,
name|newreg
argument_list|)
expr_stmt|;
name|for_each_rtx
argument_list|(
operator|&
name|REG_NOTES
argument_list|(
name|cc_src_insn
argument_list|)
argument_list|,
name|cse_change_cc_mode
argument_list|,
name|newreg
argument_list|)
expr_stmt|;
comment|/* Do the same in the following insns that use the 		 current value of CC_REG within BB.  */
name|cse_change_cc_mode_insns
argument_list|(
name|NEXT_INSN
argument_list|(
name|cc_src_insn
argument_list|)
argument_list|,
name|NEXT_INSN
argument_list|(
name|last_insn
argument_list|)
argument_list|,
name|newreg
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

end_unit

