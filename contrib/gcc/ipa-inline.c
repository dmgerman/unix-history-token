begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Inlining decision heuristics.    Copyright (C) 2003, 2004 Free Software Foundation, Inc.    Contributed by Jan Hubicka  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/*  Inlining decision heuristics      We separate inlining decisions from the inliner itself and store it     inside callgraph as so called inline plan.  Refer to cgraph.c     documentation about particular representation of inline plans in the     callgraph.      There are three major parts of this file:      cgraph_mark_inline implementation        This function allows to mark given call inline and performs necessary       modifications of cgraph (production of the clones and updating overall       statistics)      inlining heuristics limits        These functions allow to check that particular inlining is allowed       by the limits specified by user (allowed function growth, overall unit       growth and so on).      inlining heuristics        This is implementation of IPA pass aiming to get as much of benefit       from inlining obeying the limits checked above.        The implementation of particular heuristics is separated from       the rest of code to make it easier to replace it with more complicated       implementation in the future.  The rest of inlining code acts as a       library aimed to modify the callgraph and verify that the parameters       on code size growth fits.        To mark given call inline, use cgraph_mark_inline function, the       verification is performed by cgraph_default_inline_p and       cgraph_check_inline_limits.        The heuristics implements simple knapsack style algorithm ordering       all functions by their "profitability" (estimated by code size growth)       and inlining them in priority order.        cgraph_decide_inlining implements heuristics taking whole callgraph       into account, while cgraph_decide_inlining_incrementally considers       only one function at a time and is used in non-unit-at-a-time mode.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"tree-inline.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"cgraph.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_include
include|#
directive|include
file|"fibheap.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"coverage.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_comment
comment|/* Statistics we collect about inlining algorithm.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ncalls_inlined
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfunctions_inlined
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|initial_insns
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|overall_insns
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|max_insns
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gcov_type
name|max_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Estimate size of the function after inlining WHAT into TO.  */
end_comment

begin_function
specifier|static
name|int
name|cgraph_estimate_size_after_inlining
parameter_list|(
name|int
name|times
parameter_list|,
name|struct
name|cgraph_node
modifier|*
name|to
parameter_list|,
name|struct
name|cgraph_node
modifier|*
name|what
parameter_list|)
block|{
name|int
name|size
decl_stmt|;
name|tree
name|fndecl
init|=
name|what
operator|->
name|decl
decl_stmt|,
name|arg
decl_stmt|;
name|int
name|call_insns
init|=
name|PARAM_VALUE
argument_list|(
name|PARAM_INLINE_CALL_COST
argument_list|)
decl_stmt|;
for|for
control|(
name|arg
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
init|;
name|arg
condition|;
name|arg
operator|=
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
control|)
name|call_insns
operator|+=
name|estimate_move_cost
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
operator|(
name|what
operator|->
name|global
operator|.
name|insns
operator|-
name|call_insns
operator|)
operator|*
name|times
operator|+
name|to
operator|->
name|global
operator|.
name|insns
expr_stmt|;
name|gcc_assert
argument_list|(
name|size
operator|>=
literal|0
argument_list|)
expr_stmt|;
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/* E is expected to be an edge being inlined.  Clone destination node of    the edge and redirect it to the new clone.    DUPLICATE is used for bookkeeping on whether we are actually creating new    clones or re-using node originally representing out-of-line function call.    */
end_comment

begin_function
name|void
name|cgraph_clone_inlined_nodes
parameter_list|(
name|struct
name|cgraph_edge
modifier|*
name|e
parameter_list|,
name|bool
name|duplicate
parameter_list|,
name|bool
name|update_original
parameter_list|)
block|{
if|if
condition|(
name|duplicate
condition|)
block|{
comment|/* We may eliminate the need for out-of-line copy to be output. 	 In that case just go ahead and re-use it.  */
if|if
condition|(
operator|!
name|e
operator|->
name|callee
operator|->
name|callers
operator|->
name|next_caller
operator|&&
operator|!
name|e
operator|->
name|callee
operator|->
name|needed
operator|&&
name|flag_unit_at_a_time
condition|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|e
operator|->
name|callee
operator|->
name|global
operator|.
name|inlined_to
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_SAVED_TREE
argument_list|(
name|e
operator|->
name|callee
operator|->
name|decl
argument_list|)
condition|)
name|overall_insns
operator|-=
name|e
operator|->
name|callee
operator|->
name|global
operator|.
name|insns
operator|,
name|nfunctions_inlined
operator|++
expr_stmt|;
name|duplicate
operator|=
name|false
expr_stmt|;
block|}
else|else
block|{
name|struct
name|cgraph_node
modifier|*
name|n
decl_stmt|;
name|n
operator|=
name|cgraph_clone_node
argument_list|(
name|e
operator|->
name|callee
argument_list|,
name|e
operator|->
name|count
argument_list|,
name|e
operator|->
name|loop_nest
argument_list|,
name|update_original
argument_list|)
expr_stmt|;
name|cgraph_redirect_edge_callee
argument_list|(
name|e
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|e
operator|->
name|caller
operator|->
name|global
operator|.
name|inlined_to
condition|)
name|e
operator|->
name|callee
operator|->
name|global
operator|.
name|inlined_to
operator|=
name|e
operator|->
name|caller
operator|->
name|global
operator|.
name|inlined_to
expr_stmt|;
else|else
name|e
operator|->
name|callee
operator|->
name|global
operator|.
name|inlined_to
operator|=
name|e
operator|->
name|caller
expr_stmt|;
comment|/* Recursively clone all bodies.  */
for|for
control|(
name|e
operator|=
name|e
operator|->
name|callee
operator|->
name|callees
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next_callee
control|)
if|if
condition|(
operator|!
name|e
operator|->
name|inline_failed
condition|)
name|cgraph_clone_inlined_nodes
argument_list|(
name|e
argument_list|,
name|duplicate
argument_list|,
name|update_original
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Mark edge E as inlined and update callgraph accordingly.     UPDATE_ORIGINAL specify whether profile of original function should be    updated. */
end_comment

begin_function
name|void
name|cgraph_mark_inline_edge
parameter_list|(
name|struct
name|cgraph_edge
modifier|*
name|e
parameter_list|,
name|bool
name|update_original
parameter_list|)
block|{
name|int
name|old_insns
init|=
literal|0
decl_stmt|,
name|new_insns
init|=
literal|0
decl_stmt|;
name|struct
name|cgraph_node
modifier|*
name|to
init|=
name|NULL
decl_stmt|,
modifier|*
name|what
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|callee
operator|->
name|inline_decl
condition|)
name|cgraph_redirect_edge_callee
argument_list|(
name|e
argument_list|,
name|cgraph_node
argument_list|(
name|e
operator|->
name|callee
operator|->
name|inline_decl
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|e
operator|->
name|inline_failed
argument_list|)
expr_stmt|;
name|e
operator|->
name|inline_failed
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|e
operator|->
name|callee
operator|->
name|global
operator|.
name|inlined
operator|&&
name|flag_unit_at_a_time
condition|)
name|DECL_POSSIBLY_INLINED
argument_list|(
name|e
operator|->
name|callee
operator|->
name|decl
argument_list|)
operator|=
name|true
expr_stmt|;
name|e
operator|->
name|callee
operator|->
name|global
operator|.
name|inlined
operator|=
name|true
expr_stmt|;
name|cgraph_clone_inlined_nodes
argument_list|(
name|e
argument_list|,
name|true
argument_list|,
name|update_original
argument_list|)
expr_stmt|;
name|what
operator|=
name|e
operator|->
name|callee
expr_stmt|;
comment|/* Now update size of caller and all functions caller is inlined into.  */
for|for
control|(
init|;
name|e
operator|&&
operator|!
name|e
operator|->
name|inline_failed
condition|;
name|e
operator|=
name|e
operator|->
name|caller
operator|->
name|callers
control|)
block|{
name|old_insns
operator|=
name|e
operator|->
name|caller
operator|->
name|global
operator|.
name|insns
expr_stmt|;
name|new_insns
operator|=
name|cgraph_estimate_size_after_inlining
argument_list|(
literal|1
argument_list|,
name|e
operator|->
name|caller
argument_list|,
name|what
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|new_insns
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|to
operator|=
name|e
operator|->
name|caller
expr_stmt|;
name|to
operator|->
name|global
operator|.
name|insns
operator|=
name|new_insns
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|what
operator|->
name|global
operator|.
name|inlined_to
operator|==
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_insns
operator|>
name|old_insns
condition|)
name|overall_insns
operator|+=
name|new_insns
operator|-
name|old_insns
expr_stmt|;
name|ncalls_inlined
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Mark all calls of EDGE->CALLEE inlined into EDGE->CALLER.    Return following unredirected edge in the list of callers    of EDGE->CALLEE  */
end_comment

begin_function
specifier|static
name|struct
name|cgraph_edge
modifier|*
name|cgraph_mark_inline
parameter_list|(
name|struct
name|cgraph_edge
modifier|*
name|edge
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|to
init|=
name|edge
operator|->
name|caller
decl_stmt|;
name|struct
name|cgraph_node
modifier|*
name|what
init|=
name|edge
operator|->
name|callee
decl_stmt|;
name|struct
name|cgraph_edge
modifier|*
name|e
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|int
name|times
init|=
literal|0
decl_stmt|;
comment|/* Look for all calls, mark them inline and clone recursively      all inlined functions.  */
for|for
control|(
name|e
operator|=
name|what
operator|->
name|callers
init|;
name|e
condition|;
name|e
operator|=
name|next
control|)
block|{
name|next
operator|=
name|e
operator|->
name|next_caller
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|caller
operator|==
name|to
operator|&&
name|e
operator|->
name|inline_failed
condition|)
block|{
name|cgraph_mark_inline_edge
argument_list|(
name|e
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|edge
condition|)
name|edge
operator|=
name|next
expr_stmt|;
name|times
operator|++
expr_stmt|;
block|}
block|}
name|gcc_assert
argument_list|(
name|times
argument_list|)
expr_stmt|;
return|return
name|edge
return|;
block|}
end_function

begin_comment
comment|/* Estimate the growth caused by inlining NODE into all callees.  */
end_comment

begin_function
specifier|static
name|int
name|cgraph_estimate_growth
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|node
parameter_list|)
block|{
name|int
name|growth
init|=
literal|0
decl_stmt|;
name|struct
name|cgraph_edge
modifier|*
name|e
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|global
operator|.
name|estimated_growth
operator|!=
name|INT_MIN
condition|)
return|return
name|node
operator|->
name|global
operator|.
name|estimated_growth
return|;
for|for
control|(
name|e
operator|=
name|node
operator|->
name|callers
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next_caller
control|)
if|if
condition|(
name|e
operator|->
name|inline_failed
condition|)
name|growth
operator|+=
operator|(
name|cgraph_estimate_size_after_inlining
argument_list|(
literal|1
argument_list|,
name|e
operator|->
name|caller
argument_list|,
name|node
argument_list|)
operator|-
name|e
operator|->
name|caller
operator|->
name|global
operator|.
name|insns
operator|)
expr_stmt|;
comment|/* ??? Wrong for self recursive functions or cases where we decide to not      inline for different reasons, but it is not big deal as in that case      we will keep the body around, but we will also avoid some inlining.  */
if|if
condition|(
operator|!
name|node
operator|->
name|needed
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|node
operator|->
name|decl
argument_list|)
condition|)
name|growth
operator|-=
name|node
operator|->
name|global
operator|.
name|insns
expr_stmt|;
name|node
operator|->
name|global
operator|.
name|estimated_growth
operator|=
name|growth
expr_stmt|;
return|return
name|growth
return|;
block|}
end_function

begin_comment
comment|/* Return false when inlining WHAT into TO is not good idea    as it would cause too large growth of function bodies.      When ONE_ONLY is true, assume that only one call site is going    to be inlined, otherwise figure out how many call sites in    TO calls WHAT and verify that all can be inlined.    */
end_comment

begin_function
specifier|static
name|bool
name|cgraph_check_inline_limits
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|to
parameter_list|,
name|struct
name|cgraph_node
modifier|*
name|what
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|reason
parameter_list|,
name|bool
name|one_only
parameter_list|)
block|{
name|int
name|times
init|=
literal|0
decl_stmt|;
name|struct
name|cgraph_edge
modifier|*
name|e
decl_stmt|;
name|int
name|newsize
decl_stmt|;
name|int
name|limit
decl_stmt|;
if|if
condition|(
name|one_only
condition|)
name|times
operator|=
literal|1
expr_stmt|;
else|else
for|for
control|(
name|e
operator|=
name|to
operator|->
name|callees
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next_callee
control|)
if|if
condition|(
name|e
operator|->
name|callee
operator|==
name|what
condition|)
name|times
operator|++
expr_stmt|;
if|if
condition|(
name|to
operator|->
name|global
operator|.
name|inlined_to
condition|)
name|to
operator|=
name|to
operator|->
name|global
operator|.
name|inlined_to
expr_stmt|;
comment|/* When inlining large function body called once into small function,      take the inlined function as base for limiting the growth.  */
if|if
condition|(
name|to
operator|->
name|local
operator|.
name|self_insns
operator|>
name|what
operator|->
name|local
operator|.
name|self_insns
condition|)
name|limit
operator|=
name|to
operator|->
name|local
operator|.
name|self_insns
expr_stmt|;
else|else
name|limit
operator|=
name|what
operator|->
name|local
operator|.
name|self_insns
expr_stmt|;
name|limit
operator|+=
name|limit
operator|*
name|PARAM_VALUE
argument_list|(
name|PARAM_LARGE_FUNCTION_GROWTH
argument_list|)
operator|/
literal|100
expr_stmt|;
comment|/* Check the size after inlining against the function limits.  But allow      the function to shrink if it went over the limits by forced inlining.  */
name|newsize
operator|=
name|cgraph_estimate_size_after_inlining
argument_list|(
name|times
argument_list|,
name|to
argument_list|,
name|what
argument_list|)
expr_stmt|;
if|if
condition|(
name|newsize
operator|>=
name|to
operator|->
name|global
operator|.
name|insns
operator|&&
name|newsize
operator|>
name|PARAM_VALUE
argument_list|(
name|PARAM_LARGE_FUNCTION_INSNS
argument_list|)
operator|&&
name|newsize
operator|>
name|limit
condition|)
block|{
if|if
condition|(
name|reason
condition|)
operator|*
name|reason
operator|=
name|N_
argument_list|(
literal|"--param large-function-growth limit reached"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Return true when function N is small enough to be inlined.  */
end_comment

begin_function
name|bool
name|cgraph_default_inline_p
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|n
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|reason
parameter_list|)
block|{
name|tree
name|decl
init|=
name|n
operator|->
name|decl
decl_stmt|;
if|if
condition|(
name|n
operator|->
name|inline_decl
condition|)
name|decl
operator|=
name|n
operator|->
name|inline_decl
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_INLINE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|reason
condition|)
operator|*
name|reason
operator|=
name|N_
argument_list|(
literal|"function not inlinable"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|DECL_STRUCT_FUNCTION
argument_list|(
name|decl
argument_list|)
operator|->
name|cfg
condition|)
block|{
if|if
condition|(
name|reason
condition|)
operator|*
name|reason
operator|=
name|N_
argument_list|(
literal|"function body not available"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|DECL_DECLARED_INLINE_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|n
operator|->
name|global
operator|.
name|insns
operator|>=
name|MAX_INLINE_INSNS_SINGLE
condition|)
block|{
if|if
condition|(
name|reason
condition|)
operator|*
name|reason
operator|=
name|N_
argument_list|(
literal|"--param max-inline-insns-single limit reached"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|n
operator|->
name|global
operator|.
name|insns
operator|>=
name|MAX_INLINE_INSNS_AUTO
condition|)
block|{
if|if
condition|(
name|reason
condition|)
operator|*
name|reason
operator|=
name|N_
argument_list|(
literal|"--param max-inline-insns-auto limit reached"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Return true when inlining WHAT would create recursive inlining.    We call recursive inlining all cases where same function appears more than    once in the single recursion nest path in the inline graph.  */
end_comment

begin_function
specifier|static
name|bool
name|cgraph_recursive_inlining_p
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|to
parameter_list|,
name|struct
name|cgraph_node
modifier|*
name|what
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|reason
parameter_list|)
block|{
name|bool
name|recursive
decl_stmt|;
if|if
condition|(
name|to
operator|->
name|global
operator|.
name|inlined_to
condition|)
name|recursive
operator|=
name|what
operator|->
name|decl
operator|==
name|to
operator|->
name|global
operator|.
name|inlined_to
operator|->
name|decl
expr_stmt|;
else|else
name|recursive
operator|=
name|what
operator|->
name|decl
operator|==
name|to
operator|->
name|decl
expr_stmt|;
comment|/* Marking recursive function inline has sane semantic and thus we should      not warn on it.  */
if|if
condition|(
name|recursive
operator|&&
name|reason
condition|)
operator|*
name|reason
operator|=
operator|(
name|what
operator|->
name|local
operator|.
name|disregard_inline_limits
condition|?
name|N_
argument_list|(
literal|"recursive inlining"
argument_list|)
else|:
literal|""
operator|)
expr_stmt|;
return|return
name|recursive
return|;
block|}
end_function

begin_comment
comment|/* Return true if the call can be hot.  */
end_comment

begin_function
specifier|static
name|bool
name|cgraph_maybe_hot_edge_p
parameter_list|(
name|struct
name|cgraph_edge
modifier|*
name|edge
parameter_list|)
block|{
if|if
condition|(
name|profile_info
operator|&&
name|flag_branch_probabilities
operator|&&
operator|(
name|edge
operator|->
name|count
operator|<=
name|profile_info
operator|->
name|sum_max
operator|/
name|PARAM_VALUE
argument_list|(
name|HOT_BB_COUNT_FRACTION
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* A cost model driving the inlining heuristics in a way so the edges with    smallest badness are inlined first.  After each inlining is performed    the costs of all caller edges of nodes affected are recomputed so the    metrics may accurately depend on values such as number of inlinable callers    of the function or function body size.     With profiling we use number of executions of each edge to drive the cost.    We also should distinguish hot and cold calls where the cold calls are    inlined into only when code size is overall improved.      */
end_comment

begin_function
specifier|static
name|int
name|cgraph_edge_badness
parameter_list|(
name|struct
name|cgraph_edge
modifier|*
name|edge
parameter_list|)
block|{
if|if
condition|(
name|max_count
condition|)
block|{
name|int
name|growth
init|=
name|cgraph_estimate_size_after_inlining
argument_list|(
literal|1
argument_list|,
name|edge
operator|->
name|caller
argument_list|,
name|edge
operator|->
name|callee
argument_list|)
decl_stmt|;
name|growth
operator|-=
name|edge
operator|->
name|caller
operator|->
name|global
operator|.
name|insns
expr_stmt|;
comment|/* Always prefer inlining saving code size.  */
if|if
condition|(
name|growth
operator|<=
literal|0
condition|)
return|return
name|INT_MIN
operator|-
name|growth
return|;
return|return
operator|(
call|(
name|int
call|)
argument_list|(
operator|(
name|double
operator|)
name|edge
operator|->
name|count
operator|*
name|INT_MIN
operator|/
name|max_count
argument_list|)
operator|)
operator|/
name|growth
return|;
block|}
else|else
block|{
name|int
name|nest
init|=
name|MIN
argument_list|(
name|edge
operator|->
name|loop_nest
argument_list|,
literal|8
argument_list|)
decl_stmt|;
name|int
name|badness
init|=
name|cgraph_estimate_growth
argument_list|(
name|edge
operator|->
name|callee
argument_list|)
operator|*
literal|256
decl_stmt|;
comment|/* Decrease badness if call is nested.  */
if|if
condition|(
name|badness
operator|>
literal|0
condition|)
name|badness
operator|>>=
name|nest
expr_stmt|;
else|else
name|badness
operator|<<=
name|nest
expr_stmt|;
comment|/* Make recursive inlining happen always after other inlining is done.  */
if|if
condition|(
name|cgraph_recursive_inlining_p
argument_list|(
name|edge
operator|->
name|caller
argument_list|,
name|edge
operator|->
name|callee
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
name|badness
operator|+
literal|1
return|;
else|else
return|return
name|badness
return|;
block|}
block|}
end_function

begin_comment
comment|/* Recompute heap nodes for each of caller edge.  */
end_comment

begin_function
specifier|static
name|void
name|update_caller_keys
parameter_list|(
name|fibheap_t
name|heap
parameter_list|,
name|struct
name|cgraph_node
modifier|*
name|node
parameter_list|,
name|bitmap
name|updated_nodes
parameter_list|)
block|{
name|struct
name|cgraph_edge
modifier|*
name|edge
decl_stmt|;
specifier|const
name|char
modifier|*
name|failed_reason
decl_stmt|;
if|if
condition|(
operator|!
name|node
operator|->
name|local
operator|.
name|inlinable
operator|||
name|node
operator|->
name|local
operator|.
name|disregard_inline_limits
operator|||
name|node
operator|->
name|global
operator|.
name|inlined_to
condition|)
return|return;
if|if
condition|(
name|bitmap_bit_p
argument_list|(
name|updated_nodes
argument_list|,
name|node
operator|->
name|uid
argument_list|)
condition|)
return|return;
name|bitmap_set_bit
argument_list|(
name|updated_nodes
argument_list|,
name|node
operator|->
name|uid
argument_list|)
expr_stmt|;
name|node
operator|->
name|global
operator|.
name|estimated_growth
operator|=
name|INT_MIN
expr_stmt|;
if|if
condition|(
operator|!
name|node
operator|->
name|local
operator|.
name|inlinable
condition|)
return|return;
comment|/* Prune out edges we won't inline into anymore.  */
if|if
condition|(
operator|!
name|cgraph_default_inline_p
argument_list|(
name|node
argument_list|,
operator|&
name|failed_reason
argument_list|)
condition|)
block|{
for|for
control|(
name|edge
operator|=
name|node
operator|->
name|callers
init|;
name|edge
condition|;
name|edge
operator|=
name|edge
operator|->
name|next_caller
control|)
if|if
condition|(
name|edge
operator|->
name|aux
condition|)
block|{
name|fibheap_delete_node
argument_list|(
name|heap
argument_list|,
name|edge
operator|->
name|aux
argument_list|)
expr_stmt|;
name|edge
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|edge
operator|->
name|inline_failed
condition|)
name|edge
operator|->
name|inline_failed
operator|=
name|failed_reason
expr_stmt|;
block|}
return|return;
block|}
for|for
control|(
name|edge
operator|=
name|node
operator|->
name|callers
init|;
name|edge
condition|;
name|edge
operator|=
name|edge
operator|->
name|next_caller
control|)
if|if
condition|(
name|edge
operator|->
name|inline_failed
condition|)
block|{
name|int
name|badness
init|=
name|cgraph_edge_badness
argument_list|(
name|edge
argument_list|)
decl_stmt|;
if|if
condition|(
name|edge
operator|->
name|aux
condition|)
block|{
name|fibnode_t
name|n
init|=
name|edge
operator|->
name|aux
decl_stmt|;
name|gcc_assert
argument_list|(
name|n
operator|->
name|data
operator|==
name|edge
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|key
operator|==
name|badness
condition|)
continue|continue;
comment|/* fibheap_replace_key only increase the keys.  */
if|if
condition|(
name|fibheap_replace_key
argument_list|(
name|heap
argument_list|,
name|n
argument_list|,
name|badness
argument_list|)
condition|)
continue|continue;
name|fibheap_delete_node
argument_list|(
name|heap
argument_list|,
name|edge
operator|->
name|aux
argument_list|)
expr_stmt|;
block|}
name|edge
operator|->
name|aux
operator|=
name|fibheap_insert
argument_list|(
name|heap
argument_list|,
name|badness
argument_list|,
name|edge
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Recompute heap nodes for each of caller edges of each of callees.  */
end_comment

begin_function
specifier|static
name|void
name|update_callee_keys
parameter_list|(
name|fibheap_t
name|heap
parameter_list|,
name|struct
name|cgraph_node
modifier|*
name|node
parameter_list|,
name|bitmap
name|updated_nodes
parameter_list|)
block|{
name|struct
name|cgraph_edge
modifier|*
name|e
decl_stmt|;
name|node
operator|->
name|global
operator|.
name|estimated_growth
operator|=
name|INT_MIN
expr_stmt|;
for|for
control|(
name|e
operator|=
name|node
operator|->
name|callees
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next_callee
control|)
if|if
condition|(
name|e
operator|->
name|inline_failed
condition|)
name|update_caller_keys
argument_list|(
name|heap
argument_list|,
name|e
operator|->
name|callee
argument_list|,
name|updated_nodes
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|e
operator|->
name|inline_failed
condition|)
name|update_callee_keys
argument_list|(
name|heap
argument_list|,
name|e
operator|->
name|callee
argument_list|,
name|updated_nodes
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Enqueue all recursive calls from NODE into priority queue depending on    how likely we want to recursively inline the call.  */
end_comment

begin_function
specifier|static
name|void
name|lookup_recursive_calls
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|node
parameter_list|,
name|struct
name|cgraph_node
modifier|*
name|where
parameter_list|,
name|fibheap_t
name|heap
parameter_list|)
block|{
specifier|static
name|int
name|priority
decl_stmt|;
name|struct
name|cgraph_edge
modifier|*
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|where
operator|->
name|callees
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next_callee
control|)
if|if
condition|(
name|e
operator|->
name|callee
operator|==
name|node
condition|)
block|{
comment|/* When profile feedback is available, prioritize by expected number 	   of calls.  Without profile feedback we maintain simple queue 	   to order candidates via recursive depths.  */
name|fibheap_insert
argument_list|(
name|heap
argument_list|,
operator|!
name|max_count
condition|?
name|priority
operator|++
else|:
operator|-
operator|(
name|e
operator|->
name|count
operator|/
operator|(
operator|(
name|max_count
operator|+
operator|(
literal|1
operator|<<
literal|24
operator|)
operator|-
literal|1
operator|)
operator|/
operator|(
literal|1
operator|<<
literal|24
operator|)
operator|)
operator|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|e
operator|=
name|where
operator|->
name|callees
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next_callee
control|)
if|if
condition|(
operator|!
name|e
operator|->
name|inline_failed
condition|)
name|lookup_recursive_calls
argument_list|(
name|node
argument_list|,
name|e
operator|->
name|callee
argument_list|,
name|heap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find callgraph nodes closing a circle in the graph.  The    resulting hashtab can be used to avoid walking the circles.    Uses the cgraph nodes ->aux field which needs to be zero    before and will be zero after operation.  */
end_comment

begin_function
specifier|static
name|void
name|cgraph_find_cycles
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|node
parameter_list|,
name|htab_t
name|cycles
parameter_list|)
block|{
name|struct
name|cgraph_edge
modifier|*
name|e
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|aux
condition|)
block|{
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
name|slot
operator|=
name|htab_find_slot
argument_list|(
name|cycles
argument_list|,
name|node
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|slot
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Cycle contains %s\n"
argument_list|,
name|cgraph_node_name
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|slot
operator|=
name|node
expr_stmt|;
block|}
return|return;
block|}
name|node
operator|->
name|aux
operator|=
name|node
expr_stmt|;
for|for
control|(
name|e
operator|=
name|node
operator|->
name|callees
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next_callee
control|)
name|cgraph_find_cycles
argument_list|(
name|e
operator|->
name|callee
argument_list|,
name|cycles
argument_list|)
expr_stmt|;
name|node
operator|->
name|aux
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Flatten the cgraph node.  We have to be careful in recursing    as to not run endlessly in circles of the callgraph.    We do so by using a hashtab of cycle entering nodes as generated    by cgraph_find_cycles.  */
end_comment

begin_function
specifier|static
name|void
name|cgraph_flatten_node
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|node
parameter_list|,
name|htab_t
name|cycles
parameter_list|)
block|{
name|struct
name|cgraph_edge
modifier|*
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|node
operator|->
name|callees
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next_callee
control|)
block|{
comment|/* Inline call, if possible, and recurse.  Be sure we are not 	 entering callgraph circles here.  */
if|if
condition|(
name|e
operator|->
name|inline_failed
operator|&&
name|e
operator|->
name|callee
operator|->
name|local
operator|.
name|inlinable
operator|&&
operator|!
name|cgraph_recursive_inlining_p
argument_list|(
name|node
argument_list|,
name|e
operator|->
name|callee
argument_list|,
operator|&
name|e
operator|->
name|inline_failed
argument_list|)
operator|&&
operator|!
name|htab_find
argument_list|(
name|cycles
argument_list|,
name|e
operator|->
name|callee
argument_list|)
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" inlining %s"
argument_list|,
name|cgraph_node_name
argument_list|(
name|e
operator|->
name|callee
argument_list|)
argument_list|)
expr_stmt|;
name|cgraph_mark_inline_edge
argument_list|(
name|e
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|cgraph_flatten_node
argument_list|(
name|e
operator|->
name|callee
argument_list|,
name|cycles
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" !inlining %s"
argument_list|,
name|cgraph_node_name
argument_list|(
name|e
operator|->
name|callee
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Decide on recursive inlining: in the case function has recursive calls,    inline until body size reaches given argument.  */
end_comment

begin_function
specifier|static
name|bool
name|cgraph_decide_recursive_inlining
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|node
parameter_list|)
block|{
name|int
name|limit
init|=
name|PARAM_VALUE
argument_list|(
name|PARAM_MAX_INLINE_INSNS_RECURSIVE_AUTO
argument_list|)
decl_stmt|;
name|int
name|max_depth
init|=
name|PARAM_VALUE
argument_list|(
name|PARAM_MAX_INLINE_RECURSIVE_DEPTH_AUTO
argument_list|)
decl_stmt|;
name|int
name|probability
init|=
name|PARAM_VALUE
argument_list|(
name|PARAM_MIN_INLINE_RECURSIVE_PROBABILITY
argument_list|)
decl_stmt|;
name|fibheap_t
name|heap
decl_stmt|;
name|struct
name|cgraph_edge
modifier|*
name|e
decl_stmt|;
name|struct
name|cgraph_node
modifier|*
name|master_clone
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|int
name|depth
init|=
literal|0
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|DECL_DECLARED_INLINE_P
argument_list|(
name|node
operator|->
name|decl
argument_list|)
condition|)
block|{
name|limit
operator|=
name|PARAM_VALUE
argument_list|(
name|PARAM_MAX_INLINE_INSNS_RECURSIVE
argument_list|)
expr_stmt|;
name|max_depth
operator|=
name|PARAM_VALUE
argument_list|(
name|PARAM_MAX_INLINE_RECURSIVE_DEPTH
argument_list|)
expr_stmt|;
block|}
comment|/* Make sure that function is small enough to be considered for inlining.  */
if|if
condition|(
operator|!
name|max_depth
operator|||
name|cgraph_estimate_size_after_inlining
argument_list|(
literal|1
argument_list|,
name|node
argument_list|,
name|node
argument_list|)
operator|>=
name|limit
condition|)
return|return
name|false
return|;
name|heap
operator|=
name|fibheap_new
argument_list|()
expr_stmt|;
name|lookup_recursive_calls
argument_list|(
name|node
argument_list|,
name|node
argument_list|,
name|heap
argument_list|)
expr_stmt|;
if|if
condition|(
name|fibheap_empty
argument_list|(
name|heap
argument_list|)
condition|)
block|{
name|fibheap_delete
argument_list|(
name|heap
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  Performing recursive inlining on %s\n"
argument_list|,
name|cgraph_node_name
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We need original clone to copy around.  */
name|master_clone
operator|=
name|cgraph_clone_node
argument_list|(
name|node
argument_list|,
name|node
operator|->
name|count
argument_list|,
literal|1
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|master_clone
operator|->
name|needed
operator|=
name|true
expr_stmt|;
for|for
control|(
name|e
operator|=
name|master_clone
operator|->
name|callees
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next_callee
control|)
if|if
condition|(
operator|!
name|e
operator|->
name|inline_failed
condition|)
name|cgraph_clone_inlined_nodes
argument_list|(
name|e
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* Do the inlining and update list of recursive call during process.  */
while|while
condition|(
operator|!
name|fibheap_empty
argument_list|(
name|heap
argument_list|)
operator|&&
operator|(
name|cgraph_estimate_size_after_inlining
argument_list|(
literal|1
argument_list|,
name|node
argument_list|,
name|master_clone
argument_list|)
operator|<=
name|limit
operator|)
condition|)
block|{
name|struct
name|cgraph_edge
modifier|*
name|curr
init|=
name|fibheap_extract_min
argument_list|(
name|heap
argument_list|)
decl_stmt|;
name|struct
name|cgraph_node
modifier|*
name|cnode
decl_stmt|;
name|depth
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|cnode
operator|=
name|curr
operator|->
name|caller
init|;
name|cnode
operator|->
name|global
operator|.
name|inlined_to
condition|;
name|cnode
operator|=
name|cnode
operator|->
name|callers
operator|->
name|caller
control|)
if|if
condition|(
name|node
operator|->
name|decl
operator|==
name|curr
operator|->
name|callee
operator|->
name|decl
condition|)
name|depth
operator|++
expr_stmt|;
if|if
condition|(
name|depth
operator|>
name|max_depth
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"   maxmal depth reached\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|max_count
condition|)
block|{
if|if
condition|(
operator|!
name|cgraph_maybe_hot_edge_p
argument_list|(
name|curr
argument_list|)
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"   Not inlining cold call\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|curr
operator|->
name|count
operator|*
literal|100
operator|/
name|node
operator|->
name|count
operator|<
name|probability
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"   Probability of edge is too small\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"   Inlining call of depth %i"
argument_list|,
name|depth
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|count
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" called approx. %.2f times per call"
argument_list|,
operator|(
name|double
operator|)
name|curr
operator|->
name|count
operator|/
name|node
operator|->
name|count
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|cgraph_redirect_edge_callee
argument_list|(
name|curr
argument_list|,
name|master_clone
argument_list|)
expr_stmt|;
name|cgraph_mark_inline_edge
argument_list|(
name|curr
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|lookup_recursive_calls
argument_list|(
name|node
argument_list|,
name|curr
operator|->
name|callee
argument_list|,
name|heap
argument_list|)
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fibheap_empty
argument_list|(
name|heap
argument_list|)
operator|&&
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"    Recursive inlining growth limit met.\n"
argument_list|)
expr_stmt|;
name|fibheap_delete
argument_list|(
name|heap
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n   Inlined %i times, body grown from %i to %i insns\n"
argument_list|,
name|n
argument_list|,
name|master_clone
operator|->
name|global
operator|.
name|insns
argument_list|,
name|node
operator|->
name|global
operator|.
name|insns
argument_list|)
expr_stmt|;
comment|/* Remove master clone we used for inlining.  We rely that clones inlined      into master clone gets queued just before master clone so we don't      need recursion.  */
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
operator|!=
name|master_clone
condition|;
name|node
operator|=
name|next
control|)
block|{
name|next
operator|=
name|node
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|global
operator|.
name|inlined_to
operator|==
name|master_clone
condition|)
name|cgraph_remove_node
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
name|cgraph_remove_node
argument_list|(
name|master_clone
argument_list|)
expr_stmt|;
comment|/* FIXME: Recursive inlining actually reduces number of calls of the      function.  At this place we should probably walk the function and      inline clones and compensate the counts accordingly.  This probably      doesn't matter much in practice.  */
return|return
name|n
operator|>
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Set inline_failed for all callers of given function to REASON.  */
end_comment

begin_function
specifier|static
name|void
name|cgraph_set_inline_failed
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|node
parameter_list|,
specifier|const
name|char
modifier|*
name|reason
parameter_list|)
block|{
name|struct
name|cgraph_edge
modifier|*
name|e
decl_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Inlining failed: %s\n"
argument_list|,
name|reason
argument_list|)
expr_stmt|;
for|for
control|(
name|e
operator|=
name|node
operator|->
name|callers
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next_caller
control|)
if|if
condition|(
name|e
operator|->
name|inline_failed
condition|)
name|e
operator|->
name|inline_failed
operator|=
name|reason
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We use greedy algorithm for inlining of small functions:    All inline candidates are put into prioritized heap based on estimated    growth of the overall number of instructions and then update the estimates.     INLINED and INLINED_CALEES are just pointers to arrays large enough    to be passed to cgraph_inlined_into and cgraph_inlined_callees.  */
end_comment

begin_function
specifier|static
name|void
name|cgraph_decide_inlining_of_small_functions
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|node
decl_stmt|;
name|struct
name|cgraph_edge
modifier|*
name|edge
decl_stmt|;
specifier|const
name|char
modifier|*
name|failed_reason
decl_stmt|;
name|fibheap_t
name|heap
init|=
name|fibheap_new
argument_list|()
decl_stmt|;
name|bitmap
name|updated_nodes
init|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nDeciding on smaller functions:\n"
argument_list|)
expr_stmt|;
comment|/* Put all inline candidates into the heap.  */
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|node
operator|->
name|local
operator|.
name|inlinable
operator|||
operator|!
name|node
operator|->
name|callers
operator|||
name|node
operator|->
name|local
operator|.
name|disregard_inline_limits
condition|)
continue|continue;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Considering inline candidate %s.\n"
argument_list|,
name|cgraph_node_name
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|->
name|global
operator|.
name|estimated_growth
operator|=
name|INT_MIN
expr_stmt|;
if|if
condition|(
operator|!
name|cgraph_default_inline_p
argument_list|(
name|node
argument_list|,
operator|&
name|failed_reason
argument_list|)
condition|)
block|{
name|cgraph_set_inline_failed
argument_list|(
name|node
argument_list|,
name|failed_reason
argument_list|)
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|edge
operator|=
name|node
operator|->
name|callers
init|;
name|edge
condition|;
name|edge
operator|=
name|edge
operator|->
name|next_caller
control|)
if|if
condition|(
name|edge
operator|->
name|inline_failed
condition|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|edge
operator|->
name|aux
argument_list|)
expr_stmt|;
name|edge
operator|->
name|aux
operator|=
name|fibheap_insert
argument_list|(
name|heap
argument_list|,
name|cgraph_edge_badness
argument_list|(
name|edge
argument_list|)
argument_list|,
name|edge
argument_list|)
expr_stmt|;
block|}
block|}
while|while
condition|(
name|overall_insns
operator|<=
name|max_insns
operator|&&
operator|(
name|edge
operator|=
name|fibheap_extract_min
argument_list|(
name|heap
argument_list|)
operator|)
condition|)
block|{
name|int
name|old_insns
init|=
name|overall_insns
decl_stmt|;
name|struct
name|cgraph_node
modifier|*
name|where
decl_stmt|;
name|int
name|growth
init|=
name|cgraph_estimate_size_after_inlining
argument_list|(
literal|1
argument_list|,
name|edge
operator|->
name|caller
argument_list|,
name|edge
operator|->
name|callee
argument_list|)
decl_stmt|;
name|growth
operator|-=
name|edge
operator|->
name|caller
operator|->
name|global
operator|.
name|insns
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nConsidering %s with %i insns\n"
argument_list|,
name|cgraph_node_name
argument_list|(
name|edge
operator|->
name|callee
argument_list|)
argument_list|,
name|edge
operator|->
name|callee
operator|->
name|global
operator|.
name|insns
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" to be inlined into %s\n"
literal|" Estimated growth after inlined into all callees is %+i insns.\n"
literal|" Estimated badness is %i.\n"
argument_list|,
name|cgraph_node_name
argument_list|(
name|edge
operator|->
name|caller
argument_list|)
argument_list|,
name|cgraph_estimate_growth
argument_list|(
name|edge
operator|->
name|callee
argument_list|)
argument_list|,
name|cgraph_edge_badness
argument_list|(
name|edge
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|edge
operator|->
name|count
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" Called "
name|HOST_WIDEST_INT_PRINT_DEC
literal|"x\n"
argument_list|,
name|edge
operator|->
name|count
argument_list|)
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|edge
operator|->
name|aux
argument_list|)
expr_stmt|;
name|edge
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|edge
operator|->
name|inline_failed
condition|)
continue|continue;
comment|/* When not having profile info ready we don't weight by any way the          position of call in procedure itself.  This means if call of 	 function A from function B seems profitable to inline, the recursive 	 call of function A in inline copy of A in B will look profitable too 	 and we end up inlining until reaching maximal function growth.  This 	 is not good idea so prohibit the recursive inlining.  	 ??? When the frequencies are taken into account we might not need this 	 restriction.   */
if|if
condition|(
operator|!
name|max_count
condition|)
block|{
name|where
operator|=
name|edge
operator|->
name|caller
expr_stmt|;
while|while
condition|(
name|where
operator|->
name|global
operator|.
name|inlined_to
condition|)
block|{
if|if
condition|(
name|where
operator|->
name|decl
operator|==
name|edge
operator|->
name|callee
operator|->
name|decl
condition|)
break|break;
name|where
operator|=
name|where
operator|->
name|callers
operator|->
name|caller
expr_stmt|;
block|}
if|if
condition|(
name|where
operator|->
name|global
operator|.
name|inlined_to
condition|)
block|{
name|edge
operator|->
name|inline_failed
operator|=
operator|(
name|edge
operator|->
name|callee
operator|->
name|local
operator|.
name|disregard_inline_limits
condition|?
name|N_
argument_list|(
literal|"recursive inlining"
argument_list|)
else|:
literal|""
operator|)
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" inline_failed:Recursive inlining performed only for function itself.\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
operator|!
name|cgraph_maybe_hot_edge_p
argument_list|(
name|edge
argument_list|)
operator|&&
name|growth
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|cgraph_recursive_inlining_p
argument_list|(
name|edge
operator|->
name|caller
argument_list|,
name|edge
operator|->
name|callee
argument_list|,
operator|&
name|edge
operator|->
name|inline_failed
argument_list|)
condition|)
block|{
name|edge
operator|->
name|inline_failed
operator|=
name|N_
argument_list|(
literal|"call is unlikely"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" inline_failed:%s.\n"
argument_list|,
name|edge
operator|->
name|inline_failed
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
operator|!
name|cgraph_default_inline_p
argument_list|(
name|edge
operator|->
name|callee
argument_list|,
operator|&
name|edge
operator|->
name|inline_failed
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|cgraph_recursive_inlining_p
argument_list|(
name|edge
operator|->
name|caller
argument_list|,
name|edge
operator|->
name|callee
argument_list|,
operator|&
name|edge
operator|->
name|inline_failed
argument_list|)
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" inline_failed:%s.\n"
argument_list|,
name|edge
operator|->
name|inline_failed
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|cgraph_recursive_inlining_p
argument_list|(
name|edge
operator|->
name|caller
argument_list|,
name|edge
operator|->
name|callee
argument_list|,
operator|&
name|edge
operator|->
name|inline_failed
argument_list|)
condition|)
block|{
name|where
operator|=
name|edge
operator|->
name|caller
expr_stmt|;
if|if
condition|(
name|where
operator|->
name|global
operator|.
name|inlined_to
condition|)
name|where
operator|=
name|where
operator|->
name|global
operator|.
name|inlined_to
expr_stmt|;
if|if
condition|(
operator|!
name|cgraph_decide_recursive_inlining
argument_list|(
name|where
argument_list|)
condition|)
continue|continue;
name|update_callee_keys
argument_list|(
name|heap
argument_list|,
name|where
argument_list|,
name|updated_nodes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|cgraph_node
modifier|*
name|callee
decl_stmt|;
if|if
condition|(
operator|!
name|cgraph_check_inline_limits
argument_list|(
name|edge
operator|->
name|caller
argument_list|,
name|edge
operator|->
name|callee
argument_list|,
operator|&
name|edge
operator|->
name|inline_failed
argument_list|,
name|true
argument_list|)
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" Not inlining into %s:%s.\n"
argument_list|,
name|cgraph_node_name
argument_list|(
name|edge
operator|->
name|caller
argument_list|)
argument_list|,
name|edge
operator|->
name|inline_failed
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|callee
operator|=
name|edge
operator|->
name|callee
expr_stmt|;
name|cgraph_mark_inline_edge
argument_list|(
name|edge
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|update_callee_keys
argument_list|(
name|heap
argument_list|,
name|callee
argument_list|,
name|updated_nodes
argument_list|)
expr_stmt|;
block|}
name|where
operator|=
name|edge
operator|->
name|caller
expr_stmt|;
if|if
condition|(
name|where
operator|->
name|global
operator|.
name|inlined_to
condition|)
name|where
operator|=
name|where
operator|->
name|global
operator|.
name|inlined_to
expr_stmt|;
comment|/* Our profitability metric can depend on local properties 	 such as number of inlinable calls and size of the function body. 	 After inlining these properties might change for the function we 	 inlined into (since it's body size changed) and for the functions 	 called by function we inlined (since number of it inlinable callers 	 might change).  */
name|update_caller_keys
argument_list|(
name|heap
argument_list|,
name|where
argument_list|,
name|updated_nodes
argument_list|)
expr_stmt|;
name|bitmap_clear
argument_list|(
name|updated_nodes
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" Inlined into %s which now has %i insns,"
literal|"net change of %+i insns.\n"
argument_list|,
name|cgraph_node_name
argument_list|(
name|edge
operator|->
name|caller
argument_list|)
argument_list|,
name|edge
operator|->
name|caller
operator|->
name|global
operator|.
name|insns
argument_list|,
name|overall_insns
operator|-
name|old_insns
argument_list|)
expr_stmt|;
block|}
block|}
while|while
condition|(
operator|(
name|edge
operator|=
name|fibheap_extract_min
argument_list|(
name|heap
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|gcc_assert
argument_list|(
name|edge
operator|->
name|aux
argument_list|)
expr_stmt|;
name|edge
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|edge
operator|->
name|callee
operator|->
name|local
operator|.
name|disregard_inline_limits
operator|&&
name|edge
operator|->
name|inline_failed
operator|&&
operator|!
name|cgraph_recursive_inlining_p
argument_list|(
name|edge
operator|->
name|caller
argument_list|,
name|edge
operator|->
name|callee
argument_list|,
operator|&
name|edge
operator|->
name|inline_failed
argument_list|)
condition|)
name|edge
operator|->
name|inline_failed
operator|=
name|N_
argument_list|(
literal|"--param inline-unit-growth limit reached"
argument_list|)
expr_stmt|;
block|}
name|fibheap_delete
argument_list|(
name|heap
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|updated_nodes
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Decide on the inlining.  We do so in the topological order to avoid    expenses on updating data structures.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|cgraph_decide_inlining
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|node
decl_stmt|;
name|int
name|nnodes
decl_stmt|;
name|struct
name|cgraph_node
modifier|*
modifier|*
name|order
init|=
name|XCNEWVEC
argument_list|(
expr|struct
name|cgraph_node
operator|*
argument_list|,
name|cgraph_n_nodes
argument_list|)
decl_stmt|;
name|int
name|old_insns
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_INLINE_HEURISTICS
argument_list|)
expr_stmt|;
name|max_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
if|if
condition|(
name|node
operator|->
name|analyzed
operator|&&
operator|(
name|node
operator|->
name|needed
operator|||
name|node
operator|->
name|reachable
operator|)
condition|)
block|{
name|struct
name|cgraph_edge
modifier|*
name|e
decl_stmt|;
comment|/* At the moment, no IPA passes change function bodies before inlining. 	   Save some time by not recomputing function body sizes if early inlining 	   already did so.  */
if|if
condition|(
operator|!
name|flag_early_inlining
condition|)
name|node
operator|->
name|local
operator|.
name|self_insns
operator|=
name|node
operator|->
name|global
operator|.
name|insns
operator|=
name|estimate_num_insns
argument_list|(
name|node
operator|->
name|decl
argument_list|)
expr_stmt|;
name|initial_insns
operator|+=
name|node
operator|->
name|local
operator|.
name|self_insns
expr_stmt|;
name|gcc_assert
argument_list|(
name|node
operator|->
name|local
operator|.
name|self_insns
operator|==
name|node
operator|->
name|global
operator|.
name|insns
argument_list|)
expr_stmt|;
for|for
control|(
name|e
operator|=
name|node
operator|->
name|callees
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next_callee
control|)
if|if
condition|(
name|max_count
operator|<
name|e
operator|->
name|count
condition|)
name|max_count
operator|=
name|e
operator|->
name|count
expr_stmt|;
block|}
name|overall_insns
operator|=
name|initial_insns
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|max_count
operator|||
operator|(
name|profile_info
operator|&&
name|flag_branch_probabilities
operator|)
argument_list|)
expr_stmt|;
name|max_insns
operator|=
name|overall_insns
expr_stmt|;
if|if
condition|(
name|max_insns
operator|<
name|PARAM_VALUE
argument_list|(
name|PARAM_LARGE_UNIT_INSNS
argument_list|)
condition|)
name|max_insns
operator|=
name|PARAM_VALUE
argument_list|(
name|PARAM_LARGE_UNIT_INSNS
argument_list|)
expr_stmt|;
name|max_insns
operator|=
operator|(
operator|(
name|HOST_WIDEST_INT
operator|)
name|max_insns
operator|*
operator|(
literal|100
operator|+
name|PARAM_VALUE
argument_list|(
name|PARAM_INLINE_UNIT_GROWTH
argument_list|)
operator|)
operator|/
literal|100
operator|)
expr_stmt|;
name|nnodes
operator|=
name|cgraph_postorder
argument_list|(
name|order
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nDeciding on inlining.  Starting with %i insns.\n"
argument_list|,
name|initial_insns
argument_list|)
expr_stmt|;
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
name|node
operator|->
name|aux
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nInlining always_inline functions:\n"
argument_list|)
expr_stmt|;
comment|/* In the first pass mark all always_inline edges.  Do this with a priority      so none of our later choices will make this impossible.  */
for|for
control|(
name|i
operator|=
name|nnodes
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|struct
name|cgraph_edge
modifier|*
name|e
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|node
operator|=
name|order
index|[
name|i
index|]
expr_stmt|;
comment|/* Handle nodes to be flattened, but don't update overall unit size.  */
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"flatten"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|node
operator|->
name|decl
argument_list|)
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|old_overall_insns
init|=
name|overall_insns
decl_stmt|;
name|htab_t
name|cycles
decl_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Flattening %s\n"
argument_list|,
name|cgraph_node_name
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|cycles
operator|=
name|htab_create
argument_list|(
literal|7
argument_list|,
name|htab_hash_pointer
argument_list|,
name|htab_eq_pointer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cgraph_find_cycles
argument_list|(
name|node
argument_list|,
name|cycles
argument_list|)
expr_stmt|;
name|cgraph_flatten_node
argument_list|(
name|node
argument_list|,
name|cycles
argument_list|)
expr_stmt|;
name|htab_delete
argument_list|(
name|cycles
argument_list|)
expr_stmt|;
name|overall_insns
operator|=
name|old_overall_insns
expr_stmt|;
comment|/* We don't need to consider always_inline functions inside the flattened 	     function anymore.  */
continue|continue;
block|}
if|if
condition|(
operator|!
name|node
operator|->
name|local
operator|.
name|disregard_inline_limits
condition|)
continue|continue;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nConsidering %s %i insns (always inline)\n"
argument_list|,
name|cgraph_node_name
argument_list|(
name|node
argument_list|)
argument_list|,
name|node
operator|->
name|global
operator|.
name|insns
argument_list|)
expr_stmt|;
name|old_insns
operator|=
name|overall_insns
expr_stmt|;
for|for
control|(
name|e
operator|=
name|node
operator|->
name|callers
init|;
name|e
condition|;
name|e
operator|=
name|next
control|)
block|{
name|next
operator|=
name|e
operator|->
name|next_caller
expr_stmt|;
if|if
condition|(
operator|!
name|e
operator|->
name|inline_failed
condition|)
continue|continue;
if|if
condition|(
name|cgraph_recursive_inlining_p
argument_list|(
name|e
operator|->
name|caller
argument_list|,
name|e
operator|->
name|callee
argument_list|,
operator|&
name|e
operator|->
name|inline_failed
argument_list|)
condition|)
continue|continue;
name|cgraph_mark_inline_edge
argument_list|(
name|e
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" Inlined into %s which now has %i insns.\n"
argument_list|,
name|cgraph_node_name
argument_list|(
name|e
operator|->
name|caller
argument_list|)
argument_list|,
name|e
operator|->
name|caller
operator|->
name|global
operator|.
name|insns
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" Inlined for a net change of %+i insns.\n"
argument_list|,
name|overall_insns
operator|-
name|old_insns
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|flag_really_no_inline
condition|)
name|cgraph_decide_inlining_of_small_functions
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|flag_really_no_inline
operator|&&
name|flag_inline_functions_called_once
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nDeciding on functions called once:\n"
argument_list|)
expr_stmt|;
comment|/* And finally decide what functions are called once.  */
for|for
control|(
name|i
operator|=
name|nnodes
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|node
operator|=
name|order
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|callers
operator|&&
operator|!
name|node
operator|->
name|callers
operator|->
name|next_caller
operator|&&
operator|!
name|node
operator|->
name|needed
operator|&&
name|node
operator|->
name|local
operator|.
name|inlinable
operator|&&
name|node
operator|->
name|callers
operator|->
name|inline_failed
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|node
operator|->
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_COMDAT
argument_list|(
name|node
operator|->
name|decl
argument_list|)
condition|)
block|{
name|bool
name|ok
init|=
name|true
decl_stmt|;
name|struct
name|cgraph_node
modifier|*
name|node1
decl_stmt|;
comment|/* Verify that we won't duplicate the caller.  */
for|for
control|(
name|node1
operator|=
name|node
operator|->
name|callers
operator|->
name|caller
init|;
name|node1
operator|->
name|callers
operator|&&
operator|!
name|node1
operator|->
name|callers
operator|->
name|inline_failed
operator|&&
name|ok
condition|;
name|node1
operator|=
name|node1
operator|->
name|callers
operator|->
name|caller
control|)
if|if
condition|(
name|node1
operator|->
name|callers
operator|->
name|next_caller
operator|||
name|node1
operator|->
name|needed
condition|)
name|ok
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|ok
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nConsidering %s %i insns.\n"
argument_list|,
name|cgraph_node_name
argument_list|(
name|node
argument_list|)
argument_list|,
name|node
operator|->
name|global
operator|.
name|insns
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" Called once from %s %i insns.\n"
argument_list|,
name|cgraph_node_name
argument_list|(
name|node
operator|->
name|callers
operator|->
name|caller
argument_list|)
argument_list|,
name|node
operator|->
name|callers
operator|->
name|caller
operator|->
name|global
operator|.
name|insns
argument_list|)
expr_stmt|;
block|}
name|old_insns
operator|=
name|overall_insns
expr_stmt|;
if|if
condition|(
name|cgraph_check_inline_limits
argument_list|(
name|node
operator|->
name|callers
operator|->
name|caller
argument_list|,
name|node
argument_list|,
name|NULL
argument_list|,
name|false
argument_list|)
condition|)
block|{
name|cgraph_mark_inline
argument_list|(
name|node
operator|->
name|callers
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" Inlined into %s which now has %i insns"
literal|" for a net change of %+i insns.\n"
argument_list|,
name|cgraph_node_name
argument_list|(
name|node
operator|->
name|callers
operator|->
name|caller
argument_list|)
argument_list|,
name|node
operator|->
name|callers
operator|->
name|caller
operator|->
name|global
operator|.
name|insns
argument_list|,
name|overall_insns
operator|-
name|old_insns
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" Inline limit reached, not inlined.\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nInlined %i calls, eliminated %i functions, "
literal|"%i insns turned to %i insns.\n\n"
argument_list|,
name|ncalls_inlined
argument_list|,
name|nfunctions_inlined
argument_list|,
name|initial_insns
argument_list|,
name|overall_insns
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|order
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_INLINE_HEURISTICS
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Decide on the inlining.  We do so in the topological order to avoid    expenses on updating data structures.  */
end_comment

begin_function
name|bool
name|cgraph_decide_inlining_incrementally
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|node
parameter_list|,
name|bool
name|early
parameter_list|)
block|{
name|struct
name|cgraph_edge
modifier|*
name|e
decl_stmt|;
name|bool
name|inlined
init|=
name|false
decl_stmt|;
specifier|const
name|char
modifier|*
name|failed_reason
decl_stmt|;
comment|/* First of all look for always inline functions.  */
for|for
control|(
name|e
operator|=
name|node
operator|->
name|callees
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next_callee
control|)
if|if
condition|(
name|e
operator|->
name|callee
operator|->
name|local
operator|.
name|disregard_inline_limits
operator|&&
name|e
operator|->
name|inline_failed
operator|&&
operator|!
name|cgraph_recursive_inlining_p
argument_list|(
name|node
argument_list|,
name|e
operator|->
name|callee
argument_list|,
operator|&
name|e
operator|->
name|inline_failed
argument_list|)
comment|/* ??? It is possible that renaming variable removed the function body 	   in duplicate_decls. See gcc.c-torture/compile/20011119-2.c  */
operator|&&
operator|(
name|DECL_SAVED_TREE
argument_list|(
name|e
operator|->
name|callee
operator|->
name|decl
argument_list|)
operator|||
name|e
operator|->
name|callee
operator|->
name|inline_decl
operator|)
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
name|early
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  Early inlining %s"
argument_list|,
name|cgraph_node_name
argument_list|(
name|e
operator|->
name|callee
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" into %s\n"
argument_list|,
name|cgraph_node_name
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|cgraph_mark_inline
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|inlined
operator|=
name|true
expr_stmt|;
block|}
comment|/* Now do the automatic inlining.  */
if|if
condition|(
operator|!
name|flag_really_no_inline
condition|)
for|for
control|(
name|e
operator|=
name|node
operator|->
name|callees
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next_callee
control|)
if|if
condition|(
name|e
operator|->
name|callee
operator|->
name|local
operator|.
name|inlinable
operator|&&
name|e
operator|->
name|inline_failed
operator|&&
operator|!
name|e
operator|->
name|callee
operator|->
name|local
operator|.
name|disregard_inline_limits
operator|&&
operator|!
name|cgraph_recursive_inlining_p
argument_list|(
name|node
argument_list|,
name|e
operator|->
name|callee
argument_list|,
operator|&
name|e
operator|->
name|inline_failed
argument_list|)
operator|&&
operator|(
operator|!
name|early
operator|||
operator|(
name|cgraph_estimate_size_after_inlining
argument_list|(
literal|1
argument_list|,
name|e
operator|->
name|caller
argument_list|,
name|e
operator|->
name|callee
argument_list|)
operator|<=
name|e
operator|->
name|caller
operator|->
name|global
operator|.
name|insns
operator|)
operator|)
operator|&&
name|cgraph_check_inline_limits
argument_list|(
name|node
argument_list|,
name|e
operator|->
name|callee
argument_list|,
operator|&
name|e
operator|->
name|inline_failed
argument_list|,
name|false
argument_list|)
operator|&&
operator|(
name|DECL_SAVED_TREE
argument_list|(
name|e
operator|->
name|callee
operator|->
name|decl
argument_list|)
operator|||
name|e
operator|->
name|callee
operator|->
name|inline_decl
operator|)
condition|)
block|{
if|if
condition|(
name|cgraph_default_inline_p
argument_list|(
name|e
operator|->
name|callee
argument_list|,
operator|&
name|failed_reason
argument_list|)
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
name|early
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  Early inlining %s"
argument_list|,
name|cgraph_node_name
argument_list|(
name|e
operator|->
name|callee
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" into %s\n"
argument_list|,
name|cgraph_node_name
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|cgraph_mark_inline
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|inlined
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|early
condition|)
name|e
operator|->
name|inline_failed
operator|=
name|failed_reason
expr_stmt|;
block|}
if|if
condition|(
name|early
operator|&&
name|inlined
condition|)
block|{
name|push_cfun
argument_list|(
name|DECL_STRUCT_FUNCTION
argument_list|(
name|node
operator|->
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|tree_register_cfg_hooks
argument_list|()
expr_stmt|;
name|current_function_decl
operator|=
name|node
operator|->
name|decl
expr_stmt|;
name|optimize_inline_calls
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
name|node
operator|->
name|local
operator|.
name|self_insns
operator|=
name|node
operator|->
name|global
operator|.
name|insns
expr_stmt|;
name|current_function_decl
operator|=
name|NULL
expr_stmt|;
name|pop_cfun
argument_list|()
expr_stmt|;
block|}
return|return
name|inlined
return|;
block|}
end_function

begin_comment
comment|/* When inlining shall be performed.  */
end_comment

begin_function
specifier|static
name|bool
name|cgraph_gate_inlining
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|flag_inline_trees
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_ipa_inline
init|=
block|{
literal|"inline"
block|,
comment|/* name */
name|cgraph_gate_inlining
block|,
comment|/* gate */
name|cgraph_decide_inlining
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
name|TV_INTEGRATION
block|,
comment|/* tv_id */
literal|0
block|,
comment|/* properties_required */
name|PROP_cfg
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_dump_cgraph
operator||
name|TODO_dump_func
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Because inlining might remove no-longer reachable nodes, we need to    keep the array visible to garbage collector to avoid reading collected    out nodes.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nnodes
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(length (
literal|"nnodes"
argument|))
argument_list|)
expr|struct
name|cgraph_node
operator|*
operator|*
name|order
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Do inlining of small functions.  Doing so early helps profiling and other    passes to be somewhat more effective and avoids some code duplication in    later real inlining pass for testcases with very many function calls.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|cgraph_early_inlining
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|node
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|sorrycount
operator|||
name|errorcount
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
name|gcc_assert
argument_list|(
operator|!
name|node
operator|->
name|aux
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|order
operator|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|order
argument_list|)
operator|*
name|cgraph_n_nodes
argument_list|)
expr_stmt|;
name|nnodes
operator|=
name|cgraph_postorder
argument_list|(
name|order
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|nnodes
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|node
operator|=
name|order
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|analyzed
operator|&&
operator|(
name|node
operator|->
name|needed
operator|||
name|node
operator|->
name|reachable
operator|)
condition|)
name|node
operator|->
name|local
operator|.
name|self_insns
operator|=
name|node
operator|->
name|global
operator|.
name|insns
operator|=
name|estimate_num_insns
argument_list|(
name|node
operator|->
name|decl
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|nnodes
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|node
operator|=
name|order
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|analyzed
operator|&&
name|node
operator|->
name|local
operator|.
name|inlinable
operator|&&
operator|(
name|node
operator|->
name|needed
operator|||
name|node
operator|->
name|reachable
operator|)
operator|&&
name|node
operator|->
name|callers
condition|)
block|{
if|if
condition|(
name|cgraph_decide_inlining_incrementally
argument_list|(
name|node
argument_list|,
name|true
argument_list|)
condition|)
name|ggc_collect
argument_list|()
expr_stmt|;
block|}
block|}
name|cgraph_remove_unreachable_nodes
argument_list|(
name|true
argument_list|,
name|dump_file
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
name|gcc_assert
argument_list|(
operator|!
name|node
operator|->
name|global
operator|.
name|inlined_to
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ggc_free
argument_list|(
name|order
argument_list|)
expr_stmt|;
name|order
operator|=
name|NULL
expr_stmt|;
name|nnodes
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* When inlining shall be performed.  */
end_comment

begin_function
specifier|static
name|bool
name|cgraph_gate_early_inlining
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|flag_inline_trees
operator|&&
name|flag_early_inlining
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_early_ipa_inline
init|=
block|{
literal|"einline"
block|,
comment|/* name */
name|cgraph_gate_early_inlining
block|,
comment|/* gate */
name|cgraph_early_inlining
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
name|TV_INTEGRATION
block|,
comment|/* tv_id */
literal|0
block|,
comment|/* properties_required */
name|PROP_cfg
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_dump_cgraph
operator||
name|TODO_dump_func
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"gt-ipa-inline.h"
end_include

end_unit

