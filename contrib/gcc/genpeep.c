begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Generate code from machine description to perform peephole optimizations.    Copyright (C) 1987, 89, 92, 97, 98, 1999 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"hconfig.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|obstack
modifier|*
name|rtl_obstack
init|=
operator|&
name|obstack
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_comment
comment|/* Define this so we can link with print-rtl.o to get debug_rtx function.  */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|insn_name_ptr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* While tree-walking an instruction pattern, we keep a chain    of these `struct link's to record how to get down to the    current position.  In each one, POS is the operand number,    and if the operand is a vector VEC is the element number.    VEC is -1 if the operand is not a vector.  */
end_comment

begin_struct
struct|struct
name|link
block|{
name|struct
name|link
modifier|*
name|next
decl_stmt|;
name|int
name|pos
decl_stmt|;
name|int
name|vecelt
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|void
name|fatal
name|PVPROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
name|ATTRIBUTE_PRINTF_1
name|ATTRIBUTE_NORETURN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|fancy_abort
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
name|ATTRIBUTE_NORETURN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|max_opno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of operands used in current peephole definition.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|n_operands
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Peephole optimizations get insn codes just like insn patterns.    Count them so we know the code of the define_peephole we are handling.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|insn_code_number
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_peephole
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|match_rtx
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
expr|struct
name|link
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_path
name|PROTO
argument_list|(
operator|(
expr|struct
name|link
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_code
name|PROTO
argument_list|(
operator|(
name|RTX_CODE
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
specifier|static
name|void
name|gen_peephole
parameter_list|(
name|peep
parameter_list|)
name|rtx
name|peep
decl_stmt|;
block|{
name|int
name|ninsns
init|=
name|XVECLEN
argument_list|(
name|peep
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|n_operands
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"  insn = ins1;\n"
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|printf ("  want_jump = 0;\n");
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ninsns
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"  do { insn = NEXT_INSN (insn);\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"       if (insn == 0) goto L%d; }\n"
argument_list|,
name|insn_code_number
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  while (GET_CODE (insn) == NOTE\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t || (GET_CODE (insn) == INSN\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t&& (GET_CODE (PATTERN (insn)) == USE\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t\t || GET_CODE (PATTERN (insn)) == CLOBBER)));\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  if (GET_CODE (insn) == CODE_LABEL\n\       || GET_CODE (insn) == BARRIER)\n    goto L%d;\n"
argument_list|,
name|insn_code_number
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|printf ("  if (GET_CODE (insn) == JUMP_INSN)\n");       printf ("    want_jump = JUMP_LABEL (insn);\n");
endif|#
directive|endif
name|printf
argument_list|(
literal|"  pat = PATTERN (insn);\n"
argument_list|)
expr_stmt|;
comment|/* Walk the insn's pattern, remembering at all times the path 	 down to the walking point.  */
name|match_rtx
argument_list|(
name|XVECEXP
argument_list|(
name|peep
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|NULL_PTR
argument_list|,
name|insn_code_number
argument_list|)
expr_stmt|;
block|}
comment|/* We get this far if the pattern matches.      Now test the extra condition.  */
if|if
condition|(
name|XSTR
argument_list|(
name|peep
argument_list|,
literal|1
argument_list|)
operator|&&
name|XSTR
argument_list|(
name|peep
argument_list|,
literal|1
argument_list|)
index|[
literal|0
index|]
condition|)
name|printf
argument_list|(
literal|"  if (! (%s)) goto L%d;\n"
argument_list|,
name|XSTR
argument_list|(
name|peep
argument_list|,
literal|1
argument_list|)
argument_list|,
name|insn_code_number
argument_list|)
expr_stmt|;
comment|/* If that matches, construct new pattern and put it in the first insn.      This new pattern will never be matched.      It exists only so that insn-extract can get the operands back.      So use a simple regular form: a PARALLEL containing a vector      of all the operands.  */
name|printf
argument_list|(
literal|"  PATTERN (ins1) = gen_rtx_PARALLEL (VOIDmode, gen_rtvec_v (%d, operands));\n"
argument_list|,
name|n_operands
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|printf ("  if (want_jump&& GET_CODE (ins1) != JUMP_INSN)\n");   printf ("    {\n");   printf ("      rtx insn2 = emit_jump_insn_before (PATTERN (ins1), ins1);\n");   printf ("      delete_insn (ins1);\n");   printf ("      ins1 = ins2;\n");   printf ("    }\n");
endif|#
directive|endif
comment|/* Record this define_peephole's insn code in the insn,      as if it had been recognized to match this.  */
name|printf
argument_list|(
literal|"  INSN_CODE (ins1) = %d;\n"
argument_list|,
name|insn_code_number
argument_list|)
expr_stmt|;
comment|/* Delete the remaining insns.  */
if|if
condition|(
name|ninsns
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"  delete_for_peephole (NEXT_INSN (ins1), insn);\n"
argument_list|)
expr_stmt|;
comment|/* See reload1.c for insertion of NOTE which guarantees that this      cannot be zero.  */
name|printf
argument_list|(
literal|"  return NEXT_INSN (insn);\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" L%d:\n\n"
argument_list|,
name|insn_code_number
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|match_rtx
parameter_list|(
name|x
parameter_list|,
name|path
parameter_list|,
name|fail_label
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|struct
name|link
modifier|*
name|path
decl_stmt|;
name|int
name|fail_label
decl_stmt|;
block|{
specifier|register
name|RTX_CODE
name|code
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
name|struct
name|link
name|link
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|MATCH_OPERAND
case|:
if|if
condition|(
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|>
name|max_opno
condition|)
name|max_opno
operator|=
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|>=
name|n_operands
condition|)
name|n_operands
operator|=
literal|1
operator|+
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  x = "
argument_list|)
expr_stmt|;
name|print_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|";\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  operands[%d] = x;\n"
argument_list|,
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|XSTR
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|&&
name|XSTR
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
index|[
literal|0
index|]
condition|)
name|printf
argument_list|(
literal|"  if (! %s (x, %smode)) goto L%d;\n"
argument_list|,
name|XSTR
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|fail_label
argument_list|)
expr_stmt|;
return|return;
case|case
name|MATCH_DUP
case|:
case|case
name|MATCH_PAR_DUP
case|:
name|printf
argument_list|(
literal|"  x = "
argument_list|)
expr_stmt|;
name|print_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|";\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  if (!rtx_equal_p (operands[%d], x)) goto L%d;\n"
argument_list|,
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|fail_label
argument_list|)
expr_stmt|;
return|return;
case|case
name|MATCH_OP_DUP
case|:
name|printf
argument_list|(
literal|"  x = "
argument_list|)
expr_stmt|;
name|print_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|";\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  if (GET_CODE (operands[%d]) != GET_CODE (x)\n"
argument_list|,
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"      || GET_MODE (operands[%d]) != GET_MODE (x)) goto L%d;\n"
argument_list|,
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|fail_label
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  operands[%d] = x;\n"
argument_list|,
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|link
operator|.
name|next
operator|=
name|path
expr_stmt|;
name|link
operator|.
name|vecelt
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|link
operator|.
name|pos
operator|=
name|i
expr_stmt|;
name|match_rtx
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
argument_list|,
operator|&
name|link
argument_list|,
name|fail_label
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|MATCH_OPERATOR
case|:
if|if
condition|(
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|>
name|max_opno
condition|)
name|max_opno
operator|=
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|>=
name|n_operands
condition|)
name|n_operands
operator|=
literal|1
operator|+
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  x = "
argument_list|)
expr_stmt|;
name|print_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|";\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  operands[%d] = x;\n"
argument_list|,
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|XSTR
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|&&
name|XSTR
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
index|[
literal|0
index|]
condition|)
name|printf
argument_list|(
literal|"  if (! %s (x, %smode)) goto L%d;\n"
argument_list|,
name|XSTR
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|fail_label
argument_list|)
expr_stmt|;
name|link
operator|.
name|next
operator|=
name|path
expr_stmt|;
name|link
operator|.
name|vecelt
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|link
operator|.
name|pos
operator|=
name|i
expr_stmt|;
name|match_rtx
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|,
name|i
argument_list|)
argument_list|,
operator|&
name|link
argument_list|,
name|fail_label
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|MATCH_PARALLEL
case|:
if|if
condition|(
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|>
name|max_opno
condition|)
name|max_opno
operator|=
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|>=
name|n_operands
condition|)
name|n_operands
operator|=
literal|1
operator|+
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  x = "
argument_list|)
expr_stmt|;
name|print_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|";\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  if (GET_CODE (x) != PARALLEL) goto L%d;\n"
argument_list|,
name|fail_label
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  operands[%d] = x;\n"
argument_list|,
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|XSTR
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|&&
name|XSTR
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
index|[
literal|0
index|]
condition|)
name|printf
argument_list|(
literal|"  if (! %s (x, %smode)) goto L%d;\n"
argument_list|,
name|XSTR
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|fail_label
argument_list|)
expr_stmt|;
name|link
operator|.
name|next
operator|=
name|path
expr_stmt|;
name|link
operator|.
name|pos
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|link
operator|.
name|vecelt
operator|=
name|i
expr_stmt|;
name|match_rtx
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|,
name|i
argument_list|)
argument_list|,
operator|&
name|link
argument_list|,
name|fail_label
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|ADDRESS
case|:
name|match_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|path
argument_list|,
name|fail_label
argument_list|)
expr_stmt|;
return|return;
default|default:
break|break;
block|}
name|printf
argument_list|(
literal|"  x = "
argument_list|)
expr_stmt|;
name|print_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|";\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  if (GET_CODE (x) != "
argument_list|)
expr_stmt|;
name|print_code
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|") goto L%d;\n"
argument_list|,
name|fail_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|VOIDmode
condition|)
block|{
name|printf
argument_list|(
literal|"  if (GET_MODE (x) != %smode) goto L%d;\n"
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|fail_label
argument_list|)
expr_stmt|;
block|}
name|link
operator|.
name|next
operator|=
name|path
expr_stmt|;
name|link
operator|.
name|vecelt
operator|=
operator|-
literal|1
expr_stmt|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|len
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|link
operator|.
name|pos
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|||
name|fmt
index|[
name|i
index|]
operator|==
literal|'u'
condition|)
name|match_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
operator|&
name|link
argument_list|,
name|fail_label
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
name|printf
argument_list|(
literal|"  if (XVECLEN (x, %d) != %d) goto L%d;\n"
argument_list|,
name|i
argument_list|,
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|fail_label
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|link
operator|.
name|vecelt
operator|=
name|j
expr_stmt|;
name|match_rtx
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
operator|&
name|link
argument_list|,
name|fail_label
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'i'
condition|)
block|{
comment|/* Make sure that at run time `x' is the RTX we want to test.  */
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"  x = "
argument_list|)
expr_stmt|;
name|print_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|";\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"  if (XINT (x, %d) != %d) goto L%d;\n"
argument_list|,
name|i
argument_list|,
name|XINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|fail_label
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'w'
condition|)
block|{
comment|/* Make sure that at run time `x' is the RTX we want to test.  */
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"  x = "
argument_list|)
expr_stmt|;
name|print_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|";\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"  if (XWINT (x, %d) != "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|XWINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|") goto L%d;\n"
argument_list|,
name|fail_label
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'s'
condition|)
block|{
comment|/* Make sure that at run time `x' is the RTX we want to test.  */
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"  x = "
argument_list|)
expr_stmt|;
name|print_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|";\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"  if (strcmp (XSTR (x, %d), \"%s\")) goto L%d;\n"
argument_list|,
name|i
argument_list|,
name|XSTR
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|fail_label
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Given a PATH, representing a path down the instruction's    pattern from the root to a certain point, output code to    evaluate to the rtx at that point.  */
end_comment

begin_function
specifier|static
name|void
name|print_path
parameter_list|(
name|path
parameter_list|)
name|struct
name|link
modifier|*
name|path
decl_stmt|;
block|{
if|if
condition|(
name|path
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"pat"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|path
operator|->
name|vecelt
operator|>=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"XVECEXP ("
argument_list|)
expr_stmt|;
name|print_path
argument_list|(
name|path
operator|->
name|next
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", %d, %d)"
argument_list|,
name|path
operator|->
name|pos
argument_list|,
name|path
operator|->
name|vecelt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"XEXP ("
argument_list|)
expr_stmt|;
name|print_path
argument_list|(
name|path
operator|->
name|next
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", %d)"
argument_list|,
name|path
operator|->
name|pos
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|print_code
parameter_list|(
name|code
parameter_list|)
name|RTX_CODE
name|code
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p1
decl_stmt|;
for|for
control|(
name|p1
operator|=
name|GET_RTX_NAME
argument_list|(
name|code
argument_list|)
init|;
operator|*
name|p1
condition|;
name|p1
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p1
operator|>=
literal|'a'
operator|&&
operator|*
name|p1
operator|<=
literal|'z'
condition|)
name|putchar
argument_list|(
operator|*
name|p1
operator|+
literal|'A'
operator|-
literal|'a'
argument_list|)
expr_stmt|;
else|else
name|putchar
argument_list|(
operator|*
name|p1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|PTR
name|xmalloc
parameter_list|(
name|size
parameter_list|)
name|size_t
name|size
decl_stmt|;
block|{
specifier|register
name|PTR
name|val
init|=
operator|(
name|PTR
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
name|PTR
name|xrealloc
parameter_list|(
name|old
parameter_list|,
name|size
parameter_list|)
name|PTR
name|old
decl_stmt|;
name|size_t
name|size
decl_stmt|;
block|{
specifier|register
name|PTR
name|ptr
decl_stmt|;
if|if
condition|(
name|old
condition|)
name|ptr
operator|=
operator|(
name|PTR
operator|)
name|realloc
argument_list|(
name|old
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
name|ptr
operator|=
operator|(
name|PTR
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
name|fatal
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_decl_stmt
name|void
name|fatal
name|VPROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|format
operator|,
operator|...
operator|)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
specifier|const
name|char
modifier|*
name|format
decl_stmt|;
endif|#
directive|endif
name|va_list
name|ap
decl_stmt|;
name|VA_START
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|format
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"genpeep: "
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* More 'friendly' abort that prints the line and file.    config.h can #define abort fancy_abort if you like that sort of thing.  */
end_comment

begin_function
name|void
name|fancy_abort
parameter_list|()
block|{
name|fatal
argument_list|(
literal|"Internal gcc abort."
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|rtx
name|desc
decl_stmt|;
name|FILE
modifier|*
name|infile
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|max_opno
operator|=
operator|-
literal|1
expr_stmt|;
name|obstack_init
argument_list|(
name|rtl_obstack
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|<=
literal|1
condition|)
name|fatal
argument_list|(
literal|"No input file name."
argument_list|)
expr_stmt|;
name|infile
operator|=
name|fopen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|infile
operator|==
literal|0
condition|)
block|{
name|perror
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
name|init_rtl
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"/* Generated automatically by the program `genpeep'\n\ from the machine description file `md'.  */\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"config.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"system.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"insn-config.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"rtl.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"regs.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"output.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"real.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"recog.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"except.h\"\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"extern rtx peep_operand[];\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#define operands peep_operand\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"rtx\npeephole (ins1)\n     rtx ins1;\n{\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  rtx insn ATTRIBUTE_UNUSED, x ATTRIBUTE_UNUSED, pat ATTRIBUTE_UNUSED;\n\n"
argument_list|)
expr_stmt|;
comment|/* Early out: no peepholes for insns followed by barriers.  */
name|printf
argument_list|(
literal|"  if (NEXT_INSN (ins1)\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"&& GET_CODE (NEXT_INSN (ins1)) == BARRIER)\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    return 0;\n\n"
argument_list|)
expr_stmt|;
comment|/* Read the machine description.  */
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
name|read_skip_spaces
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
name|ungetc
argument_list|(
name|c
argument_list|,
name|infile
argument_list|)
expr_stmt|;
name|desc
operator|=
name|read_rtx
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_PEEPHOLE
condition|)
block|{
name|gen_peephole
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|insn_code_number
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_INSN
operator|||
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_EXPAND
operator|||
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_SPLIT
condition|)
block|{
name|insn_code_number
operator|++
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"  return 0;\n}\n\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_opno
operator|==
operator|-
literal|1
condition|)
name|max_opno
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"rtx peep_operand[%d];\n"
argument_list|,
name|max_opno
operator|+
literal|1
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|ferror
argument_list|(
name|stdout
argument_list|)
operator|!=
literal|0
condition|?
name|FATAL_EXIT_CODE
else|:
name|SUCCESS_EXIT_CODE
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
literal|0
return|;
block|}
end_function

end_unit

