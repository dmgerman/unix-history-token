begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Natural loop analysis code for GNU compiler.    Copyright (C) 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"cfgloop.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_comment
comment|/* Checks whether BB is executed exactly once in each LOOP iteration.  */
end_comment

begin_function
name|bool
name|just_once_each_iteration_p
parameter_list|(
specifier|const
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|basic_block
name|bb
parameter_list|)
block|{
comment|/* It must be executed at least once each iteration.  */
if|if
condition|(
operator|!
name|dominated_by_p
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|loop
operator|->
name|latch
argument_list|,
name|bb
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* And just once.  */
if|if
condition|(
name|bb
operator|->
name|loop_father
operator|!=
name|loop
condition|)
return|return
name|false
return|;
comment|/* But this was not enough.  We might have some irreducible loop here.  */
if|if
condition|(
name|bb
operator|->
name|flags
operator|&
name|BB_IRREDUCIBLE_LOOP
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Structure representing edge of a graph.  */
end_comment

begin_struct
struct|struct
name|edge
block|{
name|int
name|src
decl_stmt|,
name|dest
decl_stmt|;
comment|/* Source and destination.  */
name|struct
name|edge
modifier|*
name|pred_next
decl_stmt|,
modifier|*
name|succ_next
decl_stmt|;
comment|/* Next edge in predecessor and successor lists.  */
name|void
modifier|*
name|data
decl_stmt|;
comment|/* Data attached to the edge.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Structure representing vertex of a graph.  */
end_comment

begin_struct
struct|struct
name|vertex
block|{
name|struct
name|edge
modifier|*
name|pred
decl_stmt|,
modifier|*
name|succ
decl_stmt|;
comment|/* Lists of predecessors and successors.  */
name|int
name|component
decl_stmt|;
comment|/* Number of dfs restarts before reaching the 			   vertex.  */
name|int
name|post
decl_stmt|;
comment|/* Postorder number.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Structure representing a graph.  */
end_comment

begin_struct
struct|struct
name|graph
block|{
name|int
name|n_vertices
decl_stmt|;
comment|/* Number of vertices.  */
name|struct
name|vertex
modifier|*
name|vertices
decl_stmt|;
comment|/* The vertices.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Dumps graph G into F.  */
end_comment

begin_function_decl
specifier|extern
name|void
name|dump_graph
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|struct
name|graph
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|dump_graph
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|struct
name|graph
modifier|*
name|g
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|edge
modifier|*
name|e
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|g
operator|->
name|n_vertices
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|g
operator|->
name|vertices
index|[
name|i
index|]
operator|.
name|pred
operator|&&
operator|!
name|g
operator|->
name|vertices
index|[
name|i
index|]
operator|.
name|succ
condition|)
continue|continue;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%d (%d)\t<-"
argument_list|,
name|i
argument_list|,
name|g
operator|->
name|vertices
index|[
name|i
index|]
operator|.
name|component
argument_list|)
expr_stmt|;
for|for
control|(
name|e
operator|=
name|g
operator|->
name|vertices
index|[
name|i
index|]
operator|.
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" %d"
argument_list|,
name|e
operator|->
name|src
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t->"
argument_list|)
expr_stmt|;
for|for
control|(
name|e
operator|=
name|g
operator|->
name|vertices
index|[
name|i
index|]
operator|.
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" %d"
argument_list|,
name|e
operator|->
name|dest
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Creates a new graph with N_VERTICES vertices.  */
end_comment

begin_function
specifier|static
name|struct
name|graph
modifier|*
name|new_graph
parameter_list|(
name|int
name|n_vertices
parameter_list|)
block|{
name|struct
name|graph
modifier|*
name|g
init|=
name|XNEW
argument_list|(
expr|struct
name|graph
argument_list|)
decl_stmt|;
name|g
operator|->
name|n_vertices
operator|=
name|n_vertices
expr_stmt|;
name|g
operator|->
name|vertices
operator|=
name|XCNEWVEC
argument_list|(
expr|struct
name|vertex
argument_list|,
name|n_vertices
argument_list|)
expr_stmt|;
return|return
name|g
return|;
block|}
end_function

begin_comment
comment|/* Adds an edge from F to T to graph G, with DATA attached.  */
end_comment

begin_function
specifier|static
name|void
name|add_edge
parameter_list|(
name|struct
name|graph
modifier|*
name|g
parameter_list|,
name|int
name|f
parameter_list|,
name|int
name|t
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|edge
modifier|*
name|e
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|edge
argument_list|)
argument_list|)
decl_stmt|;
name|e
operator|->
name|src
operator|=
name|f
expr_stmt|;
name|e
operator|->
name|dest
operator|=
name|t
expr_stmt|;
name|e
operator|->
name|data
operator|=
name|data
expr_stmt|;
name|e
operator|->
name|pred_next
operator|=
name|g
operator|->
name|vertices
index|[
name|t
index|]
operator|.
name|pred
expr_stmt|;
name|g
operator|->
name|vertices
index|[
name|t
index|]
operator|.
name|pred
operator|=
name|e
expr_stmt|;
name|e
operator|->
name|succ_next
operator|=
name|g
operator|->
name|vertices
index|[
name|f
index|]
operator|.
name|succ
expr_stmt|;
name|g
operator|->
name|vertices
index|[
name|f
index|]
operator|.
name|succ
operator|=
name|e
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Runs dfs search over vertices of G, from NQ vertices in queue QS.    The vertices in postorder are stored into QT.  If FORWARD is false,    backward dfs is run.  */
end_comment

begin_function
specifier|static
name|void
name|dfs
parameter_list|(
name|struct
name|graph
modifier|*
name|g
parameter_list|,
name|int
modifier|*
name|qs
parameter_list|,
name|int
name|nq
parameter_list|,
name|int
modifier|*
name|qt
parameter_list|,
name|bool
name|forward
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|tick
init|=
literal|0
decl_stmt|,
name|v
decl_stmt|,
name|comp
init|=
literal|0
decl_stmt|,
name|top
decl_stmt|;
name|struct
name|edge
modifier|*
name|e
decl_stmt|;
name|struct
name|edge
modifier|*
modifier|*
name|stack
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|edge
operator|*
argument_list|)
operator|*
name|g
operator|->
name|n_vertices
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|g
operator|->
name|n_vertices
condition|;
name|i
operator|++
control|)
block|{
name|g
operator|->
name|vertices
index|[
name|i
index|]
operator|.
name|component
operator|=
operator|-
literal|1
expr_stmt|;
name|g
operator|->
name|vertices
index|[
name|i
index|]
operator|.
name|post
operator|=
operator|-
literal|1
expr_stmt|;
block|}
define|#
directive|define
name|FST_EDGE
parameter_list|(
name|V
parameter_list|)
value|(forward ? g->vertices[(V)].succ : g->vertices[(V)].pred)
define|#
directive|define
name|NEXT_EDGE
parameter_list|(
name|E
parameter_list|)
value|(forward ? (E)->succ_next : (E)->pred_next)
define|#
directive|define
name|EDGE_SRC
parameter_list|(
name|E
parameter_list|)
value|(forward ? (E)->src : (E)->dest)
define|#
directive|define
name|EDGE_DEST
parameter_list|(
name|E
parameter_list|)
value|(forward ? (E)->dest : (E)->src)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nq
condition|;
name|i
operator|++
control|)
block|{
name|v
operator|=
name|qs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|vertices
index|[
name|v
index|]
operator|.
name|post
operator|!=
operator|-
literal|1
condition|)
continue|continue;
name|g
operator|->
name|vertices
index|[
name|v
index|]
operator|.
name|component
operator|=
name|comp
operator|++
expr_stmt|;
name|e
operator|=
name|FST_EDGE
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|top
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
while|while
condition|(
name|e
operator|&&
name|g
operator|->
name|vertices
index|[
name|EDGE_DEST
argument_list|(
name|e
argument_list|)
index|]
operator|.
name|component
operator|!=
operator|-
literal|1
condition|)
name|e
operator|=
name|NEXT_EDGE
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|e
condition|)
block|{
if|if
condition|(
name|qt
condition|)
name|qt
index|[
name|tick
index|]
operator|=
name|v
expr_stmt|;
name|g
operator|->
name|vertices
index|[
name|v
index|]
operator|.
name|post
operator|=
name|tick
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|top
condition|)
break|break;
name|e
operator|=
name|stack
index|[
operator|--
name|top
index|]
expr_stmt|;
name|v
operator|=
name|EDGE_SRC
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|e
operator|=
name|NEXT_EDGE
argument_list|(
name|e
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|stack
index|[
name|top
operator|++
index|]
operator|=
name|e
expr_stmt|;
name|v
operator|=
name|EDGE_DEST
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|e
operator|=
name|FST_EDGE
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|g
operator|->
name|vertices
index|[
name|v
index|]
operator|.
name|component
operator|=
name|comp
operator|-
literal|1
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|stack
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Marks the edge E in graph G irreducible if it connects two vertices in the    same scc.  */
end_comment

begin_function
specifier|static
name|void
name|check_irred
parameter_list|(
name|struct
name|graph
modifier|*
name|g
parameter_list|,
name|struct
name|edge
modifier|*
name|e
parameter_list|)
block|{
name|edge
name|real
init|=
name|e
operator|->
name|data
decl_stmt|;
comment|/* All edges should lead from a component with higher number to the      one with lower one.  */
name|gcc_assert
argument_list|(
name|g
operator|->
name|vertices
index|[
name|e
operator|->
name|src
index|]
operator|.
name|component
operator|>=
name|g
operator|->
name|vertices
index|[
name|e
operator|->
name|dest
index|]
operator|.
name|component
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|vertices
index|[
name|e
operator|->
name|src
index|]
operator|.
name|component
operator|!=
name|g
operator|->
name|vertices
index|[
name|e
operator|->
name|dest
index|]
operator|.
name|component
condition|)
return|return;
name|real
operator|->
name|flags
operator||=
name|EDGE_IRREDUCIBLE_LOOP
expr_stmt|;
if|if
condition|(
name|flow_bb_inside_loop_p
argument_list|(
name|real
operator|->
name|src
operator|->
name|loop_father
argument_list|,
name|real
operator|->
name|dest
argument_list|)
condition|)
name|real
operator|->
name|src
operator|->
name|flags
operator||=
name|BB_IRREDUCIBLE_LOOP
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Runs CALLBACK for all edges in G.  */
end_comment

begin_function
specifier|static
name|void
name|for_each_edge
parameter_list|(
name|struct
name|graph
modifier|*
name|g
parameter_list|,
name|void
function_decl|(
name|callback
function_decl|)
parameter_list|(
name|struct
name|graph
modifier|*
parameter_list|,
name|struct
name|edge
modifier|*
parameter_list|)
parameter_list|)
block|{
name|struct
name|edge
modifier|*
name|e
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|g
operator|->
name|n_vertices
condition|;
name|i
operator|++
control|)
for|for
control|(
name|e
operator|=
name|g
operator|->
name|vertices
index|[
name|i
index|]
operator|.
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
name|callback
argument_list|(
name|g
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Releases the memory occupied by G.  */
end_comment

begin_function
specifier|static
name|void
name|free_graph
parameter_list|(
name|struct
name|graph
modifier|*
name|g
parameter_list|)
block|{
name|struct
name|edge
modifier|*
name|e
decl_stmt|,
modifier|*
name|n
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|g
operator|->
name|n_vertices
condition|;
name|i
operator|++
control|)
for|for
control|(
name|e
operator|=
name|g
operator|->
name|vertices
index|[
name|i
index|]
operator|.
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|n
control|)
block|{
name|n
operator|=
name|e
operator|->
name|succ_next
expr_stmt|;
name|free
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|g
operator|->
name|vertices
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|g
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Marks blocks and edges that are part of non-recognized loops; i.e. we    throw away all latch edges and mark blocks inside any remaining cycle.    Everything is a bit complicated due to fact we do not want to do this    for parts of cycles that only "pass" through some loop -- i.e. for    each cycle, we want to mark blocks that belong directly to innermost    loop containing the whole cycle.     LOOPS is the loop tree.  */
end_comment

begin_define
define|#
directive|define
name|LOOP_REPR
parameter_list|(
name|LOOP
parameter_list|)
value|((LOOP)->num + last_basic_block)
end_define

begin_define
define|#
directive|define
name|BB_REPR
parameter_list|(
name|BB
parameter_list|)
value|((BB)->index + 1)
end_define

begin_function
name|void
name|mark_irreducible_loops
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|)
block|{
name|basic_block
name|act
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|int
name|i
decl_stmt|,
name|src
decl_stmt|,
name|dest
decl_stmt|;
name|struct
name|graph
modifier|*
name|g
decl_stmt|;
name|int
modifier|*
name|queue1
init|=
name|XNEWVEC
argument_list|(
name|int
argument_list|,
name|last_basic_block
operator|+
name|loops
operator|->
name|num
argument_list|)
decl_stmt|;
name|int
modifier|*
name|queue2
init|=
name|XNEWVEC
argument_list|(
name|int
argument_list|,
name|last_basic_block
operator|+
name|loops
operator|->
name|num
argument_list|)
decl_stmt|;
name|int
name|nq
decl_stmt|,
name|depth
decl_stmt|;
name|struct
name|loop
modifier|*
name|cloop
decl_stmt|;
comment|/* Reset the flags.  */
name|FOR_BB_BETWEEN
argument_list|(
argument|act
argument_list|,
argument|ENTRY_BLOCK_PTR
argument_list|,
argument|EXIT_BLOCK_PTR
argument_list|,
argument|next_bb
argument_list|)
block|{
name|act
operator|->
name|flags
operator|&=
operator|~
name|BB_IRREDUCIBLE_LOOP
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|act->succs
argument_list|)
name|e
operator|->
name|flags
operator|&=
operator|~
name|EDGE_IRREDUCIBLE_LOOP
expr_stmt|;
block|}
comment|/* Create the edge lists.  */
name|g
operator|=
name|new_graph
argument_list|(
name|last_basic_block
operator|+
name|loops
operator|->
name|num
argument_list|)
expr_stmt|;
name|FOR_BB_BETWEEN
argument_list|(
argument|act
argument_list|,
argument|ENTRY_BLOCK_PTR
argument_list|,
argument|EXIT_BLOCK_PTR
argument_list|,
argument|next_bb
argument_list|)
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|act->succs
argument_list|)
block|{
comment|/* Ignore edges to exit.  */
if|if
condition|(
name|e
operator|->
name|dest
operator|==
name|EXIT_BLOCK_PTR
condition|)
continue|continue;
comment|/* And latch edges.  */
if|if
condition|(
name|e
operator|->
name|dest
operator|->
name|loop_father
operator|->
name|header
operator|==
name|e
operator|->
name|dest
operator|&&
name|e
operator|->
name|dest
operator|->
name|loop_father
operator|->
name|latch
operator|==
name|act
condition|)
continue|continue;
comment|/* Edges inside a single loop should be left where they are.  Edges 	   to subloop headers should lead to representative of the subloop, 	   but from the same place.  	   Edges exiting loops should lead from representative 	   of the son of nearest common ancestor of the loops in that 	   act lays.  */
name|src
operator|=
name|BB_REPR
argument_list|(
name|act
argument_list|)
expr_stmt|;
name|dest
operator|=
name|BB_REPR
argument_list|(
name|e
operator|->
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|dest
operator|->
name|loop_father
operator|->
name|header
operator|==
name|e
operator|->
name|dest
condition|)
name|dest
operator|=
name|LOOP_REPR
argument_list|(
name|e
operator|->
name|dest
operator|->
name|loop_father
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flow_bb_inside_loop_p
argument_list|(
name|act
operator|->
name|loop_father
argument_list|,
name|e
operator|->
name|dest
argument_list|)
condition|)
block|{
name|depth
operator|=
name|find_common_loop
argument_list|(
name|act
operator|->
name|loop_father
argument_list|,
name|e
operator|->
name|dest
operator|->
name|loop_father
argument_list|)
operator|->
name|depth
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|depth
operator|==
name|act
operator|->
name|loop_father
operator|->
name|depth
condition|)
name|cloop
operator|=
name|act
operator|->
name|loop_father
expr_stmt|;
else|else
name|cloop
operator|=
name|act
operator|->
name|loop_father
operator|->
name|pred
index|[
name|depth
index|]
expr_stmt|;
name|src
operator|=
name|LOOP_REPR
argument_list|(
name|cloop
argument_list|)
expr_stmt|;
block|}
name|add_edge
argument_list|(
name|g
argument_list|,
name|src
argument_list|,
name|dest
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
comment|/* Find the strongly connected components.  Use the algorithm of Tarjan --      first determine the postorder dfs numbering in reversed graph, then      run the dfs on the original graph in the order given by decreasing      numbers assigned by the previous pass.  */
name|nq
operator|=
literal|0
expr_stmt|;
name|FOR_BB_BETWEEN
argument_list|(
argument|act
argument_list|,
argument|ENTRY_BLOCK_PTR
argument_list|,
argument|EXIT_BLOCK_PTR
argument_list|,
argument|next_bb
argument_list|)
block|{
name|queue1
index|[
name|nq
operator|++
index|]
operator|=
name|BB_REPR
argument_list|(
name|act
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|loops
operator|->
name|num
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|loops
operator|->
name|parray
index|[
name|i
index|]
condition|)
name|queue1
index|[
name|nq
operator|++
index|]
operator|=
name|LOOP_REPR
argument_list|(
name|loops
operator|->
name|parray
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|dfs
argument_list|(
name|g
argument_list|,
name|queue1
argument_list|,
name|nq
argument_list|,
name|queue2
argument_list|,
name|false
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nq
condition|;
name|i
operator|++
control|)
name|queue1
index|[
name|i
index|]
operator|=
name|queue2
index|[
name|nq
operator|-
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|dfs
argument_list|(
name|g
argument_list|,
name|queue1
argument_list|,
name|nq
argument_list|,
name|NULL
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* Mark the irreducible loops.  */
name|for_each_edge
argument_list|(
name|g
argument_list|,
name|check_irred
argument_list|)
expr_stmt|;
name|free_graph
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|queue1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|queue2
argument_list|)
expr_stmt|;
name|loops
operator|->
name|state
operator||=
name|LOOPS_HAVE_MARKED_IRREDUCIBLE_REGIONS
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Counts number of insns inside LOOP.  */
end_comment

begin_function
name|int
name|num_loop_insns
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|basic_block
modifier|*
name|bbs
decl_stmt|,
name|bb
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|ninsns
init|=
literal|0
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|bbs
operator|=
name|get_loop_body
argument_list|(
name|loop
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loop
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
block|{
name|bb
operator|=
name|bbs
index|[
name|i
index|]
expr_stmt|;
name|ninsns
operator|++
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
init|;
name|insn
operator|!=
name|BB_END
argument_list|(
name|bb
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|ninsns
operator|++
expr_stmt|;
block|}
name|free
argument_list|(
name|bbs
argument_list|)
expr_stmt|;
return|return
name|ninsns
return|;
block|}
end_function

begin_comment
comment|/* Counts number of insns executed on average per iteration LOOP.  */
end_comment

begin_function
name|int
name|average_num_loop_insns
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|basic_block
modifier|*
name|bbs
decl_stmt|,
name|bb
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|binsns
decl_stmt|,
name|ninsns
decl_stmt|,
name|ratio
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|ninsns
operator|=
literal|0
expr_stmt|;
name|bbs
operator|=
name|get_loop_body
argument_list|(
name|loop
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loop
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
block|{
name|bb
operator|=
name|bbs
index|[
name|i
index|]
expr_stmt|;
name|binsns
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
init|;
name|insn
operator|!=
name|BB_END
argument_list|(
name|bb
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|binsns
operator|++
expr_stmt|;
name|ratio
operator|=
name|loop
operator|->
name|header
operator|->
name|frequency
operator|==
literal|0
condition|?
name|BB_FREQ_MAX
else|:
operator|(
name|bb
operator|->
name|frequency
operator|*
name|BB_FREQ_MAX
operator|)
operator|/
name|loop
operator|->
name|header
operator|->
name|frequency
expr_stmt|;
name|ninsns
operator|+=
name|binsns
operator|*
name|ratio
expr_stmt|;
block|}
name|free
argument_list|(
name|bbs
argument_list|)
expr_stmt|;
name|ninsns
operator|/=
name|BB_FREQ_MAX
expr_stmt|;
if|if
condition|(
operator|!
name|ninsns
condition|)
name|ninsns
operator|=
literal|1
expr_stmt|;
comment|/* To avoid division by zero.  */
return|return
name|ninsns
return|;
block|}
end_function

begin_comment
comment|/* Returns expected number of LOOP iterations.    Compute upper bound on number of iterations in case they do not fit integer    to help loop peeling heuristics.  Use exact counts if at all possible.  */
end_comment

begin_function
name|unsigned
name|expected_loop_iterations
parameter_list|(
specifier|const
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
if|if
condition|(
name|loop
operator|->
name|latch
operator|->
name|count
operator|||
name|loop
operator|->
name|header
operator|->
name|count
condition|)
block|{
name|gcov_type
name|count_in
decl_stmt|,
name|count_latch
decl_stmt|,
name|expected
decl_stmt|;
name|count_in
operator|=
literal|0
expr_stmt|;
name|count_latch
operator|=
literal|0
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|loop->header->preds
argument_list|)
if|if
condition|(
name|e
operator|->
name|src
operator|==
name|loop
operator|->
name|latch
condition|)
name|count_latch
operator|=
name|e
operator|->
name|count
expr_stmt|;
else|else
name|count_in
operator|+=
name|e
operator|->
name|count
expr_stmt|;
if|if
condition|(
name|count_in
operator|==
literal|0
condition|)
name|expected
operator|=
name|count_latch
operator|*
literal|2
expr_stmt|;
else|else
name|expected
operator|=
operator|(
name|count_latch
operator|+
name|count_in
operator|-
literal|1
operator|)
operator|/
name|count_in
expr_stmt|;
comment|/* Avoid overflows.  */
return|return
operator|(
name|expected
operator|>
name|REG_BR_PROB_BASE
condition|?
name|REG_BR_PROB_BASE
else|:
name|expected
operator|)
return|;
block|}
else|else
block|{
name|int
name|freq_in
decl_stmt|,
name|freq_latch
decl_stmt|;
name|freq_in
operator|=
literal|0
expr_stmt|;
name|freq_latch
operator|=
literal|0
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|loop->header->preds
argument_list|)
if|if
condition|(
name|e
operator|->
name|src
operator|==
name|loop
operator|->
name|latch
condition|)
name|freq_latch
operator|=
name|EDGE_FREQUENCY
argument_list|(
name|e
argument_list|)
expr_stmt|;
else|else
name|freq_in
operator|+=
name|EDGE_FREQUENCY
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|freq_in
operator|==
literal|0
condition|)
return|return
name|freq_latch
operator|*
literal|2
return|;
return|return
operator|(
name|freq_latch
operator|+
name|freq_in
operator|-
literal|1
operator|)
operator|/
name|freq_in
return|;
block|}
block|}
end_function

begin_comment
comment|/* Returns the maximum level of nesting of subloops of LOOP.  */
end_comment

begin_function
name|unsigned
name|get_loop_level
parameter_list|(
specifier|const
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
specifier|const
name|struct
name|loop
modifier|*
name|ploop
decl_stmt|;
name|unsigned
name|mx
init|=
literal|0
decl_stmt|,
name|l
decl_stmt|;
for|for
control|(
name|ploop
operator|=
name|loop
operator|->
name|inner
init|;
name|ploop
condition|;
name|ploop
operator|=
name|ploop
operator|->
name|next
control|)
block|{
name|l
operator|=
name|get_loop_level
argument_list|(
name|ploop
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|>=
name|mx
condition|)
name|mx
operator|=
name|l
operator|+
literal|1
expr_stmt|;
block|}
return|return
name|mx
return|;
block|}
end_function

begin_comment
comment|/* Returns estimate on cost of computing SEQ.  */
end_comment

begin_function
specifier|static
name|unsigned
name|seq_cost
parameter_list|(
name|rtx
name|seq
parameter_list|)
block|{
name|unsigned
name|cost
init|=
literal|0
decl_stmt|;
name|rtx
name|set
decl_stmt|;
for|for
control|(
init|;
name|seq
condition|;
name|seq
operator|=
name|NEXT_INSN
argument_list|(
name|seq
argument_list|)
control|)
block|{
name|set
operator|=
name|single_set
argument_list|(
name|seq
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
condition|)
name|cost
operator|+=
name|rtx_cost
argument_list|(
name|set
argument_list|,
name|SET
argument_list|)
expr_stmt|;
else|else
name|cost
operator|++
expr_stmt|;
block|}
return|return
name|cost
return|;
block|}
end_function

begin_comment
comment|/* The properties of the target.  */
end_comment

begin_decl_stmt
name|unsigned
name|target_avail_regs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of available registers.  */
end_comment

begin_decl_stmt
name|unsigned
name|target_res_regs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of reserved registers.  */
end_comment

begin_decl_stmt
name|unsigned
name|target_small_cost
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The cost for register when there is a free one.  */
end_comment

begin_decl_stmt
name|unsigned
name|target_pres_cost
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The cost for register when there are not too many 				   free ones.  */
end_comment

begin_decl_stmt
name|unsigned
name|target_spill_cost
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The cost for register when we need to spill.  */
end_comment

begin_comment
comment|/* Initialize the constants for computing set costs.  */
end_comment

begin_function
name|void
name|init_set_costs
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|seq
decl_stmt|;
name|rtx
name|reg1
init|=
name|gen_raw_REG
argument_list|(
name|SImode
argument_list|,
name|FIRST_PSEUDO_REGISTER
argument_list|)
decl_stmt|;
name|rtx
name|reg2
init|=
name|gen_raw_REG
argument_list|(
name|SImode
argument_list|,
name|FIRST_PSEUDO_REGISTER
operator|+
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|addr
init|=
name|gen_raw_REG
argument_list|(
name|Pmode
argument_list|,
name|FIRST_PSEUDO_REGISTER
operator|+
literal|2
argument_list|)
decl_stmt|;
name|rtx
name|mem
init|=
name|validize_mem
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|addr
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|GENERAL_REGS
index|]
argument_list|,
name|i
argument_list|)
operator|&&
operator|!
name|fixed_regs
index|[
name|i
index|]
condition|)
name|target_avail_regs
operator|++
expr_stmt|;
name|target_res_regs
operator|=
literal|3
expr_stmt|;
comment|/* These are really just heuristic values.  */
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg1
argument_list|,
name|reg2
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|target_small_cost
operator|=
name|seq_cost
argument_list|(
name|seq
argument_list|)
expr_stmt|;
name|target_pres_cost
operator|=
literal|2
operator|*
name|target_small_cost
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|reg1
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg2
argument_list|,
name|mem
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|target_spill_cost
operator|=
name|seq_cost
argument_list|(
name|seq
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Calculates cost for having SIZE new loop global variables.  REGS_USED is the    number of global registers used in loop.  N_USES is the number of relevant    variable uses.  */
end_comment

begin_function
name|unsigned
name|global_cost_for_size
parameter_list|(
name|unsigned
name|size
parameter_list|,
name|unsigned
name|regs_used
parameter_list|,
name|unsigned
name|n_uses
parameter_list|)
block|{
name|unsigned
name|regs_needed
init|=
name|regs_used
operator|+
name|size
decl_stmt|;
name|unsigned
name|cost
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|regs_needed
operator|+
name|target_res_regs
operator|<=
name|target_avail_regs
condition|)
name|cost
operator|+=
name|target_small_cost
operator|*
name|size
expr_stmt|;
elseif|else
if|if
condition|(
name|regs_needed
operator|<=
name|target_avail_regs
condition|)
name|cost
operator|+=
name|target_pres_cost
operator|*
name|size
expr_stmt|;
else|else
block|{
name|cost
operator|+=
name|target_pres_cost
operator|*
name|size
expr_stmt|;
name|cost
operator|+=
name|target_spill_cost
operator|*
name|n_uses
operator|*
operator|(
name|regs_needed
operator|-
name|target_avail_regs
operator|)
operator|/
name|regs_needed
expr_stmt|;
block|}
return|return
name|cost
return|;
block|}
end_function

begin_comment
comment|/* Sets EDGE_LOOP_EXIT flag for all exits of LOOPS.  */
end_comment

begin_function
name|void
name|mark_loop_exit_edges
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|edge
name|e
decl_stmt|;
if|if
condition|(
name|loops
operator|->
name|num
operator|<=
literal|1
condition|)
return|return;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|edge_iterator
name|ei
decl_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
block|{
if|if
condition|(
name|bb
operator|->
name|loop_father
operator|->
name|outer
operator|&&
name|loop_exit_edge_p
argument_list|(
name|bb
operator|->
name|loop_father
argument_list|,
name|e
argument_list|)
condition|)
name|e
operator|->
name|flags
operator||=
name|EDGE_LOOP_EXIT
expr_stmt|;
else|else
name|e
operator|->
name|flags
operator|&=
operator|~
name|EDGE_LOOP_EXIT
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

