begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Set up combined include path chain for the preprocessor.    Copyright (C) 1986, 1987, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006    Free Software Foundation, Inc.     Broken out of cppinit.c and cppfiles.c and rewritten Mar 2003.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"machmode.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"cpplib.h"
end_include

begin_include
include|#
directive|include
file|"prefix.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_include
include|#
directive|include
file|"c-incpath.h"
end_include

begin_include
include|#
directive|include
file|"cppdefault.h"
end_include

begin_comment
comment|/* Windows does not natively support inodes, and neither does MSDOS.    Cygwin's emulation can generate non-unique inodes, so don't use it.    VMS has non-numeric inodes.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_define
define|#
directive|define
name|INO_T_EQ
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|)
value|(!memcmp (&(A),&(B), sizeof (A)))
end_define

begin_define
define|#
directive|define
name|INO_T_COPY
parameter_list|(
name|DEST
parameter_list|,
name|SRC
parameter_list|)
value|memcpy(&(DEST),&(SRC), sizeof (SRC))
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
operator|(
name|defined
name|_WIN32
operator|&&
operator|!
name|defined
argument_list|(
name|_UWIN
argument_list|)
operator|)
operator|||
name|defined
name|__MSDOS__
end_if

begin_define
define|#
directive|define
name|INO_T_EQ
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|)
value|0
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|INO_T_EQ
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|)
value|((A) == (B))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|INO_T_COPY
parameter_list|(
name|DEST
parameter_list|,
name|SRC
parameter_list|)
value|(DEST) = (SRC)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|char
name|dir_separator_str
index|[]
init|=
block|{
name|DIR_SEPARATOR
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|add_env_var_paths
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_standard_paths
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_path
parameter_list|(
name|struct
name|cpp_dir
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|merge_include_chains
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|cpp_dir
modifier|*
name|remove_duplicates
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
name|struct
name|cpp_dir
modifier|*
parameter_list|,
name|struct
name|cpp_dir
modifier|*
parameter_list|,
name|struct
name|cpp_dir
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Include chains heads and tails.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cpp_dir
modifier|*
name|heads
index|[
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cpp_dir
modifier|*
name|tails
index|[
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|quote_ignores_source_dir
decl_stmt|;
end_decl_stmt

begin_enum
enum|enum
block|{
name|REASON_QUIET
init|=
literal|0
block|,
name|REASON_NOENT
block|,
name|REASON_DUP
block|,
name|REASON_DUP_SYS
block|}
enum|;
end_enum

begin_comment
comment|/* Free an element of the include chain, possibly giving a reason.  */
end_comment

begin_function
specifier|static
name|void
name|free_path
parameter_list|(
name|struct
name|cpp_dir
modifier|*
name|path
parameter_list|,
name|int
name|reason
parameter_list|)
block|{
switch|switch
condition|(
name|reason
condition|)
block|{
case|case
name|REASON_DUP
case|:
case|case
name|REASON_DUP_SYS
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"ignoring duplicate directory \"%s\"\n"
argument_list|)
argument_list|,
name|path
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|reason
operator|==
name|REASON_DUP_SYS
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|_
argument_list|(
literal|"  as it is a non-system directory that duplicates a system directory\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REASON_NOENT
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"ignoring nonexistent directory \"%s\"\n"
argument_list|)
argument_list|,
name|path
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|REASON_QUIET
case|:
default|default:
break|break;
block|}
name|free
argument_list|(
name|path
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read ENV_VAR for a PATH_SEPARATOR-separated list of file names; and    append all the names to the search path CHAIN.  */
end_comment

begin_function
specifier|static
name|void
name|add_env_var_paths
parameter_list|(
specifier|const
name|char
modifier|*
name|env_var
parameter_list|,
name|int
name|chain
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
name|path
decl_stmt|;
name|GET_ENVIRONMENT
argument_list|(
name|q
argument_list|,
name|env_var
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|q
condition|)
return|return;
for|for
control|(
name|p
operator|=
name|q
init|;
operator|*
name|q
condition|;
name|p
operator|=
name|q
operator|+
literal|1
control|)
block|{
name|q
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|q
operator|!=
literal|0
operator|&&
operator|*
name|q
operator|!=
name|PATH_SEPARATOR
condition|)
name|q
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|q
condition|)
name|path
operator|=
name|xstrdup
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
else|else
block|{
name|path
operator|=
name|XNEWVEC
argument_list|(
name|char
argument_list|,
name|q
operator|-
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|path
argument_list|,
name|p
argument_list|,
name|q
operator|-
name|p
argument_list|)
expr_stmt|;
name|path
index|[
name|q
operator|-
name|p
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|add_path
argument_list|(
name|path
argument_list|,
name|chain
argument_list|,
name|chain
operator|==
name|SYSTEM
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Append the standard include chain defined in cppdefault.c.  */
end_comment

begin_function
specifier|static
name|void
name|add_standard_paths
parameter_list|(
specifier|const
name|char
modifier|*
name|sysroot
parameter_list|,
specifier|const
name|char
modifier|*
name|iprefix
parameter_list|,
specifier|const
name|char
modifier|*
name|imultilib
parameter_list|,
name|int
name|cxx_stdinc
parameter_list|)
block|{
specifier|const
name|struct
name|default_include
modifier|*
name|p
decl_stmt|;
name|size_t
name|len
decl_stmt|;
if|if
condition|(
name|iprefix
operator|&&
operator|(
name|len
operator|=
name|cpp_GCC_INCLUDE_DIR_len
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Look for directories that start with the standard prefix. 	 "Translate" them, i.e. replace /usr/local/lib/gcc... with 	 IPREFIX and search them first.  */
for|for
control|(
name|p
operator|=
name|cpp_include_defaults
init|;
name|p
operator|->
name|fname
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|p
operator|->
name|cplusplus
operator|||
name|cxx_stdinc
condition|)
block|{
comment|/* Should we be translating sysrooted dirs too?  Assume 		 that iprefix and sysroot are mutually exclusive, for 		 now.  */
if|if
condition|(
name|sysroot
operator|&&
name|p
operator|->
name|add_sysroot
condition|)
continue|continue;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p
operator|->
name|fname
argument_list|,
name|cpp_GCC_INCLUDE_DIR
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|char
modifier|*
name|str
init|=
name|concat
argument_list|(
name|iprefix
argument_list|,
name|p
operator|->
name|fname
operator|+
name|len
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|multilib
operator|&&
name|imultilib
condition|)
name|str
operator|=
name|concat
argument_list|(
name|str
argument_list|,
name|dir_separator_str
argument_list|,
name|imultilib
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|add_path
argument_list|(
name|str
argument_list|,
name|SYSTEM
argument_list|,
name|p
operator|->
name|cxx_aware
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
for|for
control|(
name|p
operator|=
name|cpp_include_defaults
init|;
name|p
operator|->
name|fname
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|p
operator|->
name|cplusplus
operator|||
name|cxx_stdinc
condition|)
block|{
name|char
modifier|*
name|str
decl_stmt|;
comment|/* Should this directory start with the sysroot?  */
if|if
condition|(
name|sysroot
operator|&&
name|p
operator|->
name|add_sysroot
condition|)
name|str
operator|=
name|concat
argument_list|(
name|sysroot
argument_list|,
name|p
operator|->
name|fname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|str
operator|=
name|update_path
argument_list|(
name|p
operator|->
name|fname
argument_list|,
name|p
operator|->
name|component
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|multilib
operator|&&
name|imultilib
condition|)
name|str
operator|=
name|concat
argument_list|(
name|str
argument_list|,
name|dir_separator_str
argument_list|,
name|imultilib
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|add_path
argument_list|(
name|str
argument_list|,
name|SYSTEM
argument_list|,
name|p
operator|->
name|cxx_aware
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* For each duplicate path in chain HEAD, keep just the first one.    Remove each path in chain HEAD that also exists in chain SYSTEM.    Set the NEXT pointer of the last path in the resulting chain to    JOIN, unless it duplicates JOIN in which case the last path is    removed.  Return the head of the resulting chain.  Any of HEAD,    JOIN and SYSTEM can be NULL.  */
end_comment

begin_function
specifier|static
name|struct
name|cpp_dir
modifier|*
name|remove_duplicates
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|struct
name|cpp_dir
modifier|*
name|head
parameter_list|,
name|struct
name|cpp_dir
modifier|*
name|system
parameter_list|,
name|struct
name|cpp_dir
modifier|*
name|join
parameter_list|,
name|int
name|verbose
parameter_list|)
block|{
name|struct
name|cpp_dir
modifier|*
modifier|*
name|pcur
decl_stmt|,
modifier|*
name|tmp
decl_stmt|,
modifier|*
name|cur
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
for|for
control|(
name|pcur
operator|=
operator|&
name|head
init|;
operator|*
name|pcur
condition|;
control|)
block|{
name|int
name|reason
init|=
name|REASON_QUIET
decl_stmt|;
name|cur
operator|=
operator|*
name|pcur
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|cur
operator|->
name|name
argument_list|,
operator|&
name|st
argument_list|)
condition|)
block|{
comment|/* Dirs that don't exist are silently ignored, unless verbose.  */
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
name|cpp_errno
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
name|cur
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* If -Wmissing-include-dirs is given, warn.  */
name|cpp_options
modifier|*
name|opts
init|=
name|cpp_get_options
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
if|if
condition|(
name|opts
operator|->
name|warn_missing_include_dirs
operator|&&
name|cur
operator|->
name|user_supplied_p
condition|)
name|cpp_errno
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_WARNING
argument_list|,
name|cur
operator|->
name|name
argument_list|)
expr_stmt|;
name|reason
operator|=
name|REASON_NOENT
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
name|cpp_error_with_line
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s: not a directory"
argument_list|,
name|cur
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
block|{
name|INO_T_COPY
argument_list|(
name|cur
operator|->
name|ino
argument_list|,
name|st
operator|.
name|st_ino
argument_list|)
expr_stmt|;
name|cur
operator|->
name|dev
operator|=
name|st
operator|.
name|st_dev
expr_stmt|;
comment|/* Remove this one if it is in the system chain.  */
name|reason
operator|=
name|REASON_DUP_SYS
expr_stmt|;
for|for
control|(
name|tmp
operator|=
name|system
init|;
name|tmp
condition|;
name|tmp
operator|=
name|tmp
operator|->
name|next
control|)
if|if
condition|(
name|INO_T_EQ
argument_list|(
name|tmp
operator|->
name|ino
argument_list|,
name|cur
operator|->
name|ino
argument_list|)
operator|&&
name|tmp
operator|->
name|dev
operator|==
name|cur
operator|->
name|dev
operator|&&
name|cur
operator|->
name|construct
operator|==
name|tmp
operator|->
name|construct
condition|)
break|break;
if|if
condition|(
operator|!
name|tmp
condition|)
block|{
comment|/* Duplicate of something earlier in the same chain?  */
name|reason
operator|=
name|REASON_DUP
expr_stmt|;
for|for
control|(
name|tmp
operator|=
name|head
init|;
name|tmp
operator|!=
name|cur
condition|;
name|tmp
operator|=
name|tmp
operator|->
name|next
control|)
if|if
condition|(
name|INO_T_EQ
argument_list|(
name|cur
operator|->
name|ino
argument_list|,
name|tmp
operator|->
name|ino
argument_list|)
operator|&&
name|cur
operator|->
name|dev
operator|==
name|tmp
operator|->
name|dev
operator|&&
name|cur
operator|->
name|construct
operator|==
name|tmp
operator|->
name|construct
condition|)
break|break;
if|if
condition|(
name|tmp
operator|==
name|cur
comment|/* Last in the chain and duplicate of JOIN?  */
operator|&&
operator|!
operator|(
name|cur
operator|->
name|next
operator|==
name|NULL
operator|&&
name|join
operator|&&
name|INO_T_EQ
argument_list|(
name|cur
operator|->
name|ino
argument_list|,
name|join
operator|->
name|ino
argument_list|)
operator|&&
name|cur
operator|->
name|dev
operator|==
name|join
operator|->
name|dev
operator|&&
name|cur
operator|->
name|construct
operator|==
name|join
operator|->
name|construct
operator|)
condition|)
block|{
comment|/* Unique, so keep this directory.  */
name|pcur
operator|=
operator|&
name|cur
operator|->
name|next
expr_stmt|;
continue|continue;
block|}
block|}
block|}
comment|/* Remove this entry from the chain.  */
operator|*
name|pcur
operator|=
name|cur
operator|->
name|next
expr_stmt|;
name|free_path
argument_list|(
name|cur
argument_list|,
name|verbose
condition|?
name|reason
else|:
name|REASON_QUIET
argument_list|)
expr_stmt|;
block|}
operator|*
name|pcur
operator|=
name|join
expr_stmt|;
return|return
name|head
return|;
block|}
end_function

begin_comment
comment|/* Merge the four include chains together in the order quote, bracket,    system, after.  Remove duplicate dirs (as determined by    INO_T_EQ()).     We can't just merge the lists and then uniquify them because then    we may lose directories from the<> search path that should be    there; consider -iquote foo -iquote bar -Ifoo -Iquux.  It is    however safe to treat -iquote bar -iquote foo -Ifoo -Iquux as if    written -iquote bar -Ifoo -Iquux.  */
end_comment

begin_function
specifier|static
name|void
name|merge_include_chains
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|int
name|verbose
parameter_list|)
block|{
comment|/* Join the SYSTEM and AFTER chains.  Remove duplicates in the      resulting SYSTEM chain.  */
if|if
condition|(
name|heads
index|[
name|SYSTEM
index|]
condition|)
name|tails
index|[
name|SYSTEM
index|]
operator|->
name|next
operator|=
name|heads
index|[
name|AFTER
index|]
expr_stmt|;
else|else
name|heads
index|[
name|SYSTEM
index|]
operator|=
name|heads
index|[
name|AFTER
index|]
expr_stmt|;
name|heads
index|[
name|SYSTEM
index|]
operator|=
name|remove_duplicates
argument_list|(
name|pfile
argument_list|,
name|heads
index|[
name|SYSTEM
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
comment|/* Remove duplicates from BRACKET that are in itself or SYSTEM, and      join it to SYSTEM.  */
name|heads
index|[
name|BRACKET
index|]
operator|=
name|remove_duplicates
argument_list|(
name|pfile
argument_list|,
name|heads
index|[
name|BRACKET
index|]
argument_list|,
name|heads
index|[
name|SYSTEM
index|]
argument_list|,
name|heads
index|[
name|SYSTEM
index|]
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
comment|/* Remove duplicates from QUOTE that are in itself or SYSTEM, and      join it to BRACKET.  */
name|heads
index|[
name|QUOTE
index|]
operator|=
name|remove_duplicates
argument_list|(
name|pfile
argument_list|,
name|heads
index|[
name|QUOTE
index|]
argument_list|,
name|heads
index|[
name|SYSTEM
index|]
argument_list|,
name|heads
index|[
name|BRACKET
index|]
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
comment|/* If verbose, print the list of dirs to search.  */
if|if
condition|(
name|verbose
condition|)
block|{
name|struct
name|cpp_dir
modifier|*
name|p
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|_
argument_list|(
literal|"#include \"...\" search starts here:\n"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|heads
index|[
name|QUOTE
index|]
init|;
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|==
name|heads
index|[
name|BRACKET
index|]
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|_
argument_list|(
literal|"#include<...> search starts here:\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
break|break;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s\n"
argument_list|,
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|_
argument_list|(
literal|"End of search list.\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Use given -I paths for #include "..." but not #include<...>, and    don't search the directory of the present file for #include "...".    (Note that -I. -I- is not the same as the default setup; -I. uses    the compiler's working dir.)  */
end_comment

begin_function
name|void
name|split_quote_chain
parameter_list|(
name|void
parameter_list|)
block|{
name|heads
index|[
name|QUOTE
index|]
operator|=
name|heads
index|[
name|BRACKET
index|]
expr_stmt|;
name|tails
index|[
name|QUOTE
index|]
operator|=
name|tails
index|[
name|BRACKET
index|]
expr_stmt|;
name|heads
index|[
name|BRACKET
index|]
operator|=
name|NULL
expr_stmt|;
name|tails
index|[
name|BRACKET
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* This is NOT redundant.  */
name|quote_ignores_source_dir
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add P to the chain specified by CHAIN.  */
end_comment

begin_function
name|void
name|add_cpp_dir_path
parameter_list|(
name|cpp_dir
modifier|*
name|p
parameter_list|,
name|int
name|chain
parameter_list|)
block|{
if|if
condition|(
name|tails
index|[
name|chain
index|]
condition|)
name|tails
index|[
name|chain
index|]
operator|->
name|next
operator|=
name|p
expr_stmt|;
else|else
name|heads
index|[
name|chain
index|]
operator|=
name|p
expr_stmt|;
name|tails
index|[
name|chain
index|]
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add PATH to the include chain CHAIN. PATH must be malloc-ed and    NUL-terminated.  */
end_comment

begin_function
name|void
name|add_path
parameter_list|(
name|char
modifier|*
name|path
parameter_list|,
name|int
name|chain
parameter_list|,
name|int
name|cxx_aware
parameter_list|,
name|bool
name|user_supplied_p
parameter_list|)
block|{
name|cpp_dir
modifier|*
name|p
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_DOS_BASED_FILE_SYSTEM
argument_list|)
comment|/* Convert all backslashes to slashes.  The native CRT stat()      function does not recognize a directory that ends in a backslash      (unless it is a drive root dir, such "c:\").  Forward slashes,      trailing or otherwise, cause no problems for stat().  */
name|char
modifier|*
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|path
init|;
operator|*
name|c
condition|;
name|c
operator|++
control|)
if|if
condition|(
operator|*
name|c
operator|==
literal|'\\'
condition|)
operator|*
name|c
operator|=
literal|'/'
expr_stmt|;
endif|#
directive|endif
name|p
operator|=
name|XNEW
argument_list|(
name|cpp_dir
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|name
operator|=
name|path
expr_stmt|;
if|if
condition|(
name|chain
operator|==
name|SYSTEM
operator|||
name|chain
operator|==
name|AFTER
condition|)
name|p
operator|->
name|sysp
operator|=
literal|1
operator|+
operator|!
name|cxx_aware
expr_stmt|;
else|else
name|p
operator|->
name|sysp
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|construct
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|user_supplied_p
operator|=
name|user_supplied_p
expr_stmt|;
name|add_cpp_dir_path
argument_list|(
name|p
argument_list|,
name|chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Exported function to handle include chain merging, duplicate    removal, and registration with cpplib.  */
end_comment

begin_function
name|void
name|register_include_chains
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
specifier|const
name|char
modifier|*
name|sysroot
parameter_list|,
specifier|const
name|char
modifier|*
name|iprefix
parameter_list|,
specifier|const
name|char
modifier|*
name|imultilib
parameter_list|,
name|int
name|stdinc
parameter_list|,
name|int
name|cxx_stdinc
parameter_list|,
name|int
name|verbose
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|lang_env_vars
index|[]
init|=
block|{
literal|"C_INCLUDE_PATH"
block|,
literal|"CPLUS_INCLUDE_PATH"
block|,
literal|"OBJC_INCLUDE_PATH"
block|,
literal|"OBJCPLUS_INCLUDE_PATH"
block|}
decl_stmt|;
name|cpp_options
modifier|*
name|cpp_opts
init|=
name|cpp_get_options
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
name|size_t
name|idx
init|=
operator|(
name|cpp_opts
operator|->
name|objc
condition|?
literal|2
else|:
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|cpp_opts
operator|->
name|cplusplus
condition|)
name|idx
operator|++
expr_stmt|;
else|else
name|cxx_stdinc
operator|=
name|false
expr_stmt|;
comment|/* CPATH and language-dependent environment variables may add to the      include chain.  */
name|add_env_var_paths
argument_list|(
literal|"CPATH"
argument_list|,
name|BRACKET
argument_list|)
expr_stmt|;
name|add_env_var_paths
argument_list|(
name|lang_env_vars
index|[
name|idx
index|]
argument_list|,
name|SYSTEM
argument_list|)
expr_stmt|;
name|target_c_incpath
operator|.
name|extra_pre_includes
argument_list|(
name|sysroot
argument_list|,
name|iprefix
argument_list|,
name|stdinc
argument_list|)
expr_stmt|;
comment|/* Finally chain on the standard directories.  */
if|if
condition|(
name|stdinc
condition|)
name|add_standard_paths
argument_list|(
name|sysroot
argument_list|,
name|iprefix
argument_list|,
name|imultilib
argument_list|,
name|cxx_stdinc
argument_list|)
expr_stmt|;
name|target_c_incpath
operator|.
name|extra_includes
argument_list|(
name|sysroot
argument_list|,
name|iprefix
argument_list|,
name|stdinc
argument_list|)
expr_stmt|;
name|merge_include_chains
argument_list|(
name|pfile
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
name|cpp_set_include_chains
argument_list|(
name|pfile
argument_list|,
name|heads
index|[
name|QUOTE
index|]
argument_list|,
name|heads
index|[
name|BRACKET
index|]
argument_list|,
name|quote_ignores_source_dir
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
operator|!
operator|(
name|defined
name|TARGET_EXTRA_INCLUDES
operator|)
operator|||
operator|!
operator|(
name|defined
name|TARGET_EXTRA_PRE_INCLUDES
operator|)
end_if

begin_function
specifier|static
name|void
name|hook_void_charptr_charptr_int
parameter_list|(
specifier|const
name|char
modifier|*
name|sysroot
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|iprefix
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|stdinc
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{ }
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TARGET_EXTRA_INCLUDES
end_ifndef

begin_define
define|#
directive|define
name|TARGET_EXTRA_INCLUDES
value|hook_void_charptr_charptr_int
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TARGET_EXTRA_PRE_INCLUDES
end_ifndef

begin_define
define|#
directive|define
name|TARGET_EXTRA_PRE_INCLUDES
value|hook_void_charptr_charptr_int
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|target_c_incpath_s
name|target_c_incpath
init|=
block|{
name|TARGET_EXTRA_PRE_INCLUDES
block|,
name|TARGET_EXTRA_INCLUDES
block|}
decl_stmt|;
end_decl_stmt

end_unit

