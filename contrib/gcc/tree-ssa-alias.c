begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Alias analysis for trees.    Copyright (C) 2004, 2005, 2006, 2007 Free Software Foundation, Inc.    Contributed by Diego Novillo<dnovillo@redhat.com>  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"tree-dump.h"
end_include

begin_include
include|#
directive|include
file|"tree-gimple.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"tree-inline.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"tree-ssa-structalias.h"
end_include

begin_include
include|#
directive|include
file|"convert.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_include
include|#
directive|include
file|"ipa-type-escape.h"
end_include

begin_include
include|#
directive|include
file|"vec.h"
end_include

begin_include
include|#
directive|include
file|"bitmap.h"
end_include

begin_include
include|#
directive|include
file|"vecprim.h"
end_include

begin_include
include|#
directive|include
file|"pointer-set.h"
end_include

begin_comment
comment|/* Obstack used to hold grouping bitmaps and other temporary bitmaps used by    aliasing  */
end_comment

begin_decl_stmt
specifier|static
name|bitmap_obstack
name|alias_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 'true' after aliases have been computed (see compute_may_aliases).  */
end_comment

begin_decl_stmt
name|bool
name|aliases_computed_p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Structure to map a variable to its alias set and keep track of the    virtual operands that will be needed to represent it.  */
end_comment

begin_struct
struct|struct
name|alias_map_d
block|{
comment|/* Variable and its alias set.  */
name|tree
name|var
decl_stmt|;
name|HOST_WIDE_INT
name|set
decl_stmt|;
comment|/* Total number of virtual operands that will be needed to represent      all the aliases of VAR.  */
name|long
name|total_alias_vops
decl_stmt|;
comment|/* Nonzero if the aliases for this memory tag have been grouped      already.  Used in group_aliases.  */
name|unsigned
name|int
name|grouped_p
range|:
literal|1
decl_stmt|;
comment|/* Set of variables aliased with VAR.  This is the exact same      information contained in VAR_ANN (VAR)->MAY_ALIASES, but in      bitmap form to speed up alias grouping.  */
name|bitmap
name|may_aliases
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Counters used to display statistics on alias analysis.  */
end_comment

begin_struct
struct|struct
name|alias_stats_d
block|{
name|unsigned
name|int
name|alias_queries
decl_stmt|;
name|unsigned
name|int
name|alias_mayalias
decl_stmt|;
name|unsigned
name|int
name|alias_noalias
decl_stmt|;
name|unsigned
name|int
name|simple_queries
decl_stmt|;
name|unsigned
name|int
name|simple_resolved
decl_stmt|;
name|unsigned
name|int
name|tbaa_queries
decl_stmt|;
name|unsigned
name|int
name|tbaa_resolved
decl_stmt|;
name|unsigned
name|int
name|structnoaddress_queries
decl_stmt|;
name|unsigned
name|int
name|structnoaddress_resolved
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Local variables.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|alias_stats_d
name|alias_stats
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Local functions.  */
end_comment

begin_function_decl
specifier|static
name|void
name|compute_flow_insensitive_aliasing
parameter_list|(
name|struct
name|alias_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|finalize_ref_all_pointers
parameter_list|(
name|struct
name|alias_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_alias_stats
parameter_list|(
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|may_alias_p
parameter_list|(
name|tree
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|tree
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|create_memory_tag
parameter_list|(
name|tree
name|type
parameter_list|,
name|bool
name|is_type_tag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|get_tmt_for
parameter_list|(
name|tree
parameter_list|,
name|struct
name|alias_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|get_nmt_for
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_may_alias
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|replace_may_alias
parameter_list|(
name|tree
parameter_list|,
name|size_t
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|alias_info
modifier|*
name|init_alias_info
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|delete_alias_info
parameter_list|(
name|struct
name|alias_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|compute_flow_sensitive_aliasing
parameter_list|(
name|struct
name|alias_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|setup_pointers_and_addressables
parameter_list|(
name|struct
name|alias_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|create_global_var
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|maybe_create_global_var
parameter_list|(
name|struct
name|alias_info
modifier|*
name|ai
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|group_aliases
parameter_list|(
name|struct
name|alias_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_pt_anything
parameter_list|(
name|tree
name|ptr
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Global declarations.  */
end_comment

begin_comment
comment|/* Call clobbered variables in the function.  If bit I is set, then    REFERENCED_VARS (I) is call-clobbered.  */
end_comment

begin_decl_stmt
name|bitmap
name|call_clobbered_vars
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Addressable variables in the function.  If bit I is set, then    REFERENCED_VARS (I) has had its address taken.  Note that    CALL_CLOBBERED_VARS and ADDRESSABLE_VARS are not related.  An    addressable variable is not necessarily call-clobbered (e.g., a    local addressable whose address does not escape) and not all    call-clobbered variables are addressable (e.g., a local static    variable).  */
end_comment

begin_decl_stmt
name|bitmap
name|addressable_vars
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When the program has too many call-clobbered variables and call-sites,    this variable is used to represent the clobbering effects of function    calls.  In these cases, all the call clobbered variables in the program    are forced to alias this variable.  This reduces compile times by not    having to keep track of too many V_MAY_DEF expressions at call sites.  */
end_comment

begin_decl_stmt
name|tree
name|global_var
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* qsort comparison function to sort type/name tags by DECL_UID.  */
end_comment

begin_function
specifier|static
name|int
name|sort_tags_by_id
parameter_list|(
specifier|const
name|void
modifier|*
name|pa
parameter_list|,
specifier|const
name|void
modifier|*
name|pb
parameter_list|)
block|{
name|tree
name|a
init|=
operator|*
operator|(
name|tree
operator|*
operator|)
name|pa
decl_stmt|;
name|tree
name|b
init|=
operator|*
operator|(
name|tree
operator|*
operator|)
name|pb
decl_stmt|;
return|return
name|DECL_UID
argument_list|(
name|a
argument_list|)
operator|-
name|DECL_UID
argument_list|(
name|b
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Initialize WORKLIST to contain those memory tags that are marked call    clobbered.  Initialized WORKLIST2 to contain the reasons these    memory tags escaped.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|init_transitive_clobber_worklist
argument_list|(
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
name|worklist
argument_list|,
name|VEC
argument_list|(
name|int
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
name|worklist2
argument_list|)
block|{
name|referenced_var_iterator
name|rvi
decl_stmt|;
name|tree
name|curr
decl_stmt|;
name|FOR_EACH_REFERENCED_VAR
argument_list|(
argument|curr
argument_list|,
argument|rvi
argument_list|)
block|{
if|if
condition|(
name|MTAG_P
argument_list|(
name|curr
argument_list|)
operator|&&
name|is_call_clobbered
argument_list|(
name|curr
argument_list|)
condition|)
block|{
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
operator|*
name|worklist
argument_list|,
name|curr
argument_list|)
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|int
argument_list|,
name|heap
argument_list|,
operator|*
name|worklist2
argument_list|,
name|var_ann
argument_list|(
name|curr
argument_list|)
operator|->
name|escape_mask
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_decl_stmt

begin_comment
comment|/* Add ALIAS to WORKLIST (and the reason for escaping REASON to WORKLIST2) if    ALIAS is not already marked call clobbered, and is a memory    tag.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|add_to_worklist
argument_list|(
name|tree
name|alias
argument_list|,
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
name|worklist
argument_list|,
name|VEC
argument_list|(
name|int
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
name|worklist2
argument_list|,
name|int
name|reason
argument_list|)
block|{
if|if
condition|(
name|MTAG_P
argument_list|(
name|alias
argument_list|)
operator|&&
operator|!
name|is_call_clobbered
argument_list|(
name|alias
argument_list|)
condition|)
block|{
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
operator|*
name|worklist
argument_list|,
name|alias
argument_list|)
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|int
argument_list|,
name|heap
argument_list|,
operator|*
name|worklist2
argument_list|,
name|reason
argument_list|)
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_comment
comment|/* Mark aliases of TAG as call clobbered, and place any tags on the    alias list that were not already call clobbered on WORKLIST.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|mark_aliases_call_clobbered
argument_list|(
name|tree
name|tag
argument_list|,
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
name|worklist
argument_list|,
name|VEC
argument_list|(
name|int
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
name|worklist2
argument_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
name|ma
expr_stmt|;
name|tree
name|entry
decl_stmt|;
name|var_ann_t
name|ta
init|=
name|var_ann
argument_list|(
name|tag
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|MTAG_P
argument_list|(
name|tag
argument_list|)
condition|)
return|return;
name|ma
operator|=
name|may_aliases
argument_list|(
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ma
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
name|ma
argument_list|,
name|i
argument_list|,
name|entry
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|unmodifiable_var_p
argument_list|(
name|entry
argument_list|)
condition|)
block|{
name|add_to_worklist
argument_list|(
name|entry
argument_list|,
name|worklist
argument_list|,
name|worklist2
argument_list|,
name|ta
operator|->
name|escape_mask
argument_list|)
expr_stmt|;
name|mark_call_clobbered
argument_list|(
name|entry
argument_list|,
name|ta
operator|->
name|escape_mask
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_decl_stmt

begin_comment
comment|/* Tags containing global vars need to be marked as global.    Tags containing call clobbered vars need to be marked as call    clobbered. */
end_comment

begin_function
specifier|static
name|void
name|compute_tag_properties
parameter_list|(
name|void
parameter_list|)
block|{
name|referenced_var_iterator
name|rvi
decl_stmt|;
name|tree
name|tag
decl_stmt|;
name|bool
name|changed
init|=
name|true
decl_stmt|;
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
name|taglist
operator|=
name|NULL
expr_stmt|;
name|FOR_EACH_REFERENCED_VAR
argument_list|(
argument|tag
argument_list|,
argument|rvi
argument_list|)
block|{
if|if
condition|(
operator|!
name|MTAG_P
argument_list|(
name|tag
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|tag
argument_list|)
operator|==
name|STRUCT_FIELD_TAG
condition|)
continue|continue;
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|taglist
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
comment|/* We sort the taglist by DECL_UID, for two reasons.      1. To get a sequential ordering to make the bitmap accesses      faster.      2. Because of the way we compute aliases, it's more likely that      an earlier tag is included in a later tag, and this will reduce      the number of iterations.       If we had a real tag graph, we would just topo-order it and be      done with it.  */
name|qsort
argument_list|(
name|VEC_address
argument_list|(
name|tree
argument_list|,
name|taglist
argument_list|)
argument_list|,
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|taglist
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|,
name|sort_tags_by_id
argument_list|)
expr_stmt|;
comment|/* Go through each tag not marked as global, and if it aliases      global vars, mark it global.             If the tag contains call clobbered vars, mark it call      clobbered.         This loop iterates because tags may appear in the may-aliases      list of other tags when we group.  */
while|while
condition|(
name|changed
condition|)
block|{
name|unsigned
name|int
name|k
decl_stmt|;
name|changed
operator|=
name|false
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
name|taglist
argument_list|,
name|k
argument_list|,
name|tag
argument_list|)
condition|;
name|k
operator|++
control|)
block|{
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
name|ma
expr_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|tree
name|entry
decl_stmt|;
name|bool
name|tagcc
init|=
name|is_call_clobbered
argument_list|(
name|tag
argument_list|)
decl_stmt|;
name|bool
name|tagglobal
init|=
name|MTAG_GLOBAL
argument_list|(
name|tag
argument_list|)
decl_stmt|;
if|if
condition|(
name|tagcc
operator|&&
name|tagglobal
condition|)
continue|continue;
name|ma
operator|=
name|may_aliases
argument_list|(
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ma
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
name|ma
argument_list|,
name|i
argument_list|,
name|entry
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
comment|/* Call clobbered entries cause the tag to be marked 		 call clobbered.  */
if|if
condition|(
operator|!
name|tagcc
operator|&&
name|is_call_clobbered
argument_list|(
name|entry
argument_list|)
condition|)
block|{
name|mark_call_clobbered
argument_list|(
name|tag
argument_list|,
name|var_ann
argument_list|(
name|entry
argument_list|)
operator|->
name|escape_mask
argument_list|)
expr_stmt|;
name|tagcc
operator|=
name|true
expr_stmt|;
name|changed
operator|=
name|true
expr_stmt|;
block|}
comment|/* Global vars cause the tag to be marked global.  */
if|if
condition|(
operator|!
name|tagglobal
operator|&&
name|is_global_var
argument_list|(
name|entry
argument_list|)
condition|)
block|{
name|MTAG_GLOBAL
argument_list|(
name|tag
argument_list|)
operator|=
name|true
expr_stmt|;
name|changed
operator|=
name|true
expr_stmt|;
name|tagglobal
operator|=
name|true
expr_stmt|;
block|}
comment|/* Early exit once both global and cc are set, since the 		 loop can't do any more than that.  */
if|if
condition|(
name|tagcc
operator|&&
name|tagglobal
condition|)
break|break;
block|}
block|}
block|}
name|VEC_free
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|taglist
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set up the initial variable clobbers and globalness.    When this function completes, only tags whose aliases need to be    clobbered will be set clobbered.  Tags clobbered because they       contain call clobbered vars are handled in compute_tag_properties.  */
end_comment

begin_function
specifier|static
name|void
name|set_initial_properties
parameter_list|(
name|struct
name|alias_info
modifier|*
name|ai
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|referenced_var_iterator
name|rvi
decl_stmt|;
name|tree
name|var
decl_stmt|;
name|tree
name|ptr
decl_stmt|;
name|FOR_EACH_REFERENCED_VAR
argument_list|(
argument|var
argument_list|,
argument|rvi
argument_list|)
block|{
if|if
condition|(
name|is_global_var
argument_list|(
name|var
argument_list|)
operator|&&
operator|(
operator|!
name|var_can_have_subvars
argument_list|(
name|var
argument_list|)
operator|||
name|get_subvars_for_var
argument_list|(
name|var
argument_list|)
operator|==
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|unmodifiable_var_p
argument_list|(
name|var
argument_list|)
condition|)
name|mark_call_clobbered
argument_list|(
name|var
argument_list|,
name|ESCAPE_IS_GLOBAL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|PARM_DECL
operator|&&
name|default_def
argument_list|(
name|var
argument_list|)
operator|&&
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|var
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|def
init|=
name|default_def
argument_list|(
name|var
argument_list|)
decl_stmt|;
name|get_ptr_info
argument_list|(
name|def
argument_list|)
operator|->
name|value_escapes_p
operator|=
literal|1
expr_stmt|;
name|get_ptr_info
argument_list|(
name|def
argument_list|)
operator|->
name|escape_mask
operator||=
name|ESCAPE_IS_PARM
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
name|ai
operator|->
name|processed_ptrs
argument_list|,
name|i
argument_list|,
name|ptr
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ptr_info_def
modifier|*
name|pi
init|=
name|SSA_NAME_PTR_INFO
argument_list|(
name|ptr
argument_list|)
decl_stmt|;
name|var_ann_t
name|v_ann
init|=
name|var_ann
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|ptr
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|pi
operator|->
name|value_escapes_p
condition|)
block|{
comment|/* If PTR escapes then its associated memory tags and 	     pointed-to variables are call-clobbered.  */
if|if
condition|(
name|pi
operator|->
name|name_mem_tag
condition|)
name|mark_call_clobbered
argument_list|(
name|pi
operator|->
name|name_mem_tag
argument_list|,
name|pi
operator|->
name|escape_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|v_ann
operator|->
name|symbol_mem_tag
condition|)
name|mark_call_clobbered
argument_list|(
name|v_ann
operator|->
name|symbol_mem_tag
argument_list|,
name|pi
operator|->
name|escape_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|pt_vars
condition|)
block|{
name|bitmap_iterator
name|bi
decl_stmt|;
name|unsigned
name|int
name|j
decl_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|pi->pt_vars
argument_list|,
literal|0
argument_list|,
argument|j
argument_list|,
argument|bi
argument_list|)
if|if
condition|(
operator|!
name|unmodifiable_var_p
argument_list|(
name|referenced_var
argument_list|(
name|j
argument_list|)
argument_list|)
condition|)
name|mark_call_clobbered
argument_list|(
name|referenced_var
argument_list|(
name|j
argument_list|)
argument_list|,
name|pi
operator|->
name|escape_mask
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If the name tag is call clobbered, so is the symbol tag 	 associated with the base VAR_DECL.  */
if|if
condition|(
name|pi
operator|->
name|name_mem_tag
operator|&&
name|v_ann
operator|->
name|symbol_mem_tag
operator|&&
name|is_call_clobbered
argument_list|(
name|pi
operator|->
name|name_mem_tag
argument_list|)
condition|)
name|mark_call_clobbered
argument_list|(
name|v_ann
operator|->
name|symbol_mem_tag
argument_list|,
name|pi
operator|->
name|escape_mask
argument_list|)
expr_stmt|;
comment|/* Name tags and symbol tags that we don't know where they point 	 to, might point to global memory, and thus, are clobbered.           FIXME:  This is not quite right.  They should only be          clobbered if value_escapes_p is true, regardless of whether          they point to global memory or not.          So removing this code and fixing all the bugs would be nice.          It is the cause of a bunch of clobbering.  */
if|if
condition|(
operator|(
name|pi
operator|->
name|pt_global_mem
operator|||
name|pi
operator|->
name|pt_anything
operator|)
operator|&&
name|pi
operator|->
name|is_dereferenced
operator|&&
name|pi
operator|->
name|name_mem_tag
condition|)
block|{
name|mark_call_clobbered
argument_list|(
name|pi
operator|->
name|name_mem_tag
argument_list|,
name|ESCAPE_IS_GLOBAL
argument_list|)
expr_stmt|;
name|MTAG_GLOBAL
argument_list|(
name|pi
operator|->
name|name_mem_tag
argument_list|)
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|pi
operator|->
name|pt_global_mem
operator|||
name|pi
operator|->
name|pt_anything
operator|)
operator|&&
name|pi
operator|->
name|is_dereferenced
operator|&&
name|v_ann
operator|->
name|symbol_mem_tag
condition|)
block|{
name|mark_call_clobbered
argument_list|(
name|v_ann
operator|->
name|symbol_mem_tag
argument_list|,
name|ESCAPE_IS_GLOBAL
argument_list|)
expr_stmt|;
name|MTAG_GLOBAL
argument_list|(
name|v_ann
operator|->
name|symbol_mem_tag
argument_list|)
operator|=
name|true
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* This variable is set to true if we are updating the used alone    information for SMTs, or are in a pass that is going to break it    temporarily.  */
end_comment

begin_decl_stmt
name|bool
name|updating_used_alone
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Compute which variables need to be marked call clobbered because    their tag is call clobbered, and which tags need to be marked    global because they contain global variables.  */
end_comment

begin_function
specifier|static
name|void
name|compute_call_clobbered
parameter_list|(
name|struct
name|alias_info
modifier|*
name|ai
parameter_list|)
block|{
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
name|worklist
operator|=
name|NULL
expr_stmt|;
name|VEC
argument_list|(
name|int
argument_list|,
name|heap
argument_list|)
operator|*
name|worklist2
operator|=
name|NULL
expr_stmt|;
name|set_initial_properties
argument_list|(
name|ai
argument_list|)
expr_stmt|;
name|init_transitive_clobber_worklist
argument_list|(
operator|&
name|worklist
argument_list|,
operator|&
name|worklist2
argument_list|)
expr_stmt|;
while|while
condition|(
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|worklist
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|tree
name|curr
init|=
name|VEC_pop
argument_list|(
name|tree
argument_list|,
name|worklist
argument_list|)
decl_stmt|;
name|int
name|reason
init|=
name|VEC_pop
argument_list|(
name|int
argument_list|,
name|worklist2
argument_list|)
decl_stmt|;
name|mark_call_clobbered
argument_list|(
name|curr
argument_list|,
name|reason
argument_list|)
expr_stmt|;
name|mark_aliases_call_clobbered
argument_list|(
name|curr
argument_list|,
operator|&
name|worklist
argument_list|,
operator|&
name|worklist2
argument_list|)
expr_stmt|;
block|}
name|VEC_free
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|worklist
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|int
argument_list|,
name|heap
argument_list|,
name|worklist2
argument_list|)
expr_stmt|;
name|compute_tag_properties
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Helper for recalculate_used_alone.  Return a conservatively correct    answer as to whether STMT may make a store on the LHS to SYM.  */
end_comment

begin_function
specifier|static
name|bool
name|lhs_may_store_to
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|tree
name|sym
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|tree
name|lhs
init|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|lhs
operator|=
name|get_base_address
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lhs
condition|)
return|return
name|false
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|SSA_NAME
condition|)
return|return
name|false
return|;
comment|/* We could do better here by looking at the type tag of LHS, but it      is unclear whether this is worth it. */
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Recalculate the used_alone information for SMTs . */
end_comment

begin_function
name|void
name|recalculate_used_alone
parameter_list|(
name|void
parameter_list|)
block|{
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
name|calls
operator|=
name|NULL
expr_stmt|;
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|tree
name|stmt
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|referenced_var_iterator
name|rvi
decl_stmt|;
name|tree
name|var
decl_stmt|;
comment|/* First, reset all the SMT used alone bits to zero.  */
name|updating_used_alone
operator|=
name|true
expr_stmt|;
name|FOR_EACH_REFERENCED_VAR
argument_list|(
argument|var
argument_list|,
argument|rvi
argument_list|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|SYMBOL_MEMORY_TAG
condition|)
block|{
name|SMT_OLD_USED_ALONE
argument_list|(
name|var
argument_list|)
operator|=
name|SMT_USED_ALONE
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|SMT_USED_ALONE
argument_list|(
name|var
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Walk all the statements.      Calls get put into a list of statements to update, since we will      need to update operands on them if we make any changes.      If we see a bare use of a SMT anywhere in a real virtual use or virtual      def, mark the SMT as used alone, and for renaming.  */
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
block|{
name|bool
name|iscall
init|=
name|false
decl_stmt|;
name|ssa_op_iter
name|iter
decl_stmt|;
name|stmt
operator|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|CALL_EXPR
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|MODIFY_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CALL_EXPR
operator|)
condition|)
block|{
name|iscall
operator|=
name|true
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|calls
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
block|}
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|var
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_VUSE | SSA_OP_VIRTUAL_DEFS
argument_list|)
block|{
name|tree
name|svar
init|=
name|var
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|SSA_NAME
condition|)
name|svar
operator|=
name|SSA_NAME_VAR
argument_list|(
name|var
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|svar
argument_list|)
operator|==
name|SYMBOL_MEMORY_TAG
condition|)
block|{
comment|/* We only care about the LHS on calls.  */
if|if
condition|(
name|iscall
operator|&&
operator|!
name|lhs_may_store_to
argument_list|(
name|stmt
argument_list|,
name|svar
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|SMT_USED_ALONE
argument_list|(
name|svar
argument_list|)
condition|)
block|{
name|SMT_USED_ALONE
argument_list|(
name|svar
argument_list|)
operator|=
name|true
expr_stmt|;
comment|/* Only need to mark for renaming if it wasn't 			 used alone before.  */
if|if
condition|(
operator|!
name|SMT_OLD_USED_ALONE
argument_list|(
name|svar
argument_list|)
condition|)
name|mark_sym_for_renaming
argument_list|(
name|svar
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/* Update the operands on all the calls we saw.  */
if|if
condition|(
name|calls
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
name|calls
argument_list|,
name|i
argument_list|,
name|stmt
argument_list|)
condition|;
name|i
operator|++
control|)
name|update_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
comment|/* We need to mark SMT's that are no longer used for renaming so the      symbols go away, or else verification will be angry with us, even      though they are dead.  */
name|FOR_EACH_REFERENCED_VAR
argument_list|(
argument|var
argument_list|,
argument|rvi
argument_list|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|SYMBOL_MEMORY_TAG
condition|)
block|{
if|if
condition|(
name|SMT_OLD_USED_ALONE
argument_list|(
name|var
argument_list|)
operator|&&
operator|!
name|SMT_USED_ALONE
argument_list|(
name|var
argument_list|)
condition|)
name|mark_sym_for_renaming
argument_list|(
name|var
argument_list|)
expr_stmt|;
block|}
name|VEC_free
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|calls
argument_list|)
expr_stmt|;
name|updating_used_alone
operator|=
name|false
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute may-alias information for every variable referenced in function    FNDECL.     Alias analysis proceeds in 3 main phases:     1- Points-to and escape analysis.     This phase walks the use-def chains in the SSA web looking for three    things:  	* Assignments of the form P_i =&VAR 	* Assignments of the form P_i = malloc() 	* Pointers and ADDR_EXPR that escape the current function.     The concept of 'escaping' is the same one used in the Java world.  When    a pointer or an ADDR_EXPR escapes, it means that it has been exposed    outside of the current function.  So, assignment to global variables,    function arguments and returning a pointer are all escape sites, as are    conversions between pointers and integers.     This is where we are currently limited.  Since not everything is renamed    into SSA, we lose track of escape properties when a pointer is stashed    inside a field in a structure, for instance.  In those cases, we are    assuming that the pointer does escape.     We use escape analysis to determine whether a variable is    call-clobbered.  Simply put, if an ADDR_EXPR escapes, then the variable    is call-clobbered.  If a pointer P_i escapes, then all the variables    pointed-to by P_i (and its memory tag) also escape.     2- Compute flow-sensitive aliases     We have two classes of memory tags.  Memory tags associated with the    pointed-to data type of the pointers in the program.  These tags are    called "symbol memory tag" (SMT).  The other class are those associated    with SSA_NAMEs, called "name memory tag" (NMT). The basic idea is that    when adding operands for an INDIRECT_REF *P_i, we will first check    whether P_i has a name tag, if it does we use it, because that will have    more precise aliasing information.  Otherwise, we use the standard symbol    tag.     In this phase, we go through all the pointers we found in points-to    analysis and create alias sets for the name memory tags associated with    each pointer P_i.  If P_i escapes, we mark call-clobbered the variables    it points to and its tag.      3- Compute flow-insensitive aliases     This pass will compare the alias set of every symbol memory tag and    every addressable variable found in the program.  Given a symbol    memory tag SMT and an addressable variable V.  If the alias sets of    SMT and V conflict (as computed by may_alias_p), then V is marked    as an alias tag and added to the alias set of SMT.     For instance, consider the following function:  	    foo (int i) 	    { 	      int *p, a, b; 	     	      if (i> 10) 	        p =&a; 	      else 	        p =&b; 	     	      *p = 3; 	      a = b + 2; 	      return *p; 	    }     After aliasing analysis has finished, the symbol memory tag for pointer    'p' will have two aliases, namely variables 'a' and 'b'.  Every time    pointer 'p' is dereferenced, we want to mark the operation as a    potential reference to 'a' and 'b'.  	    foo (int i) 	    { 	      int *p, a, b;  	      if (i_2> 10) 		p_4 =&a; 	      else 		p_6 =&b; 	      # p_1 = PHI<p_4(1), p_6(2)>;  	      # a_7 = V_MAY_DEF<a_3>; 	      # b_8 = V_MAY_DEF<b_5>; 	      *p_1 = 3;  	      # a_9 = V_MAY_DEF<a_7> 	      # VUSE<b_8> 	      a_9 = b_8 + 2;  	      # VUSE<a_9>; 	      # VUSE<b_8>; 	      return *p_1; 	    }     In certain cases, the list of may aliases for a pointer may grow too    large.  This may cause an explosion in the number of virtual operands    inserted in the code.  Resulting in increased memory consumption and    compilation time.     When the number of virtual operands needed to represent aliased    loads and stores grows too large (configurable with @option{--param    max-aliased-vops}), alias sets are grouped to avoid severe    compile-time slow downs and memory consumption.  See group_aliases.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|compute_may_aliases
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|alias_info
modifier|*
name|ai
decl_stmt|;
name|memset
argument_list|(
operator|&
name|alias_stats
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|alias_stats
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize aliasing information.  */
name|ai
operator|=
name|init_alias_info
argument_list|()
expr_stmt|;
comment|/* For each pointer P_i, determine the sets of variables that P_i may      point-to.  For every addressable variable V, determine whether the      address of V escapes the current function, making V call-clobbered      (i.e., whether&V is stored in a global variable or if its passed as a      function call argument).  */
name|compute_points_to_sets
argument_list|(
name|ai
argument_list|)
expr_stmt|;
comment|/* Collect all pointers and addressable variables, compute alias sets,      create memory tags for pointers and promote variables whose address is      not needed anymore.  */
name|setup_pointers_and_addressables
argument_list|(
name|ai
argument_list|)
expr_stmt|;
comment|/* Compute flow-sensitive, points-to based aliasing for all the name      memory tags.  Note that this pass needs to be done before flow      insensitive analysis because it uses the points-to information      gathered before to mark call-clobbered symbol tags.  */
name|compute_flow_sensitive_aliasing
argument_list|(
name|ai
argument_list|)
expr_stmt|;
comment|/* Compute type-based flow-insensitive aliasing for all the type      memory tags.  */
name|compute_flow_insensitive_aliasing
argument_list|(
name|ai
argument_list|)
expr_stmt|;
comment|/* Compute call clobbering information.  */
name|compute_call_clobbered
argument_list|(
name|ai
argument_list|)
expr_stmt|;
comment|/* Determine if we need to enable alias grouping.  */
if|if
condition|(
name|ai
operator|->
name|total_alias_vops
operator|>=
name|MAX_ALIASED_VOPS
condition|)
name|group_aliases
argument_list|(
name|ai
argument_list|)
expr_stmt|;
comment|/* If the program has too many call-clobbered variables and/or function      calls, create .GLOBAL_VAR and use it to model call-clobbering      semantics at call sites.  This reduces the number of virtual operands      considerably, improving compile times at the expense of lost      aliasing precision.  */
name|maybe_create_global_var
argument_list|(
name|ai
argument_list|)
expr_stmt|;
comment|/* If the program contains ref-all pointers, finalize may-alias information      for them.  This pass needs to be run after call-clobbering information      has been computed.  */
if|if
condition|(
name|ai
operator|->
name|ref_all_symbol_mem_tag
condition|)
name|finalize_ref_all_pointers
argument_list|(
name|ai
argument_list|)
expr_stmt|;
comment|/* Debugging dumps.  */
if|if
condition|(
name|dump_file
condition|)
block|{
name|dump_referenced_vars
argument_list|(
name|dump_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_flags
operator|&
name|TDF_STATS
condition|)
name|dump_alias_stats
argument_list|(
name|dump_file
argument_list|)
expr_stmt|;
name|dump_points_to_info
argument_list|(
name|dump_file
argument_list|)
expr_stmt|;
name|dump_alias_info
argument_list|(
name|dump_file
argument_list|)
expr_stmt|;
block|}
comment|/* Report strict aliasing violations.  */
name|strict_aliasing_warning_backend
argument_list|()
expr_stmt|;
comment|/* Deallocate memory used by aliasing data structures.  */
name|delete_alias_info
argument_list|(
name|ai
argument_list|)
expr_stmt|;
name|updating_used_alone
operator|=
name|true
expr_stmt|;
block|{
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
block|{
name|update_stmt_if_modified
argument_list|(
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|recalculate_used_alone
argument_list|()
expr_stmt|;
name|updating_used_alone
operator|=
name|false
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_may_alias
init|=
block|{
literal|"alias"
block|,
comment|/* name */
name|NULL
block|,
comment|/* gate */
name|compute_may_aliases
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
name|TV_TREE_MAY_ALIAS
block|,
comment|/* tv_id */
name|PROP_cfg
operator||
name|PROP_ssa
block|,
comment|/* properties_required */
name|PROP_alias
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_dump_func
operator||
name|TODO_update_ssa
operator||
name|TODO_ggc_collect
operator||
name|TODO_verify_ssa
operator||
name|TODO_verify_stmts
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Data structure used to count the number of dereferences to PTR    inside an expression.  */
end_comment

begin_struct
struct|struct
name|count_ptr_d
block|{
name|tree
name|ptr
decl_stmt|;
name|unsigned
name|count
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Helper for count_uses_and_derefs.  Called by walk_tree to look for    (ALIGN/MISALIGNED_)INDIRECT_REF nodes for the pointer passed in DATA.  */
end_comment

begin_function
specifier|static
name|tree
name|count_ptr_derefs
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|walk_subtrees
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|count_ptr_d
modifier|*
name|count_p
init|=
operator|(
expr|struct
name|count_ptr_d
operator|*
operator|)
name|data
decl_stmt|;
comment|/* Do not walk inside ADDR_EXPR nodes.  In the expression&ptr->fld,      pointer 'ptr' is *not* dereferenced, it is simply used to compute      the address of 'fld' as 'ptr + offsetof(fld)'.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|tp
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|INDIRECT_REF_P
argument_list|(
operator|*
name|tp
argument_list|)
operator|&&
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
literal|0
argument_list|)
operator|==
name|count_p
operator|->
name|ptr
condition|)
name|count_p
operator|->
name|count
operator|++
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Count the number of direct and indirect uses for pointer PTR in    statement STMT.  The two counts are stored in *NUM_USES_P and    *NUM_DEREFS_P respectively.  *IS_STORE_P is set to 'true' if at    least one of those dereferences is a store operation.  */
end_comment

begin_function
name|void
name|count_uses_and_derefs
parameter_list|(
name|tree
name|ptr
parameter_list|,
name|tree
name|stmt
parameter_list|,
name|unsigned
modifier|*
name|num_uses_p
parameter_list|,
name|unsigned
modifier|*
name|num_derefs_p
parameter_list|,
name|bool
modifier|*
name|is_store
parameter_list|)
block|{
name|ssa_op_iter
name|i
decl_stmt|;
name|tree
name|use
decl_stmt|;
operator|*
name|num_uses_p
operator|=
literal|0
expr_stmt|;
operator|*
name|num_derefs_p
operator|=
literal|0
expr_stmt|;
operator|*
name|is_store
operator|=
name|false
expr_stmt|;
comment|/* Find out the total number of uses of PTR in STMT.  */
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|use
argument_list|,
argument|stmt
argument_list|,
argument|i
argument_list|,
argument|SSA_OP_USE
argument_list|)
if|if
condition|(
name|use
operator|==
name|ptr
condition|)
operator|(
operator|*
name|num_uses_p
operator|)
operator|++
expr_stmt|;
comment|/* Now count the number of indirect references to PTR.  This is      truly awful, but we don't have much choice.  There are no parent      pointers inside INDIRECT_REFs, so an expression like      '*x_1 = foo (x_1, *x_1)' needs to be traversed piece by piece to      find all the indirect and direct uses of x_1 inside.  The only      shortcut we can take is the fact that GIMPLE only allows      INDIRECT_REFs inside the expressions below.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|MODIFY_EXPR
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|RETURN_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MODIFY_EXPR
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|ASM_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|CALL_EXPR
condition|)
block|{
name|tree
name|lhs
decl_stmt|,
name|rhs
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|MODIFY_EXPR
condition|)
block|{
name|lhs
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|RETURN_EXPR
condition|)
block|{
name|tree
name|e
init|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|lhs
operator|=
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|ASM_EXPR
condition|)
block|{
name|lhs
operator|=
name|ASM_OUTPUTS
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|rhs
operator|=
name|ASM_INPUTS
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lhs
operator|=
name|NULL_TREE
expr_stmt|;
name|rhs
operator|=
name|stmt
expr_stmt|;
block|}
if|if
condition|(
name|lhs
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|TREE_LIST
operator|||
name|EXPR_P
argument_list|(
name|lhs
argument_list|)
operator|)
condition|)
block|{
name|struct
name|count_ptr_d
name|count
decl_stmt|;
name|count
operator|.
name|ptr
operator|=
name|ptr
expr_stmt|;
name|count
operator|.
name|count
operator|=
literal|0
expr_stmt|;
name|walk_tree
argument_list|(
operator|&
name|lhs
argument_list|,
name|count_ptr_derefs
argument_list|,
operator|&
name|count
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|is_store
operator|=
name|true
expr_stmt|;
operator|*
name|num_derefs_p
operator|=
name|count
operator|.
name|count
expr_stmt|;
block|}
if|if
condition|(
name|rhs
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|TREE_LIST
operator|||
name|EXPR_P
argument_list|(
name|rhs
argument_list|)
operator|)
condition|)
block|{
name|struct
name|count_ptr_d
name|count
decl_stmt|;
name|count
operator|.
name|ptr
operator|=
name|ptr
expr_stmt|;
name|count
operator|.
name|count
operator|=
literal|0
expr_stmt|;
name|walk_tree
argument_list|(
operator|&
name|rhs
argument_list|,
name|count_ptr_derefs
argument_list|,
operator|&
name|count
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|num_derefs_p
operator|+=
name|count
operator|.
name|count
expr_stmt|;
block|}
block|}
name|gcc_assert
argument_list|(
operator|*
name|num_uses_p
operator|>=
operator|*
name|num_derefs_p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize the data structures used for alias analysis.  */
end_comment

begin_function
specifier|static
name|struct
name|alias_info
modifier|*
name|init_alias_info
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|alias_info
modifier|*
name|ai
decl_stmt|;
name|referenced_var_iterator
name|rvi
decl_stmt|;
name|tree
name|var
decl_stmt|;
name|bitmap_obstack_initialize
argument_list|(
operator|&
name|alias_obstack
argument_list|)
expr_stmt|;
name|ai
operator|=
name|XCNEW
argument_list|(
expr|struct
name|alias_info
argument_list|)
expr_stmt|;
name|ai
operator|->
name|ssa_names_visited
operator|=
name|sbitmap_alloc
argument_list|(
name|num_ssa_names
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|ai
operator|->
name|ssa_names_visited
argument_list|)
expr_stmt|;
name|ai
operator|->
name|processed_ptrs
operator|=
name|VEC_alloc
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|ai
operator|->
name|written_vars
operator|=
name|BITMAP_ALLOC
argument_list|(
operator|&
name|alias_obstack
argument_list|)
expr_stmt|;
name|ai
operator|->
name|dereferenced_ptrs_store
operator|=
name|BITMAP_ALLOC
argument_list|(
operator|&
name|alias_obstack
argument_list|)
expr_stmt|;
name|ai
operator|->
name|dereferenced_ptrs_load
operator|=
name|BITMAP_ALLOC
argument_list|(
operator|&
name|alias_obstack
argument_list|)
expr_stmt|;
comment|/* If aliases have been computed before, clear existing information.  */
if|if
condition|(
name|aliases_computed_p
condition|)
block|{
name|unsigned
name|i
decl_stmt|;
comment|/* Similarly, clear the set of addressable variables.  In this 	 case, we can just clear the set because addressability is 	 only computed here.  */
name|bitmap_clear
argument_list|(
name|addressable_vars
argument_list|)
expr_stmt|;
comment|/* Clear flow-insensitive alias information from each symbol.  */
name|FOR_EACH_REFERENCED_VAR
argument_list|(
argument|var
argument_list|,
argument|rvi
argument_list|)
block|{
name|var_ann_t
name|ann
init|=
name|var_ann
argument_list|(
name|var
argument_list|)
decl_stmt|;
name|ann
operator|->
name|is_aliased
operator|=
literal|0
expr_stmt|;
name|ann
operator|->
name|may_aliases
operator|=
name|NULL
expr_stmt|;
name|NUM_REFERENCES_CLEAR
argument_list|(
name|ann
argument_list|)
expr_stmt|;
comment|/* Since we are about to re-discover call-clobbered 	     variables, clear the call-clobbered flag.  Variables that 	     are intrinsically call-clobbered (globals, local statics, 	     etc) will not be marked by the aliasing code, so we can't 	     remove them from CALL_CLOBBERED_VARS.    	     NB: STRUCT_FIELDS are still call clobbered if they are for 	     a global variable, so we *don't* clear their call clobberedness 	     just because they are tags, though we will clear it if they 	     aren't for global variables.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|NAME_MEMORY_TAG
operator|||
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|SYMBOL_MEMORY_TAG
operator|||
operator|!
name|is_global_var
argument_list|(
name|var
argument_list|)
condition|)
name|clear_call_clobbered
argument_list|(
name|var
argument_list|)
expr_stmt|;
block|}
comment|/* Clear flow-sensitive points-to information from each SSA name.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|num_ssa_names
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|name
init|=
name|ssa_name
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|name
operator|||
operator|!
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|name
argument_list|)
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|SSA_NAME_PTR_INFO
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|struct
name|ptr_info_def
modifier|*
name|pi
init|=
name|SSA_NAME_PTR_INFO
argument_list|(
name|name
argument_list|)
decl_stmt|;
comment|/* Clear all the flags but keep the name tag to 		 avoid creating new temporaries unnecessarily.  If 		 this pointer is found to point to a subset or 		 superset of its former points-to set, then a new 		 tag will need to be created in create_name_tags.  */
name|pi
operator|->
name|pt_anything
operator|=
literal|0
expr_stmt|;
name|pi
operator|->
name|pt_null
operator|=
literal|0
expr_stmt|;
name|pi
operator|->
name|value_escapes_p
operator|=
literal|0
expr_stmt|;
name|pi
operator|->
name|is_dereferenced
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|pt_vars
condition|)
name|bitmap_clear
argument_list|(
name|pi
operator|->
name|pt_vars
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Next time, we will need to reset alias information.  */
name|aliases_computed_p
operator|=
name|true
expr_stmt|;
return|return
name|ai
return|;
block|}
end_function

begin_comment
comment|/* Deallocate memory used by alias analysis.  */
end_comment

begin_function
specifier|static
name|void
name|delete_alias_info
parameter_list|(
name|struct
name|alias_info
modifier|*
name|ai
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|referenced_var_iterator
name|rvi
decl_stmt|;
name|tree
name|var
decl_stmt|;
name|sbitmap_free
argument_list|(
name|ai
operator|->
name|ssa_names_visited
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|ai
operator|->
name|processed_ptrs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ai
operator|->
name|num_addressable_vars
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|ai
operator|->
name|addressable_vars
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|FOR_EACH_REFERENCED_VAR
argument_list|(
argument|var
argument_list|,
argument|rvi
argument_list|)
block|{
name|var_ann_t
name|ann
init|=
name|var_ann
argument_list|(
name|var
argument_list|)
decl_stmt|;
name|NUM_REFERENCES_CLEAR
argument_list|(
name|ann
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|ai
operator|->
name|addressable_vars
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ai
operator|->
name|num_pointers
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|ai
operator|->
name|pointers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ai
operator|->
name|pointers
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|ai
operator|->
name|written_vars
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|ai
operator|->
name|dereferenced_ptrs_store
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|ai
operator|->
name|dereferenced_ptrs_load
argument_list|)
expr_stmt|;
name|bitmap_obstack_release
argument_list|(
operator|&
name|alias_obstack
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ai
argument_list|)
expr_stmt|;
name|delete_points_to_sets
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Used for hashing to identify pointer infos with identical    pt_vars bitmaps.  */
end_comment

begin_function
specifier|static
name|int
name|eq_ptr_info
parameter_list|(
specifier|const
name|void
modifier|*
name|p1
parameter_list|,
specifier|const
name|void
modifier|*
name|p2
parameter_list|)
block|{
specifier|const
name|struct
name|ptr_info_def
modifier|*
name|n1
init|=
operator|(
specifier|const
expr|struct
name|ptr_info_def
operator|*
operator|)
name|p1
decl_stmt|;
specifier|const
name|struct
name|ptr_info_def
modifier|*
name|n2
init|=
operator|(
specifier|const
expr|struct
name|ptr_info_def
operator|*
operator|)
name|p2
decl_stmt|;
return|return
name|bitmap_equal_p
argument_list|(
name|n1
operator|->
name|pt_vars
argument_list|,
name|n2
operator|->
name|pt_vars
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|hashval_t
name|ptr_info_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
specifier|const
name|struct
name|ptr_info_def
modifier|*
name|n
init|=
operator|(
specifier|const
expr|struct
name|ptr_info_def
operator|*
operator|)
name|p
decl_stmt|;
return|return
name|bitmap_hash
argument_list|(
name|n
operator|->
name|pt_vars
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Create name tags for all the pointers that have been dereferenced.    We only create a name tag for a pointer P if P is found to point to    a set of variables (so that we can alias them to *P) or if it is    the result of a call to malloc (which means that P cannot point to    anything else nor alias any other variable).     If two pointers P and Q point to the same set of variables, they    are assigned the same name tag.  */
end_comment

begin_function
specifier|static
name|void
name|create_name_tags
parameter_list|(
name|void
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
name|with_ptvars
operator|=
name|NULL
expr_stmt|;
name|tree
name|ptr
decl_stmt|;
name|htab_t
name|ptr_hash
decl_stmt|;
comment|/* Collect the list of pointers with a non-empty points to set.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|num_ssa_names
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|ptr
init|=
name|ssa_name
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|struct
name|ptr_info_def
modifier|*
name|pi
decl_stmt|;
if|if
condition|(
operator|!
name|ptr
operator|||
operator|!
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|ptr
argument_list|)
argument_list|)
operator|||
operator|!
name|SSA_NAME_PTR_INFO
argument_list|(
name|ptr
argument_list|)
condition|)
continue|continue;
name|pi
operator|=
name|SSA_NAME_PTR_INFO
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|pt_anything
operator|||
operator|!
name|pi
operator|->
name|is_dereferenced
condition|)
block|{
comment|/* No name tags for pointers that have not been 	     dereferenced or point to an arbitrary location.  */
name|pi
operator|->
name|name_mem_tag
operator|=
name|NULL_TREE
expr_stmt|;
continue|continue;
block|}
comment|/* Set pt_anything on the pointers without pt_vars filled in so 	 that they are assigned a symbol tag.  */
if|if
condition|(
name|pi
operator|->
name|pt_vars
operator|&&
operator|!
name|bitmap_empty_p
argument_list|(
name|pi
operator|->
name|pt_vars
argument_list|)
condition|)
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|with_ptvars
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
else|else
name|set_pt_anything
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
comment|/* If we didn't find any pointers with pt_vars set, we're done.  */
if|if
condition|(
operator|!
name|with_ptvars
condition|)
return|return;
name|ptr_hash
operator|=
name|htab_create
argument_list|(
literal|10
argument_list|,
name|ptr_info_hash
argument_list|,
name|eq_ptr_info
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Now go through the pointers with pt_vars, and find a name tag      with the same pt_vars as this pointer, or create one if one      doesn't exist.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
name|with_ptvars
argument_list|,
name|i
argument_list|,
name|ptr
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ptr_info_def
modifier|*
name|pi
init|=
name|SSA_NAME_PTR_INFO
argument_list|(
name|ptr
argument_list|)
decl_stmt|;
name|tree
name|old_name_tag
init|=
name|pi
operator|->
name|name_mem_tag
decl_stmt|;
name|struct
name|ptr_info_def
modifier|*
modifier|*
name|slot
decl_stmt|;
comment|/* If PTR points to a set of variables, check if we don't 	 have another pointer Q with the same points-to set before 	 creating a tag.  If so, use Q's tag instead of creating a 	 new one. 	  	 This is important for not creating unnecessary symbols 	 and also for copy propagation.  If we ever need to 	 propagate PTR into Q or vice-versa, we would run into 	 problems if they both had different name tags because 	 they would have different SSA version numbers (which 	 would force us to take the name tags in and out of SSA).  */
name|slot
operator|=
operator|(
expr|struct
name|ptr_info_def
operator|*
operator|*
operator|)
name|htab_find_slot
argument_list|(
name|ptr_hash
argument_list|,
name|pi
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|slot
condition|)
name|pi
operator|->
name|name_mem_tag
operator|=
operator|(
operator|*
name|slot
operator|)
operator|->
name|name_mem_tag
expr_stmt|;
else|else
block|{
operator|*
name|slot
operator|=
name|pi
expr_stmt|;
comment|/* If we didn't find a pointer with the same points-to set 	     as PTR, create a new name tag if needed.  */
if|if
condition|(
name|pi
operator|->
name|name_mem_tag
operator|==
name|NULL_TREE
condition|)
name|pi
operator|->
name|name_mem_tag
operator|=
name|get_nmt_for
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
comment|/* If the new name tag computed for PTR is different than 	 the old name tag that it used to have, then the old tag 	 needs to be removed from the IL, so we mark it for 	 renaming.  */
if|if
condition|(
name|old_name_tag
operator|&&
name|old_name_tag
operator|!=
name|pi
operator|->
name|name_mem_tag
condition|)
name|mark_sym_for_renaming
argument_list|(
name|old_name_tag
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|pi
operator|->
name|name_mem_tag
argument_list|)
operator||=
name|TREE_THIS_VOLATILE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ptr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Mark the new name tag for renaming.  */
name|mark_sym_for_renaming
argument_list|(
name|pi
operator|->
name|name_mem_tag
argument_list|)
expr_stmt|;
block|}
name|htab_delete
argument_list|(
name|ptr_hash
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|with_ptvars
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* For every pointer P_i in AI->PROCESSED_PTRS, create may-alias sets for    the name memory tag (NMT) associated with P_i.  If P_i escapes, then its    name tag and the variables it points-to are call-clobbered.  Finally, if    P_i escapes and we could not determine where it points to, then all the    variables in the same alias set as *P_i are marked call-clobbered.  This    is necessary because we must assume that P_i may take the address of any    variable in the same alias set.  */
end_comment

begin_function
specifier|static
name|void
name|compute_flow_sensitive_aliasing
parameter_list|(
name|struct
name|alias_info
modifier|*
name|ai
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|tree
name|ptr
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
name|ai
operator|->
name|processed_ptrs
argument_list|,
name|i
argument_list|,
name|ptr
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|find_what_p_points_to
argument_list|(
name|ptr
argument_list|)
condition|)
name|set_pt_anything
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
name|create_name_tags
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
name|ai
operator|->
name|processed_ptrs
argument_list|,
name|i
argument_list|,
name|ptr
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|j
decl_stmt|;
name|struct
name|ptr_info_def
modifier|*
name|pi
init|=
name|SSA_NAME_PTR_INFO
argument_list|(
name|ptr
argument_list|)
decl_stmt|;
name|var_ann_t
name|v_ann
init|=
name|var_ann
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|ptr
argument_list|)
argument_list|)
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
comment|/* Set up aliasing information for PTR's name memory tag (if it has 	 one).  Note that only pointers that have been dereferenced will 	 have a name memory tag.  */
if|if
condition|(
name|pi
operator|->
name|name_mem_tag
operator|&&
name|pi
operator|->
name|pt_vars
condition|)
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|pi->pt_vars
argument_list|,
literal|0
argument_list|,
argument|j
argument_list|,
argument|bi
argument_list|)
block|{
name|add_may_alias
argument_list|(
name|pi
operator|->
name|name_mem_tag
argument_list|,
name|referenced_var
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
name|add_may_alias
argument_list|(
name|v_ann
operator|->
name|symbol_mem_tag
argument_list|,
name|referenced_var
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Compute type-based alias sets.  Traverse all the pointers and    addressable variables found in setup_pointers_and_addressables.        For every pointer P in AI->POINTERS and addressable variable V in    AI->ADDRESSABLE_VARS, add V to the may-alias sets of P's symbol    memory tag (SMT) if their alias sets conflict.  V is then marked as    an alias tag so that the operand scanner knows that statements    containing V have aliased operands.  */
end_comment

begin_function
specifier|static
name|void
name|compute_flow_insensitive_aliasing
parameter_list|(
name|struct
name|alias_info
modifier|*
name|ai
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
comment|/* Initialize counter for the total number of virtual operands that      aliasing will introduce.  When AI->TOTAL_ALIAS_VOPS goes beyond the      threshold set by --params max-alias-vops, we enable alias      grouping.  */
name|ai
operator|->
name|total_alias_vops
operator|=
literal|0
expr_stmt|;
comment|/* For every pointer P, determine which addressable variables may alias      with P's symbol memory tag.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ai
operator|->
name|num_pointers
condition|;
name|i
operator|++
control|)
block|{
name|size_t
name|j
decl_stmt|;
name|struct
name|alias_map_d
modifier|*
name|p_map
init|=
name|ai
operator|->
name|pointers
index|[
name|i
index|]
decl_stmt|;
name|tree
name|tag
init|=
name|var_ann
argument_list|(
name|p_map
operator|->
name|var
argument_list|)
operator|->
name|symbol_mem_tag
decl_stmt|;
name|var_ann_t
name|tag_ann
init|=
name|var_ann
argument_list|(
name|tag
argument_list|)
decl_stmt|;
name|tree
name|var
decl_stmt|;
comment|/* Call-clobbering information is not finalized yet at this point.  */
if|if
condition|(
name|PTR_IS_REF_ALL
argument_list|(
name|p_map
operator|->
name|var
argument_list|)
condition|)
continue|continue;
name|p_map
operator|->
name|total_alias_vops
operator|=
literal|0
expr_stmt|;
name|p_map
operator|->
name|may_aliases
operator|=
name|BITMAP_ALLOC
argument_list|(
operator|&
name|alias_obstack
argument_list|)
expr_stmt|;
comment|/* Add any pre-existing may_aliases to the bitmap used to represent 	 TAG's alias set in case we need to group aliases.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
name|tag_ann
operator|->
name|may_aliases
argument_list|,
name|j
argument_list|,
name|var
argument_list|)
condition|;
operator|++
name|j
control|)
name|bitmap_set_bit
argument_list|(
name|p_map
operator|->
name|may_aliases
argument_list|,
name|DECL_UID
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ai
operator|->
name|num_addressable_vars
condition|;
name|j
operator|++
control|)
block|{
name|struct
name|alias_map_d
modifier|*
name|v_map
decl_stmt|;
name|var_ann_t
name|v_ann
decl_stmt|;
name|bool
name|tag_stored_p
decl_stmt|,
name|var_stored_p
decl_stmt|;
name|v_map
operator|=
name|ai
operator|->
name|addressable_vars
index|[
name|j
index|]
expr_stmt|;
name|var
operator|=
name|v_map
operator|->
name|var
expr_stmt|;
name|v_ann
operator|=
name|var_ann
argument_list|(
name|var
argument_list|)
expr_stmt|;
comment|/* Skip memory tags and variables that have never been 	     written to.  We also need to check if the variables are 	     call-clobbered because they may be overwritten by 	     function calls.  	     Note this is effectively random accessing elements in 	     the sparse bitset, which can be highly inefficient. 	     So we first check the call_clobbered status of the 	     tag and variable before querying the bitmap.  */
name|tag_stored_p
operator|=
name|is_call_clobbered
argument_list|(
name|tag
argument_list|)
operator|||
name|bitmap_bit_p
argument_list|(
name|ai
operator|->
name|written_vars
argument_list|,
name|DECL_UID
argument_list|(
name|tag
argument_list|)
argument_list|)
expr_stmt|;
name|var_stored_p
operator|=
name|is_call_clobbered
argument_list|(
name|var
argument_list|)
operator|||
name|bitmap_bit_p
argument_list|(
name|ai
operator|->
name|written_vars
argument_list|,
name|DECL_UID
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tag_stored_p
operator|&&
operator|!
name|var_stored_p
condition|)
continue|continue;
if|if
condition|(
name|may_alias_p
argument_list|(
name|p_map
operator|->
name|var
argument_list|,
name|p_map
operator|->
name|set
argument_list|,
name|var
argument_list|,
name|v_map
operator|->
name|set
argument_list|,
name|false
argument_list|)
condition|)
block|{
name|size_t
name|num_tag_refs
decl_stmt|,
name|num_var_refs
decl_stmt|;
name|num_tag_refs
operator|=
name|NUM_REFERENCES
argument_list|(
name|tag_ann
argument_list|)
expr_stmt|;
name|num_var_refs
operator|=
name|NUM_REFERENCES
argument_list|(
name|v_ann
argument_list|)
expr_stmt|;
comment|/* Add VAR to TAG's may-aliases set.  */
comment|/* We should never have a var with subvars here, because 	         they shouldn't get into the set of addressable vars */
name|gcc_assert
argument_list|(
operator|!
name|var_can_have_subvars
argument_list|(
name|var
argument_list|)
operator|||
name|get_subvars_for_var
argument_list|(
name|var
argument_list|)
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|add_may_alias
argument_list|(
name|tag
argument_list|,
name|var
argument_list|)
expr_stmt|;
comment|/* Update the bitmap used to represent TAG's alias set 		 in case we need to group aliases.  */
name|bitmap_set_bit
argument_list|(
name|p_map
operator|->
name|may_aliases
argument_list|,
name|DECL_UID
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Update the total number of virtual operands due to 		 aliasing.  Since we are adding one more alias to TAG's 		 may-aliases set, the total number of virtual operands due 		 to aliasing will be increased by the number of references 		 made to VAR and TAG (every reference to TAG will also 		 count as a reference to VAR).  */
name|ai
operator|->
name|total_alias_vops
operator|+=
operator|(
name|num_var_refs
operator|+
name|num_tag_refs
operator|)
expr_stmt|;
name|p_map
operator|->
name|total_alias_vops
operator|+=
operator|(
name|num_var_refs
operator|+
name|num_tag_refs
operator|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Since this analysis is based exclusively on symbols, it fails to      handle cases where two pointers P and Q have different memory      tags with conflicting alias set numbers but no aliased symbols in      common.       For example, suppose that we have two memory tags SMT.1 and SMT.2      such that            		may-aliases (SMT.1) = { a } 		may-aliases (SMT.2) = { b }       and the alias set number of SMT.1 conflicts with that of SMT.2.      Since they don't have symbols in common, loads and stores from      SMT.1 and SMT.2 will seem independent of each other, which will      lead to the optimizers making invalid transformations (see      testsuite/gcc.c-torture/execute/pr15262-[12].c).       To avoid this problem, we do a final traversal of AI->POINTERS      looking for pairs of pointers that have no aliased symbols in      common and yet have conflicting alias set numbers.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ai
operator|->
name|num_pointers
condition|;
name|i
operator|++
control|)
block|{
name|size_t
name|j
decl_stmt|;
name|struct
name|alias_map_d
modifier|*
name|p_map1
init|=
name|ai
operator|->
name|pointers
index|[
name|i
index|]
decl_stmt|;
name|tree
name|tag1
init|=
name|var_ann
argument_list|(
name|p_map1
operator|->
name|var
argument_list|)
operator|->
name|symbol_mem_tag
decl_stmt|;
name|bitmap
name|may_aliases1
init|=
name|p_map1
operator|->
name|may_aliases
decl_stmt|;
if|if
condition|(
name|PTR_IS_REF_ALL
argument_list|(
name|p_map1
operator|->
name|var
argument_list|)
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|ai
operator|->
name|num_pointers
condition|;
name|j
operator|++
control|)
block|{
name|struct
name|alias_map_d
modifier|*
name|p_map2
init|=
name|ai
operator|->
name|pointers
index|[
name|j
index|]
decl_stmt|;
name|tree
name|tag2
init|=
name|var_ann
argument_list|(
name|p_map2
operator|->
name|var
argument_list|)
operator|->
name|symbol_mem_tag
decl_stmt|;
name|bitmap
name|may_aliases2
init|=
name|p_map2
operator|->
name|may_aliases
decl_stmt|;
if|if
condition|(
name|PTR_IS_REF_ALL
argument_list|(
name|p_map2
operator|->
name|var
argument_list|)
condition|)
continue|continue;
comment|/* If the pointers may not point to each other, do nothing.  */
if|if
condition|(
operator|!
name|may_alias_p
argument_list|(
name|p_map1
operator|->
name|var
argument_list|,
name|p_map1
operator|->
name|set
argument_list|,
name|tag2
argument_list|,
name|p_map2
operator|->
name|set
argument_list|,
name|true
argument_list|)
condition|)
continue|continue;
comment|/* The two pointers may alias each other.  If they already have 	     symbols in common, do nothing.  */
if|if
condition|(
name|bitmap_intersect_p
argument_list|(
name|may_aliases1
argument_list|,
name|may_aliases2
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|bitmap_empty_p
argument_list|(
name|may_aliases2
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|k
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
comment|/* Add all the aliases for TAG2 into TAG1's alias set. 		 FIXME, update grouping heuristic counters.  */
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|may_aliases2
argument_list|,
literal|0
argument_list|,
argument|k
argument_list|,
argument|bi
argument_list|)
name|add_may_alias
argument_list|(
name|tag1
argument_list|,
name|referenced_var
argument_list|(
name|k
argument_list|)
argument_list|)
expr_stmt|;
name|bitmap_ior_into
argument_list|(
name|may_aliases1
argument_list|,
name|may_aliases2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Since TAG2 does not have any aliases of its own, add 		 TAG2 itself to the alias set of TAG1.  */
name|add_may_alias
argument_list|(
name|tag1
argument_list|,
name|tag2
argument_list|)
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|may_aliases1
argument_list|,
name|DECL_UID
argument_list|(
name|tag2
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n%s: Total number of aliased vops: %ld\n"
argument_list|,
name|get_name
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
name|ai
operator|->
name|total_alias_vops
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finalize may-alias information for ref-all pointers.  Traverse all    the addressable variables found in setup_pointers_and_addressables.     If flow-sensitive alias analysis has attached a name memory tag to    a ref-all pointer, we will use it for the dereferences because that    will have more precise aliasing information.  But if there is no    name tag, we will use a special symbol tag that aliases all the    call-clobbered addressable variables.  */
end_comment

begin_function
specifier|static
name|void
name|finalize_ref_all_pointers
parameter_list|(
name|struct
name|alias_info
modifier|*
name|ai
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
if|if
condition|(
name|global_var
condition|)
name|add_may_alias
argument_list|(
name|ai
operator|->
name|ref_all_symbol_mem_tag
argument_list|,
name|global_var
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* First add the real call-clobbered variables.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ai
operator|->
name|num_addressable_vars
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|var
init|=
name|ai
operator|->
name|addressable_vars
index|[
name|i
index|]
operator|->
name|var
decl_stmt|;
if|if
condition|(
name|is_call_clobbered
argument_list|(
name|var
argument_list|)
condition|)
name|add_may_alias
argument_list|(
name|ai
operator|->
name|ref_all_symbol_mem_tag
argument_list|,
name|var
argument_list|)
expr_stmt|;
block|}
comment|/* Then add the call-clobbered pointer memory tags.  See 	 compute_flow_insensitive_aliasing for the rationale.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ai
operator|->
name|num_pointers
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|ptr
init|=
name|ai
operator|->
name|pointers
index|[
name|i
index|]
operator|->
name|var
decl_stmt|,
name|tag
decl_stmt|;
if|if
condition|(
name|PTR_IS_REF_ALL
argument_list|(
name|ptr
argument_list|)
condition|)
continue|continue;
name|tag
operator|=
name|var_ann
argument_list|(
name|ptr
argument_list|)
operator|->
name|symbol_mem_tag
expr_stmt|;
if|if
condition|(
name|is_call_clobbered
argument_list|(
name|tag
argument_list|)
condition|)
name|add_may_alias
argument_list|(
name|ai
operator|->
name|ref_all_symbol_mem_tag
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Comparison function for qsort used in group_aliases.  */
end_comment

begin_function
specifier|static
name|int
name|total_alias_vops_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|,
specifier|const
name|void
modifier|*
name|q
parameter_list|)
block|{
specifier|const
name|struct
name|alias_map_d
modifier|*
modifier|*
name|p1
init|=
operator|(
specifier|const
expr|struct
name|alias_map_d
operator|*
operator|*
operator|)
name|p
decl_stmt|;
specifier|const
name|struct
name|alias_map_d
modifier|*
modifier|*
name|p2
init|=
operator|(
specifier|const
expr|struct
name|alias_map_d
operator|*
operator|*
operator|)
name|q
decl_stmt|;
name|long
name|n1
init|=
operator|(
operator|*
name|p1
operator|)
operator|->
name|total_alias_vops
decl_stmt|;
name|long
name|n2
init|=
operator|(
operator|*
name|p2
operator|)
operator|->
name|total_alias_vops
decl_stmt|;
comment|/* We want to sort in descending order.  */
return|return
operator|(
name|n1
operator|>
name|n2
condition|?
operator|-
literal|1
else|:
operator|(
name|n1
operator|==
name|n2
operator|)
condition|?
literal|0
else|:
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Group all the aliases for TAG to make TAG represent all the    variables in its alias set.  Update the total number    of virtual operands due to aliasing (AI->TOTAL_ALIAS_VOPS).  This    function will make TAG be the unique alias tag for all the    variables in its may-aliases.  So, given:     	may-aliases(TAG) = { V1, V2, V3 }     This function will group the variables into:     	may-aliases(V1) = { TAG } 	may-aliases(V2) = { TAG } 	may-aliases(V2) = { TAG }  */
end_comment

begin_function
specifier|static
name|void
name|group_aliases_into
parameter_list|(
name|tree
name|tag
parameter_list|,
name|bitmap
name|tag_aliases
parameter_list|,
name|struct
name|alias_info
modifier|*
name|ai
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|var_ann_t
name|tag_ann
init|=
name|var_ann
argument_list|(
name|tag
argument_list|)
decl_stmt|;
name|size_t
name|num_tag_refs
init|=
name|NUM_REFERENCES
argument_list|(
name|tag_ann
argument_list|)
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|tag_aliases
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
name|tree
name|var
init|=
name|referenced_var
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|var_ann_t
name|ann
init|=
name|var_ann
argument_list|(
name|var
argument_list|)
decl_stmt|;
comment|/* Make TAG the unique alias of VAR.  */
name|ann
operator|->
name|is_aliased
operator|=
literal|0
expr_stmt|;
name|ann
operator|->
name|may_aliases
operator|=
name|NULL
expr_stmt|;
comment|/* Note that VAR and TAG may be the same if the function has no 	 addressable variables (see the discussion at the end of 	 setup_pointers_and_addressables).  */
if|if
condition|(
name|var
operator|!=
name|tag
condition|)
name|add_may_alias
argument_list|(
name|var
argument_list|,
name|tag
argument_list|)
expr_stmt|;
comment|/* Reduce total number of virtual operands contributed 	 by TAG on behalf of VAR.  Notice that the references to VAR 	 itself won't be removed.  We will merely replace them with 	 references to TAG.  */
name|ai
operator|->
name|total_alias_vops
operator|-=
name|num_tag_refs
expr_stmt|;
block|}
comment|/* We have reduced the number of virtual operands that TAG makes on      behalf of all the variables formerly aliased with it.  However,      we have also "removed" all the virtual operands for TAG itself,      so we add them back.  */
name|ai
operator|->
name|total_alias_vops
operator|+=
name|num_tag_refs
expr_stmt|;
comment|/* TAG no longer has any aliases.  */
name|tag_ann
operator|->
name|may_aliases
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Group may-aliases sets to reduce the number of virtual operands due    to aliasing.       1- Sort the list of pointers in decreasing number of contributed 	virtual operands.       2- Take the first entry in AI->POINTERS and revert the role of 	the memory tag and its aliases.  Usually, whenever an aliased 	variable Vi is found to alias with a memory tag T, we add Vi 	to the may-aliases set for T.  Meaning that after alias 	analysis, we will have:  		may-aliases(T) = { V1, V2, V3, ..., Vn }  	This means that every statement that references T, will get 'n' 	virtual operands for each of the Vi tags.  But, when alias 	grouping is enabled, we make T an alias tag and add it to the 	alias set of all the Vi variables:  		may-aliases(V1) = { T } 		may-aliases(V2) = { T } 		... 		may-aliases(Vn) = { T }  	This has two effects: (a) statements referencing T will only get 	a single virtual operand, and, (b) all the variables Vi will now 	appear to alias each other.  So, we lose alias precision to 	improve compile time.  But, in theory, a program with such a high 	level of aliasing should not be very optimizable in the first 	place.       3- Since variables may be in the alias set of more than one 	memory tag, the grouping done in step (2) needs to be extended 	to all the memory tags that have a non-empty intersection with 	the may-aliases set of tag T.  For instance, if we originally 	had these may-aliases sets:  		may-aliases(T) = { V1, V2, V3 } 		may-aliases(R) = { V2, V4 }  	In step (2) we would have reverted the aliases for T as:  		may-aliases(V1) = { T } 		may-aliases(V2) = { T } 		may-aliases(V3) = { T }  	But note that now V2 is no longer aliased with R.  We could 	add R to may-aliases(V2), but we are in the process of 	grouping aliases to reduce virtual operands so what we do is 	add V4 to the grouping to obtain:  		may-aliases(V1) = { T } 		may-aliases(V2) = { T } 		may-aliases(V3) = { T } 		may-aliases(V4) = { T }       4- If the total number of virtual operands due to aliasing is 	still above the threshold set by max-alias-vops, go back to (2).  */
end_comment

begin_function
specifier|static
name|void
name|group_aliases
parameter_list|(
name|struct
name|alias_info
modifier|*
name|ai
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|tree
name|ptr
decl_stmt|;
comment|/* Sort the POINTERS array in descending order of contributed      virtual operands.  */
name|qsort
argument_list|(
name|ai
operator|->
name|pointers
argument_list|,
name|ai
operator|->
name|num_pointers
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|alias_map_d
operator|*
argument_list|)
argument_list|,
name|total_alias_vops_cmp
argument_list|)
expr_stmt|;
comment|/* For every pointer in AI->POINTERS, reverse the roles of its tag      and the tag's may-aliases set.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ai
operator|->
name|num_pointers
condition|;
name|i
operator|++
control|)
block|{
name|size_t
name|j
decl_stmt|;
name|tree
name|tag1
init|=
name|var_ann
argument_list|(
name|ai
operator|->
name|pointers
index|[
name|i
index|]
operator|->
name|var
argument_list|)
operator|->
name|symbol_mem_tag
decl_stmt|;
name|bitmap
name|tag1_aliases
init|=
name|ai
operator|->
name|pointers
index|[
name|i
index|]
operator|->
name|may_aliases
decl_stmt|;
comment|/* Skip tags that have been grouped already.  */
if|if
condition|(
name|ai
operator|->
name|pointers
index|[
name|i
index|]
operator|->
name|grouped_p
condition|)
continue|continue;
comment|/* See if TAG1 had any aliases in common with other symbol tags. 	 If we find a TAG2 with common aliases with TAG1, add TAG2's 	 aliases into TAG1.  */
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|ai
operator|->
name|num_pointers
condition|;
name|j
operator|++
control|)
block|{
name|bitmap
name|tag2_aliases
init|=
name|ai
operator|->
name|pointers
index|[
name|j
index|]
operator|->
name|may_aliases
decl_stmt|;
if|if
condition|(
name|bitmap_intersect_p
argument_list|(
name|tag1_aliases
argument_list|,
name|tag2_aliases
argument_list|)
condition|)
block|{
name|tree
name|tag2
init|=
name|var_ann
argument_list|(
name|ai
operator|->
name|pointers
index|[
name|j
index|]
operator|->
name|var
argument_list|)
operator|->
name|symbol_mem_tag
decl_stmt|;
name|bitmap_ior_into
argument_list|(
name|tag1_aliases
argument_list|,
name|tag2_aliases
argument_list|)
expr_stmt|;
comment|/* TAG2 does not need its aliases anymore.  */
name|bitmap_clear
argument_list|(
name|tag2_aliases
argument_list|)
expr_stmt|;
name|var_ann
argument_list|(
name|tag2
argument_list|)
operator|->
name|may_aliases
operator|=
name|NULL
expr_stmt|;
comment|/* TAG1 is the unique alias of TAG2.  */
name|add_may_alias
argument_list|(
name|tag2
argument_list|,
name|tag1
argument_list|)
expr_stmt|;
name|ai
operator|->
name|pointers
index|[
name|j
index|]
operator|->
name|grouped_p
operator|=
name|true
expr_stmt|;
block|}
block|}
comment|/* Now group all the aliases we collected into TAG1.  */
name|group_aliases_into
argument_list|(
name|tag1
argument_list|,
name|tag1_aliases
argument_list|,
name|ai
argument_list|)
expr_stmt|;
comment|/* If we've reduced total number of virtual operands below the 	 threshold, stop.  */
if|if
condition|(
name|ai
operator|->
name|total_alias_vops
operator|<
name|MAX_ALIASED_VOPS
condition|)
break|break;
block|}
comment|/* Finally, all the variables that have been grouped cannot be in      the may-alias set of name memory tags.  Suppose that we have      grouped the aliases in this code so that may-aliases(a) = SMT.20       	p_5 =&a; 	... 	# a_9 = V_MAY_DEF<a_8> 	p_5->field = 0 	... Several modifications to SMT.20 ...  	# VUSE<a_9> 	x_30 = p_5->field       Since p_5 points to 'a', the optimizers will try to propagate 0      into p_5->field, but that is wrong because there have been      modifications to 'SMT.20' in between.  To prevent this we have to      replace 'a' with 'SMT.20' in the name tag of p_5.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
name|ai
operator|->
name|processed_ptrs
argument_list|,
name|i
argument_list|,
name|ptr
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|size_t
name|j
decl_stmt|;
name|tree
name|name_tag
init|=
name|SSA_NAME_PTR_INFO
argument_list|(
name|ptr
argument_list|)
operator|->
name|name_mem_tag
decl_stmt|;
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
name|aliases
expr_stmt|;
name|tree
name|alias
decl_stmt|;
if|if
condition|(
name|name_tag
operator|==
name|NULL_TREE
condition|)
continue|continue;
name|aliases
operator|=
name|var_ann
argument_list|(
name|name_tag
argument_list|)
operator|->
name|may_aliases
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
name|aliases
argument_list|,
name|j
argument_list|,
name|alias
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|var_ann_t
name|ann
init|=
name|var_ann
argument_list|(
name|alias
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|MTAG_P
argument_list|(
name|alias
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|alias
argument_list|)
operator|==
name|STRUCT_FIELD_TAG
operator|)
operator|&&
name|ann
operator|->
name|may_aliases
condition|)
block|{
name|tree
name|new_alias
decl_stmt|;
name|gcc_assert
argument_list|(
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|ann
operator|->
name|may_aliases
argument_list|)
operator|==
literal|1
argument_list|)
expr_stmt|;
name|new_alias
operator|=
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|ann
operator|->
name|may_aliases
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|replace_may_alias
argument_list|(
name|name_tag
argument_list|,
name|j
argument_list|,
name|new_alias
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"%s: Total number of aliased vops after grouping: %ld%s\n"
argument_list|,
name|get_name
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
name|ai
operator|->
name|total_alias_vops
argument_list|,
operator|(
name|ai
operator|->
name|total_alias_vops
operator|<
literal|0
operator|)
condition|?
literal|" (negative values are OK)"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create a new alias set entry for VAR in AI->ADDRESSABLE_VARS.  */
end_comment

begin_function
specifier|static
name|void
name|create_alias_map_for
parameter_list|(
name|tree
name|var
parameter_list|,
name|struct
name|alias_info
modifier|*
name|ai
parameter_list|)
block|{
name|struct
name|alias_map_d
modifier|*
name|alias_map
decl_stmt|;
name|alias_map
operator|=
name|XCNEW
argument_list|(
expr|struct
name|alias_map_d
argument_list|)
expr_stmt|;
name|alias_map
operator|->
name|var
operator|=
name|var
expr_stmt|;
name|alias_map
operator|->
name|set
operator|=
name|get_alias_set
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|ai
operator|->
name|addressable_vars
index|[
name|ai
operator|->
name|num_addressable_vars
operator|++
index|]
operator|=
name|alias_map
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create memory tags for all the dereferenced pointers and build the    ADDRESSABLE_VARS and POINTERS arrays used for building the may-alias    sets.  Based on the address escape and points-to information collected    earlier, this pass will also clear the TREE_ADDRESSABLE flag from those    variables whose address is not needed anymore.  */
end_comment

begin_function
specifier|static
name|void
name|setup_pointers_and_addressables
parameter_list|(
name|struct
name|alias_info
modifier|*
name|ai
parameter_list|)
block|{
name|size_t
name|n_vars
decl_stmt|,
name|num_addressable_vars
decl_stmt|,
name|num_pointers
decl_stmt|;
name|referenced_var_iterator
name|rvi
decl_stmt|;
name|tree
name|var
decl_stmt|;
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
name|varvec
operator|=
name|NULL
expr_stmt|;
name|safe_referenced_var_iterator
name|srvi
decl_stmt|;
comment|/* Size up the arrays ADDRESSABLE_VARS and POINTERS.  */
name|num_addressable_vars
operator|=
name|num_pointers
operator|=
literal|0
expr_stmt|;
name|FOR_EACH_REFERENCED_VAR
argument_list|(
argument|var
argument_list|,
argument|rvi
argument_list|)
block|{
if|if
condition|(
name|may_be_aliased
argument_list|(
name|var
argument_list|)
condition|)
name|num_addressable_vars
operator|++
expr_stmt|;
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|var
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Since we don't keep track of volatile variables, assume that 	     these pointers are used in indirect store operations.  */
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|var
argument_list|)
condition|)
name|bitmap_set_bit
argument_list|(
name|ai
operator|->
name|dereferenced_ptrs_store
argument_list|,
name|DECL_UID
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
name|num_pointers
operator|++
expr_stmt|;
block|}
block|}
comment|/* Create ADDRESSABLE_VARS and POINTERS.  Note that these arrays are      always going to be slightly bigger than we actually need them      because some TREE_ADDRESSABLE variables will be marked      non-addressable below and only pointers with unique symbol tags are      going to be added to POINTERS.  */
name|ai
operator|->
name|addressable_vars
operator|=
name|XCNEWVEC
argument_list|(
expr|struct
name|alias_map_d
operator|*
argument_list|,
name|num_addressable_vars
argument_list|)
expr_stmt|;
name|ai
operator|->
name|pointers
operator|=
name|XCNEWVEC
argument_list|(
expr|struct
name|alias_map_d
operator|*
argument_list|,
name|num_pointers
argument_list|)
expr_stmt|;
name|ai
operator|->
name|num_addressable_vars
operator|=
literal|0
expr_stmt|;
name|ai
operator|->
name|num_pointers
operator|=
literal|0
expr_stmt|;
comment|/* Since we will be creating symbol memory tags within this loop,      cache the value of NUM_REFERENCED_VARS to avoid processing the      additional tags unnecessarily.  */
name|n_vars
operator|=
name|num_referenced_vars
expr_stmt|;
name|FOR_EACH_REFERENCED_VAR_SAFE
argument_list|(
argument|var
argument_list|,
argument|varvec
argument_list|,
argument|srvi
argument_list|)
block|{
name|var_ann_t
name|v_ann
init|=
name|var_ann
argument_list|(
name|var
argument_list|)
decl_stmt|;
name|subvar_t
name|svars
decl_stmt|;
comment|/* Name memory tags already have flow-sensitive aliasing 	 information, so they need not be processed by 	 compute_flow_insensitive_aliasing.  Similarly, symbol memory 	 tags are already accounted for when we process their 	 associated pointer.                  Structure fields, on the other hand, have to have some of this          information processed for them, but it's pointless to mark them          non-addressable (since they are fake variables anyway).  */
if|if
condition|(
name|MTAG_P
argument_list|(
name|var
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|!=
name|STRUCT_FIELD_TAG
condition|)
continue|continue;
comment|/* Remove the ADDRESSABLE flag from every addressable variable whose          address is not needed anymore.  This is caused by the propagation          of ADDR_EXPR constants into INDIRECT_REF expressions and the          removal of dead pointer assignments done by the early scalar          cleanup passes.  */
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|var
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|bitmap_bit_p
argument_list|(
name|addressable_vars
argument_list|,
name|DECL_UID
argument_list|(
name|var
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|!=
name|RESULT_DECL
operator|&&
operator|!
name|is_global_var
argument_list|(
name|var
argument_list|)
condition|)
block|{
name|bool
name|okay_to_mark
init|=
name|true
decl_stmt|;
comment|/* Since VAR is now a regular GIMPLE register, we will need 		 to rename VAR into SSA afterwards.  */
name|mark_sym_for_renaming
argument_list|(
name|var
argument_list|)
expr_stmt|;
comment|/* If VAR can have sub-variables, and any of its 		 sub-variables has its address taken, then we cannot 		 remove the addressable flag from VAR.  */
if|if
condition|(
name|var_can_have_subvars
argument_list|(
name|var
argument_list|)
operator|&&
operator|(
name|svars
operator|=
name|get_subvars_for_var
argument_list|(
name|var
argument_list|)
operator|)
condition|)
block|{
name|subvar_t
name|sv
decl_stmt|;
for|for
control|(
name|sv
operator|=
name|svars
init|;
name|sv
condition|;
name|sv
operator|=
name|sv
operator|->
name|next
control|)
block|{
if|if
condition|(
name|bitmap_bit_p
argument_list|(
name|addressable_vars
argument_list|,
name|DECL_UID
argument_list|(
name|sv
operator|->
name|var
argument_list|)
argument_list|)
condition|)
name|okay_to_mark
operator|=
name|false
expr_stmt|;
name|mark_sym_for_renaming
argument_list|(
name|sv
operator|->
name|var
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* The address of VAR is not needed, remove the 		 addressable bit, so that it can be optimized as a 		 regular variable.  */
if|if
condition|(
name|okay_to_mark
condition|)
name|mark_non_addressable
argument_list|(
name|var
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Global variables and addressable locals may be aliased.  Create an          entry in ADDRESSABLE_VARS for VAR.  */
if|if
condition|(
name|may_be_aliased
argument_list|(
name|var
argument_list|)
operator|&&
operator|(
operator|!
name|var_can_have_subvars
argument_list|(
name|var
argument_list|)
operator|||
name|get_subvars_for_var
argument_list|(
name|var
argument_list|)
operator|==
name|NULL
operator|)
condition|)
block|{
name|create_alias_map_for
argument_list|(
name|var
argument_list|,
name|ai
argument_list|)
expr_stmt|;
name|mark_sym_for_renaming
argument_list|(
name|var
argument_list|)
expr_stmt|;
block|}
comment|/* Add pointer variables that have been dereferenced to the POINTERS          array and create a symbol memory tag for them.  */
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|var
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|bitmap_bit_p
argument_list|(
name|ai
operator|->
name|dereferenced_ptrs_store
argument_list|,
name|DECL_UID
argument_list|(
name|var
argument_list|)
argument_list|)
operator|||
name|bitmap_bit_p
argument_list|(
name|ai
operator|->
name|dereferenced_ptrs_load
argument_list|,
name|DECL_UID
argument_list|(
name|var
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|tree
name|tag
decl_stmt|;
name|var_ann_t
name|t_ann
decl_stmt|;
comment|/* If pointer VAR still doesn't have a memory tag 		 associated with it, create it now or re-use an 		 existing one.  */
name|tag
operator|=
name|get_tmt_for
argument_list|(
name|var
argument_list|,
name|ai
argument_list|)
expr_stmt|;
name|t_ann
operator|=
name|var_ann
argument_list|(
name|tag
argument_list|)
expr_stmt|;
comment|/* The symbol tag will need to be renamed into SSA 		 afterwards. Note that we cannot do this inside 		 get_tmt_for because aliasing may run multiple times 		 and we only create symbol tags the first time.  */
name|mark_sym_for_renaming
argument_list|(
name|tag
argument_list|)
expr_stmt|;
comment|/* Similarly, if pointer VAR used to have another type 		 tag, we will need to process it in the renamer to 		 remove the stale virtual operands.  */
if|if
condition|(
name|v_ann
operator|->
name|symbol_mem_tag
condition|)
name|mark_sym_for_renaming
argument_list|(
name|v_ann
operator|->
name|symbol_mem_tag
argument_list|)
expr_stmt|;
comment|/* Associate the tag with pointer VAR.  */
name|v_ann
operator|->
name|symbol_mem_tag
operator|=
name|tag
expr_stmt|;
comment|/* If pointer VAR has been used in a store operation, 		 then its memory tag must be marked as written-to.  */
if|if
condition|(
name|bitmap_bit_p
argument_list|(
name|ai
operator|->
name|dereferenced_ptrs_store
argument_list|,
name|DECL_UID
argument_list|(
name|var
argument_list|)
argument_list|)
condition|)
name|bitmap_set_bit
argument_list|(
name|ai
operator|->
name|written_vars
argument_list|,
name|DECL_UID
argument_list|(
name|tag
argument_list|)
argument_list|)
expr_stmt|;
comment|/* All the dereferences of pointer VAR count as 		 references of TAG.  Since TAG can be associated with 		 several pointers, add the dereferences of VAR to the 		 TAG.  */
name|NUM_REFERENCES_SET
argument_list|(
name|t_ann
argument_list|,
name|NUM_REFERENCES
argument_list|(
name|t_ann
argument_list|)
operator|+
name|NUM_REFERENCES
argument_list|(
name|v_ann
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The pointer has not been dereferenced.  If it had a 		 symbol memory tag, remove it and mark the old tag for 		 renaming to remove it out of the IL.  */
name|var_ann_t
name|ann
init|=
name|var_ann
argument_list|(
name|var
argument_list|)
decl_stmt|;
name|tree
name|tag
init|=
name|ann
operator|->
name|symbol_mem_tag
decl_stmt|;
if|if
condition|(
name|tag
condition|)
block|{
name|mark_sym_for_renaming
argument_list|(
name|tag
argument_list|)
expr_stmt|;
name|ann
operator|->
name|symbol_mem_tag
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
block|}
block|}
name|VEC_free
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|varvec
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Determine whether to use .GLOBAL_VAR to model call clobbering semantics. At    every call site, we need to emit V_MAY_DEF expressions to represent the    clobbering effects of the call for variables whose address escapes the    current function.     One approach is to group all call-clobbered variables into a single    representative that is used as an alias of every call-clobbered variable    (.GLOBAL_VAR).  This works well, but it ties the optimizer hands because    references to any call clobbered variable is a reference to .GLOBAL_VAR.     The second approach is to emit a clobbering V_MAY_DEF for every     call-clobbered variable at call sites.  This is the preferred way in terms     of optimization opportunities but it may create too many V_MAY_DEF operands    if there are many call clobbered variables and function calls in the     function.     To decide whether or not to use .GLOBAL_VAR we multiply the number of    function calls found by the number of call-clobbered variables.  If that    product is beyond a certain threshold, as determined by the parameterized    values shown below, we use .GLOBAL_VAR.     FIXME.  This heuristic should be improved.  One idea is to use several    .GLOBAL_VARs of different types instead of a single one.  The thresholds    have been derived from a typical bootstrap cycle, including all target    libraries. Compile times were found increase by ~1% compared to using    .GLOBAL_VAR.  */
end_comment

begin_function
specifier|static
name|void
name|maybe_create_global_var
parameter_list|(
name|struct
name|alias_info
modifier|*
name|ai
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|,
name|n_clobbered
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
comment|/* No need to create it, if we have one already.  */
if|if
condition|(
name|global_var
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* Count all the call-clobbered variables.  */
name|n_clobbered
operator|=
literal|0
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|call_clobbered_vars
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
name|n_clobbered
operator|++
expr_stmt|;
block|}
comment|/* If the number of virtual operands that would be needed to 	 model all the call-clobbered variables is larger than 	 GLOBAL_VAR_THRESHOLD, create .GLOBAL_VAR.  	 Also create .GLOBAL_VAR if there are no call-clobbered 	 variables and the program contains a mixture of pure/const 	 and regular function calls.  This is to avoid the problem 	 described in PR 20115:  	      int X; 	      int func_pure (void) { return X; } 	      int func_non_pure (int a) { X += a; } 	      int foo () 	      { 	 	int a = func_pure (); 		func_non_pure (a); 		a = func_pure (); 		return a; 	      }  	 Since foo() has no call-clobbered variables, there is 	 no relationship between the calls to func_pure and 	 func_non_pure.  Since func_pure has no side-effects, value 	 numbering optimizations elide the second call to func_pure. 	 So, if we have some pure/const and some regular calls in the 	 program we create .GLOBAL_VAR to avoid missing these 	 relations.  */
if|if
condition|(
name|ai
operator|->
name|num_calls_found
operator|*
name|n_clobbered
operator|>=
operator|(
name|size_t
operator|)
name|GLOBAL_VAR_THRESHOLD
operator|||
operator|(
name|n_clobbered
operator|==
literal|0
operator|&&
name|ai
operator|->
name|num_calls_found
operator|>
literal|0
operator|&&
name|ai
operator|->
name|num_pure_const_calls_found
operator|>
literal|0
operator|&&
name|ai
operator|->
name|num_calls_found
operator|>
name|ai
operator|->
name|num_pure_const_calls_found
operator|)
condition|)
name|create_global_var
argument_list|()
expr_stmt|;
block|}
comment|/* Mark all call-clobbered symbols for renaming.  Since the initial      rewrite into SSA ignored all call sites, we may need to rename      .GLOBAL_VAR and the call-clobbered variables.   */
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|call_clobbered_vars
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
name|tree
name|var
init|=
name|referenced_var
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|/* If the function has calls to clobbering functions and 	 .GLOBAL_VAR has been created, make it an alias for all 	 call-clobbered variables.  */
if|if
condition|(
name|global_var
operator|&&
name|var
operator|!=
name|global_var
condition|)
block|{
name|add_may_alias
argument_list|(
name|var
argument_list|,
name|global_var
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|get_subvars_for_var
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mark_sym_for_renaming
argument_list|(
name|var
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return TRUE if pointer PTR may point to variable VAR.        MEM_ALIAS_SET is the alias set for the memory location pointed-to by PTR 	This is needed because when checking for type conflicts we are 	interested in the alias set of the memory location pointed-to by 	PTR.  The alias set of PTR itself is irrelevant.        VAR_ALIAS_SET is the alias set for VAR.  */
end_comment

begin_function
specifier|static
name|bool
name|may_alias_p
parameter_list|(
name|tree
name|ptr
parameter_list|,
name|HOST_WIDE_INT
name|mem_alias_set
parameter_list|,
name|tree
name|var
parameter_list|,
name|HOST_WIDE_INT
name|var_alias_set
parameter_list|,
name|bool
name|alias_set_only
parameter_list|)
block|{
name|tree
name|mem
decl_stmt|;
name|alias_stats
operator|.
name|alias_queries
operator|++
expr_stmt|;
name|alias_stats
operator|.
name|simple_queries
operator|++
expr_stmt|;
comment|/* By convention, a variable cannot alias itself.  */
name|mem
operator|=
name|var_ann
argument_list|(
name|ptr
argument_list|)
operator|->
name|symbol_mem_tag
expr_stmt|;
if|if
condition|(
name|mem
operator|==
name|var
condition|)
block|{
name|alias_stats
operator|.
name|alias_noalias
operator|++
expr_stmt|;
name|alias_stats
operator|.
name|simple_resolved
operator|++
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* If -fargument-noalias-global is> 2, pointer arguments may      not point to anything else.  */
if|if
condition|(
name|flag_argument_noalias
operator|>
literal|2
operator|&&
name|TREE_CODE
argument_list|(
name|ptr
argument_list|)
operator|==
name|PARM_DECL
condition|)
block|{
name|alias_stats
operator|.
name|alias_noalias
operator|++
expr_stmt|;
name|alias_stats
operator|.
name|simple_resolved
operator|++
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* If -fargument-noalias-global is> 1, pointer arguments may      not point to global variables.  */
if|if
condition|(
name|flag_argument_noalias
operator|>
literal|1
operator|&&
name|is_global_var
argument_list|(
name|var
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|ptr
argument_list|)
operator|==
name|PARM_DECL
condition|)
block|{
name|alias_stats
operator|.
name|alias_noalias
operator|++
expr_stmt|;
name|alias_stats
operator|.
name|simple_resolved
operator|++
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* If either MEM or VAR is a read-only global and the other one      isn't, then PTR cannot point to VAR.  */
if|if
condition|(
operator|(
name|unmodifiable_var_p
argument_list|(
name|mem
argument_list|)
operator|&&
operator|!
name|unmodifiable_var_p
argument_list|(
name|var
argument_list|)
operator|)
operator|||
operator|(
name|unmodifiable_var_p
argument_list|(
name|var
argument_list|)
operator|&&
operator|!
name|unmodifiable_var_p
argument_list|(
name|mem
argument_list|)
operator|)
condition|)
block|{
name|alias_stats
operator|.
name|alias_noalias
operator|++
expr_stmt|;
name|alias_stats
operator|.
name|simple_resolved
operator|++
expr_stmt|;
return|return
name|false
return|;
block|}
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|mem
argument_list|)
operator|==
name|SYMBOL_MEMORY_TAG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_NO_TBAA_P
argument_list|(
name|ptr
argument_list|)
condition|)
block|{
name|alias_stats
operator|.
name|tbaa_queries
operator|++
expr_stmt|;
comment|/* If the alias sets don't conflict then MEM cannot alias VAR.  */
if|if
condition|(
operator|!
name|alias_sets_conflict_p
argument_list|(
name|mem_alias_set
argument_list|,
name|var_alias_set
argument_list|)
condition|)
block|{
name|alias_stats
operator|.
name|alias_noalias
operator|++
expr_stmt|;
name|alias_stats
operator|.
name|tbaa_resolved
operator|++
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* If VAR is a record or union type, PTR cannot point into VAR 	 unless there is some explicit address operation in the 	 program that can reference a field of the type pointed-to by 	 PTR.  This also assumes that the types of both VAR and PTR 	 are contained within the compilation unit, and that there is 	 no fancy addressing arithmetic associated with any of the 	 types involved.  */
if|if
condition|(
name|mem_alias_set
operator|!=
literal|0
operator|&&
name|var_alias_set
operator|!=
literal|0
condition|)
block|{
name|tree
name|ptr_type
init|=
name|TREE_TYPE
argument_list|(
name|ptr
argument_list|)
decl_stmt|;
name|tree
name|var_type
init|=
name|TREE_TYPE
argument_list|(
name|var
argument_list|)
decl_stmt|;
comment|/* The star count is -1 if the type at the end of the pointer_to  	 chain is not a record or union type. */
if|if
condition|(
operator|(
operator|!
name|alias_set_only
operator|)
operator|&&
name|ipa_type_escape_star_count_of_interesting_type
argument_list|(
name|var_type
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|int
name|ptr_star_count
init|=
literal|0
decl_stmt|;
comment|/* ipa_type_escape_star_count_of_interesting_type is a 		 little too restrictive for the pointer type, need to 		 allow pointers to primitive types as long as those 		 types cannot be pointers to everything.  */
while|while
condition|(
name|POINTER_TYPE_P
argument_list|(
name|ptr_type
argument_list|)
condition|)
block|{
comment|/* Strip the *s off.  */
name|ptr_type
operator|=
name|TREE_TYPE
argument_list|(
name|ptr_type
argument_list|)
expr_stmt|;
name|ptr_star_count
operator|++
expr_stmt|;
block|}
comment|/* There does not appear to be a better test to see if 		 the pointer type was one of the pointer to everything 		 types.  */
if|if
condition|(
name|ptr_star_count
operator|>
literal|0
condition|)
block|{
name|alias_stats
operator|.
name|structnoaddress_queries
operator|++
expr_stmt|;
if|if
condition|(
name|ipa_type_escape_field_does_not_clobber_p
argument_list|(
name|var_type
argument_list|,
name|TREE_TYPE
argument_list|(
name|ptr
argument_list|)
argument_list|)
condition|)
block|{
name|alias_stats
operator|.
name|structnoaddress_resolved
operator|++
expr_stmt|;
name|alias_stats
operator|.
name|alias_noalias
operator|++
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|ptr_star_count
operator|==
literal|0
condition|)
block|{
comment|/* If PTR_TYPE was not really a pointer to type, it cannot  		     alias.  */
name|alias_stats
operator|.
name|structnoaddress_queries
operator|++
expr_stmt|;
name|alias_stats
operator|.
name|structnoaddress_resolved
operator|++
expr_stmt|;
name|alias_stats
operator|.
name|alias_noalias
operator|++
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
block|}
block|}
name|alias_stats
operator|.
name|alias_mayalias
operator|++
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Add ALIAS to the set of variables that may alias VAR.  */
end_comment

begin_function
specifier|static
name|void
name|add_may_alias
parameter_list|(
name|tree
name|var
parameter_list|,
name|tree
name|alias
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|var_ann_t
name|v_ann
init|=
name|get_var_ann
argument_list|(
name|var
argument_list|)
decl_stmt|;
name|var_ann_t
name|a_ann
init|=
name|get_var_ann
argument_list|(
name|alias
argument_list|)
decl_stmt|;
name|tree
name|al
decl_stmt|;
comment|/* Don't allow self-referential aliases.  */
name|gcc_assert
argument_list|(
name|var
operator|!=
name|alias
argument_list|)
expr_stmt|;
comment|/* ALIAS must be addressable if it's being added to an alias set.  */
if|#
directive|if
literal|1
name|TREE_ADDRESSABLE
argument_list|(
name|alias
argument_list|)
operator|=
literal|1
expr_stmt|;
else|#
directive|else
name|gcc_assert
argument_list|(
name|may_be_aliased
argument_list|(
name|alias
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|v_ann
operator|->
name|may_aliases
operator|==
name|NULL
condition|)
name|v_ann
operator|->
name|may_aliases
operator|=
name|VEC_alloc
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Avoid adding duplicates.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
name|v_ann
operator|->
name|may_aliases
argument_list|,
name|i
argument_list|,
name|al
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|alias
operator|==
name|al
condition|)
return|return;
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|,
name|v_ann
operator|->
name|may_aliases
argument_list|,
name|alias
argument_list|)
expr_stmt|;
name|a_ann
operator|->
name|is_aliased
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Replace alias I in the alias sets of VAR with NEW_ALIAS.  */
end_comment

begin_function
specifier|static
name|void
name|replace_may_alias
parameter_list|(
name|tree
name|var
parameter_list|,
name|size_t
name|i
parameter_list|,
name|tree
name|new_alias
parameter_list|)
block|{
name|var_ann_t
name|v_ann
init|=
name|var_ann
argument_list|(
name|var
argument_list|)
decl_stmt|;
name|VEC_replace
argument_list|(
name|tree
argument_list|,
name|v_ann
operator|->
name|may_aliases
argument_list|,
name|i
argument_list|,
name|new_alias
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Mark pointer PTR as pointing to an arbitrary memory location.  */
end_comment

begin_function
specifier|static
name|void
name|set_pt_anything
parameter_list|(
name|tree
name|ptr
parameter_list|)
block|{
name|struct
name|ptr_info_def
modifier|*
name|pi
init|=
name|get_ptr_info
argument_list|(
name|ptr
argument_list|)
decl_stmt|;
name|pi
operator|->
name|pt_anything
operator|=
literal|1
expr_stmt|;
name|pi
operator|->
name|pt_vars
operator|=
name|NULL
expr_stmt|;
comment|/* The pointer used to have a name tag, but we now found it pointing      to an arbitrary location.  The name tag needs to be renamed and      disassociated from PTR.  */
if|if
condition|(
name|pi
operator|->
name|name_mem_tag
condition|)
block|{
name|mark_sym_for_renaming
argument_list|(
name|pi
operator|->
name|name_mem_tag
argument_list|)
expr_stmt|;
name|pi
operator|->
name|name_mem_tag
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return true if STMT is an "escape" site from the current function.  Escape    sites those statements which might expose the address of a variable    outside the current function.  STMT is an escape site iff:     	1- STMT is a function call, or 	2- STMT is an __asm__ expression, or 	3- STMT is an assignment to a non-local variable, or 	4- STMT is a return statement.     Return the type of escape site found, if we found one, or NO_ESCAPE    if none.  */
end_comment

begin_function
name|enum
name|escape_type
name|is_escape_site
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
name|tree
name|call
init|=
name|get_call_expr_in
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
if|if
condition|(
name|call
operator|!=
name|NULL_TREE
condition|)
block|{
if|if
condition|(
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|call
argument_list|)
condition|)
return|return
name|ESCAPE_TO_PURE_CONST
return|;
return|return
name|ESCAPE_TO_CALL
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|ASM_EXPR
condition|)
return|return
name|ESCAPE_TO_ASM
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|MODIFY_EXPR
condition|)
block|{
name|tree
name|lhs
init|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* Get to the base of _REF nodes.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|!=
name|SSA_NAME
condition|)
name|lhs
operator|=
name|get_base_address
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
comment|/* If we couldn't recognize the LHS of the assignment, assume that it 	 is a non-local store.  */
if|if
condition|(
name|lhs
operator|==
name|NULL_TREE
condition|)
return|return
name|ESCAPE_UNKNOWN
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|VIEW_CONVERT_EXPR
condition|)
block|{
name|tree
name|from
init|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|to
init|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
comment|/* If the RHS is a conversion between a pointer and an integer, the 	     pointer escapes since we can't track the integer.  */
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|from
argument_list|)
operator|&&
operator|!
name|POINTER_TYPE_P
argument_list|(
name|to
argument_list|)
condition|)
return|return
name|ESCAPE_BAD_CAST
return|;
comment|/* Same if the RHS is a conversion between a regular pointer and a 	     ref-all pointer since we can't track the SMT of the former.  */
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|from
argument_list|)
operator|&&
operator|!
name|TYPE_REF_CAN_ALIAS_ALL
argument_list|(
name|from
argument_list|)
operator|&&
name|POINTER_TYPE_P
argument_list|(
name|to
argument_list|)
operator|&&
name|TYPE_REF_CAN_ALIAS_ALL
argument_list|(
name|to
argument_list|)
condition|)
return|return
name|ESCAPE_BAD_CAST
return|;
block|}
comment|/* If the LHS is an SSA name, it can't possibly represent a non-local 	 memory store.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|SSA_NAME
condition|)
return|return
name|NO_ESCAPE
return|;
comment|/* FIXME: LHS is not an SSA_NAME.  Even if it's an assignment to a 	 local variables we cannot be sure if it will escape, because we 	 don't have information about objects not in SSA form.  Need to 	 implement something along the lines of  	 J.-D. Choi, M. Gupta, M. J. Serrano, V. C. Sreedhar, and S. P. 	 Midkiff, ``Escape analysis for java,'' in Proceedings of the 	 Conference on Object-Oriented Programming Systems, Languages, and 	 Applications (OOPSLA), pp. 1-19, 1999.  */
return|return
name|ESCAPE_STORED_IN_GLOBAL
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|RETURN_EXPR
condition|)
return|return
name|ESCAPE_TO_RETURN
return|;
return|return
name|NO_ESCAPE
return|;
block|}
end_function

begin_comment
comment|/* Create a new memory tag of type TYPE.    Does NOT push it into the current binding.  */
end_comment

begin_function
specifier|static
name|tree
name|create_tag_raw
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|tree
name|tmp_var
decl_stmt|;
name|tree
name|new_type
decl_stmt|;
comment|/* Make the type of the variable writable.  */
name|new_type
operator|=
name|build_type_variant
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TYPE_ATTRIBUTES
argument_list|(
name|new_type
argument_list|)
operator|=
name|TYPE_ATTRIBUTES
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|tmp_var
operator|=
name|build_decl
argument_list|(
name|code
argument_list|,
name|create_tmp_var_name
argument_list|(
name|prefix
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* Make the variable writable.  */
name|TREE_READONLY
argument_list|(
name|tmp_var
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* It doesn't start out global.  */
name|MTAG_GLOBAL
argument_list|(
name|tmp_var
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|tmp_var
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_USED
argument_list|(
name|tmp_var
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|tmp_var
return|;
block|}
end_function

begin_comment
comment|/* Create a new memory tag of type TYPE.  If IS_TYPE_TAG is true, the tag    is considered to represent all the pointers whose pointed-to types are    in the same alias set class.  Otherwise, the tag represents a single    SSA_NAME pointer variable.  */
end_comment

begin_function
specifier|static
name|tree
name|create_memory_tag
parameter_list|(
name|tree
name|type
parameter_list|,
name|bool
name|is_type_tag
parameter_list|)
block|{
name|var_ann_t
name|ann
decl_stmt|;
name|tree
name|tag
init|=
name|create_tag_raw
argument_list|(
name|is_type_tag
condition|?
name|SYMBOL_MEMORY_TAG
else|:
name|NAME_MEMORY_TAG
argument_list|,
name|type
argument_list|,
operator|(
name|is_type_tag
operator|)
condition|?
literal|"SMT"
else|:
literal|"NMT"
argument_list|)
decl_stmt|;
comment|/* By default, memory tags are local variables.  Alias analysis will      determine whether they should be considered globals.  */
name|DECL_CONTEXT
argument_list|(
name|tag
argument_list|)
operator|=
name|current_function_decl
expr_stmt|;
comment|/* Memory tags are by definition addressable.  */
name|TREE_ADDRESSABLE
argument_list|(
name|tag
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ann
operator|=
name|get_var_ann
argument_list|(
name|tag
argument_list|)
expr_stmt|;
name|ann
operator|->
name|symbol_mem_tag
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Add the tag to the symbol table.  */
name|add_referenced_var
argument_list|(
name|tag
argument_list|)
expr_stmt|;
return|return
name|tag
return|;
block|}
end_function

begin_comment
comment|/* Create a name memory tag to represent a specific SSA_NAME pointer P_i.    This is used if P_i has been found to point to a specific set of    variables or to a non-aliased memory location like the address returned    by malloc functions.  */
end_comment

begin_function
specifier|static
name|tree
name|get_nmt_for
parameter_list|(
name|tree
name|ptr
parameter_list|)
block|{
name|struct
name|ptr_info_def
modifier|*
name|pi
init|=
name|get_ptr_info
argument_list|(
name|ptr
argument_list|)
decl_stmt|;
name|tree
name|tag
init|=
name|pi
operator|->
name|name_mem_tag
decl_stmt|;
if|if
condition|(
name|tag
operator|==
name|NULL_TREE
condition|)
name|tag
operator|=
name|create_memory_tag
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ptr
argument_list|)
argument_list|)
argument_list|,
name|false
argument_list|)
expr_stmt|;
return|return
name|tag
return|;
block|}
end_function

begin_comment
comment|/* Return the symbol memory tag associated to pointer PTR.  A memory    tag is an artificial variable that represents the memory location    pointed-to by PTR.  It is used to model the effects of pointer    de-references on addressable variables.        AI points to the data gathered during alias analysis.  This    function populates the array AI->POINTERS.  */
end_comment

begin_function
specifier|static
name|tree
name|get_tmt_for
parameter_list|(
name|tree
name|ptr
parameter_list|,
name|struct
name|alias_info
modifier|*
name|ai
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|tree
name|tag
decl_stmt|;
name|tree
name|tag_type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ptr
argument_list|)
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|tag_set
init|=
name|get_alias_set
argument_list|(
name|tag_type
argument_list|)
decl_stmt|;
comment|/* We use a unique memory tag for all the ref-all pointers.  */
if|if
condition|(
name|PTR_IS_REF_ALL
argument_list|(
name|ptr
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ai
operator|->
name|ref_all_symbol_mem_tag
condition|)
name|ai
operator|->
name|ref_all_symbol_mem_tag
operator|=
name|create_memory_tag
argument_list|(
name|void_type_node
argument_list|,
name|true
argument_list|)
expr_stmt|;
return|return
name|ai
operator|->
name|ref_all_symbol_mem_tag
return|;
block|}
comment|/* To avoid creating unnecessary memory tags, only create one memory tag      per alias set class.  Note that it may be tempting to group      memory tags based on conflicting alias sets instead of      equivalence.  That would be wrong because alias sets are not      necessarily transitive (as demonstrated by the libstdc++ test      23_containers/vector/cons/4.cc).  Given three alias sets A, B, C      such that conflicts (A, B) == true and conflicts (A, C) == true,      it does not necessarily follow that conflicts (B, C) == true.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tag
operator|=
name|NULL_TREE
init|;
name|i
operator|<
name|ai
operator|->
name|num_pointers
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|alias_map_d
modifier|*
name|curr
init|=
name|ai
operator|->
name|pointers
index|[
name|i
index|]
decl_stmt|;
name|tree
name|curr_tag
init|=
name|var_ann
argument_list|(
name|curr
operator|->
name|var
argument_list|)
operator|->
name|symbol_mem_tag
decl_stmt|;
if|if
condition|(
name|tag_set
operator|==
name|curr
operator|->
name|set
condition|)
block|{
name|tag
operator|=
name|curr_tag
expr_stmt|;
break|break;
block|}
block|}
comment|/* If VAR cannot alias with any of the existing memory tags, create a new      tag for PTR and add it to the POINTERS array.  */
if|if
condition|(
name|tag
operator|==
name|NULL_TREE
condition|)
block|{
name|struct
name|alias_map_d
modifier|*
name|alias_map
decl_stmt|;
comment|/* If PTR did not have a symbol tag already, create a new SMT.* 	 artificial variable representing the memory location 	 pointed-to by PTR.  */
if|if
condition|(
name|var_ann
argument_list|(
name|ptr
argument_list|)
operator|->
name|symbol_mem_tag
operator|==
name|NULL_TREE
condition|)
name|tag
operator|=
name|create_memory_tag
argument_list|(
name|tag_type
argument_list|,
name|true
argument_list|)
expr_stmt|;
else|else
name|tag
operator|=
name|var_ann
argument_list|(
name|ptr
argument_list|)
operator|->
name|symbol_mem_tag
expr_stmt|;
comment|/* Add PTR to the POINTERS array.  Note that we are not interested in 	 PTR's alias set.  Instead, we cache the alias set for the memory that 	 PTR points to.  */
name|alias_map
operator|=
name|XCNEW
argument_list|(
expr|struct
name|alias_map_d
argument_list|)
expr_stmt|;
name|alias_map
operator|->
name|var
operator|=
name|ptr
expr_stmt|;
name|alias_map
operator|->
name|set
operator|=
name|tag_set
expr_stmt|;
name|ai
operator|->
name|pointers
index|[
name|ai
operator|->
name|num_pointers
operator|++
index|]
operator|=
name|alias_map
expr_stmt|;
block|}
comment|/* If the pointed-to type is volatile, so is the tag.  */
name|TREE_THIS_VOLATILE
argument_list|(
name|tag
argument_list|)
operator||=
name|TREE_THIS_VOLATILE
argument_list|(
name|tag_type
argument_list|)
expr_stmt|;
comment|/* Make sure that the symbol tag has the same alias set as the      pointed-to type.  */
name|gcc_assert
argument_list|(
name|tag_set
operator|==
name|get_alias_set
argument_list|(
name|tag
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|tag
return|;
block|}
end_function

begin_comment
comment|/* Create GLOBAL_VAR, an artificial global variable to act as a    representative of all the variables that may be clobbered by function    calls.  */
end_comment

begin_function
specifier|static
name|void
name|create_global_var
parameter_list|(
name|void
parameter_list|)
block|{
name|global_var
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|".GLOBAL_VAR"
argument_list|)
argument_list|,
name|void_type_node
argument_list|)
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|global_var
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|global_var
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|global_var
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|global_var
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_USED
argument_list|(
name|global_var
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|global_var
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|global_var
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|global_var
argument_list|)
operator|=
literal|0
expr_stmt|;
name|create_var_ann
argument_list|(
name|global_var
argument_list|)
expr_stmt|;
name|mark_call_clobbered
argument_list|(
name|global_var
argument_list|,
name|ESCAPE_UNKNOWN
argument_list|)
expr_stmt|;
name|add_referenced_var
argument_list|(
name|global_var
argument_list|)
expr_stmt|;
name|mark_sym_for_renaming
argument_list|(
name|global_var
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump alias statistics on FILE.  */
end_comment

begin_function
specifier|static
name|void
name|dump_alias_stats
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|funcname
init|=
name|lang_hooks
operator|.
name|decl_printable_name
argument_list|(
name|current_function_decl
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\nAlias statistics for %s\n\n"
argument_list|,
name|funcname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Total alias queries:\t%u\n"
argument_list|,
name|alias_stats
operator|.
name|alias_queries
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Total alias mayalias results:\t%u\n"
argument_list|,
name|alias_stats
operator|.
name|alias_mayalias
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Total alias noalias results:\t%u\n"
argument_list|,
name|alias_stats
operator|.
name|alias_noalias
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Total simple queries:\t%u\n"
argument_list|,
name|alias_stats
operator|.
name|simple_queries
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Total simple resolved:\t%u\n"
argument_list|,
name|alias_stats
operator|.
name|simple_resolved
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Total TBAA queries:\t%u\n"
argument_list|,
name|alias_stats
operator|.
name|tbaa_queries
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Total TBAA resolved:\t%u\n"
argument_list|,
name|alias_stats
operator|.
name|tbaa_resolved
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Total non-addressable structure type queries:\t%u\n"
argument_list|,
name|alias_stats
operator|.
name|structnoaddress_queries
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Total non-addressable structure type resolved:\t%u\n"
argument_list|,
name|alias_stats
operator|.
name|structnoaddress_resolved
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump alias information on FILE.  */
end_comment

begin_function
name|void
name|dump_alias_info
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|funcname
init|=
name|lang_hooks
operator|.
name|decl_printable_name
argument_list|(
name|current_function_decl
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|referenced_var_iterator
name|rvi
decl_stmt|;
name|tree
name|var
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\nFlow-insensitive alias information for %s\n\n"
argument_list|,
name|funcname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Aliased symbols\n\n"
argument_list|)
expr_stmt|;
name|FOR_EACH_REFERENCED_VAR
argument_list|(
argument|var
argument_list|,
argument|rvi
argument_list|)
block|{
if|if
condition|(
name|may_be_aliased
argument_list|(
name|var
argument_list|)
condition|)
name|dump_variable
argument_list|(
name|file
argument_list|,
name|var
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\nDereferenced pointers\n\n"
argument_list|)
expr_stmt|;
name|FOR_EACH_REFERENCED_VAR
argument_list|(
argument|var
argument_list|,
argument|rvi
argument_list|)
block|{
name|var_ann_t
name|ann
init|=
name|var_ann
argument_list|(
name|var
argument_list|)
decl_stmt|;
if|if
condition|(
name|ann
operator|->
name|symbol_mem_tag
condition|)
name|dump_variable
argument_list|(
name|file
argument_list|,
name|var
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\nSymbol memory tags\n\n"
argument_list|)
expr_stmt|;
name|FOR_EACH_REFERENCED_VAR
argument_list|(
argument|var
argument_list|,
argument|rvi
argument_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|SYMBOL_MEMORY_TAG
condition|)
name|dump_variable
argument_list|(
name|file
argument_list|,
name|var
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n\nFlow-sensitive alias information for %s\n\n"
argument_list|,
name|funcname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"SSA_NAME pointers\n\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|num_ssa_names
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|ptr
init|=
name|ssa_name
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|struct
name|ptr_info_def
modifier|*
name|pi
decl_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL_TREE
condition|)
continue|continue;
name|pi
operator|=
name|SSA_NAME_PTR_INFO
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SSA_NAME_IN_FREE_LIST
argument_list|(
name|ptr
argument_list|)
operator|&&
name|pi
operator|&&
name|pi
operator|->
name|name_mem_tag
condition|)
name|dump_points_to_info_for
argument_list|(
name|file
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\nName memory tags\n\n"
argument_list|)
expr_stmt|;
name|FOR_EACH_REFERENCED_VAR
argument_list|(
argument|var
argument_list|,
argument|rvi
argument_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|NAME_MEMORY_TAG
condition|)
name|dump_variable
argument_list|(
name|file
argument_list|,
name|var
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump alias information on stderr.  */
end_comment

begin_function
name|void
name|debug_alias_info
parameter_list|(
name|void
parameter_list|)
block|{
name|dump_alias_info
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the alias information associated with pointer T.  It creates a    new instance if none existed.  */
end_comment

begin_function
name|struct
name|ptr_info_def
modifier|*
name|get_ptr_info
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|struct
name|ptr_info_def
modifier|*
name|pi
decl_stmt|;
name|gcc_assert
argument_list|(
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|pi
operator|=
name|SSA_NAME_PTR_INFO
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|==
name|NULL
condition|)
block|{
name|pi
operator|=
name|GGC_NEW
argument_list|(
expr|struct
name|ptr_info_def
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
name|pi
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pi
argument_list|)
argument_list|)
expr_stmt|;
name|SSA_NAME_PTR_INFO
argument_list|(
name|t
argument_list|)
operator|=
name|pi
expr_stmt|;
block|}
return|return
name|pi
return|;
block|}
end_function

begin_comment
comment|/* Dump points-to information for SSA_NAME PTR into FILE.  */
end_comment

begin_function
name|void
name|dump_points_to_info_for
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|tree
name|ptr
parameter_list|)
block|{
name|struct
name|ptr_info_def
modifier|*
name|pi
init|=
name|SSA_NAME_PTR_INFO
argument_list|(
name|ptr
argument_list|)
decl_stmt|;
name|print_generic_expr
argument_list|(
name|file
argument_list|,
name|ptr
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
condition|)
block|{
if|if
condition|(
name|pi
operator|->
name|name_mem_tag
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|", name memory tag: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|file
argument_list|,
name|pi
operator|->
name|name_mem_tag
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pi
operator|->
name|is_dereferenced
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|", is dereferenced"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|value_escapes_p
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|", its value escapes"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|pt_anything
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|", points-to anything"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|pt_null
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|", points-to NULL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|pt_vars
condition|)
block|{
name|unsigned
name|ix
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|", points-to vars: { "
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|pi->pt_vars
argument_list|,
literal|0
argument_list|,
argument|ix
argument_list|,
argument|bi
argument_list|)
block|{
name|print_generic_expr
argument_list|(
name|file
argument_list|,
name|referenced_var
argument_list|(
name|ix
argument_list|)
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump points-to information for VAR into stderr.  */
end_comment

begin_function
name|void
name|debug_points_to_info_for
parameter_list|(
name|tree
name|var
parameter_list|)
block|{
name|dump_points_to_info_for
argument_list|(
name|stderr
argument_list|,
name|var
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump points-to information into FILE.  NOTE: This function is slow, as    it needs to traverse the whole CFG looking for pointer SSA_NAMEs.  */
end_comment

begin_function
name|void
name|dump_points_to_info
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|block_stmt_iterator
name|si
decl_stmt|;
name|ssa_op_iter
name|iter
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
init|=
name|lang_hooks
operator|.
name|decl_printable_name
argument_list|(
name|current_function_decl
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|referenced_var_iterator
name|rvi
decl_stmt|;
name|tree
name|var
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n\nPointed-to sets for pointers in %s\n\n"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
comment|/* First dump points-to information for the default definitions of      pointer variables.  This is necessary because default definitions are      not part of the code.  */
name|FOR_EACH_REFERENCED_VAR
argument_list|(
argument|var
argument_list|,
argument|rvi
argument_list|)
block|{
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|var
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|def
init|=
name|default_def
argument_list|(
name|var
argument_list|)
decl_stmt|;
if|if
condition|(
name|def
condition|)
name|dump_points_to_info_for
argument_list|(
name|file
argument_list|,
name|def
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Dump points-to information for every pointer defined in the program.  */
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|tree
name|phi
decl_stmt|;
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|bb
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
block|{
name|tree
name|ptr
init|=
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
decl_stmt|;
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|ptr
argument_list|)
argument_list|)
condition|)
name|dump_points_to_info_for
argument_list|(
name|file
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|si
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|si
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|si
argument_list|)
control|)
block|{
name|tree
name|stmt
init|=
name|bsi_stmt
argument_list|(
name|si
argument_list|)
decl_stmt|;
name|tree
name|def
decl_stmt|;
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|def
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_DEF
argument_list|)
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|def
argument_list|)
argument_list|)
condition|)
name|dump_points_to_info_for
argument_list|(
name|file
argument_list|,
name|def
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump points-to info pointed to by PTO into STDERR.  */
end_comment

begin_function
name|void
name|debug_points_to_info
parameter_list|(
name|void
parameter_list|)
block|{
name|dump_points_to_info
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump to FILE the list of variables that may be aliasing VAR.  */
end_comment

begin_function
name|void
name|dump_may_aliases_for
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|tree
name|var
parameter_list|)
block|{
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
name|aliases
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|SSA_NAME
condition|)
name|var
operator|=
name|SSA_NAME_VAR
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|aliases
operator|=
name|var_ann
argument_list|(
name|var
argument_list|)
operator|->
name|may_aliases
expr_stmt|;
if|if
condition|(
name|aliases
condition|)
block|{
name|size_t
name|i
decl_stmt|;
name|tree
name|al
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"{ "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
name|aliases
argument_list|,
name|i
argument_list|,
name|al
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|print_generic_expr
argument_list|(
name|file
argument_list|,
name|al
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Dump to stderr the list of variables that may be aliasing VAR.  */
end_comment

begin_function
name|void
name|debug_may_aliases_for
parameter_list|(
name|tree
name|var
parameter_list|)
block|{
name|dump_may_aliases_for
argument_list|(
name|stderr
argument_list|,
name|var
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true if VAR may be aliased.  */
end_comment

begin_function
name|bool
name|may_be_aliased
parameter_list|(
name|tree
name|var
parameter_list|)
block|{
comment|/* Obviously.  */
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|var
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* Globally visible variables can have their addresses taken by other      translation units.  */
if|if
condition|(
name|MTAG_P
argument_list|(
name|var
argument_list|)
operator|&&
operator|(
name|MTAG_GLOBAL
argument_list|(
name|var
argument_list|)
operator|||
name|TREE_PUBLIC
argument_list|(
name|var
argument_list|)
operator|)
condition|)
return|return
name|true
return|;
elseif|else
if|if
condition|(
operator|!
name|MTAG_P
argument_list|(
name|var
argument_list|)
operator|&&
operator|(
name|DECL_EXTERNAL
argument_list|(
name|var
argument_list|)
operator|||
name|TREE_PUBLIC
argument_list|(
name|var
argument_list|)
operator|)
condition|)
return|return
name|true
return|;
comment|/* Automatic variables can't have their addresses escape any other way.      This must be after the check for global variables, as extern declarations      do not have TREE_STATIC set.  */
if|if
condition|(
operator|!
name|TREE_STATIC
argument_list|(
name|var
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* If we're in unit-at-a-time mode, then we must have seen all occurrences      of address-of operators, and so we can trust TREE_ADDRESSABLE.  Otherwise      we can only be sure the variable isn't addressable if it's local to the      current function.  */
if|if
condition|(
name|flag_unit_at_a_time
condition|)
return|return
name|false
return|;
if|if
condition|(
name|decl_function_context
argument_list|(
name|var
argument_list|)
operator|==
name|current_function_decl
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Given two symbols return TRUE if one is in the alias set of the other.  */
end_comment

begin_function
name|bool
name|is_aliased_with
parameter_list|(
name|tree
name|tag
parameter_list|,
name|tree
name|sym
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
name|aliases
expr_stmt|;
name|tree
name|al
decl_stmt|;
if|if
condition|(
name|var_ann
argument_list|(
name|sym
argument_list|)
operator|->
name|is_aliased
condition|)
block|{
name|aliases
operator|=
name|var_ann
argument_list|(
name|tag
argument_list|)
operator|->
name|may_aliases
expr_stmt|;
if|if
condition|(
name|aliases
operator|==
name|NULL
condition|)
return|return
name|false
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
name|aliases
argument_list|,
name|i
argument_list|,
name|al
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|al
operator|==
name|sym
condition|)
return|return
name|true
return|;
block|}
else|else
block|{
name|aliases
operator|=
name|var_ann
argument_list|(
name|sym
argument_list|)
operator|->
name|may_aliases
expr_stmt|;
if|if
condition|(
name|aliases
operator|==
name|NULL
condition|)
return|return
name|false
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
name|aliases
argument_list|,
name|i
argument_list|,
name|al
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|al
operator|==
name|tag
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Given two tags return TRUE if their may-alias sets intersect.  */
end_comment

begin_function
name|bool
name|may_aliases_intersect
parameter_list|(
name|tree
name|tag1
parameter_list|,
name|tree
name|tag2
parameter_list|)
block|{
name|struct
name|pointer_set_t
modifier|*
name|set1
init|=
name|pointer_set_create
argument_list|()
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
name|may_aliases1
operator|=
name|may_aliases
argument_list|(
name|tag1
argument_list|)
expr_stmt|;
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
name|may_aliases2
operator|=
name|may_aliases
argument_list|(
name|tag2
argument_list|)
expr_stmt|;
name|tree
name|sym
decl_stmt|;
comment|/* Insert all the symbols from the first may-alias set into the      pointer-set.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
name|may_aliases1
argument_list|,
name|i
argument_list|,
name|sym
argument_list|)
condition|;
name|i
operator|++
control|)
name|pointer_set_insert
argument_list|(
name|set1
argument_list|,
name|sym
argument_list|)
expr_stmt|;
comment|/* Go through the second may-alias set and check if it contains symbols that      are common with the first set.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
name|may_aliases2
argument_list|,
name|i
argument_list|,
name|sym
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|pointer_set_contains
argument_list|(
name|set1
argument_list|,
name|sym
argument_list|)
condition|)
block|{
name|pointer_set_destroy
argument_list|(
name|set1
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
name|pointer_set_destroy
argument_list|(
name|set1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* The following is based on code in add_stmt_operand to ensure that the    same defs/uses/vdefs/vuses will be found after replacing a reference    to var (or ARRAY_REF to var) with an INDIRECT_REF to ptr whose value    is the address of var.  Return a memtag for the ptr, after adding the     proper may_aliases to it (which are the aliases of var, if it has any,    or var itself).  */
end_comment

begin_function
specifier|static
name|tree
name|add_may_alias_for_new_tag
parameter_list|(
name|tree
name|tag
parameter_list|,
name|tree
name|var
parameter_list|)
block|{
name|var_ann_t
name|v_ann
init|=
name|var_ann
argument_list|(
name|var
argument_list|)
decl_stmt|;
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
name|aliases
operator|=
name|v_ann
operator|->
name|may_aliases
expr_stmt|;
comment|/* Case 1: |aliases| == 1  */
if|if
condition|(
operator|(
name|aliases
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|aliases
argument_list|)
operator|==
literal|1
operator|)
condition|)
block|{
name|tree
name|ali
init|=
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|aliases
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ali
argument_list|)
operator|==
name|SYMBOL_MEMORY_TAG
condition|)
return|return
name|ali
return|;
block|}
comment|/* Case 2: |aliases| == 0  */
if|if
condition|(
name|aliases
operator|==
name|NULL
condition|)
name|add_may_alias
argument_list|(
name|tag
argument_list|,
name|var
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Case 3: |aliases|> 1  */
name|unsigned
name|i
decl_stmt|;
name|tree
name|al
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
name|aliases
argument_list|,
name|i
argument_list|,
name|al
argument_list|)
condition|;
name|i
operator|++
control|)
name|add_may_alias
argument_list|(
name|tag
argument_list|,
name|al
argument_list|)
expr_stmt|;
block|}
return|return
name|tag
return|;
block|}
end_function

begin_comment
comment|/* Create a new symbol tag for PTR.  Construct the may-alias list of this type    tag so that it has the aliasing of VAR, or of the relevant subvars of VAR    according to the location accessed by EXPR.     Note, the set of aliases represented by the new symbol tag are not marked    for renaming.  */
end_comment

begin_function
name|void
name|new_type_alias
parameter_list|(
name|tree
name|ptr
parameter_list|,
name|tree
name|var
parameter_list|,
name|tree
name|expr
parameter_list|)
block|{
name|var_ann_t
name|p_ann
init|=
name|var_ann
argument_list|(
name|ptr
argument_list|)
decl_stmt|;
name|tree
name|tag_type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ptr
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|tag
decl_stmt|;
name|subvar_t
name|svars
decl_stmt|;
name|tree
name|ali
init|=
name|NULL_TREE
decl_stmt|;
name|HOST_WIDE_INT
name|offset
decl_stmt|,
name|size
decl_stmt|,
name|maxsize
decl_stmt|;
name|tree
name|ref
decl_stmt|;
name|gcc_assert
argument_list|(
name|p_ann
operator|->
name|symbol_mem_tag
operator|==
name|NULL_TREE
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|MTAG_P
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
name|ref
operator|=
name|get_ref_base_and_extent
argument_list|(
name|expr
argument_list|,
operator|&
name|offset
argument_list|,
operator|&
name|size
argument_list|,
operator|&
name|maxsize
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|tag
operator|=
name|create_memory_tag
argument_list|(
name|tag_type
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|p_ann
operator|->
name|symbol_mem_tag
operator|=
name|tag
expr_stmt|;
comment|/* Add VAR to the may-alias set of PTR's new symbol tag.  If VAR has      subvars, add the subvars to the tag instead of the actual var.  */
if|if
condition|(
name|var_can_have_subvars
argument_list|(
name|var
argument_list|)
operator|&&
operator|(
name|svars
operator|=
name|get_subvars_for_var
argument_list|(
name|var
argument_list|)
operator|)
condition|)
block|{
name|subvar_t
name|sv
decl_stmt|;
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
name|overlaps
operator|=
name|NULL
expr_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
for|for
control|(
name|sv
operator|=
name|svars
init|;
name|sv
condition|;
name|sv
operator|=
name|sv
operator|->
name|next
control|)
block|{
name|bool
name|exact
decl_stmt|;
if|if
condition|(
name|overlap_subvar
argument_list|(
name|offset
argument_list|,
name|maxsize
argument_list|,
name|sv
operator|->
name|var
argument_list|,
operator|&
name|exact
argument_list|)
condition|)
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|overlaps
argument_list|,
name|sv
operator|->
name|var
argument_list|)
expr_stmt|;
block|}
name|len
operator|=
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|overlaps
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nnumber of overlapping subvars = %u\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|1
condition|)
name|ali
operator|=
name|add_may_alias_for_new_tag
argument_list|(
name|tag
argument_list|,
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|overlaps
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|len
operator|>
literal|1
condition|)
block|{
name|unsigned
name|int
name|k
decl_stmt|;
name|tree
name|sv_var
decl_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
name|overlaps
argument_list|,
name|k
argument_list|,
name|sv_var
argument_list|)
condition|;
name|k
operator|++
control|)
block|{
name|ali
operator|=
name|add_may_alias_for_new_tag
argument_list|(
name|tag
argument_list|,
name|sv_var
argument_list|)
expr_stmt|;
if|if
condition|(
name|ali
operator|!=
name|tag
condition|)
block|{
comment|/* Can happen only if 'Case 1' of add_may_alias_for_new_tag 		     took place.  Since more than one svar was found, we add  		     'ali' as one of the may_aliases of the new tag.  */
name|add_may_alias
argument_list|(
name|tag
argument_list|,
name|ali
argument_list|)
expr_stmt|;
name|ali
operator|=
name|tag
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
name|ali
operator|=
name|add_may_alias_for_new_tag
argument_list|(
name|tag
argument_list|,
name|var
argument_list|)
expr_stmt|;
name|p_ann
operator|->
name|symbol_mem_tag
operator|=
name|ali
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|tag
argument_list|)
operator|=
name|TREE_READONLY
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|MTAG_GLOBAL
argument_list|(
name|tag
argument_list|)
operator|=
name|is_global_var
argument_list|(
name|var
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This represents the used range of a variable.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|used_part
block|{
name|HOST_WIDE_INT
name|minused
decl_stmt|;
name|HOST_WIDE_INT
name|maxused
decl_stmt|;
comment|/* True if we have an explicit use/def of some portion of this variable,      even if it is all of it. i.e. a.b = 5 or temp = a.b.  */
name|bool
name|explicit_uses
decl_stmt|;
comment|/* True if we have an implicit use/def of some portion of this      variable.  Implicit uses occur when we can't tell what part we      are referencing, and have to make conservative assumptions.  */
name|bool
name|implicit_uses
decl_stmt|;
comment|/* True if the structure is only written to or taken its address.  */
name|bool
name|write_only
decl_stmt|;
block|}
typedef|*
name|used_part_t
typedef|;
end_typedef

begin_comment
comment|/* An array of used_part structures, indexed by variable uid.  */
end_comment

begin_decl_stmt
specifier|static
name|htab_t
name|used_portions
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|used_part_map
block|{
name|unsigned
name|int
name|uid
decl_stmt|;
name|used_part_t
name|to
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Return true if the uid in the two used part maps are equal.  */
end_comment

begin_function
specifier|static
name|int
name|used_part_map_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|va
parameter_list|,
specifier|const
name|void
modifier|*
name|vb
parameter_list|)
block|{
specifier|const
name|struct
name|used_part_map
modifier|*
name|a
init|=
operator|(
specifier|const
expr|struct
name|used_part_map
operator|*
operator|)
name|va
decl_stmt|;
specifier|const
name|struct
name|used_part_map
modifier|*
name|b
init|=
operator|(
specifier|const
expr|struct
name|used_part_map
operator|*
operator|)
name|vb
decl_stmt|;
return|return
operator|(
name|a
operator|->
name|uid
operator|==
name|b
operator|->
name|uid
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Hash a from uid in a used_part_map.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|used_part_map_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|item
parameter_list|)
block|{
return|return
operator|(
operator|(
specifier|const
expr|struct
name|used_part_map
operator|*
operator|)
name|item
operator|)
operator|->
name|uid
return|;
block|}
end_function

begin_comment
comment|/* Free a used part map element.  */
end_comment

begin_function
specifier|static
name|void
name|free_used_part_map
parameter_list|(
name|void
modifier|*
name|item
parameter_list|)
block|{
name|free
argument_list|(
operator|(
operator|(
expr|struct
name|used_part_map
operator|*
operator|)
name|item
operator|)
operator|->
name|to
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|item
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Lookup a used_part structure for a UID.  */
end_comment

begin_function
specifier|static
name|used_part_t
name|up_lookup
parameter_list|(
name|unsigned
name|int
name|uid
parameter_list|)
block|{
name|struct
name|used_part_map
modifier|*
name|h
decl_stmt|,
name|in
decl_stmt|;
name|in
operator|.
name|uid
operator|=
name|uid
expr_stmt|;
name|h
operator|=
operator|(
expr|struct
name|used_part_map
operator|*
operator|)
name|htab_find_with_hash
argument_list|(
name|used_portions
argument_list|,
operator|&
name|in
argument_list|,
name|uid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|h
condition|)
return|return
name|NULL
return|;
return|return
name|h
operator|->
name|to
return|;
block|}
end_function

begin_comment
comment|/* Insert the pair UID, TO into the used part hashtable.  */
end_comment

begin_function
specifier|static
name|void
name|up_insert
parameter_list|(
name|unsigned
name|int
name|uid
parameter_list|,
name|used_part_t
name|to
parameter_list|)
block|{
name|struct
name|used_part_map
modifier|*
name|h
decl_stmt|;
name|void
modifier|*
modifier|*
name|loc
decl_stmt|;
name|h
operator|=
name|XNEW
argument_list|(
expr|struct
name|used_part_map
argument_list|)
expr_stmt|;
name|h
operator|->
name|uid
operator|=
name|uid
expr_stmt|;
name|h
operator|->
name|to
operator|=
name|to
expr_stmt|;
name|loc
operator|=
name|htab_find_slot_with_hash
argument_list|(
name|used_portions
argument_list|,
name|h
argument_list|,
name|uid
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|loc
operator|!=
name|NULL
condition|)
name|free
argument_list|(
operator|*
name|loc
argument_list|)
expr_stmt|;
operator|*
operator|(
expr|struct
name|used_part_map
operator|*
operator|*
operator|)
name|loc
operator|=
name|h
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a variable uid, UID, get or create the entry in the used portions    table for the variable.  */
end_comment

begin_function
specifier|static
name|used_part_t
name|get_or_create_used_part_for
parameter_list|(
name|size_t
name|uid
parameter_list|)
block|{
name|used_part_t
name|up
decl_stmt|;
if|if
condition|(
operator|(
name|up
operator|=
name|up_lookup
argument_list|(
name|uid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|up
operator|=
name|XCNEW
argument_list|(
expr|struct
name|used_part
argument_list|)
expr_stmt|;
name|up
operator|->
name|minused
operator|=
name|INT_MAX
expr_stmt|;
name|up
operator|->
name|maxused
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|explicit_uses
operator|=
name|false
expr_stmt|;
name|up
operator|->
name|implicit_uses
operator|=
name|false
expr_stmt|;
name|up
operator|->
name|write_only
operator|=
name|true
expr_stmt|;
block|}
return|return
name|up
return|;
block|}
end_function

begin_comment
comment|/* Create and return a structure sub-variable for field type FIELD at    offset OFFSET, with size SIZE, of variable VAR.  */
end_comment

begin_function
specifier|static
name|tree
name|create_sft
parameter_list|(
name|tree
name|var
parameter_list|,
name|tree
name|field
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|offset
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|size
parameter_list|)
block|{
name|var_ann_t
name|ann
decl_stmt|;
name|tree
name|subvar
init|=
name|create_tag_raw
argument_list|(
name|STRUCT_FIELD_TAG
argument_list|,
name|field
argument_list|,
literal|"SFT"
argument_list|)
decl_stmt|;
comment|/* We need to copy the various flags from VAR to SUBVAR, so that      they are is_global_var iff the original variable was.  */
name|DECL_CONTEXT
argument_list|(
name|subvar
argument_list|)
operator|=
name|DECL_CONTEXT
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|MTAG_GLOBAL
argument_list|(
name|subvar
argument_list|)
operator|=
name|DECL_EXTERNAL
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|subvar
argument_list|)
operator|=
name|TREE_PUBLIC
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|subvar
argument_list|)
operator|=
name|TREE_STATIC
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|subvar
argument_list|)
operator|=
name|TREE_READONLY
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|subvar
argument_list|)
operator|=
name|TREE_ADDRESSABLE
argument_list|(
name|var
argument_list|)
expr_stmt|;
comment|/* Add the new variable to REFERENCED_VARS.  */
name|ann
operator|=
name|get_var_ann
argument_list|(
name|subvar
argument_list|)
expr_stmt|;
name|ann
operator|->
name|symbol_mem_tag
operator|=
name|NULL
expr_stmt|;
name|add_referenced_var
argument_list|(
name|subvar
argument_list|)
expr_stmt|;
name|SFT_PARENT_VAR
argument_list|(
name|subvar
argument_list|)
operator|=
name|var
expr_stmt|;
name|SFT_OFFSET
argument_list|(
name|subvar
argument_list|)
operator|=
name|offset
expr_stmt|;
name|SFT_SIZE
argument_list|(
name|subvar
argument_list|)
operator|=
name|size
expr_stmt|;
return|return
name|subvar
return|;
block|}
end_function

begin_comment
comment|/* Given an aggregate VAR, create the subvariables that represent its    fields.  */
end_comment

begin_function
specifier|static
name|void
name|create_overlap_variables_for
parameter_list|(
name|tree
name|var
parameter_list|)
block|{
name|VEC
argument_list|(
name|fieldoff_s
argument_list|,
name|heap
argument_list|)
operator|*
name|fieldstack
operator|=
name|NULL
expr_stmt|;
name|used_part_t
name|up
decl_stmt|;
name|size_t
name|uid
init|=
name|DECL_UID
argument_list|(
name|var
argument_list|)
decl_stmt|;
name|up
operator|=
name|up_lookup
argument_list|(
name|uid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|up
operator|||
name|up
operator|->
name|write_only
condition|)
return|return;
name|push_fields_onto_fieldstack
argument_list|(
name|TREE_TYPE
argument_list|(
name|var
argument_list|)
argument_list|,
operator|&
name|fieldstack
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|VEC_length
argument_list|(
name|fieldoff_s
argument_list|,
name|fieldstack
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|subvar_t
modifier|*
name|subvars
decl_stmt|;
name|fieldoff_s
modifier|*
name|fo
decl_stmt|;
name|bool
name|notokay
init|=
name|false
decl_stmt|;
name|int
name|fieldcount
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|HOST_WIDE_INT
name|lastfooffset
init|=
operator|-
literal|1
decl_stmt|;
name|HOST_WIDE_INT
name|lastfosize
init|=
operator|-
literal|1
decl_stmt|;
name|tree
name|lastfotype
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Not all fields have DECL_SIZE set, and those that don't, we don't 	 know their size, and thus, can't handle. 	 The same is true of fields with DECL_SIZE that is not an integer 	 constant (such as variable sized fields). 	 Fields with offsets which are not constant will have an offset< 0  	 We *could* handle fields that are constant sized arrays, but 	 currently don't.  Doing so would require some extra changes to 	 tree-ssa-operands.c.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|fieldoff_s
argument_list|,
name|fieldstack
argument_list|,
name|i
argument_list|,
name|fo
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|fo
operator|->
name|size
operator|||
name|TREE_CODE
argument_list|(
name|fo
operator|->
name|size
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|fo
operator|->
name|offset
operator|<
literal|0
condition|)
block|{
name|notokay
operator|=
name|true
expr_stmt|;
break|break;
block|}
name|fieldcount
operator|++
expr_stmt|;
block|}
comment|/* The current heuristic we use is as follows: 	 If the variable has no used portions in this function, no 	 structure vars are created for it. 	 Otherwise,          If the variable has less than SALIAS_MAX_IMPLICIT_FIELDS, 	 we always create structure vars for them. 	 If the variable has more than SALIAS_MAX_IMPLICIT_FIELDS, and 	 some explicit uses, we create structure vars for them. 	 If the variable has more than SALIAS_MAX_IMPLICIT_FIELDS, and 	 no explicit uses, we do not create structure vars for them.       */
if|if
condition|(
name|fieldcount
operator|>=
name|SALIAS_MAX_IMPLICIT_FIELDS
operator|&&
operator|!
name|up
operator|->
name|explicit_uses
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Variable "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|var
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" has no explicit uses in this function, and is> SALIAS_MAX_IMPLICIT_FIELDS, so skipping\n"
argument_list|)
expr_stmt|;
block|}
name|notokay
operator|=
name|true
expr_stmt|;
block|}
comment|/* Bail out, if we can't create overlap variables.  */
if|if
condition|(
name|notokay
condition|)
block|{
name|VEC_free
argument_list|(
name|fieldoff_s
argument_list|,
name|heap
argument_list|,
name|fieldstack
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Otherwise, create the variables.  */
name|subvars
operator|=
name|lookup_subvars_for_var
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|sort_fieldstack
argument_list|(
name|fieldstack
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|VEC_length
argument_list|(
name|fieldoff_s
argument_list|,
name|fieldstack
argument_list|)
init|;
name|VEC_iterate
argument_list|(
name|fieldoff_s
argument_list|,
name|fieldstack
argument_list|,
operator|--
name|i
argument_list|,
name|fo
argument_list|)
condition|;
control|)
block|{
name|subvar_t
name|sv
decl_stmt|;
name|HOST_WIDE_INT
name|fosize
decl_stmt|;
name|tree
name|currfotype
decl_stmt|;
name|fosize
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|fo
operator|->
name|size
argument_list|)
expr_stmt|;
name|currfotype
operator|=
name|fo
operator|->
name|type
expr_stmt|;
comment|/* If this field isn't in the used portion, 	     or it has the exact same offset and size as the last 	     field, skip it.  */
if|if
condition|(
operator|(
operator|(
name|fo
operator|->
name|offset
operator|<=
name|up
operator|->
name|minused
operator|&&
name|fo
operator|->
name|offset
operator|+
name|fosize
operator|<=
name|up
operator|->
name|minused
operator|)
operator|||
name|fo
operator|->
name|offset
operator|>=
name|up
operator|->
name|maxused
operator|)
operator|||
operator|(
name|fo
operator|->
name|offset
operator|==
name|lastfooffset
operator|&&
name|fosize
operator|==
name|lastfosize
operator|&&
name|currfotype
operator|==
name|lastfotype
operator|)
condition|)
continue|continue;
name|sv
operator|=
name|GGC_NEW
argument_list|(
expr|struct
name|subvar
argument_list|)
expr_stmt|;
name|sv
operator|->
name|next
operator|=
operator|*
name|subvars
expr_stmt|;
name|sv
operator|->
name|var
operator|=
name|create_sft
argument_list|(
name|var
argument_list|,
name|fo
operator|->
name|type
argument_list|,
name|fo
operator|->
name|offset
argument_list|,
name|fosize
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"structure field tag %s created for var %s"
argument_list|,
name|get_name
argument_list|(
name|sv
operator|->
name|var
argument_list|)
argument_list|,
name|get_name
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" offset "
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|SFT_OFFSET
argument_list|(
name|sv
operator|->
name|var
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" size "
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|SFT_SIZE
argument_list|(
name|sv
operator|->
name|var
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|lastfotype
operator|=
name|currfotype
expr_stmt|;
name|lastfooffset
operator|=
name|fo
operator|->
name|offset
expr_stmt|;
name|lastfosize
operator|=
name|fosize
expr_stmt|;
operator|*
name|subvars
operator|=
name|sv
expr_stmt|;
block|}
comment|/* Once we have created subvars, the original is no longer call 	 clobbered on its own.  Its call clobbered status depends 	 completely on the call clobbered status of the subvars.  	 add_referenced_var in the above loop will take care of 	 marking subvars of global variables as call clobbered for us 	 to start, since they are global as well.  */
name|clear_call_clobbered
argument_list|(
name|var
argument_list|)
expr_stmt|;
block|}
name|VEC_free
argument_list|(
name|fieldoff_s
argument_list|,
name|heap
argument_list|,
name|fieldstack
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find the conservative answer to the question of what portions of what     structures are used by this statement.  We assume that if we have a    component ref with a known size + offset, that we only need that part    of the structure.  For unknown cases, or cases where we do something    to the whole structure, we assume we need to create fields for the     entire structure.  */
end_comment

begin_function
specifier|static
name|tree
name|find_used_portions
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|walk_subtrees
parameter_list|,
name|void
modifier|*
name|lhs_p
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|tp
argument_list|)
condition|)
block|{
case|case
name|MODIFY_EXPR
case|:
comment|/* Recurse manually here to track whether the use is in the 	 LHS of an assignment.  */
name|find_used_portions
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|walk_subtrees
argument_list|,
name|tp
argument_list|)
expr_stmt|;
return|return
name|find_used_portions
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|walk_subtrees
argument_list|,
name|NULL
argument_list|)
return|;
case|case
name|REALPART_EXPR
case|:
case|case
name|IMAGPART_EXPR
case|:
case|case
name|COMPONENT_REF
case|:
case|case
name|ARRAY_REF
case|:
block|{
name|HOST_WIDE_INT
name|bitsize
decl_stmt|;
name|HOST_WIDE_INT
name|bitmaxsize
decl_stmt|;
name|HOST_WIDE_INT
name|bitpos
decl_stmt|;
name|tree
name|ref
decl_stmt|;
name|ref
operator|=
name|get_ref_base_and_extent
argument_list|(
operator|*
name|tp
argument_list|,
operator|&
name|bitpos
argument_list|,
operator|&
name|bitsize
argument_list|,
operator|&
name|bitmaxsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_P
argument_list|(
name|ref
argument_list|)
operator|&&
name|var_can_have_subvars
argument_list|(
name|ref
argument_list|)
operator|&&
name|bitmaxsize
operator|!=
operator|-
literal|1
condition|)
block|{
name|size_t
name|uid
init|=
name|DECL_UID
argument_list|(
name|ref
argument_list|)
decl_stmt|;
name|used_part_t
name|up
decl_stmt|;
name|up
operator|=
name|get_or_create_used_part_for
argument_list|(
name|uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitpos
operator|<=
name|up
operator|->
name|minused
condition|)
name|up
operator|->
name|minused
operator|=
name|bitpos
expr_stmt|;
if|if
condition|(
operator|(
name|bitpos
operator|+
name|bitmaxsize
operator|>=
name|up
operator|->
name|maxused
operator|)
condition|)
name|up
operator|->
name|maxused
operator|=
name|bitpos
operator|+
name|bitmaxsize
expr_stmt|;
if|if
condition|(
name|bitsize
operator|==
name|bitmaxsize
condition|)
name|up
operator|->
name|explicit_uses
operator|=
name|true
expr_stmt|;
else|else
name|up
operator|->
name|implicit_uses
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|!
name|lhs_p
condition|)
name|up
operator|->
name|write_only
operator|=
name|false
expr_stmt|;
name|up_insert
argument_list|(
name|uid
argument_list|,
name|up
argument_list|)
expr_stmt|;
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
block|}
break|break;
comment|/* This is here to make sure we mark the entire base variable as used 	 when you take its address.  Because our used portion analysis is 	 simple, we aren't looking at casts or pointer arithmetic to see what 	 happens when you take the address.  */
case|case
name|ADDR_EXPR
case|:
block|{
name|tree
name|var
init|=
name|get_base_address
argument_list|(
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|var
operator|&&
name|DECL_P
argument_list|(
name|var
argument_list|)
operator|&&
name|DECL_SIZE
argument_list|(
name|var
argument_list|)
operator|&&
name|var_can_have_subvars
argument_list|(
name|var
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_SIZE
argument_list|(
name|var
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|used_part_t
name|up
decl_stmt|;
name|size_t
name|uid
init|=
name|DECL_UID
argument_list|(
name|var
argument_list|)
decl_stmt|;
name|up
operator|=
name|get_or_create_used_part_for
argument_list|(
name|uid
argument_list|)
expr_stmt|;
name|up
operator|->
name|minused
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|maxused
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_SIZE
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
name|up
operator|->
name|implicit_uses
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|!
name|lhs_p
condition|)
name|up
operator|->
name|write_only
operator|=
name|false
expr_stmt|;
name|up_insert
argument_list|(
name|uid
argument_list|,
name|up
argument_list|)
expr_stmt|;
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
block|}
break|break;
case|case
name|CALL_EXPR
case|:
block|{
name|tree
modifier|*
name|arg
decl_stmt|;
for|for
control|(
name|arg
operator|=
operator|&
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
literal|1
argument_list|)
init|;
operator|*
name|arg
condition|;
name|arg
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|arg
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
operator|*
name|arg
argument_list|)
argument_list|)
operator|!=
name|ADDR_EXPR
condition|)
name|find_used_portions
argument_list|(
operator|&
name|TREE_VALUE
argument_list|(
operator|*
name|arg
argument_list|)
argument_list|,
name|walk_subtrees
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
case|case
name|VAR_DECL
case|:
case|case
name|PARM_DECL
case|:
case|case
name|RESULT_DECL
case|:
block|{
name|tree
name|var
init|=
operator|*
name|tp
decl_stmt|;
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|var
argument_list|)
operator|&&
name|var_can_have_subvars
argument_list|(
name|var
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_SIZE
argument_list|(
name|var
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|used_part_t
name|up
decl_stmt|;
name|size_t
name|uid
init|=
name|DECL_UID
argument_list|(
name|var
argument_list|)
decl_stmt|;
name|up
operator|=
name|get_or_create_used_part_for
argument_list|(
name|uid
argument_list|)
expr_stmt|;
name|up
operator|->
name|minused
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|maxused
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_SIZE
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
name|up
operator|->
name|implicit_uses
operator|=
name|true
expr_stmt|;
name|up_insert
argument_list|(
name|uid
argument_list|,
name|up
argument_list|)
expr_stmt|;
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
block|}
break|break;
default|default:
break|break;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Create structure field variables for structures used in this function.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|create_structure_vars
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|safe_referenced_var_iterator
name|rvi
decl_stmt|;
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
name|varvec
operator|=
name|NULL
expr_stmt|;
name|tree
name|var
decl_stmt|;
name|used_portions
operator|=
name|htab_create
argument_list|(
literal|10
argument_list|,
name|used_part_map_hash
argument_list|,
name|used_part_map_eq
argument_list|,
name|free_used_part_map
argument_list|)
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|block_stmt_iterator
name|bsi
decl_stmt|;
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
block|{
name|walk_tree_without_duplicates
argument_list|(
name|bsi_stmt_ptr
argument_list|(
name|bsi
argument_list|)
argument_list|,
name|find_used_portions
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
name|FOR_EACH_REFERENCED_VAR_SAFE
argument_list|(
argument|var
argument_list|,
argument|varvec
argument_list|,
argument|rvi
argument_list|)
block|{
comment|/* The C++ FE creates vars without DECL_SIZE set, for some reason.  */
if|if
condition|(
name|var
operator|&&
name|DECL_SIZE
argument_list|(
name|var
argument_list|)
operator|&&
name|var_can_have_subvars
argument_list|(
name|var
argument_list|)
operator|&&
operator|!
name|MTAG_P
argument_list|(
name|var
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_SIZE
argument_list|(
name|var
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|create_overlap_variables_for
argument_list|(
name|var
argument_list|)
expr_stmt|;
block|}
name|htab_delete
argument_list|(
name|used_portions
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|varvec
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|gate_structure_vars
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|flag_tree_salias
operator|!=
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_create_structure_vars
init|=
block|{
literal|"salias"
block|,
comment|/* name */
name|gate_structure_vars
block|,
comment|/* gate */
name|create_structure_vars
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
literal|0
block|,
comment|/* tv_id */
name|PROP_cfg
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_dump_func
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Reset the DECL_CALL_CLOBBERED flags on our referenced vars.  In    theory, this only needs to be done for globals.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|reset_cc_flags
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|var
decl_stmt|;
name|referenced_var_iterator
name|rvi
decl_stmt|;
name|FOR_EACH_REFERENCED_VAR
argument_list|(
argument|var
argument_list|,
argument|rvi
argument_list|)
name|DECL_CALL_CLOBBERED
argument_list|(
name|var
argument_list|)
operator|=
name|false
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_reset_cc_flags
init|=
block|{
name|NULL
block|,
comment|/* name */
name|NULL
block|,
comment|/* gate */
name|reset_cc_flags
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
literal|0
block|,
comment|/* tv_id */
name|PROP_referenced_vars
operator||
name|PROP_cfg
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
literal|0
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

end_unit

