begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Reload pseudo regs into hard regs for insns that require hard regs.    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"machmode.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"optabs.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"cselib.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_comment
comment|/* This file contains the reload pass of the compiler, which is    run after register allocation has been done.  It checks that    each insn is valid (operands required to be in registers really    are in registers of the proper class) and fixes up invalid ones    by copying values temporarily into registers for the insns    that need them.     The results of register allocation are described by the vector    reg_renumber; the insns still contain pseudo regs, but reg_renumber    can be used to find which hard reg, if any, a pseudo reg is in.     The technique we always use is to free up a few hard regs that are    called ``reload regs'', and for each place where a pseudo reg    must be in a hard reg, copy it temporarily into one of the reload regs.     Reload regs are allocated locally for every instruction that needs    reloads.  When there are pseudos which are allocated to a register that    has been chosen as a reload reg, such pseudos must be ``spilled''.    This means that they go to other hard regs, or to stack slots if no other    available hard regs can be found.  Spilling can invalidate more    insns, requiring additional need for reloads, so we must keep checking    until the process stabilizes.     For machines with different classes of registers, we must keep track    of the register class needed for each reload, and make sure that    we allocate enough reload registers of each class.     The file reload.c contains the code that checks one insn for    validity and reports the reloads that it needs.  This file    is in charge of scanning the entire rtl code, accumulating the    reload needs, spilling, assigning reload registers to use for    fixing up each insn, and generating the new insns to copy values    into the reload registers.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|REGISTER_MOVE_COST
end_ifndef

begin_define
define|#
directive|define
name|REGISTER_MOVE_COST
parameter_list|(
name|m
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|)
value|2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LOCAL_REGNO
end_ifndef

begin_define
define|#
directive|define
name|LOCAL_REGNO
parameter_list|(
name|REGNO
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* During reload_as_needed, element N contains a REG rtx for the hard reg    into which reg N has been reloaded (perhaps for a previous insn).  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|reg_last_reload_reg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Elt N nonzero if reg_last_reload_reg[N] has been set in this insn    for an output reload that stores into reg N.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|reg_has_output_reload
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indicates which hard regs are reload-registers for an output reload    in the current insn.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|reg_is_output_reload
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element N is the constant value to which pseudo reg N is equivalent,    or zero if pseudo reg N is not equivalent to a constant.    find_reloads looks at this in order to replace pseudo reg N    with the constant it stands for.  */
end_comment

begin_decl_stmt
name|rtx
modifier|*
name|reg_equiv_constant
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element N is a memory location to which pseudo reg N is equivalent,    prior to any register elimination (such as frame pointer to stack    pointer).  Depending on whether or not it is a valid address, this value    is transferred to either reg_equiv_address or reg_equiv_mem.  */
end_comment

begin_decl_stmt
name|rtx
modifier|*
name|reg_equiv_memory_loc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element N is the address of stack slot to which pseudo reg N is equivalent.    This is used when the address is not valid as a memory address    (because its displacement is too big for the machine.)  */
end_comment

begin_decl_stmt
name|rtx
modifier|*
name|reg_equiv_address
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element N is the memory slot to which pseudo reg N is equivalent,    or zero if pseudo reg N is not equivalent to a memory slot.  */
end_comment

begin_decl_stmt
name|rtx
modifier|*
name|reg_equiv_mem
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Widest width in which each pseudo reg is referred to (via subreg).  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
modifier|*
name|reg_max_ref_width
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element N is the list of insns that initialized reg N from its equivalent    constant or memory slot.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|reg_equiv_init
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Vector to remember old contents of reg_renumber before spilling.  */
end_comment

begin_decl_stmt
specifier|static
name|short
modifier|*
name|reg_old_renumber
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* During reload_as_needed, element N contains the last pseudo regno reloaded    into hard register N.  If that pseudo reg occupied more than one register,    reg_reloaded_contents points to that pseudo for each spill register in    use; all of these must remain set for an inheritance to occur.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|reg_reloaded_contents
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* During reload_as_needed, element N contains the insn for which    hard register N was last used.   Its contents are significant only    when reg_reloaded_valid is set for this register.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|reg_reloaded_insn
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indicate if reg_reloaded_insn / reg_reloaded_contents is valid */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|reg_reloaded_valid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indicate if the register was dead at the end of the reload.    This is only valid if reg_reloaded_contents is set and valid.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|reg_reloaded_dead
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of spill-regs so far; number of valid elements of spill_regs.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|n_spills
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* In parallel with spill_regs, contains REG rtx's for those regs.    Holds the last rtx used for any given reg, or 0 if it has never    been used for spilling yet.  This rtx is reused, provided it has    the proper mode.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|spill_reg_rtx
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* In parallel with spill_regs, contains nonzero for a spill reg    that was stored after the last time it was used.    The precise value is the insn generated to do the store.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|spill_reg_store
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the register that was stored with spill_reg_store.  This is a    copy of reload_out / reload_out_reg when the value was stored; if    reload_out is a MEM, spill_reg_stored_to will be set to reload_out_reg.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|spill_reg_stored_to
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This table is the inverse mapping of spill_regs:    indexed by hard reg number,    it contains the position of that reg in spill_regs,    or -1 for something that is not in spill_regs.     ?!?  This is no longer accurate.  */
end_comment

begin_decl_stmt
specifier|static
name|short
name|spill_reg_order
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This reg set indicates registers that can't be used as spill registers for    the currently processed insn.  These are the hard registers which are live    during the insn, but not allocated to pseudos, as well as fixed    registers.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|bad_spill_regs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These are the hard registers that can't be used as spill register for any    insn.  This includes registers used for user variables and registers that    we can't eliminate.  A register that appears in this set also can't be used    to retry register allocation.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|bad_spill_regs_global
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Describes order of use of registers for reloading    of spilled pseudo-registers.  `n_spills' is the number of    elements that are actually valid; new ones are added at the end.     Both spill_regs and spill_reg_order are used on two occasions:    once during find_reload_regs, where they keep track of the spill registers    for a single insn, but also during reload_as_needed where they show all    the registers ever used by reload.  For the latter case, the information    is calculated during finish_spills.  */
end_comment

begin_decl_stmt
specifier|static
name|short
name|spill_regs
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This vector of reg sets indicates, for each pseudo, which hard registers    may not be used for retrying global allocation because the register was    formerly spilled from one of them.  If we allowed reallocating a pseudo to    a register that it was already allocated to, reload might not    terminate.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
modifier|*
name|pseudo_previous_regs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This vector of reg sets indicates, for each pseudo, which hard    registers may not be used for retrying global allocation because they    are used as spill registers during one of the insns in which the    pseudo is live.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
modifier|*
name|pseudo_forbidden_regs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* All hard regs that have been used as spill registers for any insn are    marked in this set.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|used_spill_regs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index of last register assigned as a spill register.  We allocate in    a round-robin fashion.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|last_spill_reg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if indirect addressing is supported on the machine; this means    that spilling (REG n) does not require reloading it into a register in    order to do (MEM (REG n)) or (MEM (PLUS (REG n) (CONST_INT c))).  The    value indicates the level of indirect addressing supported, e.g., two    means that (MEM (MEM (REG n))) is also valid if (REG n) does not get    a hard register.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|spill_indirect_levels
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if indirect addressing is supported when the innermost MEM is    of the form (MEM (SYMBOL_REF sym)).  It is assumed that the level to    which these are valid is the same as spill_indirect_levels, above.  */
end_comment

begin_decl_stmt
name|char
name|indirect_symref_ok
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if an address (plus (reg frame_pointer) (reg ...)) is valid.  */
end_comment

begin_decl_stmt
name|char
name|double_reg_address_ok
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record the stack slot for each spilled hard register.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|spill_stack_slot
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Width allocated so far for that stack slot.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|spill_stack_slot_width
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record which pseudos needed to be spilled.  */
end_comment

begin_decl_stmt
specifier|static
name|regset_head
name|spilled_pseudos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used for communication between order_regs_for_reload and count_pseudo.    Used to avoid counting one pseudo twice.  */
end_comment

begin_decl_stmt
specifier|static
name|regset_head
name|pseudos_counted
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* First uid used by insns created by reload in this function.    Used in find_equiv_reg.  */
end_comment

begin_decl_stmt
name|int
name|reload_first_uid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag set by local-alloc or global-alloc if anything is live in    a call-clobbered reg across calls.  */
end_comment

begin_decl_stmt
name|int
name|caller_save_needed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to 1 while reload_as_needed is operating.    Required by some machines to handle any generated moves differently.  */
end_comment

begin_decl_stmt
name|int
name|reload_in_progress
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These arrays record the insn_code of insns that may be needed to    perform input and output reloads of special objects.  They provide a    place to pass a scratch register.  */
end_comment

begin_decl_stmt
name|enum
name|insn_code
name|reload_in_optab
index|[
name|NUM_MACHINE_MODES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|insn_code
name|reload_out_optab
index|[
name|NUM_MACHINE_MODES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This obstack is used for allocation of rtl during register elimination.    The allocated storage can be freed once find_reloads has processed the    insn.  */
end_comment

begin_decl_stmt
name|struct
name|obstack
name|reload_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Points to the beginning of the reload_obstack.  All insn_chain structures    are allocated first.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|reload_startobj
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The point after all insn_chain structures.  Used to quickly deallocate    memory allocated in copy_reloads during calculate_needs_all_insns.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|reload_firstobj
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This points before all local rtl generated by register elimination.    Used to quickly free all memory after processing one insn.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|reload_insn_firstobj
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_comment
comment|/* List of insn_chain instructions, one for every insn that reload needs to    examine.  */
end_comment

begin_decl_stmt
name|struct
name|insn_chain
modifier|*
name|reload_insn_chain
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|TREE_CODE
end_ifdef

begin_decl_stmt
specifier|extern
name|tree
name|current_function_decl
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|extern
name|union
name|tree_node
modifier|*
name|current_function_decl
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* List of all insns needing reloads.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|insn_chain
modifier|*
name|insns_need_reload
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* This structure is used to record information about register eliminations.    Each array entry describes one possible way of eliminating a register    in favor of another.   If there is more than one way of eliminating a    particular register, the most preferred should be specified first.  */
end_comment

begin_struct
struct|struct
name|elim_table
block|{
name|int
name|from
decl_stmt|;
comment|/* Register number to be eliminated.  */
name|int
name|to
decl_stmt|;
comment|/* Register number used as replacement.  */
name|int
name|initial_offset
decl_stmt|;
comment|/* Initial difference between values.  */
name|int
name|can_eliminate
decl_stmt|;
comment|/* Non-zero if this elimination can be done.  */
name|int
name|can_eliminate_previous
decl_stmt|;
comment|/* Value of CAN_ELIMINATE in previous scan over 				   insns made by reload.  */
name|int
name|offset
decl_stmt|;
comment|/* Current offset between the two regs.  */
name|int
name|previous_offset
decl_stmt|;
comment|/* Offset at end of previous insn.  */
name|int
name|ref_outside_mem
decl_stmt|;
comment|/* "to" has been referenced outside a MEM.  */
name|rtx
name|from_rtx
decl_stmt|;
comment|/* REG rtx for the register to be eliminated. 				   We cannot simply compare the number since 				   we might then spuriously replace a hard 				   register corresponding to a pseudo 				   assigned to the reg to be eliminated.  */
name|rtx
name|to_rtx
decl_stmt|;
comment|/* REG rtx for the replacement.  */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|elim_table
modifier|*
name|reg_eliminate
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is an intermediate structure to initialize the table.  It has    exactly the members provided by ELIMINABLE_REGS.  */
end_comment

begin_struct
specifier|static
specifier|const
struct|struct
name|elim_table_1
block|{
specifier|const
name|int
name|from
decl_stmt|;
specifier|const
name|int
name|to
decl_stmt|;
block|}
name|reg_eliminate_1
index|[]
init|=
comment|/* If a set of eliminable registers was specified, define the table from it.    Otherwise, default to the normal case of the frame pointer being    replaced by the stack pointer.  */
ifdef|#
directive|ifdef
name|ELIMINABLE_REGS
name|ELIMINABLE_REGS
struct|;
end_struct

begin_else
else|#
directive|else
end_else

begin_block
block|{
block|{
name|FRAME_POINTER_REGNUM
operator|,
name|STACK_POINTER_REGNUM
block|}
block|}
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|NUM_ELIMINABLE_REGS
value|ARRAY_SIZE (reg_eliminate_1)
end_define

begin_comment
comment|/* Record the number of pending eliminations that have an offset not equal    to their initial offset.  If non-zero, we use a new copy of each    replacement result in any insns encountered.  */
end_comment

begin_decl_stmt
name|int
name|num_not_at_initial_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Count the number of registers that we may be able to eliminate.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|num_eliminable
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* And the number of registers that are equivalent to a constant that    can be eliminated to frame_pointer / arg_pointer + constant.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|num_eliminable_invariants
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For each label, we record the offset of each elimination.  If we reach    a label by more than one path and an offset differs, we cannot do the    elimination.  This information is indexed by the number of the label.    The first table is an array of flags that records whether we have yet    encountered a label and the second table is an array of arrays, one    entry in the latter array for each elimination.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|offsets_known_at
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|int
argument_list|(
operator|*
name|offsets_at
argument_list|)
index|[
name|NUM_ELIMINABLE_REGS
index|]
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Number of labels in the current function.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|num_labels
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|void
name|replace_pseudos_in_call_usage
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|*
operator|,
expr|enum
name|machine_mode
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|maybe_fix_stack_asms
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|copy_reloads
name|PARAMS
argument_list|(
operator|(
expr|struct
name|insn_chain
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|calculate_needs_all_insns
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|find_reg
name|PARAMS
argument_list|(
operator|(
expr|struct
name|insn_chain
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|find_reload_regs
name|PARAMS
argument_list|(
operator|(
expr|struct
name|insn_chain
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|select_reload_regs
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|delete_caller_save_insns
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|spill_failure
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
expr|enum
name|reg_class
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|count_spilled_pseudo
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|delete_dead_insn
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|alter_reg
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_label_offsets
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|check_eliminable_occurrences
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|elimination_effects
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|eliminate_regs_in_insn
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|update_eliminable_offsets
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_not_eliminable
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_initial_elim_offsets
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|verify_initial_elim_offsets
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_initial_label_offsets
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_offsets_for_label
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_elim_table
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|update_eliminables
name|PARAMS
argument_list|(
operator|(
name|HARD_REG_SET
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|spill_hard_reg
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|finish_spills
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ior_hard_reg_set
name|PARAMS
argument_list|(
operator|(
name|HARD_REG_SET
operator|*
operator|,
name|HARD_REG_SET
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|scan_paradoxical_subregs
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|count_pseudo
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|order_regs_for_reload
name|PARAMS
argument_list|(
operator|(
expr|struct
name|insn_chain
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reload_as_needed
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|forget_old_reloads_1
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reload_reg_class_lower
name|PARAMS
argument_list|(
operator|(
specifier|const
name|PTR
operator|,
specifier|const
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_reload_reg_in_use
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|,
name|int
operator|,
expr|enum
name|reload_type
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|clear_reload_reg_in_use
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|,
name|int
operator|,
expr|enum
name|reload_type
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reload_reg_free_p
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|,
name|int
operator|,
expr|enum
name|reload_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reload_reg_free_for_value_p
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|int
operator|,
expr|enum
name|reload_type
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|free_for_value_p
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
expr|enum
name|machine_mode
operator|,
name|int
operator|,
expr|enum
name|reload_type
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reload_reg_reaches_end_p
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|,
name|int
operator|,
expr|enum
name|reload_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|allocate_reload_reg
name|PARAMS
argument_list|(
operator|(
expr|struct
name|insn_chain
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|conflicts_with_override
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|failed_reload
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|set_reload_reg
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|choose_reload_regs_init
name|PARAMS
argument_list|(
operator|(
expr|struct
name|insn_chain
operator|*
operator|,
name|rtx
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|choose_reload_regs
name|PARAMS
argument_list|(
operator|(
expr|struct
name|insn_chain
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|merge_assigned_reloads
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|emit_input_reload_insns
name|PARAMS
argument_list|(
operator|(
expr|struct
name|insn_chain
operator|*
operator|,
expr|struct
name|reload
operator|*
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|emit_output_reload_insns
name|PARAMS
argument_list|(
operator|(
expr|struct
name|insn_chain
operator|*
operator|,
expr|struct
name|reload
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_input_reload
name|PARAMS
argument_list|(
operator|(
expr|struct
name|insn_chain
operator|*
operator|,
expr|struct
name|reload
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_output_reload
name|PARAMS
argument_list|(
operator|(
expr|struct
name|insn_chain
operator|*
operator|,
expr|struct
name|reload
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|emit_reload_insns
name|PARAMS
argument_list|(
operator|(
expr|struct
name|insn_chain
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|delete_output_reload
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|delete_address_reloads
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|delete_address_reloads_1
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|inc_for_reload
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|constraint_accepts_reg_p
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reload_cse_regs_1
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reload_cse_noop_set_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reload_cse_simplify_set
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reload_cse_simplify_operands
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reload_combine
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reload_combine_note_use
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|*
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reload_combine_note_store
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reload_cse_move2add
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|move2add_note_store
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|add_auto_inc_notes
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|copy_eh_notes
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|HOST_WIDE_INT
name|sext_for_mode
name|PARAMS
argument_list|(
operator|(
expr|enum
name|machine_mode
operator|,
name|HOST_WIDE_INT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|failed_reload
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|set_reload_reg
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reload_cse_delete_noop_set
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reload_cse_simplify
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fixup_abnormal_edges
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|dump_needs
name|PARAMS
argument_list|(
operator|(
expr|struct
name|insn_chain
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Initialize the reload pass once per compilation.  */
end_comment

begin_function
name|void
name|init_reload
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
comment|/* Often (MEM (REG n)) is still valid even if (REG n) is put on the stack.      Set spill_indirect_levels to the number of levels such addressing is      permitted, zero if it is not permitted at all.  */
name|rtx
name|tem
init|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|LAST_VIRTUAL_REGISTER
operator|+
literal|1
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|4
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|spill_indirect_levels
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|memory_address_p
argument_list|(
name|QImode
argument_list|,
name|tem
argument_list|)
condition|)
block|{
name|spill_indirect_levels
operator|++
expr_stmt|;
name|tem
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|tem
argument_list|)
expr_stmt|;
block|}
comment|/* See if indirect addressing is valid for (MEM (SYMBOL_REF ...)).  */
name|tem
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
literal|"foo"
argument_list|)
argument_list|)
expr_stmt|;
name|indirect_symref_ok
operator|=
name|memory_address_p
argument_list|(
name|QImode
argument_list|,
name|tem
argument_list|)
expr_stmt|;
comment|/* See if reg+reg is a valid (and offsettable) address.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
name|tem
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|HARD_FRAME_POINTER_REGNUM
argument_list|)
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This way, we make sure that reg+reg is an offsettable address.  */
name|tem
operator|=
name|plus_constant
argument_list|(
name|tem
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|memory_address_p
argument_list|(
name|QImode
argument_list|,
name|tem
argument_list|)
condition|)
block|{
name|double_reg_address_ok
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* Initialize obstack for our rtl allocation.  */
name|gcc_obstack_init
argument_list|(
operator|&
name|reload_obstack
argument_list|)
expr_stmt|;
name|reload_startobj
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|reload_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|INIT_REG_SET
argument_list|(
operator|&
name|spilled_pseudos
argument_list|)
expr_stmt|;
name|INIT_REG_SET
argument_list|(
operator|&
name|pseudos_counted
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* List of insn chains that are currently unused.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|insn_chain
modifier|*
name|unused_insn_chains
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Allocate an empty insn_chain structure.  */
end_comment

begin_function
name|struct
name|insn_chain
modifier|*
name|new_insn_chain
parameter_list|()
block|{
name|struct
name|insn_chain
modifier|*
name|c
decl_stmt|;
if|if
condition|(
name|unused_insn_chains
operator|==
literal|0
condition|)
block|{
name|c
operator|=
operator|(
expr|struct
name|insn_chain
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|reload_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|insn_chain
argument_list|)
argument_list|)
expr_stmt|;
name|INIT_REG_SET
argument_list|(
operator|&
name|c
operator|->
name|live_throughout
argument_list|)
expr_stmt|;
name|INIT_REG_SET
argument_list|(
operator|&
name|c
operator|->
name|dead_or_set
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
name|unused_insn_chains
expr_stmt|;
name|unused_insn_chains
operator|=
name|c
operator|->
name|next
expr_stmt|;
block|}
name|c
operator|->
name|is_caller_save_insn
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|need_operand_change
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|need_reload
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|need_elim
operator|=
literal|0
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/* Small utility function to set all regs in hard reg set TO which are    allocated to pseudos in regset FROM.  */
end_comment

begin_function
name|void
name|compute_use_by_pseudos
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|)
name|HARD_REG_SET
modifier|*
name|to
decl_stmt|;
name|regset
name|from
decl_stmt|;
block|{
name|unsigned
name|int
name|regno
decl_stmt|;
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|from
argument_list|,
argument|FIRST_PSEUDO_REGISTER
argument_list|,
argument|regno
argument_list|,
argument|{        int r = reg_renumber[regno];        int nregs;         if (r<
literal|0
argument|) 	 {
comment|/* reload_combine uses the information from 	      BASIC_BLOCK->global_live_at_start, which might still 	      contain registers that have not actually been allocated 	      since they have an equivalence.  */
argument|if (! reload_completed) 	     abort (); 	 }        else 	 { 	   nregs = HARD_REGNO_NREGS (r, PSEUDO_REGNO_MODE (regno)); 	   while (nregs-->
literal|0
argument|) 	     SET_HARD_REG_BIT (*to, r + nregs); 	 }      }
argument_list|)
empty_stmt|;
block|}
end_function

begin_comment
comment|/* Replace all pseudos found in LOC with their corresponding    equivalences.  */
end_comment

begin_function
specifier|static
name|void
name|replace_pseudos_in_call_usage
parameter_list|(
name|loc
parameter_list|,
name|mem_mode
parameter_list|,
name|usage
parameter_list|)
name|rtx
modifier|*
name|loc
decl_stmt|;
name|enum
name|machine_mode
name|mem_mode
decl_stmt|;
name|rtx
name|usage
decl_stmt|;
block|{
name|rtx
name|x
init|=
operator|*
name|loc
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
operator|!
name|x
condition|)
return|return;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|REG
condition|)
block|{
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
return|return;
name|x
operator|=
name|eliminate_regs
argument_list|(
name|x
argument_list|,
name|mem_mode
argument_list|,
name|usage
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
operator|*
name|loc
condition|)
block|{
operator|*
name|loc
operator|=
name|x
expr_stmt|;
name|replace_pseudos_in_call_usage
argument_list|(
name|loc
argument_list|,
name|mem_mode
argument_list|,
name|usage
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|reg_equiv_constant
index|[
name|regno
index|]
condition|)
operator|*
name|loc
operator|=
name|reg_equiv_constant
index|[
name|regno
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|reg_equiv_mem
index|[
name|regno
index|]
condition|)
operator|*
name|loc
operator|=
name|reg_equiv_mem
index|[
name|regno
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|reg_equiv_address
index|[
name|regno
index|]
condition|)
operator|*
name|loc
operator|=
name|gen_rtx_MEM
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|reg_equiv_address
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|regno_reg_rtx
index|[
name|regno
index|]
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|regno_reg_rtx
index|[
name|regno
index|]
argument_list|)
operator|!=
name|regno
condition|)
operator|*
name|loc
operator|=
name|regno_reg_rtx
index|[
name|regno
index|]
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|MEM
condition|)
block|{
name|replace_pseudos_in_call_usage
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|usage
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Process each of our operands recursively.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
condition|;
name|i
operator|++
operator|,
name|fmt
operator|++
control|)
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'e'
condition|)
name|replace_pseudos_in_call_usage
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|mem_mode
argument_list|,
name|usage
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|replace_pseudos_in_call_usage
argument_list|(
operator|&
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|mem_mode
argument_list|,
name|usage
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Global variables used by reload and its subroutines.  */
end_comment

begin_comment
comment|/* Set during calculate_needs if an insn needs register elimination.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|something_needs_elimination
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set during calculate_needs if an insn needs an operand changed.  */
end_comment

begin_decl_stmt
name|int
name|something_needs_operands_changed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means we couldn't get enough spill regs.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|failure
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Main entry point for the reload pass.     FIRST is the first insn of the function being compiled.     GLOBAL nonzero means we were called from global_alloc    and should attempt to reallocate any pseudoregs that we    displace from hard regs we will use for reloads.    If GLOBAL is zero, we do not have enough information to do that,    so any pseudo reg that is spilled must go to the stack.     Return value is nonzero if reload failed    and we must not do any more for this function.  */
end_comment

begin_function
name|int
name|reload
parameter_list|(
name|first
parameter_list|,
name|global
parameter_list|)
name|rtx
name|first
decl_stmt|;
name|int
name|global
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|struct
name|elim_table
modifier|*
name|ep
decl_stmt|;
comment|/* The two pointers used to track the true location of the memory used      for label offsets.  */
name|char
modifier|*
name|real_known_ptr
init|=
name|NULL
decl_stmt|;
name|int
argument_list|(
operator|*
name|real_at_ptr
argument_list|)
index|[
name|NUM_ELIMINABLE_REGS
index|]
expr_stmt|;
comment|/* Make sure even insns with volatile mem refs are recognizable.  */
name|init_recog
argument_list|()
expr_stmt|;
name|failure
operator|=
literal|0
expr_stmt|;
name|reload_firstobj
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|reload_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Make sure that the last insn in the chain      is not something that needs reloading.  */
name|emit_note
argument_list|(
name|NULL
argument_list|,
name|NOTE_INSN_DELETED
argument_list|)
expr_stmt|;
comment|/* Enable find_equiv_reg to distinguish insns made by reload.  */
name|reload_first_uid
operator|=
name|get_max_uid
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|SECONDARY_MEMORY_NEEDED
comment|/* Initialize the secondary memory table.  */
name|clear_secondary_mem
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* We don't have a stack slot for any spill reg yet.  */
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|spill_stack_slot
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|spill_stack_slot
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|spill_stack_slot_width
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|spill_stack_slot_width
argument_list|)
expr_stmt|;
comment|/* Initialize the save area information for caller-save, in case some      are needed.  */
name|init_save_areas
argument_list|()
expr_stmt|;
comment|/* Compute which hard registers are now in use      as homes for pseudo registers.      This is done here rather than (eg) in global_alloc      because this point is reached even if not optimizing.  */
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
name|mark_home_live
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* A function that receives a nonlocal goto must save all call-saved      registers.  */
if|if
condition|(
name|current_function_has_nonlocal_label
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|call_used_regs
index|[
name|i
index|]
operator|&&
operator|!
name|fixed_regs
index|[
name|i
index|]
operator|&&
operator|!
name|LOCAL_REGNO
argument_list|(
name|i
argument_list|)
condition|)
name|regs_ever_live
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Find all the pseudo registers that didn't get hard regs      but do have known equivalent constants or memory slots.      These include parameters (known equivalent to parameter slots)      and cse'd or loop-moved constant memory addresses.       Record constant equivalents in reg_equiv_constant      so they will be substituted by find_reloads.      Record memory equivalents in reg_mem_equiv so they can      be substituted eventually by altering the REG-rtx's.  */
name|reg_equiv_constant
operator|=
operator|(
name|rtx
operator|*
operator|)
name|xcalloc
argument_list|(
name|max_regno
argument_list|,
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|reg_equiv_mem
operator|=
operator|(
name|rtx
operator|*
operator|)
name|xcalloc
argument_list|(
name|max_regno
argument_list|,
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|reg_equiv_init
operator|=
operator|(
name|rtx
operator|*
operator|)
name|xcalloc
argument_list|(
name|max_regno
argument_list|,
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|reg_equiv_address
operator|=
operator|(
name|rtx
operator|*
operator|)
name|xcalloc
argument_list|(
name|max_regno
argument_list|,
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|reg_max_ref_width
operator|=
operator|(
name|unsigned
name|int
operator|*
operator|)
name|xcalloc
argument_list|(
name|max_regno
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|reg_old_renumber
operator|=
operator|(
name|short
operator|*
operator|)
name|xcalloc
argument_list|(
name|max_regno
argument_list|,
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|reg_old_renumber
argument_list|,
name|reg_renumber
argument_list|,
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|pseudo_forbidden_regs
operator|=
operator|(
name|HARD_REG_SET
operator|*
operator|)
name|xmalloc
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|HARD_REG_SET
argument_list|)
argument_list|)
expr_stmt|;
name|pseudo_previous_regs
operator|=
operator|(
name|HARD_REG_SET
operator|*
operator|)
name|xcalloc
argument_list|(
name|max_regno
argument_list|,
sizeof|sizeof
argument_list|(
name|HARD_REG_SET
argument_list|)
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|bad_spill_regs_global
argument_list|)
expr_stmt|;
comment|/* Look for REG_EQUIV notes; record what each pseudo is equivalent to.      Also find all paradoxical subregs and find largest such for each pseudo.      On machines with small register classes, record hard registers that      are used for user variables.  These can never be used for spills.      Also look for a "constant" REG_SETJMP.  This means that all      caller-saved registers must be marked live.  */
name|num_eliminable_invariants
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* We may introduce USEs that we want to remove at the end, so 	 we'll mark them with QImode.  Make sure there are no 	 previously-marked insns left by say regmove.  */
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|USE
operator|&&
name|GET_MODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|VOIDmode
condition|)
name|PUT_MODE
argument_list|(
name|insn
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_SETJMP
argument_list|,
name|NULL
argument_list|)
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|call_used_regs
index|[
name|i
index|]
condition|)
name|regs_ever_live
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|set
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUIV
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
if|if
condition|(
name|note
ifdef|#
directive|ifdef
name|LEGITIMATE_PIC_OPERAND_P
operator|&&
operator|(
operator|!
name|function_invariant_p
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
operator|!
name|flag_pic
comment|/* A function invariant is often CONSTANT_P but may 		     include a register.  We promise to only pass 		     CONSTANT_P objects to LEGITIMATE_PIC_OPERAND_P.  */
operator|||
operator|(
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|LEGITIMATE_PIC_OPERAND_P
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|)
endif|#
directive|endif
condition|)
block|{
name|rtx
name|x
init|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|i
operator|=
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|LAST_VIRTUAL_REGISTER
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
block|{
comment|/* Always unshare the equivalence, so we can 			 substitute into this insn without touching the 			 equivalence.  */
name|reg_equiv_memory_loc
index|[
name|i
index|]
operator|=
name|copy_rtx
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|function_invariant_p
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
condition|)
block|{
comment|/* This is PLUS of frame pointer and a constant, 			     and might be shared.  Unshare it.  */
name|reg_equiv_constant
index|[
name|i
index|]
operator|=
name|copy_rtx
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|num_eliminable_invariants
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|==
name|frame_pointer_rtx
operator|||
name|x
operator|==
name|arg_pointer_rtx
condition|)
block|{
name|reg_equiv_constant
index|[
name|i
index|]
operator|=
name|x
expr_stmt|;
name|num_eliminable_invariants
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|LEGITIMATE_CONSTANT_P
argument_list|(
name|x
argument_list|)
condition|)
name|reg_equiv_constant
index|[
name|i
index|]
operator|=
name|x
expr_stmt|;
else|else
name|reg_equiv_memory_loc
index|[
name|i
index|]
operator|=
name|force_const_mem
argument_list|(
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
else|else
continue|continue;
comment|/* If this register is being made equivalent to a MEM 		     and the MEM is not SET_SRC, the equivalencing insn 		     is one with the MEM as a SET_DEST and it occurs later. 		     So don't mark this insn now.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
operator|||
name|rtx_equal_p
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|x
argument_list|)
condition|)
name|reg_equiv_init
index|[
name|i
index|]
operator|=
name|gen_rtx_INSN_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|insn
argument_list|,
name|reg_equiv_init
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* If this insn is setting a MEM from a register equivalent to it, 	 this is the equivalencing insn.  */
elseif|else
if|if
condition|(
name|set
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|reg_equiv_memory_loc
index|[
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
index|]
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|reg_equiv_memory_loc
index|[
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
index|]
argument_list|)
condition|)
name|reg_equiv_init
index|[
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
index|]
operator|=
name|gen_rtx_INSN_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|insn
argument_list|,
name|reg_equiv_init
index|[
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|scan_paradoxical_subregs
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|init_elim_table
argument_list|()
expr_stmt|;
name|num_labels
operator|=
name|max_label_num
argument_list|()
operator|-
name|get_first_label_num
argument_list|()
expr_stmt|;
comment|/* Allocate the tables used to store offset information at labels.  */
comment|/* We used to use alloca here, but the size of what it would try to      allocate would occasionally cause it to exceed the stack limit and      cause a core dump.  */
name|real_known_ptr
operator|=
name|xmalloc
argument_list|(
name|num_labels
argument_list|)
expr_stmt|;
name|real_at_ptr
operator|=
operator|(
name|int
argument_list|(
operator|*
argument_list|)
index|[
name|NUM_ELIMINABLE_REGS
index|]
operator|)
name|xmalloc
argument_list|(
name|num_labels
operator|*
name|NUM_ELIMINABLE_REGS
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|offsets_known_at
operator|=
name|real_known_ptr
operator|-
name|get_first_label_num
argument_list|()
expr_stmt|;
name|offsets_at
operator|=
operator|(
name|int
argument_list|(
operator|*
argument_list|)
index|[
name|NUM_ELIMINABLE_REGS
index|]
operator|)
operator|(
name|real_at_ptr
operator|-
name|get_first_label_num
argument_list|()
operator|)
expr_stmt|;
comment|/* Alter each pseudo-reg rtx to contain its hard reg number.      Assign stack slots to the pseudos that lack hard regs or equivalents.      Do not touch virtual registers.  */
for|for
control|(
name|i
operator|=
name|LAST_VIRTUAL_REGISTER
operator|+
literal|1
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
name|alter_reg
argument_list|(
name|i
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* If we have some registers we think can be eliminated, scan all insns to      see if there is an insn that sets one of these registers to something      other than itself plus a constant.  If so, the register cannot be      eliminated.  Doing this scan here eliminates an extra pass through the      main reload loop in the most common case where register elimination      cannot be done.  */
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
operator|&&
name|num_eliminable
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|mark_not_eliminable
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|maybe_fix_stack_asms
argument_list|()
expr_stmt|;
name|insns_need_reload
operator|=
literal|0
expr_stmt|;
name|something_needs_elimination
operator|=
literal|0
expr_stmt|;
comment|/* Initialize to -1, which means take the first spill register.  */
name|last_spill_reg
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Spill any hard regs that we know we can't eliminate.  */
name|CLEAR_HARD_REG_SET
argument_list|(
name|used_spill_regs
argument_list|)
expr_stmt|;
for|for
control|(
name|ep
operator|=
name|reg_eliminate
init|;
name|ep
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|ep
operator|++
control|)
if|if
condition|(
operator|!
name|ep
operator|->
name|can_eliminate
condition|)
name|spill_hard_reg
argument_list|(
name|ep
operator|->
name|from
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
name|HARD_FRAME_POINTER_REGNUM
operator|!=
name|FRAME_POINTER_REGNUM
if|if
condition|(
name|frame_pointer_needed
condition|)
name|spill_hard_reg
argument_list|(
name|HARD_FRAME_POINTER_REGNUM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|finish_spills
argument_list|(
name|global
argument_list|)
expr_stmt|;
comment|/* From now on, we may need to generate moves differently.  We may also      allow modifications of insns which cause them to not be recognized.      Any such modifications will be cleaned up during reload itself.  */
name|reload_in_progress
operator|=
literal|1
expr_stmt|;
comment|/* This loop scans the entire function each go-round      and repeats until one repetition spills no additional hard regs.  */
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|something_changed
decl_stmt|;
name|int
name|did_spill
decl_stmt|;
name|HOST_WIDE_INT
name|starting_frame_size
decl_stmt|;
comment|/* Round size of stack frame to stack_alignment_needed.  This must be done 	 here because the stack size may be a part of the offset computation 	 for register elimination, and there might have been new stack slots 	 created in the last iteration of this loop.  */
if|if
condition|(
name|cfun
operator|->
name|stack_alignment_needed
condition|)
name|assign_stack_local
argument_list|(
name|BLKmode
argument_list|,
literal|0
argument_list|,
name|cfun
operator|->
name|stack_alignment_needed
argument_list|)
expr_stmt|;
name|starting_frame_size
operator|=
name|get_frame_size
argument_list|()
expr_stmt|;
name|set_initial_elim_offsets
argument_list|()
expr_stmt|;
name|set_initial_label_offsets
argument_list|()
expr_stmt|;
comment|/* For each pseudo register that has an equivalent location defined, 	 try to eliminate any eliminable registers (such as the frame pointer) 	 assuming initial offsets for the replacement register, which 	 is the normal case.  	 If the resulting location is directly addressable, substitute 	 the MEM we just got directly for the old REG.  	 If it is not addressable but is a constant or the sum of a hard reg 	 and constant, it is probably not addressable because the constant is 	 out of range, in that case record the address; we will generate 	 hairy code to compute the address in a register each time it is 	 needed.  Similarly if it is a hard register, but one that is not 	 valid as an address register.  	 If the location is not addressable, but does not have one of the 	 above forms, assign a stack slot.  We have to do this to avoid the 	 potential of producing lots of reloads if, e.g., a location involves 	 a pseudo that didn't get a hard register and has an equivalent memory 	 location that also involves a pseudo that didn't get a hard register.  	 Perhaps at some point we will improve reload_when_needed handling 	 so this problem goes away.  But that's very hairy.  */
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reg_renumber
index|[
name|i
index|]
operator|<
literal|0
operator|&&
name|reg_equiv_memory_loc
index|[
name|i
index|]
condition|)
block|{
name|rtx
name|x
init|=
name|eliminate_regs
argument_list|(
name|reg_equiv_memory_loc
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
if|if
condition|(
name|strict_memory_address_p
argument_list|(
name|GET_MODE
argument_list|(
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|reg_equiv_mem
index|[
name|i
index|]
operator|=
name|x
operator|,
name|reg_equiv_address
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
name|reg_equiv_address
index|[
name|i
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|,
name|reg_equiv_mem
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* Make a new stack slot.  Then indicate that something 		   changed so we go back and recompute offsets for 		   eliminable registers because the allocation of memory 		   below might change some offset.  reg_equiv_{mem,address} 		   will be set up for this pseudo on the next pass around 		   the loop.  */
name|reg_equiv_memory_loc
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|reg_equiv_init
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|alter_reg
argument_list|(
name|i
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|caller_save_needed
condition|)
name|setup_save_areas
argument_list|()
expr_stmt|;
comment|/* If we allocated another stack slot, redo elimination bookkeeping.  */
if|if
condition|(
name|starting_frame_size
operator|!=
name|get_frame_size
argument_list|()
condition|)
continue|continue;
if|if
condition|(
name|caller_save_needed
condition|)
block|{
name|save_call_clobbered_regs
argument_list|()
expr_stmt|;
comment|/* That might have allocated new insn_chain structures.  */
name|reload_firstobj
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|reload_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|calculate_needs_all_insns
argument_list|(
name|global
argument_list|)
expr_stmt|;
name|CLEAR_REG_SET
argument_list|(
operator|&
name|spilled_pseudos
argument_list|)
expr_stmt|;
name|did_spill
operator|=
literal|0
expr_stmt|;
name|something_changed
operator|=
literal|0
expr_stmt|;
comment|/* If we allocated any new memory locations, make another pass 	 since it might have changed elimination offsets.  */
if|if
condition|(
name|starting_frame_size
operator|!=
name|get_frame_size
argument_list|()
condition|)
name|something_changed
operator|=
literal|1
expr_stmt|;
block|{
name|HARD_REG_SET
name|to_spill
decl_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|to_spill
argument_list|)
expr_stmt|;
name|update_eliminables
argument_list|(
operator|&
name|to_spill
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|to_spill
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|spill_hard_reg
argument_list|(
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|did_spill
operator|=
literal|1
expr_stmt|;
comment|/* Regardless of the state of spills, if we previously had 		 a register that we thought we could eliminate, but no can 		 not eliminate, we must run another pass.  		 Consider pseudos which have an entry in reg_equiv_* which 		 reference an eliminable register.  We must make another pass 		 to update reg_equiv_* so that we do not substitute in the 		 old value from when we thought the elimination could be 		 performed.  */
name|something_changed
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|select_reload_regs
argument_list|()
expr_stmt|;
if|if
condition|(
name|failure
condition|)
goto|goto
name|failed
goto|;
if|if
condition|(
name|insns_need_reload
operator|!=
literal|0
operator|||
name|did_spill
condition|)
name|something_changed
operator||=
name|finish_spills
argument_list|(
name|global
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|something_changed
condition|)
break|break;
if|if
condition|(
name|caller_save_needed
condition|)
name|delete_caller_save_insns
argument_list|()
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|reload_obstack
argument_list|,
name|reload_firstobj
argument_list|)
expr_stmt|;
block|}
comment|/* If global-alloc was run, notify it of any register eliminations we have      done.  */
if|if
condition|(
name|global
condition|)
for|for
control|(
name|ep
operator|=
name|reg_eliminate
init|;
name|ep
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|ep
operator|++
control|)
if|if
condition|(
name|ep
operator|->
name|can_eliminate
condition|)
name|mark_elimination
argument_list|(
name|ep
operator|->
name|from
argument_list|,
name|ep
operator|->
name|to
argument_list|)
expr_stmt|;
comment|/* If a pseudo has no hard reg, delete the insns that made the equivalence.      If that insn didn't set the register (i.e., it copied the register to      memory), just delete that insn instead of the equivalencing insn plus      anything now dead.  If we call delete_dead_insn on that insn, we may      delete the insn that actually sets the register if the register dies      there and that is incorrect.  */
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|reg_renumber
index|[
name|i
index|]
operator|<
literal|0
operator|&&
name|reg_equiv_init
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|rtx
name|list
decl_stmt|;
for|for
control|(
name|list
operator|=
name|reg_equiv_init
index|[
name|i
index|]
init|;
name|list
condition|;
name|list
operator|=
name|XEXP
argument_list|(
name|list
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|rtx
name|equiv_insn
init|=
name|XEXP
argument_list|(
name|list
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* If we already deleted the insn or if it may trap, we can't 		 delete it.  The latter case shouldn't happen, but can 		 if an insn has a variable address, gets a REG_EH_REGION 		 note added to it, and then gets converted into an load 		 from a constant address.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|equiv_insn
argument_list|)
operator|==
name|NOTE
operator|||
name|can_throw_internal
argument_list|(
name|equiv_insn
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|reg_set_p
argument_list|(
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|,
name|PATTERN
argument_list|(
name|equiv_insn
argument_list|)
argument_list|)
condition|)
name|delete_dead_insn
argument_list|(
name|equiv_insn
argument_list|)
expr_stmt|;
else|else
block|{
name|PUT_CODE
argument_list|(
name|equiv_insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|equiv_insn
argument_list|)
operator|=
literal|0
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|equiv_insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Use the reload registers where necessary      by generating move instructions to move the must-be-register      values into or out of the reload registers.  */
if|if
condition|(
name|insns_need_reload
operator|!=
literal|0
operator|||
name|something_needs_elimination
operator|||
name|something_needs_operands_changed
condition|)
block|{
name|HOST_WIDE_INT
name|old_frame_size
init|=
name|get_frame_size
argument_list|()
decl_stmt|;
name|reload_as_needed
argument_list|(
name|global
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_frame_size
operator|!=
name|get_frame_size
argument_list|()
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|num_eliminable
condition|)
name|verify_initial_elim_offsets
argument_list|()
expr_stmt|;
block|}
comment|/* If we were able to eliminate the frame pointer, show that it is no      longer live at the start of any basic block.  If it ls live by      virtue of being in a pseudo, that pseudo will be marked live      and hence the frame pointer will be known to be live via that      pseudo.  */
if|if
condition|(
operator|!
name|frame_pointer_needed
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
name|CLEAR_REGNO_REG_SET
argument_list|(
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
operator|->
name|global_live_at_start
argument_list|,
name|HARD_FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
comment|/* Come here (with failure set nonzero) if we can't get enough spill regs      and we decide not to abort about it.  */
name|failed
label|:
name|CLEAR_REG_SET
argument_list|(
operator|&
name|spilled_pseudos
argument_list|)
expr_stmt|;
name|reload_in_progress
operator|=
literal|0
expr_stmt|;
comment|/* Now eliminate all pseudo regs by modifying them into      their equivalent memory references.      The REG-rtx's for the pseudos are modified in place,      so all insns that used to refer to them now refer to memory.       For a reg that has a reg_equiv_address, all those insns      were changed by reloading so that no insns refer to it any longer;      but the DECL_RTL of a variable decl may refer to it,      and if so this causes the debugging info to mention the variable.  */
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|addr
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|reg_equiv_mem
index|[
name|i
index|]
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|reg_equiv_mem
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_equiv_address
index|[
name|i
index|]
condition|)
name|addr
operator|=
name|reg_equiv_address
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|addr
condition|)
block|{
if|if
condition|(
name|reg_renumber
index|[
name|i
index|]
operator|<
literal|0
condition|)
block|{
name|rtx
name|reg
init|=
name|regno_reg_rtx
index|[
name|i
index|]
decl_stmt|;
name|PUT_CODE
argument_list|(
name|reg
argument_list|,
name|MEM
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
operator|=
name|addr
expr_stmt|;
name|REG_USERVAR_P
argument_list|(
name|reg
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|reg_equiv_memory_loc
index|[
name|i
index|]
condition|)
name|MEM_COPY_ATTRIBUTES
argument_list|(
name|reg
argument_list|,
name|reg_equiv_memory_loc
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|RTX_UNCHANGING_P
argument_list|(
name|reg
argument_list|)
operator|=
name|MEM_IN_STRUCT_P
argument_list|(
name|reg
argument_list|)
operator|=
name|MEM_SCALAR_P
argument_list|(
name|reg
argument_list|)
operator|=
literal|0
expr_stmt|;
name|MEM_ATTRS
argument_list|(
name|reg
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|reg_equiv_mem
index|[
name|i
index|]
condition|)
name|XEXP
argument_list|(
name|reg_equiv_mem
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
operator|=
name|addr
expr_stmt|;
block|}
block|}
comment|/* We must set reload_completed now since the cleanup_subreg_operands call      below will re-recognize each insn and reload may have generated insns      which are only valid during and after reload.  */
name|reload_completed
operator|=
literal|1
expr_stmt|;
comment|/* Make a pass over all the insns and delete all USEs which we inserted      only to tag a REG_EQUAL note on them.  Remove all REG_DEAD and REG_UNUSED      notes.  Delete all CLOBBER insns that don't refer to the return value      and simplify (subreg (reg)) operands.  Also remove all REG_RETVAL and      REG_LIBCALL notes since they are no longer useful or accurate.  Strip      and regenerate REG_INC notes that may have been moved around.  */
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
modifier|*
name|pnote
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
name|replace_pseudos_in_call_usage
argument_list|(
operator|&
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
argument_list|,
name|VOIDmode
argument_list|,
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|USE
comment|/* We mark with QImode USEs introduced by reload itself.  */
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|insn
argument_list|)
operator|==
name|QImode
operator|||
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
operator|!
name|REG_FUNCTION_VALUE_P
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
block|{
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|pnote
operator|=
operator|&
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|pnote
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
operator|*
name|pnote
argument_list|)
operator|==
name|REG_DEAD
operator|||
name|REG_NOTE_KIND
argument_list|(
operator|*
name|pnote
argument_list|)
operator|==
name|REG_UNUSED
operator|||
name|REG_NOTE_KIND
argument_list|(
operator|*
name|pnote
argument_list|)
operator|==
name|REG_INC
operator|||
name|REG_NOTE_KIND
argument_list|(
operator|*
name|pnote
argument_list|)
operator|==
name|REG_RETVAL
operator|||
name|REG_NOTE_KIND
argument_list|(
operator|*
name|pnote
argument_list|)
operator|==
name|REG_LIBCALL
condition|)
operator|*
name|pnote
operator|=
name|XEXP
argument_list|(
operator|*
name|pnote
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|pnote
operator|=
operator|&
name|XEXP
argument_list|(
operator|*
name|pnote
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
name|add_auto_inc_notes
argument_list|(
name|insn
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* And simplify (subreg (reg)) if it appears as an operand.  */
name|cleanup_subreg_operands
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* If we are doing stack checking, give a warning if this function's      frame size is larger than we expect.  */
if|if
condition|(
name|flag_stack_check
operator|&&
operator|!
name|STACK_CHECK_BUILTIN
condition|)
block|{
name|HOST_WIDE_INT
name|size
init|=
name|get_frame_size
argument_list|()
operator|+
name|STACK_CHECK_FIXED_FRAME_SIZE
decl_stmt|;
specifier|static
name|int
name|verbose_warned
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
operator|&&
operator|!
name|fixed_regs
index|[
name|i
index|]
operator|&&
name|call_used_regs
index|[
name|i
index|]
condition|)
name|size
operator|+=
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|STACK_CHECK_MAX_FRAME_SIZE
condition|)
block|{
name|warning
argument_list|(
literal|"frame size too large for reliable stack checking"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|verbose_warned
condition|)
block|{
name|warning
argument_list|(
literal|"try reducing the number of local variables"
argument_list|)
expr_stmt|;
name|verbose_warned
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* Indicate that we no longer have known memory locations or constants.  */
if|if
condition|(
name|reg_equiv_constant
condition|)
name|free
argument_list|(
name|reg_equiv_constant
argument_list|)
expr_stmt|;
name|reg_equiv_constant
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|reg_equiv_memory_loc
condition|)
name|free
argument_list|(
name|reg_equiv_memory_loc
argument_list|)
expr_stmt|;
name|reg_equiv_memory_loc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|real_known_ptr
condition|)
name|free
argument_list|(
name|real_known_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|real_at_ptr
condition|)
name|free
argument_list|(
name|real_at_ptr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reg_equiv_mem
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reg_equiv_init
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reg_equiv_address
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reg_max_ref_width
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reg_old_renumber
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pseudo_previous_regs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pseudo_forbidden_regs
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|used_spill_regs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_spills
condition|;
name|i
operator|++
control|)
name|SET_HARD_REG_BIT
argument_list|(
name|used_spill_regs
argument_list|,
name|spill_regs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Free all the insn_chain structures at once.  */
name|obstack_free
argument_list|(
operator|&
name|reload_obstack
argument_list|,
name|reload_startobj
argument_list|)
expr_stmt|;
name|unused_insn_chains
operator|=
literal|0
expr_stmt|;
name|fixup_abnormal_edges
argument_list|()
expr_stmt|;
return|return
name|failure
return|;
block|}
end_function

begin_comment
comment|/* Yet another special case.  Unfortunately, reg-stack forces people to    write incorrect clobbers in asm statements.  These clobbers must not    cause the register to appear in bad_spill_regs, otherwise we'll call    fatal_insn later.  We clear the corresponding regnos in the live    register sets to avoid this.    The whole thing is rather sick, I'm afraid.  */
end_comment

begin_function
specifier|static
name|void
name|maybe_fix_stack_asms
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|STACK_REGS
specifier|const
name|char
modifier|*
name|constraints
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|enum
name|machine_mode
name|operand_mode
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|struct
name|insn_chain
modifier|*
name|chain
decl_stmt|;
for|for
control|(
name|chain
operator|=
name|reload_insn_chain
init|;
name|chain
operator|!=
literal|0
condition|;
name|chain
operator|=
name|chain
operator|->
name|next
control|)
block|{
name|int
name|i
decl_stmt|,
name|noperands
decl_stmt|;
name|HARD_REG_SET
name|clobbered
decl_stmt|,
name|allowed
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|chain
operator|->
name|insn
argument_list|)
operator|||
operator|(
name|noperands
operator|=
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|chain
operator|->
name|insn
argument_list|)
argument_list|)
operator|)
operator|<
literal|0
condition|)
continue|continue;
name|pat
operator|=
name|PATTERN
argument_list|(
name|chain
operator|->
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|!=
name|PARALLEL
condition|)
continue|continue;
name|CLEAR_HARD_REG_SET
argument_list|(
name|clobbered
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|allowed
argument_list|)
expr_stmt|;
comment|/* First, make a mask of all stack regs that are clobbered.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|t
init|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|CLOBBER
operator|&&
name|STACK_REG_P
argument_list|(
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|clobbered
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Get the operand values and constraints out of the insn.  */
name|decode_asm_operands
argument_list|(
name|pat
argument_list|,
name|recog_data
operator|.
name|operand
argument_list|,
name|recog_data
operator|.
name|operand_loc
argument_list|,
name|constraints
argument_list|,
name|operand_mode
argument_list|)
expr_stmt|;
comment|/* For every operand, see what registers are allowed.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|noperands
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|constraints
index|[
name|i
index|]
decl_stmt|;
comment|/* For every alternative, we compute the class of registers allowed 	     for reloading in CLS, and merge its contents into the reg set 	     ALLOWED.  */
name|int
name|cls
init|=
operator|(
name|int
operator|)
name|NO_REGS
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
name|c
init|=
operator|*
name|p
operator|++
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
operator|||
name|c
operator|==
literal|','
operator|||
name|c
operator|==
literal|'#'
condition|)
block|{
comment|/* End of one alternative - mark the regs in the current 		     class, and reset the class.  */
name|IOR_HARD_REG_SET
argument_list|(
name|allowed
argument_list|,
name|reg_class_contents
index|[
name|cls
index|]
argument_list|)
expr_stmt|;
name|cls
operator|=
name|NO_REGS
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'#'
condition|)
do|do
block|{
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|!=
literal|'\0'
operator|&&
name|c
operator|!=
literal|','
condition|)
do|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
break|break;
continue|continue;
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'='
case|:
case|case
literal|'+'
case|:
case|case
literal|'*'
case|:
case|case
literal|'%'
case|:
case|case
literal|'?'
case|:
case|case
literal|'!'
case|:
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'m'
case|:
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
case|case
literal|'V'
case|:
case|case
literal|'o'
case|:
case|case
literal|'&'
case|:
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
case|case
literal|'s'
case|:
case|case
literal|'i'
case|:
case|case
literal|'n'
case|:
case|case
literal|'X'
case|:
case|case
literal|'I'
case|:
case|case
literal|'J'
case|:
case|case
literal|'K'
case|:
case|case
literal|'L'
case|:
case|case
literal|'M'
case|:
case|case
literal|'N'
case|:
case|case
literal|'O'
case|:
case|case
literal|'P'
case|:
break|break;
case|case
literal|'p'
case|:
name|cls
operator|=
operator|(
name|int
operator|)
name|reg_class_subunion
index|[
name|cls
index|]
index|[
operator|(
name|int
operator|)
name|MODE_BASE_REG_CLASS
argument_list|(
name|VOIDmode
argument_list|)
index|]
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
case|case
literal|'r'
case|:
name|cls
operator|=
operator|(
name|int
operator|)
name|reg_class_subunion
index|[
name|cls
index|]
index|[
operator|(
name|int
operator|)
name|GENERAL_REGS
index|]
expr_stmt|;
break|break;
default|default:
name|cls
operator|=
operator|(
name|int
operator|)
name|reg_class_subunion
index|[
name|cls
index|]
index|[
operator|(
name|int
operator|)
name|REG_CLASS_FROM_LETTER
argument_list|(
name|c
argument_list|)
index|]
expr_stmt|;
block|}
block|}
block|}
comment|/* Those of the registers which are clobbered, but allowed by the 	 constraints, must be usable as reload registers.  So clear them 	 out of the life information.  */
name|AND_HARD_REG_SET
argument_list|(
name|allowed
argument_list|,
name|clobbered
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|allowed
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|CLEAR_REGNO_REG_SET
argument_list|(
operator|&
name|chain
operator|->
name|live_throughout
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|CLEAR_REGNO_REG_SET
argument_list|(
operator|&
name|chain
operator|->
name|dead_or_set
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Copy the global variables n_reloads and rld into the corresponding elts    of CHAIN.  */
end_comment

begin_function
specifier|static
name|void
name|copy_reloads
parameter_list|(
name|chain
parameter_list|)
name|struct
name|insn_chain
modifier|*
name|chain
decl_stmt|;
block|{
name|chain
operator|->
name|n_reloads
operator|=
name|n_reloads
expr_stmt|;
name|chain
operator|->
name|rld
operator|=
operator|(
expr|struct
name|reload
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|reload_obstack
argument_list|,
name|n_reloads
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|reload
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|chain
operator|->
name|rld
argument_list|,
name|rld
argument_list|,
name|n_reloads
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|reload
argument_list|)
argument_list|)
expr_stmt|;
name|reload_insn_firstobj
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|reload_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Walk the chain of insns, and determine for each whether it needs reloads    and/or eliminations.  Build the corresponding insns_need_reload list, and    set something_needs_elimination as appropriate.  */
end_comment

begin_function
specifier|static
name|void
name|calculate_needs_all_insns
parameter_list|(
name|global
parameter_list|)
name|int
name|global
decl_stmt|;
block|{
name|struct
name|insn_chain
modifier|*
modifier|*
name|pprev_reload
init|=
operator|&
name|insns_need_reload
decl_stmt|;
name|struct
name|insn_chain
modifier|*
name|chain
decl_stmt|,
modifier|*
name|next
init|=
literal|0
decl_stmt|;
name|something_needs_elimination
operator|=
literal|0
expr_stmt|;
name|reload_insn_firstobj
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|reload_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|chain
operator|=
name|reload_insn_chain
init|;
name|chain
operator|!=
literal|0
condition|;
name|chain
operator|=
name|next
control|)
block|{
name|rtx
name|insn
init|=
name|chain
operator|->
name|insn
decl_stmt|;
name|next
operator|=
name|chain
operator|->
name|next
expr_stmt|;
comment|/* Clear out the shortcuts.  */
name|chain
operator|->
name|n_reloads
operator|=
literal|0
expr_stmt|;
name|chain
operator|->
name|need_elim
operator|=
literal|0
expr_stmt|;
name|chain
operator|->
name|need_reload
operator|=
literal|0
expr_stmt|;
name|chain
operator|->
name|need_operand_change
operator|=
literal|0
expr_stmt|;
comment|/* If this is a label, a JUMP_INSN, or has REG_NOTES (which might 	 include REG_LABEL), we need to see what effects this has on the 	 known offsets at labels.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|||
operator|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|set_label_offsets
argument_list|(
name|insn
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|old_body
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|old_code
init|=
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|old_notes
init|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|did_elimination
init|=
literal|0
decl_stmt|;
name|int
name|operands_changed
init|=
literal|0
decl_stmt|;
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* Skip insns that only set an equivalence.  */
if|if
condition|(
name|set
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|reg_renumber
index|[
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
index|]
operator|<
literal|0
operator|&&
name|reg_equiv_constant
index|[
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
index|]
condition|)
continue|continue;
comment|/* If needed, eliminate any eliminable registers.  */
if|if
condition|(
name|num_eliminable
operator|||
name|num_eliminable_invariants
condition|)
name|did_elimination
operator|=
name|eliminate_regs_in_insn
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Analyze the instruction.  */
name|operands_changed
operator|=
name|find_reloads
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|,
name|spill_indirect_levels
argument_list|,
name|global
argument_list|,
name|spill_reg_order
argument_list|)
expr_stmt|;
comment|/* If a no-op set needs more than one reload, this is likely 	     to be something that needs input address reloads.  We 	     can't get rid of this cleanly later, and it is of no use 	     anyway, so discard it now. 	     We only do this when expensive_optimizations is enabled, 	     since this complements reload inheritance / output 	     reload deletion, and it can make debugging harder.  */
if|if
condition|(
name|flag_expensive_optimizations
operator|&&
name|n_reloads
operator|>
literal|1
condition|)
block|{
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|set
operator|&&
name|SET_SRC
argument_list|(
name|set
argument_list|)
operator|==
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Delete it from the reload chain */
if|if
condition|(
name|chain
operator|->
name|prev
condition|)
name|chain
operator|->
name|prev
operator|->
name|next
operator|=
name|next
expr_stmt|;
else|else
name|reload_insn_chain
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|next
condition|)
name|next
operator|->
name|prev
operator|=
name|chain
operator|->
name|prev
expr_stmt|;
name|chain
operator|->
name|next
operator|=
name|unused_insn_chains
expr_stmt|;
name|unused_insn_chains
operator|=
name|chain
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|num_eliminable
condition|)
name|update_eliminable_offsets
argument_list|()
expr_stmt|;
comment|/* Remember for later shortcuts which insns had any reloads or 	     register eliminations.  */
name|chain
operator|->
name|need_elim
operator|=
name|did_elimination
expr_stmt|;
name|chain
operator|->
name|need_reload
operator|=
name|n_reloads
operator|>
literal|0
expr_stmt|;
name|chain
operator|->
name|need_operand_change
operator|=
name|operands_changed
expr_stmt|;
comment|/* Discard any register replacements done.  */
if|if
condition|(
name|did_elimination
condition|)
block|{
name|obstack_free
argument_list|(
operator|&
name|reload_obstack
argument_list|,
name|reload_insn_firstobj
argument_list|)
expr_stmt|;
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|old_body
expr_stmt|;
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
name|old_code
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|old_notes
expr_stmt|;
name|something_needs_elimination
operator|=
literal|1
expr_stmt|;
block|}
name|something_needs_operands_changed
operator||=
name|operands_changed
expr_stmt|;
if|if
condition|(
name|n_reloads
operator|!=
literal|0
condition|)
block|{
name|copy_reloads
argument_list|(
name|chain
argument_list|)
expr_stmt|;
operator|*
name|pprev_reload
operator|=
name|chain
expr_stmt|;
name|pprev_reload
operator|=
operator|&
name|chain
operator|->
name|next_need_reload
expr_stmt|;
block|}
block|}
block|}
operator|*
name|pprev_reload
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Comparison function for qsort to decide which of two reloads    should be handled first.  *P1 and *P2 are the reload numbers.  */
end_comment

begin_function
specifier|static
name|int
name|reload_reg_class_lower
parameter_list|(
name|r1p
parameter_list|,
name|r2p
parameter_list|)
specifier|const
name|PTR
name|r1p
decl_stmt|;
specifier|const
name|PTR
name|r2p
decl_stmt|;
block|{
name|int
name|r1
init|=
operator|*
operator|(
specifier|const
name|short
operator|*
operator|)
name|r1p
decl_stmt|,
name|r2
init|=
operator|*
operator|(
specifier|const
name|short
operator|*
operator|)
name|r2p
decl_stmt|;
name|int
name|t
decl_stmt|;
comment|/* Consider required reloads before optional ones.  */
name|t
operator|=
name|rld
index|[
name|r1
index|]
operator|.
name|optional
operator|-
name|rld
index|[
name|r2
index|]
operator|.
name|optional
expr_stmt|;
if|if
condition|(
name|t
operator|!=
literal|0
condition|)
return|return
name|t
return|;
comment|/* Count all solitary classes before non-solitary ones.  */
name|t
operator|=
operator|(
operator|(
name|reg_class_size
index|[
operator|(
name|int
operator|)
name|rld
index|[
name|r2
index|]
operator|.
name|class
index|]
operator|==
literal|1
operator|)
operator|-
operator|(
name|reg_class_size
index|[
operator|(
name|int
operator|)
name|rld
index|[
name|r1
index|]
operator|.
name|class
index|]
operator|==
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
literal|0
condition|)
return|return
name|t
return|;
comment|/* Aside from solitaires, consider all multi-reg groups first.  */
name|t
operator|=
name|rld
index|[
name|r2
index|]
operator|.
name|nregs
operator|-
name|rld
index|[
name|r1
index|]
operator|.
name|nregs
expr_stmt|;
if|if
condition|(
name|t
operator|!=
literal|0
condition|)
return|return
name|t
return|;
comment|/* Consider reloads in order of increasing reg-class number.  */
name|t
operator|=
operator|(
name|int
operator|)
name|rld
index|[
name|r1
index|]
operator|.
name|class
operator|-
operator|(
name|int
operator|)
name|rld
index|[
name|r2
index|]
operator|.
name|class
expr_stmt|;
if|if
condition|(
name|t
operator|!=
literal|0
condition|)
return|return
name|t
return|;
comment|/* If reloads are equally urgent, sort by reload number,      so that the results of qsort leave nothing to chance.  */
return|return
name|r1
operator|-
name|r2
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The cost of spilling each hard reg.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|spill_cost
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When spilling multiple hard registers, we use SPILL_COST for the first    spilled hard reg and SPILL_ADD_COST for subsequent regs.  SPILL_ADD_COST    only the first hard reg for a multi-reg pseudo.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|spill_add_cost
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Update the spill cost arrays, considering that pseudo REG is live.  */
end_comment

begin_function
specifier|static
name|void
name|count_pseudo
parameter_list|(
name|reg
parameter_list|)
name|int
name|reg
decl_stmt|;
block|{
name|int
name|freq
init|=
name|REG_FREQ
argument_list|(
name|reg
argument_list|)
decl_stmt|;
name|int
name|r
init|=
name|reg_renumber
index|[
name|reg
index|]
decl_stmt|;
name|int
name|nregs
decl_stmt|;
if|if
condition|(
name|REGNO_REG_SET_P
argument_list|(
operator|&
name|pseudos_counted
argument_list|,
name|reg
argument_list|)
operator|||
name|REGNO_REG_SET_P
argument_list|(
operator|&
name|spilled_pseudos
argument_list|,
name|reg
argument_list|)
condition|)
return|return;
name|SET_REGNO_REG_SET
argument_list|(
operator|&
name|pseudos_counted
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|spill_add_cost
index|[
name|r
index|]
operator|+=
name|freq
expr_stmt|;
name|nregs
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|r
argument_list|,
name|PSEUDO_REGNO_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|nregs
operator|--
operator|>
literal|0
condition|)
name|spill_cost
index|[
name|r
operator|+
name|nregs
index|]
operator|+=
name|freq
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Calculate the SPILL_COST and SPILL_ADD_COST arrays and determine the    contents of BAD_SPILL_REGS for the insn described by CHAIN.  */
end_comment

begin_function
specifier|static
name|void
name|order_regs_for_reload
parameter_list|(
name|chain
parameter_list|)
name|struct
name|insn_chain
modifier|*
name|chain
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|HARD_REG_SET
name|used_by_pseudos
decl_stmt|;
name|HARD_REG_SET
name|used_by_pseudos2
decl_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|bad_spill_regs
argument_list|,
name|fixed_reg_set
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|spill_cost
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|spill_cost
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|spill_add_cost
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|spill_add_cost
argument_list|)
expr_stmt|;
comment|/* Count number of uses of each hard reg by pseudo regs allocated to it      and then order them by decreasing use.  First exclude hard registers      that are live in or across this insn.  */
name|REG_SET_TO_HARD_REG_SET
argument_list|(
name|used_by_pseudos
argument_list|,
operator|&
name|chain
operator|->
name|live_throughout
argument_list|)
expr_stmt|;
name|REG_SET_TO_HARD_REG_SET
argument_list|(
name|used_by_pseudos2
argument_list|,
operator|&
name|chain
operator|->
name|dead_or_set
argument_list|)
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|bad_spill_regs
argument_list|,
name|used_by_pseudos
argument_list|)
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|bad_spill_regs
argument_list|,
name|used_by_pseudos2
argument_list|)
expr_stmt|;
comment|/* Now find out which pseudos are allocated to it, and update      hard_reg_n_uses.  */
name|CLEAR_REG_SET
argument_list|(
operator|&
name|pseudos_counted
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|&chain->live_throughout
argument_list|,
argument|FIRST_PSEUDO_REGISTER
argument_list|,
argument|i
argument_list|,
argument|{        count_pseudo (i);      }
argument_list|)
empty_stmt|;
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|&chain->dead_or_set
argument_list|,
argument|FIRST_PSEUDO_REGISTER
argument_list|,
argument|i
argument_list|,
argument|{        count_pseudo (i);      }
argument_list|)
empty_stmt|;
name|CLEAR_REG_SET
argument_list|(
operator|&
name|pseudos_counted
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Vector of reload-numbers showing the order in which the reloads should    be processed.  */
end_comment

begin_decl_stmt
specifier|static
name|short
name|reload_order
index|[
name|MAX_RELOADS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is used to keep track of the spill regs used in one insn.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|used_spill_regs_local
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We decided to spill hard register SPILLED, which has a size of    SPILLED_NREGS.  Determine how pseudo REG, which is live during the insn,    is affected.  We will add it to SPILLED_PSEUDOS if necessary, and we will    update SPILL_COST/SPILL_ADD_COST.  */
end_comment

begin_function
specifier|static
name|void
name|count_spilled_pseudo
parameter_list|(
name|spilled
parameter_list|,
name|spilled_nregs
parameter_list|,
name|reg
parameter_list|)
name|int
name|spilled
decl_stmt|,
name|spilled_nregs
decl_stmt|,
name|reg
decl_stmt|;
block|{
name|int
name|r
init|=
name|reg_renumber
index|[
name|reg
index|]
decl_stmt|;
name|int
name|nregs
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|r
argument_list|,
name|PSEUDO_REGNO_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|REGNO_REG_SET_P
argument_list|(
operator|&
name|spilled_pseudos
argument_list|,
name|reg
argument_list|)
operator|||
name|spilled
operator|+
name|spilled_nregs
operator|<=
name|r
operator|||
name|r
operator|+
name|nregs
operator|<=
name|spilled
condition|)
return|return;
name|SET_REGNO_REG_SET
argument_list|(
operator|&
name|spilled_pseudos
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|spill_add_cost
index|[
name|r
index|]
operator|-=
name|REG_FREQ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
while|while
condition|(
name|nregs
operator|--
operator|>
literal|0
condition|)
name|spill_cost
index|[
name|r
operator|+
name|nregs
index|]
operator|-=
name|REG_FREQ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find reload register to use for reload number ORDER.  */
end_comment

begin_function
specifier|static
name|int
name|find_reg
parameter_list|(
name|chain
parameter_list|,
name|order
parameter_list|)
name|struct
name|insn_chain
modifier|*
name|chain
decl_stmt|;
name|int
name|order
decl_stmt|;
block|{
name|int
name|rnum
init|=
name|reload_order
index|[
name|order
index|]
decl_stmt|;
name|struct
name|reload
modifier|*
name|rl
init|=
name|rld
operator|+
name|rnum
decl_stmt|;
name|int
name|best_cost
init|=
name|INT_MAX
decl_stmt|;
name|int
name|best_reg
init|=
operator|-
literal|1
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|k
decl_stmt|;
name|HARD_REG_SET
name|not_usable
decl_stmt|;
name|HARD_REG_SET
name|used_by_other_reload
decl_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|not_usable
argument_list|,
name|bad_spill_regs
argument_list|)
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|not_usable
argument_list|,
name|bad_spill_regs_global
argument_list|)
expr_stmt|;
name|IOR_COMPL_HARD_REG_SET
argument_list|(
name|not_usable
argument_list|,
name|reg_class_contents
index|[
name|rl
operator|->
name|class
index|]
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|used_by_other_reload
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|order
condition|;
name|k
operator|++
control|)
block|{
name|int
name|other
init|=
name|reload_order
index|[
name|k
index|]
decl_stmt|;
if|if
condition|(
name|rld
index|[
name|other
index|]
operator|.
name|regno
operator|>=
literal|0
operator|&&
name|reloads_conflict
argument_list|(
name|other
argument_list|,
name|rnum
argument_list|)
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|rld
index|[
name|other
index|]
operator|.
name|nregs
condition|;
name|j
operator|++
control|)
name|SET_HARD_REG_BIT
argument_list|(
name|used_by_other_reload
argument_list|,
name|rld
index|[
name|other
index|]
operator|.
name|regno
operator|+
name|j
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|int
name|regno
init|=
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|not_usable
argument_list|,
name|regno
argument_list|)
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|used_by_other_reload
argument_list|,
name|regno
argument_list|)
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|rl
operator|->
name|mode
argument_list|)
condition|)
block|{
name|int
name|this_cost
init|=
name|spill_cost
index|[
name|regno
index|]
decl_stmt|;
name|int
name|ok
init|=
literal|1
decl_stmt|;
name|unsigned
name|int
name|this_nregs
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|rl
operator|->
name|mode
argument_list|)
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|this_nregs
condition|;
name|j
operator|++
control|)
block|{
name|this_cost
operator|+=
name|spill_add_cost
index|[
name|regno
operator|+
name|j
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|TEST_HARD_REG_BIT
argument_list|(
name|not_usable
argument_list|,
name|regno
operator|+
name|j
argument_list|)
operator|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|used_by_other_reload
argument_list|,
name|regno
operator|+
name|j
argument_list|)
condition|)
name|ok
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ok
condition|)
continue|continue;
if|if
condition|(
name|rl
operator|->
name|in
operator|&&
name|GET_CODE
argument_list|(
name|rl
operator|->
name|in
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|rl
operator|->
name|in
argument_list|)
operator|==
name|regno
condition|)
name|this_cost
operator|--
expr_stmt|;
if|if
condition|(
name|rl
operator|->
name|out
operator|&&
name|GET_CODE
argument_list|(
name|rl
operator|->
name|out
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|rl
operator|->
name|out
argument_list|)
operator|==
name|regno
condition|)
name|this_cost
operator|--
expr_stmt|;
if|if
condition|(
name|this_cost
operator|<
name|best_cost
comment|/* Among registers with equal cost, prefer caller-saved ones, or 		 use REG_ALLOC_ORDER if it is defined.  */
operator|||
operator|(
name|this_cost
operator|==
name|best_cost
ifdef|#
directive|ifdef
name|REG_ALLOC_ORDER
operator|&&
operator|(
name|inv_reg_alloc_order
index|[
name|regno
index|]
operator|<
name|inv_reg_alloc_order
index|[
name|best_reg
index|]
operator|)
else|#
directive|else
operator|&&
name|call_used_regs
index|[
name|regno
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|best_reg
index|]
endif|#
directive|endif
operator|)
condition|)
block|{
name|best_reg
operator|=
name|regno
expr_stmt|;
name|best_cost
operator|=
name|this_cost
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|best_reg
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Using reg %d for reload %d\n"
argument_list|,
name|best_reg
argument_list|,
name|rnum
argument_list|)
expr_stmt|;
name|rl
operator|->
name|nregs
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|best_reg
argument_list|,
name|rl
operator|->
name|mode
argument_list|)
expr_stmt|;
name|rl
operator|->
name|regno
operator|=
name|best_reg
expr_stmt|;
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|&chain->live_throughout
argument_list|,
argument|FIRST_PSEUDO_REGISTER
argument_list|,
argument|j
argument_list|,
argument|{        count_spilled_pseudo (best_reg, rl->nregs, j);      }
argument_list|)
empty_stmt|;
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|&chain->dead_or_set
argument_list|,
argument|FIRST_PSEUDO_REGISTER
argument_list|,
argument|j
argument_list|,
argument|{        count_spilled_pseudo (best_reg, rl->nregs, j);      }
argument_list|)
empty_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rl
operator|->
name|nregs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|spill_cost
index|[
name|best_reg
operator|+
name|i
index|]
operator|!=
literal|0
operator|||
name|spill_add_cost
index|[
name|best_reg
operator|+
name|i
index|]
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|used_spill_regs_local
argument_list|,
name|best_reg
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Find more reload regs to satisfy the remaining need of an insn, which    is given by CHAIN.    Do it by ascending class number, since otherwise a reg    might be spilled for a big class and might fail to count    for a smaller class even though it belongs to that class.  */
end_comment

begin_function
specifier|static
name|void
name|find_reload_regs
parameter_list|(
name|chain
parameter_list|)
name|struct
name|insn_chain
modifier|*
name|chain
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/* In order to be certain of getting the registers we need,      we must sort the reloads into order of increasing register class.      Then our grabbing of reload registers will parallel the process      that provided the reload registers.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|chain
operator|->
name|n_reloads
condition|;
name|i
operator|++
control|)
block|{
comment|/* Show whether this reload already has a hard reg.  */
if|if
condition|(
name|chain
operator|->
name|rld
index|[
name|i
index|]
operator|.
name|reg_rtx
condition|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|chain
operator|->
name|rld
index|[
name|i
index|]
operator|.
name|reg_rtx
argument_list|)
decl_stmt|;
name|chain
operator|->
name|rld
index|[
name|i
index|]
operator|.
name|regno
operator|=
name|regno
expr_stmt|;
name|chain
operator|->
name|rld
index|[
name|i
index|]
operator|.
name|nregs
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|chain
operator|->
name|rld
index|[
name|i
index|]
operator|.
name|reg_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|chain
operator|->
name|rld
index|[
name|i
index|]
operator|.
name|regno
operator|=
operator|-
literal|1
expr_stmt|;
name|reload_order
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
block|}
name|n_reloads
operator|=
name|chain
operator|->
name|n_reloads
expr_stmt|;
name|memcpy
argument_list|(
name|rld
argument_list|,
name|chain
operator|->
name|rld
argument_list|,
name|n_reloads
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|reload
argument_list|)
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|used_spill_regs_local
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Spilling for insn %d.\n"
argument_list|,
name|INSN_UID
argument_list|(
name|chain
operator|->
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|reload_order
argument_list|,
name|n_reloads
argument_list|,
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|,
name|reload_reg_class_lower
argument_list|)
expr_stmt|;
comment|/* Compute the order of preference for hard registers to spill.  */
name|order_regs_for_reload
argument_list|(
name|chain
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_reloads
condition|;
name|i
operator|++
control|)
block|{
name|int
name|r
init|=
name|reload_order
index|[
name|i
index|]
decl_stmt|;
comment|/* Ignore reloads that got marked inoperative.  */
if|if
condition|(
operator|(
name|rld
index|[
name|r
index|]
operator|.
name|out
operator|!=
literal|0
operator|||
name|rld
index|[
name|r
index|]
operator|.
name|in
operator|!=
literal|0
operator|||
name|rld
index|[
name|r
index|]
operator|.
name|secondary_p
operator|)
operator|&&
operator|!
name|rld
index|[
name|r
index|]
operator|.
name|optional
operator|&&
name|rld
index|[
name|r
index|]
operator|.
name|regno
operator|==
operator|-
literal|1
condition|)
if|if
condition|(
operator|!
name|find_reg
argument_list|(
name|chain
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|spill_failure
argument_list|(
name|chain
operator|->
name|insn
argument_list|,
name|rld
index|[
name|r
index|]
operator|.
name|class
argument_list|)
expr_stmt|;
name|failure
operator|=
literal|1
expr_stmt|;
return|return;
block|}
block|}
name|COPY_HARD_REG_SET
argument_list|(
name|chain
operator|->
name|used_spill_regs
argument_list|,
name|used_spill_regs_local
argument_list|)
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|used_spill_regs
argument_list|,
name|used_spill_regs_local
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|chain
operator|->
name|rld
argument_list|,
name|rld
argument_list|,
name|n_reloads
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|reload
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|select_reload_regs
parameter_list|()
block|{
name|struct
name|insn_chain
modifier|*
name|chain
decl_stmt|;
comment|/* Try to satisfy the needs for each insn.  */
for|for
control|(
name|chain
operator|=
name|insns_need_reload
init|;
name|chain
operator|!=
literal|0
condition|;
name|chain
operator|=
name|chain
operator|->
name|next_need_reload
control|)
name|find_reload_regs
argument_list|(
name|chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Delete all insns that were inserted by emit_caller_save_insns during    this iteration.  */
end_comment

begin_function
specifier|static
name|void
name|delete_caller_save_insns
parameter_list|()
block|{
name|struct
name|insn_chain
modifier|*
name|c
init|=
name|reload_insn_chain
decl_stmt|;
while|while
condition|(
name|c
operator|!=
literal|0
condition|)
block|{
while|while
condition|(
name|c
operator|!=
literal|0
operator|&&
name|c
operator|->
name|is_caller_save_insn
condition|)
block|{
name|struct
name|insn_chain
modifier|*
name|next
init|=
name|c
operator|->
name|next
decl_stmt|;
name|rtx
name|insn
init|=
name|c
operator|->
name|insn
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|reload_insn_chain
condition|)
name|reload_insn_chain
operator|=
name|next
expr_stmt|;
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
condition|)
name|next
operator|->
name|prev
operator|=
name|c
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|prev
condition|)
name|c
operator|->
name|prev
operator|->
name|next
operator|=
name|next
expr_stmt|;
name|c
operator|->
name|next
operator|=
name|unused_insn_chains
expr_stmt|;
name|unused_insn_chains
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|next
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|!=
literal|0
condition|)
name|c
operator|=
name|c
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Handle the failure to find a register to spill.    INSN should be one of the insns which needed this particular spill reg.  */
end_comment

begin_function
specifier|static
name|void
name|spill_failure
parameter_list|(
name|insn
parameter_list|,
name|class
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|enum
name|reg_class
name|class
decl_stmt|;
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|reg_class_names
index|[]
init|=
name|REG_CLASS_NAMES
decl_stmt|;
if|if
condition|(
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
name|error_for_asm
argument_list|(
name|insn
argument_list|,
literal|"can't find a register in class `%s' while reloading `asm'"
argument_list|,
name|reg_class_names
index|[
name|class
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|"unable to find a register to spill in class `%s'"
argument_list|,
name|reg_class_names
index|[
name|class
index|]
argument_list|)
expr_stmt|;
name|fatal_insn
argument_list|(
literal|"this is the insn:"
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Delete an unneeded INSN and any previous insns who sole purpose is loading    data that is dead in INSN.  */
end_comment

begin_function
specifier|static
name|void
name|delete_dead_insn
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|prev
init|=
name|prev_real_insn
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|prev_dest
decl_stmt|;
comment|/* If the previous insn sets a register that dies in our insn, delete it      too.  */
if|if
condition|(
name|prev
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
operator|(
name|prev_dest
operator|=
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|)
operator|,
name|GET_CODE
argument_list|(
name|prev_dest
argument_list|)
operator|==
name|REG
operator|)
operator|&&
name|reg_mentioned_p
argument_list|(
name|prev_dest
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|&&
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
name|prev_dest
argument_list|)
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|)
argument_list|)
condition|)
name|delete_dead_insn
argument_list|(
name|prev
argument_list|)
expr_stmt|;
name|PUT_CODE
argument_list|(
name|insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Modify the home of pseudo-reg I.    The new home is present in reg_renumber[I].     FROM_REG may be the hard reg that the pseudo-reg is being spilled from;    or it may be -1, meaning there is none or it is not relevant.    This is used so that all pseudos spilled from a given hard reg    can share one stack slot.  */
end_comment

begin_function
specifier|static
name|void
name|alter_reg
parameter_list|(
name|i
parameter_list|,
name|from_reg
parameter_list|)
name|int
name|i
decl_stmt|;
name|int
name|from_reg
decl_stmt|;
block|{
comment|/* When outputting an inline function, this can happen      for a reg that isn't actually used.  */
if|if
condition|(
name|regno_reg_rtx
index|[
name|i
index|]
operator|==
literal|0
condition|)
return|return;
comment|/* If the reg got changed to a MEM at rtl-generation time,      ignore it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|)
operator|!=
name|REG
condition|)
return|return;
comment|/* Modify the reg-rtx to contain the new hard reg      number or else to contain its pseudo reg number.  */
name|REGNO
argument_list|(
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|)
operator|=
name|reg_renumber
index|[
name|i
index|]
operator|>=
literal|0
condition|?
name|reg_renumber
index|[
name|i
index|]
else|:
name|i
expr_stmt|;
comment|/* If we have a pseudo that is needed but has no hard reg or equivalent,      allocate a stack slot for it.  */
if|if
condition|(
name|reg_renumber
index|[
name|i
index|]
operator|<
literal|0
operator|&&
name|REG_N_REFS
argument_list|(
name|i
argument_list|)
operator|>
literal|0
operator|&&
name|reg_equiv_constant
index|[
name|i
index|]
operator|==
literal|0
operator|&&
name|reg_equiv_memory_loc
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|rtx
name|x
decl_stmt|;
name|unsigned
name|int
name|inherent_size
init|=
name|PSEUDO_REGNO_BYTES
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|total_size
init|=
name|MAX
argument_list|(
name|inherent_size
argument_list|,
name|reg_max_ref_width
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|int
name|adjust
init|=
literal|0
decl_stmt|;
comment|/* Each pseudo reg has an inherent size which comes from its own mode, 	 and a total size which provides room for paradoxical subregs 	 which refer to the pseudo reg in wider modes.  	 We can use a slot already allocated if it provides both 	 enough inherent space and enough total space. 	 Otherwise, we allocate a new slot, making sure that it has no less 	 inherent space, and no less total space, then the previous slot.  */
if|if
condition|(
name|from_reg
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* No known place to spill from => no slot to reuse.  */
name|x
operator|=
name|assign_stack_local
argument_list|(
name|GET_MODE
argument_list|(
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|)
argument_list|,
name|total_size
argument_list|,
name|inherent_size
operator|==
name|total_size
condition|?
literal|0
else|:
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
comment|/* Cancel the  big-endian correction done in assign_stack_local. 	       Get the address of the beginning of the slot. 	       This is so we can do a big-endian correction unconditionally 	       below.  */
name|adjust
operator|=
name|inherent_size
operator|-
name|total_size
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|x
argument_list|)
operator|=
name|RTX_UNCHANGING_P
argument_list|(
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Nothing can alias this slot except this pseudo.  */
name|set_mem_alias_set
argument_list|(
name|x
argument_list|,
name|new_alias_set
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/* Reuse a stack slot if possible.  */
elseif|else
if|if
condition|(
name|spill_stack_slot
index|[
name|from_reg
index|]
operator|!=
literal|0
operator|&&
name|spill_stack_slot_width
index|[
name|from_reg
index|]
operator|>=
name|total_size
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|spill_stack_slot
index|[
name|from_reg
index|]
argument_list|)
argument_list|)
operator|>=
name|inherent_size
operator|)
condition|)
name|x
operator|=
name|spill_stack_slot
index|[
name|from_reg
index|]
expr_stmt|;
comment|/* Allocate a bigger slot.  */
else|else
block|{
comment|/* Compute maximum size needed, both for inherent size 	     and for total size.  */
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|rtx
name|stack_slot
decl_stmt|;
if|if
condition|(
name|spill_stack_slot
index|[
name|from_reg
index|]
condition|)
block|{
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|spill_stack_slot
index|[
name|from_reg
index|]
argument_list|)
argument_list|)
operator|>
name|inherent_size
condition|)
name|mode
operator|=
name|GET_MODE
argument_list|(
name|spill_stack_slot
index|[
name|from_reg
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|spill_stack_slot_width
index|[
name|from_reg
index|]
operator|>
name|total_size
condition|)
name|total_size
operator|=
name|spill_stack_slot_width
index|[
name|from_reg
index|]
expr_stmt|;
block|}
comment|/* Make a slot with that size.  */
name|x
operator|=
name|assign_stack_local
argument_list|(
name|mode
argument_list|,
name|total_size
argument_list|,
name|inherent_size
operator|==
name|total_size
condition|?
literal|0
else|:
operator|-
literal|1
argument_list|)
expr_stmt|;
name|stack_slot
operator|=
name|x
expr_stmt|;
comment|/* All pseudos mapped to this slot can alias each other.  */
if|if
condition|(
name|spill_stack_slot
index|[
name|from_reg
index|]
condition|)
name|set_mem_alias_set
argument_list|(
name|x
argument_list|,
name|MEM_ALIAS_SET
argument_list|(
name|spill_stack_slot
index|[
name|from_reg
index|]
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|set_mem_alias_set
argument_list|(
name|x
argument_list|,
name|new_alias_set
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
block|{
comment|/* Cancel the  big-endian correction done in assign_stack_local. 		 Get the address of the beginning of the slot. 		 This is so we can do a big-endian correction unconditionally 		 below.  */
name|adjust
operator|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|-
name|total_size
expr_stmt|;
if|if
condition|(
name|adjust
condition|)
name|stack_slot
operator|=
name|adjust_address_nv
argument_list|(
name|x
argument_list|,
name|mode_for_size
argument_list|(
name|total_size
operator|*
name|BITS_PER_UNIT
argument_list|,
name|MODE_INT
argument_list|,
literal|1
argument_list|)
argument_list|,
name|adjust
argument_list|)
expr_stmt|;
block|}
name|spill_stack_slot
index|[
name|from_reg
index|]
operator|=
name|stack_slot
expr_stmt|;
name|spill_stack_slot_width
index|[
name|from_reg
index|]
operator|=
name|total_size
expr_stmt|;
block|}
comment|/* On a big endian machine, the "address" of the slot 	 is the address of the low part that fits its inherent mode.  */
if|if
condition|(
name|BYTES_BIG_ENDIAN
operator|&&
name|inherent_size
operator|<
name|total_size
condition|)
name|adjust
operator|+=
operator|(
name|total_size
operator|-
name|inherent_size
operator|)
expr_stmt|;
comment|/* If we have any adjustment to make, or if the stack slot is the 	 wrong mode, make a new stack slot.  */
name|x
operator|=
name|adjust_address_nv
argument_list|(
name|x
argument_list|,
name|GET_MODE
argument_list|(
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|)
argument_list|,
name|adjust
argument_list|)
expr_stmt|;
comment|/* If we have a decl for the original register, set it for the 	 memory.  If this is a shared MEM, make a copy.  */
if|if
condition|(
name|REGNO_DECL
argument_list|(
name|i
argument_list|)
condition|)
block|{
if|if
condition|(
name|from_reg
operator|!=
operator|-
literal|1
operator|&&
name|spill_stack_slot
index|[
name|from_reg
index|]
operator|==
name|x
condition|)
name|x
operator|=
name|copy_rtx
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|set_mem_expr
argument_list|(
name|x
argument_list|,
name|REGNO_DECL
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Save the stack slot for later.  */
name|reg_equiv_memory_loc
index|[
name|i
index|]
operator|=
name|x
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Mark the slots in regs_ever_live for the hard regs    used by pseudo-reg number REGNO.  */
end_comment

begin_function
name|void
name|mark_home_live
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|lim
decl_stmt|;
name|i
operator|=
name|reg_renumber
index|[
name|regno
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
return|return;
name|lim
operator|=
name|i
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|i
argument_list|,
name|PSEUDO_REGNO_MODE
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|lim
condition|)
name|regs_ever_live
index|[
name|i
operator|++
index|]
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This function handles the tracking of elimination offsets around branches.     X is a piece of RTL being scanned.     INSN is the insn that it came from, if any.     INITIAL_P is non-zero if we are to set the offset to be the initial    offset and zero if we are setting the offset of the label to be the    current offset.  */
end_comment

begin_function
specifier|static
name|void
name|set_label_offsets
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|,
name|initial_p
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|initial_p
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|elim_table
modifier|*
name|p
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LABEL_REF
case|:
if|if
condition|(
name|LABEL_REF_NONLOCAL_P
argument_list|(
name|x
argument_list|)
condition|)
return|return;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* ... fall through ...  */
case|case
name|CODE_LABEL
case|:
comment|/* If we know nothing about this label, set the desired offsets.  Note 	 that this sets the offset at a label to be the offset before a label 	 if we don't know anything about the label.  This is not correct for 	 the label after a BARRIER, but is the best guess we can make.  If 	 we guessed wrong, we will suppress an elimination that might have 	 been possible had we been able to guess correctly.  */
if|if
condition|(
operator|!
name|offsets_known_at
index|[
name|CODE_LABEL_NUMBER
argument_list|(
name|x
argument_list|)
index|]
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_ELIMINABLE_REGS
condition|;
name|i
operator|++
control|)
name|offsets_at
index|[
name|CODE_LABEL_NUMBER
argument_list|(
name|x
argument_list|)
index|]
index|[
name|i
index|]
operator|=
operator|(
name|initial_p
condition|?
name|reg_eliminate
index|[
name|i
index|]
operator|.
name|initial_offset
else|:
name|reg_eliminate
index|[
name|i
index|]
operator|.
name|offset
operator|)
expr_stmt|;
name|offsets_known_at
index|[
name|CODE_LABEL_NUMBER
argument_list|(
name|x
argument_list|)
index|]
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Otherwise, if this is the definition of a label and it is 	 preceded by a BARRIER, set our offsets to the known offset of 	 that label.  */
elseif|else
if|if
condition|(
name|x
operator|==
name|insn
operator|&&
operator|(
name|tem
operator|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|BARRIER
condition|)
name|set_offsets_for_label
argument_list|(
name|insn
argument_list|)
expr_stmt|;
else|else
comment|/* If neither of the above cases is true, compare each offset 	   with those previously recorded and suppress any eliminations 	   where the offsets disagree.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_ELIMINABLE_REGS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|offsets_at
index|[
name|CODE_LABEL_NUMBER
argument_list|(
name|x
argument_list|)
index|]
index|[
name|i
index|]
operator|!=
operator|(
name|initial_p
condition|?
name|reg_eliminate
index|[
name|i
index|]
operator|.
name|initial_offset
else|:
name|reg_eliminate
index|[
name|i
index|]
operator|.
name|offset
operator|)
condition|)
name|reg_eliminate
index|[
name|i
index|]
operator|.
name|can_eliminate
operator|=
literal|0
expr_stmt|;
return|return;
case|case
name|JUMP_INSN
case|:
name|set_label_offsets
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
name|initial_p
argument_list|)
expr_stmt|;
comment|/* ... fall through ...  */
case|case
name|INSN
case|:
case|case
name|CALL_INSN
case|:
comment|/* Any labels mentioned in REG_LABEL notes can be branched to indirectly 	 and hence must have all eliminations at their initial offsets.  */
for|for
control|(
name|tem
operator|=
name|REG_NOTES
argument_list|(
name|x
argument_list|)
init|;
name|tem
condition|;
name|tem
operator|=
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|tem
argument_list|)
operator|==
name|REG_LABEL
condition|)
name|set_label_offsets
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
case|case
name|PARALLEL
case|:
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
comment|/* Each of the labels in the parallel or address vector must be 	 at their initial offsets.  We want the first field for PARALLEL 	 and ADDR_VEC and the second field for ADDR_DIFF_VEC.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|unsigned
operator|)
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|code
operator|==
name|ADDR_DIFF_VEC
argument_list|)
condition|;
name|i
operator|++
control|)
name|set_label_offsets
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|code
operator|==
name|ADDR_DIFF_VEC
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|,
name|initial_p
argument_list|)
expr_stmt|;
return|return;
case|case
name|SET
case|:
comment|/* We only care about setting PC.  If the source is not RETURN, 	 IF_THEN_ELSE, or a label, disable any eliminations not at 	 their initial offsets.  Similarly if any arm of the IF_THEN_ELSE 	 isn't one of those possibilities.  For branches to a label, 	 call ourselves recursively.  	 Note that this can disable elimination unnecessarily when we have 	 a non-local goto since it will look like a non-constant jump to 	 someplace in the current function.  This isn't a significant 	 problem since such jumps will normally be when all elimination 	 pairs are back to their initial offsets.  */
if|if
condition|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|!=
name|pc_rtx
condition|)
return|return;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|PC
case|:
case|case
name|RETURN
case|:
return|return;
case|case
name|LABEL_REF
case|:
name|set_label_offsets
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|,
name|initial_p
argument_list|)
expr_stmt|;
return|return;
case|case
name|IF_THEN_ELSE
case|:
name|tem
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|set_label_offsets
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|,
name|initial_p
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|!=
name|PC
operator|&&
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|!=
name|RETURN
condition|)
break|break;
name|tem
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|set_label_offsets
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|,
name|initial_p
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|!=
name|PC
operator|&&
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|!=
name|RETURN
condition|)
break|break;
return|return;
default|default:
break|break;
block|}
comment|/* If we reach here, all eliminations must be at their initial 	 offset because we are doing a jump to a variable address.  */
for|for
control|(
name|p
operator|=
name|reg_eliminate
init|;
name|p
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|p
operator|->
name|offset
operator|!=
name|p
operator|->
name|initial_offset
condition|)
name|p
operator|->
name|can_eliminate
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Scan X and replace any eliminable registers (such as fp) with a    replacement (such as sp), plus an offset.     MEM_MODE is the mode of an enclosing MEM.  We need this to know how    much to adjust a register for, e.g., PRE_DEC.  Also, if we are inside a    MEM, we are allowed to replace a sum of a register and the constant zero    with the register, which we cannot do outside a MEM.  In addition, we need    to record the fact that a register is referenced outside a MEM.     If INSN is an insn, it is the insn containing X.  If we replace a REG    in a SET_DEST with an equivalent MEM and INSN is non-zero, write a    CLOBBER of the pseudo after INSN so find_equiv_regs will know that    the REG is being modified.     Alternatively, INSN may be a note (an EXPR_LIST or INSN_LIST).    That's used when we eliminate in expressions stored in notes.    This means, do not set ref_outside_mem even if the reference    is outside of MEMs.     REG_EQUIV_MEM and REG_EQUIV_ADDRESS contain address that have had    replacements done assuming all offsets are at their initial values.  If    they are not, or if REG_EQUIV_ADDRESS is nonzero for a pseudo we    encounter, return the actual location so that find_reloads will do    the proper thing.  */
end_comment

begin_function
name|rtx
name|eliminate_regs
parameter_list|(
name|x
parameter_list|,
name|mem_mode
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|enum
name|machine_mode
name|mem_mode
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|struct
name|elim_table
modifier|*
name|ep
decl_stmt|;
name|int
name|regno
decl_stmt|;
name|rtx
name|new
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|copied
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|current_function_decl
condition|)
return|return
name|x
return|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CODE_LABEL
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|ASM_INPUT
case|:
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
case|case
name|RETURN
case|:
return|return
name|x
return|;
case|case
name|ADDRESSOF
case|:
comment|/* This is only for the benefit of the debugging backends, which call 	 eliminate_regs on DECL_RTL; any ADDRESSOFs in the actual insns are 	 removed after CSE.  */
name|new
operator|=
name|eliminate_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|new
argument_list|)
operator|==
name|MEM
condition|)
return|return
name|XEXP
argument_list|(
name|new
argument_list|,
literal|0
argument_list|)
return|;
return|return
name|x
return|;
case|case
name|REG
case|:
name|regno
operator|=
name|REGNO
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* First handle the case where we encounter a bare register that 	 is eliminable.  Replace it with a PLUS.  */
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
for|for
control|(
name|ep
operator|=
name|reg_eliminate
init|;
name|ep
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|ep
operator|++
control|)
if|if
condition|(
name|ep
operator|->
name|from_rtx
operator|==
name|x
operator|&&
name|ep
operator|->
name|can_eliminate
condition|)
return|return
name|plus_constant
argument_list|(
name|ep
operator|->
name|to_rtx
argument_list|,
name|ep
operator|->
name|previous_offset
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|reg_renumber
operator|&&
name|reg_renumber
index|[
name|regno
index|]
operator|<
literal|0
operator|&&
name|reg_equiv_constant
operator|&&
name|reg_equiv_constant
index|[
name|regno
index|]
operator|&&
operator|!
name|CONSTANT_P
argument_list|(
name|reg_equiv_constant
index|[
name|regno
index|]
argument_list|)
condition|)
return|return
name|eliminate_regs
argument_list|(
name|copy_rtx
argument_list|(
name|reg_equiv_constant
index|[
name|regno
index|]
argument_list|)
argument_list|,
name|mem_mode
argument_list|,
name|insn
argument_list|)
return|;
return|return
name|x
return|;
comment|/* You might think handling MINUS in a manner similar to PLUS is a        good idea.  It is not.  It has been tried multiple times and every        time the change has had to have been reverted.         Other parts of reload know a PLUS is special (gen_reload for example)        and require special code to handle code a reloaded PLUS operand.         Also consider backends where the flags register is clobbered by a        MINUS, but we can emit a PLUS that does not clobber flags (ia32,        lea instruction comes to mind).  If we try to reload a MINUS, we        may kill the flags register that was holding a useful value.         So, please before trying to handle MINUS, consider reload as a        whole instead of this little section as well as the backend issues.  */
case|case
name|PLUS
case|:
comment|/* If this is the sum of an eliminable register and a constant, rework 	 the sum.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
for|for
control|(
name|ep
operator|=
name|reg_eliminate
init|;
name|ep
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|ep
operator|++
control|)
if|if
condition|(
name|ep
operator|->
name|from_rtx
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|&&
name|ep
operator|->
name|can_eliminate
condition|)
block|{
comment|/* The only time we want to replace a PLUS with a REG (this 		   occurs when the constant operand of the PLUS is the negative 		   of the offset) is when we are inside a MEM.  We won't want 		   to do so at other times because that would change the 		   structure of the insn in a way that reload can't handle. 		   We special-case the commonest situation in 		   eliminate_regs_in_insn, so just replace a PLUS with a 		   PLUS here, unless inside a MEM.  */
if|if
condition|(
name|mem_mode
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
operator|-
name|ep
operator|->
name|previous_offset
condition|)
return|return
name|ep
operator|->
name|to_rtx
return|;
else|else
return|return
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|ep
operator|->
name|to_rtx
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|ep
operator|->
name|previous_offset
argument_list|)
argument_list|)
return|;
block|}
comment|/* If the register is not eliminable, we are done since the other 	     operand is a constant.  */
return|return
name|x
return|;
block|}
comment|/* If this is part of an address, we want to bring any constant to the 	 outermost PLUS.  We will do this by doing register replacement in 	 our operands and seeing if a constant shows up in one of them.  	 Note that there is no risk of modifying the structure of the insn, 	 since we only get called for its operands, thus we are either 	 modifying the address inside a MEM, or something like an address 	 operand of a load-address insn.  */
block|{
name|rtx
name|new0
init|=
name|eliminate_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mem_mode
argument_list|,
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|new1
init|=
name|eliminate_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mem_mode
argument_list|,
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg_renumber
operator|&&
operator|(
name|new0
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|||
name|new1
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
block|{
comment|/* If one side is a PLUS and the other side is a pseudo that 	       didn't get a hard register but has a reg_equiv_constant, 	       we must replace the constant here since it may no longer 	       be in the position of any operand.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|new0
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|new1
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|new1
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_renumber
index|[
name|REGNO
argument_list|(
name|new1
argument_list|)
index|]
operator|<
literal|0
operator|&&
name|reg_equiv_constant
operator|!=
literal|0
operator|&&
name|reg_equiv_constant
index|[
name|REGNO
argument_list|(
name|new1
argument_list|)
index|]
operator|!=
literal|0
condition|)
name|new1
operator|=
name|reg_equiv_constant
index|[
name|REGNO
argument_list|(
name|new1
argument_list|)
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|new1
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|new0
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|new0
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_renumber
index|[
name|REGNO
argument_list|(
name|new0
argument_list|)
index|]
operator|<
literal|0
operator|&&
name|reg_equiv_constant
index|[
name|REGNO
argument_list|(
name|new0
argument_list|)
index|]
operator|!=
literal|0
condition|)
name|new0
operator|=
name|reg_equiv_constant
index|[
name|REGNO
argument_list|(
name|new0
argument_list|)
index|]
expr_stmt|;
name|new
operator|=
name|form_sum
argument_list|(
name|new0
argument_list|,
name|new1
argument_list|)
expr_stmt|;
comment|/* As above, if we are not inside a MEM we do not want to 	       turn a PLUS into something else.  We might try to do so here 	       for an addition of 0 if we aren't optimizing.  */
if|if
condition|(
operator|!
name|mem_mode
operator|&&
name|GET_CODE
argument_list|(
name|new
argument_list|)
operator|!=
name|PLUS
condition|)
return|return
name|gen_rtx_PLUS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|new
argument_list|,
name|const0_rtx
argument_list|)
return|;
else|else
return|return
name|new
return|;
block|}
block|}
return|return
name|x
return|;
case|case
name|MULT
case|:
comment|/* If this is the product of an eliminable register and a 	 constant, apply the distribute law and move the constant out 	 so that we have (plus (mult ..) ..).  This is needed in order 	 to keep load-address insns valid.   This case is pathological. 	 We ignore the possibility of overflow here.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
for|for
control|(
name|ep
operator|=
name|reg_eliminate
init|;
name|ep
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|ep
operator|++
control|)
if|if
condition|(
name|ep
operator|->
name|from_rtx
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|&&
name|ep
operator|->
name|can_eliminate
condition|)
block|{
if|if
condition|(
operator|!
name|mem_mode
comment|/* Refs inside notes don't count for this purpose.  */
operator|&&
operator|!
operator|(
name|insn
operator|!=
literal|0
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|EXPR_LIST
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN_LIST
operator|)
operator|)
condition|)
name|ep
operator|->
name|ref_outside_mem
operator|=
literal|1
expr_stmt|;
return|return
name|plus_constant
argument_list|(
name|gen_rtx_MULT
argument_list|(
name|Pmode
argument_list|,
name|ep
operator|->
name|to_rtx
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|ep
operator|->
name|previous_offset
operator|*
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/* ... fall through ...  */
case|case
name|CALL
case|:
case|case
name|COMPARE
case|:
comment|/* See comments before PLUS about handling MINUS.  */
case|case
name|MINUS
case|:
case|case
name|DIV
case|:
case|case
name|UDIV
case|:
case|case
name|MOD
case|:
case|case
name|UMOD
case|:
case|case
name|AND
case|:
case|case
name|IOR
case|:
case|case
name|XOR
case|:
case|case
name|ROTATERT
case|:
case|case
name|ROTATE
case|:
case|case
name|ASHIFTRT
case|:
case|case
name|LSHIFTRT
case|:
case|case
name|ASHIFT
case|:
case|case
name|NE
case|:
case|case
name|EQ
case|:
case|case
name|GE
case|:
case|case
name|GT
case|:
case|case
name|GEU
case|:
case|case
name|GTU
case|:
case|case
name|LE
case|:
case|case
name|LT
case|:
case|case
name|LEU
case|:
case|case
name|LTU
case|:
block|{
name|rtx
name|new0
init|=
name|eliminate_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mem_mode
argument_list|,
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|new1
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|?
name|eliminate_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mem_mode
argument_list|,
name|insn
argument_list|)
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|new0
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|||
name|new1
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|new0
argument_list|,
name|new1
argument_list|)
return|;
block|}
return|return
name|x
return|;
case|case
name|EXPR_LIST
case|:
comment|/* If we have something in XEXP (x, 0), the usual case, eliminate it.  */
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|new
operator|=
name|eliminate_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mem_mode
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* If this is a REG_DEAD note, it is not valid anymore. 		 Using the eliminated version could result in creating a 		 REG_DEAD note for the stack or frame pointer.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG_DEAD
condition|)
return|return
operator|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|?
name|eliminate_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mem_mode
argument_list|,
name|insn
argument_list|)
else|:
name|NULL_RTX
operator|)
return|;
name|x
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_NOTE_KIND
argument_list|(
name|x
argument_list|)
argument_list|,
name|new
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* ... fall through ...  */
case|case
name|INSN_LIST
case|:
comment|/* Now do eliminations in the rest of the chain.  If this was 	 an EXPR_LIST, this might result in allocating more memory than is 	 strictly needed, but it simplifies the code.  */
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|new
operator|=
name|eliminate_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mem_mode
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|gen_rtx_fmt_ee
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|new
argument_list|)
return|;
block|}
return|return
name|x
return|;
case|case
name|PRE_INC
case|:
case|case
name|POST_INC
case|:
case|case
name|PRE_DEC
case|:
case|case
name|POST_DEC
case|:
case|case
name|STRICT_LOW_PART
case|:
case|case
name|NEG
case|:
case|case
name|NOT
case|:
case|case
name|SIGN_EXTEND
case|:
case|case
name|ZERO_EXTEND
case|:
case|case
name|TRUNCATE
case|:
case|case
name|FLOAT_EXTEND
case|:
case|case
name|FLOAT_TRUNCATE
case|:
case|case
name|FLOAT
case|:
case|case
name|FIX
case|:
case|case
name|UNSIGNED_FIX
case|:
case|case
name|UNSIGNED_FLOAT
case|:
case|case
name|ABS
case|:
case|case
name|SQRT
case|:
case|case
name|FFS
case|:
name|new
operator|=
name|eliminate_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mem_mode
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|gen_rtx_fmt_e
argument_list|(
name|code
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|new
argument_list|)
return|;
return|return
name|x
return|;
case|case
name|SUBREG
case|:
comment|/* Similar to above processing, but preserve SUBREG_BYTE. 	 Convert (subreg (mem)) to (mem) if not paradoxical. 	 Also, if we have a non-paradoxical (subreg (pseudo)) and the 	 pseudo didn't get a hard reg, we must replace this with the 	 eliminated version of the memory location because push_reloads 	 may do the replacement in certain circumstances.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
name|reg_equiv_memory_loc
operator|!=
literal|0
operator|&&
name|reg_equiv_memory_loc
index|[
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
index|]
operator|!=
literal|0
condition|)
block|{
name|new
operator|=
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
else|else
name|new
operator|=
name|eliminate_regs
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
name|mem_mode
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|!=
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|int
name|x_size
init|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|new_size
init|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|new
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|new
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
operator|(
name|x_size
operator|<
name|new_size
ifdef|#
directive|ifdef
name|WORD_REGISTER_OPERATIONS
comment|/* On these machines, combine can create rtl of the form 		      (set (subreg:m1 (reg:m2 R) 0) ...) 		      where m1< m2, and expects something interesting to 		      happen to the entire word.  Moreover, it will use the 		      (reg:m2 R) later, expecting all bits to be preserved. 		      So if the number of words is the same, preserve the 		      subreg so that push_reloads can see it.  */
operator|&&
operator|!
operator|(
operator|(
name|x_size
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
operator|==
operator|(
name|new_size
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
endif|#
directive|endif
operator|)
operator|||
name|x_size
operator|==
name|new_size
operator|)
condition|)
return|return
name|adjust_address_nv
argument_list|(
name|x
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|x
argument_list|)
argument_list|)
return|;
else|else
return|return
name|gen_rtx_SUBREG
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|new
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|x
argument_list|)
argument_list|)
return|;
block|}
return|return
name|x
return|;
case|case
name|MEM
case|:
comment|/* This is only for the benefit of the debugging backends, which call 	 eliminate_regs on DECL_RTL; any ADDRESSOFs in the actual insns are 	 removed after CSE.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDRESSOF
condition|)
return|return
name|eliminate_regs
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
name|insn
argument_list|)
return|;
comment|/* Our only special processing is to pass the mode of the MEM to our 	 recursive call and copy the flags.  While we are here, handle this 	 case more efficiently.  */
return|return
name|replace_equiv_address_nv
argument_list|(
name|x
argument_list|,
name|eliminate_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|insn
argument_list|)
argument_list|)
return|;
case|case
name|USE
case|:
comment|/* Handle insn_list USE that a call to a pure function may generate.  */
name|new
operator|=
name|eliminate_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|gen_rtx_USE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|new
argument_list|)
return|;
return|return
name|x
return|;
case|case
name|CLOBBER
case|:
case|case
name|ASM_OPERANDS
case|:
case|case
name|SET
case|:
name|abort
argument_list|()
expr_stmt|;
default|default:
break|break;
block|}
comment|/* Process each of our operands recursively.  If any have changed, make a      copy of the rtx.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
condition|;
name|i
operator|++
operator|,
name|fmt
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'e'
condition|)
block|{
name|new
operator|=
name|eliminate_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|mem_mode
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|&&
operator|!
name|copied
condition|)
block|{
name|rtx
name|new_x
init|=
name|rtx_alloc
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|new_x
argument_list|,
name|x
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|new_x
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|new_x
operator|->
name|fld
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|new_x
operator|->
name|fld
index|[
literal|0
index|]
argument_list|)
operator|*
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|new_x
expr_stmt|;
name|copied
operator|=
literal|1
expr_stmt|;
block|}
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|=
name|new
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'E'
condition|)
block|{
name|int
name|copied_vec
init|=
literal|0
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|new
operator|=
name|eliminate_regs
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|mem_mode
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|!=
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|&&
operator|!
name|copied_vec
condition|)
block|{
name|rtvec
name|new_v
init|=
name|gen_rtvec_v
argument_list|(
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|XVEC
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|->
name|elem
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|copied
condition|)
block|{
name|rtx
name|new_x
init|=
name|rtx_alloc
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|new_x
argument_list|,
name|x
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|new_x
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|new_x
operator|->
name|fld
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|new_x
operator|->
name|fld
index|[
literal|0
index|]
argument_list|)
operator|*
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|)
operator|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|new_x
expr_stmt|;
name|copied
operator|=
literal|1
expr_stmt|;
block|}
name|XVEC
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|=
name|new_v
expr_stmt|;
name|copied_vec
operator|=
literal|1
expr_stmt|;
block|}
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|=
name|new
expr_stmt|;
block|}
block|}
block|}
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Scan rtx X for modifications of elimination target registers.  Update    the table of eliminables to reflect the changed state.  MEM_MODE is    the mode of an enclosing MEM rtx, or VOIDmode if not within a MEM.  */
end_comment

begin_function
specifier|static
name|void
name|elimination_effects
parameter_list|(
name|x
parameter_list|,
name|mem_mode
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|enum
name|machine_mode
name|mem_mode
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|struct
name|elim_table
modifier|*
name|ep
decl_stmt|;
name|int
name|regno
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CODE_LABEL
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|ASM_INPUT
case|:
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
case|case
name|RETURN
case|:
return|return;
case|case
name|ADDRESSOF
case|:
name|abort
argument_list|()
expr_stmt|;
case|case
name|REG
case|:
name|regno
operator|=
name|REGNO
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* First handle the case where we encounter a bare register that 	 is eliminable.  Replace it with a PLUS.  */
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
for|for
control|(
name|ep
operator|=
name|reg_eliminate
init|;
name|ep
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|ep
operator|++
control|)
if|if
condition|(
name|ep
operator|->
name|from_rtx
operator|==
name|x
operator|&&
name|ep
operator|->
name|can_eliminate
condition|)
block|{
if|if
condition|(
operator|!
name|mem_mode
condition|)
name|ep
operator|->
name|ref_outside_mem
operator|=
literal|1
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|reg_renumber
index|[
name|regno
index|]
operator|<
literal|0
operator|&&
name|reg_equiv_constant
operator|&&
name|reg_equiv_constant
index|[
name|regno
index|]
operator|&&
operator|!
name|function_invariant_p
argument_list|(
name|reg_equiv_constant
index|[
name|regno
index|]
argument_list|)
condition|)
name|elimination_effects
argument_list|(
name|reg_equiv_constant
index|[
name|regno
index|]
argument_list|,
name|mem_mode
argument_list|)
expr_stmt|;
return|return;
case|case
name|PRE_INC
case|:
case|case
name|POST_INC
case|:
case|case
name|PRE_DEC
case|:
case|case
name|POST_DEC
case|:
case|case
name|POST_MODIFY
case|:
case|case
name|PRE_MODIFY
case|:
for|for
control|(
name|ep
operator|=
name|reg_eliminate
init|;
name|ep
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|ep
operator|++
control|)
if|if
condition|(
name|ep
operator|->
name|to_rtx
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|int
name|size
init|=
name|GET_MODE_SIZE
argument_list|(
name|mem_mode
argument_list|)
decl_stmt|;
comment|/* If more bytes than MEM_MODE are pushed, account for them.  */
ifdef|#
directive|ifdef
name|PUSH_ROUNDING
if|if
condition|(
name|ep
operator|->
name|to_rtx
operator|==
name|stack_pointer_rtx
condition|)
name|size
operator|=
name|PUSH_ROUNDING
argument_list|(
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|code
operator|==
name|PRE_DEC
operator|||
name|code
operator|==
name|POST_DEC
condition|)
name|ep
operator|->
name|offset
operator|+=
name|size
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|PRE_INC
operator|||
name|code
operator|==
name|POST_INC
condition|)
name|ep
operator|->
name|offset
operator|-=
name|size
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|code
operator|==
name|PRE_MODIFY
operator|||
name|code
operator|==
name|POST_MODIFY
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|ep
operator|->
name|offset
operator|-=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* These two aren't unary operators.  */
if|if
condition|(
name|code
operator|==
name|POST_MODIFY
operator|||
name|code
operator|==
name|PRE_MODIFY
condition|)
break|break;
comment|/* Fall through to generic unary operation case.  */
case|case
name|STRICT_LOW_PART
case|:
case|case
name|NEG
case|:
case|case
name|NOT
case|:
case|case
name|SIGN_EXTEND
case|:
case|case
name|ZERO_EXTEND
case|:
case|case
name|TRUNCATE
case|:
case|case
name|FLOAT_EXTEND
case|:
case|case
name|FLOAT_TRUNCATE
case|:
case|case
name|FLOAT
case|:
case|case
name|FIX
case|:
case|case
name|UNSIGNED_FIX
case|:
case|case
name|UNSIGNED_FLOAT
case|:
case|case
name|ABS
case|:
case|case
name|SQRT
case|:
case|case
name|FFS
case|:
name|elimination_effects
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mem_mode
argument_list|)
expr_stmt|;
return|return;
case|case
name|SUBREG
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
name|reg_equiv_memory_loc
operator|!=
literal|0
operator|&&
name|reg_equiv_memory_loc
index|[
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
index|]
operator|!=
literal|0
condition|)
return|return;
name|elimination_effects
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
name|mem_mode
argument_list|)
expr_stmt|;
return|return;
case|case
name|USE
case|:
comment|/* If using a register that is the source of an eliminate we still 	 think can be performed, note it cannot be performed since we don't 	 know how this register is used.  */
for|for
control|(
name|ep
operator|=
name|reg_eliminate
init|;
name|ep
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|ep
operator|++
control|)
if|if
condition|(
name|ep
operator|->
name|from_rtx
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|)
name|ep
operator|->
name|can_eliminate
operator|=
literal|0
expr_stmt|;
name|elimination_effects
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mem_mode
argument_list|)
expr_stmt|;
return|return;
case|case
name|CLOBBER
case|:
comment|/* If clobbering a register that is the replacement register for an 	 elimination we still think can be performed, note that it cannot 	 be performed.  Otherwise, we need not be concerned about it.  */
for|for
control|(
name|ep
operator|=
name|reg_eliminate
init|;
name|ep
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|ep
operator|++
control|)
if|if
condition|(
name|ep
operator|->
name|to_rtx
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|)
name|ep
operator|->
name|can_eliminate
operator|=
literal|0
expr_stmt|;
name|elimination_effects
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mem_mode
argument_list|)
expr_stmt|;
return|return;
case|case
name|SET
case|:
comment|/* Check for setting a register that we know about.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
comment|/* See if this is setting the replacement register for an 	     elimination.  	     If DEST is the hard frame pointer, we do nothing because we 	     assume that all assignments to the frame pointer are for 	     non-local gotos and are being done at a time when they are valid 	     and do not disturb anything else.  Some machines want to 	     eliminate a fake argument pointer (or even a fake frame pointer) 	     with either the real frame or the stack pointer.  Assignments to 	     the hard frame pointer must not prevent this elimination.  */
for|for
control|(
name|ep
operator|=
name|reg_eliminate
init|;
name|ep
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|ep
operator|++
control|)
if|if
condition|(
name|ep
operator|->
name|to_rtx
operator|==
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|&&
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|!=
name|hard_frame_pointer_rtx
condition|)
block|{
comment|/* If it is being incremented, adjust the offset.  Otherwise, 		   this elimination can't be done.  */
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
operator|==
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|ep
operator|->
name|offset
operator|-=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|ep
operator|->
name|can_eliminate
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|elimination_effects
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|elimination_effects
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|MEM
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDRESSOF
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Our only special processing is to pass the mode of the MEM to our 	 recursive call.  */
name|elimination_effects
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return;
default|default:
break|break;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
condition|;
name|i
operator|++
operator|,
name|fmt
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'e'
condition|)
name|elimination_effects
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|mem_mode
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|elimination_effects
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|mem_mode
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Descend through rtx X and verify that no references to eliminable registers    remain.  If any do remain, mark the involved register as not    eliminable.  */
end_comment

begin_function
specifier|static
name|void
name|check_eliminable_occurrences
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|struct
name|elim_table
modifier|*
name|ep
decl_stmt|;
for|for
control|(
name|ep
operator|=
name|reg_eliminate
init|;
name|ep
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|ep
operator|++
control|)
if|if
condition|(
name|ep
operator|->
name|from_rtx
operator|==
name|x
operator|&&
name|ep
operator|->
name|can_eliminate
condition|)
name|ep
operator|->
name|can_eliminate
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
condition|;
name|i
operator|++
operator|,
name|fmt
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'e'
condition|)
name|check_eliminable_occurrences
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|check_eliminable_occurrences
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Scan INSN and eliminate all eliminable registers in it.     If REPLACE is nonzero, do the replacement destructively.  Also    delete the insn as dead it if it is setting an eliminable register.     If REPLACE is zero, do all our allocations in reload_obstack.     If no eliminations were done and this insn doesn't require any elimination    processing (these are not identical conditions: it might be updating sp,    but not referencing fp; this needs to be seen during reload_as_needed so    that the offset between fp and sp can be taken into consideration), zero    is returned.  Otherwise, 1 is returned.  */
end_comment

begin_function
specifier|static
name|int
name|eliminate_regs_in_insn
parameter_list|(
name|insn
parameter_list|,
name|replace
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|int
name|replace
decl_stmt|;
block|{
name|int
name|icode
init|=
name|recog_memoized
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|old_body
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|insn_is_asm
init|=
name|asm_noperands
argument_list|(
name|old_body
argument_list|)
operator|>=
literal|0
decl_stmt|;
name|rtx
name|old_set
init|=
name|single_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|new_body
decl_stmt|;
name|int
name|val
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|any_changes
decl_stmt|;
name|rtx
name|substed_operand
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|rtx
name|orig_operand
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|struct
name|elim_table
modifier|*
name|ep
decl_stmt|;
if|if
condition|(
operator|!
name|insn_is_asm
operator|&&
name|icode
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ASM_INPUT
condition|)
return|return
literal|0
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|old_set
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|old_set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|old_set
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
comment|/* Check for setting an eliminable register.  */
for|for
control|(
name|ep
operator|=
name|reg_eliminate
init|;
name|ep
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|ep
operator|++
control|)
if|if
condition|(
name|ep
operator|->
name|from_rtx
operator|==
name|SET_DEST
argument_list|(
name|old_set
argument_list|)
operator|&&
name|ep
operator|->
name|can_eliminate
condition|)
block|{
if|#
directive|if
name|HARD_FRAME_POINTER_REGNUM
operator|!=
name|FRAME_POINTER_REGNUM
comment|/* If this is setting the frame pointer register to the 	       hardware frame pointer register and this is an elimination 	       that will be done (tested above), this insn is really 	       adjusting the frame pointer downward to compensate for 	       the adjustment done before a nonlocal goto.  */
if|if
condition|(
name|ep
operator|->
name|from
operator|==
name|FRAME_POINTER_REGNUM
operator|&&
name|ep
operator|->
name|to
operator|==
name|HARD_FRAME_POINTER_REGNUM
condition|)
block|{
name|rtx
name|base
init|=
name|SET_SRC
argument_list|(
name|old_set
argument_list|)
decl_stmt|;
name|rtx
name|base_insn
init|=
name|insn
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|base
operator|!=
name|ep
operator|->
name|to_rtx
condition|)
block|{
name|rtx
name|prev_insn
decl_stmt|,
name|prev_set
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|base
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|offset
operator|+=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|base
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|base
operator|=
name|XEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|prev_insn
operator|=
name|prev_nonnote_insn
argument_list|(
name|base_insn
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|prev_set
operator|=
name|single_set
argument_list|(
name|prev_insn
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_DEST
argument_list|(
name|prev_set
argument_list|)
argument_list|,
name|base
argument_list|)
condition|)
block|{
name|base
operator|=
name|SET_SRC
argument_list|(
name|prev_set
argument_list|)
expr_stmt|;
name|base_insn
operator|=
name|prev_insn
expr_stmt|;
block|}
else|else
break|break;
block|}
if|if
condition|(
name|base
operator|==
name|ep
operator|->
name|to_rtx
condition|)
block|{
name|rtx
name|src
init|=
name|plus_constant
argument_list|(
name|ep
operator|->
name|to_rtx
argument_list|,
name|offset
operator|-
name|ep
operator|->
name|offset
argument_list|)
decl_stmt|;
name|new_body
operator|=
name|old_body
expr_stmt|;
if|if
condition|(
operator|!
name|replace
condition|)
block|{
name|new_body
operator|=
name|copy_insn
argument_list|(
name|old_body
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
condition|)
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|copy_insn_1
argument_list|(
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|new_body
expr_stmt|;
name|old_set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* First see if this insn remains valid when we 		       make the change.  If not, keep the INSN_CODE 		       the same and let reload fit it up.  */
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|old_set
argument_list|)
argument_list|,
name|src
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_DEST
argument_list|(
name|old_set
argument_list|)
argument_list|,
name|ep
operator|->
name|to_rtx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|apply_change_group
argument_list|()
condition|)
block|{
name|SET_SRC
argument_list|(
name|old_set
argument_list|)
operator|=
name|src
expr_stmt|;
name|SET_DEST
argument_list|(
name|old_set
argument_list|)
operator|=
name|ep
operator|->
name|to_rtx
expr_stmt|;
block|}
name|val
operator|=
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
endif|#
directive|endif
comment|/* In this case this insn isn't serving a useful purpose.  We 	       will delete it in reload_as_needed once we know that this 	       elimination is, in fact, being done.  	       If REPLACE isn't set, we can't delete this insn, but needn't 	       process it since it won't be used unless something changes.  */
if|if
condition|(
name|replace
condition|)
block|{
name|delete_dead_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|val
operator|=
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
comment|/* We allow one special case which happens to work on all machines we      currently support: a single set with the source being a PLUS of an      eliminable register and a constant.  */
if|if
condition|(
name|old_set
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|old_set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|old_set
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|old_set
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|old_set
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|old_set
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|rtx
name|reg
init|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|old_set
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|offset
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|old_set
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|ep
operator|=
name|reg_eliminate
init|;
name|ep
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|ep
operator|++
control|)
if|if
condition|(
name|ep
operator|->
name|from_rtx
operator|==
name|reg
operator|&&
name|ep
operator|->
name|can_eliminate
condition|)
block|{
name|offset
operator|+=
name|ep
operator|->
name|offset
expr_stmt|;
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
block|{
name|int
name|num_clobbers
decl_stmt|;
comment|/* We assume here that if we need a PARALLEL with 		   CLOBBERs for this assignment, we can do with the 		   MATCH_SCRATCHes that add_clobbers allocates. 		   There's not much we can do if that doesn't work.  */
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|SET_DEST
argument_list|(
name|old_set
argument_list|)
argument_list|,
name|ep
operator|->
name|to_rtx
argument_list|)
expr_stmt|;
name|num_clobbers
operator|=
literal|0
expr_stmt|;
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
name|recog
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
operator|&
name|num_clobbers
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_clobbers
condition|)
block|{
name|rtvec
name|vec
init|=
name|rtvec_alloc
argument_list|(
name|num_clobbers
operator|+
literal|1
argument_list|)
decl_stmt|;
name|vec
operator|->
name|elem
index|[
literal|0
index|]
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|vec
argument_list|)
expr_stmt|;
name|add_clobbers
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|new_body
operator|=
name|old_body
expr_stmt|;
if|if
condition|(
operator|!
name|replace
condition|)
block|{
name|new_body
operator|=
name|copy_insn
argument_list|(
name|old_body
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
condition|)
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|copy_insn_1
argument_list|(
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|new_body
expr_stmt|;
name|old_set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|old_set
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|=
name|ep
operator|->
name|to_rtx
expr_stmt|;
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|old_set
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|=
name|GEN_INT
argument_list|(
name|offset
argument_list|)
expr_stmt|;
block|}
name|val
operator|=
literal|1
expr_stmt|;
comment|/* This can't have an effect on elimination offsets, so skip right 	       to the end.  */
goto|goto
name|done
goto|;
block|}
block|}
comment|/* Determine the effects of this insn on elimination offsets.  */
name|elimination_effects
argument_list|(
name|old_body
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Eliminate all eliminable registers occurring in operands that      can be handled by reload.  */
name|extract_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|any_changes
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|recog_data
operator|.
name|n_operands
condition|;
name|i
operator|++
control|)
block|{
name|orig_operand
index|[
name|i
index|]
operator|=
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
expr_stmt|;
name|substed_operand
index|[
name|i
index|]
operator|=
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
expr_stmt|;
comment|/* For an asm statement, every operand is eliminable.  */
if|if
condition|(
name|insn_is_asm
operator|||
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
name|i
index|]
operator|.
name|eliminable
condition|)
block|{
comment|/* Check for setting a register that we know about.  */
if|if
condition|(
name|recog_data
operator|.
name|operand_type
index|[
name|i
index|]
operator|!=
name|OP_IN
operator|&&
name|GET_CODE
argument_list|(
name|orig_operand
index|[
name|i
index|]
argument_list|)
operator|==
name|REG
condition|)
block|{
comment|/* If we are assigning to a register that can be eliminated, it 		 must be as part of a PARALLEL, since the code above handles 		 single SETs.  We must indicate that we can no longer 		 eliminate this reg.  */
for|for
control|(
name|ep
operator|=
name|reg_eliminate
init|;
name|ep
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|ep
operator|++
control|)
if|if
condition|(
name|ep
operator|->
name|from_rtx
operator|==
name|orig_operand
index|[
name|i
index|]
operator|&&
name|ep
operator|->
name|can_eliminate
condition|)
name|ep
operator|->
name|can_eliminate
operator|=
literal|0
expr_stmt|;
block|}
name|substed_operand
index|[
name|i
index|]
operator|=
name|eliminate_regs
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
name|replace
condition|?
name|insn
else|:
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|substed_operand
index|[
name|i
index|]
operator|!=
name|orig_operand
index|[
name|i
index|]
condition|)
name|val
operator|=
name|any_changes
operator|=
literal|1
expr_stmt|;
comment|/* Terminate the search in check_eliminable_occurrences at 	     this point.  */
operator|*
name|recog_data
operator|.
name|operand_loc
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* If an output operand changed from a REG to a MEM and INSN is an 	   insn, write a CLOBBER insn.  */
if|if
condition|(
name|recog_data
operator|.
name|operand_type
index|[
name|i
index|]
operator|!=
name|OP_IN
operator|&&
name|GET_CODE
argument_list|(
name|orig_operand
index|[
name|i
index|]
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|substed_operand
index|[
name|i
index|]
argument_list|)
operator|==
name|MEM
operator|&&
name|replace
condition|)
name|emit_insn_after
argument_list|(
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|orig_operand
index|[
name|i
index|]
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|recog_data
operator|.
name|n_dups
condition|;
name|i
operator|++
control|)
operator|*
name|recog_data
operator|.
name|dup_loc
index|[
name|i
index|]
operator|=
operator|*
name|recog_data
operator|.
name|operand_loc
index|[
operator|(
name|int
operator|)
name|recog_data
operator|.
name|dup_num
index|[
name|i
index|]
index|]
expr_stmt|;
comment|/* If any eliminable remain, they aren't eliminable anymore.  */
name|check_eliminable_occurrences
argument_list|(
name|old_body
argument_list|)
expr_stmt|;
comment|/* Substitute the operands; the new values are in the substed_operand      array.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|recog_data
operator|.
name|n_operands
condition|;
name|i
operator|++
control|)
operator|*
name|recog_data
operator|.
name|operand_loc
index|[
name|i
index|]
operator|=
name|substed_operand
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|recog_data
operator|.
name|n_dups
condition|;
name|i
operator|++
control|)
operator|*
name|recog_data
operator|.
name|dup_loc
index|[
name|i
index|]
operator|=
name|substed_operand
index|[
operator|(
name|int
operator|)
name|recog_data
operator|.
name|dup_num
index|[
name|i
index|]
index|]
expr_stmt|;
comment|/* If we are replacing a body that was a (set X (plus Y Z)), try to      re-recognize the insn.  We do this in case we had a simple addition      but now can do this as a load-address.  This saves an insn in this      common case.      If re-recognition fails, the old insn code number will still be used,      and some register operands may have changed into PLUS expressions.      These will be handled by find_reloads by loading them into a register      again.  */
if|if
condition|(
name|val
condition|)
block|{
comment|/* If we aren't replacing things permanently and we changed something, 	 make another copy to ensure that all the RTL is new.  Otherwise 	 things can go wrong if find_reload swaps commutative operands 	 and one is inside RTL that has been copied while the other is not.  */
name|new_body
operator|=
name|old_body
expr_stmt|;
if|if
condition|(
operator|!
name|replace
condition|)
block|{
name|new_body
operator|=
name|copy_insn
argument_list|(
name|old_body
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
condition|)
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|copy_insn_1
argument_list|(
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|new_body
expr_stmt|;
comment|/* If we had a move insn but now we don't, rerecognize it.  This will 	 cause spurious re-recognition if the old move had a PARALLEL since 	 the new one still will, but we can't call single_set without 	 having put NEW_BODY into the insn and the re-recognition won't 	 hurt in this rare case.  */
comment|/* ??? Why this huge if statement - why don't we just rerecognize the 	 thing always?  */
if|if
condition|(
operator|!
name|insn_is_asm
operator|&&
name|old_set
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|old_set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|new_body
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|new_body
argument_list|)
argument_list|)
operator|!=
name|REG
operator|)
operator|)
comment|/* If this was a load from or store to memory, compare 		 the MEM in recog_data.operand to the one in the insn. 		 If they are not equal, then rerecognize the insn.  */
operator|||
operator|(
name|old_set
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|old_set
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|SET_SRC
argument_list|(
name|old_set
argument_list|)
operator|!=
name|recog_data
operator|.
name|operand
index|[
literal|1
index|]
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|old_set
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|SET_DEST
argument_list|(
name|old_set
argument_list|)
operator|!=
name|recog_data
operator|.
name|operand
index|[
literal|0
index|]
operator|)
operator|)
operator|)
comment|/* If this was an add insn before, rerecognize.  */
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|old_set
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|)
condition|)
block|{
name|int
name|new_icode
init|=
name|recog
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_icode
operator|<
literal|0
condition|)
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
name|icode
expr_stmt|;
block|}
block|}
comment|/* Restore the old body.  If there were any changes to it, we made a copy      of it while the changes were still in place, so we'll correctly return      a modified insn below.  */
if|if
condition|(
operator|!
name|replace
condition|)
block|{
comment|/* Restore the old body.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|recog_data
operator|.
name|n_operands
condition|;
name|i
operator|++
control|)
operator|*
name|recog_data
operator|.
name|operand_loc
index|[
name|i
index|]
operator|=
name|orig_operand
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|recog_data
operator|.
name|n_dups
condition|;
name|i
operator|++
control|)
operator|*
name|recog_data
operator|.
name|dup_loc
index|[
name|i
index|]
operator|=
name|orig_operand
index|[
operator|(
name|int
operator|)
name|recog_data
operator|.
name|dup_num
index|[
name|i
index|]
index|]
expr_stmt|;
block|}
comment|/* Update all elimination pairs to reflect the status after the current      insn.  The changes we make were determined by the earlier call to      elimination_effects.       We also detect a cases where register elimination cannot be done,      namely, if a register would be both changed and referenced outside a MEM      in the resulting insn since such an insn is often undefined and, even if      not, we cannot know what meaning will be given to it.  Note that it is      valid to have a register used in an address in an insn that changes it      (presumably with a pre- or post-increment or decrement).       If anything changes, return nonzero.  */
for|for
control|(
name|ep
operator|=
name|reg_eliminate
init|;
name|ep
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|ep
operator|++
control|)
block|{
if|if
condition|(
name|ep
operator|->
name|previous_offset
operator|!=
name|ep
operator|->
name|offset
operator|&&
name|ep
operator|->
name|ref_outside_mem
condition|)
name|ep
operator|->
name|can_eliminate
operator|=
literal|0
expr_stmt|;
name|ep
operator|->
name|ref_outside_mem
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|previous_offset
operator|!=
name|ep
operator|->
name|offset
condition|)
name|val
operator|=
literal|1
expr_stmt|;
block|}
name|done
label|:
comment|/* If we changed something, perform elimination in REG_NOTES.  This is      needed even when REPLACE is zero because a REG_DEAD note might refer      to a register that we eliminate and could cause a different number      of spill registers to be needed in the final reload pass than in      the pre-passes.  */
if|if
condition|(
name|val
operator|&&
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|!=
literal|0
condition|)
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|eliminate_regs
argument_list|(
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Loop through all elimination pairs.    Recalculate the number not at initial offset.     Compute the maximum offset (minimum offset if the stack does not    grow downward) for each elimination pair.  */
end_comment

begin_function
specifier|static
name|void
name|update_eliminable_offsets
parameter_list|()
block|{
name|struct
name|elim_table
modifier|*
name|ep
decl_stmt|;
name|num_not_at_initial_offset
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ep
operator|=
name|reg_eliminate
init|;
name|ep
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|ep
operator|++
control|)
block|{
name|ep
operator|->
name|previous_offset
operator|=
name|ep
operator|->
name|offset
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|can_eliminate
operator|&&
name|ep
operator|->
name|offset
operator|!=
name|ep
operator|->
name|initial_offset
condition|)
name|num_not_at_initial_offset
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Given X, a SET or CLOBBER of DEST, if DEST is the target of a register    replacement we currently believe is valid, mark it as not eliminable if X    modifies DEST in any way other than by adding a constant integer to it.     If DEST is the frame pointer, we do nothing because we assume that    all assignments to the hard frame pointer are nonlocal gotos and are being    done at a time when they are valid and do not disturb anything else.    Some machines want to eliminate a fake argument pointer with either the    frame or stack pointer.  Assignments to the hard frame pointer must not    prevent this elimination.     Called via note_stores from reload before starting its passes to scan    the insns of the function.  */
end_comment

begin_function
specifier|static
name|void
name|mark_not_eliminable
parameter_list|(
name|dest
parameter_list|,
name|x
parameter_list|,
name|data
parameter_list|)
name|rtx
name|dest
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* A SUBREG of a hard register here is just changing its mode.  We should      not see a SUBREG of an eliminable hard register, but check just in      case.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
condition|)
name|dest
operator|=
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
operator|==
name|hard_frame_pointer_rtx
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_ELIMINABLE_REGS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reg_eliminate
index|[
name|i
index|]
operator|.
name|can_eliminate
operator|&&
name|dest
operator|==
name|reg_eliminate
index|[
name|i
index|]
operator|.
name|to_rtx
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|PLUS
operator|||
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|!=
name|dest
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|)
condition|)
block|{
name|reg_eliminate
index|[
name|i
index|]
operator|.
name|can_eliminate_previous
operator|=
name|reg_eliminate
index|[
name|i
index|]
operator|.
name|can_eliminate
operator|=
literal|0
expr_stmt|;
name|num_eliminable
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Verify that the initial elimination offsets did not change since the    last call to set_initial_elim_offsets.  This is used to catch cases    where something illegal happened during reload_as_needed that could    cause incorrect code to be generated if we did not check for it.  */
end_comment

begin_function
specifier|static
name|void
name|verify_initial_elim_offsets
parameter_list|()
block|{
name|int
name|t
decl_stmt|;
ifdef|#
directive|ifdef
name|ELIMINABLE_REGS
name|struct
name|elim_table
modifier|*
name|ep
decl_stmt|;
for|for
control|(
name|ep
operator|=
name|reg_eliminate
init|;
name|ep
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|ep
operator|++
control|)
block|{
name|INITIAL_ELIMINATION_OFFSET
argument_list|(
name|ep
operator|->
name|from
argument_list|,
name|ep
operator|->
name|to
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|ep
operator|->
name|initial_offset
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
else|#
directive|else
name|INITIAL_FRAME_POINTER_OFFSET
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|reg_eliminate
index|[
literal|0
index|]
operator|.
name|initial_offset
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Reset all offsets on eliminable registers to their initial values.  */
end_comment

begin_function
specifier|static
name|void
name|set_initial_elim_offsets
parameter_list|()
block|{
name|struct
name|elim_table
modifier|*
name|ep
init|=
name|reg_eliminate
decl_stmt|;
ifdef|#
directive|ifdef
name|ELIMINABLE_REGS
for|for
control|(
init|;
name|ep
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|ep
operator|++
control|)
block|{
name|INITIAL_ELIMINATION_OFFSET
argument_list|(
name|ep
operator|->
name|from
argument_list|,
name|ep
operator|->
name|to
argument_list|,
name|ep
operator|->
name|initial_offset
argument_list|)
expr_stmt|;
name|ep
operator|->
name|previous_offset
operator|=
name|ep
operator|->
name|offset
operator|=
name|ep
operator|->
name|initial_offset
expr_stmt|;
block|}
else|#
directive|else
name|INITIAL_FRAME_POINTER_OFFSET
argument_list|(
name|ep
operator|->
name|initial_offset
argument_list|)
expr_stmt|;
name|ep
operator|->
name|previous_offset
operator|=
name|ep
operator|->
name|offset
operator|=
name|ep
operator|->
name|initial_offset
expr_stmt|;
endif|#
directive|endif
name|num_not_at_initial_offset
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize the known label offsets.    Set a known offset for each forced label to be at the initial offset    of each elimination.  We do this because we assume that all    computed jumps occur from a location where each elimination is    at its initial offset.    For all other labels, show that we don't know the offsets.  */
end_comment

begin_function
specifier|static
name|void
name|set_initial_label_offsets
parameter_list|()
block|{
name|rtx
name|x
decl_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|offsets_known_at
index|[
name|get_first_label_num
argument_list|()
index|]
argument_list|,
literal|0
argument_list|,
name|num_labels
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
name|forced_labels
init|;
name|x
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|)
name|set_label_offsets
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set all elimination offsets to the known values for the code label given    by INSN.  */
end_comment

begin_function
specifier|static
name|void
name|set_offsets_for_label
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|int
name|label_nr
init|=
name|CODE_LABEL_NUMBER
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|struct
name|elim_table
modifier|*
name|ep
decl_stmt|;
name|num_not_at_initial_offset
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|ep
operator|=
name|reg_eliminate
init|;
name|i
operator|<
name|NUM_ELIMINABLE_REGS
condition|;
name|ep
operator|++
operator|,
name|i
operator|++
control|)
block|{
name|ep
operator|->
name|offset
operator|=
name|ep
operator|->
name|previous_offset
operator|=
name|offsets_at
index|[
name|label_nr
index|]
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|can_eliminate
operator|&&
name|ep
operator|->
name|offset
operator|!=
name|ep
operator|->
name|initial_offset
condition|)
name|num_not_at_initial_offset
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* See if anything that happened changes which eliminations are valid.    For example, on the Sparc, whether or not the frame pointer can    be eliminated can depend on what registers have been used.  We need    not check some conditions again (such as flag_omit_frame_pointer)    since they can't have changed.  */
end_comment

begin_function
specifier|static
name|void
name|update_eliminables
parameter_list|(
name|pset
parameter_list|)
name|HARD_REG_SET
modifier|*
name|pset
decl_stmt|;
block|{
if|#
directive|if
name|HARD_FRAME_POINTER_REGNUM
operator|!=
name|FRAME_POINTER_REGNUM
name|int
name|previous_frame_pointer_needed
init|=
name|frame_pointer_needed
decl_stmt|;
endif|#
directive|endif
name|struct
name|elim_table
modifier|*
name|ep
decl_stmt|;
for|for
control|(
name|ep
operator|=
name|reg_eliminate
init|;
name|ep
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|ep
operator|++
control|)
if|if
condition|(
operator|(
name|ep
operator|->
name|from
operator|==
name|HARD_FRAME_POINTER_REGNUM
operator|&&
name|FRAME_POINTER_REQUIRED
operator|)
ifdef|#
directive|ifdef
name|ELIMINABLE_REGS
operator|||
operator|!
name|CAN_ELIMINATE
argument_list|(
name|ep
operator|->
name|from
argument_list|,
name|ep
operator|->
name|to
argument_list|)
endif|#
directive|endif
condition|)
name|ep
operator|->
name|can_eliminate
operator|=
literal|0
expr_stmt|;
comment|/* Look for the case where we have discovered that we can't replace      register A with register B and that means that we will now be      trying to replace register A with register C.  This means we can      no longer replace register C with register B and we need to disable      such an elimination, if it exists.  This occurs often with A == ap,      B == sp, and C == fp.  */
for|for
control|(
name|ep
operator|=
name|reg_eliminate
init|;
name|ep
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|ep
operator|++
control|)
block|{
name|struct
name|elim_table
modifier|*
name|op
decl_stmt|;
name|int
name|new_to
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|ep
operator|->
name|can_eliminate
operator|&&
name|ep
operator|->
name|can_eliminate_previous
condition|)
block|{
comment|/* Find the current elimination for ep->from, if there is a 	     new one.  */
for|for
control|(
name|op
operator|=
name|reg_eliminate
init|;
name|op
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|op
operator|++
control|)
if|if
condition|(
name|op
operator|->
name|from
operator|==
name|ep
operator|->
name|from
operator|&&
name|op
operator|->
name|can_eliminate
condition|)
block|{
name|new_to
operator|=
name|op
operator|->
name|to
expr_stmt|;
break|break;
block|}
comment|/* See if there is an elimination of NEW_TO -> EP->TO.  If so, 	     disable it.  */
for|for
control|(
name|op
operator|=
name|reg_eliminate
init|;
name|op
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|op
operator|++
control|)
if|if
condition|(
name|op
operator|->
name|from
operator|==
name|new_to
operator|&&
name|op
operator|->
name|to
operator|==
name|ep
operator|->
name|to
condition|)
name|op
operator|->
name|can_eliminate
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* See if any registers that we thought we could eliminate the previous      time are no longer eliminable.  If so, something has changed and we      must spill the register.  Also, recompute the number of eliminable      registers and see if the frame pointer is needed; it is if there is      no elimination of the frame pointer that we can perform.  */
name|frame_pointer_needed
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|ep
operator|=
name|reg_eliminate
init|;
name|ep
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|ep
operator|++
control|)
block|{
if|if
condition|(
name|ep
operator|->
name|can_eliminate
operator|&&
name|ep
operator|->
name|from
operator|==
name|FRAME_POINTER_REGNUM
operator|&&
name|ep
operator|->
name|to
operator|!=
name|HARD_FRAME_POINTER_REGNUM
condition|)
name|frame_pointer_needed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|ep
operator|->
name|can_eliminate
operator|&&
name|ep
operator|->
name|can_eliminate_previous
condition|)
block|{
name|ep
operator|->
name|can_eliminate_previous
operator|=
literal|0
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
operator|*
name|pset
argument_list|,
name|ep
operator|->
name|from
argument_list|)
expr_stmt|;
name|num_eliminable
operator|--
expr_stmt|;
block|}
block|}
if|#
directive|if
name|HARD_FRAME_POINTER_REGNUM
operator|!=
name|FRAME_POINTER_REGNUM
comment|/* If we didn't need a frame pointer last time, but we do now, spill      the hard frame pointer.  */
if|if
condition|(
name|frame_pointer_needed
operator|&&
operator|!
name|previous_frame_pointer_needed
condition|)
name|SET_HARD_REG_BIT
argument_list|(
operator|*
name|pset
argument_list|,
name|HARD_FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Initialize the table of registers to eliminate.  */
end_comment

begin_function
specifier|static
name|void
name|init_elim_table
parameter_list|()
block|{
name|struct
name|elim_table
modifier|*
name|ep
decl_stmt|;
ifdef|#
directive|ifdef
name|ELIMINABLE_REGS
specifier|const
name|struct
name|elim_table_1
modifier|*
name|ep1
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|reg_eliminate
condition|)
name|reg_eliminate
operator|=
operator|(
expr|struct
name|elim_table
operator|*
operator|)
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|elim_table
argument_list|)
argument_list|,
name|NUM_ELIMINABLE_REGS
argument_list|)
expr_stmt|;
comment|/* Does this function require a frame pointer?  */
name|frame_pointer_needed
operator|=
operator|(
operator|!
name|flag_omit_frame_pointer
ifdef|#
directive|ifdef
name|EXIT_IGNORE_STACK
comment|/* ?? If EXIT_IGNORE_STACK is set, we will not save 			     and restore sp for alloca.  So we can't eliminate 			     the frame pointer in that case.  At some point, 			     we should improve this by emitting the 			     sp-adjusting insns for this case.  */
operator|||
operator|(
name|current_function_calls_alloca
operator|&&
name|EXIT_IGNORE_STACK
operator|)
endif|#
directive|endif
operator|||
name|FRAME_POINTER_REQUIRED
operator|)
expr_stmt|;
name|num_eliminable
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|ELIMINABLE_REGS
for|for
control|(
name|ep
operator|=
name|reg_eliminate
operator|,
name|ep1
operator|=
name|reg_eliminate_1
init|;
name|ep
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|ep
operator|++
operator|,
name|ep1
operator|++
control|)
block|{
name|ep
operator|->
name|from
operator|=
name|ep1
operator|->
name|from
expr_stmt|;
name|ep
operator|->
name|to
operator|=
name|ep1
operator|->
name|to
expr_stmt|;
name|ep
operator|->
name|can_eliminate
operator|=
name|ep
operator|->
name|can_eliminate_previous
operator|=
operator|(
name|CAN_ELIMINATE
argument_list|(
name|ep
operator|->
name|from
argument_list|,
name|ep
operator|->
name|to
argument_list|)
operator|&&
operator|!
operator|(
name|ep
operator|->
name|to
operator|==
name|STACK_POINTER_REGNUM
operator|&&
name|frame_pointer_needed
operator|)
operator|)
expr_stmt|;
block|}
else|#
directive|else
name|reg_eliminate
index|[
literal|0
index|]
operator|.
name|from
operator|=
name|reg_eliminate_1
index|[
literal|0
index|]
operator|.
name|from
expr_stmt|;
name|reg_eliminate
index|[
literal|0
index|]
operator|.
name|to
operator|=
name|reg_eliminate_1
index|[
literal|0
index|]
operator|.
name|to
expr_stmt|;
name|reg_eliminate
index|[
literal|0
index|]
operator|.
name|can_eliminate
operator|=
name|reg_eliminate
index|[
literal|0
index|]
operator|.
name|can_eliminate_previous
operator|=
operator|!
name|frame_pointer_needed
expr_stmt|;
endif|#
directive|endif
comment|/* Count the number of eliminable registers and build the FROM and TO      REG rtx's.  Note that code in gen_rtx will cause, e.g.,      gen_rtx (REG, Pmode, STACK_POINTER_REGNUM) to equal stack_pointer_rtx.      We depend on this.  */
for|for
control|(
name|ep
operator|=
name|reg_eliminate
init|;
name|ep
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|ep
operator|++
control|)
block|{
name|num_eliminable
operator|+=
name|ep
operator|->
name|can_eliminate
expr_stmt|;
name|ep
operator|->
name|from_rtx
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|ep
operator|->
name|from
argument_list|)
expr_stmt|;
name|ep
operator|->
name|to_rtx
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|ep
operator|->
name|to
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Kick all pseudos out of hard register REGNO.     If CANT_ELIMINATE is nonzero, it means that we are doing this spill    because we found we can't eliminate some register.  In the case, no pseudos    are allowed to be in the register, even if they are only in a block that    doesn't require spill registers, unlike the case when we are spilling this    hard reg to produce another spill register.     Return nonzero if any pseudos needed to be kicked out.  */
end_comment

begin_function
specifier|static
name|void
name|spill_hard_reg
parameter_list|(
name|regno
parameter_list|,
name|cant_eliminate
parameter_list|)
name|unsigned
name|int
name|regno
decl_stmt|;
name|int
name|cant_eliminate
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|cant_eliminate
condition|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|bad_spill_regs_global
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|regs_ever_live
index|[
name|regno
index|]
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Spill every pseudo reg that was allocated to this reg      or to something that overlaps this reg.  */
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reg_renumber
index|[
name|i
index|]
operator|>=
literal|0
operator|&&
operator|(
name|unsigned
name|int
operator|)
name|reg_renumber
index|[
name|i
index|]
operator|<=
name|regno
operator|&&
operator|(
operator|(
name|unsigned
name|int
operator|)
name|reg_renumber
index|[
name|i
index|]
operator|+
name|HARD_REGNO_NREGS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|reg_renumber
index|[
name|i
index|]
argument_list|,
name|PSEUDO_REGNO_MODE
argument_list|(
name|i
argument_list|)
argument_list|)
operator|>
name|regno
operator|)
condition|)
name|SET_REGNO_REG_SET
argument_list|(
operator|&
name|spilled_pseudos
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* I'm getting weird preprocessor errors if I use IOR_HARD_REG_SET    from within EXECUTE_IF_SET_IN_REG_SET.  Hence this awkwardness.  */
end_comment

begin_function
specifier|static
name|void
name|ior_hard_reg_set
parameter_list|(
name|set1
parameter_list|,
name|set2
parameter_list|)
name|HARD_REG_SET
modifier|*
name|set1
decl_stmt|,
decl|*
name|set2
decl_stmt|;
end_function

begin_block
block|{
name|IOR_HARD_REG_SET
argument_list|(
operator|*
name|set1
argument_list|,
operator|*
name|set2
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* After find_reload_regs has been run for all insn that need reloads,    and/or spill_hard_regs was called, this function is used to actually    spill pseudo registers and try to reallocate them.  It also sets up the    spill_regs array for use by choose_reload_regs.  */
end_comment

begin_function
specifier|static
name|int
name|finish_spills
parameter_list|(
name|global
parameter_list|)
name|int
name|global
decl_stmt|;
block|{
name|struct
name|insn_chain
modifier|*
name|chain
decl_stmt|;
name|int
name|something_changed
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Build the spill_regs array for the function.  */
comment|/* If there are some registers still to eliminate and one of the spill regs      wasn't ever used before, additional stack space may have to be      allocated to store this register.  Thus, we may have changed the offset      between the stack and frame pointers, so mark that something has changed.       One might think that we need only set VAL to 1 if this is a call-used      register.  However, the set of registers that must be saved by the      prologue is not identical to the call-used set.  For example, the      register used by the call insn for the return PC is a call-used register,      but must be saved by the prologue.  */
name|n_spills
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|used_spill_regs
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|spill_reg_order
index|[
name|i
index|]
operator|=
name|n_spills
expr_stmt|;
name|spill_regs
index|[
name|n_spills
operator|++
index|]
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|num_eliminable
operator|&&
operator|!
name|regs_ever_live
index|[
name|i
index|]
condition|)
name|something_changed
operator|=
literal|1
expr_stmt|;
name|regs_ever_live
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|spill_reg_order
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|&spilled_pseudos
argument_list|,
argument|FIRST_PSEUDO_REGISTER
argument_list|,
argument|i
argument_list|,
argument|{
comment|/* Record the current hard register the pseudo is allocated to in 	  pseudo_previous_regs so we avoid reallocating it to the same 	  hard reg in a later pass.  */
argument|if (reg_renumber[i]<
literal|0
argument|) 	 abort ();         SET_HARD_REG_BIT (pseudo_previous_regs[i], reg_renumber[i]);
comment|/* Mark it as no longer having a hard register home.  */
argument|reg_renumber[i] = -
literal|1
argument|;
comment|/* We will need to scan everything again.  */
argument|something_changed =
literal|1
argument|;      }
argument_list|)
empty_stmt|;
comment|/* Retry global register allocation if possible.  */
if|if
condition|(
name|global
condition|)
block|{
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pseudo_forbidden_regs
argument_list|,
literal|0
argument_list|,
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|HARD_REG_SET
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For every insn that needs reloads, set the registers used as spill 	 regs in pseudo_forbidden_regs for every pseudo live across the 	 insn.  */
for|for
control|(
name|chain
operator|=
name|insns_need_reload
init|;
name|chain
condition|;
name|chain
operator|=
name|chain
operator|->
name|next_need_reload
control|)
block|{
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|&chain->live_throughout
argument_list|,
argument|FIRST_PSEUDO_REGISTER
argument_list|,
argument|i
argument_list|,
argument|{ 	       ior_hard_reg_set (pseudo_forbidden_regs + i,&chain->used_spill_regs); 	     }
argument_list|)
empty_stmt|;
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|&chain->dead_or_set
argument_list|,
argument|FIRST_PSEUDO_REGISTER
argument_list|,
argument|i
argument_list|,
argument|{ 	       ior_hard_reg_set (pseudo_forbidden_regs + i,&chain->used_spill_regs); 	     }
argument_list|)
empty_stmt|;
block|}
comment|/* Retry allocating the spilled pseudos.  For each reg, merge the 	 various reg sets that indicate which hard regs can't be used, 	 and call retry_global_alloc. 	 We change spill_pseudos here to only contain pseudos that did not 	 get a new hard register.  */
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reg_old_renumber
index|[
name|i
index|]
operator|!=
name|reg_renumber
index|[
name|i
index|]
condition|)
block|{
name|HARD_REG_SET
name|forbidden
decl_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|forbidden
argument_list|,
name|bad_spill_regs_global
argument_list|)
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|forbidden
argument_list|,
name|pseudo_forbidden_regs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|forbidden
argument_list|,
name|pseudo_previous_regs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|retry_global_alloc
argument_list|(
name|i
argument_list|,
name|forbidden
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_renumber
index|[
name|i
index|]
operator|>=
literal|0
condition|)
name|CLEAR_REGNO_REG_SET
argument_list|(
operator|&
name|spilled_pseudos
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Fix up the register information in the insn chain.      This involves deleting those of the spilled pseudos which did not get      a new hard register home from the live_{before,after} sets.  */
for|for
control|(
name|chain
operator|=
name|reload_insn_chain
init|;
name|chain
condition|;
name|chain
operator|=
name|chain
operator|->
name|next
control|)
block|{
name|HARD_REG_SET
name|used_by_pseudos
decl_stmt|;
name|HARD_REG_SET
name|used_by_pseudos2
decl_stmt|;
name|AND_COMPL_REG_SET
argument_list|(
operator|&
name|chain
operator|->
name|live_throughout
argument_list|,
operator|&
name|spilled_pseudos
argument_list|)
expr_stmt|;
name|AND_COMPL_REG_SET
argument_list|(
operator|&
name|chain
operator|->
name|dead_or_set
argument_list|,
operator|&
name|spilled_pseudos
argument_list|)
expr_stmt|;
comment|/* Mark any unallocated hard regs as available for spills.  That 	 makes inheritance work somewhat better.  */
if|if
condition|(
name|chain
operator|->
name|need_reload
condition|)
block|{
name|REG_SET_TO_HARD_REG_SET
argument_list|(
name|used_by_pseudos
argument_list|,
operator|&
name|chain
operator|->
name|live_throughout
argument_list|)
expr_stmt|;
name|REG_SET_TO_HARD_REG_SET
argument_list|(
name|used_by_pseudos2
argument_list|,
operator|&
name|chain
operator|->
name|dead_or_set
argument_list|)
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|used_by_pseudos
argument_list|,
name|used_by_pseudos2
argument_list|)
expr_stmt|;
comment|/* Save the old value for the sanity test below.  */
name|COPY_HARD_REG_SET
argument_list|(
name|used_by_pseudos2
argument_list|,
name|chain
operator|->
name|used_spill_regs
argument_list|)
expr_stmt|;
name|compute_use_by_pseudos
argument_list|(
operator|&
name|used_by_pseudos
argument_list|,
operator|&
name|chain
operator|->
name|live_throughout
argument_list|)
expr_stmt|;
name|compute_use_by_pseudos
argument_list|(
operator|&
name|used_by_pseudos
argument_list|,
operator|&
name|chain
operator|->
name|dead_or_set
argument_list|)
expr_stmt|;
name|COMPL_HARD_REG_SET
argument_list|(
name|chain
operator|->
name|used_spill_regs
argument_list|,
name|used_by_pseudos
argument_list|)
expr_stmt|;
name|AND_HARD_REG_SET
argument_list|(
name|chain
operator|->
name|used_spill_regs
argument_list|,
name|used_spill_regs
argument_list|)
expr_stmt|;
comment|/* Make sure we only enlarge the set.  */
name|GO_IF_HARD_REG_SUBSET
argument_list|(
name|used_by_pseudos2
argument_list|,
name|chain
operator|->
name|used_spill_regs
argument_list|,
name|ok
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
name|ok
label|:
empty_stmt|;
block|}
block|}
comment|/* Let alter_reg modify the reg rtx's for the modified pseudos.  */
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
block|{
name|int
name|regno
init|=
name|reg_renumber
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|reg_old_renumber
index|[
name|i
index|]
operator|==
name|regno
condition|)
continue|continue;
name|alter_reg
argument_list|(
name|i
argument_list|,
name|reg_old_renumber
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|reg_old_renumber
index|[
name|i
index|]
operator|=
name|regno
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
block|{
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|" Register %d now on stack.\n\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|" Register %d now in %d.\n\n"
argument_list|,
name|i
argument_list|,
name|reg_renumber
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|something_changed
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find all paradoxical subregs within X and update reg_max_ref_width.    Also mark any hard registers used to store user variables as    forbidden from being used for spill registers.  */
end_comment

begin_function
specifier|static
name|void
name|scan_paradoxical_subregs
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
if|#
directive|if
literal|0
block|if (SMALL_REGISTER_CLASSES&& REGNO (x)< FIRST_PSEUDO_REGISTER&& REG_USERVAR_P (x)) 	SET_HARD_REG_BIT (bad_spill_regs_global, REGNO (x));
endif|#
directive|endif
return|return;
case|case
name|CONST_INT
case|:
case|case
name|CONST
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CC0
case|:
case|case
name|PC
case|:
case|case
name|USE
case|:
case|case
name|CLOBBER
case|:
return|return;
case|case
name|SUBREG
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
condition|)
name|reg_max_ref_width
index|[
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
index|]
operator|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return;
default|default:
break|break;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|scan_paradoxical_subregs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|scan_paradoxical_subregs
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Reload pseudo-registers into hard regs around each insn as needed.    Additional register load insns are output before the insn that needs it    and perhaps store insns after insns that modify the reloaded pseudo reg.     reg_last_reload_reg and reg_reloaded_contents keep track of    which registers are already available in reload registers.    We update these for the reloads that we perform,    as the insns are scanned.  */
end_comment

begin_function
specifier|static
name|void
name|reload_as_needed
parameter_list|(
name|live_known
parameter_list|)
name|int
name|live_known
decl_stmt|;
block|{
name|struct
name|insn_chain
modifier|*
name|chain
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|AUTO_INC_DEC
argument_list|)
name|int
name|i
decl_stmt|;
endif|#
directive|endif
name|rtx
name|x
decl_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|spill_reg_rtx
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|spill_reg_rtx
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|spill_reg_store
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|spill_reg_store
argument_list|)
expr_stmt|;
name|reg_last_reload_reg
operator|=
operator|(
name|rtx
operator|*
operator|)
name|xcalloc
argument_list|(
name|max_regno
argument_list|,
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|reg_has_output_reload
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|max_regno
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|reg_reloaded_valid
argument_list|)
expr_stmt|;
name|set_initial_elim_offsets
argument_list|()
expr_stmt|;
for|for
control|(
name|chain
operator|=
name|reload_insn_chain
init|;
name|chain
condition|;
name|chain
operator|=
name|chain
operator|->
name|next
control|)
block|{
name|rtx
name|prev
decl_stmt|;
name|rtx
name|insn
init|=
name|chain
operator|->
name|insn
decl_stmt|;
name|rtx
name|old_next
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* If we pass a label, copy the offsets from the label information 	 into the current offsets of each elimination.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|set_offsets_for_label
argument_list|(
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|oldpat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* If this is a USE and CLOBBER of a MEM, ensure that any 	     references to eliminable registers have been removed.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|=
name|eliminate_regs
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
comment|/* If we need to do register elimination processing, do so. 	     This might delete the insn, in which case we are done.  */
if|if
condition|(
operator|(
name|num_eliminable
operator|||
name|num_eliminable_invariants
operator|)
operator|&&
name|chain
operator|->
name|need_elim
condition|)
block|{
name|eliminate_regs_in_insn
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
block|{
name|update_eliminable_offsets
argument_list|()
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* If need_elim is nonzero but need_reload is zero, one might think 	     that we could simply set n_reloads to 0.  However, find_reloads 	     could have done some manipulation of the insn (such as swapping 	     commutative operands), and these manipulations are lost during 	     the first pass for every insn that needs register elimination. 	     So the actions of find_reloads must be redone here.  */
if|if
condition|(
operator|!
name|chain
operator|->
name|need_elim
operator|&&
operator|!
name|chain
operator|->
name|need_reload
operator|&&
operator|!
name|chain
operator|->
name|need_operand_change
condition|)
name|n_reloads
operator|=
literal|0
expr_stmt|;
comment|/* First find the pseudo regs that must be reloaded for this insn. 	     This info is returned in the tables reload_... (see reload.h). 	     Also modify the body of INSN by substituting RELOAD 	     rtx's for those pseudo regs.  */
else|else
block|{
name|memset
argument_list|(
name|reg_has_output_reload
argument_list|,
literal|0
argument_list|,
name|max_regno
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|reg_is_output_reload
argument_list|)
expr_stmt|;
name|find_reloads
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|,
name|spill_indirect_levels
argument_list|,
name|live_known
argument_list|,
name|spill_reg_order
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n_reloads
operator|>
literal|0
condition|)
block|{
name|rtx
name|next
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|p
decl_stmt|;
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Now compute which reload regs to reload them into.  Perhaps 		 reusing reload regs from previous insns, or else output 		 load insns to reload them.  Maybe output store insns too. 		 Record the choices of reload reg in reload_reg_rtx.  */
name|choose_reload_regs
argument_list|(
name|chain
argument_list|)
expr_stmt|;
comment|/* Merge any reloads that we didn't combine for fear of 		 increasing the number of spill registers needed but now 		 discover can be safely merged.  */
if|if
condition|(
name|SMALL_REGISTER_CLASSES
condition|)
name|merge_assigned_reloads
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Generate the insns to reload operands into or out of 		 their reload regs.  */
name|emit_reload_insns
argument_list|(
name|chain
argument_list|)
expr_stmt|;
comment|/* Substitute the chosen reload regs from reload_reg_rtx 		 into the insn's body (or perhaps into the bodies of other 		 load and store insn that we just made for reloading 		 and that we moved the structure into).  */
name|subst_reloads
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* If this was an ASM, make sure that all the reload insns 		 we have generated are valid.  If not, give an error 		 and delete them.  */
if|if
condition|(
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
for|for
control|(
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|prev
argument_list|)
init|;
name|p
operator|!=
name|next
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
if|if
condition|(
name|p
operator|!=
name|insn
operator|&&
name|INSN_P
argument_list|(
name|p
argument_list|)
operator|&&
operator|(
name|recog_memoized
argument_list|(
name|p
argument_list|)
operator|<
literal|0
operator|||
operator|(
name|extract_insn
argument_list|(
name|p
argument_list|)
operator|,
operator|!
name|constrain_operands
argument_list|(
literal|1
argument_list|)
operator|)
operator|)
condition|)
block|{
name|error_for_asm
argument_list|(
name|insn
argument_list|,
literal|"`asm' operand requires impossible reload"
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|num_eliminable
operator|&&
name|chain
operator|->
name|need_elim
condition|)
name|update_eliminable_offsets
argument_list|()
expr_stmt|;
comment|/* Any previously reloaded spilled pseudo reg, stored in this insn, 	     is no longer validly lying around to save a future reload. 	     Note that this does not detect pseudos that were reloaded 	     for this insn in order to be stored in 	     (obeying register constraints).  That is correct; such reload 	     registers ARE still valid.  */
name|note_stores
argument_list|(
name|oldpat
argument_list|,
name|forget_old_reloads_1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* There may have been CLOBBER insns placed after INSN.  So scan 	     between INSN and NEXT and use them to forget old reloads.  */
for|for
control|(
name|x
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
init|;
name|x
operator|!=
name|old_next
condition|;
name|x
operator|=
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|x
argument_list|)
argument_list|,
name|forget_old_reloads_1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
comment|/* Likewise for regs altered by auto-increment in this insn. 	     REG_INC notes have been changed by reloading: 	     find_reloads_address_1 records substitutions for them, 	     which have been performed by subst_reloads above.  */
for|for
control|(
name|i
operator|=
name|n_reloads
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|rtx
name|in_reg
init|=
name|rld
index|[
name|i
index|]
operator|.
name|in_reg
decl_stmt|;
if|if
condition|(
name|in_reg
condition|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|in_reg
argument_list|)
decl_stmt|;
comment|/* PRE_INC / PRE_DEC will have the reload register ending up 		     with the same value as the stack slot, but that doesn't 		     hold true for POST_INC / POST_DEC.  Either we have to 		     convert the memory access to a true POST_INC / POST_DEC, 		     or we can't use the reload register for inheritance.  */
if|if
condition|(
operator|(
name|code
operator|==
name|POST_INC
operator|||
name|code
operator|==
name|POST_DEC
operator|)
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_reloaded_valid
argument_list|,
name|REGNO
argument_list|(
name|rld
index|[
name|i
index|]
operator|.
name|reg_rtx
argument_list|)
argument_list|)
comment|/* Make sure it is the inc/dec pseudo, and not 			 some other (e.g. output operand) pseudo.  */
operator|&&
operator|(
name|reg_reloaded_contents
index|[
name|REGNO
argument_list|(
name|rld
index|[
name|i
index|]
operator|.
name|reg_rtx
argument_list|)
index|]
operator|==
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|in_reg
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|reload_reg
init|=
name|rld
index|[
name|i
index|]
operator|.
name|reg_rtx
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|reload_reg
argument_list|)
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
name|rtx
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|PREV_INSN
argument_list|(
name|old_next
argument_list|)
init|;
name|p
operator|!=
name|prev
condition|;
name|p
operator|=
name|PREV_INSN
argument_list|(
name|p
argument_list|)
control|)
block|{
comment|/* We really want to ignore REG_INC notes here, so 			     use PATTERN (p) as argument to reg_set_p .  */
if|if
condition|(
name|reg_set_p
argument_list|(
name|reload_reg
argument_list|,
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
break|break;
name|n
operator|=
name|count_occurrences
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|,
name|reload_reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
continue|continue;
if|if
condition|(
name|n
operator|==
literal|1
condition|)
block|{
name|n
operator|=
name|validate_replace_rtx
argument_list|(
name|reload_reg
argument_list|,
name|gen_rtx
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|reload_reg
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* We must also verify that the constraints 				 are met after the replacement.  */
name|extract_insn
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
name|n
operator|=
name|constrain_operands
argument_list|(
literal|1
argument_list|)
expr_stmt|;
else|else
break|break;
comment|/* If the constraints were not met, then 				 undo the replacement.  */
if|if
condition|(
operator|!
name|n
condition|)
block|{
name|validate_replace_rtx
argument_list|(
name|gen_rtx
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|reload_reg
argument_list|)
argument_list|,
name|reload_reg
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
break|break;
block|}
if|if
condition|(
name|n
operator|==
literal|1
condition|)
block|{
name|REG_NOTES
argument_list|(
name|p
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_INC
argument_list|,
name|reload_reg
argument_list|,
name|REG_NOTES
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Mark this as having an output reload so that the 			     REG_INC processing code below won't invalidate 			     the reload for inheritance.  */
name|SET_HARD_REG_BIT
argument_list|(
name|reg_is_output_reload
argument_list|,
name|REGNO
argument_list|(
name|reload_reg
argument_list|)
argument_list|)
expr_stmt|;
name|reg_has_output_reload
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|in_reg
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|forget_old_reloads_1
argument_list|(
name|XEXP
argument_list|(
name|in_reg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|code
operator|==
name|PRE_INC
operator|||
name|code
operator|==
name|PRE_DEC
operator|)
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_reloaded_valid
argument_list|,
name|REGNO
argument_list|(
name|rld
index|[
name|i
index|]
operator|.
name|reg_rtx
argument_list|)
argument_list|)
comment|/* Make sure it is the inc/dec pseudo, and not 			      some other (e.g. output operand) pseudo.  */
operator|&&
operator|(
name|reg_reloaded_contents
index|[
name|REGNO
argument_list|(
name|rld
index|[
name|i
index|]
operator|.
name|reg_rtx
argument_list|)
index|]
operator|==
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|in_reg
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|reg_is_output_reload
argument_list|,
name|REGNO
argument_list|(
name|rld
index|[
name|i
index|]
operator|.
name|reg_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|reg_has_output_reload
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|in_reg
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* If a pseudo that got a hard register is auto-incremented, 	     we must purge records of copying it into pseudos without 	     hard registers.  */
for|for
control|(
name|x
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|x
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|x
argument_list|)
operator|==
name|REG_INC
condition|)
block|{
comment|/* See if this pseudo reg was reloaded in this insn. 		   If so, its last-reload info is still valid 		   because it is based on this insn's reload.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_reloads
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|rld
index|[
name|i
index|]
operator|.
name|out
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|n_reloads
condition|)
name|forget_old_reloads_1
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
comment|/* A reload reg's contents are unknown after a label.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|CLEAR_HARD_REG_SET
argument_list|(
name|reg_reloaded_valid
argument_list|)
expr_stmt|;
comment|/* Don't assume a reload reg is still good after a call insn 	 if it is a call-used reg.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|reg_reloaded_valid
argument_list|,
name|call_used_reg_set
argument_list|)
expr_stmt|;
block|}
comment|/* Clean up.  */
name|free
argument_list|(
name|reg_last_reload_reg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reg_has_output_reload
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Discard all record of any value reloaded from X,    or reloaded in X from someplace else;    unless X is an output reload reg of the current insn.     X may be a hard reg (the reload reg)    or it may be a pseudo reg that was reloaded from.  */
end_comment

begin_function
specifier|static
name|void
name|forget_old_reloads_1
parameter_list|(
name|x
parameter_list|,
name|ignored
parameter_list|,
name|data
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|ignored
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|unsigned
name|int
name|regno
decl_stmt|;
name|unsigned
name|int
name|nr
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
comment|/* note_stores does give us subregs of hard regs,      subreg_regno_offset will abort if it is not a hard reg.  */
while|while
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|offset
operator|+=
name|subreg_regno_offset
argument_list|(
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|x
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
condition|)
return|return;
name|regno
operator|=
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
name|offset
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|nr
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|nr
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Storing into a spilled-reg invalidates its contents. 	 This can happen if a block-local pseudo is allocated to that reg 	 and it wasn't spilled because this block's total need is 0. 	 Then some insn might have an optional reload and use this reg.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nr
condition|;
name|i
operator|++
control|)
comment|/* But don't do this if the reg actually serves as an output 	   reload reg in the current instruction.  */
if|if
condition|(
name|n_reloads
operator|==
literal|0
operator|||
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_is_output_reload
argument_list|,
name|regno
operator|+
name|i
argument_list|)
condition|)
block|{
name|CLEAR_HARD_REG_BIT
argument_list|(
name|reg_reloaded_valid
argument_list|,
name|regno
operator|+
name|i
argument_list|)
expr_stmt|;
name|spill_reg_store
index|[
name|regno
operator|+
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Since value of X has changed,      forget any value previously copied from it.  */
while|while
condition|(
name|nr
operator|--
operator|>
literal|0
condition|)
comment|/* But don't forget a copy if this is the output reload        that establishes the copy's validity.  */
if|if
condition|(
name|n_reloads
operator|==
literal|0
operator|||
name|reg_has_output_reload
index|[
name|regno
operator|+
name|nr
index|]
operator|==
literal|0
condition|)
name|reg_last_reload_reg
index|[
name|regno
operator|+
name|nr
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The following HARD_REG_SETs indicate when each hard register is    used for a reload of various parts of the current insn.  */
end_comment

begin_comment
comment|/* If reg is unavailable for all reloads.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|reload_reg_unavailable
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If reg is in use as a reload reg for a RELOAD_OTHER reload.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|reload_reg_used
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If reg is in use for a RELOAD_FOR_INPUT_ADDRESS reload for operand I.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|reload_reg_used_in_input_addr
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If reg is in use for a RELOAD_FOR_INPADDR_ADDRESS reload for operand I.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|reload_reg_used_in_inpaddr_addr
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If reg is in use for a RELOAD_FOR_OUTPUT_ADDRESS reload for operand I.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|reload_reg_used_in_output_addr
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If reg is in use for a RELOAD_FOR_OUTADDR_ADDRESS reload for operand I.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|reload_reg_used_in_outaddr_addr
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If reg is in use for a RELOAD_FOR_INPUT reload for operand I.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|reload_reg_used_in_input
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If reg is in use for a RELOAD_FOR_OUTPUT reload for operand I.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|reload_reg_used_in_output
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If reg is in use for a RELOAD_FOR_OPERAND_ADDRESS reload.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|reload_reg_used_in_op_addr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If reg is in use for a RELOAD_FOR_OPADDR_ADDR reload.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|reload_reg_used_in_op_addr_reload
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If reg is in use for a RELOAD_FOR_INSN reload.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|reload_reg_used_in_insn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If reg is in use for a RELOAD_FOR_OTHER_ADDRESS reload.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|reload_reg_used_in_other_addr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If reg is in use as a reload reg for any sort of reload.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|reload_reg_used_at_all
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If reg is use as an inherited reload.  We just mark the first register    in the group.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|reload_reg_used_for_inherit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Records which hard regs are used in any way, either as explicit use or    by being allocated to a pseudo during any point of the current insn.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|reg_used_in_insn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mark reg REGNO as in use for a reload of the sort spec'd by OPNUM and    TYPE. MODE is used to indicate how many consecutive regs are    actually used.  */
end_comment

begin_function
specifier|static
name|void
name|mark_reload_reg_in_use
parameter_list|(
name|regno
parameter_list|,
name|opnum
parameter_list|,
name|type
parameter_list|,
name|mode
parameter_list|)
name|unsigned
name|int
name|regno
decl_stmt|;
name|int
name|opnum
decl_stmt|;
name|enum
name|reload_type
name|type
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|unsigned
name|int
name|nregs
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|regno
init|;
name|i
operator|<
name|nregs
operator|+
name|regno
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|RELOAD_OTHER
case|:
name|SET_HARD_REG_BIT
argument_list|(
name|reload_reg_used
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_INPUT_ADDRESS
case|:
name|SET_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_input_addr
index|[
name|opnum
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_INPADDR_ADDRESS
case|:
name|SET_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_inpaddr_addr
index|[
name|opnum
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OUTPUT_ADDRESS
case|:
name|SET_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_output_addr
index|[
name|opnum
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OUTADDR_ADDRESS
case|:
name|SET_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_outaddr_addr
index|[
name|opnum
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OPERAND_ADDRESS
case|:
name|SET_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_op_addr
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OPADDR_ADDR
case|:
name|SET_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_op_addr_reload
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OTHER_ADDRESS
case|:
name|SET_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_other_addr
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_INPUT
case|:
name|SET_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_input
index|[
name|opnum
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OUTPUT
case|:
name|SET_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_output
index|[
name|opnum
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_INSN
case|:
name|SET_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_insn
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
name|SET_HARD_REG_BIT
argument_list|(
name|reload_reg_used_at_all
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Similarly, but show REGNO is no longer in use for a reload.  */
end_comment

begin_function
specifier|static
name|void
name|clear_reload_reg_in_use
parameter_list|(
name|regno
parameter_list|,
name|opnum
parameter_list|,
name|type
parameter_list|,
name|mode
parameter_list|)
name|unsigned
name|int
name|regno
decl_stmt|;
name|int
name|opnum
decl_stmt|;
name|enum
name|reload_type
name|type
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|unsigned
name|int
name|nregs
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|start_regno
decl_stmt|,
name|end_regno
decl_stmt|,
name|r
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* A complication is that for some reload types, inheritance might      allow multiple reloads of the same types to share a reload register.      We set check_opnum if we have to check only reloads with the same      operand number, and check_any if we have to check all reloads.  */
name|int
name|check_opnum
init|=
literal|0
decl_stmt|;
name|int
name|check_any
init|=
literal|0
decl_stmt|;
name|HARD_REG_SET
modifier|*
name|used_in_set
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|RELOAD_OTHER
case|:
name|used_in_set
operator|=
operator|&
name|reload_reg_used
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_INPUT_ADDRESS
case|:
name|used_in_set
operator|=
operator|&
name|reload_reg_used_in_input_addr
index|[
name|opnum
index|]
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_INPADDR_ADDRESS
case|:
name|check_opnum
operator|=
literal|1
expr_stmt|;
name|used_in_set
operator|=
operator|&
name|reload_reg_used_in_inpaddr_addr
index|[
name|opnum
index|]
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OUTPUT_ADDRESS
case|:
name|used_in_set
operator|=
operator|&
name|reload_reg_used_in_output_addr
index|[
name|opnum
index|]
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OUTADDR_ADDRESS
case|:
name|check_opnum
operator|=
literal|1
expr_stmt|;
name|used_in_set
operator|=
operator|&
name|reload_reg_used_in_outaddr_addr
index|[
name|opnum
index|]
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OPERAND_ADDRESS
case|:
name|used_in_set
operator|=
operator|&
name|reload_reg_used_in_op_addr
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OPADDR_ADDR
case|:
name|check_any
operator|=
literal|1
expr_stmt|;
name|used_in_set
operator|=
operator|&
name|reload_reg_used_in_op_addr_reload
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OTHER_ADDRESS
case|:
name|used_in_set
operator|=
operator|&
name|reload_reg_used_in_other_addr
expr_stmt|;
name|check_any
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_INPUT
case|:
name|used_in_set
operator|=
operator|&
name|reload_reg_used_in_input
index|[
name|opnum
index|]
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OUTPUT
case|:
name|used_in_set
operator|=
operator|&
name|reload_reg_used_in_output
index|[
name|opnum
index|]
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_INSN
case|:
name|used_in_set
operator|=
operator|&
name|reload_reg_used_in_insn
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* We resolve conflicts with remaining reloads of the same type by      excluding the intervals of of reload registers by them from the      interval of freed reload registers.  Since we only keep track of      one set of interval bounds, we might have to exclude somewhat      more than what would be necessary if we used a HARD_REG_SET here.      But this should only happen very infrequently, so there should      be no reason to worry about it.  */
name|start_regno
operator|=
name|regno
expr_stmt|;
name|end_regno
operator|=
name|regno
operator|+
name|nregs
expr_stmt|;
if|if
condition|(
name|check_opnum
operator|||
name|check_any
condition|)
block|{
for|for
control|(
name|i
operator|=
name|n_reloads
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|rld
index|[
name|i
index|]
operator|.
name|when_needed
operator|==
name|type
operator|&&
operator|(
name|check_any
operator|||
name|rld
index|[
name|i
index|]
operator|.
name|opnum
operator|==
name|opnum
operator|)
operator|&&
name|rld
index|[
name|i
index|]
operator|.
name|reg_rtx
condition|)
block|{
name|unsigned
name|int
name|conflict_start
init|=
name|true_regnum
argument_list|(
name|rld
index|[
name|i
index|]
operator|.
name|reg_rtx
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|conflict_end
init|=
operator|(
name|conflict_start
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|conflict_start
argument_list|,
name|rld
index|[
name|i
index|]
operator|.
name|mode
argument_list|)
operator|)
decl_stmt|;
comment|/* If there is an overlap with the first to-be-freed register, 		 adjust the interval start.  */
if|if
condition|(
name|conflict_start
operator|<=
name|start_regno
operator|&&
name|conflict_end
operator|>
name|start_regno
condition|)
name|start_regno
operator|=
name|conflict_end
expr_stmt|;
comment|/* Otherwise, if there is a conflict with one of the other 		 to-be-freed registers, adjust the interval end.  */
if|if
condition|(
name|conflict_start
operator|>
name|start_regno
operator|&&
name|conflict_start
operator|<
name|end_regno
condition|)
name|end_regno
operator|=
name|conflict_start
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|r
operator|=
name|start_regno
init|;
name|r
operator|<
name|end_regno
condition|;
name|r
operator|++
control|)
name|CLEAR_HARD_REG_BIT
argument_list|(
operator|*
name|used_in_set
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* 1 if reg REGNO is free as a reload reg for a reload of the sort    specified by OPNUM and TYPE.  */
end_comment

begin_function
specifier|static
name|int
name|reload_reg_free_p
parameter_list|(
name|regno
parameter_list|,
name|opnum
parameter_list|,
name|type
parameter_list|)
name|unsigned
name|int
name|regno
decl_stmt|;
name|int
name|opnum
decl_stmt|;
name|enum
name|reload_type
name|type
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/* In use for a RELOAD_OTHER means it's not available for anything.  */
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_unavailable
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|RELOAD_OTHER
case|:
comment|/* In use for anything means we can't use it for RELOAD_OTHER.  */
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_other_addr
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_op_addr
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_insn
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reload_n_operands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_input_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_inpaddr_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_output_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_outaddr_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_input
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_output
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
case|case
name|RELOAD_FOR_INPUT
case|:
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_insn
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_op_addr
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_op_addr_reload
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If it is used for some other input, can't use it.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reload_n_operands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_input
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If it is used in a later operand's address, can't use it.  */
for|for
control|(
name|i
operator|=
name|opnum
operator|+
literal|1
init|;
name|i
operator|<
name|reload_n_operands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_input_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_inpaddr_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
case|case
name|RELOAD_FOR_INPUT_ADDRESS
case|:
comment|/* Can't use a register if it is used for an input address for this 	 operand or used as an input in an earlier one.  */
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_input_addr
index|[
name|opnum
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_inpaddr_addr
index|[
name|opnum
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|opnum
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_input
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
case|case
name|RELOAD_FOR_INPADDR_ADDRESS
case|:
comment|/* Can't use a register if it is used for an input address 	 for this operand or used as an input in an earlier 	 one.  */
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_inpaddr_addr
index|[
name|opnum
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|opnum
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_input
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
case|case
name|RELOAD_FOR_OUTPUT_ADDRESS
case|:
comment|/* Can't use a register if it is used for an output address for this 	 operand or used as an output in this or a later operand.  Note 	 that multiple output operands are emitted in reverse order, so 	 the conflicting ones are those with lower indices.  */
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_output_addr
index|[
name|opnum
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|opnum
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_output
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
case|case
name|RELOAD_FOR_OUTADDR_ADDRESS
case|:
comment|/* Can't use a register if it is used for an output address 	 for this operand or used as an output in this or a 	 later operand.  Note that multiple output operands are 	 emitted in reverse order, so the conflicting ones are 	 those with lower indices.  */
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_outaddr_addr
index|[
name|opnum
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|opnum
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_output
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
case|case
name|RELOAD_FOR_OPERAND_ADDRESS
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reload_n_operands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_input
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
operator|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_insn
argument_list|,
name|regno
argument_list|)
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_op_addr
argument_list|,
name|regno
argument_list|)
operator|)
return|;
case|case
name|RELOAD_FOR_OPADDR_ADDR
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reload_n_operands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_input
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
operator|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_op_addr_reload
argument_list|,
name|regno
argument_list|)
operator|)
return|;
case|case
name|RELOAD_FOR_OUTPUT
case|:
comment|/* This cannot share a register with RELOAD_FOR_INSN reloads, other 	 outputs, or an operand address for this or an earlier output. 	 Note that multiple output operands are emitted in reverse order, 	 so the conflicting ones are those with higher indices.  */
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_insn
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reload_n_operands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_output
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
name|opnum
init|;
name|i
operator|<
name|reload_n_operands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_output_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_outaddr_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
case|case
name|RELOAD_FOR_INSN
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reload_n_operands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_input
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_output
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
operator|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_insn
argument_list|,
name|regno
argument_list|)
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_op_addr
argument_list|,
name|regno
argument_list|)
operator|)
return|;
case|case
name|RELOAD_FOR_OTHER_ADDRESS
case|:
return|return
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_other_addr
argument_list|,
name|regno
argument_list|)
return|;
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return 1 if the value in reload reg REGNO, as used by a reload    needed for the part of the insn specified by OPNUM and TYPE,    is still available in REGNO at the end of the insn.     We can assume that the reload reg was already tested for availability    at the time it is needed, and we should not check this again,    in case the reg has already been marked in use.  */
end_comment

begin_function
specifier|static
name|int
name|reload_reg_reaches_end_p
parameter_list|(
name|regno
parameter_list|,
name|opnum
parameter_list|,
name|type
parameter_list|)
name|unsigned
name|int
name|regno
decl_stmt|;
name|int
name|opnum
decl_stmt|;
name|enum
name|reload_type
name|type
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|RELOAD_OTHER
case|:
comment|/* Since a RELOAD_OTHER reload claims the reg for the entire insn, 	 its value must reach the end.  */
return|return
literal|1
return|;
comment|/* If this use is for part of the insn, 	 its value reaches if no subsequent part uses the same register. 	 Just like the above function, don't try to do this with lots 	 of fallthroughs.  */
case|case
name|RELOAD_FOR_OTHER_ADDRESS
case|:
comment|/* Here we check for everything else, since these don't conflict 	 with anything else and everything comes later.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reload_n_operands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_output_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_outaddr_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_output
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_input_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_inpaddr_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_input
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
operator|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_op_addr
argument_list|,
name|regno
argument_list|)
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_insn
argument_list|,
name|regno
argument_list|)
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used
argument_list|,
name|regno
argument_list|)
operator|)
return|;
case|case
name|RELOAD_FOR_INPUT_ADDRESS
case|:
case|case
name|RELOAD_FOR_INPADDR_ADDRESS
case|:
comment|/* Similar, except that we check only for this and subsequent inputs 	 and the address of only subsequent inputs and we do not need 	 to check for RELOAD_OTHER objects since they are known not to 	 conflict.  */
for|for
control|(
name|i
operator|=
name|opnum
init|;
name|i
operator|<
name|reload_n_operands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_input
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
name|opnum
operator|+
literal|1
init|;
name|i
operator|<
name|reload_n_operands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_input_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_inpaddr_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reload_n_operands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_output_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_outaddr_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_output
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_op_addr_reload
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
operator|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_op_addr
argument_list|,
name|regno
argument_list|)
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_insn
argument_list|,
name|regno
argument_list|)
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used
argument_list|,
name|regno
argument_list|)
operator|)
return|;
case|case
name|RELOAD_FOR_INPUT
case|:
comment|/* Similar to input address, except we start at the next operand for 	 both input and input address and we do not check for 	 RELOAD_FOR_OPERAND_ADDRESS and RELOAD_FOR_INSN since these 	 would conflict.  */
for|for
control|(
name|i
operator|=
name|opnum
operator|+
literal|1
init|;
name|i
operator|<
name|reload_n_operands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_input_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_inpaddr_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_input
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* ... fall through ...  */
case|case
name|RELOAD_FOR_OPERAND_ADDRESS
case|:
comment|/* Check outputs and their addresses.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reload_n_operands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_output_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_outaddr_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_output
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
operator|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used
argument_list|,
name|regno
argument_list|)
operator|)
return|;
case|case
name|RELOAD_FOR_OPADDR_ADDR
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reload_n_operands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_output_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_outaddr_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_output
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
operator|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_op_addr
argument_list|,
name|regno
argument_list|)
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_insn
argument_list|,
name|regno
argument_list|)
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used
argument_list|,
name|regno
argument_list|)
operator|)
return|;
case|case
name|RELOAD_FOR_INSN
case|:
comment|/* These conflict with other outputs with RELOAD_OTHER.  So 	 we need only check for output addresses.  */
name|opnum
operator|=
name|reload_n_operands
expr_stmt|;
comment|/* ... fall through ...  */
case|case
name|RELOAD_FOR_OUTPUT
case|:
case|case
name|RELOAD_FOR_OUTPUT_ADDRESS
case|:
case|case
name|RELOAD_FOR_OUTADDR_ADDRESS
case|:
comment|/* We already know these can't conflict with a later output.  So the 	 only thing to check are later output addresses. 	 Note that multiple output operands are emitted in reverse order, 	 so the conflicting ones are those with lower indices.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|opnum
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_output_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_outaddr_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if the reloads denoted by R1 and R2 cannot share a register.    Return 0 otherwise.     This function uses the same algorithm as reload_reg_free_p above.  */
end_comment

begin_function
name|int
name|reloads_conflict
parameter_list|(
name|r1
parameter_list|,
name|r2
parameter_list|)
name|int
name|r1
decl_stmt|,
name|r2
decl_stmt|;
block|{
name|enum
name|reload_type
name|r1_type
init|=
name|rld
index|[
name|r1
index|]
operator|.
name|when_needed
decl_stmt|;
name|enum
name|reload_type
name|r2_type
init|=
name|rld
index|[
name|r2
index|]
operator|.
name|when_needed
decl_stmt|;
name|int
name|r1_opnum
init|=
name|rld
index|[
name|r1
index|]
operator|.
name|opnum
decl_stmt|;
name|int
name|r2_opnum
init|=
name|rld
index|[
name|r2
index|]
operator|.
name|opnum
decl_stmt|;
comment|/* RELOAD_OTHER conflicts with everything.  */
if|if
condition|(
name|r2_type
operator|==
name|RELOAD_OTHER
condition|)
return|return
literal|1
return|;
comment|/* Otherwise, check conflicts differently for each type.  */
switch|switch
condition|(
name|r1_type
condition|)
block|{
case|case
name|RELOAD_FOR_INPUT
case|:
return|return
operator|(
name|r2_type
operator|==
name|RELOAD_FOR_INSN
operator|||
name|r2_type
operator|==
name|RELOAD_FOR_OPERAND_ADDRESS
operator|||
name|r2_type
operator|==
name|RELOAD_FOR_OPADDR_ADDR
operator|||
name|r2_type
operator|==
name|RELOAD_FOR_INPUT
operator|||
operator|(
operator|(
name|r2_type
operator|==
name|RELOAD_FOR_INPUT_ADDRESS
operator|||
name|r2_type
operator|==
name|RELOAD_FOR_INPADDR_ADDRESS
operator|)
operator|&&
name|r2_opnum
operator|>
name|r1_opnum
operator|)
operator|)
return|;
case|case
name|RELOAD_FOR_INPUT_ADDRESS
case|:
return|return
operator|(
operator|(
name|r2_type
operator|==
name|RELOAD_FOR_INPUT_ADDRESS
operator|&&
name|r1_opnum
operator|==
name|r2_opnum
operator|)
operator|||
operator|(
name|r2_type
operator|==
name|RELOAD_FOR_INPUT
operator|&&
name|r2_opnum
operator|<
name|r1_opnum
operator|)
operator|)
return|;
case|case
name|RELOAD_FOR_INPADDR_ADDRESS
case|:
return|return
operator|(
operator|(
name|r2_type
operator|==
name|RELOAD_FOR_INPADDR_ADDRESS
operator|&&
name|r1_opnum
operator|==
name|r2_opnum
operator|)
operator|||
operator|(
name|r2_type
operator|==
name|RELOAD_FOR_INPUT
operator|&&
name|r2_opnum
operator|<
name|r1_opnum
operator|)
operator|)
return|;
case|case
name|RELOAD_FOR_OUTPUT_ADDRESS
case|:
return|return
operator|(
operator|(
name|r2_type
operator|==
name|RELOAD_FOR_OUTPUT_ADDRESS
operator|&&
name|r2_opnum
operator|==
name|r1_opnum
operator|)
operator|||
operator|(
name|r2_type
operator|==
name|RELOAD_FOR_OUTPUT
operator|&&
name|r2_opnum
operator|<=
name|r1_opnum
operator|)
operator|)
return|;
case|case
name|RELOAD_FOR_OUTADDR_ADDRESS
case|:
return|return
operator|(
operator|(
name|r2_type
operator|==
name|RELOAD_FOR_OUTADDR_ADDRESS
operator|&&
name|r2_opnum
operator|==
name|r1_opnum
operator|)
operator|||
operator|(
name|r2_type
operator|==
name|RELOAD_FOR_OUTPUT
operator|&&
name|r2_opnum
operator|<=
name|r1_opnum
operator|)
operator|)
return|;
case|case
name|RELOAD_FOR_OPERAND_ADDRESS
case|:
return|return
operator|(
name|r2_type
operator|==
name|RELOAD_FOR_INPUT
operator|||
name|r2_type
operator|==
name|RELOAD_FOR_INSN
operator|||
name|r2_type
operator|==
name|RELOAD_FOR_OPERAND_ADDRESS
operator|)
return|;
case|case
name|RELOAD_FOR_OPADDR_ADDR
case|:
return|return
operator|(
name|r2_type
operator|==
name|RELOAD_FOR_INPUT
operator|||
name|r2_type
operator|==
name|RELOAD_FOR_OPADDR_ADDR
operator|)
return|;
case|case
name|RELOAD_FOR_OUTPUT
case|:
return|return
operator|(
name|r2_type
operator|==
name|RELOAD_FOR_INSN
operator|||
name|r2_type
operator|==
name|RELOAD_FOR_OUTPUT
operator|||
operator|(
operator|(
name|r2_type
operator|==
name|RELOAD_FOR_OUTPUT_ADDRESS
operator|||
name|r2_type
operator|==
name|RELOAD_FOR_OUTADDR_ADDRESS
operator|)
operator|&&
name|r2_opnum
operator|>=
name|r1_opnum
operator|)
operator|)
return|;
case|case
name|RELOAD_FOR_INSN
case|:
return|return
operator|(
name|r2_type
operator|==
name|RELOAD_FOR_INPUT
operator|||
name|r2_type
operator|==
name|RELOAD_FOR_OUTPUT
operator|||
name|r2_type
operator|==
name|RELOAD_FOR_INSN
operator|||
name|r2_type
operator|==
name|RELOAD_FOR_OPERAND_ADDRESS
operator|)
return|;
case|case
name|RELOAD_FOR_OTHER_ADDRESS
case|:
return|return
name|r2_type
operator|==
name|RELOAD_FOR_OTHER_ADDRESS
return|;
case|case
name|RELOAD_OTHER
case|:
return|return
literal|1
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Indexed by reload number, 1 if incoming value    inherited from previous insns.  */
end_comment

begin_decl_stmt
name|char
name|reload_inherited
index|[
name|MAX_RELOADS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For an inherited reload, this is the insn the reload was inherited from,    if we know it.  Otherwise, this is 0.  */
end_comment

begin_decl_stmt
name|rtx
name|reload_inheritance_insn
index|[
name|MAX_RELOADS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If non-zero, this is a place to get the value of the reload,    rather than using reload_in.  */
end_comment

begin_decl_stmt
name|rtx
name|reload_override_in
index|[
name|MAX_RELOADS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For each reload, the hard register number of the register used,    or -1 if we did not need a register for this reload.  */
end_comment

begin_decl_stmt
name|int
name|reload_spill_index
index|[
name|MAX_RELOADS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Subroutine of free_for_value_p, used to check a single register.    START_REGNO is the starting regno of the full reload register    (possibly comprising multiple hard registers) that we are considering.  */
end_comment

begin_function
specifier|static
name|int
name|reload_reg_free_for_value_p
parameter_list|(
name|start_regno
parameter_list|,
name|regno
parameter_list|,
name|opnum
parameter_list|,
name|type
parameter_list|,
name|value
parameter_list|,
name|out
parameter_list|,
name|reloadnum
parameter_list|,
name|ignore_address_reloads
parameter_list|)
name|int
name|start_regno
decl_stmt|,
name|regno
decl_stmt|;
name|int
name|opnum
decl_stmt|;
name|enum
name|reload_type
name|type
decl_stmt|;
name|rtx
name|value
decl_stmt|,
name|out
decl_stmt|;
name|int
name|reloadnum
decl_stmt|;
name|int
name|ignore_address_reloads
decl_stmt|;
block|{
name|int
name|time1
decl_stmt|;
comment|/* Set if we see an input reload that must not share its reload register      with any new earlyclobber, but might otherwise share the reload      register with an output or input-output reload.  */
name|int
name|check_earlyclobber
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|copy
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_unavailable
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|out
operator|==
name|const0_rtx
condition|)
block|{
name|copy
operator|=
literal|1
expr_stmt|;
name|out
operator|=
name|NULL_RTX
expr_stmt|;
block|}
comment|/* We use some pseudo 'time' value to check if the lifetimes of the      new register use would overlap with the one of a previous reload      that is not read-only or uses a different value.      The 'time' used doesn't have to be linear in any shape or form, just      monotonic.      Some reload types use different 'buckets' for each operand.      So there are MAX_RECOG_OPERANDS different time values for each      such reload type.      We compute TIME1 as the time when the register for the prospective      new reload ceases to be live, and TIME2 for each existing      reload as the time when that the reload register of that reload      becomes live.      Where there is little to be gained by exact lifetime calculations,      we just make conservative assumptions, i.e. a longer lifetime;      this is done in the 'default:' cases.  */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|RELOAD_FOR_OTHER_ADDRESS
case|:
comment|/* RELOAD_FOR_OTHER_ADDRESS conflicts with RELOAD_OTHER reloads.  */
name|time1
operator|=
name|copy
condition|?
literal|0
else|:
literal|1
expr_stmt|;
break|break;
case|case
name|RELOAD_OTHER
case|:
name|time1
operator|=
name|copy
condition|?
literal|1
else|:
name|MAX_RECOG_OPERANDS
operator|*
literal|5
operator|+
literal|5
expr_stmt|;
break|break;
comment|/* For each input, we may have a sequence of RELOAD_FOR_INPADDR_ADDRESS, 	 RELOAD_FOR_INPUT_ADDRESS and RELOAD_FOR_INPUT.  By adding 0 / 1 / 2 , 	 respectively, to the time values for these, we get distinct time 	 values.  To get distinct time values for each operand, we have to 	 multiply opnum by at least three.  We round that up to four because 	 multiply by four is often cheaper.  */
case|case
name|RELOAD_FOR_INPADDR_ADDRESS
case|:
name|time1
operator|=
name|opnum
operator|*
literal|4
operator|+
literal|2
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_INPUT_ADDRESS
case|:
name|time1
operator|=
name|opnum
operator|*
literal|4
operator|+
literal|3
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_INPUT
case|:
comment|/* All RELOAD_FOR_INPUT reloads remain live till the instruction 	 executes (inclusive).  */
name|time1
operator|=
name|copy
condition|?
name|opnum
operator|*
literal|4
operator|+
literal|4
else|:
name|MAX_RECOG_OPERANDS
operator|*
literal|4
operator|+
literal|3
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OPADDR_ADDR
case|:
comment|/* opnum * 4 + 4<= (MAX_RECOG_OPERANDS - 1) * 4 + 4 == MAX_RECOG_OPERANDS * 4 */
name|time1
operator|=
name|MAX_RECOG_OPERANDS
operator|*
literal|4
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OPERAND_ADDRESS
case|:
comment|/* RELOAD_FOR_OPERAND_ADDRESS reloads are live even while the insn 	 is executed.  */
name|time1
operator|=
name|copy
condition|?
name|MAX_RECOG_OPERANDS
operator|*
literal|4
operator|+
literal|2
else|:
name|MAX_RECOG_OPERANDS
operator|*
literal|4
operator|+
literal|3
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OUTADDR_ADDRESS
case|:
name|time1
operator|=
name|MAX_RECOG_OPERANDS
operator|*
literal|4
operator|+
literal|4
operator|+
name|opnum
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OUTPUT_ADDRESS
case|:
name|time1
operator|=
name|MAX_RECOG_OPERANDS
operator|*
literal|4
operator|+
literal|5
operator|+
name|opnum
expr_stmt|;
break|break;
default|default:
name|time1
operator|=
name|MAX_RECOG_OPERANDS
operator|*
literal|5
operator|+
literal|5
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_reloads
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|reg
init|=
name|rld
index|[
name|i
index|]
operator|.
name|reg_rtx
decl_stmt|;
if|if
condition|(
name|reg
operator|&&
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|REG
operator|&&
operator|(
operator|(
name|unsigned
operator|)
name|regno
operator|-
name|true_regnum
argument_list|(
name|reg
argument_list|)
operator|<=
name|HARD_REGNO_NREGS
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|-
operator|(
name|unsigned
operator|)
literal|1
operator|)
operator|&&
name|i
operator|!=
name|reloadnum
condition|)
block|{
name|rtx
name|other_input
init|=
name|rld
index|[
name|i
index|]
operator|.
name|in
decl_stmt|;
comment|/* If the other reload loads the same input value, that 	     will not cause a conflict only if it's loading it into 	     the same register.  */
if|if
condition|(
name|true_regnum
argument_list|(
name|reg
argument_list|)
operator|!=
name|start_regno
condition|)
name|other_input
operator|=
name|NULL_RTX
expr_stmt|;
if|if
condition|(
operator|!
name|other_input
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|other_input
argument_list|,
name|value
argument_list|)
operator|||
name|rld
index|[
name|i
index|]
operator|.
name|out
operator|||
name|out
condition|)
block|{
name|int
name|time2
decl_stmt|;
switch|switch
condition|(
name|rld
index|[
name|i
index|]
operator|.
name|when_needed
condition|)
block|{
case|case
name|RELOAD_FOR_OTHER_ADDRESS
case|:
name|time2
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_INPADDR_ADDRESS
case|:
comment|/* find_reloads makes sure that a 		     RELOAD_FOR_{INP,OP,OUT}ADDR_ADDRESS reload is only used 		     by at most one - the first - 		     RELOAD_FOR_{INPUT,OPERAND,OUTPUT}_ADDRESS .  If the 		     address reload is inherited, the address address reload 		     goes away, so we can ignore this conflict.  */
if|if
condition|(
name|type
operator|==
name|RELOAD_FOR_INPUT_ADDRESS
operator|&&
name|reloadnum
operator|==
name|i
operator|+
literal|1
operator|&&
name|ignore_address_reloads
comment|/* Unless the RELOAD_FOR_INPUT is an auto_inc expression. 			 Then the address address is still needed to store 			 back the new address.  */
operator|&&
operator|!
name|rld
index|[
name|reloadnum
index|]
operator|.
name|out
condition|)
continue|continue;
comment|/* Likewise, if a RELOAD_FOR_INPUT can inherit a value, its 		     RELOAD_FOR_INPUT_ADDRESS / RELOAD_FOR_INPADDR_ADDRESS 		     reloads go away.  */
if|if
condition|(
name|type
operator|==
name|RELOAD_FOR_INPUT
operator|&&
name|opnum
operator|==
name|rld
index|[
name|i
index|]
operator|.
name|opnum
operator|&&
name|ignore_address_reloads
comment|/* Unless we are reloading an auto_inc expression.  */
operator|&&
operator|!
name|rld
index|[
name|reloadnum
index|]
operator|.
name|out
condition|)
continue|continue;
name|time2
operator|=
name|rld
index|[
name|i
index|]
operator|.
name|opnum
operator|*
literal|4
operator|+
literal|2
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_INPUT_ADDRESS
case|:
if|if
condition|(
name|type
operator|==
name|RELOAD_FOR_INPUT
operator|&&
name|opnum
operator|==
name|rld
index|[
name|i
index|]
operator|.
name|opnum
operator|&&
name|ignore_address_reloads
operator|&&
operator|!
name|rld
index|[
name|reloadnum
index|]
operator|.
name|out
condition|)
continue|continue;
name|time2
operator|=
name|rld
index|[
name|i
index|]
operator|.
name|opnum
operator|*
literal|4
operator|+
literal|3
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_INPUT
case|:
name|time2
operator|=
name|rld
index|[
name|i
index|]
operator|.
name|opnum
operator|*
literal|4
operator|+
literal|4
expr_stmt|;
name|check_earlyclobber
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* rld[i].opnum * 4 + 4<= (MAX_RECOG_OPERAND - 1) * 4 + 4 		     == MAX_RECOG_OPERAND * 4  */
case|case
name|RELOAD_FOR_OPADDR_ADDR
case|:
if|if
condition|(
name|type
operator|==
name|RELOAD_FOR_OPERAND_ADDRESS
operator|&&
name|reloadnum
operator|==
name|i
operator|+
literal|1
operator|&&
name|ignore_address_reloads
operator|&&
operator|!
name|rld
index|[
name|reloadnum
index|]
operator|.
name|out
condition|)
continue|continue;
name|time2
operator|=
name|MAX_RECOG_OPERANDS
operator|*
literal|4
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OPERAND_ADDRESS
case|:
name|time2
operator|=
name|MAX_RECOG_OPERANDS
operator|*
literal|4
operator|+
literal|2
expr_stmt|;
name|check_earlyclobber
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_INSN
case|:
name|time2
operator|=
name|MAX_RECOG_OPERANDS
operator|*
literal|4
operator|+
literal|3
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OUTPUT
case|:
comment|/* All RELOAD_FOR_OUTPUT reloads become live just after the 		     instruction is executed.  */
name|time2
operator|=
name|MAX_RECOG_OPERANDS
operator|*
literal|4
operator|+
literal|4
expr_stmt|;
break|break;
comment|/* The first RELOAD_FOR_OUTADDR_ADDRESS reload conflicts with 		     the RELOAD_FOR_OUTPUT reloads, so assign it the same time 		     value.  */
case|case
name|RELOAD_FOR_OUTADDR_ADDRESS
case|:
if|if
condition|(
name|type
operator|==
name|RELOAD_FOR_OUTPUT_ADDRESS
operator|&&
name|reloadnum
operator|==
name|i
operator|+
literal|1
operator|&&
name|ignore_address_reloads
operator|&&
operator|!
name|rld
index|[
name|reloadnum
index|]
operator|.
name|out
condition|)
continue|continue;
name|time2
operator|=
name|MAX_RECOG_OPERANDS
operator|*
literal|4
operator|+
literal|4
operator|+
name|rld
index|[
name|i
index|]
operator|.
name|opnum
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OUTPUT_ADDRESS
case|:
name|time2
operator|=
name|MAX_RECOG_OPERANDS
operator|*
literal|4
operator|+
literal|5
operator|+
name|rld
index|[
name|i
index|]
operator|.
name|opnum
expr_stmt|;
break|break;
case|case
name|RELOAD_OTHER
case|:
comment|/* If there is no conflict in the input part, handle this 		     like an output reload.  */
if|if
condition|(
operator|!
name|rld
index|[
name|i
index|]
operator|.
name|in
operator|||
name|rtx_equal_p
argument_list|(
name|other_input
argument_list|,
name|value
argument_list|)
condition|)
block|{
name|time2
operator|=
name|MAX_RECOG_OPERANDS
operator|*
literal|4
operator|+
literal|4
expr_stmt|;
comment|/* Earlyclobbered outputs must conflict with inputs.  */
if|if
condition|(
name|earlyclobber_operand_p
argument_list|(
name|rld
index|[
name|i
index|]
operator|.
name|out
argument_list|)
condition|)
name|time2
operator|=
name|MAX_RECOG_OPERANDS
operator|*
literal|4
operator|+
literal|3
expr_stmt|;
break|break;
block|}
name|time2
operator|=
literal|1
expr_stmt|;
comment|/* RELOAD_OTHER might be live beyond instruction execution, 		     but this is not obvious when we set time2 = 1.  So check 		     here if there might be a problem with the new reload 		     clobbering the register used by the RELOAD_OTHER.  */
if|if
condition|(
name|out
condition|)
return|return
literal|0
return|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|time1
operator|>=
name|time2
operator|&&
operator|(
operator|!
name|rld
index|[
name|i
index|]
operator|.
name|in
operator|||
name|rld
index|[
name|i
index|]
operator|.
name|out
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|other_input
argument_list|,
name|value
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|out
operator|&&
name|rld
index|[
name|reloadnum
index|]
operator|.
name|out_reg
operator|&&
name|time2
operator|>=
name|MAX_RECOG_OPERANDS
operator|*
literal|4
operator|+
literal|3
operator|)
condition|)
return|return
literal|0
return|;
block|}
block|}
block|}
comment|/* Earlyclobbered outputs must conflict with inputs.  */
if|if
condition|(
name|check_earlyclobber
operator|&&
name|out
operator|&&
name|earlyclobber_operand_p
argument_list|(
name|out
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the value in reload reg REGNO, as used by a reload    needed for the part of the insn specified by OPNUM and TYPE,    may be used to load VALUE into it.     MODE is the mode in which the register is used, this is needed to    determine how many hard regs to test.     Other read-only reloads with the same value do not conflict    unless OUT is non-zero and these other reloads have to live while    output reloads live.    If OUT is CONST0_RTX, this is a special case: it means that the    test should not be for using register REGNO as reload register, but    for copying from register REGNO into the reload register.     RELOADNUM is the number of the reload we want to load this value for;    a reload does not conflict with itself.     When IGNORE_ADDRESS_RELOADS is set, we can not have conflicts with    reloads that load an address for the very reload we are considering.     The caller has to make sure that there is no conflict with the return    register.  */
end_comment

begin_function
specifier|static
name|int
name|free_for_value_p
parameter_list|(
name|regno
parameter_list|,
name|mode
parameter_list|,
name|opnum
parameter_list|,
name|type
parameter_list|,
name|value
parameter_list|,
name|out
parameter_list|,
name|reloadnum
parameter_list|,
name|ignore_address_reloads
parameter_list|)
name|int
name|regno
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|opnum
decl_stmt|;
name|enum
name|reload_type
name|type
decl_stmt|;
name|rtx
name|value
decl_stmt|,
name|out
decl_stmt|;
name|int
name|reloadnum
decl_stmt|;
name|int
name|ignore_address_reloads
decl_stmt|;
block|{
name|int
name|nregs
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
decl_stmt|;
while|while
condition|(
name|nregs
operator|--
operator|>
literal|0
condition|)
if|if
condition|(
operator|!
name|reload_reg_free_for_value_p
argument_list|(
name|regno
argument_list|,
name|regno
operator|+
name|nregs
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|,
name|value
argument_list|,
name|out
argument_list|,
name|reloadnum
argument_list|,
name|ignore_address_reloads
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Determine whether the reload reg X overlaps any rtx'es used for    overriding inheritance.  Return nonzero if so.  */
end_comment

begin_function
specifier|static
name|int
name|conflicts_with_override
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_reloads
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reload_override_in
index|[
name|i
index|]
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|x
argument_list|,
name|reload_override_in
index|[
name|i
index|]
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Give an error message saying we failed to find a reload for INSN,    and clear out reload R.  */
end_comment

begin_function
specifier|static
name|void
name|failed_reload
parameter_list|(
name|insn
parameter_list|,
name|r
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|int
name|r
decl_stmt|;
block|{
if|if
condition|(
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
comment|/* It's the compiler's fault.  */
name|fatal_insn
argument_list|(
literal|"could not find a spill register"
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* It's the user's fault; the operand's mode and constraint      don't match.  Disable this reload so we don't crash in final.  */
name|error_for_asm
argument_list|(
name|insn
argument_list|,
literal|"`asm' operand constraint incompatible with operand size"
argument_list|)
expr_stmt|;
name|rld
index|[
name|r
index|]
operator|.
name|in
operator|=
literal|0
expr_stmt|;
name|rld
index|[
name|r
index|]
operator|.
name|out
operator|=
literal|0
expr_stmt|;
name|rld
index|[
name|r
index|]
operator|.
name|reg_rtx
operator|=
literal|0
expr_stmt|;
name|rld
index|[
name|r
index|]
operator|.
name|optional
operator|=
literal|1
expr_stmt|;
name|rld
index|[
name|r
index|]
operator|.
name|secondary_p
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* I is the index in SPILL_REG_RTX of the reload register we are to allocate    for reload R.  If it's valid, get an rtx for it.  Return nonzero if    successful.  */
end_comment

begin_function
specifier|static
name|int
name|set_reload_reg
parameter_list|(
name|i
parameter_list|,
name|r
parameter_list|)
name|int
name|i
decl_stmt|,
name|r
decl_stmt|;
block|{
name|int
name|regno
decl_stmt|;
name|rtx
name|reg
init|=
name|spill_reg_rtx
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|reg
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|reg
argument_list|)
operator|!=
name|rld
index|[
name|r
index|]
operator|.
name|mode
condition|)
name|spill_reg_rtx
index|[
name|i
index|]
operator|=
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|rld
index|[
name|r
index|]
operator|.
name|mode
argument_list|,
name|spill_regs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|regno
operator|=
name|true_regnum
argument_list|(
name|reg
argument_list|)
expr_stmt|;
comment|/* Detect when the reload reg can't hold the reload mode.      This used to be one `if', but Sequent compiler can't handle that.  */
if|if
condition|(
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|rld
index|[
name|r
index|]
operator|.
name|mode
argument_list|)
condition|)
block|{
name|enum
name|machine_mode
name|test_mode
init|=
name|VOIDmode
decl_stmt|;
if|if
condition|(
name|rld
index|[
name|r
index|]
operator|.
name|in
condition|)
name|test_mode
operator|=
name|GET_MODE
argument_list|(
name|rld
index|[
name|r
index|]
operator|.
name|in
argument_list|)
expr_stmt|;
comment|/* If rld[r].in has VOIDmode, it means we will load it 	 in whatever mode the reload reg has: to wit, rld[r].mode. 	 We have already tested that for validity.  */
comment|/* Aside from that, we need to test that the expressions 	 to reload from or into have modes which are valid for this 	 reload register.  Otherwise the reload insns would be invalid.  */
if|if
condition|(
operator|!
operator|(
name|rld
index|[
name|r
index|]
operator|.
name|in
operator|!=
literal|0
operator|&&
name|test_mode
operator|!=
name|VOIDmode
operator|&&
operator|!
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|test_mode
argument_list|)
operator|)
condition|)
if|if
condition|(
operator|!
operator|(
name|rld
index|[
name|r
index|]
operator|.
name|out
operator|!=
literal|0
operator|&&
operator|!
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|rld
index|[
name|r
index|]
operator|.
name|out
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/* The reg is OK.  */
name|last_spill_reg
operator|=
name|i
expr_stmt|;
comment|/* Mark as in use for this insn the reload regs we use 	       for this.  */
name|mark_reload_reg_in_use
argument_list|(
name|spill_regs
index|[
name|i
index|]
argument_list|,
name|rld
index|[
name|r
index|]
operator|.
name|opnum
argument_list|,
name|rld
index|[
name|r
index|]
operator|.
name|when_needed
argument_list|,
name|rld
index|[
name|r
index|]
operator|.
name|mode
argument_list|)
expr_stmt|;
name|rld
index|[
name|r
index|]
operator|.
name|reg_rtx
operator|=
name|reg
expr_stmt|;
name|reload_spill_index
index|[
name|r
index|]
operator|=
name|spill_regs
index|[
name|i
index|]
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Find a spill register to use as a reload register for reload R.    LAST_RELOAD is non-zero if this is the last reload for the insn being    processed.     Set rld[R].reg_rtx to the register allocated.     We return 1 if successful, or 0 if we couldn't find a spill reg and    we didn't change anything.  */
end_comment

begin_function
specifier|static
name|int
name|allocate_reload_reg
parameter_list|(
name|chain
parameter_list|,
name|r
parameter_list|,
name|last_reload
parameter_list|)
name|struct
name|insn_chain
modifier|*
name|chain
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|r
decl_stmt|;
name|int
name|last_reload
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|pass
decl_stmt|,
name|count
decl_stmt|;
comment|/* If we put this reload ahead, thinking it is a group,      then insist on finding a group.  Otherwise we can grab a      reg that some other reload needs.      (That can happen when we have a 68000 DATA_OR_FP_REG      which is a group of data regs or one fp reg.)      We need not be so restrictive if there are no more reloads      for this insn.       ??? Really it would be nicer to have smarter handling      for that kind of reg class, where a problem like this is normal.      Perhaps those classes should be avoided for reloading      by use of more alternatives.  */
name|int
name|force_group
init|=
name|rld
index|[
name|r
index|]
operator|.
name|nregs
operator|>
literal|1
operator|&&
operator|!
name|last_reload
decl_stmt|;
comment|/* If we want a single register and haven't yet found one,      take any reg in the right class and not in use.      If we want a consecutive group, here is where we look for it.       We use two passes so we can first look for reload regs to      reuse, which are already in use for other reloads in this insn,      and only then use additional registers.      I think that maximizing reuse is needed to make sure we don't      run out of reload regs.  Suppose we have three reloads, and      reloads A and B can share regs.  These need two regs.      Suppose A and B are given different regs.      That leaves none for C.  */
for|for
control|(
name|pass
operator|=
literal|0
init|;
name|pass
operator|<
literal|2
condition|;
name|pass
operator|++
control|)
block|{
comment|/* I is the index in spill_regs. 	 We advance it round-robin between insns to use all spill regs 	 equally, so that inherited reloads have a chance 	 of leapfrogging each other.  */
name|i
operator|=
name|last_spill_reg
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|n_spills
condition|;
name|count
operator|++
control|)
block|{
name|int
name|class
init|=
operator|(
name|int
operator|)
name|rld
index|[
name|r
index|]
operator|.
name|class
decl_stmt|;
name|int
name|regnum
decl_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|n_spills
condition|)
name|i
operator|-=
name|n_spills
expr_stmt|;
name|regnum
operator|=
name|spill_regs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|reload_reg_free_p
argument_list|(
name|regnum
argument_list|,
name|rld
index|[
name|r
index|]
operator|.
name|opnum
argument_list|,
name|rld
index|[
name|r
index|]
operator|.
name|when_needed
argument_list|)
operator|||
operator|(
name|rld
index|[
name|r
index|]
operator|.
name|in
comment|/* We check reload_reg_used to make sure we 		      don't clobber the return register.  */
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used
argument_list|,
name|regnum
argument_list|)
operator|&&
name|free_for_value_p
argument_list|(
name|regnum
argument_list|,
name|rld
index|[
name|r
index|]
operator|.
name|mode
argument_list|,
name|rld
index|[
name|r
index|]
operator|.
name|opnum
argument_list|,
name|rld
index|[
name|r
index|]
operator|.
name|when_needed
argument_list|,
name|rld
index|[
name|r
index|]
operator|.
name|in
argument_list|,
name|rld
index|[
name|r
index|]
operator|.
name|out
argument_list|,
name|r
argument_list|,
literal|1
argument_list|)
operator|)
operator|)
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|class
index|]
argument_list|,
name|regnum
argument_list|)
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|regnum
argument_list|,
name|rld
index|[
name|r
index|]
operator|.
name|mode
argument_list|)
comment|/* Look first for regs to share, then for unshared.  But 		 don't share regs used for inherited reloads; they are 		 the ones we want to preserve.  */
operator|&&
operator|(
name|pass
operator|||
operator|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_at_all
argument_list|,
name|regnum
argument_list|)
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_for_inherit
argument_list|,
name|regnum
argument_list|)
operator|)
operator|)
condition|)
block|{
name|int
name|nr
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regnum
argument_list|,
name|rld
index|[
name|r
index|]
operator|.
name|mode
argument_list|)
decl_stmt|;
comment|/* Avoid the problem where spilling a GENERAL_OR_FP_REG 		 (on 68000) got us two FP regs.  If NR is 1, 		 we would reject both of them.  */
if|if
condition|(
name|force_group
condition|)
name|nr
operator|=
name|rld
index|[
name|r
index|]
operator|.
name|nregs
expr_stmt|;
comment|/* If we need only one reg, we have already won.  */
if|if
condition|(
name|nr
operator|==
literal|1
condition|)
block|{
comment|/* But reject a single reg if we demand a group.  */
if|if
condition|(
name|force_group
condition|)
continue|continue;
break|break;
block|}
comment|/* Otherwise check that as many consecutive regs as we need 		 are available here.  */
while|while
condition|(
name|nr
operator|>
literal|1
condition|)
block|{
name|int
name|regno
init|=
name|regnum
operator|+
name|nr
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|class
index|]
argument_list|,
name|regno
argument_list|)
operator|&&
name|spill_reg_order
index|[
name|regno
index|]
operator|>=
literal|0
operator|&&
name|reload_reg_free_p
argument_list|(
name|regno
argument_list|,
name|rld
index|[
name|r
index|]
operator|.
name|opnum
argument_list|,
name|rld
index|[
name|r
index|]
operator|.
name|when_needed
argument_list|)
operator|)
condition|)
break|break;
name|nr
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|nr
operator|==
literal|1
condition|)
break|break;
block|}
block|}
comment|/* If we found something on pass 1, omit pass 2.  */
if|if
condition|(
name|count
operator|<
name|n_spills
condition|)
break|break;
block|}
comment|/* We should have found a spill register by now.  */
if|if
condition|(
name|count
operator|>=
name|n_spills
condition|)
return|return
literal|0
return|;
comment|/* I is the index in SPILL_REG_RTX of the reload register we are to      allocate.  Get an rtx for it and find its register number.  */
return|return
name|set_reload_reg
argument_list|(
name|i
argument_list|,
name|r
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Initialize all the tables needed to allocate reload registers.    CHAIN is the insn currently being processed; SAVE_RELOAD_REG_RTX    is the array we use to restore the reg_rtx field for every reload.  */
end_comment

begin_function
specifier|static
name|void
name|choose_reload_regs_init
parameter_list|(
name|chain
parameter_list|,
name|save_reload_reg_rtx
parameter_list|)
name|struct
name|insn_chain
modifier|*
name|chain
decl_stmt|;
name|rtx
modifier|*
name|save_reload_reg_rtx
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_reloads
condition|;
name|i
operator|++
control|)
name|rld
index|[
name|i
index|]
operator|.
name|reg_rtx
operator|=
name|save_reload_reg_rtx
index|[
name|i
index|]
expr_stmt|;
name|memset
argument_list|(
name|reload_inherited
argument_list|,
literal|0
argument_list|,
name|MAX_RELOADS
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reload_inheritance_insn
argument_list|,
literal|0
argument_list|,
name|MAX_RELOADS
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reload_override_in
argument_list|,
literal|0
argument_list|,
name|MAX_RELOADS
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|reload_reg_used
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|reload_reg_used_at_all
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|reload_reg_used_in_op_addr
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|reload_reg_used_in_op_addr_reload
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|reload_reg_used_in_insn
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|reload_reg_used_in_other_addr
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|reg_used_in_insn
argument_list|)
expr_stmt|;
block|{
name|HARD_REG_SET
name|tmp
decl_stmt|;
name|REG_SET_TO_HARD_REG_SET
argument_list|(
name|tmp
argument_list|,
operator|&
name|chain
operator|->
name|live_throughout
argument_list|)
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|reg_used_in_insn
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|REG_SET_TO_HARD_REG_SET
argument_list|(
name|tmp
argument_list|,
operator|&
name|chain
operator|->
name|dead_or_set
argument_list|)
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|reg_used_in_insn
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|compute_use_by_pseudos
argument_list|(
operator|&
name|reg_used_in_insn
argument_list|,
operator|&
name|chain
operator|->
name|live_throughout
argument_list|)
expr_stmt|;
name|compute_use_by_pseudos
argument_list|(
operator|&
name|reg_used_in_insn
argument_list|,
operator|&
name|chain
operator|->
name|dead_or_set
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reload_n_operands
condition|;
name|i
operator|++
control|)
block|{
name|CLEAR_HARD_REG_SET
argument_list|(
name|reload_reg_used_in_output
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|reload_reg_used_in_input
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|reload_reg_used_in_input_addr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|reload_reg_used_in_inpaddr_addr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|reload_reg_used_in_output_addr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|reload_reg_used_in_outaddr_addr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|COMPL_HARD_REG_SET
argument_list|(
name|reload_reg_unavailable
argument_list|,
name|chain
operator|->
name|used_spill_regs
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|reload_reg_used_for_inherit
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_reloads
condition|;
name|i
operator|++
control|)
comment|/* If we have already decided to use a certain register,        don't use it in another way.  */
if|if
condition|(
name|rld
index|[
name|i
index|]
operator|.
name|reg_rtx
condition|)
name|mark_reload_reg_in_use
argument_list|(
name|REGNO
argument_list|(
name|rld
index|[
name|i
index|]
operator|.
name|reg_rtx
argument_list|)
argument_list|,
name|rld
index|[
name|i
index|]
operator|.
name|opnum
argument_list|,
name|rld
index|[
name|i
index|]
operator|.
name|when_needed
argument_list|,
name|rld
index|[
name|i
index|]
operator|.
name|mode
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Assign hard reg targets for the pseudo-registers we must reload    into hard regs for this insn.    Also output the instructions to copy them in and out of the hard regs.     For machines with register classes, we are responsible for    finding a reload reg in the proper class.  */
end_comment

begin_function
specifier|static
name|void
name|choose_reload_regs
parameter_list|(
name|chain
parameter_list|)
name|struct
name|insn_chain
modifier|*
name|chain
decl_stmt|;
block|{
name|rtx
name|insn
init|=
name|chain
operator|->
name|insn
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|unsigned
name|int
name|max_group_size
init|=
literal|1
decl_stmt|;
name|enum
name|reg_class
name|group_class
init|=
name|NO_REGS
decl_stmt|;
name|int
name|pass
decl_stmt|,
name|win
decl_stmt|,
name|inheritance
decl_stmt|;
name|rtx
name|save_reload_reg_rtx
index|[
name|MAX_RELOADS
index|]
decl_stmt|;
comment|/* In order to be certain of getting the registers we need,      we must sort the reloads into order of increasing register class.      Then our grabbing of reload registers will parallel the process      that provided the reload registers.       Also note whether any of the reloads wants a consecutive group of regs.      If so, record the maximum size of the group desired and what      register class contains all the groups needed by this insn.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_reloads
condition|;
name|j
operator|++
control|)
block|{
name|reload_order
index|[
name|j
index|]
operator|=
name|j
expr_stmt|;
name|reload_spill_index
index|[
name|j
index|]
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|rld
index|[
name|j
index|]
operator|.
name|nregs
operator|>
literal|1
condition|)
block|{
name|max_group_size
operator|=
name|MAX
argument_list|(
name|rld
index|[
name|j
index|]
operator|.
name|nregs
argument_list|,
name|max_group_size
argument_list|)
expr_stmt|;
name|group_class
operator|=
name|reg_class_superunion
index|[
operator|(
name|int
operator|)
name|rld
index|[
name|j
index|]
operator|.
name|class
index|]
index|[
operator|(
name|int
operator|)
name|group_class
index|]
expr_stmt|;
block|}
name|save_reload_reg_rtx
index|[
name|j
index|]
operator|=
name|rld
index|[
name|j
index|]
operator|.
name|reg_rtx
expr_stmt|;
block|}
if|if
condition|(
name|n_reloads
operator|>
literal|1
condition|)
name|qsort
argument_list|(
name|reload_order
argument_list|,
name|n_reloads
argument_list|,
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|,
name|reload_reg_class_lower
argument_list|)
expr_stmt|;
comment|/* If -O, try first with inheritance, then turning it off.      If not -O, don't do inheritance.      Using inheritance when not optimizing leads to paradoxes      with fp on the 68k: fp numbers (not NaNs) fail to be equal to themselves      because one side of the comparison might be inherited.  */
name|win
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|inheritance
operator|=
name|optimize
operator|>
literal|0
init|;
name|inheritance
operator|>=
literal|0
condition|;
name|inheritance
operator|--
control|)
block|{
name|choose_reload_regs_init
argument_list|(
name|chain
argument_list|,
name|save_reload_reg_rtx
argument_list|)
expr_stmt|;
comment|/* Process the reloads in order of preference just found. 	 Beyond this point, subregs can be found in reload_reg_rtx.  	 This used to look for an existing reloaded home for all of the 	 reloads, and only then perform any new reloads.  But that could lose 	 if the reloads were done out of reg-class order because a later 	 reload with a looser constraint might have an old home in a register 	 needed by an earlier reload with a tighter constraint.  	 To solve this, we make two passes over the reloads, in the order 	 described above.  In the first pass we try to inherit a reload 	 from a previous insn.  If there is a later reload that needs a 	 class that is a proper subset of the class being processed, we must 	 also allocate a spill register during the first pass.  	 Then make a second pass over the reloads to allocate any reloads 	 that haven't been given registers yet.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_reloads
condition|;
name|j
operator|++
control|)
block|{
name|int
name|r
init|=
name|reload_order
index|[
name|j
index|]
decl_stmt|;
name|rtx
name|search_equiv
init|=
name|NULL_RTX
decl_stmt|;
comment|/* Ignore reloads that got marked inoperative.  */
if|if
condition|(
name|rld
index|[
name|r
index|]
operator|.
name|out
operator|==
literal|0
operator|&&
name|rld
index|[
name|r
index|]
operator|.
name|in
operator|==
literal|0
operator|&&
operator|!
name|rld
index|[
name|r
index|]
operator|.
name|secondary_p
condition|)
continue|continue;
comment|/* If find_reloads chose to use reload_in or reload_out as a reload 	     register, we don't need to chose one.  Otherwise, try even if it 	     found one since we might save an insn if we find the value lying 	     around. 	     Try also when reload_in is a pseudo without a hard reg.  */
if|if
condition|(
name|rld
index|[
name|r
index|]
operator|.
name|in
operator|!=
literal|0
operator|&&
name|rld
index|[
name|r
index|]
operator|.
name|reg_rtx
operator|!=
literal|0
operator|&&
operator|(
name|rtx_equal_p
argument_list|(
name|rld
index|[
name|r
index|]
operator|.
name|in
argument_list|,
name|rld
index|[
name|r
index|]
operator|.
name|reg_rtx
argument_list|)
operator|||
operator|(
name|rtx_equal_p
argument_list|(
name|rld
index|[
name|r
index|]
operator|.
name|out
argument_list|,
name|rld
index|[
name|r
index|]
operator|.
name|reg_rtx
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|rld
index|[
name|r
index|]
operator|.
name|in
argument_list|)
operator|!=
name|MEM
operator|&&
name|true_regnum
argument_list|(
name|rld
index|[
name|r
index|]
operator|.
name|in
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
operator|)
condition|)
continue|continue;
if|#
directive|if
literal|0
comment|/* No longer needed for correct operation. 	 It might give better code, or might not; worth an experiment?  */
comment|/* If this is an optional reload, we can't inherit from earlier insns 	     until we are sure that any non-optional reloads have been allocated. 	     The following code takes advantage of the fact that optional reloads 	     are at the end of reload_order.  */
block|if (rld[r].optional != 0) 	    for (i = 0; i< j; i++) 	      if ((rld[reload_order[i]].out != 0 		   || rld[reload_order[i]].in != 0 		   || rld[reload_order[i]].secondary_p)&& ! rld[reload_order[i]].optional&& rld[reload_order[i]].reg_rtx == 0) 		allocate_reload_reg (chain, reload_order[i], 0);
endif|#
directive|endif
comment|/* First see if this pseudo is already available as reloaded 	     for a previous insn.  We cannot try to inherit for reloads 	     that are smaller than the maximum number of registers needed 	     for groups unless the register we would allocate cannot be used 	     for the groups.  	     We could check here to see if this is a secondary reload for 	     an object that is already in a register of the desired class. 	     This would avoid the need for the secondary reload register. 	     But this is complex because we can't easily determine what 	     objects might want to be loaded via this reload.  So let a 	     register be allocated here.  In `emit_reload_insns' we suppress 	     one of the loads in the case described above.  */
if|if
condition|(
name|inheritance
condition|)
block|{
name|int
name|byte
init|=
literal|0
decl_stmt|;
name|int
name|regno
init|=
operator|-
literal|1
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|VOIDmode
decl_stmt|;
if|if
condition|(
name|rld
index|[
name|r
index|]
operator|.
name|in
operator|==
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|rld
index|[
name|r
index|]
operator|.
name|in
argument_list|)
operator|==
name|REG
condition|)
block|{
name|regno
operator|=
name|REGNO
argument_list|(
name|rld
index|[
name|r
index|]
operator|.
name|in
argument_list|)
expr_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|rld
index|[
name|r
index|]
operator|.
name|in
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|rld
index|[
name|r
index|]
operator|.
name|in_reg
argument_list|)
operator|==
name|REG
condition|)
block|{
name|regno
operator|=
name|REGNO
argument_list|(
name|rld
index|[
name|r
index|]
operator|.
name|in_reg
argument_list|)
expr_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|rld
index|[
name|r
index|]
operator|.
name|in_reg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|rld
index|[
name|r
index|]
operator|.
name|in_reg
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|rld
index|[
name|r
index|]
operator|.
name|in_reg
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|byte
operator|=
name|SUBREG_BYTE
argument_list|(
name|rld
index|[
name|r
index|]
operator|.
name|in_reg
argument_list|)
expr_stmt|;
name|regno
operator|=
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|rld
index|[
name|r
index|]
operator|.
name|in_reg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|regno
operator|=
name|subreg_regno
argument_list|(
name|rld
index|[
name|r
index|]
operator|.
name|in_reg
argument_list|)
expr_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|rld
index|[
name|r
index|]
operator|.
name|in_reg
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
elseif|else
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|rld
index|[
name|r
index|]
operator|.
name|in_reg
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|rld
index|[
name|r
index|]
operator|.
name|in_reg
argument_list|)
operator|==
name|PRE_DEC
operator|||
name|GET_CODE
argument_list|(
name|rld
index|[
name|r
index|]
operator|.
name|in_reg
argument_list|)
operator|==
name|POST_INC
operator|||
name|GET_CODE
argument_list|(
name|rld
index|[
name|r
index|]
operator|.
name|in_reg
argument_list|)
operator|==
name|POST_DEC
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|rld
index|[
name|r
index|]
operator|.
name|in_reg
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|regno
operator|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|rld
index|[
name|r
index|]
operator|.
name|in_reg
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|rld
index|[
name|r
index|]
operator|.
name|in_reg
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|rld
index|[
name|r
index|]
operator|.
name|out
operator|=
name|rld
index|[
name|r
index|]
operator|.
name|in
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* This won't work, since REGNO can be a pseudo reg number. 		 Also, it takes much more hair to keep track of all the things 		 that can invalidate an inherited reload of part of a pseudoreg.  */
block|else if (GET_CODE (rld[r].in) == SUBREG&& GET_CODE (SUBREG_REG (rld[r].in)) == REG) 		regno = subreg_regno (rld[r].in);
endif|#
directive|endif
if|if
condition|(
name|regno
operator|>=
literal|0
operator|&&
name|reg_last_reload_reg
index|[
name|regno
index|]
operator|!=
literal|0
condition|)
block|{
name|enum
name|reg_class
name|class
init|=
name|rld
index|[
name|r
index|]
operator|.
name|class
decl_stmt|,
name|last_class
decl_stmt|;
name|rtx
name|last_reg
init|=
name|reg_last_reload_reg
index|[
name|regno
index|]
decl_stmt|;
name|enum
name|machine_mode
name|need_mode
decl_stmt|;
name|i
operator|=
name|REGNO
argument_list|(
name|last_reg
argument_list|)
expr_stmt|;
name|i
operator|+=
name|subreg_regno_offset
argument_list|(
name|i
argument_list|,
name|GET_MODE
argument_list|(
name|last_reg
argument_list|)
argument_list|,
name|byte
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|last_class
operator|=
name|REGNO_REG_CLASS
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|byte
operator|==
literal|0
condition|)
name|need_mode
operator|=
name|mode
expr_stmt|;
else|else
name|need_mode
operator|=
name|smallest_mode_for_size
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|+
name|byte
argument_list|,
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
ifdef|#
directive|ifdef
name|CLASS_CANNOT_CHANGE_MODE
operator|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|CLASS_CANNOT_CHANGE_MODE
index|]
argument_list|,
name|i
argument_list|)
condition|?
operator|!
name|CLASS_CANNOT_CHANGE_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|last_reg
argument_list|)
argument_list|,
name|need_mode
argument_list|)
else|:
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|last_reg
argument_list|)
argument_list|)
operator|>=
name|GET_MODE_SIZE
argument_list|(
name|need_mode
argument_list|)
operator|)
operator|)
else|#
directive|else
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|last_reg
argument_list|)
argument_list|)
operator|>=
name|GET_MODE_SIZE
argument_list|(
name|need_mode
argument_list|)
operator|)
endif|#
directive|endif
operator|&&
name|reg_reloaded_contents
index|[
name|i
index|]
operator|==
name|regno
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_reloaded_valid
argument_list|,
name|i
argument_list|)
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|i
argument_list|,
name|rld
index|[
name|r
index|]
operator|.
name|mode
argument_list|)
operator|&&
operator|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|class
index|]
argument_list|,
name|i
argument_list|)
comment|/* Even if we can't use this register as a reload 			     register, we might use it for reload_override_in, 			     if copying it to the desired class is cheap 			     enough.  */
operator|||
operator|(
operator|(
name|REGISTER_MOVE_COST
argument_list|(
name|mode
argument_list|,
name|last_class
argument_list|,
name|class
argument_list|)
operator|<
name|MEMORY_MOVE_COST
argument_list|(
name|mode
argument_list|,
name|class
argument_list|,
literal|1
argument_list|)
operator|)
ifdef|#
directive|ifdef
name|SECONDARY_INPUT_RELOAD_CLASS
operator|&&
operator|(
name|SECONDARY_INPUT_RELOAD_CLASS
argument_list|(
name|class
argument_list|,
name|mode
argument_list|,
name|last_reg
argument_list|)
operator|==
name|NO_REGS
operator|)
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SECONDARY_MEMORY_NEEDED
operator|&&
operator|!
name|SECONDARY_MEMORY_NEEDED
argument_list|(
name|last_class
argument_list|,
name|class
argument_list|,
name|mode
argument_list|)
endif|#
directive|endif
operator|)
operator|)
operator|&&
operator|(
name|rld
index|[
name|r
index|]
operator|.
name|nregs
operator|==
name|max_group_size
operator|||
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|group_class
index|]
argument_list|,
name|i
argument_list|)
operator|)
operator|&&
name|free_for_value_p
argument_list|(
name|i
argument_list|,
name|rld
index|[
name|r
index|]
operator|.
name|mode
argument_list|,
name|rld
index|[
name|r
index|]
operator|.
name|opnum
argument_list|,
name|rld
index|[
name|r
index|]
operator|.
name|when_needed
argument_list|,
name|rld
index|[
name|r
index|]
operator|.
name|in
argument_list|,
name|const0_rtx
argument_list|,
name|r
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|/* If a group is needed, verify that all the subsequent 			 registers still have their values intact.  */
name|int
name|nr
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|i
argument_list|,
name|rld
index|[
name|r
index|]
operator|.
name|mode
argument_list|)
decl_stmt|;
name|int
name|k
decl_stmt|;
for|for
control|(
name|k
operator|=
literal|1
init|;
name|k
operator|<
name|nr
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|reg_reloaded_contents
index|[
name|i
operator|+
name|k
index|]
operator|!=
name|regno
operator|||
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_reloaded_valid
argument_list|,
name|i
operator|+
name|k
argument_list|)
condition|)
break|break;
if|if
condition|(
name|k
operator|==
name|nr
condition|)
block|{
name|int
name|i1
decl_stmt|;
name|int
name|bad_for_class
decl_stmt|;
name|last_reg
operator|=
operator|(
name|GET_MODE
argument_list|(
name|last_reg
argument_list|)
operator|==
name|mode
condition|?
name|last_reg
else|:
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|i
argument_list|)
operator|)
expr_stmt|;
name|bad_for_class
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|nr
condition|;
name|k
operator|++
control|)
name|bad_for_class
operator||=
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|rld
index|[
name|r
index|]
operator|.
name|class
index|]
argument_list|,
name|i
operator|+
name|k
argument_list|)
expr_stmt|;
comment|/* We found a register that contains the 			     value we need.  If this register is the 			     same as an `earlyclobber' operand of the 			     current insn, just mark it as a place to 			     reload from since we can't use it as the 			     reload register itself.  */
for|for
control|(
name|i1
operator|=
literal|0
init|;
name|i1
operator|<
name|n_earlyclobbers
condition|;
name|i1
operator|++
control|)
if|if
condition|(
name|reg_overlap_mentioned_for_reload_p
argument_list|(
name|reg_last_reload_reg
index|[
name|regno
index|]
argument_list|,
name|reload_earlyclobbers
index|[
name|i1
index|]
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i1
operator|!=
name|n_earlyclobbers
operator|||
operator|!
operator|(
name|free_for_value_p
argument_list|(
name|i
argument_list|,
name|rld
index|[
name|r
index|]
operator|.
name|mode
argument_list|,
name|rld
index|[
name|r
index|]
operator|.
name|opnum
argument_list|,
name|rld
index|[
name|r
index|]
operator|.
name|when_needed
argument_list|,
name|rld
index|[
name|r
index|]
operator|.
name|in
argument_list|,
name|rld
index|[
name|r
index|]
operator|.
name|out
argument_list|,
name|r
argument_list|,
literal|1
argument_list|)
operator|)
comment|/* Don't use it if we'd clobber a pseudo reg.  */
operator|||
operator|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_used_in_insn
argument_list|,
name|i
argument_list|)
operator|&&
name|rld
index|[
name|r
index|]
operator|.
name|out
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_reloaded_dead
argument_list|,
name|i
argument_list|)
operator|)
comment|/* Don't clobber the frame pointer.  */
operator|||
operator|(
name|i
operator|==
name|HARD_FRAME_POINTER_REGNUM
operator|&&
name|rld
index|[
name|r
index|]
operator|.
name|out
operator|)
comment|/* Don't really use the inherited spill reg 				 if we need it wider than we've got it.  */
operator|||
operator|(
name|GET_MODE_SIZE
argument_list|(
name|rld
index|[
name|r
index|]
operator|.
name|mode
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|)
operator|||
name|bad_for_class
comment|/* If find_reloads chose reload_out as reload 				 register, stay with it - that leaves the 				 inherited register for subsequent reloads.  */
operator|||
operator|(
name|rld
index|[
name|r
index|]
operator|.
name|out
operator|&&
name|rld
index|[
name|r
index|]
operator|.
name|reg_rtx
operator|&&
name|rtx_equal_p
argument_list|(
name|rld
index|[
name|r
index|]
operator|.
name|out
argument_list|,
name|rld
index|[
name|r
index|]
operator|.
name|reg_rtx
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|rld
index|[
name|r
index|]
operator|.
name|optional
condition|)
block|{
name|reload_override_in
index|[
name|r
index|]
operator|=
name|last_reg
expr_stmt|;
name|reload_inheritance_insn
index|[
name|r
index|]
operator|=
name|reg_reloaded_insn
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|k
decl_stmt|;
comment|/* We can use this as a reload reg.  */
comment|/* Mark the register as in use for this part of 				 the insn.  */
name|mark_reload_reg_in_use
argument_list|(
name|i
argument_list|,
name|rld
index|[
name|r
index|]
operator|.
name|opnum
argument_list|,
name|rld
index|[
name|r
index|]
operator|.
name|when_needed
argument_list|,
name|rld
index|[
name|r
index|]
operator|.
name|mode
argument_list|)
expr_stmt|;
name|rld
index|[
name|r
index|]
operator|.
name|reg_rtx
operator|=
name|last_reg
expr_stmt|;
name|reload_inherited
index|[
name|r
index|]
operator|=
literal|1
expr_stmt|;
name|reload_inheritance_insn
index|[
name|r
index|]
operator|=
name|reg_reloaded_insn
index|[
name|i
index|]
expr_stmt|;
name|reload_spill_index
index|[
name|r
index|]
operator|=
name|i
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|nr
condition|;
name|k
operator|++
control|)
name|SET_HARD_REG_BIT
argument_list|(
name|reload_reg_used_for_inherit
argument_list|,
name|i
operator|+
name|k
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/* Here's another way to see if the value is already lying around.  */
if|if
condition|(
name|inheritance
operator|&&
name|rld
index|[
name|r
index|]
operator|.
name|in
operator|!=
literal|0
operator|&&
operator|!
name|reload_inherited
index|[
name|r
index|]
operator|&&
name|rld
index|[
name|r
index|]
operator|.
name|out
operator|==
literal|0
operator|&&
operator|(
name|CONSTANT_P
argument_list|(
name|rld
index|[
name|r
index|]
operator|.
name|in
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|rld
index|[
name|r
index|]
operator|.
name|in
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|rld
index|[
name|r
index|]
operator|.
name|in
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|rld
index|[
name|r
index|]
operator|.
name|in
argument_list|)
operator|==
name|MEM
operator|)
operator|&&
operator|(
name|rld
index|[
name|r
index|]
operator|.
name|nregs
operator|==
name|max_group_size
operator|||
operator|!
name|reg_classes_intersect_p
argument_list|(
name|rld
index|[
name|r
index|]
operator|.
name|class
argument_list|,
name|group_class
argument_list|)
operator|)
condition|)
name|search_equiv
operator|=
name|rld
index|[
name|r
index|]
operator|.
name|in
expr_stmt|;
comment|/* If this is an output reload from a simple move insn, look 	     if an equivalence for the input is available.  */
elseif|else
if|if
condition|(
name|inheritance
operator|&&
name|rld
index|[
name|r
index|]
operator|.
name|in
operator|==
literal|0
operator|&&
name|rld
index|[
name|r
index|]
operator|.
name|out
operator|!=
literal|0
condition|)
block|{
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|set
operator|&&
name|rtx_equal_p
argument_list|(
name|rld
index|[
name|r
index|]
operator|.
name|out
argument_list|,
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|&&
name|CONSTANT_P
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
condition|)
name|search_equiv
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|search_equiv
condition|)
block|{
name|rtx
name|equiv
init|=
name|find_equiv_reg
argument_list|(
name|search_equiv
argument_list|,
name|insn
argument_list|,
name|rld
index|[
name|r
index|]
operator|.
name|class
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|rld
index|[
name|r
index|]
operator|.
name|mode
argument_list|)
decl_stmt|;
name|int
name|regno
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|equiv
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|equiv
argument_list|)
operator|==
name|REG
condition|)
name|regno
operator|=
name|REGNO
argument_list|(
name|equiv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|equiv
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
comment|/* This must be a SUBREG of a hard register. 			 Make a new REG since this might be used in an 			 address and not all machines support SUBREGs 			 there.  */
name|regno
operator|=
name|subreg_regno
argument_list|(
name|equiv
argument_list|)
expr_stmt|;
name|equiv
operator|=
name|gen_rtx_REG
argument_list|(
name|rld
index|[
name|r
index|]
operator|.
name|mode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* If we found a spill reg, reject it unless it is free 		 and of the desired class.  */
if|if
condition|(
name|equiv
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_at_all
argument_list|,
name|regno
argument_list|)
operator|&&
operator|!
name|free_for_value_p
argument_list|(
name|regno
argument_list|,
name|rld
index|[
name|r
index|]
operator|.
name|mode
argument_list|,
name|rld
index|[
name|r
index|]
operator|.
name|opnum
argument_list|,
name|rld
index|[
name|r
index|]
operator|.
name|when_needed
argument_list|,
name|rld
index|[
name|r
index|]
operator|.
name|in
argument_list|,
name|rld
index|[
name|r
index|]
operator|.
name|out
argument_list|,
name|r
argument_list|,
literal|1
argument_list|)
operator|)
operator|||
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|rld
index|[
name|r
index|]
operator|.
name|class
index|]
argument_list|,
name|regno
argument_list|)
operator|)
condition|)
name|equiv
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|equiv
operator|!=
literal|0
operator|&&
operator|!
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|rld
index|[
name|r
index|]
operator|.
name|mode
argument_list|)
condition|)
name|equiv
operator|=
literal|0
expr_stmt|;
comment|/* We found a register that contains the value we need. 		 If this register is the same as an `earlyclobber' operand 		 of the current insn, just mark it as a place to reload from 		 since we can't use it as the reload register itself.  */
if|if
condition|(
name|equiv
operator|!=
literal|0
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_earlyclobbers
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reg_overlap_mentioned_for_reload_p
argument_list|(
name|equiv
argument_list|,
name|reload_earlyclobbers
index|[
name|i
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|rld
index|[
name|r
index|]
operator|.
name|optional
condition|)
name|reload_override_in
index|[
name|r
index|]
operator|=
name|equiv
expr_stmt|;
name|equiv
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* If the equiv register we have found is explicitly clobbered 		 in the current insn, it depends on the reload type if we 		 can use it, use it for reload_override_in, or not at all. 		 In particular, we then can't use EQUIV for a 		 RELOAD_FOR_OUTPUT_ADDRESS reload.  */
if|if
condition|(
name|equiv
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|regno_clobbered_p
argument_list|(
name|regno
argument_list|,
name|insn
argument_list|,
name|rld
index|[
name|r
index|]
operator|.
name|mode
argument_list|,
literal|0
argument_list|)
condition|)
switch|switch
condition|(
name|rld
index|[
name|r
index|]
operator|.
name|when_needed
condition|)
block|{
case|case
name|RELOAD_FOR_OTHER_ADDRESS
case|:
case|case
name|RELOAD_FOR_INPADDR_ADDRESS
case|:
case|case
name|RELOAD_FOR_INPUT_ADDRESS
case|:
case|case
name|RELOAD_FOR_OPADDR_ADDR
case|:
break|break;
case|case
name|RELOAD_OTHER
case|:
case|case
name|RELOAD_FOR_INPUT
case|:
case|case
name|RELOAD_FOR_OPERAND_ADDRESS
case|:
if|if
condition|(
operator|!
name|rld
index|[
name|r
index|]
operator|.
name|optional
condition|)
name|reload_override_in
index|[
name|r
index|]
operator|=
name|equiv
expr_stmt|;
comment|/* Fall through.  */
default|default:
name|equiv
operator|=
literal|0
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|regno_clobbered_p
argument_list|(
name|regno
argument_list|,
name|insn
argument_list|,
name|rld
index|[
name|r
index|]
operator|.
name|mode
argument_list|,
literal|1
argument_list|)
condition|)
switch|switch
condition|(
name|rld
index|[
name|r
index|]
operator|.
name|when_needed
condition|)
block|{
case|case
name|RELOAD_FOR_OTHER_ADDRESS
case|:
case|case
name|RELOAD_FOR_INPADDR_ADDRESS
case|:
case|case
name|RELOAD_FOR_INPUT_ADDRESS
case|:
case|case
name|RELOAD_FOR_OPADDR_ADDR
case|:
case|case
name|RELOAD_FOR_OPERAND_ADDRESS
case|:
case|case
name|RELOAD_FOR_INPUT
case|:
break|break;
case|case
name|RELOAD_OTHER
case|:
if|if
condition|(
operator|!
name|rld
index|[
name|r
index|]
operator|.
name|optional
condition|)
name|reload_override_in
index|[
name|r
index|]
operator|=
name|equiv
expr_stmt|;
comment|/* Fall through.  */
default|default:
name|equiv
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
comment|/* If we found an equivalent reg, say no code need be generated 		 to load it, and use it as our reload reg.  */
if|if
condition|(
name|equiv
operator|!=
literal|0
operator|&&
name|regno
operator|!=
name|HARD_FRAME_POINTER_REGNUM
condition|)
block|{
name|int
name|nr
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|rld
index|[
name|r
index|]
operator|.
name|mode
argument_list|)
decl_stmt|;
name|int
name|k
decl_stmt|;
name|rld
index|[
name|r
index|]
operator|.
name|reg_rtx
operator|=
name|equiv
expr_stmt|;
name|reload_inherited
index|[
name|r
index|]
operator|=
literal|1
expr_stmt|;
comment|/* If reg_reloaded_valid is not set for this register, 		     there might be a stale spill_reg_store lying around. 		     We must clear it, since otherwise emit_reload_insns 		     might delete the store.  */
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_reloaded_valid
argument_list|,
name|regno
argument_list|)
condition|)
name|spill_reg_store
index|[
name|regno
index|]
operator|=
name|NULL_RTX
expr_stmt|;
comment|/* If any of the hard registers in EQUIV are spill 		     registers, mark them as in use for this insn.  */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|nr
condition|;
name|k
operator|++
control|)
block|{
name|i
operator|=
name|spill_reg_order
index|[
name|regno
operator|+
name|k
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
name|mark_reload_reg_in_use
argument_list|(
name|regno
argument_list|,
name|rld
index|[
name|r
index|]
operator|.
name|opnum
argument_list|,
name|rld
index|[
name|r
index|]
operator|.
name|when_needed
argument_list|,
name|rld
index|[
name|r
index|]
operator|.
name|mode
argument_list|)
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|reload_reg_used_for_inherit
argument_list|,
name|regno
operator|+
name|k
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* If we found a register to use already, or if this is an optional 	     reload, we are done.  */
if|if
condition|(
name|rld
index|[
name|r
index|]
operator|.
name|reg_rtx
operator|!=
literal|0
operator|||
name|rld
index|[
name|r
index|]
operator|.
name|optional
operator|!=
literal|0
condition|)
continue|continue;
if|#
directive|if
literal|0
comment|/* No longer needed for correct operation.  Might or might 	     not give better code on the average.  Want to experiment?  */
comment|/* See if there is a later reload that has a class different from our 	     class that intersects our class or that requires less register 	     than our reload.  If so, we must allocate a register to this 	     reload now, since that reload might inherit a previous reload 	     and take the only available register in our class.  Don't do this 	     for optional reloads since they will force all previous reloads 	     to be allocated.  Also don't do this for reloads that have been 	     turned off.  */
block|for (i = j + 1; i< n_reloads; i++) 	    { 	      int s = reload_order[i];  	      if ((rld[s].in == 0&& rld[s].out == 0&& ! rld[s].secondary_p) 		  || rld[s].optional) 		continue;  	      if ((rld[s].class != rld[r].class&& reg_classes_intersect_p (rld[r].class, 					       rld[s].class)) 		  || rld[s].nregs< rld[r].nregs) 		break; 	    }  	  if (i == n_reloads) 	    continue;  	  allocate_reload_reg (chain, r, j == n_reloads - 1);
endif|#
directive|endif
block|}
comment|/* Now allocate reload registers for anything non-optional that 	 didn't get one yet.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_reloads
condition|;
name|j
operator|++
control|)
block|{
name|int
name|r
init|=
name|reload_order
index|[
name|j
index|]
decl_stmt|;
comment|/* Ignore reloads that got marked inoperative.  */
if|if
condition|(
name|rld
index|[
name|r
index|]
operator|.
name|out
operator|==
literal|0
operator|&&
name|rld
index|[
name|r
index|]
operator|.
name|in
operator|==
literal|0
operator|&&
operator|!
name|rld
index|[
name|r
index|]
operator|.
name|secondary_p
condition|)
continue|continue;
comment|/* Skip reloads that already have a register allocated or are 	     optional.  */
if|if
condition|(
name|rld
index|[
name|r
index|]
operator|.
name|reg_rtx
operator|!=
literal|0
operator|||
name|rld
index|[
name|r
index|]
operator|.
name|optional
condition|)
continue|continue;
if|if
condition|(
operator|!
name|allocate_reload_reg
argument_list|(
name|chain
argument_list|,
name|r
argument_list|,
name|j
operator|==
name|n_reloads
operator|-
literal|1
argument_list|)
condition|)
break|break;
block|}
comment|/* If that loop got all the way, we have won.  */
if|if
condition|(
name|j
operator|==
name|n_reloads
condition|)
block|{
name|win
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* Loop around and try without any inheritance.  */
block|}
if|if
condition|(
operator|!
name|win
condition|)
block|{
comment|/* First undo everything done by the failed attempt 	 to allocate with inheritance.  */
name|choose_reload_regs_init
argument_list|(
name|chain
argument_list|,
name|save_reload_reg_rtx
argument_list|)
expr_stmt|;
comment|/* Some sanity tests to verify that the reloads found in the first 	 pass are identical to the ones we have now.  */
if|if
condition|(
name|chain
operator|->
name|n_reloads
operator|!=
name|n_reloads
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_reloads
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|chain
operator|->
name|rld
index|[
name|i
index|]
operator|.
name|regno
operator|<
literal|0
operator|||
name|chain
operator|->
name|rld
index|[
name|i
index|]
operator|.
name|reg_rtx
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|chain
operator|->
name|rld
index|[
name|i
index|]
operator|.
name|when_needed
operator|!=
name|rld
index|[
name|i
index|]
operator|.
name|when_needed
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_spills
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|spill_regs
index|[
name|j
index|]
operator|==
name|chain
operator|->
name|rld
index|[
name|i
index|]
operator|.
name|regno
condition|)
if|if
condition|(
operator|!
name|set_reload_reg
argument_list|(
name|j
argument_list|,
name|i
argument_list|)
condition|)
name|failed_reload
argument_list|(
name|chain
operator|->
name|insn
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If we thought we could inherit a reload, because it seemed that      nothing else wanted the same reload register earlier in the insn,      verify that assumption, now that all reloads have been assigned.      Likewise for reloads where reload_override_in has been set.  */
comment|/* If doing expensive optimizations, do one preliminary pass that doesn't      cancel any inheritance, but removes reloads that have been needed only      for reloads that we know can be inherited.  */
for|for
control|(
name|pass
operator|=
name|flag_expensive_optimizations
init|;
name|pass
operator|>=
literal|0
condition|;
name|pass
operator|--
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_reloads
condition|;
name|j
operator|++
control|)
block|{
name|int
name|r
init|=
name|reload_order
index|[
name|j
index|]
decl_stmt|;
name|rtx
name|check_reg
decl_stmt|;
if|if
condition|(
name|reload_inherited
index|[
name|r
index|]
operator|&&
name|rld
index|[
name|r
index|]
operator|.
name|reg_rtx
condition|)
name|check_reg
operator|=
name|rld
index|[
name|r
index|]
operator|.
name|reg_rtx
expr_stmt|;
elseif|else
if|if
condition|(
name|reload_override_in
index|[
name|r
index|]
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|reload_override_in
index|[
name|r
index|]
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|reload_override_in
index|[
name|r
index|]
argument_list|)
operator|==
name|SUBREG
operator|)
condition|)
name|check_reg
operator|=
name|reload_override_in
index|[
name|r
index|]
expr_stmt|;
else|else
continue|continue;
if|if
condition|(
operator|!
name|free_for_value_p
argument_list|(
name|true_regnum
argument_list|(
name|check_reg
argument_list|)
argument_list|,
name|rld
index|[
name|r
index|]
operator|.
name|mode
argument_list|,
name|rld
index|[
name|r
index|]
operator|.
name|opnum
argument_list|,
name|rld
index|[
name|r
index|]
operator|.
name|when_needed
argument_list|,
name|rld
index|[
name|r
index|]
operator|.
name|in
argument_list|,
operator|(
name|reload_inherited
index|[
name|r
index|]
condition|?
name|rld
index|[
name|r
index|]
operator|.
name|out
else|:
name|const0_rtx
operator|)
argument_list|,
name|r
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|pass
condition|)
continue|continue;
name|reload_inherited
index|[
name|r
index|]
operator|=
literal|0
expr_stmt|;
name|reload_override_in
index|[
name|r
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If we can inherit a RELOAD_FOR_INPUT, or can use a 	     reload_override_in, then we do not need its related 	     RELOAD_FOR_INPUT_ADDRESS / RELOAD_FOR_INPADDR_ADDRESS reloads; 	     likewise for other reload types. 	     We handle this by removing a reload when its only replacement 	     is mentioned in reload_in of the reload we are going to inherit. 	     A special case are auto_inc expressions; even if the input is 	     inherited, we still need the address for the output.  We can 	     recognize them because they have RELOAD_OUT set to RELOAD_IN. 	     If we succeeded removing some reload and we are doing a preliminary 	     pass just to remove such reloads, make another pass, since the 	     removal of one reload might allow us to inherit another one.  */
elseif|else
if|if
condition|(
name|rld
index|[
name|r
index|]
operator|.
name|in
operator|&&
name|rld
index|[
name|r
index|]
operator|.
name|out
operator|!=
name|rld
index|[
name|r
index|]
operator|.
name|in
operator|&&
name|remove_address_replacements
argument_list|(
name|rld
index|[
name|r
index|]
operator|.
name|in
argument_list|)
operator|&&
name|pass
condition|)
name|pass
operator|=
literal|2
expr_stmt|;
block|}
block|}
comment|/* Now that reload_override_in is known valid,      actually override reload_in.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_reloads
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|reload_override_in
index|[
name|j
index|]
condition|)
name|rld
index|[
name|j
index|]
operator|.
name|in
operator|=
name|reload_override_in
index|[
name|j
index|]
expr_stmt|;
comment|/* If this reload won't be done because it has been cancelled or is      optional and not inherited, clear reload_reg_rtx so other      routines (such as subst_reloads) don't get confused.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_reloads
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|rld
index|[
name|j
index|]
operator|.
name|reg_rtx
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|rld
index|[
name|j
index|]
operator|.
name|optional
operator|&&
operator|!
name|reload_inherited
index|[
name|j
index|]
operator|)
operator|||
operator|(
name|rld
index|[
name|j
index|]
operator|.
name|in
operator|==
literal|0
operator|&&
name|rld
index|[
name|j
index|]
operator|.
name|out
operator|==
literal|0
operator|&&
operator|!
name|rld
index|[
name|j
index|]
operator|.
name|secondary_p
operator|)
operator|)
condition|)
block|{
name|int
name|regno
init|=
name|true_regnum
argument_list|(
name|rld
index|[
name|j
index|]
operator|.
name|reg_rtx
argument_list|)
decl_stmt|;
if|if
condition|(
name|spill_reg_order
index|[
name|regno
index|]
operator|>=
literal|0
condition|)
name|clear_reload_reg_in_use
argument_list|(
name|regno
argument_list|,
name|rld
index|[
name|j
index|]
operator|.
name|opnum
argument_list|,
name|rld
index|[
name|j
index|]
operator|.
name|when_needed
argument_list|,
name|rld
index|[
name|j
index|]
operator|.
name|mode
argument_list|)
expr_stmt|;
name|rld
index|[
name|j
index|]
operator|.
name|reg_rtx
operator|=
literal|0
expr_stmt|;
name|reload_spill_index
index|[
name|j
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Record which pseudos and which spill regs have output reloads.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_reloads
condition|;
name|j
operator|++
control|)
block|{
name|int
name|r
init|=
name|reload_order
index|[
name|j
index|]
decl_stmt|;
name|i
operator|=
name|reload_spill_index
index|[
name|r
index|]
expr_stmt|;
comment|/* I is nonneg if this reload uses a register. 	 If rld[r].reg_rtx is 0, this is an optional reload 	 that we opted to ignore.  */
if|if
condition|(
name|rld
index|[
name|r
index|]
operator|.
name|out_reg
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|rld
index|[
name|r
index|]
operator|.
name|out_reg
argument_list|)
operator|==
name|REG
operator|&&
name|rld
index|[
name|r
index|]
operator|.
name|reg_rtx
operator|!=
literal|0
condition|)
block|{
name|int
name|nregno
init|=
name|REGNO
argument_list|(
name|rld
index|[
name|r
index|]
operator|.
name|out_reg
argument_list|)
decl_stmt|;
name|int
name|nr
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|nregno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|nr
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|nregno
argument_list|,
name|rld
index|[
name|r
index|]
operator|.
name|mode
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|nr
operator|>=
literal|0
condition|)
name|reg_has_output_reload
index|[
name|nregno
operator|+
name|nr
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
name|nr
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|i
argument_list|,
name|rld
index|[
name|r
index|]
operator|.
name|mode
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|nr
operator|>=
literal|0
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|reg_is_output_reload
argument_list|,
name|i
operator|+
name|nr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rld
index|[
name|r
index|]
operator|.
name|when_needed
operator|!=
name|RELOAD_OTHER
operator|&&
name|rld
index|[
name|r
index|]
operator|.
name|when_needed
operator|!=
name|RELOAD_FOR_OUTPUT
operator|&&
name|rld
index|[
name|r
index|]
operator|.
name|when_needed
operator|!=
name|RELOAD_FOR_INSN
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Deallocate the reload register for reload R.  This is called from    remove_address_replacements.  */
end_comment

begin_function
name|void
name|deallocate_reload_reg
parameter_list|(
name|r
parameter_list|)
name|int
name|r
decl_stmt|;
block|{
name|int
name|regno
decl_stmt|;
if|if
condition|(
operator|!
name|rld
index|[
name|r
index|]
operator|.
name|reg_rtx
condition|)
return|return;
name|regno
operator|=
name|true_regnum
argument_list|(
name|rld
index|[
name|r
index|]
operator|.
name|reg_rtx
argument_list|)
expr_stmt|;
name|rld
index|[
name|r
index|]
operator|.
name|reg_rtx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|spill_reg_order
index|[
name|regno
index|]
operator|>=
literal|0
condition|)
name|clear_reload_reg_in_use
argument_list|(
name|regno
argument_list|,
name|rld
index|[
name|r
index|]
operator|.
name|opnum
argument_list|,
name|rld
index|[
name|r
index|]
operator|.
name|when_needed
argument_list|,
name|rld
index|[
name|r
index|]
operator|.
name|mode
argument_list|)
expr_stmt|;
name|reload_spill_index
index|[
name|r
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If SMALL_REGISTER_CLASSES is non-zero, we may not have merged two    reloads of the same item for fear that we might not have enough reload    registers. However, normally they will get the same reload register    and hence actually need not be loaded twice.     Here we check for the most common case of this phenomenon: when we have    a number of reloads for the same object, each of which were allocated    the same reload_reg_rtx, that reload_reg_rtx is not used for any other    reload, and is not modified in the insn itself.  If we find such,    merge all the reloads and set the resulting reload to RELOAD_OTHER.    This will not increase the number of spill registers needed and will    prevent redundant code.  */
end_comment

begin_function
specifier|static
name|void
name|merge_assigned_reloads
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* Scan all the reloads looking for ones that only load values and      are not already RELOAD_OTHER and ones whose reload_reg_rtx are      assigned and not modified by INSN.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_reloads
condition|;
name|i
operator|++
control|)
block|{
name|int
name|conflicting_input
init|=
literal|0
decl_stmt|;
name|int
name|max_input_address_opnum
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|min_conflicting_input_opnum
init|=
name|MAX_RECOG_OPERANDS
decl_stmt|;
if|if
condition|(
name|rld
index|[
name|i
index|]
operator|.
name|in
operator|==
literal|0
operator|||
name|rld
index|[
name|i
index|]
operator|.
name|when_needed
operator|==
name|RELOAD_OTHER
operator|||
name|rld
index|[
name|i
index|]
operator|.
name|out
operator|!=
literal|0
operator|||
name|rld
index|[
name|i
index|]
operator|.
name|reg_rtx
operator|==
literal|0
operator|||
name|reg_set_p
argument_list|(
name|rld
index|[
name|i
index|]
operator|.
name|reg_rtx
argument_list|,
name|insn
argument_list|)
condition|)
continue|continue;
comment|/* Look at all other reloads.  Ensure that the only use of this 	 reload_reg_rtx is in a reload that just loads the same value 	 as we do.  Note that any secondary reloads must be of the identical 	 class since the values, modes, and result registers are the 	 same, so we need not do anything with any secondary reloads.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_reloads
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|j
operator|||
name|rld
index|[
name|j
index|]
operator|.
name|reg_rtx
operator|==
literal|0
operator|||
operator|!
name|reg_overlap_mentioned_p
argument_list|(
name|rld
index|[
name|j
index|]
operator|.
name|reg_rtx
argument_list|,
name|rld
index|[
name|i
index|]
operator|.
name|reg_rtx
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|rld
index|[
name|j
index|]
operator|.
name|when_needed
operator|==
name|RELOAD_FOR_INPUT_ADDRESS
operator|&&
name|rld
index|[
name|j
index|]
operator|.
name|opnum
operator|>
name|max_input_address_opnum
condition|)
name|max_input_address_opnum
operator|=
name|rld
index|[
name|j
index|]
operator|.
name|opnum
expr_stmt|;
comment|/* If the reload regs aren't exactly the same (e.g, different modes) 	     or if the values are different, we can't merge this reload. 	     But if it is an input reload, we might still merge 	     RELOAD_FOR_INPUT_ADDRESS and RELOAD_FOR_OTHER_ADDRESS reloads.  */
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|rld
index|[
name|i
index|]
operator|.
name|reg_rtx
argument_list|,
name|rld
index|[
name|j
index|]
operator|.
name|reg_rtx
argument_list|)
operator|||
name|rld
index|[
name|j
index|]
operator|.
name|out
operator|!=
literal|0
operator|||
name|rld
index|[
name|j
index|]
operator|.
name|in
operator|==
literal|0
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|rld
index|[
name|i
index|]
operator|.
name|in
argument_list|,
name|rld
index|[
name|j
index|]
operator|.
name|in
argument_list|)
condition|)
block|{
if|if
condition|(
name|rld
index|[
name|j
index|]
operator|.
name|when_needed
operator|!=
name|RELOAD_FOR_INPUT
operator|||
operator|(
operator|(
name|rld
index|[
name|i
index|]
operator|.
name|when_needed
operator|!=
name|RELOAD_FOR_INPUT_ADDRESS
operator|||
name|rld
index|[
name|i
index|]
operator|.
name|opnum
operator|>
name|rld
index|[
name|j
index|]
operator|.
name|opnum
operator|)
operator|&&
name|rld
index|[
name|i
index|]
operator|.
name|when_needed
operator|!=
name|RELOAD_FOR_OTHER_ADDRESS
operator|)
condition|)
break|break;
name|conflicting_input
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|min_conflicting_input_opnum
operator|>
name|rld
index|[
name|j
index|]
operator|.
name|opnum
condition|)
name|min_conflicting_input_opnum
operator|=
name|rld
index|[
name|j
index|]
operator|.
name|opnum
expr_stmt|;
block|}
block|}
comment|/* If all is OK, merge the reloads.  Only set this to RELOAD_OTHER if 	 we, in fact, found any matching reloads.  */
if|if
condition|(
name|j
operator|==
name|n_reloads
operator|&&
name|max_input_address_opnum
operator|<=
name|min_conflicting_input_opnum
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_reloads
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|i
operator|!=
name|j
operator|&&
name|rld
index|[
name|j
index|]
operator|.
name|reg_rtx
operator|!=
literal|0
operator|&&
name|rtx_equal_p
argument_list|(
name|rld
index|[
name|i
index|]
operator|.
name|reg_rtx
argument_list|,
name|rld
index|[
name|j
index|]
operator|.
name|reg_rtx
argument_list|)
operator|&&
operator|(
operator|!
name|conflicting_input
operator|||
name|rld
index|[
name|j
index|]
operator|.
name|when_needed
operator|==
name|RELOAD_FOR_INPUT_ADDRESS
operator|||
name|rld
index|[
name|j
index|]
operator|.
name|when_needed
operator|==
name|RELOAD_FOR_OTHER_ADDRESS
operator|)
condition|)
block|{
name|rld
index|[
name|i
index|]
operator|.
name|when_needed
operator|=
name|RELOAD_OTHER
expr_stmt|;
name|rld
index|[
name|j
index|]
operator|.
name|in
operator|=
literal|0
expr_stmt|;
name|reload_spill_index
index|[
name|j
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|transfer_replacements
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
comment|/* If this is now RELOAD_OTHER, look for any reloads that load 	     parts of this operand and set them to RELOAD_FOR_OTHER_ADDRESS 	     if they were for inputs, RELOAD_OTHER for outputs.  Note that 	     this test is equivalent to looking for reloads for this operand 	     number.  */
if|if
condition|(
name|rld
index|[
name|i
index|]
operator|.
name|when_needed
operator|==
name|RELOAD_OTHER
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_reloads
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|rld
index|[
name|j
index|]
operator|.
name|in
operator|!=
literal|0
operator|&&
name|rld
index|[
name|j
index|]
operator|.
name|when_needed
operator|!=
name|RELOAD_OTHER
operator|&&
name|reg_overlap_mentioned_for_reload_p
argument_list|(
name|rld
index|[
name|j
index|]
operator|.
name|in
argument_list|,
name|rld
index|[
name|i
index|]
operator|.
name|in
argument_list|)
condition|)
name|rld
index|[
name|j
index|]
operator|.
name|when_needed
operator|=
operator|(
operator|(
name|rld
index|[
name|j
index|]
operator|.
name|when_needed
operator|==
name|RELOAD_FOR_INPUT_ADDRESS
operator|||
name|rld
index|[
name|j
index|]
operator|.
name|when_needed
operator|==
name|RELOAD_FOR_INPADDR_ADDRESS
operator|)
condition|?
name|RELOAD_FOR_OTHER_ADDRESS
else|:
name|RELOAD_OTHER
operator|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* These arrays are filled by emit_reload_insns and its subroutines.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|input_reload_insns
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|other_input_address_reload_insns
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|other_input_reload_insns
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|input_address_reload_insns
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|inpaddr_address_reload_insns
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|output_reload_insns
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|output_address_reload_insns
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|outaddr_address_reload_insns
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|operand_reload_insns
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|other_operand_reload_insns
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|other_output_reload_insns
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Values to be put in spill_reg_store are put here first.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|new_spill_reg_store
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|reg_reloaded_died
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Generate insns to perform reload RL, which is for the insn in CHAIN and    has the number J.  OLD contains the value to be used as input.  */
end_comment

begin_function
specifier|static
name|void
name|emit_input_reload_insns
parameter_list|(
name|chain
parameter_list|,
name|rl
parameter_list|,
name|old
parameter_list|,
name|j
parameter_list|)
name|struct
name|insn_chain
modifier|*
name|chain
decl_stmt|;
name|struct
name|reload
modifier|*
name|rl
decl_stmt|;
name|rtx
name|old
decl_stmt|;
name|int
name|j
decl_stmt|;
block|{
name|rtx
name|insn
init|=
name|chain
operator|->
name|insn
decl_stmt|;
name|rtx
name|reloadreg
init|=
name|rl
operator|->
name|reg_rtx
decl_stmt|;
name|rtx
name|oldequiv_reg
init|=
literal|0
decl_stmt|;
name|rtx
name|oldequiv
init|=
literal|0
decl_stmt|;
name|int
name|special
init|=
literal|0
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
modifier|*
name|where
decl_stmt|;
comment|/* Determine the mode to reload in.      This is very tricky because we have three to choose from.      There is the mode the insn operand wants (rl->inmode).      There is the mode of the reload register RELOADREG.      There is the intrinsic mode of the operand, which we could find      by stripping some SUBREGs.      It turns out that RELOADREG's mode is irrelevant:      we can change that arbitrarily.       Consider (SUBREG:SI foo:QI) as an operand that must be SImode;      then the reload reg may not support QImode moves, so use SImode.      If foo is in memory due to spilling a pseudo reg, this is safe,      because the QImode value is in the least significant part of a      slot big enough for a SImode.  If foo is some other sort of      memory reference, then it is impossible to reload this case,      so previous passes had better make sure this never happens.       Then consider a one-word union which has SImode and one of its      members is a float, being fetched as (SUBREG:SF union:SI).      We must fetch that as SFmode because we could be loading into      a float-only register.  In this case OLD's mode is correct.       Consider an immediate integer: it has VOIDmode.  Here we need      to get a mode from something else.       In some cases, there is a fourth mode, the operand's      containing mode.  If the insn specifies a containing mode for      this operand, it overrides all others.       I am not sure whether the algorithm here is always right,      but it does the right things in those cases.  */
name|mode
operator|=
name|GET_MODE
argument_list|(
name|old
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|mode
operator|=
name|rl
operator|->
name|inmode
expr_stmt|;
ifdef|#
directive|ifdef
name|SECONDARY_INPUT_RELOAD_CLASS
comment|/* If we need a secondary register for this operation, see if      the value is already in a register in that class.  Don't      do this if the secondary register will be used as a scratch      register.  */
if|if
condition|(
name|rl
operator|->
name|secondary_in_reload
operator|>=
literal|0
operator|&&
name|rl
operator|->
name|secondary_in_icode
operator|==
name|CODE_FOR_nothing
operator|&&
name|optimize
condition|)
name|oldequiv
operator|=
name|find_equiv_reg
argument_list|(
name|old
argument_list|,
name|insn
argument_list|,
name|rld
index|[
name|rl
operator|->
name|secondary_in_reload
index|]
operator|.
name|class
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If reloading from memory, see if there is a register      that already holds the same value.  If so, reload from there.      We can pass 0 as the reload_reg_p argument because      any other reload has either already been emitted,      in which case find_equiv_reg will see the reload-insn,      or has yet to be emitted, in which case it doesn't matter      because we will use this equiv reg right away.  */
if|if
condition|(
name|oldequiv
operator|==
literal|0
operator|&&
name|optimize
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|old
argument_list|)
operator|==
name|MEM
operator|||
operator|(
name|GET_CODE
argument_list|(
name|old
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|old
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_renumber
index|[
name|REGNO
argument_list|(
name|old
argument_list|)
index|]
operator|<
literal|0
operator|)
operator|)
condition|)
name|oldequiv
operator|=
name|find_equiv_reg
argument_list|(
name|old
argument_list|,
name|insn
argument_list|,
name|ALL_REGS
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldequiv
condition|)
block|{
name|unsigned
name|int
name|regno
init|=
name|true_regnum
argument_list|(
name|oldequiv
argument_list|)
decl_stmt|;
comment|/* Don't use OLDEQUIV if any other reload changes it at an 	 earlier stage of this insn or at this stage.  */
if|if
condition|(
operator|!
name|free_for_value_p
argument_list|(
name|regno
argument_list|,
name|rl
operator|->
name|mode
argument_list|,
name|rl
operator|->
name|opnum
argument_list|,
name|rl
operator|->
name|when_needed
argument_list|,
name|rl
operator|->
name|in
argument_list|,
name|const0_rtx
argument_list|,
name|j
argument_list|,
literal|0
argument_list|)
condition|)
name|oldequiv
operator|=
literal|0
expr_stmt|;
comment|/* If it is no cheaper to copy from OLDEQUIV into the 	 reload register than it would be to move from memory, 	 don't use it. Likewise, if we need a secondary register 	 or memory.  */
if|if
condition|(
name|oldequiv
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|REGNO_REG_CLASS
argument_list|(
name|regno
argument_list|)
operator|!=
name|rl
operator|->
name|class
operator|&&
operator|(
name|REGISTER_MOVE_COST
argument_list|(
name|mode
argument_list|,
name|REGNO_REG_CLASS
argument_list|(
name|regno
argument_list|)
argument_list|,
name|rl
operator|->
name|class
argument_list|)
operator|>=
name|MEMORY_MOVE_COST
argument_list|(
name|mode
argument_list|,
name|rl
operator|->
name|class
argument_list|,
literal|1
argument_list|)
operator|)
operator|)
ifdef|#
directive|ifdef
name|SECONDARY_INPUT_RELOAD_CLASS
operator|||
operator|(
name|SECONDARY_INPUT_RELOAD_CLASS
argument_list|(
name|rl
operator|->
name|class
argument_list|,
name|mode
argument_list|,
name|oldequiv
argument_list|)
operator|!=
name|NO_REGS
operator|)
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SECONDARY_MEMORY_NEEDED
operator|||
name|SECONDARY_MEMORY_NEEDED
argument_list|(
name|REGNO_REG_CLASS
argument_list|(
name|regno
argument_list|)
argument_list|,
name|rl
operator|->
name|class
argument_list|,
name|mode
argument_list|)
endif|#
directive|endif
operator|)
condition|)
name|oldequiv
operator|=
literal|0
expr_stmt|;
block|}
comment|/* delete_output_reload is only invoked properly if old contains      the original pseudo register.  Since this is replaced with a      hard reg when RELOAD_OVERRIDE_IN is set, see if we can      find the pseudo in RELOAD_IN_REG.  */
if|if
condition|(
name|oldequiv
operator|==
literal|0
operator|&&
name|reload_override_in
index|[
name|j
index|]
operator|&&
name|GET_CODE
argument_list|(
name|rl
operator|->
name|in_reg
argument_list|)
operator|==
name|REG
condition|)
block|{
name|oldequiv
operator|=
name|old
expr_stmt|;
name|old
operator|=
name|rl
operator|->
name|in_reg
expr_stmt|;
block|}
if|if
condition|(
name|oldequiv
operator|==
literal|0
condition|)
name|oldequiv
operator|=
name|old
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|oldequiv
argument_list|)
operator|==
name|REG
condition|)
name|oldequiv_reg
operator|=
name|oldequiv
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|oldequiv
argument_list|)
operator|==
name|SUBREG
condition|)
name|oldequiv_reg
operator|=
name|SUBREG_REG
argument_list|(
name|oldequiv
argument_list|)
expr_stmt|;
comment|/* If we are reloading from a register that was recently stored in      with an output-reload, see if we can prove there was      actually no need to store the old value in it.  */
if|if
condition|(
name|optimize
operator|&&
name|GET_CODE
argument_list|(
name|oldequiv
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|oldequiv
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|spill_reg_store
index|[
name|REGNO
argument_list|(
name|oldequiv
argument_list|)
index|]
operator|&&
name|GET_CODE
argument_list|(
name|old
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|dead_or_set_p
argument_list|(
name|insn
argument_list|,
name|spill_reg_stored_to
index|[
name|REGNO
argument_list|(
name|oldequiv
argument_list|)
index|]
argument_list|)
operator|||
name|rtx_equal_p
argument_list|(
name|spill_reg_stored_to
index|[
name|REGNO
argument_list|(
name|oldequiv
argument_list|)
index|]
argument_list|,
name|rl
operator|->
name|out_reg
argument_list|)
operator|)
condition|)
name|delete_output_reload
argument_list|(
name|insn
argument_list|,
name|j
argument_list|,
name|REGNO
argument_list|(
name|oldequiv
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Encapsulate both RELOADREG and OLDEQUIV into that mode,      then load RELOADREG from OLDEQUIV.  Note that we cannot use      gen_lowpart_common since it can do the wrong thing when      RELOADREG has a multi-word mode.  Note that RELOADREG      must always be a REG here.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|reloadreg
argument_list|)
operator|!=
name|mode
condition|)
name|reloadreg
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|REGNO
argument_list|(
name|reloadreg
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|oldequiv
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_MODE
argument_list|(
name|oldequiv
argument_list|)
operator|!=
name|mode
condition|)
name|oldequiv
operator|=
name|SUBREG_REG
argument_list|(
name|oldequiv
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|oldequiv
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|oldequiv
argument_list|)
condition|)
name|oldequiv
operator|=
name|gen_lowpart_SUBREG
argument_list|(
name|mode
argument_list|,
name|oldequiv
argument_list|)
expr_stmt|;
comment|/* Switch to the right place to emit the reload insns.  */
switch|switch
condition|(
name|rl
operator|->
name|when_needed
condition|)
block|{
case|case
name|RELOAD_OTHER
case|:
name|where
operator|=
operator|&
name|other_input_reload_insns
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_INPUT
case|:
name|where
operator|=
operator|&
name|input_reload_insns
index|[
name|rl
operator|->
name|opnum
index|]
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_INPUT_ADDRESS
case|:
name|where
operator|=
operator|&
name|input_address_reload_insns
index|[
name|rl
operator|->
name|opnum
index|]
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_INPADDR_ADDRESS
case|:
name|where
operator|=
operator|&
name|inpaddr_address_reload_insns
index|[
name|rl
operator|->
name|opnum
index|]
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OUTPUT_ADDRESS
case|:
name|where
operator|=
operator|&
name|output_address_reload_insns
index|[
name|rl
operator|->
name|opnum
index|]
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OUTADDR_ADDRESS
case|:
name|where
operator|=
operator|&
name|outaddr_address_reload_insns
index|[
name|rl
operator|->
name|opnum
index|]
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OPERAND_ADDRESS
case|:
name|where
operator|=
operator|&
name|operand_reload_insns
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OPADDR_ADDR
case|:
name|where
operator|=
operator|&
name|other_operand_reload_insns
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OTHER_ADDRESS
case|:
name|where
operator|=
operator|&
name|other_input_address_reload_insns
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|push_to_sequence
argument_list|(
operator|*
name|where
argument_list|)
expr_stmt|;
comment|/* Auto-increment addresses must be reloaded in a special way.  */
if|if
condition|(
name|rl
operator|->
name|out
operator|&&
operator|!
name|rl
operator|->
name|out_reg
condition|)
block|{
comment|/* We are not going to bother supporting the case where a 	 incremented register can't be copied directly from 	 OLDEQUIV since this seems highly unlikely.  */
if|if
condition|(
name|rl
operator|->
name|secondary_in_reload
operator|>=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|reload_inherited
index|[
name|j
index|]
condition|)
name|oldequiv
operator|=
name|reloadreg
expr_stmt|;
name|old
operator|=
name|XEXP
argument_list|(
name|rl
operator|->
name|in_reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|optimize
operator|&&
name|GET_CODE
argument_list|(
name|oldequiv
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|oldequiv
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|spill_reg_store
index|[
name|REGNO
argument_list|(
name|oldequiv
argument_list|)
index|]
operator|&&
name|GET_CODE
argument_list|(
name|old
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|dead_or_set_p
argument_list|(
name|insn
argument_list|,
name|spill_reg_stored_to
index|[
name|REGNO
argument_list|(
name|oldequiv
argument_list|)
index|]
argument_list|)
operator|||
name|rtx_equal_p
argument_list|(
name|spill_reg_stored_to
index|[
name|REGNO
argument_list|(
name|oldequiv
argument_list|)
index|]
argument_list|,
name|old
argument_list|)
operator|)
condition|)
name|delete_output_reload
argument_list|(
name|insn
argument_list|,
name|j
argument_list|,
name|REGNO
argument_list|(
name|oldequiv
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Prevent normal processing of this reload.  */
name|special
operator|=
literal|1
expr_stmt|;
comment|/* Output a special code sequence for this case.  */
name|new_spill_reg_store
index|[
name|REGNO
argument_list|(
name|reloadreg
argument_list|)
index|]
operator|=
name|inc_for_reload
argument_list|(
name|reloadreg
argument_list|,
name|oldequiv
argument_list|,
name|rl
operator|->
name|out
argument_list|,
name|rl
operator|->
name|inc
argument_list|)
expr_stmt|;
block|}
comment|/* If we are reloading a pseudo-register that was set by the previous      insn, see if we can get rid of that pseudo-register entirely      by redirecting the previous insn into our reload register.  */
elseif|else
if|if
condition|(
name|optimize
operator|&&
name|GET_CODE
argument_list|(
name|old
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|old
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|dead_or_set_p
argument_list|(
name|insn
argument_list|,
name|old
argument_list|)
comment|/* This is unsafe if some other reload 	      uses the same reg first.  */
operator|&&
operator|!
name|conflicts_with_override
argument_list|(
name|reloadreg
argument_list|)
operator|&&
name|free_for_value_p
argument_list|(
name|REGNO
argument_list|(
name|reloadreg
argument_list|)
argument_list|,
name|rl
operator|->
name|mode
argument_list|,
name|rl
operator|->
name|opnum
argument_list|,
name|rl
operator|->
name|when_needed
argument_list|,
name|old
argument_list|,
name|rl
operator|->
name|out
argument_list|,
name|j
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|rtx
name|temp
init|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
while|while
condition|(
name|temp
operator|&&
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|NOTE
condition|)
name|temp
operator|=
name|PREV_INSN
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|&&
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|==
name|old
comment|/* Make sure we can access insn_operand_constraint.  */
operator|&&
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|<
literal|0
comment|/* This is unsafe if prev insn rejects our reload reg.  */
operator|&&
name|constraint_accepts_reg_p
argument_list|(
name|insn_data
index|[
name|recog_memoized
argument_list|(
name|temp
argument_list|)
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|constraint
argument_list|,
name|reloadreg
argument_list|)
comment|/* This is unsafe if operand occurs more than once in current 	     insn.  Perhaps some occurrences aren't reloaded.  */
operator|&&
name|count_occurrences
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|old
argument_list|,
literal|0
argument_list|)
operator|==
literal|1
comment|/* Don't risk splitting a matching pair of operands.  */
operator|&&
operator|!
name|reg_mentioned_p
argument_list|(
name|old
argument_list|,
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|temp
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Store into the reload register instead of the pseudo.  */
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|=
name|reloadreg
expr_stmt|;
comment|/* If the previous insn is an output reload, the source is 	     a reload register, and its spill_reg_store entry will 	     contain the previous destination.  This is now 	     invalid.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|temp
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|temp
argument_list|)
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|spill_reg_store
index|[
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|temp
argument_list|)
argument_list|)
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
name|spill_reg_stored_to
index|[
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|temp
argument_list|)
argument_list|)
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If these are the only uses of the pseudo reg, 	     pretend for GDB it lives in the reload reg we used.  */
if|if
condition|(
name|REG_N_DEATHS
argument_list|(
name|REGNO
argument_list|(
name|old
argument_list|)
argument_list|)
operator|==
literal|1
operator|&&
name|REG_N_SETS
argument_list|(
name|REGNO
argument_list|(
name|old
argument_list|)
argument_list|)
operator|==
literal|1
condition|)
block|{
name|reg_renumber
index|[
name|REGNO
argument_list|(
name|old
argument_list|)
index|]
operator|=
name|REGNO
argument_list|(
name|rl
operator|->
name|reg_rtx
argument_list|)
expr_stmt|;
name|alter_reg
argument_list|(
name|REGNO
argument_list|(
name|old
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|special
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* We can't do that, so output an insn to load RELOADREG.  */
ifdef|#
directive|ifdef
name|SECONDARY_INPUT_RELOAD_CLASS
comment|/* If we have a secondary reload, pick up the secondary register      and icode, if any.  If OLDEQUIV and OLD are different or      if this is an in-out reload, recompute whether or not we      still need a secondary register and what the icode should      be.  If we still need a secondary register and the class or      icode is different, go back to reloading from OLD if using      OLDEQUIV means that we got the wrong type of register.  We      cannot have different class or icode due to an in-out reload      because we don't make such reloads when both the input and      output need secondary reload registers.  */
if|if
condition|(
operator|!
name|special
operator|&&
name|rl
operator|->
name|secondary_in_reload
operator|>=
literal|0
condition|)
block|{
name|rtx
name|second_reload_reg
init|=
literal|0
decl_stmt|;
name|int
name|secondary_reload
init|=
name|rl
operator|->
name|secondary_in_reload
decl_stmt|;
name|rtx
name|real_oldequiv
init|=
name|oldequiv
decl_stmt|;
name|rtx
name|real_old
init|=
name|old
decl_stmt|;
name|rtx
name|tmp
decl_stmt|;
name|enum
name|insn_code
name|icode
decl_stmt|;
comment|/* If OLDEQUIV is a pseudo with a MEM, get the real MEM 	 and similarly for OLD. 	 See comments in get_secondary_reload in reload.c.  */
comment|/* If it is a pseudo that cannot be replaced with its 	 equivalent MEM, we must fall back to reload_in, which 	 will have all the necessary substitutions registered. 	 Likewise for a pseudo that can't be replaced with its 	 equivalent constant.  	 Take extra care for subregs of such pseudos.  Note that 	 we cannot use reg_equiv_mem in this case because it is 	 not in the right mode.  */
name|tmp
operator|=
name|oldequiv
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|SUBREG
condition|)
name|tmp
operator|=
name|SUBREG_REG
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|tmp
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|(
name|reg_equiv_memory_loc
index|[
name|REGNO
argument_list|(
name|tmp
argument_list|)
index|]
operator|!=
literal|0
operator|||
name|reg_equiv_constant
index|[
name|REGNO
argument_list|(
name|tmp
argument_list|)
index|]
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|reg_equiv_mem
index|[
name|REGNO
argument_list|(
name|tmp
argument_list|)
index|]
operator|||
name|num_not_at_initial_offset
operator|||
name|GET_CODE
argument_list|(
name|oldequiv
argument_list|)
operator|==
name|SUBREG
condition|)
name|real_oldequiv
operator|=
name|rl
operator|->
name|in
expr_stmt|;
else|else
name|real_oldequiv
operator|=
name|reg_equiv_mem
index|[
name|REGNO
argument_list|(
name|tmp
argument_list|)
index|]
expr_stmt|;
block|}
name|tmp
operator|=
name|old
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|SUBREG
condition|)
name|tmp
operator|=
name|SUBREG_REG
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|tmp
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|(
name|reg_equiv_memory_loc
index|[
name|REGNO
argument_list|(
name|tmp
argument_list|)
index|]
operator|!=
literal|0
operator|||
name|reg_equiv_constant
index|[
name|REGNO
argument_list|(
name|tmp
argument_list|)
index|]
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|reg_equiv_mem
index|[
name|REGNO
argument_list|(
name|tmp
argument_list|)
index|]
operator|||
name|num_not_at_initial_offset
operator|||
name|GET_CODE
argument_list|(
name|old
argument_list|)
operator|==
name|SUBREG
condition|)
name|real_old
operator|=
name|rl
operator|->
name|in
expr_stmt|;
else|else
name|real_old
operator|=
name|reg_equiv_mem
index|[
name|REGNO
argument_list|(
name|tmp
argument_list|)
index|]
expr_stmt|;
block|}
name|second_reload_reg
operator|=
name|rld
index|[
name|secondary_reload
index|]
operator|.
name|reg_rtx
expr_stmt|;
name|icode
operator|=
name|rl
operator|->
name|secondary_in_icode
expr_stmt|;
if|if
condition|(
operator|(
name|old
operator|!=
name|oldequiv
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|old
argument_list|,
name|oldequiv
argument_list|)
operator|)
operator|||
operator|(
name|rl
operator|->
name|in
operator|!=
literal|0
operator|&&
name|rl
operator|->
name|out
operator|!=
literal|0
operator|)
condition|)
block|{
name|enum
name|reg_class
name|new_class
init|=
name|SECONDARY_INPUT_RELOAD_CLASS
argument_list|(
name|rl
operator|->
name|class
argument_list|,
name|mode
argument_list|,
name|real_oldequiv
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_class
operator|==
name|NO_REGS
condition|)
name|second_reload_reg
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|enum
name|insn_code
name|new_icode
decl_stmt|;
name|enum
name|machine_mode
name|new_mode
decl_stmt|;
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|new_class
index|]
argument_list|,
name|REGNO
argument_list|(
name|second_reload_reg
argument_list|)
argument_list|)
condition|)
name|oldequiv
operator|=
name|old
operator|,
name|real_oldequiv
operator|=
name|real_old
expr_stmt|;
else|else
block|{
name|new_icode
operator|=
name|reload_in_optab
index|[
operator|(
name|int
operator|)
name|mode
index|]
expr_stmt|;
if|if
condition|(
name|new_icode
operator|!=
name|CODE_FOR_nothing
operator|&&
operator|(
operator|(
name|insn_data
index|[
operator|(
name|int
operator|)
name|new_icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|&&
operator|!
operator|(
operator|(
operator|*
name|insn_data
index|[
operator|(
name|int
operator|)
name|new_icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|reloadreg
operator|,
name|mode
operator|)
operator|)
operator|)
operator|||
operator|(
name|insn_data
index|[
operator|(
name|int
operator|)
name|new_icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|&&
operator|!
operator|(
operator|(
operator|*
name|insn_data
index|[
operator|(
name|int
operator|)
name|new_icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|real_oldequiv
operator|,
name|mode
operator|)
operator|)
operator|)
operator|)
condition|)
name|new_icode
operator|=
name|CODE_FOR_nothing
expr_stmt|;
if|if
condition|(
name|new_icode
operator|==
name|CODE_FOR_nothing
condition|)
name|new_mode
operator|=
name|mode
expr_stmt|;
else|else
name|new_mode
operator|=
name|insn_data
index|[
operator|(
name|int
operator|)
name|new_icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|second_reload_reg
argument_list|)
operator|!=
name|new_mode
condition|)
block|{
if|if
condition|(
operator|!
name|HARD_REGNO_MODE_OK
argument_list|(
name|REGNO
argument_list|(
name|second_reload_reg
argument_list|)
argument_list|,
name|new_mode
argument_list|)
condition|)
name|oldequiv
operator|=
name|old
operator|,
name|real_oldequiv
operator|=
name|real_old
expr_stmt|;
else|else
name|second_reload_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|new_mode
argument_list|,
name|REGNO
argument_list|(
name|second_reload_reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* If we still need a secondary reload register, check 	 to see if it is being used as a scratch or intermediate 	 register and generate code appropriately.  If we need 	 a scratch register, use REAL_OLDEQUIV since the form of 	 the insn may depend on the actual address if it is 	 a MEM.  */
if|if
condition|(
name|second_reload_reg
condition|)
block|{
if|if
condition|(
name|icode
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|emit_insn
argument_list|(
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|reloadreg
argument_list|,
name|real_oldequiv
argument_list|,
name|second_reload_reg
argument_list|)
argument_list|)
expr_stmt|;
name|special
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* See if we need a scratch register to load the 		 intermediate register (a tertiary reload).  */
name|enum
name|insn_code
name|tertiary_icode
init|=
name|rld
index|[
name|secondary_reload
index|]
operator|.
name|secondary_in_icode
decl_stmt|;
if|if
condition|(
name|tertiary_icode
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|rtx
name|third_reload_reg
init|=
name|rld
index|[
name|rld
index|[
name|secondary_reload
index|]
operator|.
name|secondary_in_reload
index|]
operator|.
name|reg_rtx
decl_stmt|;
name|emit_insn
argument_list|(
operator|(
name|GEN_FCN
argument_list|(
name|tertiary_icode
argument_list|)
argument_list|(
name|second_reload_reg
argument_list|,
name|real_oldequiv
argument_list|,
name|third_reload_reg
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
name|gen_reload
argument_list|(
name|second_reload_reg
argument_list|,
name|real_oldequiv
argument_list|,
name|rl
operator|->
name|opnum
argument_list|,
name|rl
operator|->
name|when_needed
argument_list|)
expr_stmt|;
name|oldequiv
operator|=
name|second_reload_reg
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|special
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|reloadreg
argument_list|,
name|oldequiv
argument_list|)
condition|)
block|{
name|rtx
name|real_oldequiv
init|=
name|oldequiv
decl_stmt|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|oldequiv
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|oldequiv
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|(
name|reg_equiv_memory_loc
index|[
name|REGNO
argument_list|(
name|oldequiv
argument_list|)
index|]
operator|!=
literal|0
operator|||
name|reg_equiv_constant
index|[
name|REGNO
argument_list|(
name|oldequiv
argument_list|)
index|]
operator|!=
literal|0
operator|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|oldequiv
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|oldequiv
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|oldequiv
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|&&
operator|(
operator|(
name|reg_equiv_memory_loc
index|[
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|oldequiv
argument_list|)
argument_list|)
index|]
operator|!=
literal|0
operator|)
operator|||
operator|(
name|reg_equiv_constant
index|[
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|oldequiv
argument_list|)
argument_list|)
index|]
operator|!=
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|CONSTANT_P
argument_list|(
name|oldequiv
argument_list|)
operator|&&
operator|(
name|PREFERRED_RELOAD_CLASS
argument_list|(
name|oldequiv
argument_list|,
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|reloadreg
argument_list|)
argument_list|)
argument_list|)
operator|==
name|NO_REGS
operator|)
operator|)
condition|)
name|real_oldequiv
operator|=
name|rl
operator|->
name|in
expr_stmt|;
name|gen_reload
argument_list|(
name|reloadreg
argument_list|,
name|real_oldequiv
argument_list|,
name|rl
operator|->
name|opnum
argument_list|,
name|rl
operator|->
name|when_needed
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_non_call_exceptions
condition|)
name|copy_eh_notes
argument_list|(
name|insn
argument_list|,
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
comment|/* End this sequence.  */
operator|*
name|where
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
comment|/* Update reload_override_in so that delete_address_reloads_1      can see the actual register usage.  */
if|if
condition|(
name|oldequiv_reg
condition|)
name|reload_override_in
index|[
name|j
index|]
operator|=
name|oldequiv
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate insns to for the output reload RL, which is for the insn described    by CHAIN and has the number J.  */
end_comment

begin_function
specifier|static
name|void
name|emit_output_reload_insns
parameter_list|(
name|chain
parameter_list|,
name|rl
parameter_list|,
name|j
parameter_list|)
name|struct
name|insn_chain
modifier|*
name|chain
decl_stmt|;
name|struct
name|reload
modifier|*
name|rl
decl_stmt|;
name|int
name|j
decl_stmt|;
block|{
name|rtx
name|reloadreg
init|=
name|rl
operator|->
name|reg_rtx
decl_stmt|;
name|rtx
name|insn
init|=
name|chain
operator|->
name|insn
decl_stmt|;
name|int
name|special
init|=
literal|0
decl_stmt|;
name|rtx
name|old
init|=
name|rl
operator|->
name|out
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|old
argument_list|)
decl_stmt|;
name|rtx
name|p
decl_stmt|;
if|if
condition|(
name|rl
operator|->
name|when_needed
operator|==
name|RELOAD_OTHER
condition|)
name|start_sequence
argument_list|()
expr_stmt|;
else|else
name|push_to_sequence
argument_list|(
name|output_reload_insns
index|[
name|rl
operator|->
name|opnum
index|]
argument_list|)
expr_stmt|;
comment|/* Determine the mode to reload in.      See comments above (for input reloading).  */
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
block|{
comment|/* VOIDmode should never happen for an output.  */
if|if
condition|(
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
comment|/* It's the compiler's fault.  */
name|fatal_insn
argument_list|(
literal|"VOIDmode on an output"
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|error_for_asm
argument_list|(
name|insn
argument_list|,
literal|"output operand is constant in `asm'"
argument_list|)
expr_stmt|;
comment|/* Prevent crash--use something we know is valid.  */
name|mode
operator|=
name|word_mode
expr_stmt|;
name|old
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|REGNO
argument_list|(
name|reloadreg
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_MODE
argument_list|(
name|reloadreg
argument_list|)
operator|!=
name|mode
condition|)
name|reloadreg
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|REGNO
argument_list|(
name|reloadreg
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SECONDARY_OUTPUT_RELOAD_CLASS
comment|/* If we need two reload regs, set RELOADREG to the intermediate      one, since it will be stored into OLD.  We might need a secondary      register only for an input reload, so check again here.  */
if|if
condition|(
name|rl
operator|->
name|secondary_out_reload
operator|>=
literal|0
condition|)
block|{
name|rtx
name|real_old
init|=
name|old
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|old
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|old
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_equiv_mem
index|[
name|REGNO
argument_list|(
name|old
argument_list|)
index|]
operator|!=
literal|0
condition|)
name|real_old
operator|=
name|reg_equiv_mem
index|[
name|REGNO
argument_list|(
name|old
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|SECONDARY_OUTPUT_RELOAD_CLASS
argument_list|(
name|rl
operator|->
name|class
argument_list|,
name|mode
argument_list|,
name|real_old
argument_list|)
operator|!=
name|NO_REGS
operator|)
condition|)
block|{
name|rtx
name|second_reloadreg
init|=
name|reloadreg
decl_stmt|;
name|reloadreg
operator|=
name|rld
index|[
name|rl
operator|->
name|secondary_out_reload
index|]
operator|.
name|reg_rtx
expr_stmt|;
comment|/* See if RELOADREG is to be used as a scratch register 	     or as an intermediate register.  */
if|if
condition|(
name|rl
operator|->
name|secondary_out_icode
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|emit_insn
argument_list|(
operator|(
name|GEN_FCN
argument_list|(
name|rl
operator|->
name|secondary_out_icode
argument_list|)
argument_list|(
name|real_old
argument_list|,
name|second_reloadreg
argument_list|,
name|reloadreg
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|special
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* See if we need both a scratch and intermediate reload 		 register.  */
name|int
name|secondary_reload
init|=
name|rl
operator|->
name|secondary_out_reload
decl_stmt|;
name|enum
name|insn_code
name|tertiary_icode
init|=
name|rld
index|[
name|secondary_reload
index|]
operator|.
name|secondary_out_icode
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|reloadreg
argument_list|)
operator|!=
name|mode
condition|)
name|reloadreg
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|REGNO
argument_list|(
name|reloadreg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tertiary_icode
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|rtx
name|third_reloadreg
init|=
name|rld
index|[
name|rld
index|[
name|secondary_reload
index|]
operator|.
name|secondary_out_reload
index|]
operator|.
name|reg_rtx
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
comment|/* Copy primary reload reg to secondary reload reg. 		     (Note that these have been swapped above, then 		     secondary reload reg to OLD using our insn.)  */
comment|/* If REAL_OLD is a paradoxical SUBREG, remove it 		     and try to put the opposite SUBREG on 		     RELOADREG.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|real_old
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|real_old
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|real_old
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
literal|0
operator|!=
operator|(
name|tem
operator|=
name|gen_lowpart_common
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|real_old
argument_list|)
argument_list|)
argument_list|,
name|reloadreg
argument_list|)
operator|)
condition|)
name|real_old
operator|=
name|SUBREG_REG
argument_list|(
name|real_old
argument_list|)
operator|,
name|reloadreg
operator|=
name|tem
expr_stmt|;
name|gen_reload
argument_list|(
name|reloadreg
argument_list|,
name|second_reloadreg
argument_list|,
name|rl
operator|->
name|opnum
argument_list|,
name|rl
operator|->
name|when_needed
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
operator|(
name|GEN_FCN
argument_list|(
name|tertiary_icode
argument_list|)
argument_list|(
name|real_old
argument_list|,
name|reloadreg
argument_list|,
name|third_reloadreg
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|special
operator|=
literal|1
expr_stmt|;
block|}
else|else
comment|/* Copy between the reload regs here and then to 		   OUT later.  */
name|gen_reload
argument_list|(
name|reloadreg
argument_list|,
name|second_reloadreg
argument_list|,
name|rl
operator|->
name|opnum
argument_list|,
name|rl
operator|->
name|when_needed
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* Output the last reload insn.  */
if|if
condition|(
operator|!
name|special
condition|)
block|{
name|rtx
name|set
decl_stmt|;
comment|/* Don't output the last reload if OLD is not the dest of 	 INSN and is in the src and is clobbered by INSN.  */
if|if
condition|(
operator|!
name|flag_expensive_optimizations
operator|||
name|GET_CODE
argument_list|(
name|old
argument_list|)
operator|!=
name|REG
operator|||
operator|!
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
operator|)
operator|||
name|rtx_equal_p
argument_list|(
name|old
argument_list|,
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|||
operator|!
name|reg_mentioned_p
argument_list|(
name|old
argument_list|,
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|||
operator|!
name|regno_clobbered_p
argument_list|(
name|REGNO
argument_list|(
name|old
argument_list|)
argument_list|,
name|insn
argument_list|,
name|rl
operator|->
name|mode
argument_list|,
literal|0
argument_list|)
condition|)
name|gen_reload
argument_list|(
name|old
argument_list|,
name|reloadreg
argument_list|,
name|rl
operator|->
name|opnum
argument_list|,
name|rl
operator|->
name|when_needed
argument_list|)
expr_stmt|;
block|}
comment|/* Look at all insns we emitted, just to be safe.  */
for|for
control|(
name|p
operator|=
name|get_insns
argument_list|()
init|;
name|p
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|p
argument_list|)
decl_stmt|;
comment|/* If this output reload doesn't come from a spill reg, 	   clear any memory of reloaded copies of the pseudo reg. 	   If this output reload comes from a spill reg, 	   reg_has_output_reload will make this do nothing.  */
name|note_stores
argument_list|(
name|pat
argument_list|,
name|forget_old_reloads_1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|rl
operator|->
name|reg_rtx
argument_list|,
name|pat
argument_list|)
condition|)
block|{
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|reload_spill_index
index|[
name|j
index|]
operator|<
literal|0
operator|&&
name|set
operator|&&
name|SET_SRC
argument_list|(
name|set
argument_list|)
operator|==
name|rl
operator|->
name|reg_rtx
condition|)
block|{
name|int
name|src
init|=
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
decl_stmt|;
name|reload_spill_index
index|[
name|j
index|]
operator|=
name|src
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|reg_is_output_reload
argument_list|,
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|src
argument_list|)
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|reg_reloaded_died
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|REGNO
argument_list|(
name|rl
operator|->
name|reg_rtx
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|s
init|=
name|rl
operator|->
name|secondary_out_reload
decl_stmt|;
name|set
operator|=
name|single_set
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* If this reload copies only to the secondary reload 		   register, the secondary reload does the actual 		   store.  */
if|if
condition|(
name|s
operator|>=
literal|0
operator|&&
name|set
operator|==
name|NULL_RTX
condition|)
comment|/* We can't tell what function the secondary reload 		     has and where the actual store to the pseudo is 		     made; leave new_spill_reg_store alone.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|s
operator|>=
literal|0
operator|&&
name|SET_SRC
argument_list|(
name|set
argument_list|)
operator|==
name|rl
operator|->
name|reg_rtx
operator|&&
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|==
name|rld
index|[
name|s
index|]
operator|.
name|reg_rtx
condition|)
block|{
comment|/* Usually the next instruction will be the 		       secondary reload insn;  if we can confirm 		       that it is, setting new_spill_reg_store to 		       that insn will allow an extra optimization.  */
name|rtx
name|s_reg
init|=
name|rld
index|[
name|s
index|]
operator|.
name|reg_rtx
decl_stmt|;
name|rtx
name|next
init|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|rld
index|[
name|s
index|]
operator|.
name|out
operator|=
name|rl
operator|->
name|out
expr_stmt|;
name|rld
index|[
name|s
index|]
operator|.
name|out_reg
operator|=
name|rl
operator|->
name|out_reg
expr_stmt|;
name|set
operator|=
name|single_set
argument_list|(
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
operator|&&
name|SET_SRC
argument_list|(
name|set
argument_list|)
operator|==
name|s_reg
operator|&&
operator|!
name|new_spill_reg_store
index|[
name|REGNO
argument_list|(
name|s_reg
argument_list|)
index|]
condition|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|reg_is_output_reload
argument_list|,
name|REGNO
argument_list|(
name|s_reg
argument_list|)
argument_list|)
expr_stmt|;
name|new_spill_reg_store
index|[
name|REGNO
argument_list|(
name|s_reg
argument_list|)
index|]
operator|=
name|next
expr_stmt|;
block|}
block|}
else|else
name|new_spill_reg_store
index|[
name|REGNO
argument_list|(
name|rl
operator|->
name|reg_rtx
argument_list|)
index|]
operator|=
name|p
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|rl
operator|->
name|when_needed
operator|==
name|RELOAD_OTHER
condition|)
block|{
name|emit_insns
argument_list|(
name|other_output_reload_insns
index|[
name|rl
operator|->
name|opnum
index|]
argument_list|)
expr_stmt|;
name|other_output_reload_insns
index|[
name|rl
operator|->
name|opnum
index|]
operator|=
name|get_insns
argument_list|()
expr_stmt|;
block|}
else|else
name|output_reload_insns
index|[
name|rl
operator|->
name|opnum
index|]
operator|=
name|get_insns
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_non_call_exceptions
condition|)
name|copy_eh_notes
argument_list|(
name|insn
argument_list|,
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Do input reloading for reload RL, which is for the insn described by CHAIN    and has the number J.  */
end_comment

begin_function
specifier|static
name|void
name|do_input_reload
parameter_list|(
name|chain
parameter_list|,
name|rl
parameter_list|,
name|j
parameter_list|)
name|struct
name|insn_chain
modifier|*
name|chain
decl_stmt|;
name|struct
name|reload
modifier|*
name|rl
decl_stmt|;
name|int
name|j
decl_stmt|;
block|{
name|int
name|expect_occurrences
init|=
literal|1
decl_stmt|;
name|rtx
name|insn
init|=
name|chain
operator|->
name|insn
decl_stmt|;
name|rtx
name|old
init|=
operator|(
name|rl
operator|->
name|in
operator|&&
name|GET_CODE
argument_list|(
name|rl
operator|->
name|in
argument_list|)
operator|==
name|MEM
condition|?
name|rl
operator|->
name|in_reg
else|:
name|rl
operator|->
name|in
operator|)
decl_stmt|;
if|if
condition|(
name|old
operator|!=
literal|0
comment|/* AUTO_INC reloads need to be handled even if inherited.  We got an 	 AUTO_INC reload if reload_out is set but reload_out_reg isn't.  */
operator|&&
operator|(
operator|!
name|reload_inherited
index|[
name|j
index|]
operator|||
operator|(
name|rl
operator|->
name|out
operator|&&
operator|!
name|rl
operator|->
name|out_reg
operator|)
operator|)
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|rl
operator|->
name|reg_rtx
argument_list|,
name|old
argument_list|)
operator|&&
name|rl
operator|->
name|reg_rtx
operator|!=
literal|0
condition|)
name|emit_input_reload_insns
argument_list|(
name|chain
argument_list|,
name|rld
operator|+
name|j
argument_list|,
name|old
argument_list|,
name|j
argument_list|)
expr_stmt|;
comment|/* When inheriting a wider reload, we have a MEM in rl->in,      e.g. inheriting a SImode output reload for      (mem:HI (plus:SI (reg:SI 14 fp) (const_int 10)))  */
if|if
condition|(
name|optimize
operator|&&
name|reload_inherited
index|[
name|j
index|]
operator|&&
name|rl
operator|->
name|in
operator|&&
name|GET_CODE
argument_list|(
name|rl
operator|->
name|in
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|rl
operator|->
name|in_reg
argument_list|)
operator|==
name|MEM
operator|&&
name|reload_spill_index
index|[
name|j
index|]
operator|>=
literal|0
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_reloaded_valid
argument_list|,
name|reload_spill_index
index|[
name|j
index|]
argument_list|)
condition|)
block|{
name|expect_occurrences
operator|=
name|count_occurrences
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|rl
operator|->
name|in
argument_list|,
literal|0
argument_list|)
operator|==
literal|1
condition|?
literal|0
else|:
operator|-
literal|1
expr_stmt|;
name|rl
operator|->
name|in
operator|=
name|regno_reg_rtx
index|[
name|reg_reloaded_contents
index|[
name|reload_spill_index
index|[
name|j
index|]
index|]
index|]
expr_stmt|;
block|}
comment|/* If we are reloading a register that was recently stored in with an      output-reload, see if we can prove there was      actually no need to store the old value in it.  */
if|if
condition|(
name|optimize
operator|&&
operator|(
name|reload_inherited
index|[
name|j
index|]
operator|||
name|reload_override_in
index|[
name|j
index|]
operator|)
operator|&&
name|rl
operator|->
name|reg_rtx
operator|&&
name|GET_CODE
argument_list|(
name|rl
operator|->
name|reg_rtx
argument_list|)
operator|==
name|REG
operator|&&
name|spill_reg_store
index|[
name|REGNO
argument_list|(
name|rl
operator|->
name|reg_rtx
argument_list|)
index|]
operator|!=
literal|0
if|#
directive|if
literal|0
comment|/* There doesn't seem to be any reason to restrict this to pseudos 	 and doing so loses in the case where we are copying from a 	 register of the wrong class.  */
expr|&& (REGNO (spill_reg_stored_to[REGNO (rl->reg_rtx)])>= FIRST_PSEUDO_REGISTER)
endif|#
directive|endif
comment|/* The insn might have already some references to stackslots 	 replaced by MEMs, while reload_out_reg still names the 	 original pseudo.  */
operator|&&
operator|(
name|dead_or_set_p
argument_list|(
name|insn
argument_list|,
name|spill_reg_stored_to
index|[
name|REGNO
argument_list|(
name|rl
operator|->
name|reg_rtx
argument_list|)
index|]
argument_list|)
operator|||
name|rtx_equal_p
argument_list|(
name|spill_reg_stored_to
index|[
name|REGNO
argument_list|(
name|rl
operator|->
name|reg_rtx
argument_list|)
index|]
argument_list|,
name|rl
operator|->
name|out_reg
argument_list|)
operator|)
condition|)
name|delete_output_reload
argument_list|(
name|insn
argument_list|,
name|j
argument_list|,
name|REGNO
argument_list|(
name|rl
operator|->
name|reg_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Do output reloading for reload RL, which is for the insn described by    CHAIN and has the number J.    ??? At some point we need to support handling output reloads of    JUMP_INSNs or insns that set cc0.  */
end_comment

begin_function
specifier|static
name|void
name|do_output_reload
parameter_list|(
name|chain
parameter_list|,
name|rl
parameter_list|,
name|j
parameter_list|)
name|struct
name|insn_chain
modifier|*
name|chain
decl_stmt|;
name|struct
name|reload
modifier|*
name|rl
decl_stmt|;
name|int
name|j
decl_stmt|;
block|{
name|rtx
name|note
decl_stmt|,
name|old
decl_stmt|;
name|rtx
name|insn
init|=
name|chain
operator|->
name|insn
decl_stmt|;
comment|/* If this is an output reload that stores something that is      not loaded in this same reload, see if we can eliminate a previous      store.  */
name|rtx
name|pseudo
init|=
name|rl
operator|->
name|out_reg
decl_stmt|;
if|if
condition|(
name|pseudo
operator|&&
name|GET_CODE
argument_list|(
name|pseudo
argument_list|)
operator|==
name|REG
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|rl
operator|->
name|in_reg
argument_list|,
name|pseudo
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|pseudo
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_last_reload_reg
index|[
name|REGNO
argument_list|(
name|pseudo
argument_list|)
index|]
condition|)
block|{
name|int
name|pseudo_no
init|=
name|REGNO
argument_list|(
name|pseudo
argument_list|)
decl_stmt|;
name|int
name|last_regno
init|=
name|REGNO
argument_list|(
name|reg_last_reload_reg
index|[
name|pseudo_no
index|]
argument_list|)
decl_stmt|;
comment|/* We don't need to test full validity of last_regno for 	 inherit here; we only want to know if the store actually 	 matches the pseudo.  */
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_reloaded_valid
argument_list|,
name|last_regno
argument_list|)
operator|&&
name|reg_reloaded_contents
index|[
name|last_regno
index|]
operator|==
name|pseudo_no
operator|&&
name|spill_reg_store
index|[
name|last_regno
index|]
operator|&&
name|rtx_equal_p
argument_list|(
name|pseudo
argument_list|,
name|spill_reg_stored_to
index|[
name|last_regno
index|]
argument_list|)
condition|)
name|delete_output_reload
argument_list|(
name|insn
argument_list|,
name|j
argument_list|,
name|last_regno
argument_list|)
expr_stmt|;
block|}
name|old
operator|=
name|rl
operator|->
name|out_reg
expr_stmt|;
if|if
condition|(
name|old
operator|==
literal|0
operator|||
name|rl
operator|->
name|reg_rtx
operator|==
name|old
operator|||
name|rl
operator|->
name|reg_rtx
operator|==
literal|0
condition|)
return|return;
comment|/* An output operand that dies right away does need a reload,      but need not be copied from it.  Show the new location in the      REG_UNUSED note.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|old
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|old
argument_list|)
operator|==
name|SCRATCH
operator|)
operator|&&
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_UNUSED
argument_list|,
name|old
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
operator|=
name|rl
operator|->
name|reg_rtx
expr_stmt|;
return|return;
block|}
comment|/* Likewise for a SUBREG of an operand that dies.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|old
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|old
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
literal|0
operator|!=
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_UNUSED
argument_list|,
name|SUBREG_REG
argument_list|(
name|old
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
operator|=
name|gen_lowpart_common
argument_list|(
name|GET_MODE
argument_list|(
name|old
argument_list|)
argument_list|,
name|rl
operator|->
name|reg_rtx
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|old
argument_list|)
operator|==
name|SCRATCH
condition|)
comment|/* If we aren't optimizing, there won't be a REG_UNUSED note,        but we don't want to make an output reload.  */
return|return;
comment|/* If is a JUMP_INSN, we can't support output reloads yet.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
name|abort
argument_list|()
expr_stmt|;
name|emit_output_reload_insns
argument_list|(
name|chain
argument_list|,
name|rld
operator|+
name|j
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output insns to reload values in and out of the chosen reload regs.  */
end_comment

begin_function
specifier|static
name|void
name|emit_reload_insns
parameter_list|(
name|chain
parameter_list|)
name|struct
name|insn_chain
modifier|*
name|chain
decl_stmt|;
block|{
name|rtx
name|insn
init|=
name|chain
operator|->
name|insn
decl_stmt|;
name|int
name|j
decl_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|reg_reloaded_died
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|reload_n_operands
condition|;
name|j
operator|++
control|)
name|input_reload_insns
index|[
name|j
index|]
operator|=
name|input_address_reload_insns
index|[
name|j
index|]
operator|=
name|inpaddr_address_reload_insns
index|[
name|j
index|]
operator|=
name|output_reload_insns
index|[
name|j
index|]
operator|=
name|output_address_reload_insns
index|[
name|j
index|]
operator|=
name|outaddr_address_reload_insns
index|[
name|j
index|]
operator|=
name|other_output_reload_insns
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
name|other_input_address_reload_insns
operator|=
literal|0
expr_stmt|;
name|other_input_reload_insns
operator|=
literal|0
expr_stmt|;
name|operand_reload_insns
operator|=
literal|0
expr_stmt|;
name|other_operand_reload_insns
operator|=
literal|0
expr_stmt|;
comment|/* Dump reloads into the dump file.  */
if|if
condition|(
name|rtl_dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"\nReloads for insn # %d\n"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|debug_reload_to_stream
argument_list|(
name|rtl_dump_file
argument_list|)
expr_stmt|;
block|}
comment|/* Now output the instructions to copy the data into and out of the      reload registers.  Do these in the order that the reloads were reported,      since reloads of base and index registers precede reloads of operands      and the operands may need the base and index registers reloaded.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_reloads
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|rld
index|[
name|j
index|]
operator|.
name|reg_rtx
operator|&&
name|REGNO
argument_list|(
name|rld
index|[
name|j
index|]
operator|.
name|reg_rtx
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|new_spill_reg_store
index|[
name|REGNO
argument_list|(
name|rld
index|[
name|j
index|]
operator|.
name|reg_rtx
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
name|do_input_reload
argument_list|(
name|chain
argument_list|,
name|rld
operator|+
name|j
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|do_output_reload
argument_list|(
name|chain
argument_list|,
name|rld
operator|+
name|j
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
comment|/* Now write all the insns we made for reloads in the order expected by      the allocation functions.  Prior to the insn being reloaded, we write      the following reloads:       RELOAD_FOR_OTHER_ADDRESS reloads for input addresses.       RELOAD_OTHER reloads.       For each operand, any RELOAD_FOR_INPADDR_ADDRESS reloads followed      by any RELOAD_FOR_INPUT_ADDRESS reloads followed by the      RELOAD_FOR_INPUT reload for the operand.       RELOAD_FOR_OPADDR_ADDRS reloads.       RELOAD_FOR_OPERAND_ADDRESS reloads.       After the insn being reloaded, we write the following:       For each operand, any RELOAD_FOR_OUTADDR_ADDRESS reloads followed      by any RELOAD_FOR_OUTPUT_ADDRESS reload followed by the      RELOAD_FOR_OUTPUT reload, followed by any RELOAD_OTHER output      reloads for the operand.  The RELOAD_OTHER output reloads are      output in descending order by reload number.  */
name|emit_insns_before
argument_list|(
name|other_input_address_reload_insns
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|emit_insns_before
argument_list|(
name|other_input_reload_insns
argument_list|,
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|reload_n_operands
condition|;
name|j
operator|++
control|)
block|{
name|emit_insns_before
argument_list|(
name|inpaddr_address_reload_insns
index|[
name|j
index|]
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|emit_insns_before
argument_list|(
name|input_address_reload_insns
index|[
name|j
index|]
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|emit_insns_before
argument_list|(
name|input_reload_insns
index|[
name|j
index|]
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
name|emit_insns_before
argument_list|(
name|other_operand_reload_insns
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|emit_insns_before
argument_list|(
name|operand_reload_insns
argument_list|,
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|reload_n_operands
condition|;
name|j
operator|++
control|)
block|{
name|rtx
name|x
init|=
name|emit_insns_after
argument_list|(
name|outaddr_address_reload_insns
index|[
name|j
index|]
argument_list|,
name|insn
argument_list|)
decl_stmt|;
name|x
operator|=
name|emit_insns_after
argument_list|(
name|output_address_reload_insns
index|[
name|j
index|]
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|x
operator|=
name|emit_insns_after
argument_list|(
name|output_reload_insns
index|[
name|j
index|]
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|emit_insns_after
argument_list|(
name|other_output_reload_insns
index|[
name|j
index|]
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
comment|/* For all the spill regs newly reloaded in this instruction,      record what they were reloaded from, so subsequent instructions      can inherit the reloads.       Update spill_reg_store for the reloads of this insn.      Copy the elements that were updated in the loop above.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_reloads
condition|;
name|j
operator|++
control|)
block|{
name|int
name|r
init|=
name|reload_order
index|[
name|j
index|]
decl_stmt|;
name|int
name|i
init|=
name|reload_spill_index
index|[
name|r
index|]
decl_stmt|;
comment|/* If this is a non-inherited input reload from a pseudo, we must 	 clear any memory of a previous store to the same pseudo.  Only do 	 something if there will not be an output reload for the pseudo 	 being reloaded.  */
if|if
condition|(
name|rld
index|[
name|r
index|]
operator|.
name|in_reg
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|reload_inherited
index|[
name|r
index|]
operator|||
name|reload_override_in
index|[
name|r
index|]
operator|)
condition|)
block|{
name|rtx
name|reg
init|=
name|rld
index|[
name|r
index|]
operator|.
name|in_reg
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
condition|)
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|!
name|reg_has_output_reload
index|[
name|REGNO
argument_list|(
name|reg
argument_list|)
index|]
condition|)
block|{
name|int
name|nregno
init|=
name|REGNO
argument_list|(
name|reg
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg_last_reload_reg
index|[
name|nregno
index|]
condition|)
block|{
name|int
name|last_regno
init|=
name|REGNO
argument_list|(
name|reg_last_reload_reg
index|[
name|nregno
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg_reloaded_contents
index|[
name|last_regno
index|]
operator|==
name|nregno
condition|)
name|spill_reg_store
index|[
name|last_regno
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
comment|/* I is nonneg if this reload used a register. 	 If rld[r].reg_rtx is 0, this is an optional reload 	 that we opted to ignore.  */
if|if
condition|(
name|i
operator|>=
literal|0
operator|&&
name|rld
index|[
name|r
index|]
operator|.
name|reg_rtx
operator|!=
literal|0
condition|)
block|{
name|int
name|nr
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|i
argument_list|,
name|GET_MODE
argument_list|(
name|rld
index|[
name|r
index|]
operator|.
name|reg_rtx
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|k
decl_stmt|;
name|int
name|part_reaches_end
init|=
literal|0
decl_stmt|;
name|int
name|all_reaches_end
init|=
literal|1
decl_stmt|;
comment|/* For a multi register reload, we need to check if all or part 	     of the value lives to the end.  */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|nr
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|reload_reg_reaches_end_p
argument_list|(
name|i
operator|+
name|k
argument_list|,
name|rld
index|[
name|r
index|]
operator|.
name|opnum
argument_list|,
name|rld
index|[
name|r
index|]
operator|.
name|when_needed
argument_list|)
condition|)
name|part_reaches_end
operator|=
literal|1
expr_stmt|;
else|else
name|all_reaches_end
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Ignore reloads that don't reach the end of the insn in 	     entirety.  */
if|if
condition|(
name|all_reaches_end
condition|)
block|{
comment|/* First, clear out memory of what used to be in this spill reg. 		 If consecutive registers are used, clear them all.  */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|nr
condition|;
name|k
operator|++
control|)
name|CLEAR_HARD_REG_BIT
argument_list|(
name|reg_reloaded_valid
argument_list|,
name|i
operator|+
name|k
argument_list|)
expr_stmt|;
comment|/* Maybe the spill reg contains a copy of reload_out.  */
if|if
condition|(
name|rld
index|[
name|r
index|]
operator|.
name|out
operator|!=
literal|0
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|rld
index|[
name|r
index|]
operator|.
name|out
argument_list|)
operator|==
name|REG
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
operator|||
operator|!
name|rld
index|[
name|r
index|]
operator|.
name|out_reg
endif|#
directive|endif
operator|||
name|GET_CODE
argument_list|(
name|rld
index|[
name|r
index|]
operator|.
name|out_reg
argument_list|)
operator|==
name|REG
operator|)
condition|)
block|{
name|rtx
name|out
init|=
operator|(
name|GET_CODE
argument_list|(
name|rld
index|[
name|r
index|]
operator|.
name|out
argument_list|)
operator|==
name|REG
condition|?
name|rld
index|[
name|r
index|]
operator|.
name|out
else|:
name|rld
index|[
name|r
index|]
operator|.
name|out_reg
condition|?
name|rld
index|[
name|r
index|]
operator|.
name|out_reg
comment|/* AUTO_INC */
else|:
name|XEXP
argument_list|(
name|rld
index|[
name|r
index|]
operator|.
name|in_reg
argument_list|,
literal|0
argument_list|)
operator|)
decl_stmt|;
name|int
name|nregno
init|=
name|REGNO
argument_list|(
name|out
argument_list|)
decl_stmt|;
name|int
name|nnr
init|=
operator|(
name|nregno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|?
literal|1
else|:
name|HARD_REGNO_NREGS
argument_list|(
name|nregno
argument_list|,
name|GET_MODE
argument_list|(
name|rld
index|[
name|r
index|]
operator|.
name|reg_rtx
argument_list|)
argument_list|)
operator|)
decl_stmt|;
name|spill_reg_store
index|[
name|i
index|]
operator|=
name|new_spill_reg_store
index|[
name|i
index|]
expr_stmt|;
name|spill_reg_stored_to
index|[
name|i
index|]
operator|=
name|out
expr_stmt|;
name|reg_last_reload_reg
index|[
name|nregno
index|]
operator|=
name|rld
index|[
name|r
index|]
operator|.
name|reg_rtx
expr_stmt|;
comment|/* If NREGNO is a hard register, it may occupy more than 		     one register.  If it does, say what is in the 		     rest of the registers assuming that both registers 		     agree on how many words the object takes.  If not, 		     invalidate the subsequent registers.  */
if|if
condition|(
name|nregno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
for|for
control|(
name|k
operator|=
literal|1
init|;
name|k
operator|<
name|nnr
condition|;
name|k
operator|++
control|)
name|reg_last_reload_reg
index|[
name|nregno
operator|+
name|k
index|]
operator|=
operator|(
name|nr
operator|==
name|nnr
condition|?
name|gen_rtx_REG
argument_list|(
name|reg_raw_mode
index|[
name|REGNO
argument_list|(
name|rld
index|[
name|r
index|]
operator|.
name|reg_rtx
argument_list|)
operator|+
name|k
index|]
argument_list|,
name|REGNO
argument_list|(
name|rld
index|[
name|r
index|]
operator|.
name|reg_rtx
argument_list|)
operator|+
name|k
argument_list|)
else|:
literal|0
operator|)
expr_stmt|;
comment|/* Now do the inverse operation.  */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|nr
condition|;
name|k
operator|++
control|)
block|{
name|CLEAR_HARD_REG_BIT
argument_list|(
name|reg_reloaded_dead
argument_list|,
name|i
operator|+
name|k
argument_list|)
expr_stmt|;
name|reg_reloaded_contents
index|[
name|i
operator|+
name|k
index|]
operator|=
operator|(
name|nregno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
name|nr
operator|!=
name|nnr
condition|?
name|nregno
else|:
name|nregno
operator|+
name|k
operator|)
expr_stmt|;
name|reg_reloaded_insn
index|[
name|i
operator|+
name|k
index|]
operator|=
name|insn
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|reg_reloaded_valid
argument_list|,
name|i
operator|+
name|k
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Maybe the spill reg contains a copy of reload_in.  Only do 		 something if there will not be an output reload for 		 the register being reloaded.  */
elseif|else
if|if
condition|(
name|rld
index|[
name|r
index|]
operator|.
name|out_reg
operator|==
literal|0
operator|&&
name|rld
index|[
name|r
index|]
operator|.
name|in
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|rld
index|[
name|r
index|]
operator|.
name|in
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|rld
index|[
name|r
index|]
operator|.
name|in
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|!
name|reg_has_output_reload
index|[
name|REGNO
argument_list|(
name|rld
index|[
name|r
index|]
operator|.
name|in
argument_list|)
index|]
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|rld
index|[
name|r
index|]
operator|.
name|in_reg
argument_list|)
operator|==
name|REG
operator|&&
operator|!
name|reg_has_output_reload
index|[
name|REGNO
argument_list|(
name|rld
index|[
name|r
index|]
operator|.
name|in_reg
argument_list|)
index|]
operator|)
operator|)
operator|&&
operator|!
name|reg_set_p
argument_list|(
name|rld
index|[
name|r
index|]
operator|.
name|reg_rtx
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|nregno
decl_stmt|;
name|int
name|nnr
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|rld
index|[
name|r
index|]
operator|.
name|in
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|rld
index|[
name|r
index|]
operator|.
name|in
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|nregno
operator|=
name|REGNO
argument_list|(
name|rld
index|[
name|r
index|]
operator|.
name|in
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|rld
index|[
name|r
index|]
operator|.
name|in_reg
argument_list|)
operator|==
name|REG
condition|)
name|nregno
operator|=
name|REGNO
argument_list|(
name|rld
index|[
name|r
index|]
operator|.
name|in_reg
argument_list|)
expr_stmt|;
else|else
name|nregno
operator|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|rld
index|[
name|r
index|]
operator|.
name|in_reg
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|nnr
operator|=
operator|(
name|nregno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|?
literal|1
else|:
name|HARD_REGNO_NREGS
argument_list|(
name|nregno
argument_list|,
name|GET_MODE
argument_list|(
name|rld
index|[
name|r
index|]
operator|.
name|reg_rtx
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|reg_last_reload_reg
index|[
name|nregno
index|]
operator|=
name|rld
index|[
name|r
index|]
operator|.
name|reg_rtx
expr_stmt|;
if|if
condition|(
name|nregno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
for|for
control|(
name|k
operator|=
literal|1
init|;
name|k
operator|<
name|nnr
condition|;
name|k
operator|++
control|)
name|reg_last_reload_reg
index|[
name|nregno
operator|+
name|k
index|]
operator|=
operator|(
name|nr
operator|==
name|nnr
condition|?
name|gen_rtx_REG
argument_list|(
name|reg_raw_mode
index|[
name|REGNO
argument_list|(
name|rld
index|[
name|r
index|]
operator|.
name|reg_rtx
argument_list|)
operator|+
name|k
index|]
argument_list|,
name|REGNO
argument_list|(
name|rld
index|[
name|r
index|]
operator|.
name|reg_rtx
argument_list|)
operator|+
name|k
argument_list|)
else|:
literal|0
operator|)
expr_stmt|;
comment|/* Unless we inherited this reload, show we haven't 		     recently done a store. 		     Previous stores of inherited auto_inc expressions 		     also have to be discarded.  */
if|if
condition|(
operator|!
name|reload_inherited
index|[
name|r
index|]
operator|||
operator|(
name|rld
index|[
name|r
index|]
operator|.
name|out
operator|&&
operator|!
name|rld
index|[
name|r
index|]
operator|.
name|out_reg
operator|)
condition|)
name|spill_reg_store
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|nr
condition|;
name|k
operator|++
control|)
block|{
name|CLEAR_HARD_REG_BIT
argument_list|(
name|reg_reloaded_dead
argument_list|,
name|i
operator|+
name|k
argument_list|)
expr_stmt|;
name|reg_reloaded_contents
index|[
name|i
operator|+
name|k
index|]
operator|=
operator|(
name|nregno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
name|nr
operator|!=
name|nnr
condition|?
name|nregno
else|:
name|nregno
operator|+
name|k
operator|)
expr_stmt|;
name|reg_reloaded_insn
index|[
name|i
operator|+
name|k
index|]
operator|=
name|insn
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|reg_reloaded_valid
argument_list|,
name|i
operator|+
name|k
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* However, if part of the reload reaches the end, then we must 	     invalidate the old info for the part that survives to the end.  */
elseif|else
if|if
condition|(
name|part_reaches_end
condition|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|nr
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|reload_reg_reaches_end_p
argument_list|(
name|i
operator|+
name|k
argument_list|,
name|rld
index|[
name|r
index|]
operator|.
name|opnum
argument_list|,
name|rld
index|[
name|r
index|]
operator|.
name|when_needed
argument_list|)
condition|)
name|CLEAR_HARD_REG_BIT
argument_list|(
name|reg_reloaded_valid
argument_list|,
name|i
operator|+
name|k
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* The following if-statement was #if 0'd in 1.34 (or before...). 	 It's reenabled in 1.35 because supposedly nothing else 	 deals with this problem.  */
comment|/* If a register gets output-reloaded from a non-spill register, 	 that invalidates any previous reloaded copy of it. 	 But forget_old_reloads_1 won't get to see it, because 	 it thinks only about the original insn.  So invalidate it here.  */
if|if
condition|(
name|i
operator|<
literal|0
operator|&&
name|rld
index|[
name|r
index|]
operator|.
name|out
operator|!=
literal|0
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|rld
index|[
name|r
index|]
operator|.
name|out
argument_list|)
operator|==
name|REG
operator|||
operator|(
name|GET_CODE
argument_list|(
name|rld
index|[
name|r
index|]
operator|.
name|out
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|rld
index|[
name|r
index|]
operator|.
name|out_reg
argument_list|)
operator|==
name|REG
operator|)
operator|)
condition|)
block|{
name|rtx
name|out
init|=
operator|(
name|GET_CODE
argument_list|(
name|rld
index|[
name|r
index|]
operator|.
name|out
argument_list|)
operator|==
name|REG
condition|?
name|rld
index|[
name|r
index|]
operator|.
name|out
else|:
name|rld
index|[
name|r
index|]
operator|.
name|out_reg
operator|)
decl_stmt|;
name|int
name|nregno
init|=
name|REGNO
argument_list|(
name|out
argument_list|)
decl_stmt|;
if|if
condition|(
name|nregno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|rtx
name|src_reg
decl_stmt|,
name|store_insn
init|=
name|NULL_RTX
decl_stmt|;
name|reg_last_reload_reg
index|[
name|nregno
index|]
operator|=
literal|0
expr_stmt|;
comment|/* If we can find a hard register that is stored, record 		 the storing insn so that we may delete this insn with 		 delete_output_reload.  */
name|src_reg
operator|=
name|rld
index|[
name|r
index|]
operator|.
name|reg_rtx
expr_stmt|;
comment|/* If this is an optional reload, try to find the source reg 		 from an input reload.  */
if|if
condition|(
operator|!
name|src_reg
condition|)
block|{
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|set
operator|&&
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|==
name|rld
index|[
name|r
index|]
operator|.
name|out
condition|)
block|{
name|int
name|k
decl_stmt|;
name|src_reg
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|store_insn
operator|=
name|insn
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|n_reloads
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|rld
index|[
name|k
index|]
operator|.
name|in
operator|==
name|src_reg
condition|)
block|{
name|src_reg
operator|=
name|rld
index|[
name|k
index|]
operator|.
name|reg_rtx
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
else|else
name|store_insn
operator|=
name|new_spill_reg_store
index|[
name|REGNO
argument_list|(
name|src_reg
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|src_reg
operator|&&
name|GET_CODE
argument_list|(
name|src_reg
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|src_reg
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|src_regno
init|=
name|REGNO
argument_list|(
name|src_reg
argument_list|)
decl_stmt|;
name|int
name|nr
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|src_regno
argument_list|,
name|rld
index|[
name|r
index|]
operator|.
name|mode
argument_list|)
decl_stmt|;
comment|/* The place where to find a death note varies with 		     PRESERVE_DEATH_INFO_REGNO_P .  The condition is not 		     necessarily checked exactly in the code that moves 		     notes, so just check both locations.  */
name|rtx
name|note
init|=
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|src_regno
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|note
operator|&&
name|store_insn
condition|)
name|note
operator|=
name|find_regno_note
argument_list|(
name|store_insn
argument_list|,
name|REG_DEAD
argument_list|,
name|src_regno
argument_list|)
expr_stmt|;
while|while
condition|(
name|nr
operator|--
operator|>
literal|0
condition|)
block|{
name|spill_reg_store
index|[
name|src_regno
operator|+
name|nr
index|]
operator|=
name|store_insn
expr_stmt|;
name|spill_reg_stored_to
index|[
name|src_regno
operator|+
name|nr
index|]
operator|=
name|out
expr_stmt|;
name|reg_reloaded_contents
index|[
name|src_regno
operator|+
name|nr
index|]
operator|=
name|nregno
expr_stmt|;
name|reg_reloaded_insn
index|[
name|src_regno
operator|+
name|nr
index|]
operator|=
name|store_insn
expr_stmt|;
name|CLEAR_HARD_REG_BIT
argument_list|(
name|reg_reloaded_dead
argument_list|,
name|src_regno
operator|+
name|nr
argument_list|)
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|reg_reloaded_valid
argument_list|,
name|src_regno
operator|+
name|nr
argument_list|)
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|reg_is_output_reload
argument_list|,
name|src_regno
operator|+
name|nr
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|reg_reloaded_died
argument_list|,
name|src_regno
argument_list|)
expr_stmt|;
else|else
name|CLEAR_HARD_REG_BIT
argument_list|(
name|reg_reloaded_died
argument_list|,
name|src_regno
argument_list|)
expr_stmt|;
block|}
name|reg_last_reload_reg
index|[
name|nregno
index|]
operator|=
name|src_reg
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|num_regs
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|nregno
argument_list|,
name|GET_MODE
argument_list|(
name|rld
index|[
name|r
index|]
operator|.
name|out
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|num_regs
operator|--
operator|>
literal|0
condition|)
name|reg_last_reload_reg
index|[
name|nregno
operator|+
name|num_regs
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
name|IOR_HARD_REG_SET
argument_list|(
name|reg_reloaded_dead
argument_list|,
name|reg_reloaded_died
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit code to perform a reload from IN (which may be a reload register) to    OUT (which may also be a reload register).  IN or OUT is from operand    OPNUM with reload type TYPE.     Returns first insn emitted.  */
end_comment

begin_function
name|rtx
name|gen_reload
parameter_list|(
name|out
parameter_list|,
name|in
parameter_list|,
name|opnum
parameter_list|,
name|type
parameter_list|)
name|rtx
name|out
decl_stmt|;
name|rtx
name|in
decl_stmt|;
name|int
name|opnum
decl_stmt|;
name|enum
name|reload_type
name|type
decl_stmt|;
block|{
name|rtx
name|last
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
comment|/* If IN is a paradoxical SUBREG, remove it and try to put the      opposite SUBREG on OUT.  Likewise for a paradoxical SUBREG on OUT.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|in
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|tem
operator|=
name|gen_lowpart_common
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|)
argument_list|,
name|out
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|in
operator|=
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
operator|,
name|out
operator|=
name|tem
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|out
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|out
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|out
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|tem
operator|=
name|gen_lowpart_common
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|out
argument_list|)
argument_list|)
argument_list|,
name|in
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|out
operator|=
name|SUBREG_REG
argument_list|(
name|out
argument_list|)
operator|,
name|in
operator|=
name|tem
expr_stmt|;
comment|/* How to do this reload can get quite tricky.  Normally, we are being      asked to reload a simple operand, such as a MEM, a constant, or a pseudo      register that didn't get a hard register.  In that case we can just      call emit_move_insn.       We can also be asked to reload a PLUS that adds a register or a MEM to      another register, constant or MEM.  This can occur during frame pointer      elimination and while reloading addresses.  This case is handled by      trying to emit a single insn to perform the add.  If it is not valid,      we use a two insn sequence.       Finally, we could be called to handle an 'o' constraint by putting      an address into a register.  In that case, we first try to do this      with a named pattern of "reload_load_address".  If no such pattern      exists, we just emit a SET insn and hope for the best (it will normally      be valid on machines that use 'o').       This entire process is made complex because reload will never      process the insns we generate here and so we must ensure that      they will fit their constraints and also by the fact that parts of      IN might be being reloaded separately and replaced with spill registers.      Because of this, we are, in some sense, just guessing the right approach      here.  The one listed above seems to work.       ??? At some point, this whole thing needs to be rethought.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|PLUS
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|in
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|in
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|in
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|in
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|in
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|||
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|in
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|in
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|MEM
operator|)
condition|)
block|{
comment|/* We need to compute the sum of a register or a MEM and another 	 register, constant, or MEM, and put it into the reload 	 register.  The best possible way of doing this is if the machine 	 has a three-operand ADD insn that accepts the required operands.  	 The simplest approach is to try to generate such an insn and see if it 	 is recognized and matches its constraints.  If so, it can be used.  	 It might be better not to actually emit the insn unless it is valid, 	 but we need to pass the insn as an operand to `recog' and 	 `extract_insn' and it is simpler to emit and then delete the insn if 	 not valid than to dummy things up.  */
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|,
name|tem
decl_stmt|,
name|insn
decl_stmt|;
name|int
name|code
decl_stmt|;
name|op0
operator|=
name|find_replacement
argument_list|(
operator|&
name|XEXP
argument_list|(
name|in
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|op1
operator|=
name|find_replacement
argument_list|(
operator|&
name|XEXP
argument_list|(
name|in
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Since constraint checking is strict, commutativity won't be 	 checked, so we need to do that here to avoid spurious failure 	 if the add instruction is two-address and the second operand 	 of the add is the same as the reload reg, which is frequently 	 the case.  If the insn would be A = B + A, rearrange it so 	 it will be A = A + B as constrain_operands expects.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|in
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|out
argument_list|)
operator|==
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|in
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|tem
operator|=
name|op0
operator|,
name|op0
operator|=
name|op1
operator|,
name|op1
operator|=
name|tem
expr_stmt|;
if|if
condition|(
name|op0
operator|!=
name|XEXP
argument_list|(
name|in
argument_list|,
literal|0
argument_list|)
operator|||
name|op1
operator|!=
name|XEXP
argument_list|(
name|in
argument_list|,
literal|1
argument_list|)
condition|)
name|in
operator|=
name|gen_rtx_PLUS
argument_list|(
name|GET_MODE
argument_list|(
name|in
argument_list|)
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|out
argument_list|,
name|in
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|recog_memoized
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|>=
literal|0
condition|)
block|{
name|extract_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* We want constrain operands to treat this insn strictly in 	     its validity determination, i.e., the way it would after reload 	     has completed.  */
if|if
condition|(
name|constrain_operands
argument_list|(
literal|1
argument_list|)
condition|)
return|return
name|insn
return|;
block|}
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
comment|/* If that failed, we must use a conservative two-insn sequence.  	 Use a move to copy one operand into the reload register.  Prefer 	 to reload a constant, MEM or pseudo since the move patterns can 	 handle an arbitrary operand.  If OP1 is not a constant, MEM or 	 pseudo and OP1 is not a valid operand for an add instruction, then 	 reload OP1.  	 After reloading one of the operands into the reload register, add 	 the reload register to the output register.  	 If there is another way to do this for a specific machine, a 	 DEFINE_PEEPHOLE should be specified that recognizes the sequence 	 we emit below.  */
name|code
operator|=
operator|(
name|int
operator|)
name|add_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|GET_MODE
argument_list|(
name|out
argument_list|)
index|]
operator|.
name|insn_code
expr_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op1
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|MEM
operator|||
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|SUBREG
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|op1
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|||
operator|(
name|code
operator|!=
name|CODE_FOR_nothing
operator|&&
operator|!
operator|(
operator|(
operator|*
name|insn_data
index|[
name|code
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|insn_data
index|[
name|code
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
operator|)
operator|)
operator|)
condition|)
name|tem
operator|=
name|op0
operator|,
name|op0
operator|=
name|op1
operator|,
name|op1
operator|=
name|tem
expr_stmt|;
name|gen_reload
argument_list|(
name|out
argument_list|,
name|op0
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* If OP0 and OP1 are the same, we can use OUT for OP1. 	 This fixes a problem on the 32K where the stack pointer cannot 	 be used as an operand of an add insn.  */
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
condition|)
name|op1
operator|=
name|out
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_add2_insn
argument_list|(
name|out
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If that failed, copy the address register to the reload register. 	 Then add the constant to the reload register.  */
name|code
operator|=
name|recog_memoized
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|>=
literal|0
condition|)
block|{
name|extract_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* We want constrain operands to treat this insn strictly in 	     its validity determination, i.e., the way it would after reload 	     has completed.  */
if|if
condition|(
name|constrain_operands
argument_list|(
literal|1
argument_list|)
condition|)
block|{
comment|/* Add a REG_EQUIV note so that find_equiv_reg can find it.  */
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_EQUIV
argument_list|,
name|in
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|insn
return|;
block|}
block|}
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
name|gen_reload
argument_list|(
name|out
argument_list|,
name|op1
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_add2_insn
argument_list|(
name|out
argument_list|,
name|op0
argument_list|)
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_EQUIV
argument_list|,
name|in
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SECONDARY_MEMORY_NEEDED
comment|/* If we need a memory location to do the move, do it that way.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|in
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|GET_CODE
argument_list|(
name|out
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|out
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|SECONDARY_MEMORY_NEEDED
argument_list|(
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|in
argument_list|)
argument_list|)
argument_list|,
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|out
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|out
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Get the memory to use and rewrite both registers to its mode.  */
name|rtx
name|loc
init|=
name|get_secondary_mem
argument_list|(
name|in
argument_list|,
name|GET_MODE
argument_list|(
name|out
argument_list|)
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|loc
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|out
argument_list|)
condition|)
name|out
operator|=
name|gen_rtx_REG
argument_list|(
name|GET_MODE
argument_list|(
name|loc
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|out
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|loc
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|in
argument_list|)
condition|)
name|in
operator|=
name|gen_rtx_REG
argument_list|(
name|GET_MODE
argument_list|(
name|loc
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|in
argument_list|)
argument_list|)
expr_stmt|;
name|gen_reload
argument_list|(
name|loc
argument_list|,
name|in
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|gen_reload
argument_list|(
name|out
argument_list|,
name|loc
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* If IN is a simple operand, use gen_move_insn.  */
elseif|else
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|in
argument_list|)
argument_list|)
operator|==
literal|'o'
operator|||
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|SUBREG
condition|)
name|emit_insn
argument_list|(
name|gen_move_insn
argument_list|(
name|out
argument_list|,
name|in
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_reload_load_address
elseif|else
if|if
condition|(
name|HAVE_reload_load_address
condition|)
name|emit_insn
argument_list|(
name|gen_reload_load_address
argument_list|(
name|out
argument_list|,
name|in
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Otherwise, just write (set OUT IN) and hope for the best.  */
else|else
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|out
argument_list|,
name|in
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Return the first insn emitted.      We can not just return get_last_insn, because there may have      been multiple instructions emitted.  Also note that gen_move_insn may      emit more than one insn itself, so we can not assume that there is one      insn emitted per emit_insn_before call.  */
return|return
name|last
condition|?
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
else|:
name|get_insns
argument_list|()
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Delete a previously made output-reload whose result we now believe    is not needed.  First we double-check.     INSN is the insn now being processed.    LAST_RELOAD_REG is the hard register number for which we want to delete    the last output reload.    J is the reload-number that originally used REG.  The caller has made    certain that reload J doesn't use REG any longer for input.  */
end_comment

begin_function
specifier|static
name|void
name|delete_output_reload
parameter_list|(
name|insn
parameter_list|,
name|j
parameter_list|,
name|last_reload_reg
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|int
name|j
decl_stmt|;
name|int
name|last_reload_reg
decl_stmt|;
block|{
name|rtx
name|output_reload_insn
init|=
name|spill_reg_store
index|[
name|last_reload_reg
index|]
decl_stmt|;
name|rtx
name|reg
init|=
name|spill_reg_stored_to
index|[
name|last_reload_reg
index|]
decl_stmt|;
name|int
name|k
decl_stmt|;
name|int
name|n_occurrences
decl_stmt|;
name|int
name|n_inherited
init|=
literal|0
decl_stmt|;
name|rtx
name|i1
decl_stmt|;
name|rtx
name|substed
decl_stmt|;
comment|/* Get the raw pseudo-register referred to.  */
while|while
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
condition|)
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|substed
operator|=
name|reg_equiv_memory_loc
index|[
name|REGNO
argument_list|(
name|reg
argument_list|)
index|]
expr_stmt|;
comment|/* This is unsafe if the operand occurs more often in the current      insn than it is inherited.  */
for|for
control|(
name|k
operator|=
name|n_reloads
operator|-
literal|1
init|;
name|k
operator|>=
literal|0
condition|;
name|k
operator|--
control|)
block|{
name|rtx
name|reg2
init|=
name|rld
index|[
name|k
index|]
operator|.
name|in
decl_stmt|;
if|if
condition|(
operator|!
name|reg2
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg2
argument_list|)
operator|==
name|MEM
operator|||
name|reload_override_in
index|[
name|k
index|]
condition|)
name|reg2
operator|=
name|rld
index|[
name|k
index|]
operator|.
name|in_reg
expr_stmt|;
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
if|if
condition|(
name|rld
index|[
name|k
index|]
operator|.
name|out
operator|&&
operator|!
name|rld
index|[
name|k
index|]
operator|.
name|out_reg
condition|)
name|reg2
operator|=
name|XEXP
argument_list|(
name|rld
index|[
name|k
index|]
operator|.
name|in_reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|GET_CODE
argument_list|(
name|reg2
argument_list|)
operator|==
name|SUBREG
condition|)
name|reg2
operator|=
name|SUBREG_REG
argument_list|(
name|reg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|reg2
argument_list|,
name|reg
argument_list|)
condition|)
block|{
if|if
condition|(
name|reload_inherited
index|[
name|k
index|]
operator|||
name|reload_override_in
index|[
name|k
index|]
operator|||
name|k
operator|==
name|j
condition|)
block|{
name|n_inherited
operator|++
expr_stmt|;
name|reg2
operator|=
name|rld
index|[
name|k
index|]
operator|.
name|out_reg
expr_stmt|;
if|if
condition|(
operator|!
name|reg2
condition|)
continue|continue;
while|while
condition|(
name|GET_CODE
argument_list|(
name|reg2
argument_list|)
operator|==
name|SUBREG
condition|)
name|reg2
operator|=
name|XEXP
argument_list|(
name|reg2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|reg2
argument_list|,
name|reg
argument_list|)
condition|)
name|n_inherited
operator|++
expr_stmt|;
block|}
else|else
return|return;
block|}
block|}
name|n_occurrences
operator|=
name|count_occurrences
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|substed
condition|)
name|n_occurrences
operator|+=
name|count_occurrences
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|eliminate_regs
argument_list|(
name|substed
argument_list|,
literal|0
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_occurrences
operator|>
name|n_inherited
condition|)
return|return;
comment|/* If the pseudo-reg we are reloading is no longer referenced      anywhere between the store into it and here,      and no jumps or labels intervene, then the value can get      here through the reload reg alone.      Otherwise, give up--return.  */
for|for
control|(
name|i1
operator|=
name|NEXT_INSN
argument_list|(
name|output_reload_insn
argument_list|)
init|;
name|i1
operator|!=
name|insn
condition|;
name|i1
operator|=
name|NEXT_INSN
argument_list|(
name|i1
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|i1
argument_list|)
operator|==
name|CODE_LABEL
operator|||
name|GET_CODE
argument_list|(
name|i1
argument_list|)
operator|==
name|JUMP_INSN
condition|)
return|return;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|i1
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|i1
argument_list|)
operator|==
name|CALL_INSN
operator|)
operator|&&
name|reg_mentioned_p
argument_list|(
name|reg
argument_list|,
name|PATTERN
argument_list|(
name|i1
argument_list|)
argument_list|)
condition|)
block|{
comment|/* If this is USE in front of INSN, we only have to check that 	     there are no more references than accounted for by inheritance.  */
while|while
condition|(
name|GET_CODE
argument_list|(
name|i1
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|i1
argument_list|)
argument_list|)
operator|==
name|USE
condition|)
block|{
name|n_occurrences
operator|+=
name|rtx_equal_p
argument_list|(
name|reg
argument_list|,
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|i1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
literal|0
expr_stmt|;
name|i1
operator|=
name|NEXT_INSN
argument_list|(
name|i1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n_occurrences
operator|<=
name|n_inherited
operator|&&
name|i1
operator|==
name|insn
condition|)
break|break;
return|return;
block|}
block|}
comment|/* We will be deleting the insn.  Remove the spill reg information.  */
for|for
control|(
name|k
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|last_reload_reg
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
init|;
name|k
operator|--
operator|>
literal|0
condition|;
control|)
block|{
name|spill_reg_store
index|[
name|last_reload_reg
operator|+
name|k
index|]
operator|=
literal|0
expr_stmt|;
name|spill_reg_stored_to
index|[
name|last_reload_reg
operator|+
name|k
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* The caller has already checked that REG dies or is set in INSN.      It has also checked that we are optimizing, and thus some      inaccurancies in the debugging information are acceptable.      So we could just delete output_reload_insn.  But in some cases      we can improve the debugging information without sacrificing      optimization - maybe even improving the code: See if the pseudo      reg has been completely replaced with reload regs.  If so, delete      the store insn and forget we had a stack slot for the pseudo.  */
if|if
condition|(
name|rld
index|[
name|j
index|]
operator|.
name|out
operator|!=
name|rld
index|[
name|j
index|]
operator|.
name|in
operator|&&
name|REG_N_DEATHS
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|==
literal|1
operator|&&
name|REG_N_SETS
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|==
literal|1
operator|&&
name|REG_BASIC_BLOCK
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|>=
literal|0
operator|&&
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|i2
decl_stmt|;
comment|/* We know that it was used only between here and the beginning of 	 the current basic block.  (We also know that the last use before 	 INSN was the output reload we are thinking of deleting, but never 	 mind that.)  Search that range; see if any ref remains.  */
for|for
control|(
name|i2
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
init|;
name|i2
condition|;
name|i2
operator|=
name|PREV_INSN
argument_list|(
name|i2
argument_list|)
control|)
block|{
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|i2
argument_list|)
decl_stmt|;
comment|/* Uses which just store in the pseudo don't count, 	     since if they are the only uses, they are dead.  */
if|if
condition|(
name|set
operator|!=
literal|0
operator|&&
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|==
name|reg
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|i2
argument_list|)
operator|==
name|CODE_LABEL
operator|||
name|GET_CODE
argument_list|(
name|i2
argument_list|)
operator|==
name|JUMP_INSN
condition|)
break|break;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|i2
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|i2
argument_list|)
operator|==
name|CALL_INSN
operator|)
operator|&&
name|reg_mentioned_p
argument_list|(
name|reg
argument_list|,
name|PATTERN
argument_list|(
name|i2
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Some other ref remains; just delete the output reload we 		 know to be dead.  */
name|delete_address_reloads
argument_list|(
name|output_reload_insn
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|output_reload_insn
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Delete the now-dead stores into this pseudo.  Note that this 	 loop also takes care of deleting output_reload_insn.  */
for|for
control|(
name|i2
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
init|;
name|i2
condition|;
name|i2
operator|=
name|PREV_INSN
argument_list|(
name|i2
argument_list|)
control|)
block|{
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|i2
argument_list|)
decl_stmt|;
if|if
condition|(
name|set
operator|!=
literal|0
operator|&&
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|==
name|reg
condition|)
block|{
name|delete_address_reloads
argument_list|(
name|i2
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|i2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|i2
argument_list|)
operator|==
name|CODE_LABEL
operator|||
name|GET_CODE
argument_list|(
name|i2
argument_list|)
operator|==
name|JUMP_INSN
condition|)
break|break;
block|}
comment|/* For the debugging info, say the pseudo lives in this reload reg.  */
name|reg_renumber
index|[
name|REGNO
argument_list|(
name|reg
argument_list|)
index|]
operator|=
name|REGNO
argument_list|(
name|rld
index|[
name|j
index|]
operator|.
name|reg_rtx
argument_list|)
expr_stmt|;
name|alter_reg
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|delete_address_reloads
argument_list|(
name|output_reload_insn
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|output_reload_insn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* We are going to delete DEAD_INSN.  Recursively delete loads of    reload registers used in DEAD_INSN that are not used till CURRENT_INSN.    CURRENT_INSN is being reloaded, so we have to check its reloads too.  */
end_comment

begin_function
specifier|static
name|void
name|delete_address_reloads
parameter_list|(
name|dead_insn
parameter_list|,
name|current_insn
parameter_list|)
name|rtx
name|dead_insn
decl_stmt|,
name|current_insn
decl_stmt|;
block|{
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|dead_insn
argument_list|)
decl_stmt|;
name|rtx
name|set2
decl_stmt|,
name|dst
decl_stmt|,
name|prev
decl_stmt|,
name|next
decl_stmt|;
if|if
condition|(
name|set
condition|)
block|{
name|rtx
name|dst
init|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|MEM
condition|)
name|delete_address_reloads_1
argument_list|(
name|dead_insn
argument_list|,
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
argument_list|,
name|current_insn
argument_list|)
expr_stmt|;
block|}
comment|/* If we deleted the store from a reloaded post_{in,de}c expression,      we can delete the matching adds.  */
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|dead_insn
argument_list|)
expr_stmt|;
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|dead_insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prev
operator|||
operator|!
name|next
condition|)
return|return;
name|set
operator|=
name|single_set
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|set2
operator|=
name|single_set
argument_list|(
name|prev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set
operator|||
operator|!
name|set2
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|!=
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set2
argument_list|)
argument_list|)
operator|!=
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set2
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return;
name|dst
operator|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|dst
argument_list|,
name|SET_DEST
argument_list|(
name|set2
argument_list|)
argument_list|)
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|dst
argument_list|,
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|dst
argument_list|,
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set2
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set2
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
return|return;
name|delete_related_insns
argument_list|(
name|prev
argument_list|)
expr_stmt|;
name|delete_related_insns
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Subfunction of delete_address_reloads: process registers found in X.  */
end_comment

begin_function
specifier|static
name|void
name|delete_address_reloads_1
parameter_list|(
name|dead_insn
parameter_list|,
name|x
parameter_list|,
name|current_insn
parameter_list|)
name|rtx
name|dead_insn
decl_stmt|,
name|x
decl_stmt|,
name|current_insn
decl_stmt|;
block|{
name|rtx
name|prev
decl_stmt|,
name|set
decl_stmt|,
name|dst
decl_stmt|,
name|i2
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|!=
name|REG
condition|)
block|{
specifier|const
name|char
modifier|*
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|delete_address_reloads_1
argument_list|(
name|dead_insn
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|current_insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|delete_address_reloads_1
argument_list|(
name|dead_insn
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|current_insn
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
if|if
condition|(
name|spill_reg_order
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
operator|<
literal|0
condition|)
return|return;
comment|/* Scan backwards for the insn that sets x.  This might be a way back due      to inheritance.  */
for|for
control|(
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|dead_insn
argument_list|)
init|;
name|prev
condition|;
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|prev
argument_list|)
control|)
block|{
name|code
operator|=
name|GET_CODE
argument_list|(
name|prev
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|CODE_LABEL
operator|||
name|code
operator|==
name|JUMP_INSN
condition|)
return|return;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
literal|'i'
condition|)
continue|continue;
if|if
condition|(
name|reg_set_p
argument_list|(
name|x
argument_list|,
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|)
condition|)
break|break;
if|if
condition|(
name|reg_referenced_p
argument_list|(
name|x
argument_list|,
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|)
condition|)
return|return;
block|}
if|if
condition|(
operator|!
name|prev
operator|||
name|INSN_UID
argument_list|(
name|prev
argument_list|)
operator|<
name|reload_first_uid
condition|)
return|return;
comment|/* Check that PREV only sets the reload register.  */
name|set
operator|=
name|single_set
argument_list|(
name|prev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set
condition|)
return|return;
name|dst
operator|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|!=
name|REG
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|dst
argument_list|,
name|x
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|reg_set_p
argument_list|(
name|dst
argument_list|,
name|PATTERN
argument_list|(
name|dead_insn
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Check if DST was used in a later insn - 	 it might have been inherited.  */
for|for
control|(
name|i2
operator|=
name|NEXT_INSN
argument_list|(
name|dead_insn
argument_list|)
init|;
name|i2
condition|;
name|i2
operator|=
name|NEXT_INSN
argument_list|(
name|i2
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|i2
argument_list|)
operator|==
name|CODE_LABEL
condition|)
break|break;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|i2
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|reg_referenced_p
argument_list|(
name|dst
argument_list|,
name|PATTERN
argument_list|(
name|i2
argument_list|)
argument_list|)
condition|)
block|{
comment|/* If there is a reference to the register in the current insn, 		 it might be loaded in a non-inherited reload.  If no other 		 reload uses it, that means the register is set before 		 referenced.  */
if|if
condition|(
name|i2
operator|==
name|current_insn
condition|)
block|{
for|for
control|(
name|j
operator|=
name|n_reloads
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
operator|(
name|rld
index|[
name|j
index|]
operator|.
name|reg_rtx
operator|==
name|dst
operator|&&
name|reload_inherited
index|[
name|j
index|]
operator|)
operator|||
name|reload_override_in
index|[
name|j
index|]
operator|==
name|dst
condition|)
return|return;
for|for
control|(
name|j
operator|=
name|n_reloads
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|rld
index|[
name|j
index|]
operator|.
name|in
operator|&&
name|rld
index|[
name|j
index|]
operator|.
name|reg_rtx
operator|==
name|dst
condition|)
break|break;
if|if
condition|(
name|j
operator|>=
literal|0
condition|)
break|break;
block|}
return|return;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|i2
argument_list|)
operator|==
name|JUMP_INSN
condition|)
break|break;
comment|/* If DST is still live at CURRENT_INSN, check if it is used for 	     any reload.  Note that even if CURRENT_INSN sets DST, we still 	     have to check the reloads.  */
if|if
condition|(
name|i2
operator|==
name|current_insn
condition|)
block|{
for|for
control|(
name|j
operator|=
name|n_reloads
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
operator|(
name|rld
index|[
name|j
index|]
operator|.
name|reg_rtx
operator|==
name|dst
operator|&&
name|reload_inherited
index|[
name|j
index|]
operator|)
operator|||
name|reload_override_in
index|[
name|j
index|]
operator|==
name|dst
condition|)
return|return;
comment|/* ??? We can't finish the loop here, because dst might be 		 allocated to a pseudo in this block if no reload in this 		 block needs any of the clsses containing DST - see 		 spill_hard_reg.  There is no easy way to tell this, so we 		 have to scan till the end of the basic block.  */
block|}
if|if
condition|(
name|reg_set_p
argument_list|(
name|dst
argument_list|,
name|PATTERN
argument_list|(
name|i2
argument_list|)
argument_list|)
condition|)
break|break;
block|}
block|}
name|delete_address_reloads_1
argument_list|(
name|prev
argument_list|,
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|current_insn
argument_list|)
expr_stmt|;
name|reg_reloaded_contents
index|[
name|REGNO
argument_list|(
name|dst
argument_list|)
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|delete_insn
argument_list|(
name|prev
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output reload-insns to reload VALUE into RELOADREG.    VALUE is an autoincrement or autodecrement RTX whose operand    is a register or memory location;    so reloading involves incrementing that location.    IN is either identical to VALUE, or some cheaper place to reload from.     INC_AMOUNT is the number to increment or decrement by (always positive).    This cannot be deduced from VALUE.     Return the instruction that stores into RELOADREG.  */
end_comment

begin_function
specifier|static
name|rtx
name|inc_for_reload
parameter_list|(
name|reloadreg
parameter_list|,
name|in
parameter_list|,
name|value
parameter_list|,
name|inc_amount
parameter_list|)
name|rtx
name|reloadreg
decl_stmt|;
name|rtx
name|in
decl_stmt|,
name|value
decl_stmt|;
name|int
name|inc_amount
decl_stmt|;
block|{
comment|/* REG or MEM to be copied and incremented.  */
name|rtx
name|incloc
init|=
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* Nonzero if increment after copying.  */
name|int
name|post
init|=
operator|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|POST_DEC
operator|||
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|POST_INC
operator|)
decl_stmt|;
name|rtx
name|last
decl_stmt|;
name|rtx
name|inc
decl_stmt|;
name|rtx
name|add_insn
decl_stmt|;
name|int
name|code
decl_stmt|;
name|rtx
name|store
decl_stmt|;
name|rtx
name|real_in
init|=
name|in
operator|==
name|value
condition|?
name|XEXP
argument_list|(
name|in
argument_list|,
literal|0
argument_list|)
else|:
name|in
decl_stmt|;
comment|/* No hard register is equivalent to this register after      inc/dec operation.  If REG_LAST_RELOAD_REG were non-zero,      we could inc/dec that register as well (maybe even using it for      the source), but I'm not sure it's worth worrying about.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|incloc
argument_list|)
operator|==
name|REG
condition|)
name|reg_last_reload_reg
index|[
name|REGNO
argument_list|(
name|incloc
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|PRE_DEC
operator|||
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|POST_DEC
condition|)
name|inc_amount
operator|=
operator|-
name|inc_amount
expr_stmt|;
name|inc
operator|=
name|GEN_INT
argument_list|(
name|inc_amount
argument_list|)
expr_stmt|;
comment|/* If this is post-increment, first copy the location to the reload reg.  */
if|if
condition|(
name|post
operator|&&
name|real_in
operator|!=
name|reloadreg
condition|)
name|emit_insn
argument_list|(
name|gen_move_insn
argument_list|(
name|reloadreg
argument_list|,
name|real_in
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|==
name|value
condition|)
block|{
comment|/* See if we can directly increment INCLOC.  Use a method similar to 	 that in gen_reload.  */
name|last
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|add_insn
operator|=
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|incloc
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|GET_MODE
argument_list|(
name|incloc
argument_list|)
argument_list|,
name|incloc
argument_list|,
name|inc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|recog_memoized
argument_list|(
name|add_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|>=
literal|0
condition|)
block|{
name|extract_insn
argument_list|(
name|add_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|constrain_operands
argument_list|(
literal|1
argument_list|)
condition|)
block|{
comment|/* If this is a pre-increment and we have incremented the value 		 where it lives, copy the incremented value to RELOADREG to 		 be used as an address.  */
if|if
condition|(
operator|!
name|post
condition|)
name|emit_insn
argument_list|(
name|gen_move_insn
argument_list|(
name|reloadreg
argument_list|,
name|incloc
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|add_insn
return|;
block|}
block|}
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
comment|/* If couldn't do the increment directly, must increment in RELOADREG.      The way we do this depends on whether this is pre- or post-increment.      For pre-increment, copy INCLOC to the reload register, increment it      there, then save back.  */
if|if
condition|(
operator|!
name|post
condition|)
block|{
if|if
condition|(
name|in
operator|!=
name|reloadreg
condition|)
name|emit_insn
argument_list|(
name|gen_move_insn
argument_list|(
name|reloadreg
argument_list|,
name|real_in
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_add2_insn
argument_list|(
name|reloadreg
argument_list|,
name|inc
argument_list|)
argument_list|)
expr_stmt|;
name|store
operator|=
name|emit_insn
argument_list|(
name|gen_move_insn
argument_list|(
name|incloc
argument_list|,
name|reloadreg
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Postincrement. 	 Because this might be a jump insn or a compare, and because RELOADREG 	 may not be available after the insn in an input reload, we must do 	 the incrementation before the insn being reloaded for.  	 We have already copied IN to RELOADREG.  Increment the copy in 	 RELOADREG, save that back, then decrement RELOADREG so it has 	 the original value.  */
name|emit_insn
argument_list|(
name|gen_add2_insn
argument_list|(
name|reloadreg
argument_list|,
name|inc
argument_list|)
argument_list|)
expr_stmt|;
name|store
operator|=
name|emit_insn
argument_list|(
name|gen_move_insn
argument_list|(
name|incloc
argument_list|,
name|reloadreg
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_add2_insn
argument_list|(
name|reloadreg
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|inc_amount
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|store
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if we are certain that the constraint-string STRING allows    the hard register REG.  Return 0 if we can't be sure of this.  */
end_comment

begin_function
specifier|static
name|int
name|constraint_accepts_reg_p
parameter_list|(
name|string
parameter_list|,
name|reg
parameter_list|)
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
block|{
name|int
name|value
init|=
literal|0
decl_stmt|;
name|int
name|regno
init|=
name|true_regnum
argument_list|(
name|reg
argument_list|)
decl_stmt|;
name|int
name|c
decl_stmt|;
comment|/* Initialize for first alternative.  */
name|value
operator|=
literal|0
expr_stmt|;
comment|/* Check that each alternative contains `g' or `r'.  */
while|while
condition|(
literal|1
condition|)
switch|switch
condition|(
name|c
operator|=
operator|*
name|string
operator|++
condition|)
block|{
case|case
literal|0
case|:
comment|/* If an alternative lacks `g' or `r', we lose.  */
return|return
name|value
return|;
case|case
literal|','
case|:
comment|/* If an alternative lacks `g' or `r', we lose.  */
if|if
condition|(
name|value
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Initialize for next alternative.  */
name|value
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
case|case
literal|'r'
case|:
comment|/* Any general reg wins for this alternative.  */
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|GENERAL_REGS
index|]
argument_list|,
name|regno
argument_list|)
condition|)
name|value
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
comment|/* Any reg in specified class wins for this alternative.  */
block|{
name|enum
name|reg_class
name|class
init|=
name|REG_CLASS_FROM_LETTER
argument_list|(
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|class
index|]
argument_list|,
name|regno
argument_list|)
condition|)
name|value
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* INSN is a no-op; delete it.    If this sets the return value of the function, we must keep a USE around,    in case this is in a different basic block than the final USE.  Otherwise,    we could loose important register lifeness information on    SMALL_REGISTER_CLASSES machines, where return registers might be used as    spills:  subsequent passes assume that spill registers are dead at the end    of a basic block.    VALUE must be the return value in such a case, NULL otherwise.  */
end_comment

begin_function
specifier|static
name|void
name|reload_cse_delete_noop_set
parameter_list|(
name|insn
parameter_list|,
name|value
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|value
decl_stmt|;
block|{
if|if
condition|(
name|value
condition|)
block|{
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|NULL_RTX
expr_stmt|;
block|}
else|else
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* See whether a single set SET is a noop.  */
end_comment

begin_function
specifier|static
name|int
name|reload_cse_noop_set_p
parameter_list|(
name|set
parameter_list|)
name|rtx
name|set
decl_stmt|;
block|{
return|return
name|rtx_equal_for_cselib_p
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Try to simplify INSN.  */
end_comment

begin_function
specifier|static
name|void
name|reload_cse_simplify
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|body
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SET
condition|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
comment|/* Simplify even if we may think it is a no-op.          We may think a memory load of a value smaller than WORD_SIZE          is redundant because we haven't taken into account possible          implicit extension.  reload_cse_simplify_set() will bring          this out, so it's safer to simplify before we delete.  */
name|count
operator|+=
name|reload_cse_simplify_set
argument_list|(
name|body
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|count
operator|&&
name|reload_cse_noop_set_p
argument_list|(
name|body
argument_list|)
condition|)
block|{
name|rtx
name|value
init|=
name|SET_DEST
argument_list|(
name|body
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|REG_FUNCTION_VALUE_P
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
condition|)
name|value
operator|=
literal|0
expr_stmt|;
name|reload_cse_delete_noop_set
argument_list|(
name|insn
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|count
operator|>
literal|0
condition|)
name|apply_change_group
argument_list|()
expr_stmt|;
else|else
name|reload_cse_simplify_operands
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|rtx
name|value
init|=
name|NULL_RTX
decl_stmt|;
comment|/* If every action in a PARALLEL is a noop, we can delete 	 the entire PARALLEL.  */
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|rtx
name|part
init|=
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|part
argument_list|)
operator|==
name|SET
condition|)
block|{
if|if
condition|(
operator|!
name|reload_cse_noop_set_p
argument_list|(
name|part
argument_list|)
condition|)
break|break;
if|if
condition|(
name|REG_FUNCTION_VALUE_P
argument_list|(
name|SET_DEST
argument_list|(
name|part
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|value
condition|)
break|break;
name|value
operator|=
name|SET_DEST
argument_list|(
name|part
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|part
argument_list|)
operator|!=
name|CLOBBER
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|reload_cse_delete_noop_set
argument_list|(
name|insn
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* We're done with this insn.  */
return|return;
block|}
comment|/* It's not a no-op, but we can try to simplify it.  */
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
name|count
operator|+=
name|reload_cse_simplify_set
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
name|apply_change_group
argument_list|()
expr_stmt|;
else|else
name|reload_cse_simplify_operands
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Do a very simple CSE pass over the hard registers.     This function detects no-op moves where we happened to assign two    different pseudo-registers to the same hard register, and then    copied one to the other.  Reload will generate a useless    instruction copying a register to itself.     This function also detects cases where we load a value from memory    into two different registers, and (if memory is more expensive than    registers) changes it to simply copy the first register into the    second register.     Another optimization is performed that scans the operands of each    instruction to see whether the value is already available in a    hard register.  It then replaces the operand with the hard register    if possible, much like an optional reload would.  */
end_comment

begin_function
specifier|static
name|void
name|reload_cse_regs_1
parameter_list|(
name|first
parameter_list|)
name|rtx
name|first
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
name|cselib_init
argument_list|()
expr_stmt|;
name|init_alias_analysis
argument_list|()
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|reload_cse_simplify
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|cselib_process_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* Clean up.  */
name|end_alias_analysis
argument_list|()
expr_stmt|;
name|cselib_finish
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Call cse / combine like post-reload optimization phases.    FIRST is the first instruction.  */
end_comment

begin_function
name|void
name|reload_cse_regs
parameter_list|(
name|first
parameter_list|)
name|rtx
name|first
decl_stmt|;
block|{
name|reload_cse_regs_1
argument_list|(
name|first
argument_list|)
expr_stmt|;
name|reload_combine
argument_list|()
expr_stmt|;
name|reload_cse_move2add
argument_list|(
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_expensive_optimizations
condition|)
name|reload_cse_regs_1
argument_list|(
name|first
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Try to simplify a single SET instruction.  SET is the set pattern.    INSN is the instruction it came from.    This function only handles one case: if we set a register to a value    which is not a register, we try to find that value in some other register    and change the set into a register copy.  */
end_comment

begin_function
specifier|static
name|int
name|reload_cse_simplify_set
parameter_list|(
name|set
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|set
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|did_change
init|=
literal|0
decl_stmt|;
name|int
name|dreg
decl_stmt|;
name|rtx
name|src
decl_stmt|;
name|enum
name|reg_class
name|dclass
decl_stmt|;
name|int
name|old_cost
decl_stmt|;
name|cselib_val
modifier|*
name|val
decl_stmt|;
name|struct
name|elt_loc_list
modifier|*
name|l
decl_stmt|;
ifdef|#
directive|ifdef
name|LOAD_EXTEND_OP
name|enum
name|rtx_code
name|extend_op
init|=
name|NIL
decl_stmt|;
endif|#
directive|endif
name|dreg
operator|=
name|true_regnum
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dreg
operator|<
literal|0
condition|)
return|return
literal|0
return|;
name|src
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
if|if
condition|(
name|side_effects_p
argument_list|(
name|src
argument_list|)
operator|||
name|true_regnum
argument_list|(
name|src
argument_list|)
operator|>=
literal|0
condition|)
return|return
literal|0
return|;
name|dclass
operator|=
name|REGNO_REG_CLASS
argument_list|(
name|dreg
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOAD_EXTEND_OP
comment|/* When replacing a memory with a register, we need to honor assumptions      that combine made wrt the contents of sign bits.  We'll do this by      generating an extend instruction instead of a reg->reg copy.  Thus       the destination must be a register that we can widen.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
operator|<
name|BITS_PER_WORD
operator|&&
operator|(
name|extend_op
operator|=
name|LOAD_EXTEND_OP
argument_list|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
operator|)
operator|!=
name|NIL
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* If memory loads are cheaper than register copies, don't change them.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|MEM
condition|)
name|old_cost
operator|=
name|MEMORY_MOVE_COST
argument_list|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|,
name|dclass
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|src
argument_list|)
condition|)
name|old_cost
operator|=
name|rtx_cost
argument_list|(
name|src
argument_list|,
name|SET
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|REG
condition|)
name|old_cost
operator|=
name|REGISTER_MOVE_COST
argument_list|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|,
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|)
argument_list|,
name|dclass
argument_list|)
expr_stmt|;
else|else
comment|/* ???   */
name|old_cost
operator|=
name|rtx_cost
argument_list|(
name|src
argument_list|,
name|SET
argument_list|)
expr_stmt|;
name|val
operator|=
name|cselib_lookup
argument_list|(
name|src
argument_list|,
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|val
condition|)
return|return
literal|0
return|;
for|for
control|(
name|l
operator|=
name|val
operator|->
name|locs
init|;
name|l
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
name|rtx
name|this_rtx
init|=
name|l
operator|->
name|loc
decl_stmt|;
name|int
name|this_cost
decl_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|this_rtx
argument_list|)
operator|&&
operator|!
name|references_value_p
argument_list|(
name|this_rtx
argument_list|,
literal|0
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|LOAD_EXTEND_OP
if|if
condition|(
name|extend_op
operator|!=
name|NIL
condition|)
block|{
name|HOST_WIDE_INT
name|this_val
decl_stmt|;
comment|/* ??? I'm lazy and don't wish to handle CONST_DOUBLE.  Other 		 constants, such as SYMBOL_REF, cannot be extended.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|this_rtx
argument_list|)
operator|!=
name|CONST_INT
condition|)
continue|continue;
name|this_val
operator|=
name|INTVAL
argument_list|(
name|this_rtx
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|extend_op
condition|)
block|{
case|case
name|ZERO_EXTEND
case|:
name|this_val
operator|&=
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIGN_EXTEND
case|:
comment|/* ??? In theory we're already extended.  */
if|if
condition|(
name|this_val
operator|==
name|trunc_int_for_mode
argument_list|(
name|this_val
argument_list|,
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
condition|)
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|this_rtx
operator|=
name|GEN_INT
argument_list|(
name|this_val
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|this_cost
operator|=
name|rtx_cost
argument_list|(
name|this_rtx
argument_list|,
name|SET
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|this_rtx
argument_list|)
operator|==
name|REG
condition|)
block|{
ifdef|#
directive|ifdef
name|LOAD_EXTEND_OP
if|if
condition|(
name|extend_op
operator|!=
name|NIL
condition|)
block|{
name|this_rtx
operator|=
name|gen_rtx_fmt_e
argument_list|(
name|extend_op
argument_list|,
name|word_mode
argument_list|,
name|this_rtx
argument_list|)
expr_stmt|;
name|this_cost
operator|=
name|rtx_cost
argument_list|(
name|this_rtx
argument_list|,
name|SET
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|this_cost
operator|=
name|REGISTER_MOVE_COST
argument_list|(
name|GET_MODE
argument_list|(
name|this_rtx
argument_list|)
argument_list|,
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|this_rtx
argument_list|)
argument_list|)
argument_list|,
name|dclass
argument_list|)
expr_stmt|;
block|}
else|else
continue|continue;
comment|/* If equal costs, prefer registers over anything else.  That 	 tends to lead to smaller instructions on some machines.  */
if|if
condition|(
name|this_cost
operator|<
name|old_cost
operator|||
operator|(
name|this_cost
operator|==
name|old_cost
operator|&&
name|GET_CODE
argument_list|(
name|this_rtx
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|!=
name|REG
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|LOAD_EXTEND_OP
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|)
operator|<
name|BITS_PER_WORD
operator|&&
name|extend_op
operator|!=
name|NIL
condition|)
block|{
name|rtx
name|wide_dest
init|=
name|gen_rtx_REG
argument_list|(
name|word_mode
argument_list|,
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|ORIGINAL_REGNO
argument_list|(
name|wide_dest
argument_list|)
operator|=
name|ORIGINAL_REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|wide_dest
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|this_rtx
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|old_cost
operator|=
name|this_cost
operator|,
name|did_change
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
name|did_change
return|;
block|}
end_function

begin_comment
comment|/* Try to replace operands in INSN with equivalent values that are already    in registers.  This can be viewed as optional reloading.     For each non-register operand in the insn, see if any hard regs are    known to be equivalent to that operand.  Record the alternatives which    can accept these hard registers.  Among all alternatives, select the    ones which are better or equal to the one currently matching, where    "better" is in terms of '?' and '!' constraints.  Among the remaining    alternatives, select the one which replaces most operands with    hard registers.  */
end_comment

begin_function
specifier|static
name|int
name|reload_cse_simplify_operands
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* For each operand, all registers that are equivalent to it.  */
name|HARD_REG_SET
name|equiv_regs
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|constraints
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
comment|/* Vector recording how bad an alternative is.  */
name|int
modifier|*
name|alternative_reject
decl_stmt|;
comment|/* Vector recording how many registers can be introduced by choosing      this alternative.  */
name|int
modifier|*
name|alternative_nregs
decl_stmt|;
comment|/* Array of vectors recording, for each operand and each alternative,      which hard register to substitute, or -1 if the operand should be      left as it is.  */
name|int
modifier|*
name|op_alt_regno
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
comment|/* Array of alternatives, sorted in order of decreasing desirability.  */
name|int
modifier|*
name|alternative_order
decl_stmt|;
name|rtx
name|reg
init|=
name|gen_rtx_REG
argument_list|(
name|VOIDmode
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
name|extract_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|recog_data
operator|.
name|n_alternatives
operator|==
literal|0
operator|||
name|recog_data
operator|.
name|n_operands
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Figure out which alternative currently matches.  */
if|if
condition|(
operator|!
name|constrain_operands
argument_list|(
literal|1
argument_list|)
condition|)
name|fatal_insn_not_found
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|alternative_reject
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|recog_data
operator|.
name|n_alternatives
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|alternative_nregs
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|recog_data
operator|.
name|n_alternatives
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|alternative_order
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|recog_data
operator|.
name|n_alternatives
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|alternative_reject
argument_list|,
literal|0
argument_list|,
name|recog_data
operator|.
name|n_alternatives
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|alternative_nregs
argument_list|,
literal|0
argument_list|,
name|recog_data
operator|.
name|n_alternatives
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For each operand, find out which regs are equivalent.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|recog_data
operator|.
name|n_operands
condition|;
name|i
operator|++
control|)
block|{
name|cselib_val
modifier|*
name|v
decl_stmt|;
name|struct
name|elt_loc_list
modifier|*
name|l
decl_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|equiv_regs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* cselib blows up on CODE_LABELs.  Trying to fix that doesn't seem 	 right, so avoid the problem here.  Likewise if we have a constant          and the insn pattern doesn't tell us the mode we need.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
operator|==
name|CODE_LABEL
operator|||
operator|(
name|CONSTANT_P
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
operator|&&
name|recog_data
operator|.
name|operand_mode
index|[
name|i
index|]
operator|==
name|VOIDmode
operator|)
condition|)
continue|continue;
name|v
operator|=
name|cselib_lookup
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|,
name|recog_data
operator|.
name|operand_mode
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|v
condition|)
continue|continue;
for|for
control|(
name|l
operator|=
name|v
operator|->
name|locs
init|;
name|l
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|l
operator|->
name|loc
argument_list|)
operator|==
name|REG
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|equiv_regs
index|[
name|i
index|]
argument_list|,
name|REGNO
argument_list|(
name|l
operator|->
name|loc
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|recog_data
operator|.
name|n_operands
condition|;
name|i
operator|++
control|)
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|regno
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|op_alt_regno
index|[
name|i
index|]
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|recog_data
operator|.
name|n_alternatives
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|recog_data
operator|.
name|n_alternatives
condition|;
name|j
operator|++
control|)
name|op_alt_regno
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|p
operator|=
name|constraints
index|[
name|i
index|]
operator|=
name|recog_data
operator|.
name|constraints
index|[
name|i
index|]
expr_stmt|;
name|mode
operator|=
name|recog_data
operator|.
name|operand_mode
index|[
name|i
index|]
expr_stmt|;
comment|/* Add the reject values for each alternative given by the constraints 	 for this operand.  */
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
name|char
name|c
init|=
operator|*
name|p
operator|++
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|','
condition|)
name|j
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'?'
condition|)
name|alternative_reject
index|[
name|j
index|]
operator|+=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'!'
condition|)
name|alternative_reject
index|[
name|j
index|]
operator|+=
literal|300
expr_stmt|;
block|}
comment|/* We won't change operands which are already registers.  We 	 also don't want to modify output operands.  */
name|regno
operator|=
name|true_regnum
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
literal|0
operator|||
name|constraints
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'='
operator|||
name|constraints
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'+'
condition|)
continue|continue;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
block|{
name|int
name|class
init|=
operator|(
name|int
operator|)
name|NO_REGS
decl_stmt|;
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|equiv_regs
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
condition|)
continue|continue;
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|=
name|regno
expr_stmt|;
name|PUT_MODE
argument_list|(
name|reg
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* We found a register equal to this operand.  Now look for all 	     alternatives that can accept this register and have not been 	     assigned a register they can use yet.  */
name|j
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|constraints
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
name|c
init|=
operator|*
name|p
operator|++
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'='
case|:
case|case
literal|'+'
case|:
case|case
literal|'?'
case|:
case|case
literal|'#'
case|:
case|case
literal|'&'
case|:
case|case
literal|'!'
case|:
case|case
literal|'*'
case|:
case|case
literal|'%'
case|:
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
case|case
literal|'m'
case|:
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
case|case
literal|'V'
case|:
case|case
literal|'o'
case|:
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
case|case
literal|'G'
case|:
case|case
literal|'H'
case|:
case|case
literal|'s'
case|:
case|case
literal|'i'
case|:
case|case
literal|'n'
case|:
case|case
literal|'I'
case|:
case|case
literal|'J'
case|:
case|case
literal|'K'
case|:
case|case
literal|'L'
case|:
case|case
literal|'M'
case|:
case|case
literal|'N'
case|:
case|case
literal|'O'
case|:
case|case
literal|'P'
case|:
case|case
literal|'p'
case|:
case|case
literal|'X'
case|:
comment|/* These don't say anything we care about.  */
break|break;
case|case
literal|'g'
case|:
case|case
literal|'r'
case|:
name|class
operator|=
name|reg_class_subunion
index|[
operator|(
name|int
operator|)
name|class
index|]
index|[
operator|(
name|int
operator|)
name|GENERAL_REGS
index|]
expr_stmt|;
break|break;
default|default:
name|class
operator|=
name|reg_class_subunion
index|[
operator|(
name|int
operator|)
name|class
index|]
index|[
operator|(
name|int
operator|)
name|REG_CLASS_FROM_LETTER
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|c
argument_list|)
index|]
expr_stmt|;
break|break;
case|case
literal|','
case|:
case|case
literal|'\0'
case|:
comment|/* See if REGNO fits this alternative, and set it up as the 		     replacement register if we don't have one for this 		     alternative yet and the operand being replaced is not 		     a cheap CONST_INT.  */
if|if
condition|(
name|op_alt_regno
index|[
name|i
index|]
index|[
name|j
index|]
operator|==
operator|-
literal|1
operator|&&
name|reg_fits_class_p
argument_list|(
name|reg
argument_list|,
name|class
argument_list|,
literal|0
argument_list|,
name|mode
argument_list|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
operator|!=
name|CONST_INT
operator|||
operator|(
name|rtx_cost
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|,
name|SET
argument_list|)
operator|>
name|rtx_cost
argument_list|(
name|reg
argument_list|,
name|SET
argument_list|)
operator|)
operator|)
condition|)
block|{
name|alternative_nregs
index|[
name|j
index|]
operator|++
expr_stmt|;
name|op_alt_regno
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|regno
expr_stmt|;
block|}
name|j
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
break|break;
block|}
block|}
block|}
comment|/* Record all alternatives which are better or equal to the currently      matching one in the alternative_order array.  */
for|for
control|(
name|i
operator|=
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|recog_data
operator|.
name|n_alternatives
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|alternative_reject
index|[
name|i
index|]
operator|<=
name|alternative_reject
index|[
name|which_alternative
index|]
condition|)
name|alternative_order
index|[
name|j
operator|++
index|]
operator|=
name|i
expr_stmt|;
name|recog_data
operator|.
name|n_alternatives
operator|=
name|j
expr_stmt|;
comment|/* Sort it.  Given a small number of alternatives, a dumb algorithm      won't hurt too much.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|recog_data
operator|.
name|n_alternatives
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|int
name|best
init|=
name|i
decl_stmt|;
name|int
name|best_reject
init|=
name|alternative_reject
index|[
name|alternative_order
index|[
name|i
index|]
index|]
decl_stmt|;
name|int
name|best_nregs
init|=
name|alternative_nregs
index|[
name|alternative_order
index|[
name|i
index|]
index|]
decl_stmt|;
name|int
name|tmp
decl_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|recog_data
operator|.
name|n_alternatives
condition|;
name|j
operator|++
control|)
block|{
name|int
name|this_reject
init|=
name|alternative_reject
index|[
name|alternative_order
index|[
name|j
index|]
index|]
decl_stmt|;
name|int
name|this_nregs
init|=
name|alternative_nregs
index|[
name|alternative_order
index|[
name|j
index|]
index|]
decl_stmt|;
if|if
condition|(
name|this_reject
operator|<
name|best_reject
operator|||
operator|(
name|this_reject
operator|==
name|best_reject
operator|&&
name|this_nregs
operator|<
name|best_nregs
operator|)
condition|)
block|{
name|best
operator|=
name|j
expr_stmt|;
name|best_reject
operator|=
name|this_reject
expr_stmt|;
name|best_nregs
operator|=
name|this_nregs
expr_stmt|;
block|}
block|}
name|tmp
operator|=
name|alternative_order
index|[
name|best
index|]
expr_stmt|;
name|alternative_order
index|[
name|best
index|]
operator|=
name|alternative_order
index|[
name|i
index|]
expr_stmt|;
name|alternative_order
index|[
name|i
index|]
operator|=
name|tmp
expr_stmt|;
block|}
comment|/* Substitute the operands as determined by op_alt_regno for the best      alternative.  */
name|j
operator|=
name|alternative_order
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|recog_data
operator|.
name|n_operands
condition|;
name|i
operator|++
control|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|recog_data
operator|.
name|operand_mode
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|op_alt_regno
index|[
name|i
index|]
index|[
name|j
index|]
operator|==
operator|-
literal|1
condition|)
continue|continue;
name|validate_change
argument_list|(
name|insn
argument_list|,
name|recog_data
operator|.
name|operand_loc
index|[
name|i
index|]
argument_list|,
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|op_alt_regno
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|recog_data
operator|.
name|n_dups
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|int
name|op
init|=
name|recog_data
operator|.
name|dup_num
index|[
name|i
index|]
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|recog_data
operator|.
name|operand_mode
index|[
name|op
index|]
decl_stmt|;
if|if
condition|(
name|op_alt_regno
index|[
name|op
index|]
index|[
name|j
index|]
operator|==
operator|-
literal|1
condition|)
continue|continue;
name|validate_change
argument_list|(
name|insn
argument_list|,
name|recog_data
operator|.
name|dup_loc
index|[
name|i
index|]
argument_list|,
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|op_alt_regno
index|[
name|op
index|]
index|[
name|j
index|]
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|apply_change_group
argument_list|()
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If reload couldn't use reg+reg+offset addressing, try to use reg+reg    addressing now.    This code might also be useful when reload gave up on reg+reg addresssing    because of clashes between the return register and INDEX_REG_CLASS.  */
end_comment

begin_comment
comment|/* The maximum number of uses of a register we can keep track of to    replace them with reg+reg addressing.  */
end_comment

begin_define
define|#
directive|define
name|RELOAD_COMBINE_MAX_USES
value|6
end_define

begin_comment
comment|/* INSN is the insn where a register has ben used, and USEP points to the    location of the register within the rtl.  */
end_comment

begin_struct
struct|struct
name|reg_use
block|{
name|rtx
name|insn
decl_stmt|,
modifier|*
name|usep
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* If the register is used in some unknown fashion, USE_INDEX is negative.    If it is dead, USE_INDEX is RELOAD_COMBINE_MAX_USES, and STORE_RUID    indicates where it becomes live again.    Otherwise, USE_INDEX is the index of the last encountered use of the    register (which is first among these we have seen since we scan backwards),    OFFSET contains the constant offset that is added to the register in    all encountered uses, and USE_RUID indicates the first encountered, i.e.    last, of these uses.    STORE_RUID is always meaningful if we only want to use a value in a    register in a different place: it denotes the next insn in the insn    stream (i.e. the last ecountered) that sets or clobbers the register.  */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|struct
name|reg_use
name|reg_use
index|[
name|RELOAD_COMBINE_MAX_USES
index|]
decl_stmt|;
name|int
name|use_index
decl_stmt|;
name|rtx
name|offset
decl_stmt|;
name|int
name|store_ruid
decl_stmt|;
name|int
name|use_ruid
decl_stmt|;
block|}
name|reg_state
index|[
name|FIRST_PSEUDO_REGISTER
index|]
struct|;
end_struct

begin_comment
comment|/* Reverse linear uid.  This is increased in reload_combine while scanning    the instructions from last to first.  It is used to set last_label_ruid    and the store_ruid / use_ruid fields in reg_state.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|reload_combine_ruid
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|LABEL_LIVE
parameter_list|(
name|LABEL
parameter_list|)
define|\
value|(label_live[CODE_LABEL_NUMBER (LABEL) - min_labelno])
end_define

begin_function
specifier|static
name|void
name|reload_combine
parameter_list|()
block|{
name|rtx
name|insn
decl_stmt|,
name|set
decl_stmt|;
name|int
name|first_index_reg
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|last_index_reg
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|r
decl_stmt|;
name|int
name|last_label_ruid
decl_stmt|;
name|int
name|min_labelno
decl_stmt|,
name|n_labels
decl_stmt|;
name|HARD_REG_SET
name|ever_live_at_start
decl_stmt|,
modifier|*
name|label_live
decl_stmt|;
comment|/* If reg+reg can be used in offsetable memory addresses, the main chunk of      reload has already used it where appropriate, so there is no use in      trying to generate it now.  */
if|if
condition|(
name|double_reg_address_ok
operator|&&
name|INDEX_REG_CLASS
operator|!=
name|NO_REGS
condition|)
return|return;
comment|/* To avoid wasting too much time later searching for an index register,      determine the minimum and maximum index register numbers.  */
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|r
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|INDEX_REG_CLASS
index|]
argument_list|,
name|r
argument_list|)
condition|)
block|{
if|if
condition|(
name|first_index_reg
operator|==
operator|-
literal|1
condition|)
name|first_index_reg
operator|=
name|r
expr_stmt|;
name|last_index_reg
operator|=
name|r
expr_stmt|;
block|}
comment|/* If no index register is available, we can quit now.  */
if|if
condition|(
name|first_index_reg
operator|==
operator|-
literal|1
condition|)
return|return;
comment|/* Set up LABEL_LIVE and EVER_LIVE_AT_START.  The register lifetime      information is a bit fuzzy immediately after reload, but it's      still good enough to determine which registers are live at a jump      destination.  */
name|min_labelno
operator|=
name|get_first_label_num
argument_list|()
expr_stmt|;
name|n_labels
operator|=
name|max_label_num
argument_list|()
operator|-
name|min_labelno
expr_stmt|;
name|label_live
operator|=
operator|(
name|HARD_REG_SET
operator|*
operator|)
name|xmalloc
argument_list|(
name|n_labels
operator|*
sizeof|sizeof
argument_list|(
name|HARD_REG_SET
argument_list|)
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|ever_live_at_start
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|n_basic_blocks
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|insn
operator|=
name|BLOCK_HEAD
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
block|{
name|HARD_REG_SET
name|live
decl_stmt|;
name|REG_SET_TO_HARD_REG_SET
argument_list|(
name|live
argument_list|,
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
operator|->
name|global_live_at_start
argument_list|)
expr_stmt|;
name|compute_use_by_pseudos
argument_list|(
operator|&
name|live
argument_list|,
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
operator|->
name|global_live_at_start
argument_list|)
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|LABEL_LIVE
argument_list|(
name|insn
argument_list|)
argument_list|,
name|live
argument_list|)
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|ever_live_at_start
argument_list|,
name|live
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Initialize last_label_ruid, reload_combine_ruid and reg_state.  */
name|last_label_ruid
operator|=
name|reload_combine_ruid
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|r
operator|++
control|)
block|{
name|reg_state
index|[
name|r
index|]
operator|.
name|store_ruid
operator|=
name|reload_combine_ruid
expr_stmt|;
if|if
condition|(
name|fixed_regs
index|[
name|r
index|]
condition|)
name|reg_state
index|[
name|r
index|]
operator|.
name|use_index
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|reg_state
index|[
name|r
index|]
operator|.
name|use_index
operator|=
name|RELOAD_COMBINE_MAX_USES
expr_stmt|;
block|}
for|for
control|(
name|insn
operator|=
name|get_last_insn
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|rtx
name|note
decl_stmt|;
comment|/* We cannot do our optimization across labels.  Invalidating all the use 	 information we have would be costly, so we just note where the label 	 is and then later disable any optimization that would cross it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|last_label_ruid
operator|=
name|reload_combine_ruid
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|BARRIER
condition|)
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|r
operator|++
control|)
if|if
condition|(
operator|!
name|fixed_regs
index|[
name|r
index|]
condition|)
name|reg_state
index|[
name|r
index|]
operator|.
name|use_index
operator|=
name|RELOAD_COMBINE_MAX_USES
expr_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
name|reload_combine_ruid
operator|++
expr_stmt|;
comment|/* Look for (set (REGX) (CONST_INT)) 	 (set (REGX) (PLUS (REGX) (REGY))) 	 ... 	 ... (MEM (REGX)) ... 	 and convert it to 	 (set (REGZ) (CONST_INT)) 	 ... 	 ... (MEM (PLUS (REGZ) (REGY)))... .  	 First, check that we have (set (REGX) (PLUS (REGX) (REGY))) 	 and that we know all uses of REGX before it dies.  */
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
operator|!=
name|NULL_RTX
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|HARD_REGNO_NREGS
argument_list|(
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|1
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|&&
name|last_label_ruid
operator|<
name|reg_state
index|[
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
index|]
operator|.
name|use_ruid
condition|)
block|{
name|rtx
name|reg
init|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
decl_stmt|;
name|rtx
name|plus
init|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
decl_stmt|;
name|rtx
name|base
init|=
name|XEXP
argument_list|(
name|plus
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|prev
init|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|prev_set
init|=
name|prev
condition|?
name|single_set
argument_list|(
name|prev
argument_list|)
else|:
name|NULL_RTX
decl_stmt|;
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|reg
argument_list|)
decl_stmt|;
name|rtx
name|const_reg
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|reg_sum
init|=
name|NULL_RTX
decl_stmt|;
comment|/* Now, we need an index register. 	     We'll set index_reg to this index register, const_reg to the 	     register that is to be loaded with the constant 	     (denoted as REGZ in the substitution illustration above), 	     and reg_sum to the register-register that we want to use to 	     substitute uses of REG (typically in MEMs) with. 	     First check REG and BASE for being index registers; 	     we can use them even if they are not dead.  */
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|INDEX_REG_CLASS
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|INDEX_REG_CLASS
index|]
argument_list|,
name|REGNO
argument_list|(
name|base
argument_list|)
argument_list|)
condition|)
block|{
name|const_reg
operator|=
name|reg
expr_stmt|;
name|reg_sum
operator|=
name|plus
expr_stmt|;
block|}
else|else
block|{
comment|/* Otherwise, look for a free index register.  Since we have 		 checked above that neiter REG nor BASE are index registers, 		 if we find anything at all, it will be different from these 		 two registers.  */
for|for
control|(
name|i
operator|=
name|first_index_reg
init|;
name|i
operator|<=
name|last_index_reg
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|INDEX_REG_CLASS
index|]
argument_list|,
name|i
argument_list|)
operator|&&
name|reg_state
index|[
name|i
index|]
operator|.
name|use_index
operator|==
name|RELOAD_COMBINE_MAX_USES
operator|&&
name|reg_state
index|[
name|i
index|]
operator|.
name|store_ruid
operator|<=
name|reg_state
index|[
name|regno
index|]
operator|.
name|use_ruid
operator|&&
name|HARD_REGNO_NREGS
argument_list|(
name|i
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|==
literal|1
condition|)
block|{
name|rtx
name|index_reg
init|=
name|gen_rtx_REG
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|const_reg
operator|=
name|index_reg
expr_stmt|;
name|reg_sum
operator|=
name|gen_rtx_PLUS
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|index_reg
argument_list|,
name|base
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* Check that PREV_SET is indeed (set (REGX) (CONST_INT)) and that 	     (REGY), i.e. BASE, is not clobbered before the last use we'll 	     create.  */
if|if
condition|(
name|prev_set
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|prev_set
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_DEST
argument_list|(
name|prev_set
argument_list|)
argument_list|,
name|reg
argument_list|)
operator|&&
name|reg_state
index|[
name|regno
index|]
operator|.
name|use_index
operator|>=
literal|0
operator|&&
operator|(
name|reg_state
index|[
name|REGNO
argument_list|(
name|base
argument_list|)
index|]
operator|.
name|store_ruid
operator|<=
name|reg_state
index|[
name|regno
index|]
operator|.
name|use_ruid
operator|)
operator|&&
name|reg_sum
operator|!=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Change destination register and, if necessary, the 		 constant value in PREV, the constant loading instruction.  */
name|validate_change
argument_list|(
name|prev
argument_list|,
operator|&
name|SET_DEST
argument_list|(
name|prev_set
argument_list|)
argument_list|,
name|const_reg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_state
index|[
name|regno
index|]
operator|.
name|offset
operator|!=
name|const0_rtx
condition|)
name|validate_change
argument_list|(
name|prev
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|prev_set
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|SET_SRC
argument_list|(
name|prev_set
argument_list|)
argument_list|)
operator|+
name|INTVAL
argument_list|(
name|reg_state
index|[
name|regno
index|]
operator|.
name|offset
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Now for every use of REG that we have recorded, replace REG 		 with REG_SUM.  */
for|for
control|(
name|i
operator|=
name|reg_state
index|[
name|regno
index|]
operator|.
name|use_index
init|;
name|i
operator|<
name|RELOAD_COMBINE_MAX_USES
condition|;
name|i
operator|++
control|)
name|validate_change
argument_list|(
name|reg_state
index|[
name|regno
index|]
operator|.
name|reg_use
index|[
name|i
index|]
operator|.
name|insn
argument_list|,
name|reg_state
index|[
name|regno
index|]
operator|.
name|reg_use
index|[
name|i
index|]
operator|.
name|usep
argument_list|,
comment|/* Each change must have its own 				    replacement.  */
name|copy_rtx
argument_list|(
name|reg_sum
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|apply_change_group
argument_list|()
condition|)
block|{
name|rtx
modifier|*
name|np
decl_stmt|;
comment|/* Delete the reg-reg addition.  */
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_state
index|[
name|regno
index|]
operator|.
name|offset
operator|!=
name|const0_rtx
condition|)
comment|/* Previous REG_EQUIV / REG_EQUAL notes for PREV 		       are now invalid.  */
for|for
control|(
name|np
operator|=
operator|&
name|REG_NOTES
argument_list|(
name|prev
argument_list|)
init|;
operator|*
name|np
condition|;
control|)
block|{
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
operator|*
name|np
argument_list|)
operator|==
name|REG_EQUAL
operator|||
name|REG_NOTE_KIND
argument_list|(
operator|*
name|np
argument_list|)
operator|==
name|REG_EQUIV
condition|)
operator|*
name|np
operator|=
name|XEXP
argument_list|(
operator|*
name|np
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|np
operator|=
operator|&
name|XEXP
argument_list|(
operator|*
name|np
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|reg_state
index|[
name|regno
index|]
operator|.
name|use_index
operator|=
name|RELOAD_COMBINE_MAX_USES
expr_stmt|;
name|reg_state
index|[
name|REGNO
argument_list|(
name|const_reg
argument_list|)
index|]
operator|.
name|store_ruid
operator|=
name|reload_combine_ruid
expr_stmt|;
continue|continue;
block|}
block|}
block|}
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|reload_combine_note_store
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|rtx
name|link
decl_stmt|;
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|r
operator|++
control|)
if|if
condition|(
name|call_used_regs
index|[
name|r
index|]
condition|)
block|{
name|reg_state
index|[
name|r
index|]
operator|.
name|use_index
operator|=
name|RELOAD_COMBINE_MAX_USES
expr_stmt|;
name|reg_state
index|[
name|r
index|]
operator|.
name|store_ruid
operator|=
name|reload_combine_ruid
expr_stmt|;
block|}
for|for
control|(
name|link
operator|=
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|rtx
name|usage_rtx
init|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|usage_rtx
argument_list|)
operator|==
name|REG
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|start_reg
init|=
name|REGNO
argument_list|(
name|usage_rtx
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|num_regs
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|start_reg
argument_list|,
name|GET_MODE
argument_list|(
name|usage_rtx
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|end_reg
init|=
name|start_reg
operator|+
name|num_regs
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|i
operator|=
name|start_reg
init|;
name|i
operator|<=
name|end_reg
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
block|{
name|reg_state
index|[
name|i
index|]
operator|.
name|use_index
operator|=
name|RELOAD_COMBINE_MAX_USES
expr_stmt|;
name|reg_state
index|[
name|i
index|]
operator|.
name|store_ruid
operator|=
name|reload_combine_ruid
expr_stmt|;
block|}
else|else
name|reg_state
index|[
name|i
index|]
operator|.
name|use_index
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|RETURN
condition|)
block|{
comment|/* Non-spill registers might be used at the call destination in 	     some unknown fashion, so we have to mark the unknown use.  */
name|HARD_REG_SET
modifier|*
name|live
decl_stmt|;
if|if
condition|(
operator|(
name|condjump_p
argument_list|(
name|insn
argument_list|)
operator|||
name|condjump_in_parallel_p
argument_list|(
name|insn
argument_list|)
operator|)
operator|&&
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
condition|)
name|live
operator|=
operator|&
name|LABEL_LIVE
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|live
operator|=
operator|&
name|ever_live_at_start
expr_stmt|;
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
operator|*
name|live
argument_list|,
name|i
argument_list|)
condition|)
name|reg_state
index|[
name|i
index|]
operator|.
name|use_index
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|reload_combine_note_use
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
block|{
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_INC
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|reg_state
index|[
name|regno
index|]
operator|.
name|store_ruid
operator|=
name|reload_combine_ruid
expr_stmt|;
name|reg_state
index|[
name|regno
index|]
operator|.
name|use_index
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
name|free
argument_list|(
name|label_live
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check if DST is a register or a subreg of a register; if it is,    update reg_state[regno].store_ruid and reg_state[regno].use_index    accordingly.  Called via note_stores from reload_combine.  */
end_comment

begin_function
specifier|static
name|void
name|reload_combine_note_store
parameter_list|(
name|dst
parameter_list|,
name|set
parameter_list|,
name|data
parameter_list|)
name|rtx
name|dst
decl_stmt|,
name|set
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|int
name|regno
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|dst
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|regno
operator|=
name|subreg_regno_offset
argument_list|(
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|dst
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|dst
argument_list|)
argument_list|)
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|dst
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|dst
argument_list|)
argument_list|)
expr_stmt|;
name|dst
operator|=
name|SUBREG_REG
argument_list|(
name|dst
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|!=
name|REG
condition|)
return|return;
name|regno
operator|+=
name|REGNO
argument_list|(
name|dst
argument_list|)
expr_stmt|;
comment|/* note_stores might have stripped a STRICT_LOW_PART, so we have to be      careful with registers / register parts that are not full words.       Similarly for ZERO_EXTRACT and SIGN_EXTRACT.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|set
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
block|{
for|for
control|(
name|i
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|-
literal|1
operator|+
name|regno
init|;
name|i
operator|>=
name|regno
condition|;
name|i
operator|--
control|)
block|{
name|reg_state
index|[
name|i
index|]
operator|.
name|use_index
operator|=
operator|-
literal|1
expr_stmt|;
name|reg_state
index|[
name|i
index|]
operator|.
name|store_ruid
operator|=
name|reload_combine_ruid
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|-
literal|1
operator|+
name|regno
init|;
name|i
operator|>=
name|regno
condition|;
name|i
operator|--
control|)
block|{
name|reg_state
index|[
name|i
index|]
operator|.
name|store_ruid
operator|=
name|reload_combine_ruid
expr_stmt|;
name|reg_state
index|[
name|i
index|]
operator|.
name|use_index
operator|=
name|RELOAD_COMBINE_MAX_USES
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* XP points to a piece of rtl that has to be checked for any uses of    registers.    *XP is the pattern of INSN, or a part of it.    Called from reload_combine, and recursively by itself.  */
end_comment

begin_function
specifier|static
name|void
name|reload_combine_note_use
parameter_list|(
name|xp
parameter_list|,
name|insn
parameter_list|)
name|rtx
modifier|*
name|xp
decl_stmt|,
name|insn
decl_stmt|;
block|{
name|rtx
name|x
init|=
operator|*
name|xp
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|x
operator|->
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|rtx
name|offset
init|=
name|const0_rtx
decl_stmt|;
comment|/* For the REG case below.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|SET
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|reload_combine_note_use
argument_list|(
operator|&
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|USE
case|:
comment|/* If this is the USE of a return value, we can't change it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REG_FUNCTION_VALUE_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Mark the return register as used in an unknown fashion.  */
name|rtx
name|reg
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|reg
argument_list|)
decl_stmt|;
name|int
name|nregs
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
operator|--
name|nregs
operator|>=
literal|0
condition|)
name|reg_state
index|[
name|regno
operator|+
name|nregs
index|]
operator|.
name|use_index
operator|=
operator|-
literal|1
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|CLOBBER
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
comment|/* No spurious CLOBBERs of pseudo registers may remain.  */
if|if
condition|(
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|PLUS
case|:
comment|/* We are interested in (plus (reg) (const_int)) .  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
break|break;
name|offset
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|REG
case|:
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|use_index
decl_stmt|;
name|int
name|nregs
decl_stmt|;
comment|/* No spurious USEs of pseudo registers may remain.  */
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|abort
argument_list|()
expr_stmt|;
name|nregs
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We can't substitute into multi-hard-reg uses.  */
if|if
condition|(
name|nregs
operator|>
literal|1
condition|)
block|{
while|while
condition|(
operator|--
name|nregs
operator|>=
literal|0
condition|)
name|reg_state
index|[
name|regno
operator|+
name|nregs
index|]
operator|.
name|use_index
operator|=
operator|-
literal|1
expr_stmt|;
return|return;
block|}
comment|/* If this register is already used in some unknown fashion, we 	   can't do anything. 	   If we decrement the index from zero to -1, we can't store more 	   uses, so this register becomes used in an unknown fashion.  */
name|use_index
operator|=
operator|--
name|reg_state
index|[
name|regno
index|]
operator|.
name|use_index
expr_stmt|;
if|if
condition|(
name|use_index
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|use_index
operator|!=
name|RELOAD_COMBINE_MAX_USES
operator|-
literal|1
condition|)
block|{
comment|/* We have found another use for a register that is already 	       used later.  Check if the offsets match; if not, mark the 	       register as used in an unknown fashion.  */
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|offset
argument_list|,
name|reg_state
index|[
name|regno
index|]
operator|.
name|offset
argument_list|)
condition|)
block|{
name|reg_state
index|[
name|regno
index|]
operator|.
name|use_index
operator|=
operator|-
literal|1
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
comment|/* This is the first use of this register we have seen since we 	       marked it as dead.  */
name|reg_state
index|[
name|regno
index|]
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
name|reg_state
index|[
name|regno
index|]
operator|.
name|use_ruid
operator|=
name|reload_combine_ruid
expr_stmt|;
block|}
name|reg_state
index|[
name|regno
index|]
operator|.
name|reg_use
index|[
name|use_index
index|]
operator|.
name|insn
operator|=
name|insn
expr_stmt|;
name|reg_state
index|[
name|regno
index|]
operator|.
name|reg_use
index|[
name|use_index
index|]
operator|.
name|usep
operator|=
name|xp
expr_stmt|;
return|return;
block|}
default|default:
break|break;
block|}
comment|/* Recursively process the components of X.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|reload_combine_note_use
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|reload_combine_note_use
argument_list|(
operator|&
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* See if we can reduce the cost of a constant by replacing a move    with an add.  We track situations in which a register is set to a    constant or to a register plus a constant.  */
end_comment

begin_comment
comment|/* We cannot do our optimization across labels.  Invalidating all the    information about register contents we have would be costly, so we    use move2add_last_label_luid to note where the label is and then    later disable any optimization that would cross it.    reg_offset[n] / reg_base_reg[n] / reg_mode[n] are only valid if    reg_set_luid[n] is greater than last_label_luid[n] .  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|reg_set_luid
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If reg_base_reg[n] is negative, register n has been set to    reg_offset[n] in mode reg_mode[n] .    If reg_base_reg[n] is non-negative, register n has been set to the    sum of reg_offset[n] and the value of register reg_base_reg[n]    before reg_set_luid[n], calculated in mode reg_mode[n] .  */
end_comment

begin_decl_stmt
specifier|static
name|HOST_WIDE_INT
name|reg_offset
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reg_base_reg
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|machine_mode
name|reg_mode
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* move2add_luid is linearily increased while scanning the instructions    from first to last.  It is used to set reg_set_luid in    reload_cse_move2add and move2add_note_store.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|move2add_luid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* move2add_last_label_luid is set whenever a label is found.  Labels    invalidate all previously collected reg_offset data.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|move2add_last_label_luid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Generate a CONST_INT and force it in the range of MODE.  */
end_comment

begin_function
specifier|static
name|HOST_WIDE_INT
name|sext_for_mode
parameter_list|(
name|mode
parameter_list|,
name|value
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|HOST_WIDE_INT
name|value
decl_stmt|;
block|{
name|HOST_WIDE_INT
name|cval
init|=
name|value
operator|&
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|int
name|width
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
comment|/* If MODE is narrower than HOST_WIDE_INT and CVAL is a negative number,      sign extend it.  */
if|if
condition|(
name|width
operator|>
literal|0
operator|&&
name|width
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
name|cval
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
operator|)
operator|!=
literal|0
condition|)
name|cval
operator||=
operator|(
name|HOST_WIDE_INT
operator|)
operator|-
literal|1
operator|<<
name|width
expr_stmt|;
return|return
name|cval
return|;
block|}
end_function

begin_comment
comment|/* ??? We don't know how zero / sign extension is handled, hence we    can't go from a narrower to a wider mode.  */
end_comment

begin_define
define|#
directive|define
name|MODES_OK_FOR_MOVE2ADD
parameter_list|(
name|OUTMODE
parameter_list|,
name|INMODE
parameter_list|)
define|\
value|(GET_MODE_SIZE (OUTMODE) == GET_MODE_SIZE (INMODE) \    || (GET_MODE_SIZE (OUTMODE)<= GET_MODE_SIZE (INMODE) \&& TRULY_NOOP_TRUNCATION (GET_MODE_BITSIZE (OUTMODE), \ 				 GET_MODE_BITSIZE (INMODE))))
end_define

begin_function
specifier|static
name|void
name|reload_cse_move2add
parameter_list|(
name|first
parameter_list|)
name|rtx
name|first
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|reg_set_luid
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|move2add_last_label_luid
operator|=
literal|0
expr_stmt|;
name|move2add_luid
operator|=
literal|2
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|,
name|move2add_luid
operator|++
control|)
block|{
name|rtx
name|pat
decl_stmt|,
name|note
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
block|{
name|move2add_last_label_luid
operator|=
name|move2add_luid
expr_stmt|;
comment|/* We're going to increment move2add_luid twice after a 	     label, so that we can use move2add_last_label_luid + 1 as 	     the luid for constants.  */
name|move2add_luid
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
name|pat
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* For simplicity, we only perform this optimization on 	 straightforward SETs.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|rtx
name|reg
init|=
name|SET_DEST
argument_list|(
name|pat
argument_list|)
decl_stmt|;
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|reg
argument_list|)
decl_stmt|;
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|pat
argument_list|)
decl_stmt|;
comment|/* Check if we have valid information on the contents of this 	     register in the mode of REG.  */
if|if
condition|(
name|reg_set_luid
index|[
name|regno
index|]
operator|>
name|move2add_last_label_luid
operator|&&
name|MODES_OK_FOR_MOVE2ADD
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|reg_mode
index|[
name|regno
index|]
argument_list|)
condition|)
block|{
comment|/* Try to transform (set (REGX) (CONST_INT A)) 				  ... 				  (set (REGX) (CONST_INT B)) 		 to 				  (set (REGX) (CONST_INT A)) 				  ... 				  (set (REGX) (plus (REGX) (CONST_INT B-A)))  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|reg_base_reg
index|[
name|regno
index|]
operator|<
literal|0
condition|)
block|{
name|int
name|success
init|=
literal|0
decl_stmt|;
name|rtx
name|new_src
init|=
name|GEN_INT
argument_list|(
name|sext_for_mode
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|INTVAL
argument_list|(
name|src
argument_list|)
operator|-
name|reg_offset
index|[
name|regno
index|]
argument_list|)
argument_list|)
decl_stmt|;
comment|/* (set (reg) (plus (reg) (const_int 0))) is not canonical; 		     use (set (reg) (reg)) instead. 		     We don't delete this insn, nor do we convert it into a 		     note, to avoid losing register notes or the return 		     value flag.  jump2 already knowns how to get rid of 		     no-op moves.  */
if|if
condition|(
name|new_src
operator|==
name|const0_rtx
condition|)
name|success
operator|=
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rtx_cost
argument_list|(
name|new_src
argument_list|,
name|PLUS
argument_list|)
operator|<
name|rtx_cost
argument_list|(
name|src
argument_list|,
name|SET
argument_list|)
operator|&&
name|have_add2_insn
argument_list|(
name|reg
argument_list|,
name|new_src
argument_list|)
condition|)
name|success
operator|=
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|gen_add2_insn
argument_list|(
name|reg
argument_list|,
name|new_src
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|reg_set_luid
index|[
name|regno
index|]
operator|=
name|move2add_luid
expr_stmt|;
name|reg_mode
index|[
name|regno
index|]
operator|=
name|GET_MODE
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|reg_offset
index|[
name|regno
index|]
operator|=
name|INTVAL
argument_list|(
name|src
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Try to transform (set (REGX) (REGY)) 				  (set (REGX) (PLUS (REGX) (CONST_INT A))) 				  ... 				  (set (REGX) (REGY)) 				  (set (REGX) (PLUS (REGX) (CONST_INT B))) 		 to 				  (REGX) (REGY)) 				  (set (REGX) (PLUS (REGX) (CONST_INT A))) 				  ... 				  (set (REGX) (plus (REGX) (CONST_INT B-A)))  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|REG
operator|&&
name|reg_set_luid
index|[
name|regno
index|]
operator|==
name|reg_set_luid
index|[
name|REGNO
argument_list|(
name|src
argument_list|)
index|]
operator|&&
name|reg_base_reg
index|[
name|regno
index|]
operator|==
name|reg_base_reg
index|[
name|REGNO
argument_list|(
name|src
argument_list|)
index|]
operator|&&
name|MODES_OK_FOR_MOVE2ADD
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|reg_mode
index|[
name|REGNO
argument_list|(
name|src
argument_list|)
index|]
argument_list|)
condition|)
block|{
name|rtx
name|next
init|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|set
init|=
name|NULL_RTX
decl_stmt|;
if|if
condition|(
name|next
condition|)
name|set
operator|=
name|single_set
argument_list|(
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
operator|&&
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|==
name|reg
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|reg
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|rtx
name|src3
init|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|added_offset
init|=
name|INTVAL
argument_list|(
name|src3
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|base_offset
init|=
name|reg_offset
index|[
name|REGNO
argument_list|(
name|src
argument_list|)
index|]
decl_stmt|;
name|HOST_WIDE_INT
name|regno_offset
init|=
name|reg_offset
index|[
name|regno
index|]
decl_stmt|;
name|rtx
name|new_src
init|=
name|GEN_INT
argument_list|(
name|sext_for_mode
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|added_offset
operator|+
name|base_offset
operator|-
name|regno_offset
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|success
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|new_src
operator|==
name|const0_rtx
condition|)
comment|/* See above why we create (set (reg) (reg)) here.  */
name|success
operator|=
name|validate_change
argument_list|(
name|next
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|rtx_cost
argument_list|(
name|new_src
argument_list|,
name|PLUS
argument_list|)
operator|<
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
operator|+
name|rtx_cost
argument_list|(
name|src3
argument_list|,
name|SET
argument_list|)
operator|)
operator|&&
name|have_add2_insn
argument_list|(
name|reg
argument_list|,
name|new_src
argument_list|)
condition|)
name|success
operator|=
name|validate_change
argument_list|(
name|next
argument_list|,
operator|&
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|,
name|gen_add2_insn
argument_list|(
name|reg
argument_list|,
name|new_src
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|insn
operator|=
name|next
expr_stmt|;
name|reg_mode
index|[
name|regno
index|]
operator|=
name|GET_MODE
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|reg_offset
index|[
name|regno
index|]
operator|=
name|sext_for_mode
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|added_offset
operator|+
name|base_offset
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
block|}
block|}
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
block|{
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_INC
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
comment|/* Reset the information about this register.  */
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|reg_set_luid
index|[
name|regno
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|move2add_note_store
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* If this is a CALL_INSN, all call used registers are stored with 	 unknown values.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|call_used_regs
index|[
name|i
index|]
condition|)
comment|/* Reset the information about this register.  */
name|reg_set_luid
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* SET is a SET or CLOBBER that sets DST.    Update reg_set_luid, reg_offset and reg_base_reg accordingly.    Called from reload_cse_move2add via note_stores.  */
end_comment

begin_function
specifier|static
name|void
name|move2add_note_store
parameter_list|(
name|dst
parameter_list|,
name|set
parameter_list|,
name|data
parameter_list|)
name|rtx
name|dst
decl_stmt|,
name|set
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|unsigned
name|int
name|regno
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|dst
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|regno
operator|=
name|subreg_regno_offset
argument_list|(
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|dst
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|dst
argument_list|)
argument_list|)
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|dst
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|dst
argument_list|)
argument_list|)
expr_stmt|;
name|dst
operator|=
name|SUBREG_REG
argument_list|(
name|dst
argument_list|)
expr_stmt|;
block|}
comment|/* Some targets do argument pushes without adding REG_INC notes.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|dst
operator|=
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|POST_INC
operator|||
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|PRE_DEC
operator|||
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|POST_DEC
condition|)
name|reg_set_luid
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|!=
name|REG
condition|)
return|return;
name|regno
operator|+=
name|REGNO
argument_list|(
name|dst
argument_list|)
expr_stmt|;
if|if
condition|(
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|==
literal|1
operator|&&
name|GET_CODE
argument_list|(
name|set
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|!=
name|ZERO_EXTRACT
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|!=
name|SIGN_EXTRACT
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|!=
name|STRICT_LOW_PART
condition|)
block|{
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
decl_stmt|;
name|rtx
name|base_reg
decl_stmt|;
name|HOST_WIDE_INT
name|offset
decl_stmt|;
name|int
name|base_regno
decl_stmt|;
comment|/* This may be different from mode, if SET_DEST (set) is a 	 SUBREG.  */
name|enum
name|machine_mode
name|dst_mode
init|=
name|GET_MODE
argument_list|(
name|dst
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
condition|)
block|{
case|case
name|PLUS
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|base_reg
operator|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|reg_set_luid
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
index|]
operator|>
name|move2add_last_label_luid
operator|)
operator|&&
operator|(
name|MODES_OK_FOR_MOVE2ADD
argument_list|(
name|dst_mode
argument_list|,
name|reg_mode
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
index|]
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|reg_base_reg
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
index|]
operator|<
literal|0
condition|)
name|offset
operator|=
name|reg_offset
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
index|]
expr_stmt|;
comment|/* Maybe the first register is known to be a 		     constant.  */
elseif|else
if|if
condition|(
name|reg_set_luid
index|[
name|REGNO
argument_list|(
name|base_reg
argument_list|)
index|]
operator|>
name|move2add_last_label_luid
operator|&&
operator|(
name|MODES_OK_FOR_MOVE2ADD
argument_list|(
name|dst_mode
argument_list|,
name|reg_mode
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
index|]
argument_list|)
operator|)
operator|&&
name|reg_base_reg
index|[
name|REGNO
argument_list|(
name|base_reg
argument_list|)
index|]
operator|<
literal|0
condition|)
block|{
name|offset
operator|=
name|reg_offset
index|[
name|REGNO
argument_list|(
name|base_reg
argument_list|)
index|]
expr_stmt|;
name|base_reg
operator|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
goto|goto
name|invalidate
goto|;
block|}
else|else
goto|goto
name|invalidate
goto|;
break|break;
block|}
goto|goto
name|invalidate
goto|;
case|case
name|REG
case|:
name|base_reg
operator|=
name|src
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CONST_INT
case|:
comment|/* Start tracking the register as a constant.  */
name|reg_base_reg
index|[
name|regno
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|reg_offset
index|[
name|regno
index|]
operator|=
name|INTVAL
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We assign the same luid to all registers set to constants.  */
name|reg_set_luid
index|[
name|regno
index|]
operator|=
name|move2add_last_label_luid
operator|+
literal|1
expr_stmt|;
name|reg_mode
index|[
name|regno
index|]
operator|=
name|mode
expr_stmt|;
return|return;
default|default:
name|invalidate
label|:
comment|/* Invalidate the contents of the register.  */
name|reg_set_luid
index|[
name|regno
index|]
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|base_regno
operator|=
name|REGNO
argument_list|(
name|base_reg
argument_list|)
expr_stmt|;
comment|/* If information about the base register is not valid, set it 	 up as a new base register, pretending its value is known 	 starting from the current insn.  */
if|if
condition|(
name|reg_set_luid
index|[
name|base_regno
index|]
operator|<=
name|move2add_last_label_luid
condition|)
block|{
name|reg_base_reg
index|[
name|base_regno
index|]
operator|=
name|base_regno
expr_stmt|;
name|reg_offset
index|[
name|base_regno
index|]
operator|=
literal|0
expr_stmt|;
name|reg_set_luid
index|[
name|base_regno
index|]
operator|=
name|move2add_luid
expr_stmt|;
name|reg_mode
index|[
name|base_regno
index|]
operator|=
name|mode
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|MODES_OK_FOR_MOVE2ADD
argument_list|(
name|dst_mode
argument_list|,
name|reg_mode
index|[
name|base_regno
index|]
argument_list|)
condition|)
goto|goto
name|invalidate
goto|;
name|reg_mode
index|[
name|regno
index|]
operator|=
name|mode
expr_stmt|;
comment|/* Copy base information from our base register.  */
name|reg_set_luid
index|[
name|regno
index|]
operator|=
name|reg_set_luid
index|[
name|base_regno
index|]
expr_stmt|;
name|reg_base_reg
index|[
name|regno
index|]
operator|=
name|reg_base_reg
index|[
name|base_regno
index|]
expr_stmt|;
comment|/* Compute the sum of the offsets or constants.  */
name|reg_offset
index|[
name|regno
index|]
operator|=
name|sext_for_mode
argument_list|(
name|dst_mode
argument_list|,
name|offset
operator|+
name|reg_offset
index|[
name|base_regno
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|int
name|endregno
init|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
name|regno
init|;
name|i
operator|<
name|endregno
condition|;
name|i
operator|++
control|)
comment|/* Reset the information about this register.  */
name|reg_set_luid
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
end_ifdef

begin_function
specifier|static
name|void
name|add_auto_inc_notes
parameter_list|(
name|insn
parameter_list|,
name|x
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|MEM
operator|&&
name|auto_inc_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_INC
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Scan all the operand sub-expressions.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|add_auto_inc_notes
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|add_auto_inc_notes
argument_list|(
name|insn
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Copy EH notes from an insn to its reloads.  */
end_comment

begin_function
specifier|static
name|void
name|copy_eh_notes
parameter_list|(
name|insn
parameter_list|,
name|x
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
name|rtx
name|eh_note
init|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EH_REGION
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
if|if
condition|(
name|eh_note
condition|)
block|{
for|for
control|(
init|;
name|x
operator|!=
literal|0
condition|;
name|x
operator|=
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
control|)
block|{
if|if
condition|(
name|may_trap_p
argument_list|(
name|PATTERN
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|REG_NOTES
argument_list|(
name|x
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_EH_REGION
argument_list|,
name|XEXP
argument_list|(
name|eh_note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* This is used by reload pass, that does emit some instructions after    abnormal calls moving basic block end, but in fact it wants to emit    them on the edge.  Looks for abnormal call edges, find backward the    proper call and fix the damage.      Similar handle instructions throwing exceptions internally.  */
end_comment

begin_function
specifier|static
name|void
name|fixup_abnormal_edges
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|bool
name|inserted
init|=
name|false
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
block|{
name|basic_block
name|bb
init|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|edge
name|e
decl_stmt|;
comment|/* Look for cases we are interested in - an calls or instructions causing          exceptions.  */
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
block|{
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL_CALL
condition|)
break|break;
if|if
condition|(
operator|(
name|e
operator|->
name|flags
operator|&
operator|(
name|EDGE_ABNORMAL
operator||
name|EDGE_EH
operator|)
operator|)
operator|==
operator|(
name|EDGE_ABNORMAL
operator||
name|EDGE_EH
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|e
operator|&&
name|GET_CODE
argument_list|(
name|bb
operator|->
name|end
argument_list|)
operator|!=
name|CALL_INSN
operator|&&
operator|!
name|can_throw_internal
argument_list|(
name|bb
operator|->
name|end
argument_list|)
condition|)
block|{
name|rtx
name|insn
init|=
name|bb
operator|->
name|end
decl_stmt|,
name|stop
init|=
name|NEXT_INSN
argument_list|(
name|bb
operator|->
name|end
argument_list|)
decl_stmt|;
name|rtx
name|next
decl_stmt|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
break|break;
comment|/* Get past the new insns generated. Allow notes, as the insns may 	     be already deleted.  */
while|while
condition|(
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|)
operator|&&
operator|!
name|can_throw_internal
argument_list|(
name|insn
argument_list|)
operator|&&
name|insn
operator|!=
name|bb
operator|->
name|head
condition|)
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|CALL_INSN
operator|&&
operator|!
name|can_throw_internal
argument_list|(
name|insn
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|bb
operator|->
name|end
operator|=
name|insn
expr_stmt|;
name|inserted
operator|=
name|true
expr_stmt|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
while|while
condition|(
name|insn
operator|&&
name|insn
operator|!=
name|stop
condition|)
block|{
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|insert_insn_on_edge
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
name|insn
operator|=
name|next
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|inserted
condition|)
name|commit_edge_insertions
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

