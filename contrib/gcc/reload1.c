begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Reload pseudo regs into hard regs for insns that require hard regs.    Copyright (C) 1987, 88, 89, 92-98, 1999 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"machmode.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"insn-flags.h"
end_include

begin_include
include|#
directive|include
file|"insn-codes.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_if
if|#
directive|if
operator|!
name|defined
name|PREFERRED_STACK_BOUNDARY
operator|&&
name|defined
name|STACK_BOUNDARY
end_if

begin_define
define|#
directive|define
name|PREFERRED_STACK_BOUNDARY
value|STACK_BOUNDARY
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This file contains the reload pass of the compiler, which is    run after register allocation has been done.  It checks that    each insn is valid (operands required to be in registers really    are in registers of the proper class) and fixes up invalid ones    by copying values temporarily into registers for the insns    that need them.     The results of register allocation are described by the vector    reg_renumber; the insns still contain pseudo regs, but reg_renumber    can be used to find which hard reg, if any, a pseudo reg is in.     The technique we always use is to free up a few hard regs that are    called ``reload regs'', and for each place where a pseudo reg    must be in a hard reg, copy it temporarily into one of the reload regs.     Reload regs are allocated locally for every instruction that needs    reloads.  When there are pseudos which are allocated to a register that    has been chosen as a reload reg, such pseudos must be ``spilled''.    This means that they go to other hard regs, or to stack slots if no other    available hard regs can be found.  Spilling can invalidate more    insns, requiring additional need for reloads, so we must keep checking    until the process stabilizes.     For machines with different classes of registers, we must keep track    of the register class needed for each reload, and make sure that    we allocate enough reload registers of each class.     The file reload.c contains the code that checks one insn for    validity and reports the reloads that it needs.  This file    is in charge of scanning the entire rtl code, accumulating the    reload needs, spilling, assigning reload registers to use for    fixing up each insn, and generating the new insns to copy values    into the reload registers.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|REGISTER_MOVE_COST
end_ifndef

begin_define
define|#
directive|define
name|REGISTER_MOVE_COST
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* During reload_as_needed, element N contains a REG rtx for the hard reg    into which reg N has been reloaded (perhaps for a previous insn).  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|reg_last_reload_reg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Elt N nonzero if reg_last_reload_reg[N] has been set in this insn    for an output reload that stores into reg N.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|reg_has_output_reload
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indicates which hard regs are reload-registers for an output reload    in the current insn.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|reg_is_output_reload
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element N is the constant value to which pseudo reg N is equivalent,    or zero if pseudo reg N is not equivalent to a constant.    find_reloads looks at this in order to replace pseudo reg N    with the constant it stands for.  */
end_comment

begin_decl_stmt
name|rtx
modifier|*
name|reg_equiv_constant
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element N is a memory location to which pseudo reg N is equivalent,    prior to any register elimination (such as frame pointer to stack    pointer).  Depending on whether or not it is a valid address, this value    is transferred to either reg_equiv_address or reg_equiv_mem.  */
end_comment

begin_decl_stmt
name|rtx
modifier|*
name|reg_equiv_memory_loc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element N is the address of stack slot to which pseudo reg N is equivalent.    This is used when the address is not valid as a memory address    (because its displacement is too big for the machine.)  */
end_comment

begin_decl_stmt
name|rtx
modifier|*
name|reg_equiv_address
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element N is the memory slot to which pseudo reg N is equivalent,    or zero if pseudo reg N is not equivalent to a memory slot.  */
end_comment

begin_decl_stmt
name|rtx
modifier|*
name|reg_equiv_mem
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Widest width in which each pseudo reg is referred to (via subreg).  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|reg_max_ref_width
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element N is the list of insns that initialized reg N from its equivalent    constant or memory slot.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|reg_equiv_init
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Vector to remember old contents of reg_renumber before spilling.  */
end_comment

begin_decl_stmt
specifier|static
name|short
modifier|*
name|reg_old_renumber
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* During reload_as_needed, element N contains the last pseudo regno reloaded    into hard register N.  If that pseudo reg occupied more than one register,    reg_reloaded_contents points to that pseudo for each spill register in    use; all of these must remain set for an inheritance to occur.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|reg_reloaded_contents
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* During reload_as_needed, element N contains the insn for which    hard register N was last used.   Its contents are significant only    when reg_reloaded_valid is set for this register.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|reg_reloaded_insn
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indicate if reg_reloaded_insn / reg_reloaded_contents is valid */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|reg_reloaded_valid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indicate if the register was dead at the end of the reload.    This is only valid if reg_reloaded_contents is set and valid.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|reg_reloaded_dead
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of spill-regs so far; number of valid elements of spill_regs.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|n_spills
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* In parallel with spill_regs, contains REG rtx's for those regs.    Holds the last rtx used for any given reg, or 0 if it has never    been used for spilling yet.  This rtx is reused, provided it has    the proper mode.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|spill_reg_rtx
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* In parallel with spill_regs, contains nonzero for a spill reg    that was stored after the last time it was used.    The precise value is the insn generated to do the store.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|spill_reg_store
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the register that was stored with spill_reg_store.  This is a    copy of reload_out / reload_out_reg when the value was stored; if    reload_out is a MEM, spill_reg_stored_to will be set to reload_out_reg.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|spill_reg_stored_to
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This table is the inverse mapping of spill_regs:    indexed by hard reg number,    it contains the position of that reg in spill_regs,    or -1 for something that is not in spill_regs.      ?!?  This is no longer accurate.  */
end_comment

begin_decl_stmt
specifier|static
name|short
name|spill_reg_order
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This reg set indicates registers that can't be used as spill registers for    the currently processed insn.  These are the hard registers which are live    during the insn, but not allocated to pseudos, as well as fixed    registers.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|bad_spill_regs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These are the hard registers that can't be used as spill register for any    insn.  This includes registers used for user variables and registers that    we can't eliminate.  A register that appears in this set also can't be used    to retry register allocation.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|bad_spill_regs_global
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Describes order of use of registers for reloading    of spilled pseudo-registers.  `n_spills' is the number of    elements that are actually valid; new ones are added at the end.     Both spill_regs and spill_reg_order are used on two occasions:    once during find_reload_regs, where they keep track of the spill registers    for a single insn, but also during reload_as_needed where they show all    the registers ever used by reload.  For the latter case, the information    is calculated during finish_spills.  */
end_comment

begin_decl_stmt
specifier|static
name|short
name|spill_regs
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This vector of reg sets indicates, for each pseudo, which hard registers    may not be used for retrying global allocation because the register was    formerly spilled from one of them.  If we allowed reallocating a pseudo to    a register that it was already allocated to, reload might not    terminate.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
modifier|*
name|pseudo_previous_regs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This vector of reg sets indicates, for each pseudo, which hard    registers may not be used for retrying global allocation because they    are used as spill registers during one of the insns in which the    pseudo is live.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
modifier|*
name|pseudo_forbidden_regs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* All hard regs that have been used as spill registers for any insn are    marked in this set.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|used_spill_regs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index of last register assigned as a spill register.  We allocate in    a round-robin fashion.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|last_spill_reg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Describes order of preference for putting regs into spill_regs.    Contains the numbers of all the hard regs, in order most preferred first.    This order is different for each function.    It is set up by order_regs_for_reload.    Empty elements at the end contain -1.  */
end_comment

begin_decl_stmt
specifier|static
name|short
name|potential_reload_regs
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if indirect addressing is supported on the machine; this means    that spilling (REG n) does not require reloading it into a register in    order to do (MEM (REG n)) or (MEM (PLUS (REG n) (CONST_INT c))).  The    value indicates the level of indirect addressing supported, e.g., two    means that (MEM (MEM (REG n))) is also valid if (REG n) does not get    a hard register.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|spill_indirect_levels
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if indirect addressing is supported when the innermost MEM is    of the form (MEM (SYMBOL_REF sym)).  It is assumed that the level to    which these are valid is the same as spill_indirect_levels, above.   */
end_comment

begin_decl_stmt
name|char
name|indirect_symref_ok
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if an address (plus (reg frame_pointer) (reg ...)) is valid.  */
end_comment

begin_decl_stmt
name|char
name|double_reg_address_ok
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record the stack slot for each spilled hard register.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|spill_stack_slot
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Width allocated so far for that stack slot.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|spill_stack_slot_width
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record which pseudos needed to be spilled.  */
end_comment

begin_decl_stmt
specifier|static
name|regset
name|spilled_pseudos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* First uid used by insns created by reload in this function.    Used in find_equiv_reg.  */
end_comment

begin_decl_stmt
name|int
name|reload_first_uid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag set by local-alloc or global-alloc if anything is live in    a call-clobbered reg across calls.  */
end_comment

begin_decl_stmt
name|int
name|caller_save_needed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to 1 while reload_as_needed is operating.    Required by some machines to handle any generated moves differently.  */
end_comment

begin_decl_stmt
name|int
name|reload_in_progress
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These arrays record the insn_code of insns that may be needed to    perform input and output reloads of special objects.  They provide a    place to pass a scratch register.  */
end_comment

begin_decl_stmt
name|enum
name|insn_code
name|reload_in_optab
index|[
name|NUM_MACHINE_MODES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|insn_code
name|reload_out_optab
index|[
name|NUM_MACHINE_MODES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This obstack is used for allocation of rtl during register elimination.    The allocated storage can be freed once find_reloads has processed the    insn.  */
end_comment

begin_decl_stmt
name|struct
name|obstack
name|reload_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Points to the beginning of the reload_obstack.  All insn_chain structures    are allocated first.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|reload_startobj
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The point after all insn_chain structures.  Used to quickly deallocate    memory used while processing one insn.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|reload_firstobj
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_comment
comment|/* List of labels that must never be deleted.  */
end_comment

begin_decl_stmt
specifier|extern
name|rtx
name|forced_labels
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of insn_chain instructions, one for every insn that reload needs to    examine.  */
end_comment

begin_decl_stmt
name|struct
name|insn_chain
modifier|*
name|reload_insn_chain
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|TREE_CODE
end_ifdef

begin_decl_stmt
specifier|extern
name|tree
name|current_function_decl
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|extern
name|union
name|tree_node
modifier|*
name|current_function_decl
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* List of all insns needing reloads.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|insn_chain
modifier|*
name|insns_need_reload
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* This structure is used to record information about register eliminations.    Each array entry describes one possible way of eliminating a register    in favor of another.   If there is more than one way of eliminating a    particular register, the most preferred should be specified first.  */
end_comment

begin_struct
struct|struct
name|elim_table
block|{
name|int
name|from
decl_stmt|;
comment|/* Register number to be eliminated.  */
name|int
name|to
decl_stmt|;
comment|/* Register number used as replacement.  */
name|int
name|initial_offset
decl_stmt|;
comment|/* Initial difference between values.  */
name|int
name|can_eliminate
decl_stmt|;
comment|/* Non-zero if this elimination can be done.  */
name|int
name|can_eliminate_previous
decl_stmt|;
comment|/* Value of CAN_ELIMINATE in previous scan over 				   insns made by reload.  */
name|int
name|offset
decl_stmt|;
comment|/* Current offset between the two regs.  */
name|int
name|previous_offset
decl_stmt|;
comment|/* Offset at end of previous insn.  */
name|int
name|ref_outside_mem
decl_stmt|;
comment|/* "to" has been referenced outside a MEM.  */
name|rtx
name|from_rtx
decl_stmt|;
comment|/* REG rtx for the register to be eliminated. 				   We cannot simply compare the number since 				   we might then spuriously replace a hard 				   register corresponding to a pseudo 				   assigned to the reg to be eliminated.  */
name|rtx
name|to_rtx
decl_stmt|;
comment|/* REG rtx for the replacement.  */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|elim_table
modifier|*
name|reg_eliminate
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is an intermediate structure to initialize the table.  It has    exactly the members provided by ELIMINABLE_REGS. */
end_comment

begin_struct
specifier|static
struct|struct
name|elim_table_1
block|{
name|int
name|from
decl_stmt|;
name|int
name|to
decl_stmt|;
block|}
name|reg_eliminate_1
index|[]
init|=
comment|/* If a set of eliminable registers was specified, define the table from it.    Otherwise, default to the normal case of the frame pointer being    replaced by the stack pointer.  */
ifdef|#
directive|ifdef
name|ELIMINABLE_REGS
name|ELIMINABLE_REGS
struct|;
end_struct

begin_else
else|#
directive|else
end_else

begin_block
block|{
block|{
name|FRAME_POINTER_REGNUM
operator|,
name|STACK_POINTER_REGNUM
block|}
block|}
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|NUM_ELIMINABLE_REGS
value|(sizeof reg_eliminate_1/sizeof reg_eliminate_1[0])
end_define

begin_comment
comment|/* Record the number of pending eliminations that have an offset not equal    to their initial offset.  If non-zero, we use a new copy of each    replacement result in any insns encountered.  */
end_comment

begin_decl_stmt
name|int
name|num_not_at_initial_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Count the number of registers that we may be able to eliminate.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|num_eliminable
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* And the number of registers that are equivalent to a constant that    can be eliminated to frame_pointer / arg_pointer + constant.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|num_eliminable_invariants
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For each label, we record the offset of each elimination.  If we reach    a label by more than one path and an offset differs, we cannot do the    elimination.  This information is indexed by the number of the label.    The first table is an array of flags that records whether we have yet    encountered a label and the second table is an array of arrays, one    entry in the latter array for each elimination.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|offsets_known_at
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|int
argument_list|(
operator|*
name|offsets_at
argument_list|)
index|[
name|NUM_ELIMINABLE_REGS
index|]
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Number of labels in the current function.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|num_labels
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|hard_reg_n_uses
block|{
name|int
name|regno
decl_stmt|;
name|unsigned
name|int
name|uses
decl_stmt|;
block|}
struct|;
end_struct

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|void
name|maybe_fix_stack_asms
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|calculate_needs_all_insns
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|calculate_needs
name|PROTO
argument_list|(
operator|(
expr|struct
name|insn_chain
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|find_reload_regs
name|PROTO
argument_list|(
operator|(
expr|struct
name|insn_chain
operator|*
name|chain
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|find_tworeg_group
name|PROTO
argument_list|(
operator|(
expr|struct
name|insn_chain
operator|*
operator|,
name|int
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|find_group
name|PROTO
argument_list|(
operator|(
expr|struct
name|insn_chain
operator|*
operator|,
name|int
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|possible_group_p
name|PROTO
argument_list|(
operator|(
expr|struct
name|insn_chain
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|count_possible_groups
name|PROTO
argument_list|(
operator|(
expr|struct
name|insn_chain
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|modes_equiv_for_class_p
name|PROTO
argument_list|(
operator|(
expr|enum
name|machine_mode
operator|,
expr|enum
name|machine_mode
operator|,
expr|enum
name|reg_class
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|delete_caller_save_insns
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|spill_failure
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|new_spill_reg
name|PROTO
argument_list|(
operator|(
expr|struct
name|insn_chain
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|maybe_mark_pseudo_spilled
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|delete_dead_insn
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|alter_reg
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_label_offsets
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|eliminate_regs_in_insn
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|update_eliminable_offsets
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_not_eliminable
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_initial_elim_offsets
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|verify_initial_elim_offsets
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_initial_label_offsets
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_offsets_for_label
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_elim_table
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|update_eliminables
name|PROTO
argument_list|(
operator|(
name|HARD_REG_SET
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|spill_hard_reg
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|FILE
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|finish_spills
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ior_hard_reg_set
name|PROTO
argument_list|(
operator|(
name|HARD_REG_SET
operator|*
operator|,
name|HARD_REG_SET
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|scan_paradoxical_subregs
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hard_reg_use_compare
name|PROTO
argument_list|(
operator|(
specifier|const
name|GENERIC_PTR
operator|,
specifier|const
name|GENERIC_PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|count_pseudo
name|PROTO
argument_list|(
operator|(
expr|struct
name|hard_reg_n_uses
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|order_regs_for_reload
name|PROTO
argument_list|(
operator|(
expr|struct
name|insn_chain
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reload_as_needed
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|forget_old_reloads_1
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reload_reg_class_lower
name|PROTO
argument_list|(
operator|(
specifier|const
name|GENERIC_PTR
operator|,
specifier|const
name|GENERIC_PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_reload_reg_in_use
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
expr|enum
name|reload_type
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|clear_reload_reg_in_use
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
expr|enum
name|reload_type
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reload_reg_free_p
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
expr|enum
name|reload_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reload_reg_free_for_value_p
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
expr|enum
name|reload_type
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reload_reg_reaches_end_p
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
expr|enum
name|reload_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|allocate_reload_reg
name|PROTO
argument_list|(
operator|(
expr|struct
name|insn_chain
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|choose_reload_regs
name|PROTO
argument_list|(
operator|(
expr|struct
name|insn_chain
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|merge_assigned_reloads
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|emit_reload_insns
name|PROTO
argument_list|(
operator|(
expr|struct
name|insn_chain
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|delete_output_reload
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|delete_address_reloads
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|delete_address_reloads_1
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|inc_for_reload
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|constraint_accepts_reg_p
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reload_cse_regs_1
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reload_cse_invalidate_regno
name|PROTO
argument_list|(
operator|(
name|int
operator|,
expr|enum
name|machine_mode
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reload_cse_mem_conflict_p
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reload_cse_invalidate_mem
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reload_cse_invalidate_rtx
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reload_cse_regno_equal_p
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|rtx
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reload_cse_noop_set_p
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reload_cse_simplify_set
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reload_cse_simplify_operands
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reload_cse_check_clobber
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reload_cse_record_set
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reload_combine
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reload_combine_note_use
name|PROTO
argument_list|(
operator|(
name|rtx
operator|*
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reload_combine_note_store
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reload_cse_move2add
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|move2add_note_store
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|add_auto_inc_notes
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Initialize the reload pass once per compilation.  */
end_comment

begin_function
name|void
name|init_reload
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Often (MEM (REG n)) is still valid even if (REG n) is put on the stack.      Set spill_indirect_levels to the number of levels such addressing is      permitted, zero if it is not permitted at all.  */
specifier|register
name|rtx
name|tem
init|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|LAST_VIRTUAL_REGISTER
operator|+
literal|1
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|4
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|spill_indirect_levels
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|memory_address_p
argument_list|(
name|QImode
argument_list|,
name|tem
argument_list|)
condition|)
block|{
name|spill_indirect_levels
operator|++
expr_stmt|;
name|tem
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|tem
argument_list|)
expr_stmt|;
block|}
comment|/* See if indirect addressing is valid for (MEM (SYMBOL_REF ...)).  */
name|tem
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
literal|"foo"
argument_list|)
argument_list|)
expr_stmt|;
name|indirect_symref_ok
operator|=
name|memory_address_p
argument_list|(
name|QImode
argument_list|,
name|tem
argument_list|)
expr_stmt|;
comment|/* See if reg+reg is a valid (and offsettable) address.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
name|tem
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|HARD_FRAME_POINTER_REGNUM
argument_list|)
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This way, we make sure that reg+reg is an offsettable address.  */
name|tem
operator|=
name|plus_constant
argument_list|(
name|tem
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|memory_address_p
argument_list|(
name|QImode
argument_list|,
name|tem
argument_list|)
condition|)
block|{
name|double_reg_address_ok
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* Initialize obstack for our rtl allocation.  */
name|gcc_obstack_init
argument_list|(
operator|&
name|reload_obstack
argument_list|)
expr_stmt|;
name|reload_startobj
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|reload_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* List of insn chains that are currently unused.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|insn_chain
modifier|*
name|unused_insn_chains
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Allocate an empty insn_chain structure.  */
end_comment

begin_function
name|struct
name|insn_chain
modifier|*
name|new_insn_chain
parameter_list|()
block|{
name|struct
name|insn_chain
modifier|*
name|c
decl_stmt|;
if|if
condition|(
name|unused_insn_chains
operator|==
literal|0
condition|)
block|{
name|c
operator|=
operator|(
expr|struct
name|insn_chain
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|reload_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|insn_chain
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|->
name|live_before
operator|=
name|OBSTACK_ALLOC_REG_SET
argument_list|(
operator|&
name|reload_obstack
argument_list|)
expr_stmt|;
name|c
operator|->
name|live_after
operator|=
name|OBSTACK_ALLOC_REG_SET
argument_list|(
operator|&
name|reload_obstack
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
name|unused_insn_chains
expr_stmt|;
name|unused_insn_chains
operator|=
name|c
operator|->
name|next
expr_stmt|;
block|}
name|c
operator|->
name|is_caller_save_insn
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|need_operand_change
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|need_reload
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|need_elim
operator|=
literal|0
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/* Small utility function to set all regs in hard reg set TO which are    allocated to pseudos in regset FROM.  */
end_comment

begin_function
name|void
name|compute_use_by_pseudos
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|)
name|HARD_REG_SET
modifier|*
name|to
decl_stmt|;
name|regset
name|from
decl_stmt|;
block|{
name|int
name|regno
decl_stmt|;
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|from
argument_list|,
argument|FIRST_PSEUDO_REGISTER
argument_list|,
argument|regno
argument_list|,
argument|{        int r = reg_renumber[regno];        int nregs;        if (r<
literal|0
argument|) 	 {
comment|/* reload_combine uses the information from 	      BASIC_BLOCK->global_live_at_start, which might still 	      contain registers that have not actually been allocated 	      since they have an equivalence.  */
argument|if (! reload_completed) 	     abort (); 	 }        else 	 { 	   nregs = HARD_REGNO_NREGS (r, PSEUDO_REGNO_MODE (regno)); 	   while (nregs-->
literal|0
argument|) 	     SET_HARD_REG_BIT (*to, r + nregs); 	 }      }
argument_list|)
empty_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Global variables used by reload and its subroutines.  */
end_comment

begin_comment
comment|/* Set during calculate_needs if an insn needs register elimination.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|something_needs_elimination
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set during calculate_needs if an insn needs an operand changed.  */
end_comment

begin_decl_stmt
name|int
name|something_needs_operands_changed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means we couldn't get enough spill regs.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|failure
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Main entry point for the reload pass.     FIRST is the first insn of the function being compiled.     GLOBAL nonzero means we were called from global_alloc    and should attempt to reallocate any pseudoregs that we    displace from hard regs we will use for reloads.    If GLOBAL is zero, we do not have enough information to do that,    so any pseudo reg that is spilled must go to the stack.     DUMPFILE is the global-reg debugging dump file stream, or 0.    If it is nonzero, messages are written to it to describe    which registers are seized as reload regs, which pseudo regs    are spilled from them, and where the pseudo regs are reallocated to.     Return value is nonzero if reload failed    and we must not do any more for this function.  */
end_comment

begin_function
name|int
name|reload
parameter_list|(
name|first
parameter_list|,
name|global
parameter_list|,
name|dumpfile
parameter_list|)
name|rtx
name|first
decl_stmt|;
name|int
name|global
decl_stmt|;
name|FILE
modifier|*
name|dumpfile
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|rtx
name|insn
decl_stmt|;
specifier|register
name|struct
name|elim_table
modifier|*
name|ep
decl_stmt|;
comment|/* The two pointers used to track the true location of the memory used      for label offsets.  */
name|char
modifier|*
name|real_known_ptr
init|=
name|NULL_PTR
decl_stmt|;
name|int
argument_list|(
operator|*
name|real_at_ptr
argument_list|)
index|[
name|NUM_ELIMINABLE_REGS
index|]
expr_stmt|;
comment|/* Make sure even insns with volatile mem refs are recognizable.  */
name|init_recog
argument_list|()
expr_stmt|;
name|failure
operator|=
literal|0
expr_stmt|;
name|reload_firstobj
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|reload_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Make sure that the last insn in the chain      is not something that needs reloading.  */
name|emit_note
argument_list|(
name|NULL_PTR
argument_list|,
name|NOTE_INSN_DELETED
argument_list|)
expr_stmt|;
comment|/* Enable find_equiv_reg to distinguish insns made by reload.  */
name|reload_first_uid
operator|=
name|get_max_uid
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|SECONDARY_MEMORY_NEEDED
comment|/* Initialize the secondary memory table.  */
name|clear_secondary_mem
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* We don't have a stack slot for any spill reg yet.  */
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|spill_stack_slot
argument_list|,
sizeof|sizeof
name|spill_stack_slot
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|spill_stack_slot_width
argument_list|,
sizeof|sizeof
name|spill_stack_slot_width
argument_list|)
expr_stmt|;
comment|/* Initialize the save area information for caller-save, in case some      are needed.  */
name|init_save_areas
argument_list|()
expr_stmt|;
comment|/* Compute which hard registers are now in use      as homes for pseudo registers.      This is done here rather than (eg) in global_alloc      because this point is reached even if not optimizing.  */
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
name|mark_home_live
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* A function that receives a nonlocal goto must save all call-saved      registers.  */
if|if
condition|(
name|current_function_has_nonlocal_label
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|call_used_regs
index|[
name|i
index|]
operator|&&
operator|!
name|fixed_regs
index|[
name|i
index|]
condition|)
name|regs_ever_live
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Find all the pseudo registers that didn't get hard regs      but do have known equivalent constants or memory slots.      These include parameters (known equivalent to parameter slots)      and cse'd or loop-moved constant memory addresses.       Record constant equivalents in reg_equiv_constant      so they will be substituted by find_reloads.      Record memory equivalents in reg_mem_equiv so they can      be substituted eventually by altering the REG-rtx's.  */
name|reg_equiv_constant
operator|=
operator|(
name|rtx
operator|*
operator|)
name|xmalloc
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_equiv_constant
argument_list|,
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|reg_equiv_memory_loc
operator|=
operator|(
name|rtx
operator|*
operator|)
name|xmalloc
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_equiv_memory_loc
argument_list|,
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|reg_equiv_mem
operator|=
operator|(
name|rtx
operator|*
operator|)
name|xmalloc
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_equiv_mem
argument_list|,
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|reg_equiv_init
operator|=
operator|(
name|rtx
operator|*
operator|)
name|xmalloc
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_equiv_init
argument_list|,
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|reg_equiv_address
operator|=
operator|(
name|rtx
operator|*
operator|)
name|xmalloc
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_equiv_address
argument_list|,
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|reg_max_ref_width
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_max_ref_width
argument_list|,
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|reg_old_renumber
operator|=
operator|(
name|short
operator|*
operator|)
name|xmalloc
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|PTR
operator|)
name|reg_renumber
argument_list|,
operator|(
name|PTR
operator|)
name|reg_old_renumber
argument_list|,
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|pseudo_forbidden_regs
operator|=
operator|(
name|HARD_REG_SET
operator|*
operator|)
name|xmalloc
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|HARD_REG_SET
argument_list|)
argument_list|)
expr_stmt|;
name|pseudo_previous_regs
operator|=
operator|(
name|HARD_REG_SET
operator|*
operator|)
name|xmalloc
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|HARD_REG_SET
argument_list|)
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|bad_spill_regs_global
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pseudo_previous_regs
argument_list|,
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|HARD_REG_SET
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Look for REG_EQUIV notes; record what each pseudo is equivalent to.      Also find all paradoxical subregs and find largest such for each pseudo.      On machines with small register classes, record hard registers that      are used for user variables.  These can never be used for spills.       Also look for a "constant" NOTE_INSN_SETJMP.  This means that all      caller-saved registers must be marked live.  */
name|num_eliminable_invariants
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|CONST_CALL_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_SETJMP
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|call_used_regs
index|[
name|i
index|]
condition|)
name|regs_ever_live
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|set
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUIV
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
if|if
condition|(
name|note
ifdef|#
directive|ifdef
name|LEGITIMATE_PIC_OPERAND_P
operator|&&
operator|(
operator|!
name|function_invariant_p
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
operator|!
name|flag_pic
operator|||
name|LEGITIMATE_PIC_OPERAND_P
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
endif|#
directive|endif
condition|)
block|{
name|rtx
name|x
init|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|i
operator|=
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|LAST_VIRTUAL_REGISTER
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
block|{
comment|/* If the operand is a PLUS, the MEM may be shared, 			 so make sure we have an unshared copy here.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
name|x
operator|=
name|copy_rtx
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|reg_equiv_memory_loc
index|[
name|i
index|]
operator|=
name|x
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|function_invariant_p
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
condition|)
block|{
comment|/* This is PLUS of frame pointer and a constant, 			     and might be shared.  Unshare it.  */
name|reg_equiv_constant
index|[
name|i
index|]
operator|=
name|copy_rtx
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|num_eliminable_invariants
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|==
name|frame_pointer_rtx
operator|||
name|x
operator|==
name|arg_pointer_rtx
condition|)
block|{
name|reg_equiv_constant
index|[
name|i
index|]
operator|=
name|x
expr_stmt|;
name|num_eliminable_invariants
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|LEGITIMATE_CONSTANT_P
argument_list|(
name|x
argument_list|)
condition|)
name|reg_equiv_constant
index|[
name|i
index|]
operator|=
name|x
expr_stmt|;
else|else
name|reg_equiv_memory_loc
index|[
name|i
index|]
operator|=
name|force_const_mem
argument_list|(
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
else|else
continue|continue;
comment|/* If this register is being made equivalent to a MEM 		     and the MEM is not SET_SRC, the equivalencing insn 		     is one with the MEM as a SET_DEST and it occurs later. 		     So don't mark this insn now.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
operator|||
name|rtx_equal_p
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|x
argument_list|)
condition|)
name|reg_equiv_init
index|[
name|i
index|]
operator|=
name|gen_rtx_INSN_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|insn
argument_list|,
name|reg_equiv_init
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* If this insn is setting a MEM from a register equivalent to it, 	 this is the equivalencing insn.  */
elseif|else
if|if
condition|(
name|set
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|reg_equiv_memory_loc
index|[
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
index|]
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|reg_equiv_memory_loc
index|[
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
index|]
argument_list|)
condition|)
name|reg_equiv_init
index|[
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
index|]
operator|=
name|gen_rtx_INSN_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|insn
argument_list|,
name|reg_equiv_init
index|[
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
name|scan_paradoxical_subregs
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|init_elim_table
argument_list|()
expr_stmt|;
name|num_labels
operator|=
name|max_label_num
argument_list|()
operator|-
name|get_first_label_num
argument_list|()
expr_stmt|;
comment|/* Allocate the tables used to store offset information at labels.  */
comment|/* We used to use alloca here, but the size of what it would try to      allocate would occasionally cause it to exceed the stack limit and      cause a core dump.  */
name|real_known_ptr
operator|=
name|xmalloc
argument_list|(
name|num_labels
argument_list|)
expr_stmt|;
name|real_at_ptr
operator|=
operator|(
name|int
argument_list|(
operator|*
argument_list|)
index|[
name|NUM_ELIMINABLE_REGS
index|]
operator|)
name|xmalloc
argument_list|(
name|num_labels
operator|*
name|NUM_ELIMINABLE_REGS
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|offsets_known_at
operator|=
name|real_known_ptr
operator|-
name|get_first_label_num
argument_list|()
expr_stmt|;
name|offsets_at
operator|=
operator|(
name|int
argument_list|(
operator|*
argument_list|)
index|[
name|NUM_ELIMINABLE_REGS
index|]
operator|)
operator|(
name|real_at_ptr
operator|-
name|get_first_label_num
argument_list|()
operator|)
expr_stmt|;
comment|/* Alter each pseudo-reg rtx to contain its hard reg number.      Assign stack slots to the pseudos that lack hard regs or equivalents.      Do not touch virtual registers.  */
for|for
control|(
name|i
operator|=
name|LAST_VIRTUAL_REGISTER
operator|+
literal|1
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
name|alter_reg
argument_list|(
name|i
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* If we have some registers we think can be eliminated, scan all insns to      see if there is an insn that sets one of these registers to something      other than itself plus a constant.  If so, the register cannot be      eliminated.  Doing this scan here eliminates an extra pass through the      main reload loop in the most common case where register elimination      cannot be done.  */
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
operator|&&
name|num_eliminable
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|mark_not_eliminable
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|REGISTER_CONSTRAINTS
comment|/* If all the pseudo regs have hard regs,      except for those that are never referenced,      we know that no reloads are needed.  */
comment|/* But that is not true if there are register constraints, since      in that case some pseudos might be in the wrong kind of hard reg.  */
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reg_renumber
index|[
name|i
index|]
operator|==
operator|-
literal|1
operator|&&
name|REG_N_REFS
argument_list|(
name|i
argument_list|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|max_regno
operator|&&
name|num_eliminable
operator|==
literal|0
operator|&&
operator|!
name|caller_save_needed
condition|)
block|{
name|free
argument_list|(
name|real_known_ptr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|real_at_ptr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reg_equiv_constant
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reg_equiv_memory_loc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reg_equiv_mem
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reg_equiv_init
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reg_equiv_address
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reg_max_ref_width
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reg_old_renumber
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pseudo_previous_regs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pseudo_forbidden_regs
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
name|maybe_fix_stack_asms
argument_list|()
expr_stmt|;
name|insns_need_reload
operator|=
literal|0
expr_stmt|;
name|something_needs_elimination
operator|=
literal|0
expr_stmt|;
comment|/* Initialize to -1, which means take the first spill register.  */
name|last_spill_reg
operator|=
operator|-
literal|1
expr_stmt|;
name|spilled_pseudos
operator|=
name|ALLOCA_REG_SET
argument_list|()
expr_stmt|;
comment|/* Spill any hard regs that we know we can't eliminate.  */
name|CLEAR_HARD_REG_SET
argument_list|(
name|used_spill_regs
argument_list|)
expr_stmt|;
for|for
control|(
name|ep
operator|=
name|reg_eliminate
init|;
name|ep
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|ep
operator|++
control|)
if|if
condition|(
operator|!
name|ep
operator|->
name|can_eliminate
condition|)
name|spill_hard_reg
argument_list|(
name|ep
operator|->
name|from
argument_list|,
name|dumpfile
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
name|HARD_FRAME_POINTER_REGNUM
operator|!=
name|FRAME_POINTER_REGNUM
if|if
condition|(
name|frame_pointer_needed
condition|)
name|spill_hard_reg
argument_list|(
name|HARD_FRAME_POINTER_REGNUM
argument_list|,
name|dumpfile
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|finish_spills
argument_list|(
name|global
argument_list|,
name|dumpfile
argument_list|)
expr_stmt|;
comment|/* From now on, we may need to generate moves differently.  We may also      allow modifications of insns which cause them to not be recognized.      Any such modifications will be cleaned up during reload itself.  */
name|reload_in_progress
operator|=
literal|1
expr_stmt|;
comment|/* This loop scans the entire function each go-round      and repeats until one repetition spills no additional hard regs.  */
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|something_changed
decl_stmt|;
name|int
name|did_spill
decl_stmt|;
name|struct
name|insn_chain
modifier|*
name|chain
decl_stmt|;
name|HOST_WIDE_INT
name|starting_frame_size
decl_stmt|;
comment|/* Round size of stack frame to BIGGEST_ALIGNMENT.  This must be done 	 here because the stack size may be a part of the offset computation 	 for register elimination, and there might have been new stack slots 	 created in the last iteration of this loop.   */
name|assign_stack_local
argument_list|(
name|BLKmode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|starting_frame_size
operator|=
name|get_frame_size
argument_list|()
expr_stmt|;
name|set_initial_elim_offsets
argument_list|()
expr_stmt|;
name|set_initial_label_offsets
argument_list|()
expr_stmt|;
comment|/* For each pseudo register that has an equivalent location defined, 	 try to eliminate any eliminable registers (such as the frame pointer) 	 assuming initial offsets for the replacement register, which 	 is the normal case.  	 If the resulting location is directly addressable, substitute 	 the MEM we just got directly for the old REG.  	 If it is not addressable but is a constant or the sum of a hard reg 	 and constant, it is probably not addressable because the constant is 	 out of range, in that case record the address; we will generate 	 hairy code to compute the address in a register each time it is 	 needed.  Similarly if it is a hard register, but one that is not 	 valid as an address register.  	 If the location is not addressable, but does not have one of the 	 above forms, assign a stack slot.  We have to do this to avoid the 	 potential of producing lots of reloads if, e.g., a location involves 	 a pseudo that didn't get a hard register and has an equivalent memory 	 location that also involves a pseudo that didn't get a hard register.  	 Perhaps at some point we will improve reload_when_needed handling 	 so this problem goes away.  But that's very hairy.  */
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reg_renumber
index|[
name|i
index|]
operator|<
literal|0
operator|&&
name|reg_equiv_memory_loc
index|[
name|i
index|]
condition|)
block|{
name|rtx
name|x
init|=
name|eliminate_regs
argument_list|(
name|reg_equiv_memory_loc
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
if|if
condition|(
name|strict_memory_address_p
argument_list|(
name|GET_MODE
argument_list|(
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|reg_equiv_mem
index|[
name|i
index|]
operator|=
name|x
operator|,
name|reg_equiv_address
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
name|reg_equiv_address
index|[
name|i
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|,
name|reg_equiv_mem
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* Make a new stack slot.  Then indicate that something 		   changed so we go back and recompute offsets for 		   eliminable registers because the allocation of memory 		   below might change some offset.  reg_equiv_{mem,address} 		   will be set up for this pseudo on the next pass around 		   the loop.  */
name|reg_equiv_memory_loc
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|reg_equiv_init
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|alter_reg
argument_list|(
name|i
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|caller_save_needed
condition|)
name|setup_save_areas
argument_list|()
expr_stmt|;
comment|/* If we allocated another stack slot, redo elimination bookkeeping.  */
if|if
condition|(
name|starting_frame_size
operator|!=
name|get_frame_size
argument_list|()
condition|)
continue|continue;
if|if
condition|(
name|caller_save_needed
condition|)
block|{
name|save_call_clobbered_regs
argument_list|()
expr_stmt|;
comment|/* That might have allocated new insn_chain structures.  */
name|reload_firstobj
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|reload_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|calculate_needs_all_insns
argument_list|(
name|global
argument_list|)
expr_stmt|;
name|CLEAR_REG_SET
argument_list|(
name|spilled_pseudos
argument_list|)
expr_stmt|;
name|did_spill
operator|=
literal|0
expr_stmt|;
name|something_changed
operator|=
literal|0
expr_stmt|;
comment|/* If we allocated any new memory locations, make another pass 	 since it might have changed elimination offsets.  */
if|if
condition|(
name|starting_frame_size
operator|!=
name|get_frame_size
argument_list|()
condition|)
name|something_changed
operator|=
literal|1
expr_stmt|;
block|{
name|HARD_REG_SET
name|to_spill
decl_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|to_spill
argument_list|)
expr_stmt|;
name|update_eliminables
argument_list|(
operator|&
name|to_spill
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|to_spill
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|spill_hard_reg
argument_list|(
name|i
argument_list|,
name|dumpfile
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|did_spill
operator|=
literal|1
expr_stmt|;
comment|/* Regardless of the state of spills, if we previously had 		 a register that we thought we could eliminate, but no can 		 not eliminate, we must run another pass.  		 Consider pseudos which have an entry in reg_equiv_* which 		 reference an eliminable register.  We must make another pass 		 to update reg_equiv_* so that we do not substitute in the 		 old value from when we thought the elimination could be 		 performed.  */
name|something_changed
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|CLEAR_HARD_REG_SET
argument_list|(
name|used_spill_regs
argument_list|)
expr_stmt|;
comment|/* Try to satisfy the needs for each insn.  */
for|for
control|(
name|chain
operator|=
name|insns_need_reload
init|;
name|chain
operator|!=
literal|0
condition|;
name|chain
operator|=
name|chain
operator|->
name|next_need_reload
control|)
name|find_reload_regs
argument_list|(
name|chain
argument_list|,
name|dumpfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|failure
condition|)
goto|goto
name|failed
goto|;
if|if
condition|(
name|insns_need_reload
operator|!=
literal|0
operator|||
name|did_spill
condition|)
name|something_changed
operator||=
name|finish_spills
argument_list|(
name|global
argument_list|,
name|dumpfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|something_changed
condition|)
break|break;
if|if
condition|(
name|caller_save_needed
condition|)
name|delete_caller_save_insns
argument_list|()
expr_stmt|;
block|}
comment|/* If global-alloc was run, notify it of any register eliminations we have      done.  */
if|if
condition|(
name|global
condition|)
for|for
control|(
name|ep
operator|=
name|reg_eliminate
init|;
name|ep
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|ep
operator|++
control|)
if|if
condition|(
name|ep
operator|->
name|can_eliminate
condition|)
name|mark_elimination
argument_list|(
name|ep
operator|->
name|from
argument_list|,
name|ep
operator|->
name|to
argument_list|)
expr_stmt|;
comment|/* If a pseudo has no hard reg, delete the insns that made the equivalence.      If that insn didn't set the register (i.e., it copied the register to      memory), just delete that insn instead of the equivalencing insn plus      anything now dead.  If we call delete_dead_insn on that insn, we may      delete the insn that actually sets the register if the register dies      there and that is incorrect.  */
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|reg_renumber
index|[
name|i
index|]
operator|<
literal|0
operator|&&
name|reg_equiv_init
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|rtx
name|list
decl_stmt|;
for|for
control|(
name|list
operator|=
name|reg_equiv_init
index|[
name|i
index|]
init|;
name|list
condition|;
name|list
operator|=
name|XEXP
argument_list|(
name|list
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|rtx
name|equiv_insn
init|=
name|XEXP
argument_list|(
name|list
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|equiv_insn
argument_list|)
operator|==
name|NOTE
condition|)
continue|continue;
if|if
condition|(
name|reg_set_p
argument_list|(
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|,
name|PATTERN
argument_list|(
name|equiv_insn
argument_list|)
argument_list|)
condition|)
name|delete_dead_insn
argument_list|(
name|equiv_insn
argument_list|)
expr_stmt|;
else|else
block|{
name|PUT_CODE
argument_list|(
name|equiv_insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|equiv_insn
argument_list|)
operator|=
literal|0
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|equiv_insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Use the reload registers where necessary      by generating move instructions to move the must-be-register      values into or out of the reload registers.  */
if|if
condition|(
name|insns_need_reload
operator|!=
literal|0
operator|||
name|something_needs_elimination
operator|||
name|something_needs_operands_changed
condition|)
block|{
name|int
name|old_frame_size
init|=
name|get_frame_size
argument_list|()
decl_stmt|;
name|reload_as_needed
argument_list|(
name|global
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_frame_size
operator|!=
name|get_frame_size
argument_list|()
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|num_eliminable
condition|)
name|verify_initial_elim_offsets
argument_list|()
expr_stmt|;
block|}
comment|/* If we were able to eliminate the frame pointer, show that it is no      longer live at the start of any basic block.  If it ls live by      virtue of being in a pseudo, that pseudo will be marked live      and hence the frame pointer will be known to be live via that      pseudo.  */
if|if
condition|(
operator|!
name|frame_pointer_needed
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
name|CLEAR_REGNO_REG_SET
argument_list|(
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
operator|->
name|global_live_at_start
argument_list|,
name|HARD_FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
comment|/* Come here (with failure set nonzero) if we can't get enough spill regs      and we decide not to abort about it.  */
name|failed
label|:
name|reload_in_progress
operator|=
literal|0
expr_stmt|;
comment|/* Now eliminate all pseudo regs by modifying them into      their equivalent memory references.      The REG-rtx's for the pseudos are modified in place,      so all insns that used to refer to them now refer to memory.       For a reg that has a reg_equiv_address, all those insns      were changed by reloading so that no insns refer to it any longer;      but the DECL_RTL of a variable decl may refer to it,      and if so this causes the debugging info to mention the variable.  */
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|addr
init|=
literal|0
decl_stmt|;
name|int
name|in_struct
init|=
literal|0
decl_stmt|;
name|int
name|is_scalar
decl_stmt|;
name|int
name|is_readonly
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|reg_equiv_memory_loc
index|[
name|i
index|]
condition|)
block|{
name|in_struct
operator|=
name|MEM_IN_STRUCT_P
argument_list|(
name|reg_equiv_memory_loc
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|is_scalar
operator|=
name|MEM_SCALAR_P
argument_list|(
name|reg_equiv_memory_loc
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|is_readonly
operator|=
name|RTX_UNCHANGING_P
argument_list|(
name|reg_equiv_memory_loc
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reg_equiv_mem
index|[
name|i
index|]
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|reg_equiv_mem
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_equiv_address
index|[
name|i
index|]
condition|)
name|addr
operator|=
name|reg_equiv_address
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|addr
condition|)
block|{
if|if
condition|(
name|reg_renumber
index|[
name|i
index|]
operator|<
literal|0
condition|)
block|{
name|rtx
name|reg
init|=
name|regno_reg_rtx
index|[
name|i
index|]
decl_stmt|;
name|XEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
operator|=
name|addr
expr_stmt|;
name|REG_USERVAR_P
argument_list|(
name|reg
argument_list|)
operator|=
literal|0
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|reg
argument_list|)
operator|=
name|is_readonly
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|reg
argument_list|)
operator|=
name|in_struct
expr_stmt|;
name|MEM_SCALAR_P
argument_list|(
name|reg
argument_list|)
operator|=
name|is_scalar
expr_stmt|;
comment|/* We have no alias information about this newly created 		 MEM.  */
name|MEM_ALIAS_SET
argument_list|(
name|reg
argument_list|)
operator|=
literal|0
expr_stmt|;
name|PUT_CODE
argument_list|(
name|reg
argument_list|,
name|MEM
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reg_equiv_mem
index|[
name|i
index|]
condition|)
name|XEXP
argument_list|(
name|reg_equiv_mem
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
operator|=
name|addr
expr_stmt|;
block|}
block|}
comment|/* We must set reload_completed now since the cleanup_subreg_operands call      below will re-recognize each insn and reload may have generated insns      which are only valid during and after reload.  */
name|reload_completed
operator|=
literal|1
expr_stmt|;
comment|/* Make a pass over all the insns and delete all USEs which we      inserted only to tag a REG_EQUAL note on them.  Remove all      REG_DEAD and REG_UNUSED notes.  Delete all CLOBBER insns and      simplify (subreg (reg)) operands.  Also remove all REG_RETVAL and      REG_LIBCALL notes since they are no longer useful or accurate.      Strip and regenerate REG_INC notes that may have been moved      around.  */
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
block|{
name|rtx
modifier|*
name|pnote
decl_stmt|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|USE
operator|&&
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
block|{
name|PUT_CODE
argument_list|(
name|insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
continue|continue;
block|}
name|pnote
operator|=
operator|&
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|pnote
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
operator|*
name|pnote
argument_list|)
operator|==
name|REG_DEAD
operator|||
name|REG_NOTE_KIND
argument_list|(
operator|*
name|pnote
argument_list|)
operator|==
name|REG_UNUSED
operator|||
name|REG_NOTE_KIND
argument_list|(
operator|*
name|pnote
argument_list|)
operator|==
name|REG_INC
operator|||
name|REG_NOTE_KIND
argument_list|(
operator|*
name|pnote
argument_list|)
operator|==
name|REG_RETVAL
operator|||
name|REG_NOTE_KIND
argument_list|(
operator|*
name|pnote
argument_list|)
operator|==
name|REG_LIBCALL
condition|)
operator|*
name|pnote
operator|=
name|XEXP
argument_list|(
operator|*
name|pnote
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|pnote
operator|=
operator|&
name|XEXP
argument_list|(
operator|*
name|pnote
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
name|add_auto_inc_notes
argument_list|(
name|insn
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* And simplify (subreg (reg)) if it appears as an operand.  */
name|cleanup_subreg_operands
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* If we are doing stack checking, give a warning if this function's      frame size is larger than we expect.  */
if|if
condition|(
name|flag_stack_check
operator|&&
operator|!
name|STACK_CHECK_BUILTIN
condition|)
block|{
name|HOST_WIDE_INT
name|size
init|=
name|get_frame_size
argument_list|()
operator|+
name|STACK_CHECK_FIXED_FRAME_SIZE
decl_stmt|;
specifier|static
name|int
name|verbose_warned
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
operator|&&
operator|!
name|fixed_regs
index|[
name|i
index|]
operator|&&
name|call_used_regs
index|[
name|i
index|]
condition|)
name|size
operator|+=
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|STACK_CHECK_MAX_FRAME_SIZE
condition|)
block|{
name|warning
argument_list|(
literal|"frame size too large for reliable stack checking"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|verbose_warned
condition|)
block|{
name|warning
argument_list|(
literal|"try reducing the number of local variables"
argument_list|)
expr_stmt|;
name|verbose_warned
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* Indicate that we no longer have known memory locations or constants.  */
if|if
condition|(
name|reg_equiv_constant
condition|)
name|free
argument_list|(
name|reg_equiv_constant
argument_list|)
expr_stmt|;
name|reg_equiv_constant
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|reg_equiv_memory_loc
condition|)
name|free
argument_list|(
name|reg_equiv_memory_loc
argument_list|)
expr_stmt|;
name|reg_equiv_memory_loc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|real_known_ptr
condition|)
name|free
argument_list|(
name|real_known_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|real_at_ptr
condition|)
name|free
argument_list|(
name|real_at_ptr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reg_equiv_mem
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reg_equiv_init
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reg_equiv_address
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reg_max_ref_width
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reg_old_renumber
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pseudo_previous_regs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pseudo_forbidden_regs
argument_list|)
expr_stmt|;
name|FREE_REG_SET
argument_list|(
name|spilled_pseudos
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|used_spill_regs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_spills
condition|;
name|i
operator|++
control|)
name|SET_HARD_REG_BIT
argument_list|(
name|used_spill_regs
argument_list|,
name|spill_regs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Free all the insn_chain structures at once.  */
name|obstack_free
argument_list|(
operator|&
name|reload_obstack
argument_list|,
name|reload_startobj
argument_list|)
expr_stmt|;
name|unused_insn_chains
operator|=
literal|0
expr_stmt|;
return|return
name|failure
return|;
block|}
end_function

begin_comment
comment|/* Yet another special case.  Unfortunately, reg-stack forces people to    write incorrect clobbers in asm statements.  These clobbers must not    cause the register to appear in bad_spill_regs, otherwise we'll call    fatal_insn later.  We clear the corresponding regnos in the live    register sets to avoid this.    The whole thing is rather sick, I'm afraid.  */
end_comment

begin_function
specifier|static
name|void
name|maybe_fix_stack_asms
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|STACK_REGS
name|char
modifier|*
name|constraints
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|enum
name|machine_mode
name|operand_mode
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|struct
name|insn_chain
modifier|*
name|chain
decl_stmt|;
for|for
control|(
name|chain
operator|=
name|reload_insn_chain
init|;
name|chain
operator|!=
literal|0
condition|;
name|chain
operator|=
name|chain
operator|->
name|next
control|)
block|{
name|int
name|i
decl_stmt|,
name|noperands
decl_stmt|;
name|HARD_REG_SET
name|clobbered
decl_stmt|,
name|allowed
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|chain
operator|->
name|insn
argument_list|)
argument_list|)
operator|!=
literal|'i'
operator|||
operator|(
name|noperands
operator|=
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|chain
operator|->
name|insn
argument_list|)
argument_list|)
operator|)
operator|<
literal|0
condition|)
continue|continue;
name|pat
operator|=
name|PATTERN
argument_list|(
name|chain
operator|->
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|!=
name|PARALLEL
condition|)
continue|continue;
name|CLEAR_HARD_REG_SET
argument_list|(
name|clobbered
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|allowed
argument_list|)
expr_stmt|;
comment|/* First, make a mask of all stack regs that are clobbered.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|t
init|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|CLOBBER
operator|&&
name|STACK_REG_P
argument_list|(
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|clobbered
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Get the operand values and constraints out of the insn.  */
name|decode_asm_operands
argument_list|(
name|pat
argument_list|,
name|recog_operand
argument_list|,
name|recog_operand_loc
argument_list|,
name|constraints
argument_list|,
name|operand_mode
argument_list|)
expr_stmt|;
comment|/* For every operand, see what registers are allowed.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|noperands
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|p
init|=
name|constraints
index|[
name|i
index|]
decl_stmt|;
comment|/* For every alternative, we compute the class of registers allowed 	     for reloading in CLS, and merge its contents into the reg set 	     ALLOWED.  */
name|int
name|cls
init|=
operator|(
name|int
operator|)
name|NO_REGS
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
name|c
init|=
operator|*
name|p
operator|++
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
operator|||
name|c
operator|==
literal|','
operator|||
name|c
operator|==
literal|'#'
condition|)
block|{
comment|/* End of one alternative - mark the regs in the current 		     class, and reset the class.  */
name|IOR_HARD_REG_SET
argument_list|(
name|allowed
argument_list|,
name|reg_class_contents
index|[
name|cls
index|]
argument_list|)
expr_stmt|;
name|cls
operator|=
name|NO_REGS
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'#'
condition|)
do|do
block|{
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|!=
literal|'\0'
operator|&&
name|c
operator|!=
literal|','
condition|)
do|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
break|break;
continue|continue;
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'='
case|:
case|case
literal|'+'
case|:
case|case
literal|'*'
case|:
case|case
literal|'%'
case|:
case|case
literal|'?'
case|:
case|case
literal|'!'
case|:
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'m'
case|:
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
case|case
literal|'V'
case|:
case|case
literal|'o'
case|:
case|case
literal|'&'
case|:
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
case|case
literal|'s'
case|:
case|case
literal|'i'
case|:
case|case
literal|'n'
case|:
case|case
literal|'X'
case|:
case|case
literal|'I'
case|:
case|case
literal|'J'
case|:
case|case
literal|'K'
case|:
case|case
literal|'L'
case|:
case|case
literal|'M'
case|:
case|case
literal|'N'
case|:
case|case
literal|'O'
case|:
case|case
literal|'P'
case|:
ifdef|#
directive|ifdef
name|EXTRA_CONSTRAINT
case|case
literal|'Q'
case|:
case|case
literal|'R'
case|:
case|case
literal|'S'
case|:
case|case
literal|'T'
case|:
case|case
literal|'U'
case|:
endif|#
directive|endif
break|break;
case|case
literal|'p'
case|:
name|cls
operator|=
operator|(
name|int
operator|)
name|reg_class_subunion
index|[
name|cls
index|]
index|[
operator|(
name|int
operator|)
name|BASE_REG_CLASS
index|]
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
case|case
literal|'r'
case|:
name|cls
operator|=
operator|(
name|int
operator|)
name|reg_class_subunion
index|[
name|cls
index|]
index|[
operator|(
name|int
operator|)
name|GENERAL_REGS
index|]
expr_stmt|;
break|break;
default|default:
name|cls
operator|=
operator|(
name|int
operator|)
name|reg_class_subunion
index|[
name|cls
index|]
index|[
operator|(
name|int
operator|)
name|REG_CLASS_FROM_LETTER
argument_list|(
name|c
argument_list|)
index|]
expr_stmt|;
block|}
block|}
block|}
comment|/* Those of the registers which are clobbered, but allowed by the 	 constraints, must be usable as reload registers.  So clear them 	 out of the life information.  */
name|AND_HARD_REG_SET
argument_list|(
name|allowed
argument_list|,
name|clobbered
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|allowed
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|CLEAR_REGNO_REG_SET
argument_list|(
name|chain
operator|->
name|live_before
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|CLEAR_REGNO_REG_SET
argument_list|(
name|chain
operator|->
name|live_after
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Walk the chain of insns, and determine for each whether it needs reloads    and/or eliminations.  Build the corresponding insns_need_reload list, and    set something_needs_elimination as appropriate.  */
end_comment

begin_function
specifier|static
name|void
name|calculate_needs_all_insns
parameter_list|(
name|global
parameter_list|)
name|int
name|global
decl_stmt|;
block|{
name|struct
name|insn_chain
modifier|*
modifier|*
name|pprev_reload
init|=
operator|&
name|insns_need_reload
decl_stmt|;
name|struct
name|insn_chain
modifier|*
modifier|*
name|pchain
decl_stmt|;
name|something_needs_elimination
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|pchain
operator|=
operator|&
name|reload_insn_chain
init|;
operator|*
name|pchain
operator|!=
literal|0
condition|;
name|pchain
operator|=
operator|&
operator|(
operator|*
name|pchain
operator|)
operator|->
name|next
control|)
block|{
name|rtx
name|insn
decl_stmt|;
name|struct
name|insn_chain
modifier|*
name|chain
decl_stmt|;
name|chain
operator|=
operator|*
name|pchain
expr_stmt|;
name|insn
operator|=
name|chain
operator|->
name|insn
expr_stmt|;
comment|/* If this is a label, a JUMP_INSN, or has REG_NOTES (which might 	 include REG_LABEL), we need to see what effects this has on the 	 known offsets at labels.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|||
operator|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|set_label_offsets
argument_list|(
name|insn
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
block|{
name|rtx
name|old_body
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|old_code
init|=
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|old_notes
init|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|did_elimination
init|=
literal|0
decl_stmt|;
name|int
name|operands_changed
init|=
literal|0
decl_stmt|;
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* Skip insns that only set an equivalence.  */
if|if
condition|(
name|set
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|reg_renumber
index|[
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
index|]
operator|<
literal|0
operator|&&
name|reg_equiv_constant
index|[
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
index|]
condition|)
block|{
comment|/* Must clear out the shortcuts, in case they were set last 		 time through.  */
name|chain
operator|->
name|need_elim
operator|=
literal|0
expr_stmt|;
name|chain
operator|->
name|need_reload
operator|=
literal|0
expr_stmt|;
name|chain
operator|->
name|need_operand_change
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
comment|/* If needed, eliminate any eliminable registers.  */
if|if
condition|(
name|num_eliminable
operator|||
name|num_eliminable_invariants
condition|)
name|did_elimination
operator|=
name|eliminate_regs_in_insn
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Analyze the instruction.  */
name|operands_changed
operator|=
name|find_reloads
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|,
name|spill_indirect_levels
argument_list|,
name|global
argument_list|,
name|spill_reg_order
argument_list|)
expr_stmt|;
comment|/* If a no-op set needs more than one reload, this is likely 	     to be something that needs input address reloads.  We 	     can't get rid of this cleanly later, and it is of no use 	     anyway, so discard it now. 	     We only do this when expensive_optimizations is enabled, 	     since this complements reload inheritance / output 	     reload deletion, and it can make debugging harder.  */
if|if
condition|(
name|flag_expensive_optimizations
operator|&&
name|n_reloads
operator|>
literal|1
condition|)
block|{
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|set
operator|&&
name|SET_SRC
argument_list|(
name|set
argument_list|)
operator|==
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|PUT_CODE
argument_list|(
name|insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|num_eliminable
condition|)
name|update_eliminable_offsets
argument_list|()
expr_stmt|;
comment|/* Remember for later shortcuts which insns had any reloads or 	     register eliminations.  */
name|chain
operator|->
name|need_elim
operator|=
name|did_elimination
expr_stmt|;
name|chain
operator|->
name|need_reload
operator|=
name|n_reloads
operator|>
literal|0
expr_stmt|;
name|chain
operator|->
name|need_operand_change
operator|=
name|operands_changed
expr_stmt|;
comment|/* Discard any register replacements done.  */
if|if
condition|(
name|did_elimination
condition|)
block|{
name|obstack_free
argument_list|(
operator|&
name|reload_obstack
argument_list|,
name|reload_firstobj
argument_list|)
expr_stmt|;
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|old_body
expr_stmt|;
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
name|old_code
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|old_notes
expr_stmt|;
name|something_needs_elimination
operator|=
literal|1
expr_stmt|;
block|}
name|something_needs_operands_changed
operator||=
name|operands_changed
expr_stmt|;
if|if
condition|(
name|n_reloads
operator|!=
literal|0
condition|)
block|{
operator|*
name|pprev_reload
operator|=
name|chain
expr_stmt|;
name|pprev_reload
operator|=
operator|&
name|chain
operator|->
name|next_need_reload
expr_stmt|;
name|calculate_needs
argument_list|(
name|chain
argument_list|)
expr_stmt|;
block|}
block|}
block|}
operator|*
name|pprev_reload
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute the most additional registers needed by one instruction,    given by CHAIN.  Collect information separately for each class of regs.     To compute the number of reload registers of each class needed for an    insn, we must simulate what choose_reload_regs can do.  We do this by    splitting an insn into an "input" and an "output" part.  RELOAD_OTHER    reloads are used in both.  The input part uses those reloads,    RELOAD_FOR_INPUT reloads, which must be live over the entire input section    of reloads, and the maximum of all the RELOAD_FOR_INPUT_ADDRESS and    RELOAD_FOR_OPERAND_ADDRESS reloads, which conflict with the inputs.     The registers needed for output are RELOAD_OTHER and RELOAD_FOR_OUTPUT,    which are live for the entire output portion, and the maximum of all the    RELOAD_FOR_OUTPUT_ADDRESS reloads for each operand.     The total number of registers needed is the maximum of the    inputs and outputs.  */
end_comment

begin_function
specifier|static
name|void
name|calculate_needs
parameter_list|(
name|chain
parameter_list|)
name|struct
name|insn_chain
modifier|*
name|chain
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/* Each `struct needs' corresponds to one RELOAD_... type.  */
struct|struct
block|{
name|struct
name|needs
name|other
decl_stmt|;
name|struct
name|needs
name|input
decl_stmt|;
name|struct
name|needs
name|output
decl_stmt|;
name|struct
name|needs
name|insn
decl_stmt|;
name|struct
name|needs
name|other_addr
decl_stmt|;
name|struct
name|needs
name|op_addr
decl_stmt|;
name|struct
name|needs
name|op_addr_reload
decl_stmt|;
name|struct
name|needs
name|in_addr
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|struct
name|needs
name|in_addr_addr
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|struct
name|needs
name|out_addr
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|struct
name|needs
name|out_addr_addr
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
block|}
name|insn_needs
struct|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|chain
operator|->
name|group_size
argument_list|,
sizeof|sizeof
name|chain
operator|->
name|group_size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_REG_CLASSES
condition|;
name|i
operator|++
control|)
name|chain
operator|->
name|group_mode
index|[
name|i
index|]
operator|=
name|VOIDmode
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|insn_needs
argument_list|,
sizeof|sizeof
name|insn_needs
argument_list|)
expr_stmt|;
comment|/* Count each reload once in every class      containing the reload's own class.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_reloads
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|enum
name|reg_class
modifier|*
name|p
decl_stmt|;
name|enum
name|reg_class
name|class
init|=
name|reload_reg_class
index|[
name|i
index|]
decl_stmt|;
name|int
name|size
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|struct
name|needs
modifier|*
name|this_needs
decl_stmt|;
comment|/* Don't count the dummy reloads, for which one of the 	 regs mentioned in the insn can be used for reloading. 	 Don't count optional reloads. 	 Don't count reloads that got combined with others.  */
if|if
condition|(
name|reload_reg_rtx
index|[
name|i
index|]
operator|!=
literal|0
operator|||
name|reload_optional
index|[
name|i
index|]
operator|!=
literal|0
operator|||
operator|(
name|reload_out
index|[
name|i
index|]
operator|==
literal|0
operator|&&
name|reload_in
index|[
name|i
index|]
operator|==
literal|0
operator|&&
operator|!
name|reload_secondary_p
index|[
name|i
index|]
operator|)
condition|)
continue|continue;
name|mode
operator|=
name|reload_inmode
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|reload_outmode
index|[
name|i
index|]
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
condition|)
name|mode
operator|=
name|reload_outmode
index|[
name|i
index|]
expr_stmt|;
name|size
operator|=
name|CLASS_MAX_NREGS
argument_list|(
name|class
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* Decide which time-of-use to count this reload for.  */
switch|switch
condition|(
name|reload_when_needed
index|[
name|i
index|]
condition|)
block|{
case|case
name|RELOAD_OTHER
case|:
name|this_needs
operator|=
operator|&
name|insn_needs
operator|.
name|other
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_INPUT
case|:
name|this_needs
operator|=
operator|&
name|insn_needs
operator|.
name|input
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OUTPUT
case|:
name|this_needs
operator|=
operator|&
name|insn_needs
operator|.
name|output
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_INSN
case|:
name|this_needs
operator|=
operator|&
name|insn_needs
operator|.
name|insn
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OTHER_ADDRESS
case|:
name|this_needs
operator|=
operator|&
name|insn_needs
operator|.
name|other_addr
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_INPUT_ADDRESS
case|:
name|this_needs
operator|=
operator|&
name|insn_needs
operator|.
name|in_addr
index|[
name|reload_opnum
index|[
name|i
index|]
index|]
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_INPADDR_ADDRESS
case|:
name|this_needs
operator|=
operator|&
name|insn_needs
operator|.
name|in_addr_addr
index|[
name|reload_opnum
index|[
name|i
index|]
index|]
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OUTPUT_ADDRESS
case|:
name|this_needs
operator|=
operator|&
name|insn_needs
operator|.
name|out_addr
index|[
name|reload_opnum
index|[
name|i
index|]
index|]
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OUTADDR_ADDRESS
case|:
name|this_needs
operator|=
operator|&
name|insn_needs
operator|.
name|out_addr_addr
index|[
name|reload_opnum
index|[
name|i
index|]
index|]
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OPERAND_ADDRESS
case|:
name|this_needs
operator|=
operator|&
name|insn_needs
operator|.
name|op_addr
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OPADDR_ADDR
case|:
name|this_needs
operator|=
operator|&
name|insn_needs
operator|.
name|op_addr_reload
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|>
literal|1
condition|)
block|{
name|enum
name|machine_mode
name|other_mode
decl_stmt|,
name|allocate_mode
decl_stmt|;
comment|/* Count number of groups needed separately from 	     number of individual regs needed.  */
name|this_needs
operator|->
name|groups
index|[
operator|(
name|int
operator|)
name|class
index|]
operator|++
expr_stmt|;
name|p
operator|=
name|reg_class_superclasses
index|[
operator|(
name|int
operator|)
name|class
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
name|LIM_REG_CLASSES
condition|)
name|this_needs
operator|->
name|groups
index|[
operator|(
name|int
operator|)
operator|*
name|p
operator|++
index|]
operator|++
expr_stmt|;
comment|/* Record size and mode of a group of this class.  */
comment|/* If more than one size group is needed, 	     make all groups the largest needed size.  */
if|if
condition|(
name|chain
operator|->
name|group_size
index|[
operator|(
name|int
operator|)
name|class
index|]
operator|<
name|size
condition|)
block|{
name|other_mode
operator|=
name|chain
operator|->
name|group_mode
index|[
operator|(
name|int
operator|)
name|class
index|]
expr_stmt|;
name|allocate_mode
operator|=
name|mode
expr_stmt|;
name|chain
operator|->
name|group_size
index|[
operator|(
name|int
operator|)
name|class
index|]
operator|=
name|size
expr_stmt|;
name|chain
operator|->
name|group_mode
index|[
operator|(
name|int
operator|)
name|class
index|]
operator|=
name|mode
expr_stmt|;
block|}
else|else
block|{
name|other_mode
operator|=
name|mode
expr_stmt|;
name|allocate_mode
operator|=
name|chain
operator|->
name|group_mode
index|[
operator|(
name|int
operator|)
name|class
index|]
expr_stmt|;
block|}
comment|/* Crash if two dissimilar machine modes both need 	     groups of consecutive regs of the same class.  */
if|if
condition|(
name|other_mode
operator|!=
name|VOIDmode
operator|&&
name|other_mode
operator|!=
name|allocate_mode
operator|&&
operator|!
name|modes_equiv_for_class_p
argument_list|(
name|allocate_mode
argument_list|,
name|other_mode
argument_list|,
name|class
argument_list|)
condition|)
name|fatal_insn
argument_list|(
literal|"Two dissimilar machine modes both need groups of consecutive regs of the same class"
argument_list|,
name|chain
operator|->
name|insn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|==
literal|1
condition|)
block|{
name|this_needs
operator|->
name|regs
index|[
operator|(
name|unsigned
name|char
operator|)
name|reload_nongroup
index|[
name|i
index|]
index|]
index|[
operator|(
name|int
operator|)
name|class
index|]
operator|+=
literal|1
expr_stmt|;
name|p
operator|=
name|reg_class_superclasses
index|[
operator|(
name|int
operator|)
name|class
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
name|LIM_REG_CLASSES
condition|)
name|this_needs
operator|->
name|regs
index|[
operator|(
name|unsigned
name|char
operator|)
name|reload_nongroup
index|[
name|i
index|]
index|]
index|[
operator|(
name|int
operator|)
operator|*
name|p
operator|++
index|]
operator|+=
literal|1
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* All reloads have been counted for this insn;      now merge the various times of use.      This sets insn_needs, etc., to the maximum total number      of registers needed at any point in this insn.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_REG_CLASSES
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|,
name|in_max
decl_stmt|,
name|out_max
decl_stmt|;
comment|/* Compute normal and nongroup needs.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
literal|1
condition|;
name|j
operator|++
control|)
block|{
name|int
name|k
decl_stmt|;
for|for
control|(
name|in_max
operator|=
literal|0
operator|,
name|out_max
operator|=
literal|0
operator|,
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|reload_n_operands
condition|;
name|k
operator|++
control|)
block|{
name|in_max
operator|=
name|MAX
argument_list|(
name|in_max
argument_list|,
operator|(
name|insn_needs
operator|.
name|in_addr
index|[
name|k
index|]
operator|.
name|regs
index|[
name|j
index|]
index|[
name|i
index|]
operator|+
name|insn_needs
operator|.
name|in_addr_addr
index|[
name|k
index|]
operator|.
name|regs
index|[
name|j
index|]
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
name|out_max
operator|=
name|MAX
argument_list|(
name|out_max
argument_list|,
name|insn_needs
operator|.
name|out_addr
index|[
name|k
index|]
operator|.
name|regs
index|[
name|j
index|]
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|out_max
operator|=
name|MAX
argument_list|(
name|out_max
argument_list|,
name|insn_needs
operator|.
name|out_addr_addr
index|[
name|k
index|]
operator|.
name|regs
index|[
name|j
index|]
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* RELOAD_FOR_INSN reloads conflict with inputs, outputs, 	     and operand addresses but not things used to reload 	     them.  Similarly, RELOAD_FOR_OPERAND_ADDRESS reloads 	     don't conflict with things needed to reload inputs or 	     outputs.  */
name|in_max
operator|=
name|MAX
argument_list|(
name|MAX
argument_list|(
name|insn_needs
operator|.
name|op_addr
operator|.
name|regs
index|[
name|j
index|]
index|[
name|i
index|]
argument_list|,
name|insn_needs
operator|.
name|op_addr_reload
operator|.
name|regs
index|[
name|j
index|]
index|[
name|i
index|]
argument_list|)
argument_list|,
name|in_max
argument_list|)
expr_stmt|;
name|out_max
operator|=
name|MAX
argument_list|(
name|out_max
argument_list|,
name|insn_needs
operator|.
name|insn
operator|.
name|regs
index|[
name|j
index|]
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|insn_needs
operator|.
name|input
operator|.
name|regs
index|[
name|j
index|]
index|[
name|i
index|]
operator|=
name|MAX
argument_list|(
name|insn_needs
operator|.
name|input
operator|.
name|regs
index|[
name|j
index|]
index|[
name|i
index|]
operator|+
name|insn_needs
operator|.
name|op_addr
operator|.
name|regs
index|[
name|j
index|]
index|[
name|i
index|]
operator|+
name|insn_needs
operator|.
name|insn
operator|.
name|regs
index|[
name|j
index|]
index|[
name|i
index|]
argument_list|,
name|in_max
operator|+
name|insn_needs
operator|.
name|input
operator|.
name|regs
index|[
name|j
index|]
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|insn_needs
operator|.
name|output
operator|.
name|regs
index|[
name|j
index|]
index|[
name|i
index|]
operator|+=
name|out_max
expr_stmt|;
name|insn_needs
operator|.
name|other
operator|.
name|regs
index|[
name|j
index|]
index|[
name|i
index|]
operator|+=
name|MAX
argument_list|(
name|MAX
argument_list|(
name|insn_needs
operator|.
name|input
operator|.
name|regs
index|[
name|j
index|]
index|[
name|i
index|]
argument_list|,
name|insn_needs
operator|.
name|output
operator|.
name|regs
index|[
name|j
index|]
index|[
name|i
index|]
argument_list|)
argument_list|,
name|insn_needs
operator|.
name|other_addr
operator|.
name|regs
index|[
name|j
index|]
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Now compute group needs.  */
for|for
control|(
name|in_max
operator|=
literal|0
operator|,
name|out_max
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|reload_n_operands
condition|;
name|j
operator|++
control|)
block|{
name|in_max
operator|=
name|MAX
argument_list|(
name|in_max
argument_list|,
name|insn_needs
operator|.
name|in_addr
index|[
name|j
index|]
operator|.
name|groups
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|in_max
operator|=
name|MAX
argument_list|(
name|in_max
argument_list|,
name|insn_needs
operator|.
name|in_addr_addr
index|[
name|j
index|]
operator|.
name|groups
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|out_max
operator|=
name|MAX
argument_list|(
name|out_max
argument_list|,
name|insn_needs
operator|.
name|out_addr
index|[
name|j
index|]
operator|.
name|groups
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|out_max
operator|=
name|MAX
argument_list|(
name|out_max
argument_list|,
name|insn_needs
operator|.
name|out_addr_addr
index|[
name|j
index|]
operator|.
name|groups
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|in_max
operator|=
name|MAX
argument_list|(
name|MAX
argument_list|(
name|insn_needs
operator|.
name|op_addr
operator|.
name|groups
index|[
name|i
index|]
argument_list|,
name|insn_needs
operator|.
name|op_addr_reload
operator|.
name|groups
index|[
name|i
index|]
argument_list|)
argument_list|,
name|in_max
argument_list|)
expr_stmt|;
name|out_max
operator|=
name|MAX
argument_list|(
name|out_max
argument_list|,
name|insn_needs
operator|.
name|insn
operator|.
name|groups
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|insn_needs
operator|.
name|input
operator|.
name|groups
index|[
name|i
index|]
operator|=
name|MAX
argument_list|(
name|insn_needs
operator|.
name|input
operator|.
name|groups
index|[
name|i
index|]
operator|+
name|insn_needs
operator|.
name|op_addr
operator|.
name|groups
index|[
name|i
index|]
operator|+
name|insn_needs
operator|.
name|insn
operator|.
name|groups
index|[
name|i
index|]
argument_list|,
name|in_max
operator|+
name|insn_needs
operator|.
name|input
operator|.
name|groups
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|insn_needs
operator|.
name|output
operator|.
name|groups
index|[
name|i
index|]
operator|+=
name|out_max
expr_stmt|;
name|insn_needs
operator|.
name|other
operator|.
name|groups
index|[
name|i
index|]
operator|+=
name|MAX
argument_list|(
name|MAX
argument_list|(
name|insn_needs
operator|.
name|input
operator|.
name|groups
index|[
name|i
index|]
argument_list|,
name|insn_needs
operator|.
name|output
operator|.
name|groups
index|[
name|i
index|]
argument_list|)
argument_list|,
name|insn_needs
operator|.
name|other_addr
operator|.
name|groups
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Record the needs for later.  */
name|chain
operator|->
name|need
operator|=
name|insn_needs
operator|.
name|other
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find a group of exactly 2 registers.     First try to fill out the group by spilling a single register which    would allow completion of the group.     Then try to create a new group from a pair of registers, neither of    which are explicitly used.     Then try to create a group from any pair of registers.  */
end_comment

begin_function
specifier|static
name|void
name|find_tworeg_group
parameter_list|(
name|chain
parameter_list|,
name|class
parameter_list|,
name|dumpfile
parameter_list|)
name|struct
name|insn_chain
modifier|*
name|chain
decl_stmt|;
name|int
name|class
decl_stmt|;
name|FILE
modifier|*
name|dumpfile
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/* First, look for a register that will complete a group.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|,
name|other
decl_stmt|;
name|j
operator|=
name|potential_reload_regs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|j
operator|>=
literal|0
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|bad_spill_regs
argument_list|,
name|j
argument_list|)
operator|&&
operator|(
operator|(
name|j
operator|>
literal|0
operator|&&
operator|(
name|other
operator|=
name|j
operator|-
literal|1
operator|,
name|spill_reg_order
index|[
name|other
index|]
operator|>=
literal|0
operator|)
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|class
index|]
argument_list|,
name|j
argument_list|)
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|class
index|]
argument_list|,
name|other
argument_list|)
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|other
argument_list|,
name|chain
operator|->
name|group_mode
index|[
name|class
index|]
argument_list|)
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|chain
operator|->
name|counted_for_nongroups
argument_list|,
name|other
argument_list|)
comment|/* We don't want one part of another group. 		  We could get "two groups" that overlap!  */
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|chain
operator|->
name|counted_for_groups
argument_list|,
name|other
argument_list|)
operator|)
operator|||
operator|(
name|j
operator|<
name|FIRST_PSEUDO_REGISTER
operator|-
literal|1
operator|&&
operator|(
name|other
operator|=
name|j
operator|+
literal|1
operator|,
name|spill_reg_order
index|[
name|other
index|]
operator|>=
literal|0
operator|)
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|class
index|]
argument_list|,
name|j
argument_list|)
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|class
index|]
argument_list|,
name|other
argument_list|)
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|j
argument_list|,
name|chain
operator|->
name|group_mode
index|[
name|class
index|]
argument_list|)
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|chain
operator|->
name|counted_for_nongroups
argument_list|,
name|other
argument_list|)
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|chain
operator|->
name|counted_for_groups
argument_list|,
name|other
argument_list|)
operator|)
operator|)
condition|)
block|{
specifier|register
name|enum
name|reg_class
modifier|*
name|p
decl_stmt|;
comment|/* We have found one that will complete a group, 	     so count off one group as provided.  */
name|chain
operator|->
name|need
operator|.
name|groups
index|[
name|class
index|]
operator|--
expr_stmt|;
name|p
operator|=
name|reg_class_superclasses
index|[
name|class
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
name|LIM_REG_CLASSES
condition|)
block|{
if|if
condition|(
name|chain
operator|->
name|group_size
index|[
operator|(
name|int
operator|)
operator|*
name|p
index|]
operator|<=
name|chain
operator|->
name|group_size
index|[
name|class
index|]
condition|)
name|chain
operator|->
name|need
operator|.
name|groups
index|[
operator|(
name|int
operator|)
operator|*
name|p
index|]
operator|--
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
comment|/* Indicate both these regs are part of a group.  */
name|SET_HARD_REG_BIT
argument_list|(
name|chain
operator|->
name|counted_for_groups
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|chain
operator|->
name|counted_for_groups
argument_list|,
name|other
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* We can't complete a group, so start one.  */
if|if
condition|(
name|i
operator|==
name|FIRST_PSEUDO_REGISTER
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|,
name|k
decl_stmt|;
name|j
operator|=
name|potential_reload_regs
index|[
name|i
index|]
expr_stmt|;
comment|/* Verify that J+1 is a potential reload reg.  */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|potential_reload_regs
index|[
name|k
index|]
operator|==
name|j
operator|+
literal|1
condition|)
break|break;
if|if
condition|(
name|j
operator|>=
literal|0
operator|&&
name|j
operator|+
literal|1
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|k
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|spill_reg_order
index|[
name|j
index|]
operator|<
literal|0
operator|&&
name|spill_reg_order
index|[
name|j
operator|+
literal|1
index|]
operator|<
literal|0
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|class
index|]
argument_list|,
name|j
argument_list|)
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|class
index|]
argument_list|,
name|j
operator|+
literal|1
argument_list|)
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|j
argument_list|,
name|chain
operator|->
name|group_mode
index|[
name|class
index|]
argument_list|)
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|chain
operator|->
name|counted_for_nongroups
argument_list|,
name|j
operator|+
literal|1
argument_list|)
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|bad_spill_regs
argument_list|,
name|j
operator|+
literal|1
argument_list|)
condition|)
break|break;
block|}
comment|/* I should be the index in potential_reload_regs      of the new reload reg we have found.  */
name|new_spill_reg
argument_list|(
name|chain
argument_list|,
name|i
argument_list|,
name|class
argument_list|,
literal|0
argument_list|,
name|dumpfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find a group of more than 2 registers.    Look for a sufficient sequence of unspilled registers, and spill them all    at once.  */
end_comment

begin_function
specifier|static
name|void
name|find_group
parameter_list|(
name|chain
parameter_list|,
name|class
parameter_list|,
name|dumpfile
parameter_list|)
name|struct
name|insn_chain
modifier|*
name|chain
decl_stmt|;
name|int
name|class
decl_stmt|;
name|FILE
modifier|*
name|dumpfile
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
init|=
name|potential_reload_regs
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|j
operator|>=
literal|0
operator|&&
name|j
operator|+
name|chain
operator|->
name|group_size
index|[
name|class
index|]
operator|<=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|j
argument_list|,
name|chain
operator|->
name|group_mode
index|[
name|class
index|]
argument_list|)
condition|)
block|{
name|int
name|k
decl_stmt|;
comment|/* Check each reg in the sequence.  */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|chain
operator|->
name|group_size
index|[
name|class
index|]
condition|;
name|k
operator|++
control|)
if|if
condition|(
operator|!
operator|(
name|spill_reg_order
index|[
name|j
operator|+
name|k
index|]
operator|<
literal|0
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|bad_spill_regs
argument_list|,
name|j
operator|+
name|k
argument_list|)
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|class
index|]
argument_list|,
name|j
operator|+
name|k
argument_list|)
operator|)
condition|)
break|break;
comment|/* We got a full sequence, so spill them all.  */
if|if
condition|(
name|k
operator|==
name|chain
operator|->
name|group_size
index|[
name|class
index|]
condition|)
block|{
specifier|register
name|enum
name|reg_class
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|chain
operator|->
name|group_size
index|[
name|class
index|]
condition|;
name|k
operator|++
control|)
block|{
name|int
name|idx
decl_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|chain
operator|->
name|counted_for_groups
argument_list|,
name|j
operator|+
name|k
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|idx
operator|++
control|)
if|if
condition|(
name|potential_reload_regs
index|[
name|idx
index|]
operator|==
name|j
operator|+
name|k
condition|)
break|break;
name|new_spill_reg
argument_list|(
name|chain
argument_list|,
name|idx
argument_list|,
name|class
argument_list|,
literal|0
argument_list|,
name|dumpfile
argument_list|)
expr_stmt|;
block|}
comment|/* We have found one that will complete a group, 		 so count off one group as provided.  */
name|chain
operator|->
name|need
operator|.
name|groups
index|[
name|class
index|]
operator|--
expr_stmt|;
name|p
operator|=
name|reg_class_superclasses
index|[
name|class
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
name|LIM_REG_CLASSES
condition|)
block|{
if|if
condition|(
name|chain
operator|->
name|group_size
index|[
operator|(
name|int
operator|)
operator|*
name|p
index|]
operator|<=
name|chain
operator|->
name|group_size
index|[
name|class
index|]
condition|)
name|chain
operator|->
name|need
operator|.
name|groups
index|[
operator|(
name|int
operator|)
operator|*
name|p
index|]
operator|--
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
return|return;
block|}
block|}
block|}
comment|/* There are no groups left.  */
name|spill_failure
argument_list|(
name|chain
operator|->
name|insn
argument_list|)
expr_stmt|;
name|failure
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If pseudo REG conflicts with one of our reload registers, mark it as    spilled.  */
end_comment

begin_function
specifier|static
name|void
name|maybe_mark_pseudo_spilled
parameter_list|(
name|reg
parameter_list|)
name|int
name|reg
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|r
init|=
name|reg_renumber
index|[
name|reg
index|]
decl_stmt|;
name|int
name|nregs
decl_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|nregs
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|r
argument_list|,
name|PSEUDO_REGNO_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_spills
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|r
operator|<=
name|spill_regs
index|[
name|i
index|]
operator|&&
name|r
operator|+
name|nregs
operator|>
name|spill_regs
index|[
name|i
index|]
condition|)
block|{
name|SET_REGNO_REG_SET
argument_list|(
name|spilled_pseudos
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/* Find more reload regs to satisfy the remaining need of an insn, which    is given by CHAIN.    Do it by ascending class number, since otherwise a reg    might be spilled for a big class and might fail to count    for a smaller class even though it belongs to that class.     Count spilled regs in `spills', and add entries to    `spill_regs' and `spill_reg_order'.     ??? Note there is a problem here.    When there is a need for a group in a high-numbered class,    and also need for non-group regs that come from a lower class,    the non-group regs are chosen first.  If there aren't many regs,    they might leave no room for a group.     This was happening on the 386.  To fix it, we added the code    that calls possible_group_p, so that the lower class won't    break up the last possible group.     Really fixing the problem would require changes above    in counting the regs already spilled, and in choose_reload_regs.    It might be hard to avoid introducing bugs there.  */
end_comment

begin_function
specifier|static
name|void
name|find_reload_regs
parameter_list|(
name|chain
parameter_list|,
name|dumpfile
parameter_list|)
name|struct
name|insn_chain
modifier|*
name|chain
decl_stmt|;
name|FILE
modifier|*
name|dumpfile
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|class
decl_stmt|;
name|short
modifier|*
name|group_needs
init|=
name|chain
operator|->
name|need
operator|.
name|groups
decl_stmt|;
name|short
modifier|*
name|simple_needs
init|=
name|chain
operator|->
name|need
operator|.
name|regs
index|[
literal|0
index|]
decl_stmt|;
name|short
modifier|*
name|nongroup_needs
init|=
name|chain
operator|->
name|need
operator|.
name|regs
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|dumpfile
condition|)
name|fprintf
argument_list|(
name|dumpfile
argument_list|,
literal|"Spilling for insn %d.\n"
argument_list|,
name|INSN_UID
argument_list|(
name|chain
operator|->
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Compute the order of preference for hard registers to spill.      Store them by decreasing preference in potential_reload_regs.  */
name|order_regs_for_reload
argument_list|(
name|chain
argument_list|)
expr_stmt|;
comment|/* So far, no hard regs have been spilled.  */
name|n_spills
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
name|spill_reg_order
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|chain
operator|->
name|used_spill_regs
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|chain
operator|->
name|counted_for_groups
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|chain
operator|->
name|counted_for_nongroups
argument_list|)
expr_stmt|;
for|for
control|(
name|class
operator|=
literal|0
init|;
name|class
operator|<
name|N_REG_CLASSES
condition|;
name|class
operator|++
control|)
block|{
comment|/* First get the groups of registers. 	 If we got single registers first, we might fragment 	 possible groups.  */
while|while
condition|(
name|group_needs
index|[
name|class
index|]
operator|>
literal|0
condition|)
block|{
comment|/* If any single spilled regs happen to form groups, 	     count them now.  Maybe we don't really need 	     to spill another group.  */
name|count_possible_groups
argument_list|(
name|chain
argument_list|,
name|class
argument_list|)
expr_stmt|;
if|if
condition|(
name|group_needs
index|[
name|class
index|]
operator|<=
literal|0
condition|)
break|break;
comment|/* Groups of size 2, the only groups used on most machines, 	     are treated specially.  */
if|if
condition|(
name|chain
operator|->
name|group_size
index|[
name|class
index|]
operator|==
literal|2
condition|)
name|find_tworeg_group
argument_list|(
name|chain
argument_list|,
name|class
argument_list|,
name|dumpfile
argument_list|)
expr_stmt|;
else|else
name|find_group
argument_list|(
name|chain
argument_list|,
name|class
argument_list|,
name|dumpfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|failure
condition|)
return|return;
block|}
comment|/* Now similarly satisfy all need for single registers.  */
while|while
condition|(
name|simple_needs
index|[
name|class
index|]
operator|>
literal|0
operator|||
name|nongroup_needs
index|[
name|class
index|]
operator|>
literal|0
condition|)
block|{
comment|/* If we spilled enough regs, but they weren't counted 	     against the non-group need, see if we can count them now. 	     If so, we can avoid some actual spilling.  */
if|if
condition|(
name|simple_needs
index|[
name|class
index|]
operator|<=
literal|0
operator|&&
name|nongroup_needs
index|[
name|class
index|]
operator|>
literal|0
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_spills
condition|;
name|i
operator|++
control|)
block|{
name|int
name|regno
init|=
name|spill_regs
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|class
index|]
argument_list|,
name|regno
argument_list|)
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|chain
operator|->
name|counted_for_groups
argument_list|,
name|regno
argument_list|)
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|chain
operator|->
name|counted_for_nongroups
argument_list|,
name|regno
argument_list|)
operator|&&
name|nongroup_needs
index|[
name|class
index|]
operator|>
literal|0
condition|)
block|{
specifier|register
name|enum
name|reg_class
modifier|*
name|p
decl_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|chain
operator|->
name|counted_for_nongroups
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|nongroup_needs
index|[
name|class
index|]
operator|--
expr_stmt|;
name|p
operator|=
name|reg_class_superclasses
index|[
name|class
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
name|LIM_REG_CLASSES
condition|)
name|nongroup_needs
index|[
operator|(
name|int
operator|)
operator|*
name|p
operator|++
index|]
operator|--
expr_stmt|;
block|}
block|}
if|if
condition|(
name|simple_needs
index|[
name|class
index|]
operator|<=
literal|0
operator|&&
name|nongroup_needs
index|[
name|class
index|]
operator|<=
literal|0
condition|)
break|break;
comment|/* Consider the potential reload regs that aren't 	     yet in use as reload regs, in order of preference. 	     Find the most preferred one that's in this class.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
name|int
name|regno
init|=
name|potential_reload_regs
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|regno
operator|>=
literal|0
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|class
index|]
argument_list|,
name|regno
argument_list|)
comment|/* If this reg will not be available for groups, 		     pick one that does not foreclose possible groups. 		     This is a kludge, and not very general, 		     but it should be sufficient to make the 386 work, 		     and the problem should not occur on machines with 		     more registers.  */
operator|&&
operator|(
name|nongroup_needs
index|[
name|class
index|]
operator|==
literal|0
operator|||
name|possible_group_p
argument_list|(
name|chain
argument_list|,
name|regno
argument_list|)
operator|)
condition|)
break|break;
block|}
comment|/* If we couldn't get a register, try to get one even if we 	     might foreclose possible groups.  This may cause problems 	     later, but that's better than aborting now, since it is 	     possible that we will, in fact, be able to form the needed 	     group even with this allocation.  */
if|if
condition|(
name|i
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|asm_noperands
argument_list|(
name|chain
operator|->
name|insn
argument_list|)
operator|<
literal|0
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|potential_reload_regs
index|[
name|i
index|]
operator|>=
literal|0
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|class
index|]
argument_list|,
name|potential_reload_regs
index|[
name|i
index|]
argument_list|)
condition|)
break|break;
comment|/* I should be the index in potential_reload_regs 	     of the new reload reg we have found.  */
name|new_spill_reg
argument_list|(
name|chain
argument_list|,
name|i
argument_list|,
name|class
argument_list|,
literal|1
argument_list|,
name|dumpfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|failure
condition|)
return|return;
block|}
block|}
comment|/* We know which hard regs to use, now mark the pseudos that live in them      as needing to be kicked out.  */
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|chain->live_before
argument_list|,
argument|FIRST_PSEUDO_REGISTER
argument_list|,
argument|i
argument_list|,
argument|{        maybe_mark_pseudo_spilled (i);      }
argument_list|)
empty_stmt|;
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|chain->live_after
argument_list|,
argument|FIRST_PSEUDO_REGISTER
argument_list|,
argument|i
argument_list|,
argument|{        maybe_mark_pseudo_spilled (i);      }
argument_list|)
empty_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|used_spill_regs
argument_list|,
name|chain
operator|->
name|used_spill_regs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dump_needs
parameter_list|(
name|chain
parameter_list|,
name|dumpfile
parameter_list|)
name|struct
name|insn_chain
modifier|*
name|chain
decl_stmt|;
name|FILE
modifier|*
name|dumpfile
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|reg_class_names
index|[]
init|=
name|REG_CLASS_NAMES
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|needs
modifier|*
name|n
init|=
operator|&
name|chain
operator|->
name|need
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_REG_CLASSES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|n
operator|->
name|regs
index|[
name|i
index|]
index|[
literal|0
index|]
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|dumpfile
argument_list|,
literal|";; Need %d reg%s of class %s.\n"
argument_list|,
name|n
operator|->
name|regs
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|,
name|n
operator|->
name|regs
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|,
name|reg_class_names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|regs
index|[
name|i
index|]
index|[
literal|1
index|]
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|dumpfile
argument_list|,
literal|";; Need %d nongroup reg%s of class %s.\n"
argument_list|,
name|n
operator|->
name|regs
index|[
name|i
index|]
index|[
literal|1
index|]
argument_list|,
name|n
operator|->
name|regs
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|,
name|reg_class_names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|groups
index|[
name|i
index|]
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|dumpfile
argument_list|,
literal|";; Need %d group%s (%smode) of class %s.\n"
argument_list|,
name|n
operator|->
name|groups
index|[
name|i
index|]
argument_list|,
name|n
operator|->
name|groups
index|[
name|i
index|]
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|,
name|mode_name
index|[
operator|(
name|int
operator|)
name|chain
operator|->
name|group_mode
index|[
name|i
index|]
index|]
argument_list|,
name|reg_class_names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Delete all insns that were inserted by emit_caller_save_insns during    this iteration.  */
end_comment

begin_function
specifier|static
name|void
name|delete_caller_save_insns
parameter_list|()
block|{
name|struct
name|insn_chain
modifier|*
name|c
init|=
name|reload_insn_chain
decl_stmt|;
while|while
condition|(
name|c
operator|!=
literal|0
condition|)
block|{
while|while
condition|(
name|c
operator|!=
literal|0
operator|&&
name|c
operator|->
name|is_caller_save_insn
condition|)
block|{
name|struct
name|insn_chain
modifier|*
name|next
init|=
name|c
operator|->
name|next
decl_stmt|;
name|rtx
name|insn
init|=
name|c
operator|->
name|insn
decl_stmt|;
if|if
condition|(
name|insn
operator|==
name|BLOCK_HEAD
argument_list|(
name|c
operator|->
name|block
argument_list|)
condition|)
name|BLOCK_HEAD
argument_list|(
name|c
operator|->
name|block
argument_list|)
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|BLOCK_END
argument_list|(
name|c
operator|->
name|block
argument_list|)
condition|)
name|BLOCK_END
argument_list|(
name|c
operator|->
name|block
argument_list|)
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|reload_insn_chain
condition|)
name|reload_insn_chain
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|!=
literal|0
condition|)
name|PREV_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
operator|!=
literal|0
condition|)
name|NEXT_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
condition|)
name|next
operator|->
name|prev
operator|=
name|c
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|prev
condition|)
name|c
operator|->
name|prev
operator|->
name|next
operator|=
name|next
expr_stmt|;
name|c
operator|->
name|next
operator|=
name|unused_insn_chains
expr_stmt|;
name|unused_insn_chains
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|next
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|!=
literal|0
condition|)
name|c
operator|=
name|c
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Nonzero if, after spilling reg REGNO for non-groups,    it will still be possible to find a group if we still need one.  */
end_comment

begin_function
specifier|static
name|int
name|possible_group_p
parameter_list|(
name|chain
parameter_list|,
name|regno
parameter_list|)
name|struct
name|insn_chain
modifier|*
name|chain
decl_stmt|;
name|int
name|regno
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|class
init|=
operator|(
name|int
operator|)
name|NO_REGS
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|N_REG_CLASSES
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|chain
operator|->
name|need
operator|.
name|groups
index|[
name|i
index|]
operator|>
literal|0
condition|)
block|{
name|class
operator|=
name|i
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|class
operator|==
operator|(
name|int
operator|)
name|NO_REGS
condition|)
return|return
literal|1
return|;
comment|/* Consider each pair of consecutive registers.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
comment|/* Ignore pairs that include reg REGNO.  */
if|if
condition|(
name|i
operator|==
name|regno
operator|||
name|i
operator|+
literal|1
operator|==
name|regno
condition|)
continue|continue;
comment|/* Ignore pairs that are outside the class that needs the group. 	 ??? Here we fail to handle the case where two different classes 	 independently need groups.  But this never happens with our 	 current machine descriptions.  */
if|if
condition|(
operator|!
operator|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|class
index|]
argument_list|,
name|i
argument_list|)
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|class
index|]
argument_list|,
name|i
operator|+
literal|1
argument_list|)
operator|)
condition|)
continue|continue;
comment|/* A pair of consecutive regs we can still spill does the trick.  */
if|if
condition|(
name|spill_reg_order
index|[
name|i
index|]
operator|<
literal|0
operator|&&
name|spill_reg_order
index|[
name|i
operator|+
literal|1
index|]
operator|<
literal|0
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|bad_spill_regs
argument_list|,
name|i
argument_list|)
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|bad_spill_regs
argument_list|,
name|i
operator|+
literal|1
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* A pair of one already spilled and one we can spill does it 	 provided the one already spilled is not otherwise reserved.  */
if|if
condition|(
name|spill_reg_order
index|[
name|i
index|]
operator|<
literal|0
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|bad_spill_regs
argument_list|,
name|i
argument_list|)
operator|&&
name|spill_reg_order
index|[
name|i
operator|+
literal|1
index|]
operator|>=
literal|0
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|chain
operator|->
name|counted_for_groups
argument_list|,
name|i
operator|+
literal|1
argument_list|)
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|chain
operator|->
name|counted_for_nongroups
argument_list|,
name|i
operator|+
literal|1
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|spill_reg_order
index|[
name|i
operator|+
literal|1
index|]
operator|<
literal|0
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|bad_spill_regs
argument_list|,
name|i
operator|+
literal|1
argument_list|)
operator|&&
name|spill_reg_order
index|[
name|i
index|]
operator|>=
literal|0
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|chain
operator|->
name|counted_for_groups
argument_list|,
name|i
argument_list|)
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|chain
operator|->
name|counted_for_nongroups
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Count any groups of CLASS that can be formed from the registers recently    spilled.  */
end_comment

begin_function
specifier|static
name|void
name|count_possible_groups
parameter_list|(
name|chain
parameter_list|,
name|class
parameter_list|)
name|struct
name|insn_chain
modifier|*
name|chain
decl_stmt|;
name|int
name|class
decl_stmt|;
block|{
name|HARD_REG_SET
name|new
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* Now find all consecutive groups of spilled registers      and mark each group off against the need for such groups.      But don't count them against ordinary need, yet.  */
if|if
condition|(
name|chain
operator|->
name|group_size
index|[
name|class
index|]
operator|==
literal|0
condition|)
return|return;
name|CLEAR_HARD_REG_SET
argument_list|(
name|new
argument_list|)
expr_stmt|;
comment|/* Make a mask of all the regs that are spill regs in class I.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_spills
condition|;
name|i
operator|++
control|)
block|{
name|int
name|regno
init|=
name|spill_regs
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|class
index|]
argument_list|,
name|regno
argument_list|)
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|chain
operator|->
name|counted_for_groups
argument_list|,
name|regno
argument_list|)
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|chain
operator|->
name|counted_for_nongroups
argument_list|,
name|regno
argument_list|)
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|new
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
comment|/* Find each consecutive group of them.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|chain
operator|->
name|need
operator|.
name|groups
index|[
name|class
index|]
operator|>
literal|0
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|new
argument_list|,
name|i
argument_list|)
operator|&&
name|i
operator|+
name|chain
operator|->
name|group_size
index|[
name|class
index|]
operator|<=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|i
argument_list|,
name|chain
operator|->
name|group_mode
index|[
name|class
index|]
argument_list|)
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|chain
operator|->
name|group_size
index|[
name|class
index|]
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|new
argument_list|,
name|i
operator|+
name|j
argument_list|)
condition|)
break|break;
if|if
condition|(
name|j
operator|==
name|chain
operator|->
name|group_size
index|[
name|class
index|]
condition|)
block|{
comment|/* We found a group.  Mark it off against this class's need for 	       groups, and against each superclass too.  */
specifier|register
name|enum
name|reg_class
modifier|*
name|p
decl_stmt|;
name|chain
operator|->
name|need
operator|.
name|groups
index|[
name|class
index|]
operator|--
expr_stmt|;
name|p
operator|=
name|reg_class_superclasses
index|[
name|class
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
name|LIM_REG_CLASSES
condition|)
block|{
if|if
condition|(
name|chain
operator|->
name|group_size
index|[
operator|(
name|int
operator|)
operator|*
name|p
index|]
operator|<=
name|chain
operator|->
name|group_size
index|[
name|class
index|]
condition|)
name|chain
operator|->
name|need
operator|.
name|groups
index|[
operator|(
name|int
operator|)
operator|*
name|p
index|]
operator|--
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
comment|/* Don't count these registers again.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|chain
operator|->
name|group_size
index|[
name|class
index|]
condition|;
name|j
operator|++
control|)
name|SET_HARD_REG_BIT
argument_list|(
name|chain
operator|->
name|counted_for_groups
argument_list|,
name|i
operator|+
name|j
argument_list|)
expr_stmt|;
block|}
comment|/* Skip to the last reg in this group.  When i is incremented above, 	   it will then point to the first reg of the next possible group.  */
name|i
operator|+=
name|j
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ALLOCATE_MODE is a register mode that needs to be reloaded.  OTHER_MODE is    another mode that needs to be reloaded for the same register class CLASS.    If any reg in CLASS allows ALLOCATE_MODE but not OTHER_MODE, fail.    ALLOCATE_MODE will never be smaller than OTHER_MODE.     This code used to also fail if any reg in CLASS allows OTHER_MODE but not    ALLOCATE_MODE.  This test is unnecessary, because we will never try to put    something of mode ALLOCATE_MODE into an OTHER_MODE register.  Testing this    causes unnecessary failures on machines requiring alignment of register    groups when the two modes are different sizes, because the larger mode has    more strict alignment rules than the smaller mode.  */
end_comment

begin_function
specifier|static
name|int
name|modes_equiv_for_class_p
parameter_list|(
name|allocate_mode
parameter_list|,
name|other_mode
parameter_list|,
name|class
parameter_list|)
name|enum
name|machine_mode
name|allocate_mode
decl_stmt|,
name|other_mode
decl_stmt|;
name|enum
name|reg_class
name|class
decl_stmt|;
block|{
specifier|register
name|int
name|regno
decl_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
block|{
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|class
index|]
argument_list|,
name|regno
argument_list|)
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|allocate_mode
argument_list|)
operator|&&
operator|!
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|other_mode
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Handle the failure to find a register to spill.    INSN should be one of the insns which needed this particular spill reg.  */
end_comment

begin_function
specifier|static
name|void
name|spill_failure
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
if|if
condition|(
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
name|error_for_asm
argument_list|(
name|insn
argument_list|,
literal|"`asm' needs too many reloads"
argument_list|)
expr_stmt|;
else|else
name|fatal_insn
argument_list|(
literal|"Unable to find a register to spill."
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a new register to the tables of available spill-registers.    CHAIN is the insn for which the register will be used; we decrease the    needs of that insn.    I is the index of this register in potential_reload_regs.    CLASS is the regclass whose need is being satisfied.    NONGROUP is 0 if this register is part of a group.    DUMPFILE is the same as the one that `reload' got.  */
end_comment

begin_function
specifier|static
name|void
name|new_spill_reg
parameter_list|(
name|chain
parameter_list|,
name|i
parameter_list|,
name|class
parameter_list|,
name|nongroup
parameter_list|,
name|dumpfile
parameter_list|)
name|struct
name|insn_chain
modifier|*
name|chain
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|class
decl_stmt|;
name|int
name|nongroup
decl_stmt|;
name|FILE
modifier|*
name|dumpfile
decl_stmt|;
block|{
specifier|register
name|enum
name|reg_class
modifier|*
name|p
decl_stmt|;
name|int
name|regno
init|=
name|potential_reload_regs
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|i
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|spill_failure
argument_list|(
name|chain
operator|->
name|insn
argument_list|)
expr_stmt|;
name|failure
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|bad_spill_regs
argument_list|,
name|regno
argument_list|)
condition|)
block|{
specifier|static
name|char
modifier|*
name|reg_class_names
index|[]
init|=
name|REG_CLASS_NAMES
decl_stmt|;
if|if
condition|(
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|chain
operator|->
name|insn
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* The error message is still correct - we know only that it wasn't 	   an asm statement that caused the problem, but one of the global 	   registers declared by the users might have screwed us.  */
name|error
argument_list|(
literal|"fixed or forbidden register %d (%s) was spilled for class %s."
argument_list|,
name|regno
argument_list|,
name|reg_names
index|[
name|regno
index|]
argument_list|,
name|reg_class_names
index|[
name|class
index|]
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"This may be due to a compiler bug or to impossible asm"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"statements or clauses."
argument_list|)
expr_stmt|;
name|fatal_insn
argument_list|(
literal|"This is the instruction:"
argument_list|,
name|chain
operator|->
name|insn
argument_list|)
expr_stmt|;
block|}
name|error_for_asm
argument_list|(
name|chain
operator|->
name|insn
argument_list|,
literal|"Invalid `asm' statement:"
argument_list|)
expr_stmt|;
name|error_for_asm
argument_list|(
name|chain
operator|->
name|insn
argument_list|,
literal|"fixed or forbidden register %d (%s) was spilled for class %s."
argument_list|,
name|regno
argument_list|,
name|reg_names
index|[
name|regno
index|]
argument_list|,
name|reg_class_names
index|[
name|class
index|]
argument_list|)
expr_stmt|;
name|failure
operator|=
literal|1
expr_stmt|;
return|return;
block|}
comment|/* Make reg REGNO an additional reload reg.  */
name|potential_reload_regs
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|spill_regs
index|[
name|n_spills
index|]
operator|=
name|regno
expr_stmt|;
name|spill_reg_order
index|[
name|regno
index|]
operator|=
name|n_spills
expr_stmt|;
if|if
condition|(
name|dumpfile
condition|)
name|fprintf
argument_list|(
name|dumpfile
argument_list|,
literal|"Spilling reg %d.\n"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|chain
operator|->
name|used_spill_regs
argument_list|,
name|regno
argument_list|)
expr_stmt|;
comment|/* Clear off the needs we just satisfied.  */
name|chain
operator|->
name|need
operator|.
name|regs
index|[
literal|0
index|]
index|[
name|class
index|]
operator|--
expr_stmt|;
name|p
operator|=
name|reg_class_superclasses
index|[
name|class
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
name|LIM_REG_CLASSES
condition|)
name|chain
operator|->
name|need
operator|.
name|regs
index|[
literal|0
index|]
index|[
operator|(
name|int
operator|)
operator|*
name|p
operator|++
index|]
operator|--
expr_stmt|;
if|if
condition|(
name|nongroup
operator|&&
name|chain
operator|->
name|need
operator|.
name|regs
index|[
literal|1
index|]
index|[
name|class
index|]
operator|>
literal|0
condition|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|chain
operator|->
name|counted_for_nongroups
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|chain
operator|->
name|need
operator|.
name|regs
index|[
literal|1
index|]
index|[
name|class
index|]
operator|--
expr_stmt|;
name|p
operator|=
name|reg_class_superclasses
index|[
name|class
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
name|LIM_REG_CLASSES
condition|)
name|chain
operator|->
name|need
operator|.
name|regs
index|[
literal|1
index|]
index|[
operator|(
name|int
operator|)
operator|*
name|p
operator|++
index|]
operator|--
expr_stmt|;
block|}
name|n_spills
operator|++
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Delete an unneeded INSN and any previous insns who sole purpose is loading    data that is dead in INSN.  */
end_comment

begin_function
specifier|static
name|void
name|delete_dead_insn
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|prev
init|=
name|prev_real_insn
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|prev_dest
decl_stmt|;
comment|/* If the previous insn sets a register that dies in our insn, delete it      too.  */
if|if
condition|(
name|prev
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
operator|(
name|prev_dest
operator|=
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|)
operator|,
name|GET_CODE
argument_list|(
name|prev_dest
argument_list|)
operator|==
name|REG
operator|)
operator|&&
name|reg_mentioned_p
argument_list|(
name|prev_dest
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|&&
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
name|prev_dest
argument_list|)
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|)
argument_list|)
condition|)
name|delete_dead_insn
argument_list|(
name|prev
argument_list|)
expr_stmt|;
name|PUT_CODE
argument_list|(
name|insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Modify the home of pseudo-reg I.    The new home is present in reg_renumber[I].     FROM_REG may be the hard reg that the pseudo-reg is being spilled from;    or it may be -1, meaning there is none or it is not relevant.    This is used so that all pseudos spilled from a given hard reg    can share one stack slot.  */
end_comment

begin_function
specifier|static
name|void
name|alter_reg
parameter_list|(
name|i
parameter_list|,
name|from_reg
parameter_list|)
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|from_reg
decl_stmt|;
block|{
comment|/* When outputting an inline function, this can happen      for a reg that isn't actually used.  */
if|if
condition|(
name|regno_reg_rtx
index|[
name|i
index|]
operator|==
literal|0
condition|)
return|return;
comment|/* If the reg got changed to a MEM at rtl-generation time,      ignore it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|)
operator|!=
name|REG
condition|)
return|return;
comment|/* Modify the reg-rtx to contain the new hard reg      number or else to contain its pseudo reg number.  */
name|REGNO
argument_list|(
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|)
operator|=
name|reg_renumber
index|[
name|i
index|]
operator|>=
literal|0
condition|?
name|reg_renumber
index|[
name|i
index|]
else|:
name|i
expr_stmt|;
comment|/* If we have a pseudo that is needed but has no hard reg or equivalent,      allocate a stack slot for it.  */
if|if
condition|(
name|reg_renumber
index|[
name|i
index|]
operator|<
literal|0
operator|&&
name|REG_N_REFS
argument_list|(
name|i
argument_list|)
operator|>
literal|0
operator|&&
name|reg_equiv_constant
index|[
name|i
index|]
operator|==
literal|0
operator|&&
name|reg_equiv_memory_loc
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
specifier|register
name|rtx
name|x
decl_stmt|;
name|int
name|inherent_size
init|=
name|PSEUDO_REGNO_BYTES
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|int
name|total_size
init|=
name|MAX
argument_list|(
name|inherent_size
argument_list|,
name|reg_max_ref_width
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|int
name|adjust
init|=
literal|0
decl_stmt|;
comment|/* Each pseudo reg has an inherent size which comes from its own mode, 	 and a total size which provides room for paradoxical subregs 	 which refer to the pseudo reg in wider modes.  	 We can use a slot already allocated if it provides both 	 enough inherent space and enough total space. 	 Otherwise, we allocate a new slot, making sure that it has no less 	 inherent space, and no less total space, then the previous slot.  */
if|if
condition|(
name|from_reg
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* No known place to spill from => no slot to reuse.  */
name|x
operator|=
name|assign_stack_local
argument_list|(
name|GET_MODE
argument_list|(
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|)
argument_list|,
name|total_size
argument_list|,
name|inherent_size
operator|==
name|total_size
condition|?
literal|0
else|:
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
comment|/* Cancel the  big-endian correction done in assign_stack_local. 	       Get the address of the beginning of the slot. 	       This is so we can do a big-endian correction unconditionally 	       below.  */
name|adjust
operator|=
name|inherent_size
operator|-
name|total_size
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|x
argument_list|)
operator|=
name|RTX_UNCHANGING_P
argument_list|(
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Reuse a stack slot if possible.  */
elseif|else
if|if
condition|(
name|spill_stack_slot
index|[
name|from_reg
index|]
operator|!=
literal|0
operator|&&
name|spill_stack_slot_width
index|[
name|from_reg
index|]
operator|>=
name|total_size
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|spill_stack_slot
index|[
name|from_reg
index|]
argument_list|)
argument_list|)
operator|>=
name|inherent_size
operator|)
condition|)
name|x
operator|=
name|spill_stack_slot
index|[
name|from_reg
index|]
expr_stmt|;
comment|/* Allocate a bigger slot.  */
else|else
block|{
comment|/* Compute maximum size needed, both for inherent size 	     and for total size.  */
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|rtx
name|stack_slot
decl_stmt|;
if|if
condition|(
name|spill_stack_slot
index|[
name|from_reg
index|]
condition|)
block|{
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|spill_stack_slot
index|[
name|from_reg
index|]
argument_list|)
argument_list|)
operator|>
name|inherent_size
condition|)
name|mode
operator|=
name|GET_MODE
argument_list|(
name|spill_stack_slot
index|[
name|from_reg
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|spill_stack_slot_width
index|[
name|from_reg
index|]
operator|>
name|total_size
condition|)
name|total_size
operator|=
name|spill_stack_slot_width
index|[
name|from_reg
index|]
expr_stmt|;
block|}
comment|/* Make a slot with that size.  */
name|x
operator|=
name|assign_stack_local
argument_list|(
name|mode
argument_list|,
name|total_size
argument_list|,
name|inherent_size
operator|==
name|total_size
condition|?
literal|0
else|:
operator|-
literal|1
argument_list|)
expr_stmt|;
name|stack_slot
operator|=
name|x
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
block|{
comment|/* Cancel the  big-endian correction done in assign_stack_local. 		 Get the address of the beginning of the slot. 		 This is so we can do a big-endian correction unconditionally 		 below.  */
name|adjust
operator|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|-
name|total_size
expr_stmt|;
if|if
condition|(
name|adjust
condition|)
name|stack_slot
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode_for_size
argument_list|(
name|total_size
operator|*
name|BITS_PER_UNIT
argument_list|,
name|MODE_INT
argument_list|,
literal|1
argument_list|)
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|adjust
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|spill_stack_slot
index|[
name|from_reg
index|]
operator|=
name|stack_slot
expr_stmt|;
name|spill_stack_slot_width
index|[
name|from_reg
index|]
operator|=
name|total_size
expr_stmt|;
block|}
comment|/* On a big endian machine, the "address" of the slot 	 is the address of the low part that fits its inherent mode.  */
if|if
condition|(
name|BYTES_BIG_ENDIAN
operator|&&
name|inherent_size
operator|<
name|total_size
condition|)
name|adjust
operator|+=
operator|(
name|total_size
operator|-
name|inherent_size
operator|)
expr_stmt|;
comment|/* If we have any adjustment to make, or if the stack slot is the 	 wrong mode, make a new stack slot.  */
if|if
condition|(
name|adjust
operator|!=
literal|0
operator|||
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|x
operator|=
name|gen_rtx_MEM
argument_list|(
name|GET_MODE
argument_list|(
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|)
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|adjust
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this was shared among registers, must ensure we never 	     set it readonly since that can cause scheduling 	     problems.  Note we would only have in this adjustment 	     case in any event, since the code above doesn't set it.  */
if|if
condition|(
name|from_reg
operator|==
operator|-
literal|1
condition|)
name|RTX_UNCHANGING_P
argument_list|(
name|x
argument_list|)
operator|=
name|RTX_UNCHANGING_P
argument_list|(
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Save the stack slot for later.   */
name|reg_equiv_memory_loc
index|[
name|i
index|]
operator|=
name|x
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Mark the slots in regs_ever_live for the hard regs    used by pseudo-reg number REGNO.  */
end_comment

begin_function
name|void
name|mark_home_live
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|lim
decl_stmt|;
name|i
operator|=
name|reg_renumber
index|[
name|regno
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
return|return;
name|lim
operator|=
name|i
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|i
argument_list|,
name|PSEUDO_REGNO_MODE
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|lim
condition|)
name|regs_ever_live
index|[
name|i
operator|++
index|]
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This function handles the tracking of elimination offsets around branches.     X is a piece of RTL being scanned.     INSN is the insn that it came from, if any.     INITIAL_P is non-zero if we are to set the offset to be the initial    offset and zero if we are setting the offset of the label to be the    current offset.  */
end_comment

begin_function
specifier|static
name|void
name|set_label_offsets
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|,
name|initial_p
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|initial_p
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|elim_table
modifier|*
name|p
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LABEL_REF
case|:
if|if
condition|(
name|LABEL_REF_NONLOCAL_P
argument_list|(
name|x
argument_list|)
condition|)
return|return;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* ... fall through ...  */
case|case
name|CODE_LABEL
case|:
comment|/* If we know nothing about this label, set the desired offsets.  Note 	 that this sets the offset at a label to be the offset before a label 	 if we don't know anything about the label.  This is not correct for 	 the label after a BARRIER, but is the best guess we can make.  If 	 we guessed wrong, we will suppress an elimination that might have 	 been possible had we been able to guess correctly.  */
if|if
condition|(
operator|!
name|offsets_known_at
index|[
name|CODE_LABEL_NUMBER
argument_list|(
name|x
argument_list|)
index|]
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_ELIMINABLE_REGS
condition|;
name|i
operator|++
control|)
name|offsets_at
index|[
name|CODE_LABEL_NUMBER
argument_list|(
name|x
argument_list|)
index|]
index|[
name|i
index|]
operator|=
operator|(
name|initial_p
condition|?
name|reg_eliminate
index|[
name|i
index|]
operator|.
name|initial_offset
else|:
name|reg_eliminate
index|[
name|i
index|]
operator|.
name|offset
operator|)
expr_stmt|;
name|offsets_known_at
index|[
name|CODE_LABEL_NUMBER
argument_list|(
name|x
argument_list|)
index|]
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Otherwise, if this is the definition of a label and it is 	 preceded by a BARRIER, set our offsets to the known offset of 	 that label.  */
elseif|else
if|if
condition|(
name|x
operator|==
name|insn
operator|&&
operator|(
name|tem
operator|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|BARRIER
condition|)
name|set_offsets_for_label
argument_list|(
name|insn
argument_list|)
expr_stmt|;
else|else
comment|/* If neither of the above cases is true, compare each offset 	   with those previously recorded and suppress any eliminations 	   where the offsets disagree.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_ELIMINABLE_REGS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|offsets_at
index|[
name|CODE_LABEL_NUMBER
argument_list|(
name|x
argument_list|)
index|]
index|[
name|i
index|]
operator|!=
operator|(
name|initial_p
condition|?
name|reg_eliminate
index|[
name|i
index|]
operator|.
name|initial_offset
else|:
name|reg_eliminate
index|[
name|i
index|]
operator|.
name|offset
operator|)
condition|)
name|reg_eliminate
index|[
name|i
index|]
operator|.
name|can_eliminate
operator|=
literal|0
expr_stmt|;
return|return;
case|case
name|JUMP_INSN
case|:
name|set_label_offsets
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
name|initial_p
argument_list|)
expr_stmt|;
comment|/* ... fall through ...  */
case|case
name|INSN
case|:
case|case
name|CALL_INSN
case|:
comment|/* Any labels mentioned in REG_LABEL notes can be branched to indirectly 	 and hence must have all eliminations at their initial offsets.  */
for|for
control|(
name|tem
operator|=
name|REG_NOTES
argument_list|(
name|x
argument_list|)
init|;
name|tem
condition|;
name|tem
operator|=
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|tem
argument_list|)
operator|==
name|REG_LABEL
condition|)
name|set_label_offsets
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
comment|/* Each of the labels in the address vector must be at their initial 	 offsets.  We want the first field for ADDR_VEC and the second 	 field for ADDR_DIFF_VEC.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|unsigned
operator|)
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|code
operator|==
name|ADDR_DIFF_VEC
argument_list|)
condition|;
name|i
operator|++
control|)
name|set_label_offsets
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|code
operator|==
name|ADDR_DIFF_VEC
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|,
name|initial_p
argument_list|)
expr_stmt|;
return|return;
case|case
name|SET
case|:
comment|/* We only care about setting PC.  If the source is not RETURN, 	 IF_THEN_ELSE, or a label, disable any eliminations not at 	 their initial offsets.  Similarly if any arm of the IF_THEN_ELSE 	 isn't one of those possibilities.  For branches to a label, 	 call ourselves recursively.  	 Note that this can disable elimination unnecessarily when we have 	 a non-local goto since it will look like a non-constant jump to 	 someplace in the current function.  This isn't a significant 	 problem since such jumps will normally be when all elimination 	 pairs are back to their initial offsets.  */
if|if
condition|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|!=
name|pc_rtx
condition|)
return|return;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|PC
case|:
case|case
name|RETURN
case|:
return|return;
case|case
name|LABEL_REF
case|:
name|set_label_offsets
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|,
name|initial_p
argument_list|)
expr_stmt|;
return|return;
case|case
name|IF_THEN_ELSE
case|:
name|tem
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|set_label_offsets
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|,
name|initial_p
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|!=
name|PC
operator|&&
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|!=
name|RETURN
condition|)
break|break;
name|tem
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|set_label_offsets
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|,
name|initial_p
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|!=
name|PC
operator|&&
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|!=
name|RETURN
condition|)
break|break;
return|return;
default|default:
break|break;
block|}
comment|/* If we reach here, all eliminations must be at their initial 	 offset because we are doing a jump to a variable address.  */
for|for
control|(
name|p
operator|=
name|reg_eliminate
init|;
name|p
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|p
operator|->
name|offset
operator|!=
name|p
operator|->
name|initial_offset
condition|)
name|p
operator|->
name|can_eliminate
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Used for communication between the next two function to properly share    the vector for an ASM_OPERANDS.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|rtvec_def
modifier|*
name|old_asm_operands_vec
decl_stmt|,
modifier|*
name|new_asm_operands_vec
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Scan X and replace any eliminable registers (such as fp) with a    replacement (such as sp), plus an offset.     MEM_MODE is the mode of an enclosing MEM.  We need this to know how    much to adjust a register for, e.g., PRE_DEC.  Also, if we are inside a    MEM, we are allowed to replace a sum of a register and the constant zero    with the register, which we cannot do outside a MEM.  In addition, we need    to record the fact that a register is referenced outside a MEM.     If INSN is an insn, it is the insn containing X.  If we replace a REG    in a SET_DEST with an equivalent MEM and INSN is non-zero, write a    CLOBBER of the pseudo after INSN so find_equiv_regs will know that    the REG is being modified.     Alternatively, INSN may be a note (an EXPR_LIST or INSN_LIST).    That's used when we eliminate in expressions stored in notes.    This means, do not set ref_outside_mem even if the reference    is outside of MEMs.     If we see a modification to a register we know about, take the    appropriate action (see case SET, below).     REG_EQUIV_MEM and REG_EQUIV_ADDRESS contain address that have had    replacements done assuming all offsets are at their initial values.  If    they are not, or if REG_EQUIV_ADDRESS is nonzero for a pseudo we    encounter, return the actual location so that find_reloads will do    the proper thing.  */
end_comment

begin_function
name|rtx
name|eliminate_regs
parameter_list|(
name|x
parameter_list|,
name|mem_mode
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|enum
name|machine_mode
name|mem_mode
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|struct
name|elim_table
modifier|*
name|ep
decl_stmt|;
name|int
name|regno
decl_stmt|;
name|rtx
name|new
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|copied
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|current_function_decl
condition|)
return|return
name|x
return|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CODE_LABEL
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|ASM_INPUT
case|:
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
case|case
name|RETURN
case|:
return|return
name|x
return|;
case|case
name|ADDRESSOF
case|:
comment|/* This is only for the benefit of the debugging backends, which call 	 eliminate_regs on DECL_RTL; any ADDRESSOFs in the actual insns are 	 removed after CSE.  */
name|new
operator|=
name|eliminate_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|new
argument_list|)
operator|==
name|MEM
condition|)
return|return
name|XEXP
argument_list|(
name|new
argument_list|,
literal|0
argument_list|)
return|;
return|return
name|x
return|;
case|case
name|REG
case|:
name|regno
operator|=
name|REGNO
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* First handle the case where we encounter a bare register that 	 is eliminable.  Replace it with a PLUS.  */
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
for|for
control|(
name|ep
operator|=
name|reg_eliminate
init|;
name|ep
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|ep
operator|++
control|)
if|if
condition|(
name|ep
operator|->
name|from_rtx
operator|==
name|x
operator|&&
name|ep
operator|->
name|can_eliminate
condition|)
block|{
if|if
condition|(
operator|!
name|mem_mode
comment|/* Refs inside notes don't count for this purpose.  */
operator|&&
operator|!
operator|(
name|insn
operator|!=
literal|0
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|EXPR_LIST
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN_LIST
operator|)
operator|)
condition|)
name|ep
operator|->
name|ref_outside_mem
operator|=
literal|1
expr_stmt|;
return|return
name|plus_constant
argument_list|(
name|ep
operator|->
name|to_rtx
argument_list|,
name|ep
operator|->
name|previous_offset
argument_list|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|reg_renumber
index|[
name|regno
index|]
operator|<
literal|0
operator|&&
name|reg_equiv_constant
operator|&&
name|reg_equiv_constant
index|[
name|regno
index|]
operator|&&
operator|!
name|CONSTANT_P
argument_list|(
name|reg_equiv_constant
index|[
name|regno
index|]
argument_list|)
condition|)
return|return
name|eliminate_regs
argument_list|(
name|copy_rtx
argument_list|(
name|reg_equiv_constant
index|[
name|regno
index|]
argument_list|)
argument_list|,
name|mem_mode
argument_list|,
name|insn
argument_list|)
return|;
return|return
name|x
return|;
case|case
name|PLUS
case|:
comment|/* If this is the sum of an eliminable register and a constant, rework 	 the sum.   */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
for|for
control|(
name|ep
operator|=
name|reg_eliminate
init|;
name|ep
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|ep
operator|++
control|)
if|if
condition|(
name|ep
operator|->
name|from_rtx
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|&&
name|ep
operator|->
name|can_eliminate
condition|)
block|{
if|if
condition|(
operator|!
name|mem_mode
comment|/* Refs inside notes don't count for this purpose.  */
operator|&&
operator|!
operator|(
name|insn
operator|!=
literal|0
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|EXPR_LIST
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN_LIST
operator|)
operator|)
condition|)
name|ep
operator|->
name|ref_outside_mem
operator|=
literal|1
expr_stmt|;
comment|/* The only time we want to replace a PLUS with a REG (this 		   occurs when the constant operand of the PLUS is the negative 		   of the offset) is when we are inside a MEM.  We won't want 		   to do so at other times because that would change the 		   structure of the insn in a way that reload can't handle. 		   We special-case the commonest situation in 		   eliminate_regs_in_insn, so just replace a PLUS with a 		   PLUS here, unless inside a MEM.  */
if|if
condition|(
name|mem_mode
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
operator|-
name|ep
operator|->
name|previous_offset
condition|)
return|return
name|ep
operator|->
name|to_rtx
return|;
else|else
return|return
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|ep
operator|->
name|to_rtx
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|ep
operator|->
name|previous_offset
argument_list|)
argument_list|)
return|;
block|}
comment|/* If the register is not eliminable, we are done since the other 	     operand is a constant.  */
return|return
name|x
return|;
block|}
comment|/* If this is part of an address, we want to bring any constant to the 	 outermost PLUS.  We will do this by doing register replacement in 	 our operands and seeing if a constant shows up in one of them.  	 We assume here this is part of an address (or a "load address" insn) 	 since an eliminable register is not likely to appear in any other 	 context.  	 If we have (plus (eliminable) (reg)), we want to produce 	 (plus (plus (replacement) (reg) (const))).  If this was part of a 	 normal add insn, (plus (replacement) (reg)) will be pushed as a 	 reload.  This is the desired action.  */
block|{
name|rtx
name|new0
init|=
name|eliminate_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mem_mode
argument_list|,
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|new1
init|=
name|eliminate_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mem_mode
argument_list|,
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|new0
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|||
name|new1
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|/* If one side is a PLUS and the other side is a pseudo that 	       didn't get a hard register but has a reg_equiv_constant, 	       we must replace the constant here since it may no longer 	       be in the position of any operand.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|new0
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|new1
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|new1
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_renumber
index|[
name|REGNO
argument_list|(
name|new1
argument_list|)
index|]
operator|<
literal|0
operator|&&
name|reg_equiv_constant
operator|!=
literal|0
operator|&&
name|reg_equiv_constant
index|[
name|REGNO
argument_list|(
name|new1
argument_list|)
index|]
operator|!=
literal|0
condition|)
name|new1
operator|=
name|reg_equiv_constant
index|[
name|REGNO
argument_list|(
name|new1
argument_list|)
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|new1
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|new0
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|new0
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_renumber
index|[
name|REGNO
argument_list|(
name|new0
argument_list|)
index|]
operator|<
literal|0
operator|&&
name|reg_equiv_constant
index|[
name|REGNO
argument_list|(
name|new0
argument_list|)
index|]
operator|!=
literal|0
condition|)
name|new0
operator|=
name|reg_equiv_constant
index|[
name|REGNO
argument_list|(
name|new0
argument_list|)
index|]
expr_stmt|;
name|new
operator|=
name|form_sum
argument_list|(
name|new0
argument_list|,
name|new1
argument_list|)
expr_stmt|;
comment|/* As above, if we are not inside a MEM we do not want to 	       turn a PLUS into something else.  We might try to do so here 	       for an addition of 0 if we aren't optimizing.  */
if|if
condition|(
operator|!
name|mem_mode
operator|&&
name|GET_CODE
argument_list|(
name|new
argument_list|)
operator|!=
name|PLUS
condition|)
return|return
name|gen_rtx_PLUS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|new
argument_list|,
name|const0_rtx
argument_list|)
return|;
else|else
return|return
name|new
return|;
block|}
block|}
return|return
name|x
return|;
case|case
name|MULT
case|:
comment|/* If this is the product of an eliminable register and a  	 constant, apply the distribute law and move the constant out 	 so that we have (plus (mult ..) ..).  This is needed in order 	 to keep load-address insns valid.   This case is pathological. 	 We ignore the possibility of overflow here.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
for|for
control|(
name|ep
operator|=
name|reg_eliminate
init|;
name|ep
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|ep
operator|++
control|)
if|if
condition|(
name|ep
operator|->
name|from_rtx
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|&&
name|ep
operator|->
name|can_eliminate
condition|)
block|{
if|if
condition|(
operator|!
name|mem_mode
comment|/* Refs inside notes don't count for this purpose.  */
operator|&&
operator|!
operator|(
name|insn
operator|!=
literal|0
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|EXPR_LIST
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN_LIST
operator|)
operator|)
condition|)
name|ep
operator|->
name|ref_outside_mem
operator|=
literal|1
expr_stmt|;
return|return
name|plus_constant
argument_list|(
name|gen_rtx_MULT
argument_list|(
name|Pmode
argument_list|,
name|ep
operator|->
name|to_rtx
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|ep
operator|->
name|previous_offset
operator|*
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/* ... fall through ...  */
case|case
name|CALL
case|:
case|case
name|COMPARE
case|:
case|case
name|MINUS
case|:
case|case
name|DIV
case|:
case|case
name|UDIV
case|:
case|case
name|MOD
case|:
case|case
name|UMOD
case|:
case|case
name|AND
case|:
case|case
name|IOR
case|:
case|case
name|XOR
case|:
case|case
name|ROTATERT
case|:
case|case
name|ROTATE
case|:
case|case
name|ASHIFTRT
case|:
case|case
name|LSHIFTRT
case|:
case|case
name|ASHIFT
case|:
case|case
name|NE
case|:
case|case
name|EQ
case|:
case|case
name|GE
case|:
case|case
name|GT
case|:
case|case
name|GEU
case|:
case|case
name|GTU
case|:
case|case
name|LE
case|:
case|case
name|LT
case|:
case|case
name|LEU
case|:
case|case
name|LTU
case|:
block|{
name|rtx
name|new0
init|=
name|eliminate_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mem_mode
argument_list|,
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|new1
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|?
name|eliminate_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mem_mode
argument_list|,
name|insn
argument_list|)
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|new0
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|||
name|new1
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|new0
argument_list|,
name|new1
argument_list|)
return|;
block|}
return|return
name|x
return|;
case|case
name|EXPR_LIST
case|:
comment|/* If we have something in XEXP (x, 0), the usual case, eliminate it.  */
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|new
operator|=
name|eliminate_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mem_mode
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* If this is a REG_DEAD note, it is not valid anymore. 		 Using the eliminated version could result in creating a 		 REG_DEAD note for the stack or frame pointer.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG_DEAD
condition|)
return|return
operator|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|?
name|eliminate_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mem_mode
argument_list|,
name|insn
argument_list|)
else|:
name|NULL_RTX
operator|)
return|;
name|x
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_NOTE_KIND
argument_list|(
name|x
argument_list|)
argument_list|,
name|new
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* ... fall through ...  */
case|case
name|INSN_LIST
case|:
comment|/* Now do eliminations in the rest of the chain.  If this was 	 an EXPR_LIST, this might result in allocating more memory than is 	 strictly needed, but it simplifies the code.  */
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|new
operator|=
name|eliminate_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mem_mode
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|gen_rtx_fmt_ee
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|new
argument_list|)
return|;
block|}
return|return
name|x
return|;
case|case
name|PRE_INC
case|:
case|case
name|POST_INC
case|:
case|case
name|PRE_DEC
case|:
case|case
name|POST_DEC
case|:
for|for
control|(
name|ep
operator|=
name|reg_eliminate
init|;
name|ep
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|ep
operator|++
control|)
if|if
condition|(
name|ep
operator|->
name|to_rtx
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|int
name|size
init|=
name|GET_MODE_SIZE
argument_list|(
name|mem_mode
argument_list|)
decl_stmt|;
comment|/* If more bytes than MEM_MODE are pushed, account for them.  */
ifdef|#
directive|ifdef
name|PUSH_ROUNDING
if|if
condition|(
name|ep
operator|->
name|to_rtx
operator|==
name|stack_pointer_rtx
condition|)
name|size
operator|=
name|PUSH_ROUNDING
argument_list|(
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|code
operator|==
name|PRE_DEC
operator|||
name|code
operator|==
name|POST_DEC
condition|)
name|ep
operator|->
name|offset
operator|+=
name|size
expr_stmt|;
else|else
name|ep
operator|->
name|offset
operator|-=
name|size
expr_stmt|;
block|}
comment|/* Fall through to generic unary operation case.  */
case|case
name|STRICT_LOW_PART
case|:
case|case
name|NEG
case|:
case|case
name|NOT
case|:
case|case
name|SIGN_EXTEND
case|:
case|case
name|ZERO_EXTEND
case|:
case|case
name|TRUNCATE
case|:
case|case
name|FLOAT_EXTEND
case|:
case|case
name|FLOAT_TRUNCATE
case|:
case|case
name|FLOAT
case|:
case|case
name|FIX
case|:
case|case
name|UNSIGNED_FIX
case|:
case|case
name|UNSIGNED_FLOAT
case|:
case|case
name|ABS
case|:
case|case
name|SQRT
case|:
case|case
name|FFS
case|:
name|new
operator|=
name|eliminate_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mem_mode
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|gen_rtx_fmt_e
argument_list|(
name|code
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|new
argument_list|)
return|;
return|return
name|x
return|;
case|case
name|SUBREG
case|:
comment|/* Similar to above processing, but preserve SUBREG_WORD. 	 Convert (subreg (mem)) to (mem) if not paradoxical. 	 Also, if we have a non-paradoxical (subreg (pseudo)) and the 	 pseudo didn't get a hard reg, we must replace this with the 	 eliminated version of the memory location because push_reloads 	 may do the replacement in certain circumstances.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
name|reg_equiv_memory_loc
operator|!=
literal|0
operator|&&
name|reg_equiv_memory_loc
index|[
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
index|]
operator|!=
literal|0
condition|)
block|{
if|#
directive|if
literal|0
block|new = eliminate_regs (reg_equiv_memory_loc[REGNO (SUBREG_REG (x))], 				mem_mode, insn);
comment|/* If we didn't change anything, we must retain the pseudo.  */
block|if (new == reg_equiv_memory_loc[REGNO (SUBREG_REG (x))]) 	    new = SUBREG_REG (x); 	  else 	    {
comment|/* In this case, we must show that the pseudo is used in this 		 insn so that delete_output_reload will do the right thing.  */
block|if (insn != 0&& GET_CODE (insn) != EXPR_LIST&& GET_CODE (insn) != INSN_LIST) 		REG_NOTES (emit_insn_before (gen_rtx_USE (VOIDmode, 							  SUBREG_REG (x)), 							  insn)) 		  = gen_rtx_EXPR_LIST (REG_EQUAL, new, NULL_RTX);
comment|/* Ensure NEW isn't shared in case we have to reload it.  */
block|new = copy_rtx (new); 	    }
else|#
directive|else
name|new
operator|=
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|new
operator|=
name|eliminate_regs
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
name|mem_mode
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|int
name|x_size
init|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|new_size
init|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|new
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|new
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
operator|(
name|x_size
operator|<
name|new_size
ifdef|#
directive|ifdef
name|WORD_REGISTER_OPERATIONS
comment|/* On these machines, combine can create rtl of the form 		      (set (subreg:m1 (reg:m2 R) 0) ...) 		      where m1< m2, and expects something interesting to  		      happen to the entire word.  Moreover, it will use the 		      (reg:m2 R) later, expecting all bits to be preserved. 		      So if the number of words is the same, preserve the  		      subreg so that push_reloads can see it.  */
operator|&&
operator|!
operator|(
operator|(
name|x_size
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
operator|==
operator|(
name|new_size
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
endif|#
directive|endif
operator|)
operator|||
operator|(
name|x_size
operator|==
name|new_size
operator|)
operator|)
condition|)
block|{
name|int
name|offset
init|=
name|SUBREG_WORD
argument_list|(
name|x
argument_list|)
operator|*
name|UNITS_PER_WORD
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
name|offset
operator|+=
operator|(
name|MIN
argument_list|(
name|UNITS_PER_WORD
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|new
argument_list|)
argument_list|)
argument_list|)
operator|-
name|MIN
argument_list|(
name|UNITS_PER_WORD
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|new
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|new
argument_list|,
literal|0
argument_list|)
operator|=
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|new
argument_list|,
literal|0
argument_list|)
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
else|else
return|return
name|gen_rtx_SUBREG
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|new
argument_list|,
name|SUBREG_WORD
argument_list|(
name|x
argument_list|)
argument_list|)
return|;
block|}
return|return
name|x
return|;
case|case
name|USE
case|:
comment|/* If using a register that is the source of an eliminate we still 	 think can be performed, note it cannot be performed since we don't 	 know how this register is used.  */
for|for
control|(
name|ep
operator|=
name|reg_eliminate
init|;
name|ep
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|ep
operator|++
control|)
if|if
condition|(
name|ep
operator|->
name|from_rtx
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|)
name|ep
operator|->
name|can_eliminate
operator|=
literal|0
expr_stmt|;
name|new
operator|=
name|eliminate_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mem_mode
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|gen_rtx_fmt_e
argument_list|(
name|code
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|new
argument_list|)
return|;
return|return
name|x
return|;
case|case
name|CLOBBER
case|:
comment|/* If clobbering a register that is the replacement register for an 	 elimination we still think can be performed, note that it cannot 	 be performed.  Otherwise, we need not be concerned about it.  */
for|for
control|(
name|ep
operator|=
name|reg_eliminate
init|;
name|ep
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|ep
operator|++
control|)
if|if
condition|(
name|ep
operator|->
name|to_rtx
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|)
name|ep
operator|->
name|can_eliminate
operator|=
literal|0
expr_stmt|;
name|new
operator|=
name|eliminate_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mem_mode
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|gen_rtx_fmt_e
argument_list|(
name|code
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|new
argument_list|)
return|;
return|return
name|x
return|;
case|case
name|ASM_OPERANDS
case|:
block|{
name|rtx
modifier|*
name|temp_vec
decl_stmt|;
comment|/* Properly handle sharing input and constraint vectors.  */
if|if
condition|(
name|ASM_OPERANDS_INPUT_VEC
argument_list|(
name|x
argument_list|)
operator|!=
name|old_asm_operands_vec
condition|)
block|{
comment|/* When we come to a new vector not seen before, 	       scan all its elements; keep the old vector if none 	       of them changes; otherwise, make a copy.  */
name|old_asm_operands_vec
operator|=
name|ASM_OPERANDS_INPUT_VEC
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|temp_vec
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|3
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|x
argument_list|)
condition|;
name|i
operator|++
control|)
name|temp_vec
index|[
name|i
index|]
operator|=
name|eliminate_regs
argument_list|(
name|ASM_OPERANDS_INPUT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|mem_mode
argument_list|,
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|x
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|temp_vec
index|[
name|i
index|]
operator|!=
name|ASM_OPERANDS_INPUT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|x
argument_list|)
condition|)
name|new_asm_operands_vec
operator|=
name|old_asm_operands_vec
expr_stmt|;
else|else
name|new_asm_operands_vec
operator|=
name|gen_rtvec_v
argument_list|(
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|x
argument_list|)
argument_list|,
name|temp_vec
argument_list|)
expr_stmt|;
block|}
comment|/* If we had to copy the vector, copy the entire ASM_OPERANDS.  */
if|if
condition|(
name|new_asm_operands_vec
operator|==
name|old_asm_operands_vec
condition|)
return|return
name|x
return|;
name|new
operator|=
name|gen_rtx_ASM_OPERANDS
argument_list|(
name|VOIDmode
argument_list|,
name|ASM_OPERANDS_TEMPLATE
argument_list|(
name|x
argument_list|)
argument_list|,
name|ASM_OPERANDS_OUTPUT_CONSTRAINT
argument_list|(
name|x
argument_list|)
argument_list|,
name|ASM_OPERANDS_OUTPUT_IDX
argument_list|(
name|x
argument_list|)
argument_list|,
name|new_asm_operands_vec
argument_list|,
name|ASM_OPERANDS_INPUT_CONSTRAINT_VEC
argument_list|(
name|x
argument_list|)
argument_list|,
name|ASM_OPERANDS_SOURCE_FILE
argument_list|(
name|x
argument_list|)
argument_list|,
name|ASM_OPERANDS_SOURCE_LINE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|volatil
operator|=
name|x
operator|->
name|volatil
expr_stmt|;
return|return
name|new
return|;
block|}
case|case
name|SET
case|:
comment|/* Check for setting a register that we know about.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
comment|/* See if this is setting the replacement register for an 	     elimination.  	     If DEST is the hard frame pointer, we do nothing because we 	     assume that all assignments to the frame pointer are for 	     non-local gotos and are being done at a time when they are valid 	     and do not disturb anything else.  Some machines want to 	     eliminate a fake argument pointer (or even a fake frame pointer) 	     with either the real frame or the stack pointer.  Assignments to 	     the hard frame pointer must not prevent this elimination.  */
for|for
control|(
name|ep
operator|=
name|reg_eliminate
init|;
name|ep
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|ep
operator|++
control|)
if|if
condition|(
name|ep
operator|->
name|to_rtx
operator|==
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|&&
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|!=
name|hard_frame_pointer_rtx
condition|)
block|{
comment|/* If it is being incremented, adjust the offset.  Otherwise, 		   this elimination can't be done.  */
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
operator|==
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|ep
operator|->
name|offset
operator|-=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|ep
operator|->
name|can_eliminate
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Now check to see we are assigning to a register that can be 	     eliminated.  If so, it must be as part of a PARALLEL, since we 	     will not have been called if this is a single SET.  So indicate 	     that we can no longer eliminate this reg.  */
for|for
control|(
name|ep
operator|=
name|reg_eliminate
init|;
name|ep
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|ep
operator|++
control|)
if|if
condition|(
name|ep
operator|->
name|from_rtx
operator|==
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|&&
name|ep
operator|->
name|can_eliminate
condition|)
name|ep
operator|->
name|can_eliminate
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Now avoid the loop below in this common case.  */
block|{
name|rtx
name|new0
init|=
name|eliminate_regs
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|,
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|new1
init|=
name|eliminate_regs
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|,
name|insn
argument_list|)
decl_stmt|;
comment|/* If SET_DEST changed from a REG to a MEM and INSN is an insn, 	   write a CLOBBER insn.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|new0
argument_list|)
operator|==
name|MEM
operator|&&
name|insn
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|EXPR_LIST
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|INSN_LIST
condition|)
name|emit_insn_after
argument_list|(
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|new0
operator|!=
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|||
name|new1
operator|!=
name|SET_SRC
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|new0
argument_list|,
name|new1
argument_list|)
return|;
block|}
return|return
name|x
return|;
case|case
name|MEM
case|:
comment|/* This is only for the benefit of the debugging backends, which call 	 eliminate_regs on DECL_RTL; any ADDRESSOFs in the actual insns are 	 removed after CSE.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDRESSOF
condition|)
return|return
name|eliminate_regs
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
name|insn
argument_list|)
return|;
comment|/* Our only special processing is to pass the mode of the MEM to our 	 recursive call and copy the flags.  While we are here, handle this 	 case more efficiently.  */
name|new
operator|=
name|eliminate_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|new
operator|=
name|gen_rtx_MEM
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|->
name|volatil
operator|=
name|x
operator|->
name|volatil
expr_stmt|;
name|new
operator|->
name|unchanging
operator|=
name|x
operator|->
name|unchanging
expr_stmt|;
name|new
operator|->
name|in_struct
operator|=
name|x
operator|->
name|in_struct
expr_stmt|;
return|return
name|new
return|;
block|}
else|else
return|return
name|x
return|;
default|default:
break|break;
block|}
comment|/* Process each of our operands recursively.  If any have changed, make a      copy of the rtx.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
condition|;
name|i
operator|++
operator|,
name|fmt
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'e'
condition|)
block|{
name|new
operator|=
name|eliminate_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|mem_mode
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|&&
operator|!
name|copied
condition|)
block|{
name|rtx
name|new_x
init|=
name|rtx_alloc
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|x
argument_list|,
operator|(
name|char
operator|*
operator|)
name|new_x
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|new_x
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|new_x
operator|->
name|fld
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|new_x
operator|->
name|fld
index|[
literal|0
index|]
argument_list|)
operator|*
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|new_x
expr_stmt|;
name|copied
operator|=
literal|1
expr_stmt|;
block|}
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|=
name|new
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'E'
condition|)
block|{
name|int
name|copied_vec
init|=
literal|0
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|new
operator|=
name|eliminate_regs
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|mem_mode
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|!=
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|&&
operator|!
name|copied_vec
condition|)
block|{
name|rtvec
name|new_v
init|=
name|gen_rtvec_vv
argument_list|(
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|XVEC
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|->
name|elem
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|copied
condition|)
block|{
name|rtx
name|new_x
init|=
name|rtx_alloc
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|x
argument_list|,
operator|(
name|char
operator|*
operator|)
name|new_x
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|new_x
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|new_x
operator|->
name|fld
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|new_x
operator|->
name|fld
index|[
literal|0
index|]
argument_list|)
operator|*
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|)
operator|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|new_x
expr_stmt|;
name|copied
operator|=
literal|1
expr_stmt|;
block|}
name|XVEC
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|=
name|new_v
expr_stmt|;
name|copied_vec
operator|=
literal|1
expr_stmt|;
block|}
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|=
name|new
expr_stmt|;
block|}
block|}
block|}
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Scan INSN and eliminate all eliminable registers in it.     If REPLACE is nonzero, do the replacement destructively.  Also    delete the insn as dead it if it is setting an eliminable register.     If REPLACE is zero, do all our allocations in reload_obstack.     If no eliminations were done and this insn doesn't require any elimination    processing (these are not identical conditions: it might be updating sp,    but not referencing fp; this needs to be seen during reload_as_needed so    that the offset between fp and sp can be taken into consideration), zero    is returned.  Otherwise, 1 is returned.  */
end_comment

begin_function
specifier|static
name|int
name|eliminate_regs_in_insn
parameter_list|(
name|insn
parameter_list|,
name|replace
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|int
name|replace
decl_stmt|;
block|{
name|rtx
name|old_body
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|old_set
init|=
name|single_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|new_body
decl_stmt|;
name|int
name|val
init|=
literal|0
decl_stmt|;
name|struct
name|elim_table
modifier|*
name|ep
decl_stmt|;
if|if
condition|(
operator|!
name|replace
condition|)
name|push_obstacks
argument_list|(
operator|&
name|reload_obstack
argument_list|,
operator|&
name|reload_obstack
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_set
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|old_set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|old_set
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
comment|/* Check for setting an eliminable register.  */
for|for
control|(
name|ep
operator|=
name|reg_eliminate
init|;
name|ep
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|ep
operator|++
control|)
if|if
condition|(
name|ep
operator|->
name|from_rtx
operator|==
name|SET_DEST
argument_list|(
name|old_set
argument_list|)
operator|&&
name|ep
operator|->
name|can_eliminate
condition|)
block|{
if|#
directive|if
name|HARD_FRAME_POINTER_REGNUM
operator|!=
name|FRAME_POINTER_REGNUM
comment|/* If this is setting the frame pointer register to the 	       hardware frame pointer register and this is an elimination 	       that will be done (tested above), this insn is really 	       adjusting the frame pointer downward to compensate for 	       the adjustment done before a nonlocal goto.  */
if|if
condition|(
name|ep
operator|->
name|from
operator|==
name|FRAME_POINTER_REGNUM
operator|&&
name|ep
operator|->
name|to
operator|==
name|HARD_FRAME_POINTER_REGNUM
condition|)
block|{
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|old_set
argument_list|)
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|,
name|ok
init|=
literal|0
decl_stmt|;
name|rtx
name|prev_insn
decl_stmt|,
name|prev_set
decl_stmt|;
if|if
condition|(
name|src
operator|==
name|ep
operator|->
name|to_rtx
condition|)
name|offset
operator|=
literal|0
operator|,
name|ok
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
operator|==
name|ep
operator|->
name|to_rtx
condition|)
name|offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|,
name|ok
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
operator|==
name|ep
operator|->
name|to_rtx
condition|)
name|offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|,
name|ok
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|prev_insn
operator|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|prev_set
operator|=
name|single_set
argument_list|(
name|prev_insn
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_DEST
argument_list|(
name|prev_set
argument_list|)
argument_list|,
name|src
argument_list|)
condition|)
block|{
name|src
operator|=
name|SET_SRC
argument_list|(
name|prev_set
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
operator|==
name|ep
operator|->
name|to_rtx
condition|)
name|offset
operator|=
literal|0
operator|,
name|ok
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
operator|==
name|ep
operator|->
name|to_rtx
condition|)
name|offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|,
name|ok
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
operator|==
name|ep
operator|->
name|to_rtx
condition|)
name|offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|,
name|ok
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ok
condition|)
block|{
if|if
condition|(
name|replace
condition|)
block|{
name|rtx
name|src
init|=
name|plus_constant
argument_list|(
name|ep
operator|->
name|to_rtx
argument_list|,
name|offset
operator|-
name|ep
operator|->
name|offset
argument_list|)
decl_stmt|;
comment|/* First see if this insn remains valid when we 			   make the change.  If not, keep the INSN_CODE 			   the same and let reload fit it up.  */
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|old_set
argument_list|)
argument_list|,
name|src
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_DEST
argument_list|(
name|old_set
argument_list|)
argument_list|,
name|ep
operator|->
name|to_rtx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|apply_change_group
argument_list|()
condition|)
block|{
name|SET_SRC
argument_list|(
name|old_set
argument_list|)
operator|=
name|src
expr_stmt|;
name|SET_DEST
argument_list|(
name|old_set
argument_list|)
operator|=
name|ep
operator|->
name|to_rtx
expr_stmt|;
block|}
block|}
name|val
operator|=
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
endif|#
directive|endif
comment|/* In this case this insn isn't serving a useful purpose.  We 	       will delete it in reload_as_needed once we know that this 	       elimination is, in fact, being done.  	       If REPLACE isn't set, we can't delete this insn, but needn't 	       process it since it won't be used unless something changes.  */
if|if
condition|(
name|replace
condition|)
name|delete_dead_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|val
operator|=
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Check for (set (reg) (plus (reg from) (offset))) where the offset 	 in the insn is the negative of the offset in FROM.  Substitute 	 (set (reg) (reg to)) for the insn and change its code.  	 We have to do this here, rather than in eliminate_regs, so that we can 	 change the insn code.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|old_set
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|old_set
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|old_set
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
for|for
control|(
name|ep
operator|=
name|reg_eliminate
init|;
name|ep
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|ep
operator|++
control|)
if|if
condition|(
name|ep
operator|->
name|from_rtx
operator|==
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|old_set
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|&&
name|ep
operator|->
name|can_eliminate
condition|)
block|{
comment|/* We must stop at the first elimination that will be used. 		 If this one would replace the PLUS with a REG, do it 		 now.  Otherwise, quit the loop and let eliminate_regs 		 do its normal replacement.  */
if|if
condition|(
name|ep
operator|->
name|offset
operator|==
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|old_set
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
comment|/* We assume here that we don't need a PARALLEL of 		     any CLOBBERs for this assignment.  There's not 		     much we can do if we do need it.  */
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|SET_DEST
argument_list|(
name|old_set
argument_list|)
argument_list|,
name|ep
operator|->
name|to_rtx
argument_list|)
expr_stmt|;
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|val
operator|=
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
break|break;
block|}
block|}
name|old_asm_operands_vec
operator|=
literal|0
expr_stmt|;
comment|/* Replace the body of this insn with a substituted form.  If we changed      something, return non-zero.         If we are replacing a body that was a (set X (plus Y Z)), try to      re-recognize the insn.  We do this in case we had a simple addition      but now can do this as a load-address.  This saves an insn in this      common case.  */
name|new_body
operator|=
name|eliminate_regs
argument_list|(
name|old_body
argument_list|,
literal|0
argument_list|,
name|replace
condition|?
name|insn
else|:
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_body
operator|!=
name|old_body
condition|)
block|{
comment|/* If we aren't replacing things permanently and we changed something, 	 make another copy to ensure that all the RTL is new.  Otherwise 	 things can go wrong if find_reload swaps commutative operands 	 and one is inside RTL that has been copied while the other is not.  */
comment|/* Don't copy an asm_operands because (1) there's no need and (2) 	 copy_rtx can't do it properly when there are multiple outputs.  */
if|if
condition|(
operator|!
name|replace
operator|&&
name|asm_noperands
argument_list|(
name|old_body
argument_list|)
operator|<
literal|0
condition|)
name|new_body
operator|=
name|copy_rtx
argument_list|(
name|new_body
argument_list|)
expr_stmt|;
comment|/* If we had a move insn but now we don't, rerecognize it.  This will 	 cause spurious re-recognition if the old move had a PARALLEL since 	 the new one still will, but we can't call single_set without 	 having put NEW_BODY into the insn and the re-recognition won't 	 hurt in this rare case.  */
if|if
condition|(
name|old_set
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|old_set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|new_body
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|new_body
argument_list|)
argument_list|)
operator|!=
name|REG
operator|)
operator|)
comment|/* If this was a load from or store to memory, compare 		 the MEM in recog_operand to the one in the insn.  If they 		 are not equal, then rerecognize the insn.  */
operator|||
operator|(
name|old_set
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|old_set
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|SET_SRC
argument_list|(
name|old_set
argument_list|)
operator|!=
name|recog_operand
index|[
literal|1
index|]
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|old_set
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|SET_DEST
argument_list|(
name|old_set
argument_list|)
operator|!=
name|recog_operand
index|[
literal|0
index|]
operator|)
operator|)
operator|)
comment|/* If this was an add insn before, rerecognize.  */
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|old_set
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|new_body
argument_list|,
literal|0
argument_list|)
condition|)
comment|/* If recognition fails, store the new body anyway. 	       It's normal to have recognition failures here 	       due to bizarre memory addresses; reloading will fix them.  */
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|new_body
expr_stmt|;
block|}
else|else
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|new_body
expr_stmt|;
name|val
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Loop through all elimination pairs.  See if any have changed.       We also detect a cases where register elimination cannot be done,      namely, if a register would be both changed and referenced outside a MEM      in the resulting insn since such an insn is often undefined and, even if      not, we cannot know what meaning will be given to it.  Note that it is      valid to have a register used in an address in an insn that changes it      (presumably with a pre- or post-increment or decrement).       If anything changes, return nonzero.  */
for|for
control|(
name|ep
operator|=
name|reg_eliminate
init|;
name|ep
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|ep
operator|++
control|)
block|{
if|if
condition|(
name|ep
operator|->
name|previous_offset
operator|!=
name|ep
operator|->
name|offset
operator|&&
name|ep
operator|->
name|ref_outside_mem
condition|)
name|ep
operator|->
name|can_eliminate
operator|=
literal|0
expr_stmt|;
name|ep
operator|->
name|ref_outside_mem
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|previous_offset
operator|!=
name|ep
operator|->
name|offset
condition|)
name|val
operator|=
literal|1
expr_stmt|;
block|}
name|done
label|:
comment|/* If we changed something, perform elimination in REG_NOTES.  This is      needed even when REPLACE is zero because a REG_DEAD note might refer      to a register that we eliminate and could cause a different number      of spill registers to be needed in the final reload pass than in      the pre-passes.  */
if|if
condition|(
name|val
operator|&&
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|!=
literal|0
condition|)
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|eliminate_regs
argument_list|(
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|replace
condition|)
name|pop_obstacks
argument_list|()
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Loop through all elimination pairs.    Recalculate the number not at initial offset.     Compute the maximum offset (minimum offset if the stack does not    grow downward) for each elimination pair.  */
end_comment

begin_function
specifier|static
name|void
name|update_eliminable_offsets
parameter_list|()
block|{
name|struct
name|elim_table
modifier|*
name|ep
decl_stmt|;
name|num_not_at_initial_offset
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ep
operator|=
name|reg_eliminate
init|;
name|ep
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|ep
operator|++
control|)
block|{
name|ep
operator|->
name|previous_offset
operator|=
name|ep
operator|->
name|offset
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|can_eliminate
operator|&&
name|ep
operator|->
name|offset
operator|!=
name|ep
operator|->
name|initial_offset
condition|)
name|num_not_at_initial_offset
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Given X, a SET or CLOBBER of DEST, if DEST is the target of a register    replacement we currently believe is valid, mark it as not eliminable if X    modifies DEST in any way other than by adding a constant integer to it.     If DEST is the frame pointer, we do nothing because we assume that    all assignments to the hard frame pointer are nonlocal gotos and are being    done at a time when they are valid and do not disturb anything else.    Some machines want to eliminate a fake argument pointer with either the    frame or stack pointer.  Assignments to the hard frame pointer must not    prevent this elimination.     Called via note_stores from reload before starting its passes to scan    the insns of the function.  */
end_comment

begin_function
specifier|static
name|void
name|mark_not_eliminable
parameter_list|(
name|dest
parameter_list|,
name|x
parameter_list|)
name|rtx
name|dest
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* A SUBREG of a hard register here is just changing its mode.  We should      not see a SUBREG of an eliminable hard register, but check just in      case.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
condition|)
name|dest
operator|=
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
operator|==
name|hard_frame_pointer_rtx
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_ELIMINABLE_REGS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reg_eliminate
index|[
name|i
index|]
operator|.
name|can_eliminate
operator|&&
name|dest
operator|==
name|reg_eliminate
index|[
name|i
index|]
operator|.
name|to_rtx
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|PLUS
operator|||
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|!=
name|dest
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|)
condition|)
block|{
name|reg_eliminate
index|[
name|i
index|]
operator|.
name|can_eliminate_previous
operator|=
name|reg_eliminate
index|[
name|i
index|]
operator|.
name|can_eliminate
operator|=
literal|0
expr_stmt|;
name|num_eliminable
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Verify that the initial elimination offsets did not change since the    last call to set_initial_elim_offsets.  This is used to catch cases    where something illegal happened during reload_as_needed that could    cause incorrect code to be generated if we did not check for it.  */
end_comment

begin_function
specifier|static
name|void
name|verify_initial_elim_offsets
parameter_list|()
block|{
name|int
name|t
decl_stmt|;
ifdef|#
directive|ifdef
name|ELIMINABLE_REGS
name|struct
name|elim_table
modifier|*
name|ep
decl_stmt|;
for|for
control|(
name|ep
operator|=
name|reg_eliminate
init|;
name|ep
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|ep
operator|++
control|)
block|{
name|INITIAL_ELIMINATION_OFFSET
argument_list|(
name|ep
operator|->
name|from
argument_list|,
name|ep
operator|->
name|to
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|ep
operator|->
name|initial_offset
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
else|#
directive|else
name|INITIAL_FRAME_POINTER_OFFSET
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|reg_eliminate
index|[
literal|0
index|]
operator|.
name|initial_offset
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Reset all offsets on eliminable registers to their initial values.  */
end_comment

begin_function
specifier|static
name|void
name|set_initial_elim_offsets
parameter_list|()
block|{
name|struct
name|elim_table
modifier|*
name|ep
init|=
name|reg_eliminate
decl_stmt|;
ifdef|#
directive|ifdef
name|ELIMINABLE_REGS
for|for
control|(
init|;
name|ep
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|ep
operator|++
control|)
block|{
name|INITIAL_ELIMINATION_OFFSET
argument_list|(
name|ep
operator|->
name|from
argument_list|,
name|ep
operator|->
name|to
argument_list|,
name|ep
operator|->
name|initial_offset
argument_list|)
expr_stmt|;
name|ep
operator|->
name|previous_offset
operator|=
name|ep
operator|->
name|offset
operator|=
name|ep
operator|->
name|initial_offset
expr_stmt|;
block|}
else|#
directive|else
name|INITIAL_FRAME_POINTER_OFFSET
argument_list|(
name|ep
operator|->
name|initial_offset
argument_list|)
expr_stmt|;
name|ep
operator|->
name|previous_offset
operator|=
name|ep
operator|->
name|offset
operator|=
name|ep
operator|->
name|initial_offset
expr_stmt|;
endif|#
directive|endif
name|num_not_at_initial_offset
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize the known label offsets.    Set a known offset for each forced label to be at the initial offset    of each elimination.  We do this because we assume that all    computed jumps occur from a location where each elimination is    at its initial offset.    For all other labels, show that we don't know the offsets.  */
end_comment

begin_function
specifier|static
name|void
name|set_initial_label_offsets
parameter_list|()
block|{
name|rtx
name|x
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|offsets_known_at
index|[
name|get_first_label_num
argument_list|()
index|]
argument_list|,
name|num_labels
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
name|forced_labels
init|;
name|x
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|)
name|set_label_offsets
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set all elimination offsets to the known values for the code label given    by INSN.  */
end_comment

begin_function
specifier|static
name|void
name|set_offsets_for_label
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|int
name|label_nr
init|=
name|CODE_LABEL_NUMBER
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|struct
name|elim_table
modifier|*
name|ep
decl_stmt|;
name|num_not_at_initial_offset
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|ep
operator|=
name|reg_eliminate
init|;
name|i
operator|<
name|NUM_ELIMINABLE_REGS
condition|;
name|ep
operator|++
operator|,
name|i
operator|++
control|)
block|{
name|ep
operator|->
name|offset
operator|=
name|ep
operator|->
name|previous_offset
operator|=
name|offsets_at
index|[
name|label_nr
index|]
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|can_eliminate
operator|&&
name|ep
operator|->
name|offset
operator|!=
name|ep
operator|->
name|initial_offset
condition|)
name|num_not_at_initial_offset
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* See if anything that happened changes which eliminations are valid.    For example, on the Sparc, whether or not the frame pointer can    be eliminated can depend on what registers have been used.  We need    not check some conditions again (such as flag_omit_frame_pointer)    since they can't have changed.  */
end_comment

begin_function
specifier|static
name|void
name|update_eliminables
parameter_list|(
name|pset
parameter_list|)
name|HARD_REG_SET
modifier|*
name|pset
decl_stmt|;
block|{
if|#
directive|if
name|HARD_FRAME_POINTER_REGNUM
operator|!=
name|FRAME_POINTER_REGNUM
name|int
name|previous_frame_pointer_needed
init|=
name|frame_pointer_needed
decl_stmt|;
endif|#
directive|endif
name|struct
name|elim_table
modifier|*
name|ep
decl_stmt|;
for|for
control|(
name|ep
operator|=
name|reg_eliminate
init|;
name|ep
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|ep
operator|++
control|)
if|if
condition|(
operator|(
name|ep
operator|->
name|from
operator|==
name|HARD_FRAME_POINTER_REGNUM
operator|&&
name|FRAME_POINTER_REQUIRED
operator|)
ifdef|#
directive|ifdef
name|ELIMINABLE_REGS
operator|||
operator|!
name|CAN_ELIMINATE
argument_list|(
name|ep
operator|->
name|from
argument_list|,
name|ep
operator|->
name|to
argument_list|)
endif|#
directive|endif
condition|)
name|ep
operator|->
name|can_eliminate
operator|=
literal|0
expr_stmt|;
comment|/* Look for the case where we have discovered that we can't replace      register A with register B and that means that we will now be      trying to replace register A with register C.  This means we can      no longer replace register C with register B and we need to disable      such an elimination, if it exists.  This occurs often with A == ap,      B == sp, and C == fp.  */
for|for
control|(
name|ep
operator|=
name|reg_eliminate
init|;
name|ep
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|ep
operator|++
control|)
block|{
name|struct
name|elim_table
modifier|*
name|op
decl_stmt|;
specifier|register
name|int
name|new_to
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|ep
operator|->
name|can_eliminate
operator|&&
name|ep
operator|->
name|can_eliminate_previous
condition|)
block|{
comment|/* Find the current elimination for ep->from, if there is a 	     new one.  */
for|for
control|(
name|op
operator|=
name|reg_eliminate
init|;
name|op
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|op
operator|++
control|)
if|if
condition|(
name|op
operator|->
name|from
operator|==
name|ep
operator|->
name|from
operator|&&
name|op
operator|->
name|can_eliminate
condition|)
block|{
name|new_to
operator|=
name|op
operator|->
name|to
expr_stmt|;
break|break;
block|}
comment|/* See if there is an elimination of NEW_TO -> EP->TO.  If so, 	     disable it.  */
for|for
control|(
name|op
operator|=
name|reg_eliminate
init|;
name|op
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|op
operator|++
control|)
if|if
condition|(
name|op
operator|->
name|from
operator|==
name|new_to
operator|&&
name|op
operator|->
name|to
operator|==
name|ep
operator|->
name|to
condition|)
name|op
operator|->
name|can_eliminate
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* See if any registers that we thought we could eliminate the previous      time are no longer eliminable.  If so, something has changed and we      must spill the register.  Also, recompute the number of eliminable      registers and see if the frame pointer is needed; it is if there is      no elimination of the frame pointer that we can perform.  */
name|frame_pointer_needed
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|ep
operator|=
name|reg_eliminate
init|;
name|ep
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|ep
operator|++
control|)
block|{
if|if
condition|(
name|ep
operator|->
name|can_eliminate
operator|&&
name|ep
operator|->
name|from
operator|==
name|FRAME_POINTER_REGNUM
operator|&&
name|ep
operator|->
name|to
operator|!=
name|HARD_FRAME_POINTER_REGNUM
condition|)
name|frame_pointer_needed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|ep
operator|->
name|can_eliminate
operator|&&
name|ep
operator|->
name|can_eliminate_previous
condition|)
block|{
name|ep
operator|->
name|can_eliminate_previous
operator|=
literal|0
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
operator|*
name|pset
argument_list|,
name|ep
operator|->
name|from
argument_list|)
expr_stmt|;
name|num_eliminable
operator|--
expr_stmt|;
block|}
block|}
if|#
directive|if
name|HARD_FRAME_POINTER_REGNUM
operator|!=
name|FRAME_POINTER_REGNUM
comment|/* If we didn't need a frame pointer last time, but we do now, spill      the hard frame pointer.  */
if|if
condition|(
name|frame_pointer_needed
operator|&&
operator|!
name|previous_frame_pointer_needed
condition|)
name|SET_HARD_REG_BIT
argument_list|(
operator|*
name|pset
argument_list|,
name|HARD_FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Initialize the table of registers to eliminate.  */
end_comment

begin_function
specifier|static
name|void
name|init_elim_table
parameter_list|()
block|{
name|struct
name|elim_table
modifier|*
name|ep
decl_stmt|;
ifdef|#
directive|ifdef
name|ELIMINABLE_REGS
name|struct
name|elim_table_1
modifier|*
name|ep1
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|reg_eliminate
condition|)
block|{
name|reg_eliminate
operator|=
operator|(
expr|struct
name|elim_table
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|elim_table
argument_list|)
operator|*
name|NUM_ELIMINABLE_REGS
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|PTR
operator|)
name|reg_eliminate
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|elim_table
argument_list|)
operator|*
name|NUM_ELIMINABLE_REGS
argument_list|)
expr_stmt|;
block|}
comment|/* Does this function require a frame pointer?  */
name|frame_pointer_needed
operator|=
operator|(
operator|!
name|flag_omit_frame_pointer
ifdef|#
directive|ifdef
name|EXIT_IGNORE_STACK
comment|/* ?? If EXIT_IGNORE_STACK is set, we will not save 			     and restore sp for alloca.  So we can't eliminate 			     the frame pointer in that case.  At some point, 			     we should improve this by emitting the 			     sp-adjusting insns for this case.  */
operator|||
operator|(
name|current_function_calls_alloca
operator|&&
name|EXIT_IGNORE_STACK
operator|)
endif|#
directive|endif
operator|||
name|FRAME_POINTER_REQUIRED
operator|)
expr_stmt|;
name|num_eliminable
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|ELIMINABLE_REGS
for|for
control|(
name|ep
operator|=
name|reg_eliminate
operator|,
name|ep1
operator|=
name|reg_eliminate_1
init|;
name|ep
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|ep
operator|++
operator|,
name|ep1
operator|++
control|)
block|{
name|ep
operator|->
name|from
operator|=
name|ep1
operator|->
name|from
expr_stmt|;
name|ep
operator|->
name|to
operator|=
name|ep1
operator|->
name|to
expr_stmt|;
name|ep
operator|->
name|can_eliminate
operator|=
name|ep
operator|->
name|can_eliminate_previous
operator|=
operator|(
name|CAN_ELIMINATE
argument_list|(
name|ep
operator|->
name|from
argument_list|,
name|ep
operator|->
name|to
argument_list|)
operator|&&
operator|!
operator|(
name|ep
operator|->
name|to
operator|==
name|STACK_POINTER_REGNUM
operator|&&
name|frame_pointer_needed
operator|)
operator|)
expr_stmt|;
block|}
else|#
directive|else
name|reg_eliminate
index|[
literal|0
index|]
operator|.
name|from
operator|=
name|reg_eliminate_1
index|[
literal|0
index|]
operator|.
name|from
expr_stmt|;
name|reg_eliminate
index|[
literal|0
index|]
operator|.
name|to
operator|=
name|reg_eliminate_1
index|[
literal|0
index|]
operator|.
name|to
expr_stmt|;
name|reg_eliminate
index|[
literal|0
index|]
operator|.
name|can_eliminate
operator|=
name|reg_eliminate
index|[
literal|0
index|]
operator|.
name|can_eliminate_previous
operator|=
operator|!
name|frame_pointer_needed
expr_stmt|;
endif|#
directive|endif
comment|/* Count the number of eliminable registers and build the FROM and TO      REG rtx's.  Note that code in gen_rtx will cause, e.g.,      gen_rtx (REG, Pmode, STACK_POINTER_REGNUM) to equal stack_pointer_rtx.      We depend on this.  */
for|for
control|(
name|ep
operator|=
name|reg_eliminate
init|;
name|ep
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|ep
operator|++
control|)
block|{
name|num_eliminable
operator|+=
name|ep
operator|->
name|can_eliminate
expr_stmt|;
name|ep
operator|->
name|from_rtx
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|ep
operator|->
name|from
argument_list|)
expr_stmt|;
name|ep
operator|->
name|to_rtx
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|ep
operator|->
name|to
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Kick all pseudos out of hard register REGNO.    If DUMPFILE is nonzero, log actions taken on that file.     If CANT_ELIMINATE is nonzero, it means that we are doing this spill    because we found we can't eliminate some register.  In the case, no pseudos    are allowed to be in the register, even if they are only in a block that    doesn't require spill registers, unlike the case when we are spilling this    hard reg to produce another spill register.     Return nonzero if any pseudos needed to be kicked out.  */
end_comment

begin_function
specifier|static
name|void
name|spill_hard_reg
parameter_list|(
name|regno
parameter_list|,
name|dumpfile
parameter_list|,
name|cant_eliminate
parameter_list|)
specifier|register
name|int
name|regno
decl_stmt|;
name|FILE
modifier|*
name|dumpfile
decl_stmt|;
name|int
name|cant_eliminate
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|cant_eliminate
condition|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|bad_spill_regs_global
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|regs_ever_live
index|[
name|regno
index|]
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Spill every pseudo reg that was allocated to this reg      or to something that overlaps this reg.  */
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reg_renumber
index|[
name|i
index|]
operator|>=
literal|0
operator|&&
name|reg_renumber
index|[
name|i
index|]
operator|<=
name|regno
operator|&&
operator|(
name|reg_renumber
index|[
name|i
index|]
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|reg_renumber
index|[
name|i
index|]
argument_list|,
name|PSEUDO_REGNO_MODE
argument_list|(
name|i
argument_list|)
argument_list|)
operator|>
name|regno
operator|)
condition|)
name|SET_REGNO_REG_SET
argument_list|(
name|spilled_pseudos
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* I'm getting weird preprocessor errors if I use IOR_HARD_REG_SET    from within EXECUTE_IF_SET_IN_REG_SET.  Hence this awkwardness.  */
end_comment

begin_function
specifier|static
name|void
name|ior_hard_reg_set
parameter_list|(
name|set1
parameter_list|,
name|set2
parameter_list|)
name|HARD_REG_SET
modifier|*
name|set1
decl_stmt|,
decl|*
name|set2
decl_stmt|;
end_function

begin_block
block|{
name|IOR_HARD_REG_SET
argument_list|(
operator|*
name|set1
argument_list|,
operator|*
name|set2
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* After find_reload_regs has been run for all insn that need reloads,    and/or spill_hard_regs was called, this function is used to actually    spill pseudo registers and try to reallocate them.  It also sets up the    spill_regs array for use by choose_reload_regs.  */
end_comment

begin_function
specifier|static
name|int
name|finish_spills
parameter_list|(
name|global
parameter_list|,
name|dumpfile
parameter_list|)
name|int
name|global
decl_stmt|;
name|FILE
modifier|*
name|dumpfile
decl_stmt|;
block|{
name|struct
name|insn_chain
modifier|*
name|chain
decl_stmt|;
name|int
name|something_changed
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Build the spill_regs array for the function.  */
comment|/* If there are some registers still to eliminate and one of the spill regs      wasn't ever used before, additional stack space may have to be      allocated to store this register.  Thus, we may have changed the offset      between the stack and frame pointers, so mark that something has changed.       One might think that we need only set VAL to 1 if this is a call-used      register.  However, the set of registers that must be saved by the      prologue is not identical to the call-used set.  For example, the      register used by the call insn for the return PC is a call-used register,      but must be saved by the prologue.  */
name|n_spills
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|used_spill_regs
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|spill_reg_order
index|[
name|i
index|]
operator|=
name|n_spills
expr_stmt|;
name|spill_regs
index|[
name|n_spills
operator|++
index|]
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|num_eliminable
operator|&&
operator|!
name|regs_ever_live
index|[
name|i
index|]
condition|)
name|something_changed
operator|=
literal|1
expr_stmt|;
name|regs_ever_live
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|spill_reg_order
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|REGNO_REG_SET_P
argument_list|(
name|spilled_pseudos
argument_list|,
name|i
argument_list|)
condition|)
block|{
comment|/* Record the current hard register the pseudo is allocated to in 	   pseudo_previous_regs so we avoid reallocating it to the same 	   hard reg in a later pass.  */
if|if
condition|(
name|reg_renumber
index|[
name|i
index|]
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|pseudo_previous_regs
index|[
name|i
index|]
argument_list|,
name|reg_renumber
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Mark it as no longer having a hard register home.  */
name|reg_renumber
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* We will need to scan everything again.  */
name|something_changed
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Retry global register allocation if possible.  */
if|if
condition|(
name|global
condition|)
block|{
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pseudo_forbidden_regs
argument_list|,
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|HARD_REG_SET
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For every insn that needs reloads, set the registers used as spill 	 regs in pseudo_forbidden_regs for every pseudo live across the 	 insn.  */
for|for
control|(
name|chain
operator|=
name|insns_need_reload
init|;
name|chain
condition|;
name|chain
operator|=
name|chain
operator|->
name|next_need_reload
control|)
block|{
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|chain->live_before
argument_list|,
argument|FIRST_PSEUDO_REGISTER
argument_list|,
argument|i
argument_list|,
argument|{ 	       ior_hard_reg_set (pseudo_forbidden_regs + i,&chain->used_spill_regs); 	     }
argument_list|)
empty_stmt|;
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|chain->live_after
argument_list|,
argument|FIRST_PSEUDO_REGISTER
argument_list|,
argument|i
argument_list|,
argument|{ 	       ior_hard_reg_set (pseudo_forbidden_regs + i,&chain->used_spill_regs); 	     }
argument_list|)
empty_stmt|;
block|}
comment|/* Retry allocating the spilled pseudos.  For each reg, merge the 	 various reg sets that indicate which hard regs can't be used, 	 and call retry_global_alloc.          We change spill_pseudos here to only contain pseudos that did not 	 get a new hard register.  */
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reg_old_renumber
index|[
name|i
index|]
operator|!=
name|reg_renumber
index|[
name|i
index|]
condition|)
block|{
name|HARD_REG_SET
name|forbidden
decl_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|forbidden
argument_list|,
name|bad_spill_regs_global
argument_list|)
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|forbidden
argument_list|,
name|pseudo_forbidden_regs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|forbidden
argument_list|,
name|pseudo_previous_regs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|retry_global_alloc
argument_list|(
name|i
argument_list|,
name|forbidden
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_renumber
index|[
name|i
index|]
operator|>=
literal|0
condition|)
name|CLEAR_REGNO_REG_SET
argument_list|(
name|spilled_pseudos
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Fix up the register information in the insn chain.      This involves deleting those of the spilled pseudos which did not get      a new hard register home from the live_{before,after} sets.  */
for|for
control|(
name|chain
operator|=
name|reload_insn_chain
init|;
name|chain
condition|;
name|chain
operator|=
name|chain
operator|->
name|next
control|)
block|{
name|HARD_REG_SET
name|used_by_pseudos
decl_stmt|;
name|HARD_REG_SET
name|used_by_pseudos2
decl_stmt|;
name|AND_COMPL_REG_SET
argument_list|(
name|chain
operator|->
name|live_before
argument_list|,
name|spilled_pseudos
argument_list|)
expr_stmt|;
name|AND_COMPL_REG_SET
argument_list|(
name|chain
operator|->
name|live_after
argument_list|,
name|spilled_pseudos
argument_list|)
expr_stmt|;
comment|/* Mark any unallocated hard regs as available for spills.  That 	 makes inheritance work somewhat better.  */
if|if
condition|(
name|chain
operator|->
name|need_reload
condition|)
block|{
name|REG_SET_TO_HARD_REG_SET
argument_list|(
name|used_by_pseudos
argument_list|,
name|chain
operator|->
name|live_before
argument_list|)
expr_stmt|;
name|REG_SET_TO_HARD_REG_SET
argument_list|(
name|used_by_pseudos2
argument_list|,
name|chain
operator|->
name|live_after
argument_list|)
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|used_by_pseudos
argument_list|,
name|used_by_pseudos2
argument_list|)
expr_stmt|;
comment|/* Save the old value for the sanity test below.  */
name|COPY_HARD_REG_SET
argument_list|(
name|used_by_pseudos2
argument_list|,
name|chain
operator|->
name|used_spill_regs
argument_list|)
expr_stmt|;
name|compute_use_by_pseudos
argument_list|(
operator|&
name|used_by_pseudos
argument_list|,
name|chain
operator|->
name|live_before
argument_list|)
expr_stmt|;
name|compute_use_by_pseudos
argument_list|(
operator|&
name|used_by_pseudos
argument_list|,
name|chain
operator|->
name|live_after
argument_list|)
expr_stmt|;
name|COMPL_HARD_REG_SET
argument_list|(
name|chain
operator|->
name|used_spill_regs
argument_list|,
name|used_by_pseudos
argument_list|)
expr_stmt|;
name|AND_HARD_REG_SET
argument_list|(
name|chain
operator|->
name|used_spill_regs
argument_list|,
name|used_spill_regs
argument_list|)
expr_stmt|;
comment|/* Make sure we only enlarge the set.  */
name|GO_IF_HARD_REG_SUBSET
argument_list|(
name|used_by_pseudos2
argument_list|,
name|chain
operator|->
name|used_spill_regs
argument_list|,
name|ok
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
name|ok
label|:
empty_stmt|;
block|}
block|}
comment|/* Let alter_reg modify the reg rtx's for the modified pseudos.  */
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
block|{
name|int
name|regno
init|=
name|reg_renumber
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|reg_old_renumber
index|[
name|i
index|]
operator|==
name|regno
condition|)
continue|continue;
name|alter_reg
argument_list|(
name|i
argument_list|,
name|reg_old_renumber
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|reg_old_renumber
index|[
name|i
index|]
operator|=
name|regno
expr_stmt|;
if|if
condition|(
name|dumpfile
condition|)
block|{
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|dumpfile
argument_list|,
literal|" Register %d now on stack.\n\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|dumpfile
argument_list|,
literal|" Register %d now in %d.\n\n"
argument_list|,
name|i
argument_list|,
name|reg_renumber
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|something_changed
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find all paradoxical subregs within X and update reg_max_ref_width.     Also mark any hard registers used to store user variables as    forbidden from being used for spill registers.  */
end_comment

begin_function
specifier|static
name|void
name|scan_paradoxical_subregs
parameter_list|(
name|x
parameter_list|)
specifier|register
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
if|#
directive|if
literal|0
block|if (SMALL_REGISTER_CLASSES&& REGNO (x)< FIRST_PSEUDO_REGISTER&& REG_USERVAR_P (x)) 	SET_HARD_REG_BIT (bad_spill_regs_global, REGNO (x));
endif|#
directive|endif
return|return;
case|case
name|CONST_INT
case|:
case|case
name|CONST
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CC0
case|:
case|case
name|PC
case|:
case|case
name|USE
case|:
case|case
name|CLOBBER
case|:
return|return;
case|case
name|SUBREG
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
condition|)
name|reg_max_ref_width
index|[
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
index|]
operator|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return;
default|default:
break|break;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|scan_paradoxical_subregs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|scan_paradoxical_subregs
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|int
name|hard_reg_use_compare
parameter_list|(
name|p1p
parameter_list|,
name|p2p
parameter_list|)
specifier|const
name|GENERIC_PTR
name|p1p
decl_stmt|;
specifier|const
name|GENERIC_PTR
name|p2p
decl_stmt|;
block|{
name|struct
name|hard_reg_n_uses
modifier|*
name|p1
init|=
operator|(
expr|struct
name|hard_reg_n_uses
operator|*
operator|)
name|p1p
decl_stmt|;
name|struct
name|hard_reg_n_uses
modifier|*
name|p2
init|=
operator|(
expr|struct
name|hard_reg_n_uses
operator|*
operator|)
name|p2p
decl_stmt|;
name|int
name|bad1
init|=
name|TEST_HARD_REG_BIT
argument_list|(
name|bad_spill_regs
argument_list|,
name|p1
operator|->
name|regno
argument_list|)
decl_stmt|;
name|int
name|bad2
init|=
name|TEST_HARD_REG_BIT
argument_list|(
name|bad_spill_regs
argument_list|,
name|p2
operator|->
name|regno
argument_list|)
decl_stmt|;
if|if
condition|(
name|bad1
operator|&&
name|bad2
condition|)
return|return
name|p1
operator|->
name|regno
operator|-
name|p2
operator|->
name|regno
return|;
if|if
condition|(
name|bad1
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|bad2
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|p1
operator|->
name|uses
operator|>
name|p2
operator|->
name|uses
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|p1
operator|->
name|uses
operator|<
name|p2
operator|->
name|uses
condition|)
return|return
operator|-
literal|1
return|;
comment|/* If regs are equally good, sort by regno,      so that the results of qsort leave nothing to chance.  */
return|return
name|p1
operator|->
name|regno
operator|-
name|p2
operator|->
name|regno
return|;
block|}
end_function

begin_comment
comment|/* Used for communication between order_regs_for_reload and count_pseudo.    Used to avoid counting one pseudo twice.  */
end_comment

begin_decl_stmt
specifier|static
name|regset
name|pseudos_counted
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Update the costs in N_USES, considering that pseudo REG is live.  */
end_comment

begin_function
specifier|static
name|void
name|count_pseudo
parameter_list|(
name|n_uses
parameter_list|,
name|reg
parameter_list|)
name|struct
name|hard_reg_n_uses
modifier|*
name|n_uses
decl_stmt|;
name|int
name|reg
decl_stmt|;
block|{
name|int
name|r
init|=
name|reg_renumber
index|[
name|reg
index|]
decl_stmt|;
name|int
name|nregs
decl_stmt|;
if|if
condition|(
name|REGNO_REG_SET_P
argument_list|(
name|pseudos_counted
argument_list|,
name|reg
argument_list|)
condition|)
return|return;
name|SET_REGNO_REG_SET
argument_list|(
name|pseudos_counted
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|nregs
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|r
argument_list|,
name|PSEUDO_REGNO_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|nregs
operator|--
operator|>
literal|0
condition|)
name|n_uses
index|[
name|r
operator|++
index|]
operator|.
name|uses
operator|+=
name|REG_N_REFS
argument_list|(
name|reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Choose the order to consider regs for use as reload registers    based on how much trouble would be caused by spilling one.    Store them in order of decreasing preference in potential_reload_regs.  */
end_comment

begin_function
specifier|static
name|void
name|order_regs_for_reload
parameter_list|(
name|chain
parameter_list|)
name|struct
name|insn_chain
modifier|*
name|chain
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|o
init|=
literal|0
decl_stmt|;
name|struct
name|hard_reg_n_uses
name|hard_reg_n_uses
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
name|pseudos_counted
operator|=
name|ALLOCA_REG_SET
argument_list|()
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|bad_spill_regs
argument_list|,
name|bad_spill_regs_global
argument_list|)
expr_stmt|;
comment|/* Count number of uses of each hard reg by pseudo regs allocated to it      and then order them by decreasing use.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|;
name|hard_reg_n_uses
index|[
name|i
index|]
operator|.
name|regno
operator|=
name|i
expr_stmt|;
name|hard_reg_n_uses
index|[
name|i
index|]
operator|.
name|uses
operator|=
literal|0
expr_stmt|;
comment|/* Test the various reasons why we can't use a register for 	 spilling in this insn.  */
if|if
condition|(
name|fixed_regs
index|[
name|i
index|]
operator|||
name|REGNO_REG_SET_P
argument_list|(
name|chain
operator|->
name|live_before
argument_list|,
name|i
argument_list|)
operator|||
name|REGNO_REG_SET_P
argument_list|(
name|chain
operator|->
name|live_after
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|bad_spill_regs
argument_list|,
name|i
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Now find out which pseudos are allocated to it, and update 	 hard_reg_n_uses.  */
name|CLEAR_REG_SET
argument_list|(
name|pseudos_counted
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|chain->live_before
argument_list|,
argument|FIRST_PSEUDO_REGISTER
argument_list|,
argument|j
argument_list|,
argument|{ 	   count_pseudo (hard_reg_n_uses, j); 	 }
argument_list|)
empty_stmt|;
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|chain->live_after
argument_list|,
argument|FIRST_PSEUDO_REGISTER
argument_list|,
argument|j
argument_list|,
argument|{ 	   count_pseudo (hard_reg_n_uses, j); 	 }
argument_list|)
empty_stmt|;
block|}
name|FREE_REG_SET
argument_list|(
name|pseudos_counted
argument_list|)
expr_stmt|;
comment|/* Prefer registers not so far used, for use in temporary loading.      Among them, if REG_ALLOC_ORDER is defined, use that order.      Otherwise, prefer registers not preserved by calls.  */
ifdef|#
directive|ifdef
name|REG_ALLOC_ORDER
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
name|int
name|regno
init|=
name|reg_alloc_order
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|hard_reg_n_uses
index|[
name|regno
index|]
operator|.
name|uses
operator|==
literal|0
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|bad_spill_regs
argument_list|,
name|regno
argument_list|)
condition|)
name|potential_reload_regs
index|[
name|o
operator|++
index|]
operator|=
name|regno
expr_stmt|;
block|}
else|#
directive|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|hard_reg_n_uses
index|[
name|i
index|]
operator|.
name|uses
operator|==
literal|0
operator|&&
name|call_used_regs
index|[
name|i
index|]
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|bad_spill_regs
argument_list|,
name|i
argument_list|)
condition|)
name|potential_reload_regs
index|[
name|o
operator|++
index|]
operator|=
name|i
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|hard_reg_n_uses
index|[
name|i
index|]
operator|.
name|uses
operator|==
literal|0
operator|&&
operator|!
name|call_used_regs
index|[
name|i
index|]
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|bad_spill_regs
argument_list|,
name|i
argument_list|)
condition|)
name|potential_reload_regs
index|[
name|o
operator|++
index|]
operator|=
name|i
expr_stmt|;
block|}
endif|#
directive|endif
name|qsort
argument_list|(
name|hard_reg_n_uses
argument_list|,
name|FIRST_PSEUDO_REGISTER
argument_list|,
sizeof|sizeof
name|hard_reg_n_uses
index|[
literal|0
index|]
argument_list|,
name|hard_reg_use_compare
argument_list|)
expr_stmt|;
comment|/* Now add the regs that are already used,      preferring those used less often.  The fixed and otherwise forbidden      registers will be at the end of this list.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|hard_reg_n_uses
index|[
name|i
index|]
operator|.
name|uses
operator|!=
literal|0
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|bad_spill_regs
argument_list|,
name|hard_reg_n_uses
index|[
name|i
index|]
operator|.
name|regno
argument_list|)
condition|)
name|potential_reload_regs
index|[
name|o
operator|++
index|]
operator|=
name|hard_reg_n_uses
index|[
name|i
index|]
operator|.
name|regno
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|bad_spill_regs
argument_list|,
name|hard_reg_n_uses
index|[
name|i
index|]
operator|.
name|regno
argument_list|)
condition|)
name|potential_reload_regs
index|[
name|o
operator|++
index|]
operator|=
name|hard_reg_n_uses
index|[
name|i
index|]
operator|.
name|regno
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Reload pseudo-registers into hard regs around each insn as needed.    Additional register load insns are output before the insn that needs it    and perhaps store insns after insns that modify the reloaded pseudo reg.     reg_last_reload_reg and reg_reloaded_contents keep track of    which registers are already available in reload registers.    We update these for the reloads that we perform,    as the insns are scanned.  */
end_comment

begin_function
specifier|static
name|void
name|reload_as_needed
parameter_list|(
name|live_known
parameter_list|)
name|int
name|live_known
decl_stmt|;
block|{
name|struct
name|insn_chain
modifier|*
name|chain
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|AUTO_INC_DEC
argument_list|)
operator|||
name|defined
argument_list|(
name|INSN_CLOBBERS_REGNO_P
argument_list|)
specifier|register
name|int
name|i
decl_stmt|;
endif|#
directive|endif
name|rtx
name|x
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|spill_reg_rtx
argument_list|,
sizeof|sizeof
name|spill_reg_rtx
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|spill_reg_store
argument_list|,
sizeof|sizeof
name|spill_reg_store
argument_list|)
expr_stmt|;
name|reg_last_reload_reg
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_last_reload_reg
argument_list|,
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|reg_has_output_reload
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|max_regno
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|reg_reloaded_valid
argument_list|)
expr_stmt|;
name|set_initial_elim_offsets
argument_list|()
expr_stmt|;
for|for
control|(
name|chain
operator|=
name|reload_insn_chain
init|;
name|chain
condition|;
name|chain
operator|=
name|chain
operator|->
name|next
control|)
block|{
name|rtx
name|prev
decl_stmt|;
name|rtx
name|insn
init|=
name|chain
operator|->
name|insn
decl_stmt|;
name|rtx
name|old_next
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* If we pass a label, copy the offsets from the label information 	 into the current offsets of each elimination.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|set_offsets_for_label
argument_list|(
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
block|{
name|rtx
name|oldpat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* If this is a USE and CLOBBER of a MEM, ensure that any 	     references to eliminable registers have been removed.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|=
name|eliminate_regs
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
comment|/* If we need to do register elimination processing, do so. 	     This might delete the insn, in which case we are done.  */
if|if
condition|(
operator|(
name|num_eliminable
operator|||
name|num_eliminable_invariants
operator|)
operator|&&
name|chain
operator|->
name|need_elim
condition|)
block|{
name|eliminate_regs_in_insn
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
block|{
name|update_eliminable_offsets
argument_list|()
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* If need_elim is nonzero but need_reload is zero, one might think 	     that we could simply set n_reloads to 0.  However, find_reloads 	     could have done some manipulation of the insn (such as swapping 	     commutative operands), and these manipulations are lost during 	     the first pass for every insn that needs register elimination. 	     So the actions of find_reloads must be redone here.  */
if|if
condition|(
operator|!
name|chain
operator|->
name|need_elim
operator|&&
operator|!
name|chain
operator|->
name|need_reload
operator|&&
operator|!
name|chain
operator|->
name|need_operand_change
condition|)
name|n_reloads
operator|=
literal|0
expr_stmt|;
comment|/* First find the pseudo regs that must be reloaded for this insn. 	     This info is returned in the tables reload_... (see reload.h). 	     Also modify the body of INSN by substituting RELOAD 	     rtx's for those pseudo regs.  */
else|else
block|{
name|bzero
argument_list|(
name|reg_has_output_reload
argument_list|,
name|max_regno
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|reg_is_output_reload
argument_list|)
expr_stmt|;
name|find_reloads
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|,
name|spill_indirect_levels
argument_list|,
name|live_known
argument_list|,
name|spill_reg_order
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|num_eliminable
operator|&&
name|chain
operator|->
name|need_elim
condition|)
name|update_eliminable_offsets
argument_list|()
expr_stmt|;
if|if
condition|(
name|n_reloads
operator|>
literal|0
condition|)
block|{
name|rtx
name|next
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|p
decl_stmt|;
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Now compute which reload regs to reload them into.  Perhaps 		 reusing reload regs from previous insns, or else output 		 load insns to reload them.  Maybe output store insns too. 		 Record the choices of reload reg in reload_reg_rtx.  */
name|choose_reload_regs
argument_list|(
name|chain
argument_list|)
expr_stmt|;
comment|/* Merge any reloads that we didn't combine for fear of  		 increasing the number of spill registers needed but now 		 discover can be safely merged.  */
if|if
condition|(
name|SMALL_REGISTER_CLASSES
condition|)
name|merge_assigned_reloads
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Generate the insns to reload operands into or out of 		 their reload regs.  */
name|emit_reload_insns
argument_list|(
name|chain
argument_list|)
expr_stmt|;
comment|/* Substitute the chosen reload regs from reload_reg_rtx 		 into the insn's body (or perhaps into the bodies of other 		 load and store insn that we just made for reloading 		 and that we moved the structure into).  */
name|subst_reloads
argument_list|()
expr_stmt|;
comment|/* If this was an ASM, make sure that all the reload insns 		 we have generated are valid.  If not, give an error 		 and delete them.  */
if|if
condition|(
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
for|for
control|(
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|prev
argument_list|)
init|;
name|p
operator|!=
name|next
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
if|if
condition|(
name|p
operator|!=
name|insn
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
operator|(
name|recog_memoized
argument_list|(
name|p
argument_list|)
operator|<
literal|0
operator|||
operator|(
name|extract_insn
argument_list|(
name|p
argument_list|)
operator|,
operator|!
name|constrain_operands
argument_list|(
literal|1
argument_list|)
operator|)
operator|)
condition|)
block|{
name|error_for_asm
argument_list|(
name|insn
argument_list|,
literal|"`asm' operand requires impossible reload"
argument_list|)
expr_stmt|;
name|PUT_CODE
argument_list|(
name|p
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|p
argument_list|)
operator|=
literal|0
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|p
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
block|}
block|}
comment|/* Any previously reloaded spilled pseudo reg, stored in this insn, 	     is no longer validly lying around to save a future reload. 	     Note that this does not detect pseudos that were reloaded 	     for this insn in order to be stored in 	     (obeying register constraints).  That is correct; such reload 	     registers ARE still valid.  */
name|note_stores
argument_list|(
name|oldpat
argument_list|,
name|forget_old_reloads_1
argument_list|)
expr_stmt|;
comment|/* There may have been CLOBBER insns placed after INSN.  So scan 	     between INSN and NEXT and use them to forget old reloads.  */
for|for
control|(
name|x
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
init|;
name|x
operator|!=
name|old_next
condition|;
name|x
operator|=
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|x
argument_list|)
argument_list|,
name|forget_old_reloads_1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
comment|/* Likewise for regs altered by auto-increment in this insn. 	     REG_INC notes have been changed by reloading: 	     find_reloads_address_1 records substitutions for them, 	     which have been performed by subst_reloads above.  */
for|for
control|(
name|i
operator|=
name|n_reloads
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|rtx
name|in_reg
init|=
name|reload_in_reg
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|in_reg
condition|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|in_reg
argument_list|)
decl_stmt|;
comment|/* PRE_INC / PRE_DEC will have the reload register ending up 		     with the same value as the stack slot, but that doesn't 		     hold true for POST_INC / POST_DEC.  Either we have to 		     convert the memory access to a true POST_INC / POST_DEC, 		     or we can't use the reload register for inheritance.  */
if|if
condition|(
operator|(
name|code
operator|==
name|POST_INC
operator|||
name|code
operator|==
name|POST_DEC
operator|)
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_reloaded_valid
argument_list|,
name|REGNO
argument_list|(
name|reload_reg_rtx
index|[
name|i
index|]
argument_list|)
argument_list|)
comment|/* Make sure it is the inc/dec pseudo, and not 			 some other (e.g. output operand) pseudo.  */
operator|&&
operator|(
name|reg_reloaded_contents
index|[
name|REGNO
argument_list|(
name|reload_reg_rtx
index|[
name|i
index|]
argument_list|)
index|]
operator|==
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|in_reg
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|reload_reg
init|=
name|reload_reg_rtx
index|[
name|i
index|]
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|reload_reg
argument_list|)
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
name|rtx
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|PREV_INSN
argument_list|(
name|old_next
argument_list|)
init|;
name|p
operator|!=
name|prev
condition|;
name|p
operator|=
name|PREV_INSN
argument_list|(
name|p
argument_list|)
control|)
block|{
comment|/* We really want to ignore REG_INC notes here, so 			     use PATTERN (p) as argument to reg_set_p .  */
if|if
condition|(
name|reg_set_p
argument_list|(
name|reload_reg
argument_list|,
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
break|break;
name|n
operator|=
name|count_occurrences
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|,
name|reload_reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
continue|continue;
if|if
condition|(
name|n
operator|==
literal|1
condition|)
block|{
name|n
operator|=
name|validate_replace_rtx
argument_list|(
name|reload_reg
argument_list|,
name|gen_rtx
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|reload_reg
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* We must also verify that the constraints 				 are met after the replacement.  */
name|extract_insn
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
name|n
operator|=
name|constrain_operands
argument_list|(
literal|1
argument_list|)
expr_stmt|;
else|else
break|break;
comment|/* If the constraints were not met, then 				 undo the replacement.  */
if|if
condition|(
operator|!
name|n
condition|)
block|{
name|validate_replace_rtx
argument_list|(
name|gen_rtx
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|reload_reg
argument_list|)
argument_list|,
name|reload_reg
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
break|break;
block|}
if|if
condition|(
name|n
operator|==
literal|1
condition|)
block|{
name|REG_NOTES
argument_list|(
name|p
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_INC
argument_list|,
name|reload_reg
argument_list|,
name|REG_NOTES
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Mark this as having an output reload so that the 			     REG_INC processing code below won't invalidate 			     the reload for inheritance.  */
name|SET_HARD_REG_BIT
argument_list|(
name|reg_is_output_reload
argument_list|,
name|REGNO
argument_list|(
name|reload_reg
argument_list|)
argument_list|)
expr_stmt|;
name|reg_has_output_reload
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|in_reg
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|forget_old_reloads_1
argument_list|(
name|XEXP
argument_list|(
name|in_reg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|code
operator|==
name|PRE_INC
operator|||
name|code
operator|==
name|PRE_DEC
operator|)
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_reloaded_valid
argument_list|,
name|REGNO
argument_list|(
name|reload_reg_rtx
index|[
name|i
index|]
argument_list|)
argument_list|)
comment|/* Make sure it is the inc/dec pseudo, and not 			      some other (e.g. output operand) pseudo.  */
operator|&&
operator|(
name|reg_reloaded_contents
index|[
name|REGNO
argument_list|(
name|reload_reg_rtx
index|[
name|i
index|]
argument_list|)
index|]
operator|==
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|in_reg
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|reg_is_output_reload
argument_list|,
name|REGNO
argument_list|(
name|reload_reg_rtx
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|reg_has_output_reload
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|in_reg
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* If a pseudo that got a hard register is auto-incremented, 	     we must purge records of copying it into pseudos without 	     hard registers.  */
for|for
control|(
name|x
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|x
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|x
argument_list|)
operator|==
name|REG_INC
condition|)
block|{
comment|/* See if this pseudo reg was reloaded in this insn. 		   If so, its last-reload info is still valid 		   because it is based on this insn's reload.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_reloads
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reload_out
index|[
name|i
index|]
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|n_reloads
condition|)
name|forget_old_reloads_1
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
comment|/* A reload reg's contents are unknown after a label.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|CLEAR_HARD_REG_SET
argument_list|(
name|reg_reloaded_valid
argument_list|)
expr_stmt|;
comment|/* Don't assume a reload reg is still good after a call insn 	 if it is a call-used reg.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|reg_reloaded_valid
argument_list|,
name|call_used_reg_set
argument_list|)
expr_stmt|;
comment|/* In case registers overlap, allow certain insns to invalidate 	 particular hard registers.  */
ifdef|#
directive|ifdef
name|INSN_CLOBBERS_REGNO_P
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_reloaded_valid
argument_list|,
name|i
argument_list|)
operator|&&
name|INSN_CLOBBERS_REGNO_P
argument_list|(
name|insn
argument_list|,
name|i
argument_list|)
condition|)
name|CLEAR_HARD_REG_BIT
argument_list|(
name|reg_reloaded_valid
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_C_ALLOCA
name|alloca
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/* Discard all record of any value reloaded from X,    or reloaded in X from someplace else;    unless X is an output reload reg of the current insn.     X may be a hard reg (the reload reg)    or it may be a pseudo reg that was reloaded from.  */
end_comment

begin_function
specifier|static
name|void
name|forget_old_reloads_1
parameter_list|(
name|x
parameter_list|,
name|ignored
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|ignored
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
specifier|register
name|int
name|regno
decl_stmt|;
name|int
name|nr
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
comment|/* note_stores does give us subregs of hard regs.  */
while|while
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|offset
operator|+=
name|SUBREG_WORD
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
operator|=
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
condition|)
return|return;
name|regno
operator|=
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
name|offset
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|nr
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|int
name|i
decl_stmt|;
name|nr
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Storing into a spilled-reg invalidates its contents. 	 This can happen if a block-local pseudo is allocated to that reg 	 and it wasn't spilled because this block's total need is 0. 	 Then some insn might have an optional reload and use this reg.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nr
condition|;
name|i
operator|++
control|)
comment|/* But don't do this if the reg actually serves as an output 	   reload reg in the current instruction.  */
if|if
condition|(
name|n_reloads
operator|==
literal|0
operator|||
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_is_output_reload
argument_list|,
name|regno
operator|+
name|i
argument_list|)
condition|)
name|CLEAR_HARD_REG_BIT
argument_list|(
name|reg_reloaded_valid
argument_list|,
name|regno
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* Since value of X has changed,      forget any value previously copied from it.  */
while|while
condition|(
name|nr
operator|--
operator|>
literal|0
condition|)
comment|/* But don't forget a copy if this is the output reload        that establishes the copy's validity.  */
if|if
condition|(
name|n_reloads
operator|==
literal|0
operator|||
name|reg_has_output_reload
index|[
name|regno
operator|+
name|nr
index|]
operator|==
literal|0
condition|)
name|reg_last_reload_reg
index|[
name|regno
operator|+
name|nr
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* For each reload, the mode of the reload register.  */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|machine_mode
name|reload_mode
index|[
name|MAX_RELOADS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For each reload, the largest number of registers it will require.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|reload_nregs
index|[
name|MAX_RELOADS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Comparison function for qsort to decide which of two reloads    should be handled first.  *P1 and *P2 are the reload numbers.  */
end_comment

begin_function
specifier|static
name|int
name|reload_reg_class_lower
parameter_list|(
name|r1p
parameter_list|,
name|r2p
parameter_list|)
specifier|const
name|GENERIC_PTR
name|r1p
decl_stmt|;
specifier|const
name|GENERIC_PTR
name|r2p
decl_stmt|;
block|{
specifier|register
name|int
name|r1
init|=
operator|*
operator|(
name|short
operator|*
operator|)
name|r1p
decl_stmt|,
name|r2
init|=
operator|*
operator|(
name|short
operator|*
operator|)
name|r2p
decl_stmt|;
specifier|register
name|int
name|t
decl_stmt|;
comment|/* Consider required reloads before optional ones.  */
name|t
operator|=
name|reload_optional
index|[
name|r1
index|]
operator|-
name|reload_optional
index|[
name|r2
index|]
expr_stmt|;
if|if
condition|(
name|t
operator|!=
literal|0
condition|)
return|return
name|t
return|;
comment|/* Count all solitary classes before non-solitary ones.  */
name|t
operator|=
operator|(
operator|(
name|reg_class_size
index|[
operator|(
name|int
operator|)
name|reload_reg_class
index|[
name|r2
index|]
index|]
operator|==
literal|1
operator|)
operator|-
operator|(
name|reg_class_size
index|[
operator|(
name|int
operator|)
name|reload_reg_class
index|[
name|r1
index|]
index|]
operator|==
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
literal|0
condition|)
return|return
name|t
return|;
comment|/* Aside from solitaires, consider all multi-reg groups first.  */
name|t
operator|=
name|reload_nregs
index|[
name|r2
index|]
operator|-
name|reload_nregs
index|[
name|r1
index|]
expr_stmt|;
if|if
condition|(
name|t
operator|!=
literal|0
condition|)
return|return
name|t
return|;
comment|/* Consider reloads in order of increasing reg-class number.  */
name|t
operator|=
operator|(
name|int
operator|)
name|reload_reg_class
index|[
name|r1
index|]
operator|-
operator|(
name|int
operator|)
name|reload_reg_class
index|[
name|r2
index|]
expr_stmt|;
if|if
condition|(
name|t
operator|!=
literal|0
condition|)
return|return
name|t
return|;
comment|/* If reloads are equally urgent, sort by reload number,      so that the results of qsort leave nothing to chance.  */
return|return
name|r1
operator|-
name|r2
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The following HARD_REG_SETs indicate when each hard register is    used for a reload of various parts of the current insn.  */
end_comment

begin_comment
comment|/* If reg is in use as a reload reg for a RELOAD_OTHER reload.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|reload_reg_used
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If reg is in use for a RELOAD_FOR_INPUT_ADDRESS reload for operand I.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|reload_reg_used_in_input_addr
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If reg is in use for a RELOAD_FOR_INPADDR_ADDRESS reload for operand I.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|reload_reg_used_in_inpaddr_addr
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If reg is in use for a RELOAD_FOR_OUTPUT_ADDRESS reload for operand I.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|reload_reg_used_in_output_addr
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If reg is in use for a RELOAD_FOR_OUTADDR_ADDRESS reload for operand I.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|reload_reg_used_in_outaddr_addr
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If reg is in use for a RELOAD_FOR_INPUT reload for operand I.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|reload_reg_used_in_input
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If reg is in use for a RELOAD_FOR_OUTPUT reload for operand I.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|reload_reg_used_in_output
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If reg is in use for a RELOAD_FOR_OPERAND_ADDRESS reload.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|reload_reg_used_in_op_addr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If reg is in use for a RELOAD_FOR_OPADDR_ADDR reload.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|reload_reg_used_in_op_addr_reload
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If reg is in use for a RELOAD_FOR_INSN reload.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|reload_reg_used_in_insn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If reg is in use for a RELOAD_FOR_OTHER_ADDRESS reload.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|reload_reg_used_in_other_addr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If reg is in use as a reload reg for any sort of reload.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|reload_reg_used_at_all
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If reg is use as an inherited reload.  We just mark the first register    in the group.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|reload_reg_used_for_inherit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Records which hard regs are used in any way, either as explicit use or    by being allocated to a pseudo during any point of the current insn.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|reg_used_in_insn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mark reg REGNO as in use for a reload of the sort spec'd by OPNUM and    TYPE. MODE is used to indicate how many consecutive regs are    actually used.  */
end_comment

begin_function
specifier|static
name|void
name|mark_reload_reg_in_use
parameter_list|(
name|regno
parameter_list|,
name|opnum
parameter_list|,
name|type
parameter_list|,
name|mode
parameter_list|)
name|int
name|regno
decl_stmt|;
name|int
name|opnum
decl_stmt|;
name|enum
name|reload_type
name|type
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|int
name|nregs
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|regno
init|;
name|i
operator|<
name|nregs
operator|+
name|regno
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|RELOAD_OTHER
case|:
name|SET_HARD_REG_BIT
argument_list|(
name|reload_reg_used
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_INPUT_ADDRESS
case|:
name|SET_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_input_addr
index|[
name|opnum
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_INPADDR_ADDRESS
case|:
name|SET_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_inpaddr_addr
index|[
name|opnum
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OUTPUT_ADDRESS
case|:
name|SET_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_output_addr
index|[
name|opnum
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OUTADDR_ADDRESS
case|:
name|SET_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_outaddr_addr
index|[
name|opnum
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OPERAND_ADDRESS
case|:
name|SET_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_op_addr
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OPADDR_ADDR
case|:
name|SET_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_op_addr_reload
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OTHER_ADDRESS
case|:
name|SET_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_other_addr
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_INPUT
case|:
name|SET_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_input
index|[
name|opnum
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OUTPUT
case|:
name|SET_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_output
index|[
name|opnum
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_INSN
case|:
name|SET_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_insn
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
name|SET_HARD_REG_BIT
argument_list|(
name|reload_reg_used_at_all
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Similarly, but show REGNO is no longer in use for a reload.  */
end_comment

begin_function
specifier|static
name|void
name|clear_reload_reg_in_use
parameter_list|(
name|regno
parameter_list|,
name|opnum
parameter_list|,
name|type
parameter_list|,
name|mode
parameter_list|)
name|int
name|regno
decl_stmt|;
name|int
name|opnum
decl_stmt|;
name|enum
name|reload_type
name|type
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|int
name|nregs
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
decl_stmt|;
name|int
name|start_regno
decl_stmt|,
name|end_regno
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* A complication is that for some reload types, inheritance might      allow multiple reloads of the same types to share a reload register.      We set check_opnum if we have to check only reloads with the same      operand number, and check_any if we have to check all reloads.  */
name|int
name|check_opnum
init|=
literal|0
decl_stmt|;
name|int
name|check_any
init|=
literal|0
decl_stmt|;
name|HARD_REG_SET
modifier|*
name|used_in_set
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|RELOAD_OTHER
case|:
name|used_in_set
operator|=
operator|&
name|reload_reg_used
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_INPUT_ADDRESS
case|:
name|used_in_set
operator|=
operator|&
name|reload_reg_used_in_input_addr
index|[
name|opnum
index|]
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_INPADDR_ADDRESS
case|:
name|check_opnum
operator|=
literal|1
expr_stmt|;
name|used_in_set
operator|=
operator|&
name|reload_reg_used_in_inpaddr_addr
index|[
name|opnum
index|]
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OUTPUT_ADDRESS
case|:
name|used_in_set
operator|=
operator|&
name|reload_reg_used_in_output_addr
index|[
name|opnum
index|]
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OUTADDR_ADDRESS
case|:
name|check_opnum
operator|=
literal|1
expr_stmt|;
name|used_in_set
operator|=
operator|&
name|reload_reg_used_in_outaddr_addr
index|[
name|opnum
index|]
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OPERAND_ADDRESS
case|:
name|used_in_set
operator|=
operator|&
name|reload_reg_used_in_op_addr
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OPADDR_ADDR
case|:
name|check_any
operator|=
literal|1
expr_stmt|;
name|used_in_set
operator|=
operator|&
name|reload_reg_used_in_op_addr_reload
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OTHER_ADDRESS
case|:
name|used_in_set
operator|=
operator|&
name|reload_reg_used_in_other_addr
expr_stmt|;
name|check_any
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_INPUT
case|:
name|used_in_set
operator|=
operator|&
name|reload_reg_used_in_input
index|[
name|opnum
index|]
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OUTPUT
case|:
name|used_in_set
operator|=
operator|&
name|reload_reg_used_in_output
index|[
name|opnum
index|]
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_INSN
case|:
name|used_in_set
operator|=
operator|&
name|reload_reg_used_in_insn
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* We resolve conflicts with remaining reloads of the same type by      excluding the intervals of of reload registers by them from the      interval of freed reload registers.  Since we only keep track of      one set of interval bounds, we might have to exclude somewhat      more then what would be necessary if we used a HARD_REG_SET here.      But this should only happen very infrequently, so there should      be no reason to worry about it.  */
name|start_regno
operator|=
name|regno
expr_stmt|;
name|end_regno
operator|=
name|regno
operator|+
name|nregs
expr_stmt|;
if|if
condition|(
name|check_opnum
operator|||
name|check_any
condition|)
block|{
for|for
control|(
name|i
operator|=
name|n_reloads
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|reload_when_needed
index|[
name|i
index|]
operator|==
name|type
operator|&&
operator|(
name|check_any
operator|||
name|reload_opnum
index|[
name|i
index|]
operator|==
name|opnum
operator|)
operator|&&
name|reload_reg_rtx
index|[
name|i
index|]
condition|)
block|{
name|int
name|conflict_start
init|=
name|true_regnum
argument_list|(
name|reload_reg_rtx
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|int
name|conflict_end
init|=
operator|(
name|conflict_start
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|conflict_start
argument_list|,
name|reload_mode
index|[
name|i
index|]
argument_list|)
operator|)
decl_stmt|;
comment|/* If there is an overlap with the first to-be-freed register, 		 adjust the interval start.  */
if|if
condition|(
name|conflict_start
operator|<=
name|start_regno
operator|&&
name|conflict_end
operator|>
name|start_regno
condition|)
name|start_regno
operator|=
name|conflict_end
expr_stmt|;
comment|/* Otherwise, if there is a conflict with one of the other 		 to-be-freed registers, adjust the interval end.  */
if|if
condition|(
name|conflict_start
operator|>
name|start_regno
operator|&&
name|conflict_start
operator|<
name|end_regno
condition|)
name|end_regno
operator|=
name|conflict_start
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|i
operator|=
name|start_regno
init|;
name|i
operator|<
name|end_regno
condition|;
name|i
operator|++
control|)
name|CLEAR_HARD_REG_BIT
argument_list|(
operator|*
name|used_in_set
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* 1 if reg REGNO is free as a reload reg for a reload of the sort    specified by OPNUM and TYPE.  */
end_comment

begin_function
specifier|static
name|int
name|reload_reg_free_p
parameter_list|(
name|regno
parameter_list|,
name|opnum
parameter_list|,
name|type
parameter_list|)
name|int
name|regno
decl_stmt|;
name|int
name|opnum
decl_stmt|;
name|enum
name|reload_type
name|type
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/* In use for a RELOAD_OTHER means it's not available for anything.  */
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|RELOAD_OTHER
case|:
comment|/* In use for anything means we can't use it for RELOAD_OTHER.  */
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_other_addr
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_op_addr
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_insn
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reload_n_operands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_input_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_inpaddr_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_output_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_outaddr_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_input
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_output
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
case|case
name|RELOAD_FOR_INPUT
case|:
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_insn
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_op_addr
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_op_addr_reload
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If it is used for some other input, can't use it.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reload_n_operands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_input
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If it is used in a later operand's address, can't use it.  */
for|for
control|(
name|i
operator|=
name|opnum
operator|+
literal|1
init|;
name|i
operator|<
name|reload_n_operands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_input_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_inpaddr_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
case|case
name|RELOAD_FOR_INPUT_ADDRESS
case|:
comment|/* Can't use a register if it is used for an input address for this 	 operand or used as an input in an earlier one.  */
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_input_addr
index|[
name|opnum
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_inpaddr_addr
index|[
name|opnum
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|opnum
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_input
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
case|case
name|RELOAD_FOR_INPADDR_ADDRESS
case|:
comment|/* Can't use a register if it is used for an input address          for this operand or used as an input in an earlier          one.  */
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_inpaddr_addr
index|[
name|opnum
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|opnum
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_input
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
case|case
name|RELOAD_FOR_OUTPUT_ADDRESS
case|:
comment|/* Can't use a register if it is used for an output address for this 	 operand or used as an output in this or a later operand.  */
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_output_addr
index|[
name|opnum
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
name|opnum
init|;
name|i
operator|<
name|reload_n_operands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_output
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
case|case
name|RELOAD_FOR_OUTADDR_ADDRESS
case|:
comment|/* Can't use a register if it is used for an output address          for this operand or used as an output in this or a          later operand.  */
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_outaddr_addr
index|[
name|opnum
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
name|opnum
init|;
name|i
operator|<
name|reload_n_operands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_output
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
case|case
name|RELOAD_FOR_OPERAND_ADDRESS
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reload_n_operands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_input
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
operator|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_insn
argument_list|,
name|regno
argument_list|)
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_op_addr
argument_list|,
name|regno
argument_list|)
operator|)
return|;
case|case
name|RELOAD_FOR_OPADDR_ADDR
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reload_n_operands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_input
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
operator|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_op_addr_reload
argument_list|,
name|regno
argument_list|)
operator|)
return|;
case|case
name|RELOAD_FOR_OUTPUT
case|:
comment|/* This cannot share a register with RELOAD_FOR_INSN reloads, other 	 outputs, or an operand address for this or an earlier output.  */
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_insn
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reload_n_operands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_output
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|opnum
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_output_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_outaddr_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
case|case
name|RELOAD_FOR_INSN
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reload_n_operands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_input
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_output
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
operator|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_insn
argument_list|,
name|regno
argument_list|)
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_op_addr
argument_list|,
name|regno
argument_list|)
operator|)
return|;
case|case
name|RELOAD_FOR_OTHER_ADDRESS
case|:
return|return
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_other_addr
argument_list|,
name|regno
argument_list|)
return|;
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return 1 if the value in reload reg REGNO, as used by a reload    needed for the part of the insn specified by OPNUM and TYPE,    is still available in REGNO at the end of the insn.     We can assume that the reload reg was already tested for availability    at the time it is needed, and we should not check this again,    in case the reg has already been marked in use.  */
end_comment

begin_function
specifier|static
name|int
name|reload_reg_reaches_end_p
parameter_list|(
name|regno
parameter_list|,
name|opnum
parameter_list|,
name|type
parameter_list|)
name|int
name|regno
decl_stmt|;
name|int
name|opnum
decl_stmt|;
name|enum
name|reload_type
name|type
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|RELOAD_OTHER
case|:
comment|/* Since a RELOAD_OTHER reload claims the reg for the entire insn, 	 its value must reach the end.  */
return|return
literal|1
return|;
comment|/* If this use is for part of the insn, 	 its value reaches if no subsequent part uses the same register.  	 Just like the above function, don't try to do this with lots 	 of fallthroughs.  */
case|case
name|RELOAD_FOR_OTHER_ADDRESS
case|:
comment|/* Here we check for everything else, since these don't conflict 	 with anything else and everything comes later.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reload_n_operands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_output_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_outaddr_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_output
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_input_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_inpaddr_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_input
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
operator|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_op_addr
argument_list|,
name|regno
argument_list|)
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_insn
argument_list|,
name|regno
argument_list|)
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used
argument_list|,
name|regno
argument_list|)
operator|)
return|;
case|case
name|RELOAD_FOR_INPUT_ADDRESS
case|:
case|case
name|RELOAD_FOR_INPADDR_ADDRESS
case|:
comment|/* Similar, except that we check only for this and subsequent inputs 	 and the address of only subsequent inputs and we do not need 	 to check for RELOAD_OTHER objects since they are known not to 	 conflict.  */
for|for
control|(
name|i
operator|=
name|opnum
init|;
name|i
operator|<
name|reload_n_operands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_input
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
name|opnum
operator|+
literal|1
init|;
name|i
operator|<
name|reload_n_operands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_input_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_inpaddr_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reload_n_operands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_output_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_outaddr_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_output
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_op_addr_reload
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
operator|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_op_addr
argument_list|,
name|regno
argument_list|)
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_insn
argument_list|,
name|regno
argument_list|)
operator|)
return|;
case|case
name|RELOAD_FOR_INPUT
case|:
comment|/* Similar to input address, except we start at the next operand for 	 both input and input address and we do not check for  	 RELOAD_FOR_OPERAND_ADDRESS and RELOAD_FOR_INSN since these 	 would conflict.  */
for|for
control|(
name|i
operator|=
name|opnum
operator|+
literal|1
init|;
name|i
operator|<
name|reload_n_operands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_input_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_inpaddr_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_input
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* ... fall through ...  */
case|case
name|RELOAD_FOR_OPERAND_ADDRESS
case|:
comment|/* Check outputs and their addresses.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reload_n_operands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_output_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_outaddr_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_output
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
case|case
name|RELOAD_FOR_OPADDR_ADDR
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reload_n_operands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_output_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_outaddr_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_output
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
operator|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_op_addr
argument_list|,
name|regno
argument_list|)
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_insn
argument_list|,
name|regno
argument_list|)
operator|)
return|;
case|case
name|RELOAD_FOR_INSN
case|:
comment|/* These conflict with other outputs with RELOAD_OTHER.  So 	 we need only check for output addresses.  */
name|opnum
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* ... fall through ...  */
case|case
name|RELOAD_FOR_OUTPUT
case|:
case|case
name|RELOAD_FOR_OUTPUT_ADDRESS
case|:
case|case
name|RELOAD_FOR_OUTADDR_ADDRESS
case|:
comment|/* We already know these can't conflict with a later output.  So the 	 only thing to check are later output addresses.  */
for|for
control|(
name|i
operator|=
name|opnum
operator|+
literal|1
init|;
name|i
operator|<
name|reload_n_operands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_output_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_outaddr_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if the reloads denoted by R1 and R2 cannot share a register.    Return 0 otherwise.     This function uses the same algorithm as reload_reg_free_p above.  */
end_comment

begin_function
name|int
name|reloads_conflict
parameter_list|(
name|r1
parameter_list|,
name|r2
parameter_list|)
name|int
name|r1
decl_stmt|,
name|r2
decl_stmt|;
block|{
name|enum
name|reload_type
name|r1_type
init|=
name|reload_when_needed
index|[
name|r1
index|]
decl_stmt|;
name|enum
name|reload_type
name|r2_type
init|=
name|reload_when_needed
index|[
name|r2
index|]
decl_stmt|;
name|int
name|r1_opnum
init|=
name|reload_opnum
index|[
name|r1
index|]
decl_stmt|;
name|int
name|r2_opnum
init|=
name|reload_opnum
index|[
name|r2
index|]
decl_stmt|;
comment|/* RELOAD_OTHER conflicts with everything.  */
if|if
condition|(
name|r2_type
operator|==
name|RELOAD_OTHER
condition|)
return|return
literal|1
return|;
comment|/* Otherwise, check conflicts differently for each type.  */
switch|switch
condition|(
name|r1_type
condition|)
block|{
case|case
name|RELOAD_FOR_INPUT
case|:
return|return
operator|(
name|r2_type
operator|==
name|RELOAD_FOR_INSN
operator|||
name|r2_type
operator|==
name|RELOAD_FOR_OPERAND_ADDRESS
operator|||
name|r2_type
operator|==
name|RELOAD_FOR_OPADDR_ADDR
operator|||
name|r2_type
operator|==
name|RELOAD_FOR_INPUT
operator|||
operator|(
operator|(
name|r2_type
operator|==
name|RELOAD_FOR_INPUT_ADDRESS
operator|||
name|r2_type
operator|==
name|RELOAD_FOR_INPADDR_ADDRESS
operator|)
operator|&&
name|r2_opnum
operator|>
name|r1_opnum
operator|)
operator|)
return|;
case|case
name|RELOAD_FOR_INPUT_ADDRESS
case|:
return|return
operator|(
operator|(
name|r2_type
operator|==
name|RELOAD_FOR_INPUT_ADDRESS
operator|&&
name|r1_opnum
operator|==
name|r2_opnum
operator|)
operator|||
operator|(
name|r2_type
operator|==
name|RELOAD_FOR_INPUT
operator|&&
name|r2_opnum
operator|<
name|r1_opnum
operator|)
operator|)
return|;
case|case
name|RELOAD_FOR_INPADDR_ADDRESS
case|:
return|return
operator|(
operator|(
name|r2_type
operator|==
name|RELOAD_FOR_INPADDR_ADDRESS
operator|&&
name|r1_opnum
operator|==
name|r2_opnum
operator|)
operator|||
operator|(
name|r2_type
operator|==
name|RELOAD_FOR_INPUT
operator|&&
name|r2_opnum
operator|<
name|r1_opnum
operator|)
operator|)
return|;
case|case
name|RELOAD_FOR_OUTPUT_ADDRESS
case|:
return|return
operator|(
operator|(
name|r2_type
operator|==
name|RELOAD_FOR_OUTPUT_ADDRESS
operator|&&
name|r2_opnum
operator|==
name|r1_opnum
operator|)
operator|||
operator|(
name|r2_type
operator|==
name|RELOAD_FOR_OUTPUT
operator|&&
name|r2_opnum
operator|>=
name|r1_opnum
operator|)
operator|)
return|;
case|case
name|RELOAD_FOR_OUTADDR_ADDRESS
case|:
return|return
operator|(
operator|(
name|r2_type
operator|==
name|RELOAD_FOR_OUTADDR_ADDRESS
operator|&&
name|r2_opnum
operator|==
name|r1_opnum
operator|)
operator|||
operator|(
name|r2_type
operator|==
name|RELOAD_FOR_OUTPUT
operator|&&
name|r2_opnum
operator|>=
name|r1_opnum
operator|)
operator|)
return|;
case|case
name|RELOAD_FOR_OPERAND_ADDRESS
case|:
return|return
operator|(
name|r2_type
operator|==
name|RELOAD_FOR_INPUT
operator|||
name|r2_type
operator|==
name|RELOAD_FOR_INSN
operator|||
name|r2_type
operator|==
name|RELOAD_FOR_OPERAND_ADDRESS
operator|)
return|;
case|case
name|RELOAD_FOR_OPADDR_ADDR
case|:
return|return
operator|(
name|r2_type
operator|==
name|RELOAD_FOR_INPUT
operator|||
name|r2_type
operator|==
name|RELOAD_FOR_OPADDR_ADDR
operator|)
return|;
case|case
name|RELOAD_FOR_OUTPUT
case|:
return|return
operator|(
name|r2_type
operator|==
name|RELOAD_FOR_INSN
operator|||
name|r2_type
operator|==
name|RELOAD_FOR_OUTPUT
operator|||
operator|(
operator|(
name|r2_type
operator|==
name|RELOAD_FOR_OUTPUT_ADDRESS
operator|||
name|r2_type
operator|==
name|RELOAD_FOR_OUTADDR_ADDRESS
operator|)
operator|&&
name|r2_opnum
operator|>=
name|r1_opnum
operator|)
operator|)
return|;
case|case
name|RELOAD_FOR_INSN
case|:
return|return
operator|(
name|r2_type
operator|==
name|RELOAD_FOR_INPUT
operator|||
name|r2_type
operator|==
name|RELOAD_FOR_OUTPUT
operator|||
name|r2_type
operator|==
name|RELOAD_FOR_INSN
operator|||
name|r2_type
operator|==
name|RELOAD_FOR_OPERAND_ADDRESS
operator|)
return|;
case|case
name|RELOAD_FOR_OTHER_ADDRESS
case|:
return|return
name|r2_type
operator|==
name|RELOAD_FOR_OTHER_ADDRESS
return|;
case|case
name|RELOAD_OTHER
case|:
return|return
literal|1
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Vector of reload-numbers showing the order in which the reloads should    be processed.  */
end_comment

begin_decl_stmt
name|short
name|reload_order
index|[
name|MAX_RELOADS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by reload number, 1 if incoming value    inherited from previous insns.  */
end_comment

begin_decl_stmt
name|char
name|reload_inherited
index|[
name|MAX_RELOADS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For an inherited reload, this is the insn the reload was inherited from,    if we know it.  Otherwise, this is 0.  */
end_comment

begin_decl_stmt
name|rtx
name|reload_inheritance_insn
index|[
name|MAX_RELOADS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If non-zero, this is a place to get the value of the reload,    rather than using reload_in.  */
end_comment

begin_decl_stmt
name|rtx
name|reload_override_in
index|[
name|MAX_RELOADS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For each reload, the hard register number of the register used,    or -1 if we did not need a register for this reload.  */
end_comment

begin_decl_stmt
name|int
name|reload_spill_index
index|[
name|MAX_RELOADS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return 1 if the value in reload reg REGNO, as used by a reload    needed for the part of the insn specified by OPNUM and TYPE,    may be used to load VALUE into it.     Other read-only reloads with the same value do not conflict    unless OUT is non-zero and these other reloads have to live while    output reloads live.    If OUT is CONST0_RTX, this is a special case: it means that the    test should not be for using register REGNO as reload register, but    for copying from register REGNO into the reload register.     RELOADNUM is the number of the reload we want to load this value for;    a reload does not conflict with itself.     When IGNORE_ADDRESS_RELOADS is set, we can not have conflicts with    reloads that load an address for the very reload we are considering.     The caller has to make sure that there is no conflict with the return    register.  */
end_comment

begin_function
specifier|static
name|int
name|reload_reg_free_for_value_p
parameter_list|(
name|regno
parameter_list|,
name|opnum
parameter_list|,
name|type
parameter_list|,
name|value
parameter_list|,
name|out
parameter_list|,
name|reloadnum
parameter_list|,
name|ignore_address_reloads
parameter_list|)
name|int
name|regno
decl_stmt|;
name|int
name|opnum
decl_stmt|;
name|enum
name|reload_type
name|type
decl_stmt|;
name|rtx
name|value
decl_stmt|,
name|out
decl_stmt|;
name|int
name|reloadnum
decl_stmt|;
name|int
name|ignore_address_reloads
decl_stmt|;
block|{
name|int
name|time1
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|copy
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|out
operator|==
name|const0_rtx
condition|)
block|{
name|copy
operator|=
literal|1
expr_stmt|;
name|out
operator|=
name|NULL_RTX
expr_stmt|;
block|}
comment|/* We use some pseudo 'time' value to check if the lifetimes of the      new register use would overlap with the one of a previous reload      that is not read-only or uses a different value.      The 'time' used doesn't have to be linear in any shape or form, just      monotonic.      Some reload types use different 'buckets' for each operand.      So there are MAX_RECOG_OPERANDS different time values for each      such reload type.      We compute TIME1 as the time when the register for the prospective      new reload ceases to be live, and TIME2 for each existing      reload as the time when that the reload register of that reload      becomes live.      Where there is little to be gained by exact lifetime calculations,      we just make conservative assumptions, i.e. a longer lifetime;      this is done in the 'default:' cases.  */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|RELOAD_FOR_OTHER_ADDRESS
case|:
name|time1
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|RELOAD_OTHER
case|:
name|time1
operator|=
name|copy
condition|?
literal|1
else|:
name|MAX_RECOG_OPERANDS
operator|*
literal|5
operator|+
literal|5
expr_stmt|;
break|break;
comment|/* For each input, we might have a sequence of RELOAD_FOR_INPADDR_ADDRESS,        RELOAD_FOR_INPUT_ADDRESS and RELOAD_FOR_INPUT.  By adding 0 / 1 / 2 ,        respectively, to the time values for these, we get distinct time        values.  To get distinct time values for each operand, we have to        multiply opnum by at least three.  We round that up to four because        multiply by four is often cheaper.  */
case|case
name|RELOAD_FOR_INPADDR_ADDRESS
case|:
name|time1
operator|=
name|opnum
operator|*
literal|4
operator|+
literal|2
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_INPUT_ADDRESS
case|:
name|time1
operator|=
name|opnum
operator|*
literal|4
operator|+
literal|3
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_INPUT
case|:
comment|/* All RELOAD_FOR_INPUT reloads remain live till the instruction 	 executes (inclusive).  */
name|time1
operator|=
name|copy
condition|?
name|opnum
operator|*
literal|4
operator|+
literal|4
else|:
name|MAX_RECOG_OPERANDS
operator|*
literal|4
operator|+
literal|3
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OPADDR_ADDR
case|:
comment|/* opnum * 4 + 4<= (MAX_RECOG_OPERANDS - 1) * 4 + 4 == MAX_RECOG_OPERANDS * 4 */
name|time1
operator|=
name|MAX_RECOG_OPERANDS
operator|*
literal|4
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OPERAND_ADDRESS
case|:
comment|/* RELOAD_FOR_OPERAND_ADDRESS reloads are live even while the insn 	 is executed.  */
name|time1
operator|=
name|copy
condition|?
name|MAX_RECOG_OPERANDS
operator|*
literal|4
operator|+
literal|2
else|:
name|MAX_RECOG_OPERANDS
operator|*
literal|4
operator|+
literal|3
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OUTADDR_ADDRESS
case|:
name|time1
operator|=
name|MAX_RECOG_OPERANDS
operator|*
literal|4
operator|+
literal|4
operator|+
name|opnum
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OUTPUT_ADDRESS
case|:
name|time1
operator|=
name|MAX_RECOG_OPERANDS
operator|*
literal|4
operator|+
literal|5
operator|+
name|opnum
expr_stmt|;
break|break;
default|default:
name|time1
operator|=
name|MAX_RECOG_OPERANDS
operator|*
literal|5
operator|+
literal|5
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_reloads
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|reg
init|=
name|reload_reg_rtx
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|reg
operator|&&
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|REG
operator|&&
operator|(
operator|(
name|unsigned
operator|)
name|regno
operator|-
name|true_regnum
argument_list|(
name|reg
argument_list|)
operator|<=
name|HARD_REGNO_NREGS
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|-
operator|(
name|unsigned
operator|)
literal|1
operator|)
operator|&&
name|i
operator|!=
name|reloadnum
condition|)
block|{
if|if
condition|(
operator|!
name|reload_in
index|[
name|i
index|]
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|reload_in
index|[
name|i
index|]
argument_list|,
name|value
argument_list|)
operator|||
name|reload_out
index|[
name|i
index|]
operator|||
name|out
condition|)
block|{
name|int
name|time2
decl_stmt|;
switch|switch
condition|(
name|reload_when_needed
index|[
name|i
index|]
condition|)
block|{
case|case
name|RELOAD_FOR_OTHER_ADDRESS
case|:
name|time2
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_INPADDR_ADDRESS
case|:
comment|/* find_reloads makes sure that a 		     RELOAD_FOR_{INP,OP,OUT}ADDR_ADDRESS reload is only used 		     by at most one - the first - 		     RELOAD_FOR_{INPUT,OPERAND,OUTPUT}_ADDRESS .  If the 		     address reload is inherited, the address address reload 		     goes away, so we can ignore this conflict.  */
if|if
condition|(
name|type
operator|==
name|RELOAD_FOR_INPUT_ADDRESS
operator|&&
name|reloadnum
operator|==
name|i
operator|+
literal|1
operator|&&
name|ignore_address_reloads
comment|/* Unless the RELOAD_FOR_INPUT is an auto_inc expression. 			 Then the address address is still needed to store 			 back the new address.  */
operator|&&
operator|!
name|reload_out
index|[
name|reloadnum
index|]
condition|)
continue|continue;
comment|/* Likewise, if a RELOAD_FOR_INPUT can inherit a value, its 		     RELOAD_FOR_INPUT_ADDRESS / RELOAD_FOR_INPADDR_ADDRESS 		     reloads go away.  */
if|if
condition|(
name|type
operator|==
name|RELOAD_FOR_INPUT
operator|&&
name|opnum
operator|==
name|reload_opnum
index|[
name|i
index|]
operator|&&
name|ignore_address_reloads
comment|/* Unless we are reloading an auto_inc expression.  */
operator|&&
operator|!
name|reload_out
index|[
name|reloadnum
index|]
condition|)
continue|continue;
name|time2
operator|=
name|reload_opnum
index|[
name|i
index|]
operator|*
literal|4
operator|+
literal|2
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_INPUT_ADDRESS
case|:
if|if
condition|(
name|type
operator|==
name|RELOAD_FOR_INPUT
operator|&&
name|opnum
operator|==
name|reload_opnum
index|[
name|i
index|]
operator|&&
name|ignore_address_reloads
operator|&&
operator|!
name|reload_out
index|[
name|reloadnum
index|]
condition|)
continue|continue;
name|time2
operator|=
name|reload_opnum
index|[
name|i
index|]
operator|*
literal|4
operator|+
literal|3
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_INPUT
case|:
name|time2
operator|=
name|reload_opnum
index|[
name|i
index|]
operator|*
literal|4
operator|+
literal|4
expr_stmt|;
break|break;
comment|/* reload_opnum[i] * 4 + 4<= (MAX_RECOG_OPERAND - 1) * 4 + 4 		   == MAX_RECOG_OPERAND * 4  */
case|case
name|RELOAD_FOR_OPADDR_ADDR
case|:
if|if
condition|(
name|type
operator|==
name|RELOAD_FOR_OPERAND_ADDRESS
operator|&&
name|reloadnum
operator|==
name|i
operator|+
literal|1
operator|&&
name|ignore_address_reloads
operator|&&
operator|!
name|reload_out
index|[
name|reloadnum
index|]
condition|)
continue|continue;
name|time2
operator|=
name|MAX_RECOG_OPERANDS
operator|*
literal|4
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OPERAND_ADDRESS
case|:
name|time2
operator|=
name|MAX_RECOG_OPERANDS
operator|*
literal|4
operator|+
literal|2
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_INSN
case|:
name|time2
operator|=
name|MAX_RECOG_OPERANDS
operator|*
literal|4
operator|+
literal|3
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OUTPUT
case|:
comment|/* All RELOAD_FOR_OUTPUT reloads become live just after the 		   instruction is executed.  */
name|time2
operator|=
name|MAX_RECOG_OPERANDS
operator|*
literal|4
operator|+
literal|4
expr_stmt|;
break|break;
comment|/* The first RELOAD_FOR_OUTADDR_ADDRESS reload conflicts with 		   the RELOAD_FOR_OUTPUT reloads, so assign it the same time 		   value.  */
case|case
name|RELOAD_FOR_OUTADDR_ADDRESS
case|:
if|if
condition|(
name|type
operator|==
name|RELOAD_FOR_OUTPUT_ADDRESS
operator|&&
name|reloadnum
operator|==
name|i
operator|+
literal|1
operator|&&
name|ignore_address_reloads
operator|&&
operator|!
name|reload_out
index|[
name|reloadnum
index|]
condition|)
continue|continue;
name|time2
operator|=
name|MAX_RECOG_OPERANDS
operator|*
literal|4
operator|+
literal|4
operator|+
name|reload_opnum
index|[
name|i
index|]
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OUTPUT_ADDRESS
case|:
name|time2
operator|=
name|MAX_RECOG_OPERANDS
operator|*
literal|4
operator|+
literal|5
operator|+
name|reload_opnum
index|[
name|i
index|]
expr_stmt|;
break|break;
case|case
name|RELOAD_OTHER
case|:
comment|/* If there is no conflict in the input part, handle this 		     like an output reload.  */
if|if
condition|(
operator|!
name|reload_in
index|[
name|i
index|]
operator|||
name|rtx_equal_p
argument_list|(
name|reload_in
index|[
name|i
index|]
argument_list|,
name|value
argument_list|)
condition|)
block|{
name|time2
operator|=
name|MAX_RECOG_OPERANDS
operator|*
literal|4
operator|+
literal|4
expr_stmt|;
break|break;
block|}
name|time2
operator|=
literal|1
expr_stmt|;
comment|/* RELOAD_OTHER might be live beyond instruction execution, 		     but this is not obvious when we set time2 = 1.  So check 		     here if there might be a problem with the new reload 		     clobbering the register used by the RELOAD_OTHER.  */
if|if
condition|(
name|out
condition|)
return|return
literal|0
return|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|time1
operator|>=
name|time2
operator|&&
operator|(
operator|!
name|reload_in
index|[
name|i
index|]
operator|||
name|reload_out
index|[
name|i
index|]
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|reload_in
index|[
name|i
index|]
argument_list|,
name|value
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|out
operator|&&
name|reload_out_reg
index|[
name|reloadnum
index|]
operator|&&
name|time2
operator|>=
name|MAX_RECOG_OPERANDS
operator|*
literal|4
operator|+
literal|3
operator|)
condition|)
return|return
literal|0
return|;
block|}
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Find a spill register to use as a reload register for reload R.    LAST_RELOAD is non-zero if this is the last reload for the insn being    processed.     Set reload_reg_rtx[R] to the register allocated.     If NOERROR is nonzero, we return 1 if successful,    or 0 if we couldn't find a spill reg and we didn't change anything.  */
end_comment

begin_function
specifier|static
name|int
name|allocate_reload_reg
parameter_list|(
name|chain
parameter_list|,
name|r
parameter_list|,
name|last_reload
parameter_list|,
name|noerror
parameter_list|)
name|struct
name|insn_chain
modifier|*
name|chain
decl_stmt|;
name|int
name|r
decl_stmt|;
name|int
name|last_reload
decl_stmt|;
name|int
name|noerror
decl_stmt|;
block|{
name|rtx
name|insn
init|=
name|chain
operator|->
name|insn
decl_stmt|;
name|int
name|i
decl_stmt|,
name|pass
decl_stmt|,
name|count
decl_stmt|,
name|regno
decl_stmt|;
name|rtx
name|new
decl_stmt|;
comment|/* If we put this reload ahead, thinking it is a group,      then insist on finding a group.  Otherwise we can grab a      reg that some other reload needs.      (That can happen when we have a 68000 DATA_OR_FP_REG      which is a group of data regs or one fp reg.)      We need not be so restrictive if there are no more reloads      for this insn.       ??? Really it would be nicer to have smarter handling      for that kind of reg class, where a problem like this is normal.      Perhaps those classes should be avoided for reloading      by use of more alternatives.  */
name|int
name|force_group
init|=
name|reload_nregs
index|[
name|r
index|]
operator|>
literal|1
operator|&&
operator|!
name|last_reload
decl_stmt|;
comment|/* If we want a single register and haven't yet found one,      take any reg in the right class and not in use.      If we want a consecutive group, here is where we look for it.       We use two passes so we can first look for reload regs to      reuse, which are already in use for other reloads in this insn,      and only then use additional registers.      I think that maximizing reuse is needed to make sure we don't      run out of reload regs.  Suppose we have three reloads, and      reloads A and B can share regs.  These need two regs.      Suppose A and B are given different regs.      That leaves none for C.  */
for|for
control|(
name|pass
operator|=
literal|0
init|;
name|pass
operator|<
literal|2
condition|;
name|pass
operator|++
control|)
block|{
comment|/* I is the index in spill_regs. 	 We advance it round-robin between insns to use all spill regs 	 equally, so that inherited reloads have a chance 	 of leapfrogging each other.  Don't do this, however, when we have 	 group needs and failure would be fatal; if we only have a relatively 	 small number of spill registers, and more than one of them has 	 group needs, then by starting in the middle, we may end up  	 allocating the first one in such a way that we are not left with 	 sufficient groups to handle the rest.  */
if|if
condition|(
name|noerror
operator|||
operator|!
name|force_group
condition|)
name|i
operator|=
name|last_spill_reg
expr_stmt|;
else|else
name|i
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|n_spills
condition|;
name|count
operator|++
control|)
block|{
name|int
name|class
init|=
operator|(
name|int
operator|)
name|reload_reg_class
index|[
name|r
index|]
decl_stmt|;
name|int
name|regnum
decl_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|n_spills
condition|)
name|i
operator|-=
name|n_spills
expr_stmt|;
name|regnum
operator|=
name|spill_regs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|reload_reg_free_p
argument_list|(
name|regnum
argument_list|,
name|reload_opnum
index|[
name|r
index|]
argument_list|,
name|reload_when_needed
index|[
name|r
index|]
argument_list|)
operator|||
operator|(
name|reload_in
index|[
name|r
index|]
comment|/* We check reload_reg_used to make sure we 			 don't clobber the return register.  */
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used
argument_list|,
name|regnum
argument_list|)
operator|&&
name|reload_reg_free_for_value_p
argument_list|(
name|regnum
argument_list|,
name|reload_opnum
index|[
name|r
index|]
argument_list|,
name|reload_when_needed
index|[
name|r
index|]
argument_list|,
name|reload_in
index|[
name|r
index|]
argument_list|,
name|reload_out
index|[
name|r
index|]
argument_list|,
name|r
argument_list|,
literal|1
argument_list|)
operator|)
operator|)
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|class
index|]
argument_list|,
name|regnum
argument_list|)
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|regnum
argument_list|,
name|reload_mode
index|[
name|r
index|]
argument_list|)
comment|/* Look first for regs to share, then for unshared.  But 		 don't share regs used for inherited reloads; they are 		 the ones we want to preserve.  */
operator|&&
operator|(
name|pass
operator|||
operator|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_at_all
argument_list|,
name|regnum
argument_list|)
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_for_inherit
argument_list|,
name|regnum
argument_list|)
operator|)
operator|)
condition|)
block|{
name|int
name|nr
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regnum
argument_list|,
name|reload_mode
index|[
name|r
index|]
argument_list|)
decl_stmt|;
comment|/* Avoid the problem where spilling a GENERAL_OR_FP_REG 		 (on 68000) got us two FP regs.  If NR is 1, 		 we would reject both of them.  */
if|if
condition|(
name|force_group
condition|)
name|nr
operator|=
name|CLASS_MAX_NREGS
argument_list|(
name|reload_reg_class
index|[
name|r
index|]
argument_list|,
name|reload_mode
index|[
name|r
index|]
argument_list|)
expr_stmt|;
comment|/* If we need only one reg, we have already won.  */
if|if
condition|(
name|nr
operator|==
literal|1
condition|)
block|{
comment|/* But reject a single reg if we demand a group.  */
if|if
condition|(
name|force_group
condition|)
continue|continue;
break|break;
block|}
comment|/* Otherwise check that as many consecutive regs as we need 		 are available here. 		 Also, don't use for a group registers that are 		 needed for nongroups.  */
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|chain
operator|->
name|counted_for_nongroups
argument_list|,
name|regnum
argument_list|)
condition|)
while|while
condition|(
name|nr
operator|>
literal|1
condition|)
block|{
name|regno
operator|=
name|regnum
operator|+
name|nr
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|class
index|]
argument_list|,
name|regno
argument_list|)
operator|&&
name|spill_reg_order
index|[
name|regno
index|]
operator|>=
literal|0
operator|&&
name|reload_reg_free_p
argument_list|(
name|regno
argument_list|,
name|reload_opnum
index|[
name|r
index|]
argument_list|,
name|reload_when_needed
index|[
name|r
index|]
argument_list|)
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|chain
operator|->
name|counted_for_nongroups
argument_list|,
name|regno
argument_list|)
operator|)
condition|)
break|break;
name|nr
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|nr
operator|==
literal|1
condition|)
break|break;
block|}
block|}
comment|/* If we found something on pass 1, omit pass 2.  */
if|if
condition|(
name|count
operator|<
name|n_spills
condition|)
break|break;
block|}
comment|/* We should have found a spill register by now.  */
if|if
condition|(
name|count
operator|==
name|n_spills
condition|)
block|{
if|if
condition|(
name|noerror
condition|)
return|return
literal|0
return|;
goto|goto
name|failure
goto|;
block|}
comment|/* I is the index in SPILL_REG_RTX of the reload register we are to      allocate.  Get an rtx for it and find its register number.  */
name|new
operator|=
name|spill_reg_rtx
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|new
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|new
argument_list|)
operator|!=
name|reload_mode
index|[
name|r
index|]
condition|)
name|spill_reg_rtx
index|[
name|i
index|]
operator|=
name|new
operator|=
name|gen_rtx_REG
argument_list|(
name|reload_mode
index|[
name|r
index|]
argument_list|,
name|spill_regs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|regno
operator|=
name|true_regnum
argument_list|(
name|new
argument_list|)
expr_stmt|;
comment|/* Detect when the reload reg can't hold the reload mode.      This used to be one `if', but Sequent compiler can't handle that.  */
if|if
condition|(
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|reload_mode
index|[
name|r
index|]
argument_list|)
condition|)
block|{
name|enum
name|machine_mode
name|test_mode
init|=
name|VOIDmode
decl_stmt|;
if|if
condition|(
name|reload_in
index|[
name|r
index|]
condition|)
name|test_mode
operator|=
name|GET_MODE
argument_list|(
name|reload_in
index|[
name|r
index|]
argument_list|)
expr_stmt|;
comment|/* If reload_in[r] has VOIDmode, it means we will load it 	 in whatever mode the reload reg has: to wit, reload_mode[r]. 	 We have already tested that for validity.  */
comment|/* Aside from that, we need to test that the expressions 	 to reload from or into have modes which are valid for this 	 reload register.  Otherwise the reload insns would be invalid.  */
if|if
condition|(
operator|!
operator|(
name|reload_in
index|[
name|r
index|]
operator|!=
literal|0
operator|&&
name|test_mode
operator|!=
name|VOIDmode
operator|&&
operator|!
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|test_mode
argument_list|)
operator|)
condition|)
if|if
condition|(
operator|!
operator|(
name|reload_out
index|[
name|r
index|]
operator|!=
literal|0
operator|&&
operator|!
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|reload_out
index|[
name|r
index|]
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/* The reg is OK.  */
name|last_spill_reg
operator|=
name|i
expr_stmt|;
comment|/* Mark as in use for this insn the reload regs we use 	       for this.  */
name|mark_reload_reg_in_use
argument_list|(
name|spill_regs
index|[
name|i
index|]
argument_list|,
name|reload_opnum
index|[
name|r
index|]
argument_list|,
name|reload_when_needed
index|[
name|r
index|]
argument_list|,
name|reload_mode
index|[
name|r
index|]
argument_list|)
expr_stmt|;
name|reload_reg_rtx
index|[
name|r
index|]
operator|=
name|new
expr_stmt|;
name|reload_spill_index
index|[
name|r
index|]
operator|=
name|spill_regs
index|[
name|i
index|]
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
comment|/* The reg is not OK.  */
if|if
condition|(
name|noerror
condition|)
return|return
literal|0
return|;
name|failure
label|:
if|if
condition|(
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
comment|/* It's the compiler's fault.  */
name|fatal_insn
argument_list|(
literal|"Could not find a spill register"
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* It's the user's fault; the operand's mode and constraint      don't match.  Disable this reload so we don't crash in final.  */
name|error_for_asm
argument_list|(
name|insn
argument_list|,
literal|"`asm' operand constraint incompatible with operand size"
argument_list|)
expr_stmt|;
name|reload_in
index|[
name|r
index|]
operator|=
literal|0
expr_stmt|;
name|reload_out
index|[
name|r
index|]
operator|=
literal|0
expr_stmt|;
name|reload_reg_rtx
index|[
name|r
index|]
operator|=
literal|0
expr_stmt|;
name|reload_optional
index|[
name|r
index|]
operator|=
literal|1
expr_stmt|;
name|reload_secondary_p
index|[
name|r
index|]
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Assign hard reg targets for the pseudo-registers we must reload    into hard regs for this insn.    Also output the instructions to copy them in and out of the hard regs.     For machines with register classes, we are responsible for    finding a reload reg in the proper class.  */
end_comment

begin_function
specifier|static
name|void
name|choose_reload_regs
parameter_list|(
name|chain
parameter_list|)
name|struct
name|insn_chain
modifier|*
name|chain
decl_stmt|;
block|{
name|rtx
name|insn
init|=
name|chain
operator|->
name|insn
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|max_group_size
init|=
literal|1
decl_stmt|;
name|enum
name|reg_class
name|group_class
init|=
name|NO_REGS
decl_stmt|;
name|int
name|inheritance
decl_stmt|;
name|int
name|pass
decl_stmt|;
name|rtx
name|save_reload_reg_rtx
index|[
name|MAX_RELOADS
index|]
decl_stmt|;
name|char
name|save_reload_inherited
index|[
name|MAX_RELOADS
index|]
decl_stmt|;
name|rtx
name|save_reload_inheritance_insn
index|[
name|MAX_RELOADS
index|]
decl_stmt|;
name|rtx
name|save_reload_override_in
index|[
name|MAX_RELOADS
index|]
decl_stmt|;
name|int
name|save_reload_spill_index
index|[
name|MAX_RELOADS
index|]
decl_stmt|;
name|HARD_REG_SET
name|save_reload_reg_used
decl_stmt|;
name|HARD_REG_SET
name|save_reload_reg_used_in_input_addr
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|HARD_REG_SET
name|save_reload_reg_used_in_inpaddr_addr
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|HARD_REG_SET
name|save_reload_reg_used_in_output_addr
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|HARD_REG_SET
name|save_reload_reg_used_in_outaddr_addr
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|HARD_REG_SET
name|save_reload_reg_used_in_input
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|HARD_REG_SET
name|save_reload_reg_used_in_output
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|HARD_REG_SET
name|save_reload_reg_used_in_op_addr
decl_stmt|;
name|HARD_REG_SET
name|save_reload_reg_used_in_op_addr_reload
decl_stmt|;
name|HARD_REG_SET
name|save_reload_reg_used_in_insn
decl_stmt|;
name|HARD_REG_SET
name|save_reload_reg_used_in_other_addr
decl_stmt|;
name|HARD_REG_SET
name|save_reload_reg_used_at_all
decl_stmt|;
name|bzero
argument_list|(
name|reload_inherited
argument_list|,
name|MAX_RELOADS
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reload_inheritance_insn
argument_list|,
name|MAX_RELOADS
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reload_override_in
argument_list|,
name|MAX_RELOADS
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|reload_reg_used
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|reload_reg_used_at_all
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|reload_reg_used_in_op_addr
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|reload_reg_used_in_op_addr_reload
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|reload_reg_used_in_insn
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|reload_reg_used_in_other_addr
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|reg_used_in_insn
argument_list|)
expr_stmt|;
block|{
name|HARD_REG_SET
name|tmp
decl_stmt|;
name|REG_SET_TO_HARD_REG_SET
argument_list|(
name|tmp
argument_list|,
name|chain
operator|->
name|live_before
argument_list|)
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|reg_used_in_insn
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|REG_SET_TO_HARD_REG_SET
argument_list|(
name|tmp
argument_list|,
name|chain
operator|->
name|live_after
argument_list|)
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|reg_used_in_insn
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|compute_use_by_pseudos
argument_list|(
operator|&
name|reg_used_in_insn
argument_list|,
name|chain
operator|->
name|live_before
argument_list|)
expr_stmt|;
name|compute_use_by_pseudos
argument_list|(
operator|&
name|reg_used_in_insn
argument_list|,
name|chain
operator|->
name|live_after
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reload_n_operands
condition|;
name|i
operator|++
control|)
block|{
name|CLEAR_HARD_REG_SET
argument_list|(
name|reload_reg_used_in_output
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|reload_reg_used_in_input
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|reload_reg_used_in_input_addr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|reload_reg_used_in_inpaddr_addr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|reload_reg_used_in_output_addr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|reload_reg_used_in_outaddr_addr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|IOR_COMPL_HARD_REG_SET
argument_list|(
name|reload_reg_used
argument_list|,
name|chain
operator|->
name|used_spill_regs
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Not needed, now that we can always retry without inheritance.  */
comment|/* See if we have more mandatory reloads than spill regs.      If so, then we cannot risk optimizations that could prevent      reloads from sharing one spill register.       Since we will try finding a better register than reload_reg_rtx      unless it is equal to reload_in or reload_out, count such reloads.  */
block|{     int tem = 0;     for (j = 0; j< n_reloads; j++)       if (! reload_optional[j]&& (reload_in[j] != 0 || reload_out[j] != 0 || reload_secondary_p[j])&& (reload_reg_rtx[j] == 0 	      || (! rtx_equal_p (reload_reg_rtx[j], reload_in[j])&& ! rtx_equal_p (reload_reg_rtx[j], reload_out[j])))) 	tem++;     if (tem> n_spills)       must_reuse = 1;   }
endif|#
directive|endif
comment|/* In order to be certain of getting the registers we need,      we must sort the reloads into order of increasing register class.      Then our grabbing of reload registers will parallel the process      that provided the reload registers.       Also note whether any of the reloads wants a consecutive group of regs.      If so, record the maximum size of the group desired and what      register class contains all the groups needed by this insn.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_reloads
condition|;
name|j
operator|++
control|)
block|{
name|reload_order
index|[
name|j
index|]
operator|=
name|j
expr_stmt|;
name|reload_spill_index
index|[
name|j
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|reload_mode
index|[
name|j
index|]
operator|=
operator|(
name|reload_inmode
index|[
name|j
index|]
operator|==
name|VOIDmode
operator|||
operator|(
name|GET_MODE_SIZE
argument_list|(
name|reload_outmode
index|[
name|j
index|]
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|reload_inmode
index|[
name|j
index|]
argument_list|)
operator|)
operator|)
condition|?
name|reload_outmode
index|[
name|j
index|]
else|:
name|reload_inmode
index|[
name|j
index|]
expr_stmt|;
name|reload_nregs
index|[
name|j
index|]
operator|=
name|CLASS_MAX_NREGS
argument_list|(
name|reload_reg_class
index|[
name|j
index|]
argument_list|,
name|reload_mode
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|reload_nregs
index|[
name|j
index|]
operator|>
literal|1
condition|)
block|{
name|max_group_size
operator|=
name|MAX
argument_list|(
name|reload_nregs
index|[
name|j
index|]
argument_list|,
name|max_group_size
argument_list|)
expr_stmt|;
name|group_class
operator|=
name|reg_class_superunion
index|[
operator|(
name|int
operator|)
name|reload_reg_class
index|[
name|j
index|]
index|]
index|[
operator|(
name|int
operator|)
name|group_class
index|]
expr_stmt|;
block|}
comment|/* If we have already decided to use a certain register, 	 don't use it in another way.  */
if|if
condition|(
name|reload_reg_rtx
index|[
name|j
index|]
condition|)
name|mark_reload_reg_in_use
argument_list|(
name|REGNO
argument_list|(
name|reload_reg_rtx
index|[
name|j
index|]
argument_list|)
argument_list|,
name|reload_opnum
index|[
name|j
index|]
argument_list|,
name|reload_when_needed
index|[
name|j
index|]
argument_list|,
name|reload_mode
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n_reloads
operator|>
literal|1
condition|)
name|qsort
argument_list|(
name|reload_order
argument_list|,
name|n_reloads
argument_list|,
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|,
name|reload_reg_class_lower
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reload_reg_rtx
argument_list|,
operator|(
name|char
operator|*
operator|)
name|save_reload_reg_rtx
argument_list|,
sizeof|sizeof
name|reload_reg_rtx
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|reload_inherited
argument_list|,
name|save_reload_inherited
argument_list|,
sizeof|sizeof
name|reload_inherited
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reload_inheritance_insn
argument_list|,
operator|(
name|char
operator|*
operator|)
name|save_reload_inheritance_insn
argument_list|,
sizeof|sizeof
name|reload_inheritance_insn
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reload_override_in
argument_list|,
operator|(
name|char
operator|*
operator|)
name|save_reload_override_in
argument_list|,
sizeof|sizeof
name|reload_override_in
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reload_spill_index
argument_list|,
operator|(
name|char
operator|*
operator|)
name|save_reload_spill_index
argument_list|,
sizeof|sizeof
name|reload_spill_index
argument_list|)
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|save_reload_reg_used
argument_list|,
name|reload_reg_used
argument_list|)
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|save_reload_reg_used_at_all
argument_list|,
name|reload_reg_used_at_all
argument_list|)
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|save_reload_reg_used_in_op_addr
argument_list|,
name|reload_reg_used_in_op_addr
argument_list|)
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|save_reload_reg_used_in_op_addr_reload
argument_list|,
name|reload_reg_used_in_op_addr_reload
argument_list|)
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|save_reload_reg_used_in_insn
argument_list|,
name|reload_reg_used_in_insn
argument_list|)
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|save_reload_reg_used_in_other_addr
argument_list|,
name|reload_reg_used_in_other_addr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reload_n_operands
condition|;
name|i
operator|++
control|)
block|{
name|COPY_HARD_REG_SET
argument_list|(
name|save_reload_reg_used_in_output
index|[
name|i
index|]
argument_list|,
name|reload_reg_used_in_output
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|save_reload_reg_used_in_input
index|[
name|i
index|]
argument_list|,
name|reload_reg_used_in_input
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|save_reload_reg_used_in_input_addr
index|[
name|i
index|]
argument_list|,
name|reload_reg_used_in_input_addr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|save_reload_reg_used_in_inpaddr_addr
index|[
name|i
index|]
argument_list|,
name|reload_reg_used_in_inpaddr_addr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|save_reload_reg_used_in_output_addr
index|[
name|i
index|]
argument_list|,
name|reload_reg_used_in_output_addr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|save_reload_reg_used_in_outaddr_addr
index|[
name|i
index|]
argument_list|,
name|reload_reg_used_in_outaddr_addr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* If -O, try first with inheritance, then turning it off.      If not -O, don't do inheritance.      Using inheritance when not optimizing leads to paradoxes      with fp on the 68k: fp numbers (not NaNs) fail to be equal to themselves      because one side of the comparison might be inherited.  */
for|for
control|(
name|inheritance
operator|=
name|optimize
operator|>
literal|0
init|;
name|inheritance
operator|>=
literal|0
condition|;
name|inheritance
operator|--
control|)
block|{
comment|/* Process the reloads in order of preference just found. 	 Beyond this point, subregs can be found in reload_reg_rtx.  	 This used to look for an existing reloaded home for all 	 of the reloads, and only then perform any new reloads. 	 But that could lose if the reloads were done out of reg-class order 	 because a later reload with a looser constraint might have an old 	 home in a register needed by an earlier reload with a tighter constraint.  	 To solve this, we make two passes over the reloads, in the order 	 described above.  In the first pass we try to inherit a reload 	 from a previous insn.  If there is a later reload that needs a 	 class that is a proper subset of the class being processed, we must 	 also allocate a spill register during the first pass.  	 Then make a second pass over the reloads to allocate any reloads 	 that haven't been given registers yet.  */
name|CLEAR_HARD_REG_SET
argument_list|(
name|reload_reg_used_for_inherit
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_reloads
condition|;
name|j
operator|++
control|)
block|{
specifier|register
name|int
name|r
init|=
name|reload_order
index|[
name|j
index|]
decl_stmt|;
name|rtx
name|search_equiv
init|=
name|NULL_RTX
decl_stmt|;
comment|/* Ignore reloads that got marked inoperative.  */
if|if
condition|(
name|reload_out
index|[
name|r
index|]
operator|==
literal|0
operator|&&
name|reload_in
index|[
name|r
index|]
operator|==
literal|0
operator|&&
operator|!
name|reload_secondary_p
index|[
name|r
index|]
condition|)
continue|continue;
comment|/* If find_reloads chose to use reload_in or reload_out as a reload 	     register, we don't need to chose one.  Otherwise, try even if it 	     found one since we might save an insn if we find the value lying 	     around. 	     Try also when reload_in is a pseudo without a hard reg.  */
if|if
condition|(
name|reload_in
index|[
name|r
index|]
operator|!=
literal|0
operator|&&
name|reload_reg_rtx
index|[
name|r
index|]
operator|!=
literal|0
operator|&&
operator|(
name|rtx_equal_p
argument_list|(
name|reload_in
index|[
name|r
index|]
argument_list|,
name|reload_reg_rtx
index|[
name|r
index|]
argument_list|)
operator|||
operator|(
name|rtx_equal_p
argument_list|(
name|reload_out
index|[
name|r
index|]
argument_list|,
name|reload_reg_rtx
index|[
name|r
index|]
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|reload_in
index|[
name|r
index|]
argument_list|)
operator|!=
name|MEM
operator|&&
name|true_regnum
argument_list|(
name|reload_in
index|[
name|r
index|]
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
operator|)
condition|)
continue|continue;
if|#
directive|if
literal|0
comment|/* No longer needed for correct operation. 	 It might give better code, or might not; worth an experiment?  */
comment|/* If this is an optional reload, we can't inherit from earlier insns 	     until we are sure that any non-optional reloads have been allocated. 	     The following code takes advantage of the fact that optional reloads 	     are at the end of reload_order.  */
block|if (reload_optional[r] != 0) 	    for (i = 0; i< j; i++) 	      if ((reload_out[reload_order[i]] != 0 		   || reload_in[reload_order[i]] != 0 		   || reload_secondary_p[reload_order[i]])&& ! reload_optional[reload_order[i]]&& reload_reg_rtx[reload_order[i]] == 0) 		allocate_reload_reg (chain, reload_order[i], 0, inheritance);
endif|#
directive|endif
comment|/* First see if this pseudo is already available as reloaded 	     for a previous insn.  We cannot try to inherit for reloads 	     that are smaller than the maximum number of registers needed 	     for groups unless the register we would allocate cannot be used 	     for the groups.  	     We could check here to see if this is a secondary reload for 	     an object that is already in a register of the desired class. 	     This would avoid the need for the secondary reload register. 	     But this is complex because we can't easily determine what 	     objects might want to be loaded via this reload.  So let a 	     register be allocated here.  In `emit_reload_insns' we suppress 	     one of the loads in the case described above.  */
if|if
condition|(
name|inheritance
condition|)
block|{
name|int
name|word
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|regno
init|=
operator|-
literal|1
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
if|if
condition|(
name|reload_in
index|[
name|r
index|]
operator|==
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|reload_in
index|[
name|r
index|]
argument_list|)
operator|==
name|REG
condition|)
block|{
name|regno
operator|=
name|REGNO
argument_list|(
name|reload_in
index|[
name|r
index|]
argument_list|)
expr_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|reload_in
index|[
name|r
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|reload_in_reg
index|[
name|r
index|]
argument_list|)
operator|==
name|REG
condition|)
block|{
name|regno
operator|=
name|REGNO
argument_list|(
name|reload_in_reg
index|[
name|r
index|]
argument_list|)
expr_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|reload_in_reg
index|[
name|r
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|reload_in_reg
index|[
name|r
index|]
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|reload_in_reg
index|[
name|r
index|]
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|word
operator|=
name|SUBREG_WORD
argument_list|(
name|reload_in_reg
index|[
name|r
index|]
argument_list|)
expr_stmt|;
name|regno
operator|=
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|reload_in_reg
index|[
name|r
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|regno
operator|+=
name|word
expr_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|reload_in_reg
index|[
name|r
index|]
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
elseif|else
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|reload_in_reg
index|[
name|r
index|]
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|reload_in_reg
index|[
name|r
index|]
argument_list|)
operator|==
name|PRE_DEC
operator|||
name|GET_CODE
argument_list|(
name|reload_in_reg
index|[
name|r
index|]
argument_list|)
operator|==
name|POST_INC
operator|||
name|GET_CODE
argument_list|(
name|reload_in_reg
index|[
name|r
index|]
argument_list|)
operator|==
name|POST_DEC
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|reload_in_reg
index|[
name|r
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|regno
operator|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|reload_in_reg
index|[
name|r
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|reload_in_reg
index|[
name|r
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|reload_out
index|[
name|r
index|]
operator|=
name|reload_in
index|[
name|r
index|]
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* This won't work, since REGNO can be a pseudo reg number. 		 Also, it takes much more hair to keep track of all the things 		 that can invalidate an inherited reload of part of a pseudoreg.  */
block|else if (GET_CODE (reload_in[r]) == SUBREG&& GET_CODE (SUBREG_REG (reload_in[r])) == REG) 		regno = REGNO (SUBREG_REG (reload_in[r])) + SUBREG_WORD (reload_in[r]);
endif|#
directive|endif
if|if
condition|(
name|regno
operator|>=
literal|0
operator|&&
name|reg_last_reload_reg
index|[
name|regno
index|]
operator|!=
literal|0
condition|)
block|{
name|enum
name|reg_class
name|class
init|=
name|reload_reg_class
index|[
name|r
index|]
decl_stmt|,
name|last_class
decl_stmt|;
name|rtx
name|last_reg
init|=
name|reg_last_reload_reg
index|[
name|regno
index|]
decl_stmt|;
name|i
operator|=
name|REGNO
argument_list|(
name|last_reg
argument_list|)
operator|+
name|word
expr_stmt|;
name|last_class
operator|=
name|REGNO_REG_CLASS
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|last_reg
argument_list|)
argument_list|)
operator|>=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|+
name|word
operator|*
name|UNITS_PER_WORD
operator|)
operator|&&
name|reg_reloaded_contents
index|[
name|i
index|]
operator|==
name|regno
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_reloaded_valid
argument_list|,
name|i
argument_list|)
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|i
argument_list|,
name|reload_mode
index|[
name|r
index|]
argument_list|)
operator|&&
operator|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|class
index|]
argument_list|,
name|i
argument_list|)
comment|/* Even if we can't use this register as a reload 			     register, we might use it for reload_override_in, 			     if copying it to the desired class is cheap 			     enough.  */
operator|||
operator|(
operator|(
name|REGISTER_MOVE_COST
argument_list|(
name|last_class
argument_list|,
name|class
argument_list|)
operator|<
name|MEMORY_MOVE_COST
argument_list|(
name|mode
argument_list|,
name|class
argument_list|,
literal|1
argument_list|)
operator|)
ifdef|#
directive|ifdef
name|SECONDARY_INPUT_RELOAD_CLASS
operator|&&
operator|(
name|SECONDARY_INPUT_RELOAD_CLASS
argument_list|(
name|class
argument_list|,
name|mode
argument_list|,
name|last_reg
argument_list|)
operator|==
name|NO_REGS
operator|)
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SECONDARY_MEMORY_NEEDED
operator|&&
operator|!
name|SECONDARY_MEMORY_NEEDED
argument_list|(
name|last_class
argument_list|,
name|class
argument_list|,
name|mode
argument_list|)
endif|#
directive|endif
operator|)
operator|)
operator|&&
operator|(
name|reload_nregs
index|[
name|r
index|]
operator|==
name|max_group_size
operator|||
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|group_class
index|]
argument_list|,
name|i
argument_list|)
operator|)
operator|&&
name|reload_reg_free_for_value_p
argument_list|(
name|i
argument_list|,
name|reload_opnum
index|[
name|r
index|]
argument_list|,
name|reload_when_needed
index|[
name|r
index|]
argument_list|,
name|reload_in
index|[
name|r
index|]
argument_list|,
name|const0_rtx
argument_list|,
name|r
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|/* If a group is needed, verify that all the subsequent 			 registers still have their values intact.  */
name|int
name|nr
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|i
argument_list|,
name|reload_mode
index|[
name|r
index|]
argument_list|)
decl_stmt|;
name|int
name|k
decl_stmt|;
for|for
control|(
name|k
operator|=
literal|1
init|;
name|k
operator|<
name|nr
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|reg_reloaded_contents
index|[
name|i
operator|+
name|k
index|]
operator|!=
name|regno
operator|||
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_reloaded_valid
argument_list|,
name|i
operator|+
name|k
argument_list|)
condition|)
break|break;
if|if
condition|(
name|k
operator|==
name|nr
condition|)
block|{
name|int
name|i1
decl_stmt|;
name|last_reg
operator|=
operator|(
name|GET_MODE
argument_list|(
name|last_reg
argument_list|)
operator|==
name|mode
condition|?
name|last_reg
else|:
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|i
argument_list|)
operator|)
expr_stmt|;
comment|/* We found a register that contains the 			     value we need.  If this register is the 			     same as an `earlyclobber' operand of the 			     current insn, just mark it as a place to 			     reload from since we can't use it as the 			     reload register itself.  */
for|for
control|(
name|i1
operator|=
literal|0
init|;
name|i1
operator|<
name|n_earlyclobbers
condition|;
name|i1
operator|++
control|)
if|if
condition|(
name|reg_overlap_mentioned_for_reload_p
argument_list|(
name|reg_last_reload_reg
index|[
name|regno
index|]
argument_list|,
name|reload_earlyclobbers
index|[
name|i1
index|]
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i1
operator|!=
name|n_earlyclobbers
operator|||
operator|!
operator|(
name|reload_reg_free_for_value_p
argument_list|(
name|i
argument_list|,
name|reload_opnum
index|[
name|r
index|]
argument_list|,
name|reload_when_needed
index|[
name|r
index|]
argument_list|,
name|reload_in
index|[
name|r
index|]
argument_list|,
name|reload_out
index|[
name|r
index|]
argument_list|,
name|r
argument_list|,
literal|1
argument_list|)
operator|)
comment|/* Don't use it if we'd clobber a pseudo reg.  */
operator|||
operator|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_used_in_insn
argument_list|,
name|i
argument_list|)
operator|&&
name|reload_out
index|[
name|r
index|]
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_reloaded_dead
argument_list|,
name|i
argument_list|)
operator|)
comment|/* Don't clobber the frame pointer.  */
operator|||
operator|(
name|i
operator|==
name|HARD_FRAME_POINTER_REGNUM
operator|&&
name|reload_out
index|[
name|r
index|]
operator|)
comment|/* Don't really use the inherited spill reg 				 if we need it wider than we've got it.  */
operator|||
operator|(
name|GET_MODE_SIZE
argument_list|(
name|reload_mode
index|[
name|r
index|]
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|)
operator|||
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|reload_reg_class
index|[
name|r
index|]
index|]
argument_list|,
name|i
argument_list|)
comment|/* If find_reloads chose reload_out as reload 				 register, stay with it - that leaves the 				 inherited register for subsequent reloads.  */
operator|||
operator|(
name|reload_out
index|[
name|r
index|]
operator|&&
name|reload_reg_rtx
index|[
name|r
index|]
operator|&&
name|rtx_equal_p
argument_list|(
name|reload_out
index|[
name|r
index|]
argument_list|,
name|reload_reg_rtx
index|[
name|r
index|]
argument_list|)
operator|)
condition|)
block|{
name|reload_override_in
index|[
name|r
index|]
operator|=
name|last_reg
expr_stmt|;
name|reload_inheritance_insn
index|[
name|r
index|]
operator|=
name|reg_reloaded_insn
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
name|int
name|k
decl_stmt|;
comment|/* We can use this as a reload reg.  */
comment|/* Mark the register as in use for this part of 				 the insn.  */
name|mark_reload_reg_in_use
argument_list|(
name|i
argument_list|,
name|reload_opnum
index|[
name|r
index|]
argument_list|,
name|reload_when_needed
index|[
name|r
index|]
argument_list|,
name|reload_mode
index|[
name|r
index|]
argument_list|)
expr_stmt|;
name|reload_reg_rtx
index|[
name|r
index|]
operator|=
name|last_reg
expr_stmt|;
name|reload_inherited
index|[
name|r
index|]
operator|=
literal|1
expr_stmt|;
name|reload_inheritance_insn
index|[
name|r
index|]
operator|=
name|reg_reloaded_insn
index|[
name|i
index|]
expr_stmt|;
name|reload_spill_index
index|[
name|r
index|]
operator|=
name|i
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|nr
condition|;
name|k
operator|++
control|)
name|SET_HARD_REG_BIT
argument_list|(
name|reload_reg_used_for_inherit
argument_list|,
name|i
operator|+
name|k
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/* Here's another way to see if the value is already lying around.  */
if|if
condition|(
name|inheritance
operator|&&
name|reload_in
index|[
name|r
index|]
operator|!=
literal|0
operator|&&
operator|!
name|reload_inherited
index|[
name|r
index|]
operator|&&
name|reload_out
index|[
name|r
index|]
operator|==
literal|0
operator|&&
operator|(
name|CONSTANT_P
argument_list|(
name|reload_in
index|[
name|r
index|]
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|reload_in
index|[
name|r
index|]
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|reload_in
index|[
name|r
index|]
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|reload_in
index|[
name|r
index|]
argument_list|)
operator|==
name|MEM
operator|)
operator|&&
operator|(
name|reload_nregs
index|[
name|r
index|]
operator|==
name|max_group_size
operator|||
operator|!
name|reg_classes_intersect_p
argument_list|(
name|reload_reg_class
index|[
name|r
index|]
argument_list|,
name|group_class
argument_list|)
operator|)
condition|)
name|search_equiv
operator|=
name|reload_in
index|[
name|r
index|]
expr_stmt|;
comment|/* If this is an output reload from a simple move insn, look 	     if an equivalence for the input is available.  */
elseif|else
if|if
condition|(
name|inheritance
operator|&&
name|reload_in
index|[
name|r
index|]
operator|==
literal|0
operator|&&
name|reload_out
index|[
name|r
index|]
operator|!=
literal|0
condition|)
block|{
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|set
operator|&&
name|rtx_equal_p
argument_list|(
name|reload_out
index|[
name|r
index|]
argument_list|,
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|&&
name|CONSTANT_P
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
condition|)
name|search_equiv
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|search_equiv
condition|)
block|{
specifier|register
name|rtx
name|equiv
init|=
name|find_equiv_reg
argument_list|(
name|search_equiv
argument_list|,
name|insn
argument_list|,
name|reload_reg_class
index|[
name|r
index|]
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL_PTR
argument_list|,
literal|0
argument_list|,
name|reload_mode
index|[
name|r
index|]
argument_list|)
decl_stmt|;
name|int
name|regno
decl_stmt|;
if|if
condition|(
name|equiv
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|equiv
argument_list|)
operator|==
name|REG
condition|)
name|regno
operator|=
name|REGNO
argument_list|(
name|equiv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|equiv
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
comment|/* This must be a SUBREG of a hard register. 			 Make a new REG since this might be used in an 			 address and not all machines support SUBREGs 			 there.  */
name|regno
operator|=
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|equiv
argument_list|)
argument_list|)
operator|+
name|SUBREG_WORD
argument_list|(
name|equiv
argument_list|)
expr_stmt|;
name|equiv
operator|=
name|gen_rtx_REG
argument_list|(
name|reload_mode
index|[
name|r
index|]
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* If we found a spill reg, reject it unless it is free 		 and of the desired class.  */
if|if
condition|(
name|equiv
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_at_all
argument_list|,
name|regno
argument_list|)
operator|&&
operator|!
name|reload_reg_free_for_value_p
argument_list|(
name|regno
argument_list|,
name|reload_opnum
index|[
name|r
index|]
argument_list|,
name|reload_when_needed
index|[
name|r
index|]
argument_list|,
name|reload_in
index|[
name|r
index|]
argument_list|,
name|reload_out
index|[
name|r
index|]
argument_list|,
name|r
argument_list|,
literal|1
argument_list|)
operator|)
operator|||
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|reload_reg_class
index|[
name|r
index|]
index|]
argument_list|,
name|regno
argument_list|)
operator|)
condition|)
name|equiv
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|equiv
operator|!=
literal|0
operator|&&
operator|!
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|reload_mode
index|[
name|r
index|]
argument_list|)
condition|)
name|equiv
operator|=
literal|0
expr_stmt|;
comment|/* We found a register that contains the value we need. 		 If this register is the same as an `earlyclobber' operand 		 of the current insn, just mark it as a place to reload from 		 since we can't use it as the reload register itself.  */
if|if
condition|(
name|equiv
operator|!=
literal|0
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_earlyclobbers
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reg_overlap_mentioned_for_reload_p
argument_list|(
name|equiv
argument_list|,
name|reload_earlyclobbers
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|reload_override_in
index|[
name|r
index|]
operator|=
name|equiv
expr_stmt|;
name|equiv
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* If the equiv register we have found is explicitly clobbered 		 in the current insn, it depends on the reload type if we 		 can use it, use it for reload_override_in, or not at all. 		 In particular, we then can't use EQUIV for a 		 RELOAD_FOR_OUTPUT_ADDRESS reload.  */
if|if
condition|(
name|equiv
operator|!=
literal|0
operator|&&
name|regno_clobbered_p
argument_list|(
name|regno
argument_list|,
name|insn
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|reload_when_needed
index|[
name|r
index|]
condition|)
block|{
case|case
name|RELOAD_FOR_OTHER_ADDRESS
case|:
case|case
name|RELOAD_FOR_INPADDR_ADDRESS
case|:
case|case
name|RELOAD_FOR_INPUT_ADDRESS
case|:
case|case
name|RELOAD_FOR_OPADDR_ADDR
case|:
break|break;
case|case
name|RELOAD_OTHER
case|:
case|case
name|RELOAD_FOR_INPUT
case|:
case|case
name|RELOAD_FOR_OPERAND_ADDRESS
case|:
name|reload_override_in
index|[
name|r
index|]
operator|=
name|equiv
expr_stmt|;
comment|/* Fall through. */
default|default:
name|equiv
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
comment|/* If we found an equivalent reg, say no code need be generated 		 to load it, and use it as our reload reg.  */
if|if
condition|(
name|equiv
operator|!=
literal|0
operator|&&
name|regno
operator|!=
name|HARD_FRAME_POINTER_REGNUM
condition|)
block|{
name|int
name|nr
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|reload_mode
index|[
name|r
index|]
argument_list|)
decl_stmt|;
name|int
name|k
decl_stmt|;
name|reload_reg_rtx
index|[
name|r
index|]
operator|=
name|equiv
expr_stmt|;
name|reload_inherited
index|[
name|r
index|]
operator|=
literal|1
expr_stmt|;
comment|/* If reg_reloaded_valid is not set for this register, 		     there might be a stale spill_reg_store lying around. 		     We must clear it, since otherwise emit_reload_insns 		     might delete the store.  */
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_reloaded_valid
argument_list|,
name|regno
argument_list|)
condition|)
name|spill_reg_store
index|[
name|regno
index|]
operator|=
name|NULL_RTX
expr_stmt|;
comment|/* If any of the hard registers in EQUIV are spill 		     registers, mark them as in use for this insn.  */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|nr
condition|;
name|k
operator|++
control|)
block|{
name|i
operator|=
name|spill_reg_order
index|[
name|regno
operator|+
name|k
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
name|mark_reload_reg_in_use
argument_list|(
name|regno
argument_list|,
name|reload_opnum
index|[
name|r
index|]
argument_list|,
name|reload_when_needed
index|[
name|r
index|]
argument_list|,
name|reload_mode
index|[
name|r
index|]
argument_list|)
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|reload_reg_used_for_inherit
argument_list|,
name|regno
operator|+
name|k
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* If we found a register to use already, or if this is an optional 	     reload, we are done.  */
if|if
condition|(
name|reload_reg_rtx
index|[
name|r
index|]
operator|!=
literal|0
operator|||
name|reload_optional
index|[
name|r
index|]
operator|!=
literal|0
condition|)
continue|continue;
if|#
directive|if
literal|0
comment|/* No longer needed for correct operation.  Might or might not 	 give better code on the average.  Want to experiment?  */
comment|/* See if there is a later reload that has a class different from our 	     class that intersects our class or that requires less register 	     than our reload.  If so, we must allocate a register to this 	     reload now, since that reload might inherit a previous reload 	     and take the only available register in our class.  Don't do this 	     for optional reloads since they will force all previous reloads 	     to be allocated.  Also don't do this for reloads that have been 	     turned off.  */
block|for (i = j + 1; i< n_reloads; i++) 	    { 	      int s = reload_order[i];  	      if ((reload_in[s] == 0&& reload_out[s] == 0&& ! reload_secondary_p[s]) 		  || reload_optional[s]) 		continue;  	      if ((reload_reg_class[s] != reload_reg_class[r]&& reg_classes_intersect_p (reload_reg_class[r], 					       reload_reg_class[s])) 		  || reload_nregs[s]< reload_nregs[r]) 	      break; 	    }  	  if (i == n_reloads) 	    continue;  	  allocate_reload_reg (chain, r, j == n_reloads - 1, inheritance);
endif|#
directive|endif
block|}
comment|/* Now allocate reload registers for anything non-optional that 	 didn't get one yet.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_reloads
condition|;
name|j
operator|++
control|)
block|{
specifier|register
name|int
name|r
init|=
name|reload_order
index|[
name|j
index|]
decl_stmt|;
comment|/* Ignore reloads that got marked inoperative.  */
if|if
condition|(
name|reload_out
index|[
name|r
index|]
operator|==
literal|0
operator|&&
name|reload_in
index|[
name|r
index|]
operator|==
literal|0
operator|&&
operator|!
name|reload_secondary_p
index|[
name|r
index|]
condition|)
continue|continue;
comment|/* Skip reloads that already have a register allocated or are 	     optional.  */
if|if
condition|(
name|reload_reg_rtx
index|[
name|r
index|]
operator|!=
literal|0
operator|||
name|reload_optional
index|[
name|r
index|]
condition|)
continue|continue;
if|if
condition|(
operator|!
name|allocate_reload_reg
argument_list|(
name|chain
argument_list|,
name|r
argument_list|,
name|j
operator|==
name|n_reloads
operator|-
literal|1
argument_list|,
name|inheritance
argument_list|)
condition|)
break|break;
block|}
comment|/* If that loop got all the way, we have won.  */
if|if
condition|(
name|j
operator|==
name|n_reloads
condition|)
break|break;
comment|/* Loop around and try without any inheritance.  */
comment|/* First undo everything done by the failed attempt 	 to allocate with inheritance.  */
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|save_reload_reg_rtx
argument_list|,
operator|(
name|char
operator|*
operator|)
name|reload_reg_rtx
argument_list|,
sizeof|sizeof
name|reload_reg_rtx
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|save_reload_inherited
argument_list|,
operator|(
name|char
operator|*
operator|)
name|reload_inherited
argument_list|,
sizeof|sizeof
name|reload_inherited
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|save_reload_inheritance_insn
argument_list|,
operator|(
name|char
operator|*
operator|)
name|reload_inheritance_insn
argument_list|,
sizeof|sizeof
name|reload_inheritance_insn
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|save_reload_override_in
argument_list|,
operator|(
name|char
operator|*
operator|)
name|reload_override_in
argument_list|,
sizeof|sizeof
name|reload_override_in
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|save_reload_spill_index
argument_list|,
operator|(
name|char
operator|*
operator|)
name|reload_spill_index
argument_list|,
sizeof|sizeof
name|reload_spill_index
argument_list|)
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|reload_reg_used
argument_list|,
name|save_reload_reg_used
argument_list|)
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|reload_reg_used_at_all
argument_list|,
name|save_reload_reg_used_at_all
argument_list|)
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|reload_reg_used_in_op_addr
argument_list|,
name|save_reload_reg_used_in_op_addr
argument_list|)
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|reload_reg_used_in_op_addr_reload
argument_list|,
name|save_reload_reg_used_in_op_addr_reload
argument_list|)
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|reload_reg_used_in_insn
argument_list|,
name|save_reload_reg_used_in_insn
argument_list|)
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|reload_reg_used_in_other_addr
argument_list|,
name|save_reload_reg_used_in_other_addr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reload_n_operands
condition|;
name|i
operator|++
control|)
block|{
name|COPY_HARD_REG_SET
argument_list|(
name|reload_reg_used_in_input
index|[
name|i
index|]
argument_list|,
name|save_reload_reg_used_in_input
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|reload_reg_used_in_output
index|[
name|i
index|]
argument_list|,
name|save_reload_reg_used_in_output
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|reload_reg_used_in_input_addr
index|[
name|i
index|]
argument_list|,
name|save_reload_reg_used_in_input_addr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|reload_reg_used_in_inpaddr_addr
index|[
name|i
index|]
argument_list|,
name|save_reload_reg_used_in_inpaddr_addr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|reload_reg_used_in_output_addr
index|[
name|i
index|]
argument_list|,
name|save_reload_reg_used_in_output_addr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|reload_reg_used_in_outaddr_addr
index|[
name|i
index|]
argument_list|,
name|save_reload_reg_used_in_outaddr_addr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If we thought we could inherit a reload, because it seemed that      nothing else wanted the same reload register earlier in the insn,      verify that assumption, now that all reloads have been assigned.      Likewise for reloads where reload_override_in has been set.  */
comment|/* If doing expensive optimizations, do one preliminary pass that doesn't      cancel any inheritance, but removes reloads that have been needed only      for reloads that we know can be inherited.  */
for|for
control|(
name|pass
operator|=
name|flag_expensive_optimizations
init|;
name|pass
operator|>=
literal|0
condition|;
name|pass
operator|--
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_reloads
condition|;
name|j
operator|++
control|)
block|{
specifier|register
name|int
name|r
init|=
name|reload_order
index|[
name|j
index|]
decl_stmt|;
name|rtx
name|check_reg
decl_stmt|;
if|if
condition|(
name|reload_inherited
index|[
name|r
index|]
operator|&&
name|reload_reg_rtx
index|[
name|r
index|]
condition|)
name|check_reg
operator|=
name|reload_reg_rtx
index|[
name|r
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|reload_override_in
index|[
name|r
index|]
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|reload_override_in
index|[
name|r
index|]
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|reload_override_in
index|[
name|r
index|]
argument_list|)
operator|==
name|SUBREG
operator|)
condition|)
name|check_reg
operator|=
name|reload_override_in
index|[
name|r
index|]
expr_stmt|;
else|else
continue|continue;
if|if
condition|(
operator|!
name|reload_reg_free_for_value_p
argument_list|(
name|true_regnum
argument_list|(
name|check_reg
argument_list|)
argument_list|,
name|reload_opnum
index|[
name|r
index|]
argument_list|,
name|reload_when_needed
index|[
name|r
index|]
argument_list|,
name|reload_in
index|[
name|r
index|]
argument_list|,
operator|(
name|reload_inherited
index|[
name|r
index|]
condition|?
name|reload_out
index|[
name|r
index|]
else|:
name|const0_rtx
operator|)
argument_list|,
name|r
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|pass
condition|)
continue|continue;
name|reload_inherited
index|[
name|r
index|]
operator|=
literal|0
expr_stmt|;
name|reload_override_in
index|[
name|r
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If we can inherit a RELOAD_FOR_INPUT, or can use a 	     reload_override_in, then we do not need its related 	     RELOAD_FOR_INPUT_ADDRESS / RELOAD_FOR_INPADDR_ADDRESS reloads; 	     likewise for other reload types. 	     We handle this by removing a reload when its only replacement 	     is mentioned in reload_in of the reload we are going to inherit. 	     A special case are auto_inc expressions; even if the input is 	     inherited, we still need the address for the output.  We can 	     recognize them because they have RELOAD_OUT set but not 	     RELOAD_OUT_REG. 	     If we suceeded removing some reload and we are doing a preliminary 	     pass just to remove such reloads, make another pass, since the 	     removal of one reload might allow us to inherit another one.  */
elseif|else
if|if
condition|(
operator|(
operator|!
name|reload_out
index|[
name|r
index|]
operator|||
name|reload_out_reg
index|[
name|r
index|]
operator|)
operator|&&
name|reload_in
index|[
name|r
index|]
operator|&&
name|remove_address_replacements
argument_list|(
name|reload_in
index|[
name|r
index|]
argument_list|)
operator|&&
name|pass
condition|)
name|pass
operator|=
literal|2
expr_stmt|;
block|}
block|}
comment|/* Now that reload_override_in is known valid,      actually override reload_in.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_reloads
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|reload_override_in
index|[
name|j
index|]
condition|)
name|reload_in
index|[
name|j
index|]
operator|=
name|reload_override_in
index|[
name|j
index|]
expr_stmt|;
comment|/* If this reload won't be done because it has been cancelled or is      optional and not inherited, clear reload_reg_rtx so other      routines (such as subst_reloads) don't get confused.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_reloads
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|reload_reg_rtx
index|[
name|j
index|]
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|reload_optional
index|[
name|j
index|]
operator|&&
operator|!
name|reload_inherited
index|[
name|j
index|]
operator|)
operator|||
operator|(
name|reload_in
index|[
name|j
index|]
operator|==
literal|0
operator|&&
name|reload_out
index|[
name|j
index|]
operator|==
literal|0
operator|&&
operator|!
name|reload_secondary_p
index|[
name|j
index|]
operator|)
operator|)
condition|)
block|{
name|int
name|regno
init|=
name|true_regnum
argument_list|(
name|reload_reg_rtx
index|[
name|j
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|spill_reg_order
index|[
name|regno
index|]
operator|>=
literal|0
condition|)
name|clear_reload_reg_in_use
argument_list|(
name|regno
argument_list|,
name|reload_opnum
index|[
name|j
index|]
argument_list|,
name|reload_when_needed
index|[
name|j
index|]
argument_list|,
name|reload_mode
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|reload_reg_rtx
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Record which pseudos and which spill regs have output reloads.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_reloads
condition|;
name|j
operator|++
control|)
block|{
specifier|register
name|int
name|r
init|=
name|reload_order
index|[
name|j
index|]
decl_stmt|;
name|i
operator|=
name|reload_spill_index
index|[
name|r
index|]
expr_stmt|;
comment|/* I is nonneg if this reload uses a register. 	 If reload_reg_rtx[r] is 0, this is an optional reload 	 that we opted to ignore.  */
if|if
condition|(
name|reload_out_reg
index|[
name|r
index|]
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|reload_out_reg
index|[
name|r
index|]
argument_list|)
operator|==
name|REG
operator|&&
name|reload_reg_rtx
index|[
name|r
index|]
operator|!=
literal|0
condition|)
block|{
specifier|register
name|int
name|nregno
init|=
name|REGNO
argument_list|(
name|reload_out_reg
index|[
name|r
index|]
argument_list|)
decl_stmt|;
name|int
name|nr
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|nregno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|nr
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|nregno
argument_list|,
name|reload_mode
index|[
name|r
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|nr
operator|>=
literal|0
condition|)
name|reg_has_output_reload
index|[
name|nregno
operator|+
name|nr
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
name|nr
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|i
argument_list|,
name|reload_mode
index|[
name|r
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|nr
operator|>=
literal|0
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|reg_is_output_reload
argument_list|,
name|i
operator|+
name|nr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reload_when_needed
index|[
name|r
index|]
operator|!=
name|RELOAD_OTHER
operator|&&
name|reload_when_needed
index|[
name|r
index|]
operator|!=
name|RELOAD_FOR_OUTPUT
operator|&&
name|reload_when_needed
index|[
name|r
index|]
operator|!=
name|RELOAD_FOR_INSN
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Deallocate the reload register for reload R.  This is called from    remove_address_replacements.  */
end_comment

begin_function
name|void
name|deallocate_reload_reg
parameter_list|(
name|r
parameter_list|)
name|int
name|r
decl_stmt|;
block|{
name|int
name|regno
decl_stmt|;
if|if
condition|(
operator|!
name|reload_reg_rtx
index|[
name|r
index|]
condition|)
return|return;
name|regno
operator|=
name|true_regnum
argument_list|(
name|reload_reg_rtx
index|[
name|r
index|]
argument_list|)
expr_stmt|;
name|reload_reg_rtx
index|[
name|r
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|spill_reg_order
index|[
name|regno
index|]
operator|>=
literal|0
condition|)
name|clear_reload_reg_in_use
argument_list|(
name|regno
argument_list|,
name|reload_opnum
index|[
name|r
index|]
argument_list|,
name|reload_when_needed
index|[
name|r
index|]
argument_list|,
name|reload_mode
index|[
name|r
index|]
argument_list|)
expr_stmt|;
name|reload_spill_index
index|[
name|r
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If SMALL_REGISTER_CLASSES is non-zero, we may not have merged two    reloads of the same item for fear that we might not have enough reload    registers. However, normally they will get the same reload register    and hence actually need not be loaded twice.       Here we check for the most common case of this phenomenon: when we have    a number of reloads for the same object, each of which were allocated    the same reload_reg_rtx, that reload_reg_rtx is not used for any other    reload, and is not modified in the insn itself.  If we find such,    merge all the reloads and set the resulting reload to RELOAD_OTHER.    This will not increase the number of spill registers needed and will    prevent redundant code.  */
end_comment

begin_function
specifier|static
name|void
name|merge_assigned_reloads
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* Scan all the reloads looking for ones that only load values and      are not already RELOAD_OTHER and ones whose reload_reg_rtx are      assigned and not modified by INSN.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_reloads
condition|;
name|i
operator|++
control|)
block|{
name|int
name|conflicting_input
init|=
literal|0
decl_stmt|;
name|int
name|max_input_address_opnum
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|min_conflicting_input_opnum
init|=
name|MAX_RECOG_OPERANDS
decl_stmt|;
if|if
condition|(
name|reload_in
index|[
name|i
index|]
operator|==
literal|0
operator|||
name|reload_when_needed
index|[
name|i
index|]
operator|==
name|RELOAD_OTHER
operator|||
name|reload_out
index|[
name|i
index|]
operator|!=
literal|0
operator|||
name|reload_reg_rtx
index|[
name|i
index|]
operator|==
literal|0
operator|||
name|reg_set_p
argument_list|(
name|reload_reg_rtx
index|[
name|i
index|]
argument_list|,
name|insn
argument_list|)
condition|)
continue|continue;
comment|/* Look at all other reloads.  Ensure that the only use of this 	 reload_reg_rtx is in a reload that just loads the same value 	 as we do.  Note that any secondary reloads must be of the identical 	 class since the values, modes, and result registers are the 	 same, so we need not do anything with any secondary reloads.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_reloads
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|j
operator|||
name|reload_reg_rtx
index|[
name|j
index|]
operator|==
literal|0
operator|||
operator|!
name|reg_overlap_mentioned_p
argument_list|(
name|reload_reg_rtx
index|[
name|j
index|]
argument_list|,
name|reload_reg_rtx
index|[
name|i
index|]
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|reload_when_needed
index|[
name|j
index|]
operator|==
name|RELOAD_FOR_INPUT_ADDRESS
operator|&&
name|reload_opnum
index|[
name|j
index|]
operator|>
name|max_input_address_opnum
condition|)
name|max_input_address_opnum
operator|=
name|reload_opnum
index|[
name|j
index|]
expr_stmt|;
comment|/* If the reload regs aren't exactly the same (e.g, different modes) 	     or if the values are different, we can't merge this reload. 	     But if it is an input reload, we might still merge 	     RELOAD_FOR_INPUT_ADDRESS and RELOAD_FOR_OTHER_ADDRESS reloads.  */
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|reload_reg_rtx
index|[
name|i
index|]
argument_list|,
name|reload_reg_rtx
index|[
name|j
index|]
argument_list|)
operator|||
name|reload_out
index|[
name|j
index|]
operator|!=
literal|0
operator|||
name|reload_in
index|[
name|j
index|]
operator|==
literal|0
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|reload_in
index|[
name|i
index|]
argument_list|,
name|reload_in
index|[
name|j
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|reload_when_needed
index|[
name|j
index|]
operator|!=
name|RELOAD_FOR_INPUT
operator|||
operator|(
operator|(
name|reload_when_needed
index|[
name|i
index|]
operator|!=
name|RELOAD_FOR_INPUT_ADDRESS
operator|||
name|reload_opnum
index|[
name|i
index|]
operator|>
name|reload_opnum
index|[
name|j
index|]
operator|)
operator|&&
name|reload_when_needed
index|[
name|i
index|]
operator|!=
name|RELOAD_FOR_OTHER_ADDRESS
operator|)
condition|)
break|break;
name|conflicting_input
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|min_conflicting_input_opnum
operator|>
name|reload_opnum
index|[
name|j
index|]
condition|)
name|min_conflicting_input_opnum
operator|=
name|reload_opnum
index|[
name|j
index|]
expr_stmt|;
block|}
block|}
comment|/* If all is OK, merge the reloads.  Only set this to RELOAD_OTHER if 	 we, in fact, found any matching reloads.  */
if|if
condition|(
name|j
operator|==
name|n_reloads
operator|&&
name|max_input_address_opnum
operator|<=
name|min_conflicting_input_opnum
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_reloads
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|i
operator|!=
name|j
operator|&&
name|reload_reg_rtx
index|[
name|j
index|]
operator|!=
literal|0
operator|&&
name|rtx_equal_p
argument_list|(
name|reload_reg_rtx
index|[
name|i
index|]
argument_list|,
name|reload_reg_rtx
index|[
name|j
index|]
argument_list|)
operator|&&
operator|(
operator|!
name|conflicting_input
operator|||
name|reload_when_needed
index|[
name|j
index|]
operator|==
name|RELOAD_FOR_INPUT_ADDRESS
operator|||
name|reload_when_needed
index|[
name|j
index|]
operator|==
name|RELOAD_FOR_OTHER_ADDRESS
operator|)
condition|)
block|{
name|reload_when_needed
index|[
name|i
index|]
operator|=
name|RELOAD_OTHER
expr_stmt|;
name|reload_in
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
name|reload_spill_index
index|[
name|j
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|transfer_replacements
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
comment|/* If this is now RELOAD_OTHER, look for any reloads that load 	     parts of this operand and set them to RELOAD_FOR_OTHER_ADDRESS 	     if they were for inputs, RELOAD_OTHER for outputs.  Note that 	     this test is equivalent to looking for reloads for this operand 	     number.  */
if|if
condition|(
name|reload_when_needed
index|[
name|i
index|]
operator|==
name|RELOAD_OTHER
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_reloads
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|reload_in
index|[
name|j
index|]
operator|!=
literal|0
operator|&&
name|reload_when_needed
index|[
name|i
index|]
operator|!=
name|RELOAD_OTHER
operator|&&
name|reg_overlap_mentioned_for_reload_p
argument_list|(
name|reload_in
index|[
name|j
index|]
argument_list|,
name|reload_in
index|[
name|i
index|]
argument_list|)
condition|)
name|reload_when_needed
index|[
name|j
index|]
operator|=
operator|(
operator|(
name|reload_when_needed
index|[
name|i
index|]
operator|==
name|RELOAD_FOR_INPUT_ADDRESS
operator|||
name|reload_when_needed
index|[
name|i
index|]
operator|==
name|RELOAD_FOR_INPADDR_ADDRESS
operator|)
condition|?
name|RELOAD_FOR_OTHER_ADDRESS
else|:
name|RELOAD_OTHER
operator|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output insns to reload values in and out of the chosen reload regs.  */
end_comment

begin_function
specifier|static
name|void
name|emit_reload_insns
parameter_list|(
name|chain
parameter_list|)
name|struct
name|insn_chain
modifier|*
name|chain
decl_stmt|;
block|{
name|rtx
name|insn
init|=
name|chain
operator|->
name|insn
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
name|rtx
name|input_reload_insns
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|rtx
name|other_input_address_reload_insns
init|=
literal|0
decl_stmt|;
name|rtx
name|other_input_reload_insns
init|=
literal|0
decl_stmt|;
name|rtx
name|input_address_reload_insns
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|rtx
name|inpaddr_address_reload_insns
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|rtx
name|output_reload_insns
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|rtx
name|output_address_reload_insns
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|rtx
name|outaddr_address_reload_insns
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|rtx
name|operand_reload_insns
init|=
literal|0
decl_stmt|;
name|rtx
name|other_operand_reload_insns
init|=
literal|0
decl_stmt|;
name|rtx
name|other_output_reload_insns
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|rtx
name|following_insn
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|before_insn
init|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|special
decl_stmt|;
comment|/* Values to be put in spill_reg_store are put here first.  */
name|rtx
name|new_spill_reg_store
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
name|HARD_REG_SET
name|reg_reloaded_died
decl_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|reg_reloaded_died
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|reload_n_operands
condition|;
name|j
operator|++
control|)
name|input_reload_insns
index|[
name|j
index|]
operator|=
name|input_address_reload_insns
index|[
name|j
index|]
operator|=
name|inpaddr_address_reload_insns
index|[
name|j
index|]
operator|=
name|output_reload_insns
index|[
name|j
index|]
operator|=
name|output_address_reload_insns
index|[
name|j
index|]
operator|=
name|outaddr_address_reload_insns
index|[
name|j
index|]
operator|=
name|other_output_reload_insns
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Now output the instructions to copy the data into and out of the      reload registers.  Do these in the order that the reloads were reported,      since reloads of base and index registers precede reloads of operands      and the operands may need the base and index registers reloaded.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_reloads
condition|;
name|j
operator|++
control|)
block|{
specifier|register
name|rtx
name|old
decl_stmt|;
name|rtx
name|oldequiv_reg
init|=
literal|0
decl_stmt|;
name|rtx
name|this_reload_insn
init|=
literal|0
decl_stmt|;
name|int
name|expect_occurrences
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|reload_reg_rtx
index|[
name|j
index|]
operator|&&
name|REGNO
argument_list|(
name|reload_reg_rtx
index|[
name|j
index|]
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|new_spill_reg_store
index|[
name|REGNO
argument_list|(
name|reload_reg_rtx
index|[
name|j
index|]
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
name|old
operator|=
operator|(
name|reload_in
index|[
name|j
index|]
operator|&&
name|GET_CODE
argument_list|(
name|reload_in
index|[
name|j
index|]
argument_list|)
operator|==
name|MEM
condition|?
name|reload_in_reg
index|[
name|j
index|]
else|:
name|reload_in
index|[
name|j
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|old
operator|!=
literal|0
comment|/* AUTO_INC reloads need to be handled even if inherited.  We got an 	     AUTO_INC reload if reload_out is set but reload_out_reg isn't.  */
operator|&&
operator|(
operator|!
name|reload_inherited
index|[
name|j
index|]
operator|||
operator|(
name|reload_out
index|[
name|j
index|]
operator|&&
operator|!
name|reload_out_reg
index|[
name|j
index|]
operator|)
operator|)
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|reload_reg_rtx
index|[
name|j
index|]
argument_list|,
name|old
argument_list|)
operator|&&
name|reload_reg_rtx
index|[
name|j
index|]
operator|!=
literal|0
condition|)
block|{
specifier|register
name|rtx
name|reloadreg
init|=
name|reload_reg_rtx
index|[
name|j
index|]
decl_stmt|;
name|rtx
name|oldequiv
init|=
literal|0
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
modifier|*
name|where
decl_stmt|;
comment|/* Determine the mode to reload in. 	     This is very tricky because we have three to choose from. 	     There is the mode the insn operand wants (reload_inmode[J]). 	     There is the mode of the reload register RELOADREG. 	     There is the intrinsic mode of the operand, which we could find 	     by stripping some SUBREGs. 	     It turns out that RELOADREG's mode is irrelevant: 	     we can change that arbitrarily.  	     Consider (SUBREG:SI foo:QI) as an operand that must be SImode; 	     then the reload reg may not support QImode moves, so use SImode. 	     If foo is in memory due to spilling a pseudo reg, this is safe, 	     because the QImode value is in the least significant part of a 	     slot big enough for a SImode.  If foo is some other sort of 	     memory reference, then it is impossible to reload this case, 	     so previous passes had better make sure this never happens.  	     Then consider a one-word union which has SImode and one of its 	     members is a float, being fetched as (SUBREG:SF union:SI). 	     We must fetch that as SFmode because we could be loading into 	     a float-only register.  In this case OLD's mode is correct.  	     Consider an immediate integer: it has VOIDmode.  Here we need 	     to get a mode from something else.  	     In some cases, there is a fourth mode, the operand's 	     containing mode.  If the insn specifies a containing mode for 	     this operand, it overrides all others.  	     I am not sure whether the algorithm here is always right, 	     but it does the right things in those cases.  */
name|mode
operator|=
name|GET_MODE
argument_list|(
name|old
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|mode
operator|=
name|reload_inmode
index|[
name|j
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|SECONDARY_INPUT_RELOAD_CLASS
comment|/* If we need a secondary register for this operation, see if 	     the value is already in a register in that class.  Don't 	     do this if the secondary register will be used as a scratch 	     register.  */
if|if
condition|(
name|reload_secondary_in_reload
index|[
name|j
index|]
operator|>=
literal|0
operator|&&
name|reload_secondary_in_icode
index|[
name|j
index|]
operator|==
name|CODE_FOR_nothing
operator|&&
name|optimize
condition|)
name|oldequiv
operator|=
name|find_equiv_reg
argument_list|(
name|old
argument_list|,
name|insn
argument_list|,
name|reload_reg_class
index|[
name|reload_secondary_in_reload
index|[
name|j
index|]
index|]
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL_PTR
argument_list|,
literal|0
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If reloading from memory, see if there is a register 	     that already holds the same value.  If so, reload from there. 	     We can pass 0 as the reload_reg_p argument because 	     any other reload has either already been emitted, 	     in which case find_equiv_reg will see the reload-insn, 	     or has yet to be emitted, in which case it doesn't matter 	     because we will use this equiv reg right away.  */
if|if
condition|(
name|oldequiv
operator|==
literal|0
operator|&&
name|optimize
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|old
argument_list|)
operator|==
name|MEM
operator|||
operator|(
name|GET_CODE
argument_list|(
name|old
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|old
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_renumber
index|[
name|REGNO
argument_list|(
name|old
argument_list|)
index|]
operator|<
literal|0
operator|)
operator|)
condition|)
name|oldequiv
operator|=
name|find_equiv_reg
argument_list|(
name|old
argument_list|,
name|insn
argument_list|,
name|ALL_REGS
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL_PTR
argument_list|,
literal|0
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldequiv
condition|)
block|{
name|int
name|regno
init|=
name|true_regnum
argument_list|(
name|oldequiv
argument_list|)
decl_stmt|;
comment|/* Don't use OLDEQUIV if any other reload changes it at an 		 earlier stage of this insn or at this stage.  */
if|if
condition|(
operator|!
name|reload_reg_free_for_value_p
argument_list|(
name|regno
argument_list|,
name|reload_opnum
index|[
name|j
index|]
argument_list|,
name|reload_when_needed
index|[
name|j
index|]
argument_list|,
name|reload_in
index|[
name|j
index|]
argument_list|,
name|const0_rtx
argument_list|,
name|j
argument_list|,
literal|0
argument_list|)
condition|)
name|oldequiv
operator|=
literal|0
expr_stmt|;
comment|/* If it is no cheaper to copy from OLDEQUIV into the 		 reload register than it would be to move from memory, 		 don't use it. Likewise, if we need a secondary register 		 or memory.   */
if|if
condition|(
name|oldequiv
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|REGNO_REG_CLASS
argument_list|(
name|regno
argument_list|)
operator|!=
name|reload_reg_class
index|[
name|j
index|]
operator|&&
operator|(
name|REGISTER_MOVE_COST
argument_list|(
name|REGNO_REG_CLASS
argument_list|(
name|regno
argument_list|)
argument_list|,
name|reload_reg_class
index|[
name|j
index|]
argument_list|)
operator|>=
name|MEMORY_MOVE_COST
argument_list|(
name|mode
argument_list|,
name|reload_reg_class
index|[
name|j
index|]
argument_list|,
literal|1
argument_list|)
operator|)
operator|)
ifdef|#
directive|ifdef
name|SECONDARY_INPUT_RELOAD_CLASS
operator|||
operator|(
name|SECONDARY_INPUT_RELOAD_CLASS
argument_list|(
name|reload_reg_class
index|[
name|j
index|]
argument_list|,
name|mode
argument_list|,
name|oldequiv
argument_list|)
operator|!=
name|NO_REGS
operator|)
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SECONDARY_MEMORY_NEEDED
operator|||
name|SECONDARY_MEMORY_NEEDED
argument_list|(
name|REGNO_REG_CLASS
argument_list|(
name|regno
argument_list|)
argument_list|,
name|reload_reg_class
index|[
name|j
index|]
argument_list|,
name|mode
argument_list|)
endif|#
directive|endif
operator|)
condition|)
name|oldequiv
operator|=
literal|0
expr_stmt|;
block|}
comment|/* delete_output_reload is only invoked properly if old contains 	     the original pseudo register.  Since this is replaced with a 	     hard reg when RELOAD_OVERRIDE_IN is set, see if we can 	     find the pseudo in RELOAD_IN_REG.  */
if|if
condition|(
name|oldequiv
operator|==
literal|0
operator|&&
name|reload_override_in
index|[
name|j
index|]
operator|&&
name|GET_CODE
argument_list|(
name|reload_in_reg
index|[
name|j
index|]
argument_list|)
operator|==
name|REG
condition|)
block|{
name|oldequiv
operator|=
name|old
expr_stmt|;
name|old
operator|=
name|reload_in_reg
index|[
name|j
index|]
expr_stmt|;
block|}
if|if
condition|(
name|oldequiv
operator|==
literal|0
condition|)
name|oldequiv
operator|=
name|old
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|oldequiv
argument_list|)
operator|==
name|REG
condition|)
name|oldequiv_reg
operator|=
name|oldequiv
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|oldequiv
argument_list|)
operator|==
name|SUBREG
condition|)
name|oldequiv_reg
operator|=
name|SUBREG_REG
argument_list|(
name|oldequiv
argument_list|)
expr_stmt|;
comment|/* If we are reloading from a register that was recently stored in 	     with an output-reload, see if we can prove there was 	     actually no need to store the old value in it.  */
if|if
condition|(
name|optimize
operator|&&
name|GET_CODE
argument_list|(
name|oldequiv
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|oldequiv
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|spill_reg_store
index|[
name|REGNO
argument_list|(
name|oldequiv
argument_list|)
index|]
operator|&&
name|GET_CODE
argument_list|(
name|old
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|dead_or_set_p
argument_list|(
name|insn
argument_list|,
name|spill_reg_stored_to
index|[
name|REGNO
argument_list|(
name|oldequiv
argument_list|)
index|]
argument_list|)
operator|||
name|rtx_equal_p
argument_list|(
name|spill_reg_stored_to
index|[
name|REGNO
argument_list|(
name|oldequiv
argument_list|)
index|]
argument_list|,
name|reload_out_reg
index|[
name|j
index|]
argument_list|)
operator|)
condition|)
name|delete_output_reload
argument_list|(
name|insn
argument_list|,
name|j
argument_list|,
name|REGNO
argument_list|(
name|oldequiv
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Encapsulate both RELOADREG and OLDEQUIV into that mode, 	     then load RELOADREG from OLDEQUIV.  Note that we cannot use 	     gen_lowpart_common since it can do the wrong thing when 	     RELOADREG has a multi-word mode.  Note that RELOADREG 	     must always be a REG here.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|reloadreg
argument_list|)
operator|!=
name|mode
condition|)
name|reloadreg
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|REGNO
argument_list|(
name|reloadreg
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|oldequiv
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_MODE
argument_list|(
name|oldequiv
argument_list|)
operator|!=
name|mode
condition|)
name|oldequiv
operator|=
name|SUBREG_REG
argument_list|(
name|oldequiv
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|oldequiv
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|oldequiv
argument_list|)
condition|)
name|oldequiv
operator|=
name|gen_rtx_SUBREG
argument_list|(
name|mode
argument_list|,
name|oldequiv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Switch to the right place to emit the reload insns.  */
switch|switch
condition|(
name|reload_when_needed
index|[
name|j
index|]
condition|)
block|{
case|case
name|RELOAD_OTHER
case|:
name|where
operator|=
operator|&
name|other_input_reload_insns
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_INPUT
case|:
name|where
operator|=
operator|&
name|input_reload_insns
index|[
name|reload_opnum
index|[
name|j
index|]
index|]
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_INPUT_ADDRESS
case|:
name|where
operator|=
operator|&
name|input_address_reload_insns
index|[
name|reload_opnum
index|[
name|j
index|]
index|]
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_INPADDR_ADDRESS
case|:
name|where
operator|=
operator|&
name|inpaddr_address_reload_insns
index|[
name|reload_opnum
index|[
name|j
index|]
index|]
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OUTPUT_ADDRESS
case|:
name|where
operator|=
operator|&
name|output_address_reload_insns
index|[
name|reload_opnum
index|[
name|j
index|]
index|]
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OUTADDR_ADDRESS
case|:
name|where
operator|=
operator|&
name|outaddr_address_reload_insns
index|[
name|reload_opnum
index|[
name|j
index|]
index|]
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OPERAND_ADDRESS
case|:
name|where
operator|=
operator|&
name|operand_reload_insns
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OPADDR_ADDR
case|:
name|where
operator|=
operator|&
name|other_operand_reload_insns
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OTHER_ADDRESS
case|:
name|where
operator|=
operator|&
name|other_input_address_reload_insns
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|push_to_sequence
argument_list|(
operator|*
name|where
argument_list|)
expr_stmt|;
name|special
operator|=
literal|0
expr_stmt|;
comment|/* Auto-increment addresses must be reloaded in a special way.  */
if|if
condition|(
name|reload_out
index|[
name|j
index|]
operator|&&
operator|!
name|reload_out_reg
index|[
name|j
index|]
condition|)
block|{
comment|/* We are not going to bother supporting the case where a 		 incremented register can't be copied directly from 		 OLDEQUIV since this seems highly unlikely.  */
if|if
condition|(
name|reload_secondary_in_reload
index|[
name|j
index|]
operator|>=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|reload_inherited
index|[
name|j
index|]
condition|)
name|oldequiv
operator|=
name|reloadreg
expr_stmt|;
name|old
operator|=
name|XEXP
argument_list|(
name|reload_in_reg
index|[
name|j
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|optimize
operator|&&
name|GET_CODE
argument_list|(
name|oldequiv
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|oldequiv
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|spill_reg_store
index|[
name|REGNO
argument_list|(
name|oldequiv
argument_list|)
index|]
operator|&&
name|GET_CODE
argument_list|(
name|old
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|dead_or_set_p
argument_list|(
name|insn
argument_list|,
name|spill_reg_stored_to
index|[
name|REGNO
argument_list|(
name|oldequiv
argument_list|)
index|]
argument_list|)
operator|||
name|rtx_equal_p
argument_list|(
name|spill_reg_stored_to
index|[
name|REGNO
argument_list|(
name|oldequiv
argument_list|)
index|]
argument_list|,
name|old
argument_list|)
operator|)
condition|)
name|delete_output_reload
argument_list|(
name|insn
argument_list|,
name|j
argument_list|,
name|REGNO
argument_list|(
name|oldequiv
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Prevent normal processing of this reload.  */
name|special
operator|=
literal|1
expr_stmt|;
comment|/* Output a special code sequence for this case.  */
name|new_spill_reg_store
index|[
name|REGNO
argument_list|(
name|reloadreg
argument_list|)
index|]
operator|=
name|inc_for_reload
argument_list|(
name|reloadreg
argument_list|,
name|oldequiv
argument_list|,
name|reload_out
index|[
name|j
index|]
argument_list|,
name|reload_inc
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* If we are reloading a pseudo-register that was set by the previous 	     insn, see if we can get rid of that pseudo-register entirely 	     by redirecting the previous insn into our reload register.  */
elseif|else
if|if
condition|(
name|optimize
operator|&&
name|GET_CODE
argument_list|(
name|old
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|old
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|dead_or_set_p
argument_list|(
name|insn
argument_list|,
name|old
argument_list|)
comment|/* This is unsafe if some other reload 		      uses the same reg first.  */
operator|&&
name|reload_reg_free_for_value_p
argument_list|(
name|REGNO
argument_list|(
name|reloadreg
argument_list|)
argument_list|,
name|reload_opnum
index|[
name|j
index|]
argument_list|,
name|reload_when_needed
index|[
name|j
index|]
argument_list|,
name|old
argument_list|,
name|reload_out
index|[
name|j
index|]
argument_list|,
name|j
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|rtx
name|temp
init|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
while|while
condition|(
name|temp
operator|&&
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|NOTE
condition|)
name|temp
operator|=
name|PREV_INSN
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|&&
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|==
name|old
comment|/* Make sure we can access insn_operand_constraint.  */
operator|&&
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|<
literal|0
comment|/* This is unsafe if prev insn rejects our reload reg.  */
operator|&&
name|constraint_accepts_reg_p
argument_list|(
name|insn_operand_constraint
index|[
name|recog_memoized
argument_list|(
name|temp
argument_list|)
index|]
index|[
literal|0
index|]
argument_list|,
name|reloadreg
argument_list|)
comment|/* This is unsafe if operand occurs more than once in current 		     insn.  Perhaps some occurrences aren't reloaded.  */
operator|&&
name|count_occurrences
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|old
argument_list|)
operator|==
literal|1
comment|/* Don't risk splitting a matching pair of operands.  */
operator|&&
operator|!
name|reg_mentioned_p
argument_list|(
name|old
argument_list|,
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|temp
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Store into the reload register instead of the pseudo.  */
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|=
name|reloadreg
expr_stmt|;
comment|/* If the previous insn is an output reload, the source is 		     a reload register, and its spill_reg_store entry will 		     contain the previous destination.  This is now 		     invalid.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|temp
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|temp
argument_list|)
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|spill_reg_store
index|[
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|temp
argument_list|)
argument_list|)
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
name|spill_reg_stored_to
index|[
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|temp
argument_list|)
argument_list|)
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If these are the only uses of the pseudo reg, 		     pretend for GDB it lives in the reload reg we used.  */
if|if
condition|(
name|REG_N_DEATHS
argument_list|(
name|REGNO
argument_list|(
name|old
argument_list|)
argument_list|)
operator|==
literal|1
operator|&&
name|REG_N_SETS
argument_list|(
name|REGNO
argument_list|(
name|old
argument_list|)
argument_list|)
operator|==
literal|1
condition|)
block|{
name|reg_renumber
index|[
name|REGNO
argument_list|(
name|old
argument_list|)
index|]
operator|=
name|REGNO
argument_list|(
name|reload_reg_rtx
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|alter_reg
argument_list|(
name|REGNO
argument_list|(
name|old
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|special
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* We can't do that, so output an insn to load RELOADREG.  */
if|if
condition|(
operator|!
name|special
condition|)
block|{
ifdef|#
directive|ifdef
name|SECONDARY_INPUT_RELOAD_CLASS
name|rtx
name|second_reload_reg
init|=
literal|0
decl_stmt|;
name|enum
name|insn_code
name|icode
decl_stmt|;
comment|/* If we have a secondary reload, pick up the secondary register 		 and icode, if any.  If OLDEQUIV and OLD are different or 		 if this is an in-out reload, recompute whether or not we 		 still need a secondary register and what the icode should 		 be.  If we still need a secondary register and the class or 		 icode is different, go back to reloading from OLD if using 		 OLDEQUIV means that we got the wrong type of register.  We 		 cannot have different class or icode due to an in-out reload 		 because we don't make such reloads when both the input and 		 output need secondary reload registers.  */
if|if
condition|(
name|reload_secondary_in_reload
index|[
name|j
index|]
operator|>=
literal|0
condition|)
block|{
name|int
name|secondary_reload
init|=
name|reload_secondary_in_reload
index|[
name|j
index|]
decl_stmt|;
name|rtx
name|real_oldequiv
init|=
name|oldequiv
decl_stmt|;
name|rtx
name|real_old
init|=
name|old
decl_stmt|;
name|rtx
name|tmp
decl_stmt|;
comment|/* If OLDEQUIV is a pseudo with a MEM, get the real MEM 		     and similarly for OLD. 		     See comments in get_secondary_reload in reload.c.  */
comment|/* If it is a pseudo that cannot be replaced with its 		     equivalent MEM, we must fall back to reload_in, which 		     will have all the necessary substitutions registered. 		     Likewise for a pseudo that can't be replaced with its 		     equivalent constant.   		     Take extra care for subregs of such pseudos.  Note that 		     we cannot use reg_equiv_mem in this case because it is 		     not in the right mode.  */
name|tmp
operator|=
name|oldequiv
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|SUBREG
condition|)
name|tmp
operator|=
name|SUBREG_REG
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|tmp
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|(
name|reg_equiv_memory_loc
index|[
name|REGNO
argument_list|(
name|tmp
argument_list|)
index|]
operator|!=
literal|0
operator|||
name|reg_equiv_constant
index|[
name|REGNO
argument_list|(
name|tmp
argument_list|)
index|]
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|reg_equiv_mem
index|[
name|REGNO
argument_list|(
name|tmp
argument_list|)
index|]
operator|||
name|num_not_at_initial_offset
operator|||
name|GET_CODE
argument_list|(
name|oldequiv
argument_list|)
operator|==
name|SUBREG
condition|)
name|real_oldequiv
operator|=
name|reload_in
index|[
name|j
index|]
expr_stmt|;
else|else
name|real_oldequiv
operator|=
name|reg_equiv_mem
index|[
name|REGNO
argument_list|(
name|tmp
argument_list|)
index|]
expr_stmt|;
block|}
name|tmp
operator|=
name|old
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|SUBREG
condition|)
name|tmp
operator|=
name|SUBREG_REG
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|tmp
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|(
name|reg_equiv_memory_loc
index|[
name|REGNO
argument_list|(
name|tmp
argument_list|)
index|]
operator|!=
literal|0
operator|||
name|reg_equiv_constant
index|[
name|REGNO
argument_list|(
name|tmp
argument_list|)
index|]
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|reg_equiv_mem
index|[
name|REGNO
argument_list|(
name|tmp
argument_list|)
index|]
operator|||
name|num_not_at_initial_offset
operator|||
name|GET_CODE
argument_list|(
name|old
argument_list|)
operator|==
name|SUBREG
condition|)
name|real_old
operator|=
name|reload_in
index|[
name|j
index|]
expr_stmt|;
else|else
name|real_old
operator|=
name|reg_equiv_mem
index|[
name|REGNO
argument_list|(
name|tmp
argument_list|)
index|]
expr_stmt|;
block|}
name|second_reload_reg
operator|=
name|reload_reg_rtx
index|[
name|secondary_reload
index|]
expr_stmt|;
name|icode
operator|=
name|reload_secondary_in_icode
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|old
operator|!=
name|oldequiv
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|old
argument_list|,
name|oldequiv
argument_list|)
operator|)
operator|||
operator|(
name|reload_in
index|[
name|j
index|]
operator|!=
literal|0
operator|&&
name|reload_out
index|[
name|j
index|]
operator|!=
literal|0
operator|)
condition|)
block|{
name|enum
name|reg_class
name|new_class
init|=
name|SECONDARY_INPUT_RELOAD_CLASS
argument_list|(
name|reload_reg_class
index|[
name|j
index|]
argument_list|,
name|mode
argument_list|,
name|real_oldequiv
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_class
operator|==
name|NO_REGS
condition|)
name|second_reload_reg
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|enum
name|insn_code
name|new_icode
decl_stmt|;
name|enum
name|machine_mode
name|new_mode
decl_stmt|;
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|new_class
index|]
argument_list|,
name|REGNO
argument_list|(
name|second_reload_reg
argument_list|)
argument_list|)
condition|)
name|oldequiv
operator|=
name|old
operator|,
name|real_oldequiv
operator|=
name|real_old
expr_stmt|;
else|else
block|{
name|new_icode
operator|=
name|reload_in_optab
index|[
operator|(
name|int
operator|)
name|mode
index|]
expr_stmt|;
if|if
condition|(
name|new_icode
operator|!=
name|CODE_FOR_nothing
operator|&&
operator|(
operator|(
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|new_icode
index|]
index|[
literal|0
index|]
operator|&&
operator|!
operator|(
call|(
modifier|*
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|new_icode
index|]
index|[
literal|0
index|]
call|)
argument_list|(
name|reloadreg
argument_list|,
name|mode
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|new_icode
index|]
index|[
literal|1
index|]
operator|&&
operator|!
operator|(
call|(
modifier|*
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|new_icode
index|]
index|[
literal|1
index|]
call|)
argument_list|(
name|real_oldequiv
argument_list|,
name|mode
argument_list|)
operator|)
operator|)
operator|)
condition|)
name|new_icode
operator|=
name|CODE_FOR_nothing
expr_stmt|;
if|if
condition|(
name|new_icode
operator|==
name|CODE_FOR_nothing
condition|)
name|new_mode
operator|=
name|mode
expr_stmt|;
else|else
name|new_mode
operator|=
name|insn_operand_mode
index|[
operator|(
name|int
operator|)
name|new_icode
index|]
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|second_reload_reg
argument_list|)
operator|!=
name|new_mode
condition|)
block|{
if|if
condition|(
operator|!
name|HARD_REGNO_MODE_OK
argument_list|(
name|REGNO
argument_list|(
name|second_reload_reg
argument_list|)
argument_list|,
name|new_mode
argument_list|)
condition|)
name|oldequiv
operator|=
name|old
operator|,
name|real_oldequiv
operator|=
name|real_old
expr_stmt|;
else|else
name|second_reload_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|new_mode
argument_list|,
name|REGNO
argument_list|(
name|second_reload_reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* If we still need a secondary reload register, check 		     to see if it is being used as a scratch or intermediate 		     register and generate code appropriately.  If we need 		     a scratch register, use REAL_OLDEQUIV since the form of 		     the insn may depend on the actual address if it is  		     a MEM.  */
if|if
condition|(
name|second_reload_reg
condition|)
block|{
if|if
condition|(
name|icode
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|emit_insn
argument_list|(
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|reloadreg
argument_list|,
name|real_oldequiv
argument_list|,
name|second_reload_reg
argument_list|)
argument_list|)
expr_stmt|;
name|special
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* See if we need a scratch register to load the 			     intermediate register (a tertiary reload).  */
name|enum
name|insn_code
name|tertiary_icode
init|=
name|reload_secondary_in_icode
index|[
name|secondary_reload
index|]
decl_stmt|;
if|if
condition|(
name|tertiary_icode
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|rtx
name|third_reload_reg
init|=
name|reload_reg_rtx
index|[
name|reload_secondary_in_reload
index|[
name|secondary_reload
index|]
index|]
decl_stmt|;
name|emit_insn
argument_list|(
operator|(
name|GEN_FCN
argument_list|(
name|tertiary_icode
argument_list|)
argument_list|(
name|second_reload_reg
argument_list|,
name|real_oldequiv
argument_list|,
name|third_reload_reg
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
name|gen_reload
argument_list|(
name|second_reload_reg
argument_list|,
name|real_oldequiv
argument_list|,
name|reload_opnum
index|[
name|j
index|]
argument_list|,
name|reload_when_needed
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|oldequiv
operator|=
name|second_reload_reg
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|special
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|reloadreg
argument_list|,
name|oldequiv
argument_list|)
condition|)
block|{
name|rtx
name|real_oldequiv
init|=
name|oldequiv
decl_stmt|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|oldequiv
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|oldequiv
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|(
name|reg_equiv_memory_loc
index|[
name|REGNO
argument_list|(
name|oldequiv
argument_list|)
index|]
operator|!=
literal|0
operator|||
name|reg_equiv_constant
index|[
name|REGNO
argument_list|(
name|oldequiv
argument_list|)
index|]
operator|!=
literal|0
operator|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|oldequiv
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|oldequiv
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|oldequiv
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|&&
operator|(
operator|(
name|reg_equiv_memory_loc
index|[
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|oldequiv
argument_list|)
argument_list|)
index|]
operator|!=
literal|0
operator|)
operator|||
operator|(
name|reg_equiv_constant
index|[
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|oldequiv
argument_list|)
argument_list|)
index|]
operator|!=
literal|0
operator|)
operator|)
operator|)
condition|)
name|real_oldequiv
operator|=
name|reload_in
index|[
name|j
index|]
expr_stmt|;
name|gen_reload
argument_list|(
name|reloadreg
argument_list|,
name|real_oldequiv
argument_list|,
name|reload_opnum
index|[
name|j
index|]
argument_list|,
name|reload_when_needed
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|this_reload_insn
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
comment|/* End this sequence.  */
operator|*
name|where
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
comment|/* Update reload_override_in so that delete_address_reloads_1 	     can see the actual register usage.  */
if|if
condition|(
name|oldequiv_reg
condition|)
name|reload_override_in
index|[
name|j
index|]
operator|=
name|oldequiv
expr_stmt|;
block|}
comment|/* When inheriting a wider reload, we have a MEM in reload_in[j], 	 e.g. inheriting a SImode output reload for 	 (mem:HI (plus:SI (reg:SI 14 fp) (const_int 10)))  */
if|if
condition|(
name|optimize
operator|&&
name|reload_inherited
index|[
name|j
index|]
operator|&&
name|reload_in
index|[
name|j
index|]
operator|&&
name|GET_CODE
argument_list|(
name|reload_in
index|[
name|j
index|]
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|reload_in_reg
index|[
name|j
index|]
argument_list|)
operator|==
name|MEM
operator|&&
name|reload_spill_index
index|[
name|j
index|]
operator|>=
literal|0
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_reloaded_valid
argument_list|,
name|reload_spill_index
index|[
name|j
index|]
argument_list|)
condition|)
block|{
name|expect_occurrences
operator|=
name|count_occurrences
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|reload_in
index|[
name|j
index|]
argument_list|)
operator|==
literal|1
condition|?
literal|0
else|:
operator|-
literal|1
expr_stmt|;
name|reload_in
index|[
name|j
index|]
operator|=
name|regno_reg_rtx
index|[
name|reg_reloaded_contents
index|[
name|reload_spill_index
index|[
name|j
index|]
index|]
index|]
expr_stmt|;
block|}
comment|/* If we are reloading a register that was recently stored in with an 	 output-reload, see if we can prove there was 	 actually no need to store the old value in it.  */
if|if
condition|(
name|optimize
operator|&&
operator|(
name|reload_inherited
index|[
name|j
index|]
operator|||
name|reload_override_in
index|[
name|j
index|]
operator|)
operator|&&
name|reload_reg_rtx
index|[
name|j
index|]
operator|&&
name|GET_CODE
argument_list|(
name|reload_reg_rtx
index|[
name|j
index|]
argument_list|)
operator|==
name|REG
operator|&&
name|spill_reg_store
index|[
name|REGNO
argument_list|(
name|reload_reg_rtx
index|[
name|j
index|]
argument_list|)
index|]
operator|!=
literal|0
if|#
directive|if
literal|0
comment|/* There doesn't seem to be any reason to restrict this to pseudos 	     and doing so loses in the case where we are copying from a 	     register of the wrong class.  */
expr|&& REGNO (spill_reg_stored_to[REGNO (reload_reg_rtx[j])])>= FIRST_PSEUDO_REGISTER
endif|#
directive|endif
comment|/* The insn might have already some references to stackslots 		replaced by MEMs, while reload_out_reg still names the 		original pseudo.  */
operator|&&
operator|(
name|dead_or_set_p
argument_list|(
name|insn
argument_list|,
name|spill_reg_stored_to
index|[
name|REGNO
argument_list|(
name|reload_reg_rtx
index|[
name|j
index|]
argument_list|)
index|]
argument_list|)
operator|||
name|rtx_equal_p
argument_list|(
name|spill_reg_stored_to
index|[
name|REGNO
argument_list|(
name|reload_reg_rtx
index|[
name|j
index|]
argument_list|)
index|]
argument_list|,
name|reload_out_reg
index|[
name|j
index|]
argument_list|)
operator|)
condition|)
name|delete_output_reload
argument_list|(
name|insn
argument_list|,
name|j
argument_list|,
name|REGNO
argument_list|(
name|reload_reg_rtx
index|[
name|j
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Input-reloading is done.  Now do output-reloading, 	 storing the value from the reload-register after the main insn 	 if reload_out[j] is nonzero.  	 ??? At some point we need to support handling output reloads of 	 JUMP_INSNs or insns that set cc0.  */
comment|/* If this is an output reload that stores something that is 	 not loaded in this same reload, see if we can eliminate a previous 	 store.  */
block|{
name|rtx
name|pseudo
init|=
name|reload_out_reg
index|[
name|j
index|]
decl_stmt|;
if|if
condition|(
name|pseudo
operator|&&
name|GET_CODE
argument_list|(
name|pseudo
argument_list|)
operator|==
name|REG
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|reload_in_reg
index|[
name|j
index|]
argument_list|,
name|pseudo
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|pseudo
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_last_reload_reg
index|[
name|REGNO
argument_list|(
name|pseudo
argument_list|)
index|]
condition|)
block|{
name|int
name|pseudo_no
init|=
name|REGNO
argument_list|(
name|pseudo
argument_list|)
decl_stmt|;
name|int
name|last_regno
init|=
name|REGNO
argument_list|(
name|reg_last_reload_reg
index|[
name|pseudo_no
index|]
argument_list|)
decl_stmt|;
comment|/* We don't need to test full validity of last_regno for 	       inherit here; we only want to know if the store actually 	       matches the pseudo.  */
if|if
condition|(
name|reg_reloaded_contents
index|[
name|last_regno
index|]
operator|==
name|pseudo_no
operator|&&
name|spill_reg_store
index|[
name|last_regno
index|]
operator|&&
name|rtx_equal_p
argument_list|(
name|pseudo
argument_list|,
name|spill_reg_stored_to
index|[
name|last_regno
index|]
argument_list|)
condition|)
name|delete_output_reload
argument_list|(
name|insn
argument_list|,
name|j
argument_list|,
name|last_regno
argument_list|)
expr_stmt|;
block|}
block|}
name|old
operator|=
name|reload_out_reg
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|old
operator|!=
literal|0
operator|&&
name|reload_reg_rtx
index|[
name|j
index|]
operator|!=
name|old
operator|&&
name|reload_reg_rtx
index|[
name|j
index|]
operator|!=
literal|0
condition|)
block|{
specifier|register
name|rtx
name|reloadreg
init|=
name|reload_reg_rtx
index|[
name|j
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|SECONDARY_OUTPUT_RELOAD_CLASS
specifier|register
name|rtx
name|second_reloadreg
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|rtx
name|note
decl_stmt|,
name|p
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|special
init|=
literal|0
decl_stmt|;
comment|/* An output operand that dies right away does need a reload, 	     but need not be copied from it.  Show the new location in the 	     REG_UNUSED note.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|old
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|old
argument_list|)
operator|==
name|SCRATCH
operator|)
operator|&&
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_UNUSED
argument_list|,
name|old
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
operator|=
name|reload_reg_rtx
index|[
name|j
index|]
expr_stmt|;
continue|continue;
block|}
comment|/* Likewise for a SUBREG of an operand that dies.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|old
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|old
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
literal|0
operator|!=
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_UNUSED
argument_list|,
name|SUBREG_REG
argument_list|(
name|old
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
operator|=
name|gen_lowpart_common
argument_list|(
name|GET_MODE
argument_list|(
name|old
argument_list|)
argument_list|,
name|reload_reg_rtx
index|[
name|j
index|]
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|old
argument_list|)
operator|==
name|SCRATCH
condition|)
comment|/* If we aren't optimizing, there won't be a REG_UNUSED note, 	       but we don't want to make an output reload.  */
continue|continue;
if|#
directive|if
literal|0
comment|/* Strip off of OLD any size-increasing SUBREGs such as 	     (SUBREG:SI foo:QI 0).  */
block|while (GET_CODE (old) == SUBREG&& SUBREG_WORD (old) == 0&& (GET_MODE_SIZE (GET_MODE (old))> GET_MODE_SIZE (GET_MODE (SUBREG_REG (old))))) 	    old = SUBREG_REG (old);
endif|#
directive|endif
comment|/* If is a JUMP_INSN, we can't support output reloads yet.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|reload_when_needed
index|[
name|j
index|]
operator|==
name|RELOAD_OTHER
condition|)
name|start_sequence
argument_list|()
expr_stmt|;
else|else
name|push_to_sequence
argument_list|(
name|output_reload_insns
index|[
name|reload_opnum
index|[
name|j
index|]
index|]
argument_list|)
expr_stmt|;
name|old
operator|=
name|reload_out
index|[
name|j
index|]
expr_stmt|;
comment|/* Determine the mode to reload in. 	     See comments above (for input reloading).  */
name|mode
operator|=
name|GET_MODE
argument_list|(
name|old
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
block|{
comment|/* VOIDmode should never happen for an output.  */
if|if
condition|(
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
comment|/* It's the compiler's fault.  */
name|fatal_insn
argument_list|(
literal|"VOIDmode on an output"
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|error_for_asm
argument_list|(
name|insn
argument_list|,
literal|"output operand is constant in `asm'"
argument_list|)
expr_stmt|;
comment|/* Prevent crash--use something we know is valid.  */
name|mode
operator|=
name|word_mode
expr_stmt|;
name|old
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|REGNO
argument_list|(
name|reloadreg
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_MODE
argument_list|(
name|reloadreg
argument_list|)
operator|!=
name|mode
condition|)
name|reloadreg
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|REGNO
argument_list|(
name|reloadreg
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SECONDARY_OUTPUT_RELOAD_CLASS
comment|/* If we need two reload regs, set RELOADREG to the intermediate 	     one, since it will be stored into OLD.  We might need a secondary 	     register only for an input reload, so check again here.  */
if|if
condition|(
name|reload_secondary_out_reload
index|[
name|j
index|]
operator|>=
literal|0
condition|)
block|{
name|rtx
name|real_old
init|=
name|old
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|old
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|old
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_equiv_mem
index|[
name|REGNO
argument_list|(
name|old
argument_list|)
index|]
operator|!=
literal|0
condition|)
name|real_old
operator|=
name|reg_equiv_mem
index|[
name|REGNO
argument_list|(
name|old
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|SECONDARY_OUTPUT_RELOAD_CLASS
argument_list|(
name|reload_reg_class
index|[
name|j
index|]
argument_list|,
name|mode
argument_list|,
name|real_old
argument_list|)
operator|!=
name|NO_REGS
operator|)
condition|)
block|{
name|second_reloadreg
operator|=
name|reloadreg
expr_stmt|;
name|reloadreg
operator|=
name|reload_reg_rtx
index|[
name|reload_secondary_out_reload
index|[
name|j
index|]
index|]
expr_stmt|;
comment|/* See if RELOADREG is to be used as a scratch register 		     or as an intermediate register.  */
if|if
condition|(
name|reload_secondary_out_icode
index|[
name|j
index|]
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|emit_insn
argument_list|(
operator|(
name|GEN_FCN
argument_list|(
name|reload_secondary_out_icode
index|[
name|j
index|]
argument_list|)
argument_list|(
name|real_old
argument_list|,
name|second_reloadreg
argument_list|,
name|reloadreg
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|special
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* See if we need both a scratch and intermediate reload 			 register.  */
name|int
name|secondary_reload
init|=
name|reload_secondary_out_reload
index|[
name|j
index|]
decl_stmt|;
name|enum
name|insn_code
name|tertiary_icode
init|=
name|reload_secondary_out_icode
index|[
name|secondary_reload
index|]
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|reloadreg
argument_list|)
operator|!=
name|mode
condition|)
name|reloadreg
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|REGNO
argument_list|(
name|reloadreg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tertiary_icode
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|rtx
name|third_reloadreg
init|=
name|reload_reg_rtx
index|[
name|reload_secondary_out_reload
index|[
name|secondary_reload
index|]
index|]
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
comment|/* Copy primary reload reg to secondary reload reg. 			     (Note that these have been swapped above, then 			     secondary reload reg to OLD using our insn.  */
comment|/* If REAL_OLD is a paradoxical SUBREG, remove it 			     and try to put the opposite SUBREG on 			     RELOADREG.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|real_old
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|real_old
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|real_old
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
literal|0
operator|!=
operator|(
name|tem
operator|=
name|gen_lowpart_common
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|real_old
argument_list|)
argument_list|)
argument_list|,
name|reloadreg
argument_list|)
operator|)
condition|)
name|real_old
operator|=
name|SUBREG_REG
argument_list|(
name|real_old
argument_list|)
operator|,
name|reloadreg
operator|=
name|tem
expr_stmt|;
name|gen_reload
argument_list|(
name|reloadreg
argument_list|,
name|second_reloadreg
argument_list|,
name|reload_opnum
index|[
name|j
index|]
argument_list|,
name|reload_when_needed
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
operator|(
name|GEN_FCN
argument_list|(
name|tertiary_icode
argument_list|)
argument_list|(
name|real_old
argument_list|,
name|reloadreg
argument_list|,
name|third_reloadreg
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|special
operator|=
literal|1
expr_stmt|;
block|}
else|else
comment|/* Copy between the reload regs here and then to 			   OUT later.  */
name|gen_reload
argument_list|(
name|reloadreg
argument_list|,
name|second_reloadreg
argument_list|,
name|reload_opnum
index|[
name|j
index|]
argument_list|,
name|reload_when_needed
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* Output the last reload insn.  */
if|if
condition|(
operator|!
name|special
condition|)
block|{
name|rtx
name|set
decl_stmt|;
comment|/* Don't output the last reload if OLD is not the dest of 		 INSN and is in the src and is clobbered by INSN. */
if|if
condition|(
operator|!
name|flag_expensive_optimizations
operator|||
name|GET_CODE
argument_list|(
name|old
argument_list|)
operator|!=
name|REG
operator|||
operator|!
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
operator|)
operator|||
name|rtx_equal_p
argument_list|(
name|old
argument_list|,
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|||
operator|!
name|reg_mentioned_p
argument_list|(
name|old
argument_list|,
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|||
operator|!
name|regno_clobbered_p
argument_list|(
name|REGNO
argument_list|(
name|old
argument_list|)
argument_list|,
name|insn
argument_list|)
condition|)
name|gen_reload
argument_list|(
name|old
argument_list|,
name|reloadreg
argument_list|,
name|reload_opnum
index|[
name|j
index|]
argument_list|,
name|reload_when_needed
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Look at all insns we emitted, just to be safe.  */
for|for
control|(
name|p
operator|=
name|get_insns
argument_list|()
init|;
name|p
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|p
argument_list|)
decl_stmt|;
comment|/* If this output reload doesn't come from a spill reg, 		   clear any memory of reloaded copies of the pseudo reg. 		   If this output reload comes from a spill reg, 		   reg_has_output_reload will make this do nothing.  */
name|note_stores
argument_list|(
name|pat
argument_list|,
name|forget_old_reloads_1
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|reload_reg_rtx
index|[
name|j
index|]
argument_list|,
name|pat
argument_list|)
condition|)
block|{
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|reload_spill_index
index|[
name|j
index|]
operator|<
literal|0
operator|&&
name|set
operator|&&
name|SET_SRC
argument_list|(
name|set
argument_list|)
operator|==
name|reload_reg_rtx
index|[
name|j
index|]
condition|)
block|{
name|int
name|src
init|=
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
decl_stmt|;
name|reload_spill_index
index|[
name|j
index|]
operator|=
name|src
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|reg_is_output_reload
argument_list|,
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|src
argument_list|)
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|reg_reloaded_died
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|REGNO
argument_list|(
name|reload_reg_rtx
index|[
name|j
index|]
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|s
init|=
name|reload_secondary_out_reload
index|[
name|j
index|]
decl_stmt|;
name|set
operator|=
name|single_set
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* If this reload copies only to the secondary reload 			   register, the secondary reload does the actual 			   store.  */
if|if
condition|(
name|s
operator|>=
literal|0
operator|&&
name|set
operator|==
name|NULL_RTX
condition|)
empty_stmt|;
comment|/* We can't tell what function the secondary reload 			       has and where the actual store to the pseudo is 			       made; leave new_spill_reg_store alone.  */
elseif|else
if|if
condition|(
name|s
operator|>=
literal|0
operator|&&
name|SET_SRC
argument_list|(
name|set
argument_list|)
operator|==
name|reload_reg_rtx
index|[
name|j
index|]
operator|&&
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|==
name|reload_reg_rtx
index|[
name|s
index|]
condition|)
block|{
comment|/* Usually the next instruction will be the 			       secondary reload insn;  if we can confirm 			       that it is, setting new_spill_reg_store to 			       that insn will allow an extra optimization.  */
name|rtx
name|s_reg
init|=
name|reload_reg_rtx
index|[
name|s
index|]
decl_stmt|;
name|rtx
name|next
init|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|reload_out
index|[
name|s
index|]
operator|=
name|reload_out
index|[
name|j
index|]
expr_stmt|;
name|reload_out_reg
index|[
name|s
index|]
operator|=
name|reload_out_reg
index|[
name|j
index|]
expr_stmt|;
name|set
operator|=
name|single_set
argument_list|(
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
operator|&&
name|SET_SRC
argument_list|(
name|set
argument_list|)
operator|==
name|s_reg
operator|&&
operator|!
name|new_spill_reg_store
index|[
name|REGNO
argument_list|(
name|s_reg
argument_list|)
index|]
condition|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|reg_is_output_reload
argument_list|,
name|REGNO
argument_list|(
name|s_reg
argument_list|)
argument_list|)
expr_stmt|;
name|new_spill_reg_store
index|[
name|REGNO
argument_list|(
name|s_reg
argument_list|)
index|]
operator|=
name|next
expr_stmt|;
block|}
block|}
else|else
name|new_spill_reg_store
index|[
name|REGNO
argument_list|(
name|reload_reg_rtx
index|[
name|j
index|]
argument_list|)
index|]
operator|=
name|p
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|reload_when_needed
index|[
name|j
index|]
operator|==
name|RELOAD_OTHER
condition|)
block|{
name|emit_insns
argument_list|(
name|other_output_reload_insns
index|[
name|reload_opnum
index|[
name|j
index|]
index|]
argument_list|)
expr_stmt|;
name|other_output_reload_insns
index|[
name|reload_opnum
index|[
name|j
index|]
index|]
operator|=
name|get_insns
argument_list|()
expr_stmt|;
block|}
else|else
name|output_reload_insns
index|[
name|reload_opnum
index|[
name|j
index|]
index|]
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Now write all the insns we made for reloads in the order expected by      the allocation functions.  Prior to the insn being reloaded, we write      the following reloads:       RELOAD_FOR_OTHER_ADDRESS reloads for input addresses.       RELOAD_OTHER reloads.       For each operand, any RELOAD_FOR_INPADDR_ADDRESS reloads followed      by any RELOAD_FOR_INPUT_ADDRESS reloads followed by the      RELOAD_FOR_INPUT reload for the operand.       RELOAD_FOR_OPADDR_ADDRS reloads.       RELOAD_FOR_OPERAND_ADDRESS reloads.       After the insn being reloaded, we write the following:       For each operand, any RELOAD_FOR_OUTADDR_ADDRESS reloads followed      by any RELOAD_FOR_OUTPUT_ADDRESS reload followed by the      RELOAD_FOR_OUTPUT reload, followed by any RELOAD_OTHER output      reloads for the operand.  The RELOAD_OTHER output reloads are      output in descending order by reload number.  */
name|emit_insns_before
argument_list|(
name|other_input_address_reload_insns
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|emit_insns_before
argument_list|(
name|other_input_reload_insns
argument_list|,
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|reload_n_operands
condition|;
name|j
operator|++
control|)
block|{
name|emit_insns_before
argument_list|(
name|inpaddr_address_reload_insns
index|[
name|j
index|]
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|emit_insns_before
argument_list|(
name|input_address_reload_insns
index|[
name|j
index|]
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|emit_insns_before
argument_list|(
name|input_reload_insns
index|[
name|j
index|]
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
name|emit_insns_before
argument_list|(
name|other_operand_reload_insns
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|emit_insns_before
argument_list|(
name|operand_reload_insns
argument_list|,
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|reload_n_operands
condition|;
name|j
operator|++
control|)
block|{
name|emit_insns_before
argument_list|(
name|outaddr_address_reload_insns
index|[
name|j
index|]
argument_list|,
name|following_insn
argument_list|)
expr_stmt|;
name|emit_insns_before
argument_list|(
name|output_address_reload_insns
index|[
name|j
index|]
argument_list|,
name|following_insn
argument_list|)
expr_stmt|;
name|emit_insns_before
argument_list|(
name|output_reload_insns
index|[
name|j
index|]
argument_list|,
name|following_insn
argument_list|)
expr_stmt|;
name|emit_insns_before
argument_list|(
name|other_output_reload_insns
index|[
name|j
index|]
argument_list|,
name|following_insn
argument_list|)
expr_stmt|;
block|}
comment|/* Keep basic block info up to date.  */
if|if
condition|(
name|n_basic_blocks
condition|)
block|{
if|if
condition|(
name|BLOCK_HEAD
argument_list|(
name|chain
operator|->
name|block
argument_list|)
operator|==
name|insn
condition|)
name|BLOCK_HEAD
argument_list|(
name|chain
operator|->
name|block
argument_list|)
operator|=
name|NEXT_INSN
argument_list|(
name|before_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|BLOCK_END
argument_list|(
name|chain
operator|->
name|block
argument_list|)
operator|==
name|insn
condition|)
name|BLOCK_END
argument_list|(
name|chain
operator|->
name|block
argument_list|)
operator|=
name|PREV_INSN
argument_list|(
name|following_insn
argument_list|)
expr_stmt|;
block|}
comment|/* For all the spill regs newly reloaded in this instruction,      record what they were reloaded from, so subsequent instructions      can inherit the reloads.       Update spill_reg_store for the reloads of this insn.      Copy the elements that were updated in the loop above.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_reloads
condition|;
name|j
operator|++
control|)
block|{
specifier|register
name|int
name|r
init|=
name|reload_order
index|[
name|j
index|]
decl_stmt|;
specifier|register
name|int
name|i
init|=
name|reload_spill_index
index|[
name|r
index|]
decl_stmt|;
comment|/* If this is a non-inherited input reload from a pseudo, we must          clear any memory of a previous store to the same pseudo.  Only do          something if there will not be an output reload for the pseudo          being reloaded.  */
if|if
condition|(
name|reload_in_reg
index|[
name|r
index|]
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|reload_inherited
index|[
name|r
index|]
operator|||
name|reload_override_in
index|[
name|r
index|]
operator|)
condition|)
block|{
name|rtx
name|reg
init|=
name|reload_in_reg
index|[
name|r
index|]
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
condition|)
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|!
name|reg_has_output_reload
index|[
name|REGNO
argument_list|(
name|reg
argument_list|)
index|]
condition|)
block|{
name|int
name|nregno
init|=
name|REGNO
argument_list|(
name|reg
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg_last_reload_reg
index|[
name|nregno
index|]
condition|)
block|{
name|int
name|last_regno
init|=
name|REGNO
argument_list|(
name|reg_last_reload_reg
index|[
name|nregno
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg_reloaded_contents
index|[
name|last_regno
index|]
operator|==
name|nregno
condition|)
name|spill_reg_store
index|[
name|last_regno
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
comment|/* I is nonneg if this reload used a register. 	 If reload_reg_rtx[r] is 0, this is an optional reload 	 that we opted to ignore.  */
if|if
condition|(
name|i
operator|>=
literal|0
operator|&&
name|reload_reg_rtx
index|[
name|r
index|]
operator|!=
literal|0
condition|)
block|{
name|int
name|nr
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|i
argument_list|,
name|GET_MODE
argument_list|(
name|reload_reg_rtx
index|[
name|r
index|]
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|k
decl_stmt|;
name|int
name|part_reaches_end
init|=
literal|0
decl_stmt|;
name|int
name|all_reaches_end
init|=
literal|1
decl_stmt|;
comment|/* For a multi register reload, we need to check if all or part 	     of the value lives to the end.  */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|nr
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|reload_reg_reaches_end_p
argument_list|(
name|i
operator|+
name|k
argument_list|,
name|reload_opnum
index|[
name|r
index|]
argument_list|,
name|reload_when_needed
index|[
name|r
index|]
argument_list|)
condition|)
name|part_reaches_end
operator|=
literal|1
expr_stmt|;
else|else
name|all_reaches_end
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Ignore reloads that don't reach the end of the insn in 	     entirety.  */
if|if
condition|(
name|all_reaches_end
condition|)
block|{
comment|/* First, clear out memory of what used to be in this spill reg. 		 If consecutive registers are used, clear them all.  */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|nr
condition|;
name|k
operator|++
control|)
name|CLEAR_HARD_REG_BIT
argument_list|(
name|reg_reloaded_valid
argument_list|,
name|i
operator|+
name|k
argument_list|)
expr_stmt|;
comment|/* Maybe the spill reg contains a copy of reload_out.  */
if|if
condition|(
name|reload_out
index|[
name|r
index|]
operator|!=
literal|0
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|reload_out
index|[
name|r
index|]
argument_list|)
operator|==
name|REG
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
operator|||
operator|!
name|reload_out_reg
index|[
name|r
index|]
endif|#
directive|endif
operator|||
name|GET_CODE
argument_list|(
name|reload_out_reg
index|[
name|r
index|]
argument_list|)
operator|==
name|REG
operator|)
condition|)
block|{
name|rtx
name|out
init|=
operator|(
name|GET_CODE
argument_list|(
name|reload_out
index|[
name|r
index|]
argument_list|)
operator|==
name|REG
condition|?
name|reload_out
index|[
name|r
index|]
else|:
name|reload_out_reg
index|[
name|r
index|]
condition|?
name|reload_out_reg
index|[
name|r
index|]
comment|/* AUTO_INC */
else|:
name|XEXP
argument_list|(
name|reload_in_reg
index|[
name|r
index|]
argument_list|,
literal|0
argument_list|)
operator|)
decl_stmt|;
specifier|register
name|int
name|nregno
init|=
name|REGNO
argument_list|(
name|out
argument_list|)
decl_stmt|;
name|int
name|nnr
init|=
operator|(
name|nregno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|?
literal|1
else|:
name|HARD_REGNO_NREGS
argument_list|(
name|nregno
argument_list|,
name|GET_MODE
argument_list|(
name|reload_reg_rtx
index|[
name|r
index|]
argument_list|)
argument_list|)
operator|)
decl_stmt|;
name|spill_reg_store
index|[
name|i
index|]
operator|=
name|new_spill_reg_store
index|[
name|i
index|]
expr_stmt|;
name|spill_reg_stored_to
index|[
name|i
index|]
operator|=
name|out
expr_stmt|;
name|reg_last_reload_reg
index|[
name|nregno
index|]
operator|=
name|reload_reg_rtx
index|[
name|r
index|]
expr_stmt|;
comment|/* If NREGNO is a hard register, it may occupy more than 		     one register.  If it does, say what is in the  		     rest of the registers assuming that both registers 		     agree on how many words the object takes.  If not, 		     invalidate the subsequent registers.  */
if|if
condition|(
name|nregno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
for|for
control|(
name|k
operator|=
literal|1
init|;
name|k
operator|<
name|nnr
condition|;
name|k
operator|++
control|)
name|reg_last_reload_reg
index|[
name|nregno
operator|+
name|k
index|]
operator|=
operator|(
name|nr
operator|==
name|nnr
condition|?
name|gen_rtx_REG
argument_list|(
name|reg_raw_mode
index|[
name|REGNO
argument_list|(
name|reload_reg_rtx
index|[
name|r
index|]
argument_list|)
operator|+
name|k
index|]
argument_list|,
name|REGNO
argument_list|(
name|reload_reg_rtx
index|[
name|r
index|]
argument_list|)
operator|+
name|k
argument_list|)
else|:
literal|0
operator|)
expr_stmt|;
comment|/* Now do the inverse operation.  */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|nr
condition|;
name|k
operator|++
control|)
block|{
name|CLEAR_HARD_REG_BIT
argument_list|(
name|reg_reloaded_dead
argument_list|,
name|i
operator|+
name|k
argument_list|)
expr_stmt|;
name|reg_reloaded_contents
index|[
name|i
operator|+
name|k
index|]
operator|=
operator|(
name|nregno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
name|nr
operator|!=
name|nnr
condition|?
name|nregno
else|:
name|nregno
operator|+
name|k
operator|)
expr_stmt|;
name|reg_reloaded_insn
index|[
name|i
operator|+
name|k
index|]
operator|=
name|insn
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|reg_reloaded_valid
argument_list|,
name|i
operator|+
name|k
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Maybe the spill reg contains a copy of reload_in.  Only do 		 something if there will not be an output reload for 		 the register being reloaded.  */
elseif|else
if|if
condition|(
name|reload_out_reg
index|[
name|r
index|]
operator|==
literal|0
operator|&&
name|reload_in
index|[
name|r
index|]
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|reload_in
index|[
name|r
index|]
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|reload_in
index|[
name|r
index|]
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|!
name|reg_has_output_reload
index|[
name|REGNO
argument_list|(
name|reload_in
index|[
name|r
index|]
argument_list|)
index|]
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|reload_in_reg
index|[
name|r
index|]
argument_list|)
operator|==
name|REG
operator|&&
operator|!
name|reg_has_output_reload
index|[
name|REGNO
argument_list|(
name|reload_in_reg
index|[
name|r
index|]
argument_list|)
index|]
operator|)
operator|)
operator|&&
operator|!
name|reg_set_p
argument_list|(
name|reload_reg_rtx
index|[
name|r
index|]
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
block|{
specifier|register
name|int
name|nregno
decl_stmt|;
name|int
name|nnr
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reload_in
index|[
name|r
index|]
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|reload_in
index|[
name|r
index|]
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|nregno
operator|=
name|REGNO
argument_list|(
name|reload_in
index|[
name|r
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|reload_in_reg
index|[
name|r
index|]
argument_list|)
operator|==
name|REG
condition|)
name|nregno
operator|=
name|REGNO
argument_list|(
name|reload_in_reg
index|[
name|r
index|]
argument_list|)
expr_stmt|;
else|else
name|nregno
operator|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|reload_in_reg
index|[
name|r
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|nnr
operator|=
operator|(
name|nregno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|?
literal|1
else|:
name|HARD_REGNO_NREGS
argument_list|(
name|nregno
argument_list|,
name|GET_MODE
argument_list|(
name|reload_reg_rtx
index|[
name|r
index|]
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|reg_last_reload_reg
index|[
name|nregno
index|]
operator|=
name|reload_reg_rtx
index|[
name|r
index|]
expr_stmt|;
if|if
condition|(
name|nregno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
for|for
control|(
name|k
operator|=
literal|1
init|;
name|k
operator|<
name|nnr
condition|;
name|k
operator|++
control|)
name|reg_last_reload_reg
index|[
name|nregno
operator|+
name|k
index|]
operator|=
operator|(
name|nr
operator|==
name|nnr
condition|?
name|gen_rtx_REG
argument_list|(
name|reg_raw_mode
index|[
name|REGNO
argument_list|(
name|reload_reg_rtx
index|[
name|r
index|]
argument_list|)
operator|+
name|k
index|]
argument_list|,
name|REGNO
argument_list|(
name|reload_reg_rtx
index|[
name|r
index|]
argument_list|)
operator|+
name|k
argument_list|)
else|:
literal|0
operator|)
expr_stmt|;
comment|/* Unless we inherited this reload, show we haven't 		     recently done a store. 		     Previous stores of inherited auto_inc expressions 		     also have to be discarded.  */
if|if
condition|(
operator|!
name|reload_inherited
index|[
name|r
index|]
operator|||
operator|(
name|reload_out
index|[
name|r
index|]
operator|&&
operator|!
name|reload_out_reg
index|[
name|r
index|]
operator|)
condition|)
name|spill_reg_store
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|nr
condition|;
name|k
operator|++
control|)
block|{
name|CLEAR_HARD_REG_BIT
argument_list|(
name|reg_reloaded_dead
argument_list|,
name|i
operator|+
name|k
argument_list|)
expr_stmt|;
name|reg_reloaded_contents
index|[
name|i
operator|+
name|k
index|]
operator|=
operator|(
name|nregno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
name|nr
operator|!=
name|nnr
condition|?
name|nregno
else|:
name|nregno
operator|+
name|k
operator|)
expr_stmt|;
name|reg_reloaded_insn
index|[
name|i
operator|+
name|k
index|]
operator|=
name|insn
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|reg_reloaded_valid
argument_list|,
name|i
operator|+
name|k
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* However, if part of the reload reaches the end, then we must 	     invalidate the old info for the part that survives to the end.  */
elseif|else
if|if
condition|(
name|part_reaches_end
condition|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|nr
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|reload_reg_reaches_end_p
argument_list|(
name|i
operator|+
name|k
argument_list|,
name|reload_opnum
index|[
name|r
index|]
argument_list|,
name|reload_when_needed
index|[
name|r
index|]
argument_list|)
condition|)
name|CLEAR_HARD_REG_BIT
argument_list|(
name|reg_reloaded_valid
argument_list|,
name|i
operator|+
name|k
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* The following if-statement was #if 0'd in 1.34 (or before...). 	 It's reenabled in 1.35 because supposedly nothing else 	 deals with this problem.  */
comment|/* If a register gets output-reloaded from a non-spill register, 	 that invalidates any previous reloaded copy of it. 	 But forget_old_reloads_1 won't get to see it, because 	 it thinks only about the original insn.  So invalidate it here.  */
if|if
condition|(
name|i
operator|<
literal|0
operator|&&
name|reload_out
index|[
name|r
index|]
operator|!=
literal|0
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|reload_out
index|[
name|r
index|]
argument_list|)
operator|==
name|REG
operator|||
operator|(
name|GET_CODE
argument_list|(
name|reload_out
index|[
name|r
index|]
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|reload_out_reg
index|[
name|r
index|]
argument_list|)
operator|==
name|REG
operator|)
operator|)
condition|)
block|{
name|rtx
name|out
init|=
operator|(
name|GET_CODE
argument_list|(
name|reload_out
index|[
name|r
index|]
argument_list|)
operator|==
name|REG
condition|?
name|reload_out
index|[
name|r
index|]
else|:
name|reload_out_reg
index|[
name|r
index|]
operator|)
decl_stmt|;
specifier|register
name|int
name|nregno
init|=
name|REGNO
argument_list|(
name|out
argument_list|)
decl_stmt|;
if|if
condition|(
name|nregno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|rtx
name|src_reg
decl_stmt|,
name|store_insn
decl_stmt|;
name|reg_last_reload_reg
index|[
name|nregno
index|]
operator|=
literal|0
expr_stmt|;
comment|/* If we can find a hard register that is stored, record 		 the storing insn so that we may delete this insn with 		 delete_output_reload.  */
name|src_reg
operator|=
name|reload_reg_rtx
index|[
name|r
index|]
expr_stmt|;
comment|/* If this is an optional reload, try to find the source reg 		 from an input reload.  */
if|if
condition|(
operator|!
name|src_reg
condition|)
block|{
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|set
operator|&&
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|==
name|reload_out
index|[
name|r
index|]
condition|)
block|{
name|int
name|k
decl_stmt|;
name|src_reg
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|store_insn
operator|=
name|insn
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|n_reloads
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|reload_in
index|[
name|k
index|]
operator|==
name|src_reg
condition|)
block|{
name|src_reg
operator|=
name|reload_reg_rtx
index|[
name|k
index|]
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
else|else
name|store_insn
operator|=
name|new_spill_reg_store
index|[
name|REGNO
argument_list|(
name|src_reg
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|src_reg
operator|&&
name|GET_CODE
argument_list|(
name|src_reg
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|src_reg
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|src_regno
init|=
name|REGNO
argument_list|(
name|src_reg
argument_list|)
decl_stmt|;
name|int
name|nr
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|src_regno
argument_list|,
name|reload_mode
index|[
name|r
index|]
argument_list|)
decl_stmt|;
comment|/* The place where to find a death note varies with 		     PRESERVE_DEATH_INFO_REGNO_P .  The condition is not 		     necessarily checked exactly in the code that moves 		     notes, so just check both locations.  */
name|rtx
name|note
init|=
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|src_regno
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|note
condition|)
name|note
operator|=
name|find_regno_note
argument_list|(
name|store_insn
argument_list|,
name|REG_DEAD
argument_list|,
name|src_regno
argument_list|)
expr_stmt|;
while|while
condition|(
name|nr
operator|--
operator|>
literal|0
condition|)
block|{
name|spill_reg_store
index|[
name|src_regno
operator|+
name|nr
index|]
operator|=
name|store_insn
expr_stmt|;
name|spill_reg_stored_to
index|[
name|src_regno
operator|+
name|nr
index|]
operator|=
name|out
expr_stmt|;
name|reg_reloaded_contents
index|[
name|src_regno
operator|+
name|nr
index|]
operator|=
name|nregno
expr_stmt|;
name|reg_reloaded_insn
index|[
name|src_regno
operator|+
name|nr
index|]
operator|=
name|store_insn
expr_stmt|;
name|CLEAR_HARD_REG_BIT
argument_list|(
name|reg_reloaded_dead
argument_list|,
name|src_regno
operator|+
name|nr
argument_list|)
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|reg_reloaded_valid
argument_list|,
name|src_regno
operator|+
name|nr
argument_list|)
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|reg_is_output_reload
argument_list|,
name|src_regno
operator|+
name|nr
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|reg_reloaded_died
argument_list|,
name|src_regno
argument_list|)
expr_stmt|;
else|else
name|CLEAR_HARD_REG_BIT
argument_list|(
name|reg_reloaded_died
argument_list|,
name|src_regno
argument_list|)
expr_stmt|;
block|}
name|reg_last_reload_reg
index|[
name|nregno
index|]
operator|=
name|src_reg
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|num_regs
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|nregno
argument_list|,
name|GET_MODE
argument_list|(
name|reload_out
index|[
name|r
index|]
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|num_regs
operator|--
operator|>
literal|0
condition|)
name|reg_last_reload_reg
index|[
name|nregno
operator|+
name|num_regs
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
name|IOR_HARD_REG_SET
argument_list|(
name|reg_reloaded_dead
argument_list|,
name|reg_reloaded_died
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit code to perform a reload from IN (which may be a reload register) to    OUT (which may also be a reload register).  IN or OUT is from operand    OPNUM with reload type TYPE.      Returns first insn emitted.  */
end_comment

begin_function
name|rtx
name|gen_reload
parameter_list|(
name|out
parameter_list|,
name|in
parameter_list|,
name|opnum
parameter_list|,
name|type
parameter_list|)
name|rtx
name|out
decl_stmt|;
name|rtx
name|in
decl_stmt|;
name|int
name|opnum
decl_stmt|;
name|enum
name|reload_type
name|type
decl_stmt|;
block|{
name|rtx
name|last
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
comment|/* If IN is a paradoxical SUBREG, remove it and try to put the      opposite SUBREG on OUT.  Likewise for a paradoxical SUBREG on OUT.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|in
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|tem
operator|=
name|gen_lowpart_common
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|)
argument_list|,
name|out
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|in
operator|=
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
operator|,
name|out
operator|=
name|tem
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|out
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|out
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|out
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|tem
operator|=
name|gen_lowpart_common
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|out
argument_list|)
argument_list|)
argument_list|,
name|in
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|out
operator|=
name|SUBREG_REG
argument_list|(
name|out
argument_list|)
operator|,
name|in
operator|=
name|tem
expr_stmt|;
comment|/* How to do this reload can get quite tricky.  Normally, we are being      asked to reload a simple operand, such as a MEM, a constant, or a pseudo      register that didn't get a hard register.  In that case we can just      call emit_move_insn.       We can also be asked to reload a PLUS that adds a register or a MEM to      another register, constant or MEM.  This can occur during frame pointer      elimination and while reloading addresses.  This case is handled by      trying to emit a single insn to perform the add.  If it is not valid,      we use a two insn sequence.       Finally, we could be called to handle an 'o' constraint by putting      an address into a register.  In that case, we first try to do this      with a named pattern of "reload_load_address".  If no such pattern      exists, we just emit a SET insn and hope for the best (it will normally      be valid on machines that use 'o').       This entire process is made complex because reload will never      process the insns we generate here and so we must ensure that      they will fit their constraints and also by the fact that parts of      IN might be being reloaded separately and replaced with spill registers.      Because of this, we are, in some sense, just guessing the right approach      here.  The one listed above seems to work.       ??? At some point, this whole thing needs to be rethought.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|PLUS
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|in
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|in
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|in
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|in
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|in
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|||
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|in
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|in
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|MEM
operator|)
condition|)
block|{
comment|/* We need to compute the sum of a register or a MEM and another 	 register, constant, or MEM, and put it into the reload 	 register.  The best possible way of doing this is if the machine 	 has a three-operand ADD insn that accepts the required operands.  	 The simplest approach is to try to generate such an insn and see if it 	 is recognized and matches its constraints.  If so, it can be used.  	 It might be better not to actually emit the insn unless it is valid, 	 but we need to pass the insn as an operand to `recog' and 	 `extract_insn' and it is simpler to emit and then delete the insn if 	 not valid than to dummy things up.  */
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|,
name|tem
decl_stmt|,
name|insn
decl_stmt|;
name|int
name|code
decl_stmt|;
name|op0
operator|=
name|find_replacement
argument_list|(
operator|&
name|XEXP
argument_list|(
name|in
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|op1
operator|=
name|find_replacement
argument_list|(
operator|&
name|XEXP
argument_list|(
name|in
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Since constraint checking is strict, commutativity won't be 	 checked, so we need to do that here to avoid spurious failure 	 if the add instruction is two-address and the second operand 	 of the add is the same as the reload reg, which is frequently 	 the case.  If the insn would be A = B + A, rearrange it so 	 it will be A = A + B as constrain_operands expects.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|in
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|out
argument_list|)
operator|==
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|in
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|tem
operator|=
name|op0
operator|,
name|op0
operator|=
name|op1
operator|,
name|op1
operator|=
name|tem
expr_stmt|;
if|if
condition|(
name|op0
operator|!=
name|XEXP
argument_list|(
name|in
argument_list|,
literal|0
argument_list|)
operator|||
name|op1
operator|!=
name|XEXP
argument_list|(
name|in
argument_list|,
literal|1
argument_list|)
condition|)
name|in
operator|=
name|gen_rtx_PLUS
argument_list|(
name|GET_MODE
argument_list|(
name|in
argument_list|)
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|out
argument_list|,
name|in
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|recog_memoized
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|>=
literal|0
condition|)
block|{
name|extract_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* We want constrain operands to treat this insn strictly in 	     its validity determination, i.e., the way it would after reload 	     has completed.  */
if|if
condition|(
name|constrain_operands
argument_list|(
literal|1
argument_list|)
condition|)
return|return
name|insn
return|;
block|}
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
comment|/* If that failed, we must use a conservative two-insn sequence. 	 use move to copy constant, MEM, or pseudo register to the reload 	 register since "move" will be able to handle an arbitrary operand, 	 unlike add which can't, in general.  Then add the registers.  	 If there is another way to do this for a specific machine, a 	 DEFINE_PEEPHOLE should be specified that recognizes the sequence 	 we emit below.  */
name|code
operator|=
operator|(
name|int
operator|)
name|add_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|GET_MODE
argument_list|(
name|out
argument_list|)
index|]
operator|.
name|insn_code
expr_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op1
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|MEM
operator|||
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|SUBREG
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|op1
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|||
operator|(
name|code
operator|!=
name|CODE_FOR_nothing
operator|&&
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
name|code
index|]
index|[
literal|2
index|]
call|)
argument_list|(
name|op1
argument_list|,
name|insn_operand_mode
index|[
name|code
index|]
index|[
literal|2
index|]
argument_list|)
operator|)
condition|)
name|tem
operator|=
name|op0
operator|,
name|op0
operator|=
name|op1
operator|,
name|op1
operator|=
name|tem
expr_stmt|;
name|gen_reload
argument_list|(
name|out
argument_list|,
name|op0
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* If OP0 and OP1 are the same, we can use OUT for OP1. 	 This fixes a problem on the 32K where the stack pointer cannot 	 be used as an operand of an add insn.  */
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
condition|)
name|op1
operator|=
name|out
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_add2_insn
argument_list|(
name|out
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If that failed, copy the address register to the reload register. 	 Then add the constant to the reload register.  */
name|code
operator|=
name|recog_memoized
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|>=
literal|0
condition|)
block|{
name|extract_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* We want constrain operands to treat this insn strictly in 	     its validity determination, i.e., the way it would after reload 	     has completed.  */
if|if
condition|(
name|constrain_operands
argument_list|(
literal|1
argument_list|)
condition|)
block|{
comment|/* Add a REG_EQUIV note so that find_equiv_reg can find it.  */
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_EQUIV
argument_list|,
name|in
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|insn
return|;
block|}
block|}
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
name|gen_reload
argument_list|(
name|out
argument_list|,
name|op1
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_add2_insn
argument_list|(
name|out
argument_list|,
name|op0
argument_list|)
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_EQUIV
argument_list|,
name|in
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SECONDARY_MEMORY_NEEDED
comment|/* If we need a memory location to do the move, do it that way.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|in
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|GET_CODE
argument_list|(
name|out
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|out
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|SECONDARY_MEMORY_NEEDED
argument_list|(
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|in
argument_list|)
argument_list|)
argument_list|,
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|out
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|out
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Get the memory to use and rewrite both registers to its mode.  */
name|rtx
name|loc
init|=
name|get_secondary_mem
argument_list|(
name|in
argument_list|,
name|GET_MODE
argument_list|(
name|out
argument_list|)
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|loc
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|out
argument_list|)
condition|)
name|out
operator|=
name|gen_rtx_REG
argument_list|(
name|GET_MODE
argument_list|(
name|loc
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|out
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|loc
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|in
argument_list|)
condition|)
name|in
operator|=
name|gen_rtx_REG
argument_list|(
name|GET_MODE
argument_list|(
name|loc
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|in
argument_list|)
argument_list|)
expr_stmt|;
name|gen_reload
argument_list|(
name|loc
argument_list|,
name|in
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|gen_reload
argument_list|(
name|out
argument_list|,
name|loc
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* If IN is a simple operand, use gen_move_insn.  */
elseif|else
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|in
argument_list|)
argument_list|)
operator|==
literal|'o'
operator|||
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|SUBREG
condition|)
name|emit_insn
argument_list|(
name|gen_move_insn
argument_list|(
name|out
argument_list|,
name|in
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_reload_load_address
elseif|else
if|if
condition|(
name|HAVE_reload_load_address
condition|)
name|emit_insn
argument_list|(
name|gen_reload_load_address
argument_list|(
name|out
argument_list|,
name|in
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Otherwise, just write (set OUT IN) and hope for the best.  */
else|else
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|out
argument_list|,
name|in
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Return the first insn emitted.      We can not just return get_last_insn, because there may have      been multiple instructions emitted.  Also note that gen_move_insn may      emit more than one insn itself, so we can not assume that there is one      insn emitted per emit_insn_before call.  */
return|return
name|last
condition|?
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
else|:
name|get_insns
argument_list|()
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Delete a previously made output-reload    whose result we now believe is not needed.    First we double-check.     INSN is the insn now being processed.    LAST_RELOAD_REG is the hard register number for which we want to delete    the last output reload.    J is the reload-number that originally used REG.  The caller has made    certain that reload J doesn't use REG any longer for input.  */
end_comment

begin_function
specifier|static
name|void
name|delete_output_reload
parameter_list|(
name|insn
parameter_list|,
name|j
parameter_list|,
name|last_reload_reg
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|int
name|j
decl_stmt|;
name|int
name|last_reload_reg
decl_stmt|;
block|{
name|rtx
name|output_reload_insn
init|=
name|spill_reg_store
index|[
name|last_reload_reg
index|]
decl_stmt|;
name|rtx
name|reg
init|=
name|spill_reg_stored_to
index|[
name|last_reload_reg
index|]
decl_stmt|;
name|int
name|k
decl_stmt|;
name|int
name|n_occurrences
decl_stmt|;
name|int
name|n_inherited
init|=
literal|0
decl_stmt|;
specifier|register
name|rtx
name|i1
decl_stmt|;
name|rtx
name|substed
decl_stmt|;
comment|/* Get the raw pseudo-register referred to.  */
while|while
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
condition|)
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|substed
operator|=
name|reg_equiv_memory_loc
index|[
name|REGNO
argument_list|(
name|reg
argument_list|)
index|]
expr_stmt|;
comment|/* This is unsafe if the operand occurs more often in the current      insn than it is inherited.  */
for|for
control|(
name|k
operator|=
name|n_reloads
operator|-
literal|1
init|;
name|k
operator|>=
literal|0
condition|;
name|k
operator|--
control|)
block|{
name|rtx
name|reg2
init|=
name|reload_in
index|[
name|k
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|reg2
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg2
argument_list|)
operator|==
name|MEM
operator|||
name|reload_override_in
index|[
name|k
index|]
condition|)
name|reg2
operator|=
name|reload_in_reg
index|[
name|k
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
if|if
condition|(
name|reload_out
index|[
name|k
index|]
operator|&&
operator|!
name|reload_out_reg
index|[
name|k
index|]
condition|)
name|reg2
operator|=
name|XEXP
argument_list|(
name|reload_in_reg
index|[
name|k
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|GET_CODE
argument_list|(
name|reg2
argument_list|)
operator|==
name|SUBREG
condition|)
name|reg2
operator|=
name|SUBREG_REG
argument_list|(
name|reg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|reg2
argument_list|,
name|reg
argument_list|)
condition|)
block|{
if|if
condition|(
name|reload_inherited
index|[
name|k
index|]
operator|||
name|reload_override_in
index|[
name|k
index|]
operator|||
name|k
operator|==
name|j
condition|)
block|{
name|n_inherited
operator|++
expr_stmt|;
name|reg2
operator|=
name|reload_out_reg
index|[
name|k
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|reg2
condition|)
continue|continue;
while|while
condition|(
name|GET_CODE
argument_list|(
name|reg2
argument_list|)
operator|==
name|SUBREG
condition|)
name|reg2
operator|=
name|XEXP
argument_list|(
name|reg2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|reg2
argument_list|,
name|reg
argument_list|)
condition|)
name|n_inherited
operator|++
expr_stmt|;
block|}
else|else
return|return;
block|}
block|}
name|n_occurrences
operator|=
name|count_occurrences
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|substed
condition|)
name|n_occurrences
operator|+=
name|count_occurrences
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|substed
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_occurrences
operator|>
name|n_inherited
condition|)
return|return;
comment|/* If the pseudo-reg we are reloading is no longer referenced      anywhere between the store into it and here,      and no jumps or labels intervene, then the value can get      here through the reload reg alone.      Otherwise, give up--return.  */
for|for
control|(
name|i1
operator|=
name|NEXT_INSN
argument_list|(
name|output_reload_insn
argument_list|)
init|;
name|i1
operator|!=
name|insn
condition|;
name|i1
operator|=
name|NEXT_INSN
argument_list|(
name|i1
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|i1
argument_list|)
operator|==
name|CODE_LABEL
operator|||
name|GET_CODE
argument_list|(
name|i1
argument_list|)
operator|==
name|JUMP_INSN
condition|)
return|return;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|i1
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|i1
argument_list|)
operator|==
name|CALL_INSN
operator|)
operator|&&
name|reg_mentioned_p
argument_list|(
name|reg
argument_list|,
name|PATTERN
argument_list|(
name|i1
argument_list|)
argument_list|)
condition|)
block|{
comment|/* If this is USE in front of INSN, we only have to check that 	     there are no more references than accounted for by inheritance.  */
while|while
condition|(
name|GET_CODE
argument_list|(
name|i1
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|i1
argument_list|)
argument_list|)
operator|==
name|USE
condition|)
block|{
name|n_occurrences
operator|+=
name|rtx_equal_p
argument_list|(
name|reg
argument_list|,
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|i1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
literal|0
expr_stmt|;
name|i1
operator|=
name|NEXT_INSN
argument_list|(
name|i1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n_occurrences
operator|<=
name|n_inherited
operator|&&
name|i1
operator|==
name|insn
condition|)
break|break;
return|return;
block|}
block|}
comment|/* The caller has already checked that REG dies or is set in INSN.      It has also checked that we are optimizing, and thus some inaccurancies      in the debugging information are acceptable.      So we could just delete output_reload_insn.      But in some cases we can improve the debugging information without      sacrificing optimization - maybe even improving the code:      See if the pseudo reg has been completely replaced      with reload regs.  If so, delete the store insn      and forget we had a stack slot for the pseudo.  */
if|if
condition|(
name|reload_out
index|[
name|j
index|]
operator|!=
name|reload_in
index|[
name|j
index|]
operator|&&
name|REG_N_DEATHS
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|==
literal|1
operator|&&
name|REG_N_SETS
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|==
literal|1
operator|&&
name|REG_BASIC_BLOCK
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|>=
literal|0
operator|&&
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|i2
decl_stmt|;
comment|/* We know that it was used only between here 	 and the beginning of the current basic block. 	 (We also know that the last use before INSN was 	 the output reload we are thinking of deleting, but never mind that.) 	 Search that range; see if any ref remains.  */
for|for
control|(
name|i2
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
init|;
name|i2
condition|;
name|i2
operator|=
name|PREV_INSN
argument_list|(
name|i2
argument_list|)
control|)
block|{
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|i2
argument_list|)
decl_stmt|;
comment|/* Uses which just store in the pseudo don't count, 	     since if they are the only uses, they are dead.  */
if|if
condition|(
name|set
operator|!=
literal|0
operator|&&
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|==
name|reg
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|i2
argument_list|)
operator|==
name|CODE_LABEL
operator|||
name|GET_CODE
argument_list|(
name|i2
argument_list|)
operator|==
name|JUMP_INSN
condition|)
break|break;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|i2
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|i2
argument_list|)
operator|==
name|CALL_INSN
operator|)
operator|&&
name|reg_mentioned_p
argument_list|(
name|reg
argument_list|,
name|PATTERN
argument_list|(
name|i2
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Some other ref remains; just delete the output reload we 		 know to be dead.  */
name|delete_address_reloads
argument_list|(
name|output_reload_insn
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|PUT_CODE
argument_list|(
name|output_reload_insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|output_reload_insn
argument_list|)
operator|=
literal|0
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|output_reload_insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
return|return;
block|}
block|}
comment|/* Delete the now-dead stores into this pseudo.  */
for|for
control|(
name|i2
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
init|;
name|i2
condition|;
name|i2
operator|=
name|PREV_INSN
argument_list|(
name|i2
argument_list|)
control|)
block|{
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|i2
argument_list|)
decl_stmt|;
if|if
condition|(
name|set
operator|!=
literal|0
operator|&&
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|==
name|reg
condition|)
block|{
name|delete_address_reloads
argument_list|(
name|i2
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* This might be a basic block head, 		 thus don't use delete_insn.  */
name|PUT_CODE
argument_list|(
name|i2
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|i2
argument_list|)
operator|=
literal|0
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|i2
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|i2
argument_list|)
operator|==
name|CODE_LABEL
operator|||
name|GET_CODE
argument_list|(
name|i2
argument_list|)
operator|==
name|JUMP_INSN
condition|)
break|break;
block|}
comment|/* For the debugging info, 	 say the pseudo lives in this reload reg.  */
name|reg_renumber
index|[
name|REGNO
argument_list|(
name|reg
argument_list|)
index|]
operator|=
name|REGNO
argument_list|(
name|reload_reg_rtx
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|alter_reg
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|delete_address_reloads
argument_list|(
name|output_reload_insn
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|PUT_CODE
argument_list|(
name|output_reload_insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|output_reload_insn
argument_list|)
operator|=
literal|0
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|output_reload_insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We are going to delete DEAD_INSN.  Recursively delete loads of    reload registers used in DEAD_INSN that are not used till CURRENT_INSN.    CURRENT_INSN is being reloaded, so we have to check its reloads too.  */
end_comment

begin_function
specifier|static
name|void
name|delete_address_reloads
parameter_list|(
name|dead_insn
parameter_list|,
name|current_insn
parameter_list|)
name|rtx
name|dead_insn
decl_stmt|,
name|current_insn
decl_stmt|;
block|{
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|dead_insn
argument_list|)
decl_stmt|;
name|rtx
name|set2
decl_stmt|,
name|dst
decl_stmt|,
name|prev
decl_stmt|,
name|next
decl_stmt|;
if|if
condition|(
name|set
condition|)
block|{
name|rtx
name|dst
init|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|MEM
condition|)
name|delete_address_reloads_1
argument_list|(
name|dead_insn
argument_list|,
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
argument_list|,
name|current_insn
argument_list|)
expr_stmt|;
block|}
comment|/* If we deleted the store from a reloaded post_{in,de}c expression,      we can delete the matching adds.  */
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|dead_insn
argument_list|)
expr_stmt|;
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|dead_insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prev
operator|||
operator|!
name|next
condition|)
return|return;
name|set
operator|=
name|single_set
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|set2
operator|=
name|single_set
argument_list|(
name|prev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set
operator|||
operator|!
name|set2
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|!=
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set2
argument_list|)
argument_list|)
operator|!=
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set2
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return;
name|dst
operator|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|dst
argument_list|,
name|SET_DEST
argument_list|(
name|set2
argument_list|)
argument_list|)
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|dst
argument_list|,
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|dst
argument_list|,
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set2
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set2
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
return|return;
name|delete_insn
argument_list|(
name|prev
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Subfunction of delete_address_reloads: process registers found in X.  */
end_comment

begin_function
specifier|static
name|void
name|delete_address_reloads_1
parameter_list|(
name|dead_insn
parameter_list|,
name|x
parameter_list|,
name|current_insn
parameter_list|)
name|rtx
name|dead_insn
decl_stmt|,
name|x
decl_stmt|,
name|current_insn
decl_stmt|;
block|{
name|rtx
name|prev
decl_stmt|,
name|set
decl_stmt|,
name|dst
decl_stmt|,
name|i2
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|!=
name|REG
condition|)
block|{
name|char
modifier|*
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|delete_address_reloads_1
argument_list|(
name|dead_insn
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|current_insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|delete_address_reloads_1
argument_list|(
name|dead_insn
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|current_insn
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
if|if
condition|(
name|spill_reg_order
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
operator|<
literal|0
condition|)
return|return;
comment|/* Scan backwards for the insn that sets x.  This might be a way back due      to inheritance.  */
for|for
control|(
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|dead_insn
argument_list|)
init|;
name|prev
condition|;
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|prev
argument_list|)
control|)
block|{
name|code
operator|=
name|GET_CODE
argument_list|(
name|prev
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|CODE_LABEL
operator|||
name|code
operator|==
name|JUMP_INSN
condition|)
return|return;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
literal|'i'
condition|)
continue|continue;
if|if
condition|(
name|reg_set_p
argument_list|(
name|x
argument_list|,
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|)
condition|)
break|break;
if|if
condition|(
name|reg_referenced_p
argument_list|(
name|x
argument_list|,
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|)
condition|)
return|return;
block|}
if|if
condition|(
operator|!
name|prev
operator|||
name|INSN_UID
argument_list|(
name|prev
argument_list|)
operator|<
name|reload_first_uid
condition|)
return|return;
comment|/* Check that PREV only sets the reload register.  */
name|set
operator|=
name|single_set
argument_list|(
name|prev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set
condition|)
return|return;
name|dst
operator|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|!=
name|REG
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|dst
argument_list|,
name|x
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|reg_set_p
argument_list|(
name|dst
argument_list|,
name|PATTERN
argument_list|(
name|dead_insn
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Check if DST was used in a later insn - 	 it might have been inherited.  */
for|for
control|(
name|i2
operator|=
name|NEXT_INSN
argument_list|(
name|dead_insn
argument_list|)
init|;
name|i2
condition|;
name|i2
operator|=
name|NEXT_INSN
argument_list|(
name|i2
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|i2
argument_list|)
operator|==
name|CODE_LABEL
condition|)
break|break;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|i2
argument_list|)
argument_list|)
operator|!=
literal|'i'
condition|)
continue|continue;
if|if
condition|(
name|reg_referenced_p
argument_list|(
name|dst
argument_list|,
name|PATTERN
argument_list|(
name|i2
argument_list|)
argument_list|)
condition|)
block|{
comment|/* If there is a reference to the register in the current insn, 		 it might be loaded in a non-inherited reload.  If no other 		 reload uses it, that means the register is set before 		 referenced.  */
if|if
condition|(
name|i2
operator|==
name|current_insn
condition|)
block|{
for|for
control|(
name|j
operator|=
name|n_reloads
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
operator|(
name|reload_reg_rtx
index|[
name|j
index|]
operator|==
name|dst
operator|&&
name|reload_inherited
index|[
name|j
index|]
operator|)
operator|||
name|reload_override_in
index|[
name|j
index|]
operator|==
name|dst
condition|)
return|return;
for|for
control|(
name|j
operator|=
name|n_reloads
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|reload_in
index|[
name|j
index|]
operator|&&
name|reload_reg_rtx
index|[
name|j
index|]
operator|==
name|dst
condition|)
break|break;
if|if
condition|(
name|j
operator|>=
literal|0
condition|)
break|break;
block|}
return|return;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|i2
argument_list|)
operator|==
name|JUMP_INSN
condition|)
break|break;
comment|/* If DST is still live at CURRENT_INSN, check if it is used for 	     any reload.  Note that even if CURRENT_INSN sets DST, we still 	     have to check the reloads.  */
if|if
condition|(
name|i2
operator|==
name|current_insn
condition|)
block|{
for|for
control|(
name|j
operator|=
name|n_reloads
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
operator|(
name|reload_reg_rtx
index|[
name|j
index|]
operator|==
name|dst
operator|&&
name|reload_inherited
index|[
name|j
index|]
operator|)
operator|||
name|reload_override_in
index|[
name|j
index|]
operator|==
name|dst
condition|)
return|return;
comment|/* ??? We can't finish the loop here, because dst might be 		 allocated to a pseudo in this block if no reload in this 		 block needs any of the clsses containing DST - see 		 spill_hard_reg.  There is no easy way to tell this, so we 		 have to scan till the end of the basic block.  */
block|}
if|if
condition|(
name|reg_set_p
argument_list|(
name|dst
argument_list|,
name|PATTERN
argument_list|(
name|i2
argument_list|)
argument_list|)
condition|)
break|break;
block|}
block|}
name|delete_address_reloads_1
argument_list|(
name|prev
argument_list|,
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|current_insn
argument_list|)
expr_stmt|;
name|reg_reloaded_contents
index|[
name|REGNO
argument_list|(
name|dst
argument_list|)
index|]
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Can't use delete_insn here because PREV might be a basic block head.  */
name|PUT_CODE
argument_list|(
name|prev
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|prev
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|prev
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output reload-insns to reload VALUE into RELOADREG.    VALUE is an autoincrement or autodecrement RTX whose operand    is a register or memory location;    so reloading involves incrementing that location.    IN is either identical to VALUE, or some cheaper place to reload from.     INC_AMOUNT is the number to increment or decrement by (always positive).    This cannot be deduced from VALUE.     Return the instruction that stores into RELOADREG.  */
end_comment

begin_function
specifier|static
name|rtx
name|inc_for_reload
parameter_list|(
name|reloadreg
parameter_list|,
name|in
parameter_list|,
name|value
parameter_list|,
name|inc_amount
parameter_list|)
name|rtx
name|reloadreg
decl_stmt|;
name|rtx
name|in
decl_stmt|,
name|value
decl_stmt|;
name|int
name|inc_amount
decl_stmt|;
block|{
comment|/* REG or MEM to be copied and incremented.  */
name|rtx
name|incloc
init|=
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* Nonzero if increment after copying.  */
name|int
name|post
init|=
operator|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|POST_DEC
operator|||
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|POST_INC
operator|)
decl_stmt|;
name|rtx
name|last
decl_stmt|;
name|rtx
name|inc
decl_stmt|;
name|rtx
name|add_insn
decl_stmt|;
name|int
name|code
decl_stmt|;
name|rtx
name|store
decl_stmt|;
name|rtx
name|real_in
init|=
name|in
operator|==
name|value
condition|?
name|XEXP
argument_list|(
name|in
argument_list|,
literal|0
argument_list|)
else|:
name|in
decl_stmt|;
comment|/* No hard register is equivalent to this register after      inc/dec operation.  If REG_LAST_RELOAD_REG were non-zero,      we could inc/dec that register as well (maybe even using it for      the source), but I'm not sure it's worth worrying about.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|incloc
argument_list|)
operator|==
name|REG
condition|)
name|reg_last_reload_reg
index|[
name|REGNO
argument_list|(
name|incloc
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|PRE_DEC
operator|||
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|POST_DEC
condition|)
name|inc_amount
operator|=
operator|-
name|inc_amount
expr_stmt|;
name|inc
operator|=
name|GEN_INT
argument_list|(
name|inc_amount
argument_list|)
expr_stmt|;
comment|/* If this is post-increment, first copy the location to the reload reg.  */
if|if
condition|(
name|post
operator|&&
name|real_in
operator|!=
name|reloadreg
condition|)
name|emit_insn
argument_list|(
name|gen_move_insn
argument_list|(
name|reloadreg
argument_list|,
name|real_in
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|==
name|value
condition|)
block|{
comment|/* See if we can directly increment INCLOC.  Use a method similar to 	 that in gen_reload.  */
name|last
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|add_insn
operator|=
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|incloc
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|GET_MODE
argument_list|(
name|incloc
argument_list|)
argument_list|,
name|incloc
argument_list|,
name|inc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|recog_memoized
argument_list|(
name|add_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|>=
literal|0
condition|)
block|{
name|extract_insn
argument_list|(
name|add_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|constrain_operands
argument_list|(
literal|1
argument_list|)
condition|)
block|{
comment|/* If this is a pre-increment and we have incremented the value 		 where it lives, copy the incremented value to RELOADREG to 		 be used as an address.  */
if|if
condition|(
operator|!
name|post
condition|)
name|emit_insn
argument_list|(
name|gen_move_insn
argument_list|(
name|reloadreg
argument_list|,
name|incloc
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|add_insn
return|;
block|}
block|}
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
comment|/* If couldn't do the increment directly, must increment in RELOADREG.      The way we do this depends on whether this is pre- or post-increment.      For pre-increment, copy INCLOC to the reload register, increment it      there, then save back.  */
if|if
condition|(
operator|!
name|post
condition|)
block|{
if|if
condition|(
name|in
operator|!=
name|reloadreg
condition|)
name|emit_insn
argument_list|(
name|gen_move_insn
argument_list|(
name|reloadreg
argument_list|,
name|real_in
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_add2_insn
argument_list|(
name|reloadreg
argument_list|,
name|inc
argument_list|)
argument_list|)
expr_stmt|;
name|store
operator|=
name|emit_insn
argument_list|(
name|gen_move_insn
argument_list|(
name|incloc
argument_list|,
name|reloadreg
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Postincrement. 	 Because this might be a jump insn or a compare, and because RELOADREG 	 may not be available after the insn in an input reload, we must do 	 the incrementation before the insn being reloaded for.  	 We have already copied IN to RELOADREG.  Increment the copy in 	 RELOADREG, save that back, then decrement RELOADREG so it has 	 the original value.  */
name|emit_insn
argument_list|(
name|gen_add2_insn
argument_list|(
name|reloadreg
argument_list|,
name|inc
argument_list|)
argument_list|)
expr_stmt|;
name|store
operator|=
name|emit_insn
argument_list|(
name|gen_move_insn
argument_list|(
name|incloc
argument_list|,
name|reloadreg
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_add2_insn
argument_list|(
name|reloadreg
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|inc_amount
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|store
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if we are certain that the constraint-string STRING allows    the hard register REG.  Return 0 if we can't be sure of this.  */
end_comment

begin_function
specifier|static
name|int
name|constraint_accepts_reg_p
parameter_list|(
name|string
parameter_list|,
name|reg
parameter_list|)
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
block|{
name|int
name|value
init|=
literal|0
decl_stmt|;
name|int
name|regno
init|=
name|true_regnum
argument_list|(
name|reg
argument_list|)
decl_stmt|;
name|int
name|c
decl_stmt|;
comment|/* Initialize for first alternative.  */
name|value
operator|=
literal|0
expr_stmt|;
comment|/* Check that each alternative contains `g' or `r'.  */
while|while
condition|(
literal|1
condition|)
switch|switch
condition|(
name|c
operator|=
operator|*
name|string
operator|++
condition|)
block|{
case|case
literal|0
case|:
comment|/* If an alternative lacks `g' or `r', we lose.  */
return|return
name|value
return|;
case|case
literal|','
case|:
comment|/* If an alternative lacks `g' or `r', we lose.  */
if|if
condition|(
name|value
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Initialize for next alternative.  */
name|value
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
case|case
literal|'r'
case|:
comment|/* Any general reg wins for this alternative.  */
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|GENERAL_REGS
index|]
argument_list|,
name|regno
argument_list|)
condition|)
name|value
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
comment|/* Any reg in specified class wins for this alternative.  */
block|{
name|enum
name|reg_class
name|class
init|=
name|REG_CLASS_FROM_LETTER
argument_list|(
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|class
index|]
argument_list|,
name|regno
argument_list|)
condition|)
name|value
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the number of places FIND appears within X, but don't count    an occurrence if some SET_DEST is FIND.  */
end_comment

begin_function
name|int
name|count_occurrences
parameter_list|(
name|x
parameter_list|,
name|find
parameter_list|)
specifier|register
name|rtx
name|x
decl_stmt|,
name|find
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|char
modifier|*
name|format_ptr
decl_stmt|;
name|int
name|count
decl_stmt|;
if|if
condition|(
name|x
operator|==
name|find
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
case|case
name|QUEUED
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CODE_LABEL
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
return|return
literal|0
return|;
case|case
name|MEM
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|find
argument_list|)
operator|==
name|MEM
operator|&&
name|rtx_equal_p
argument_list|(
name|x
argument_list|,
name|find
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|SET
case|:
if|if
condition|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|==
name|find
condition|)
return|return
name|count_occurrences
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|find
argument_list|)
return|;
break|break;
default|default:
break|break;
block|}
name|format_ptr
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|format_ptr
operator|++
condition|)
block|{
case|case
literal|'e'
case|:
name|count
operator|+=
name|count_occurrences
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|find
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
if|if
condition|(
name|XVEC
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|count
operator|+=
name|count_occurrences
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|find
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
return|return
name|count
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This array holds values which are equivalent to a hard register    during reload_cse_regs.  Each array element is an EXPR_LIST of    values.  Each time a hard register is set, we set the corresponding    array element to the value.  Each time a hard register is copied    into memory, we add the memory location to the corresponding array    element.  We don't store values or memory addresses with side    effects in this array.     If the value is a CONST_INT, then the mode of the containing    EXPR_LIST is the mode in which that CONST_INT was referenced.     We sometimes clobber a specific entry in a list.  In that case, we    just set XEXP (list-entry, 0) to 0.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|reg_values
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is a preallocated REG rtx which we use as a temporary in    reload_cse_invalidate_regno, so that we don't need to allocate a    new one each time through a loop in that function.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|invalidate_regno_rtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Invalidate any entries in reg_values which depend on REGNO,    including those for REGNO itself.  This is called if REGNO is    changing.  If CLOBBER is true, then always forget anything we    currently know about REGNO.  MODE is the mode of the assignment to    REGNO, which is used to determine how many hard registers are being    changed.  If MODE is VOIDmode, then only REGNO is being changed;    this is used when invalidating call clobbered registers across a    call.  */
end_comment

begin_function
specifier|static
name|void
name|reload_cse_invalidate_regno
parameter_list|(
name|regno
parameter_list|,
name|mode
parameter_list|,
name|clobber
parameter_list|)
name|int
name|regno
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|clobber
decl_stmt|;
block|{
name|int
name|endregno
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Our callers don't always go through true_regnum; we may see a      pseudo-register here from a CLOBBER or the like.  We probably      won't ever see a pseudo-register that has a real register number,      for we check anyhow for safety.  */
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|regno
operator|=
name|reg_renumber
index|[
name|regno
index|]
expr_stmt|;
if|if
condition|(
name|regno
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|endregno
operator|=
name|regno
operator|+
literal|1
expr_stmt|;
else|else
name|endregno
operator|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|clobber
condition|)
for|for
control|(
name|i
operator|=
name|regno
init|;
name|i
operator|<
name|endregno
condition|;
name|i
operator|++
control|)
name|reg_values
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
name|reg_values
index|[
name|i
index|]
init|;
name|x
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
control|)
block|{
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
operator|&&
name|refers_to_regno_p
argument_list|(
name|regno
argument_list|,
name|endregno
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_PTR
argument_list|)
condition|)
block|{
comment|/* If this is the only entry on the list, clear                  reg_values[i].  Otherwise, just clear this entry on                  the list.  */
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
operator|&&
name|x
operator|==
name|reg_values
index|[
name|i
index|]
condition|)
block|{
name|reg_values
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
comment|/* We must look at earlier registers, in case REGNO is part of a      multi word value but is not the first register.  If an earlier      register has a value in a mode which overlaps REGNO, then we must      invalidate that earlier register.  Note that we do not need to      check REGNO or later registers (we must not check REGNO itself,      because we would incorrectly conclude that there was a conflict).  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|regno
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
name|reg_values
index|[
name|i
index|]
init|;
name|x
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
control|)
block|{
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|PUT_MODE
argument_list|(
name|invalidate_regno_rtx
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|REGNO
argument_list|(
name|invalidate_regno_rtx
argument_list|)
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|refers_to_regno_p
argument_list|(
name|regno
argument_list|,
name|endregno
argument_list|,
name|invalidate_regno_rtx
argument_list|,
name|NULL_PTR
argument_list|)
condition|)
block|{
name|reload_cse_invalidate_regno
argument_list|(
name|i
argument_list|,
name|VOIDmode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* The memory at address MEM_BASE is being changed.    Return whether this change will invalidate VAL.  */
end_comment

begin_function
specifier|static
name|int
name|reload_cse_mem_conflict_p
parameter_list|(
name|mem_base
parameter_list|,
name|val
parameter_list|)
name|rtx
name|mem_base
decl_stmt|;
name|rtx
name|val
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
decl_stmt|;
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|val
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
comment|/* Get rid of a few simple cases quickly. */
case|case
name|REG
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|SCRATCH
case|:
case|case
name|CONST
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
return|return
literal|0
return|;
case|case
name|MEM
case|:
if|if
condition|(
name|GET_MODE
argument_list|(
name|mem_base
argument_list|)
operator|==
name|BLKmode
operator|||
name|GET_MODE
argument_list|(
name|val
argument_list|)
operator|==
name|BLKmode
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|anti_dependence
argument_list|(
name|val
argument_list|,
name|mem_base
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* The address may contain nested MEMs.  */
break|break;
default|default:
break|break;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
name|reload_cse_mem_conflict_p
argument_list|(
name|mem_base
argument_list|,
name|XEXP
argument_list|(
name|val
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|val
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|reload_cse_mem_conflict_p
argument_list|(
name|mem_base
argument_list|,
name|XVECEXP
argument_list|(
name|val
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Invalidate any entries in reg_values which are changed because of a    store to MEM_RTX.  If this is called because of a non-const call    instruction, MEM_RTX is (mem:BLK const0_rtx).  */
end_comment

begin_function
specifier|static
name|void
name|reload_cse_invalidate_mem
parameter_list|(
name|mem_rtx
parameter_list|)
name|rtx
name|mem_rtx
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
name|reg_values
index|[
name|i
index|]
init|;
name|x
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
control|)
block|{
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
operator|&&
name|reload_cse_mem_conflict_p
argument_list|(
name|mem_rtx
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
comment|/* If this is the only entry on the list, clear                  reg_values[i].  Otherwise, just clear this entry on                  the list.  */
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
operator|&&
name|x
operator|==
name|reg_values
index|[
name|i
index|]
condition|)
block|{
name|reg_values
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Invalidate DEST, which is being assigned to or clobbered.  The    second parameter exists so that this function can be passed to    note_stores; it is ignored.  */
end_comment

begin_function
specifier|static
name|void
name|reload_cse_invalidate_rtx
parameter_list|(
name|dest
parameter_list|,
name|ignore
parameter_list|)
name|rtx
name|dest
decl_stmt|;
name|rtx
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
while|while
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
condition|)
name|dest
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
condition|)
name|reload_cse_invalidate_regno
argument_list|(
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
condition|)
name|reload_cse_invalidate_mem
argument_list|(
name|dest
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Do a very simple CSE pass over the hard registers.     This function detects no-op moves where we happened to assign two    different pseudo-registers to the same hard register, and then    copied one to the other.  Reload will generate a useless    instruction copying a register to itself.     This function also detects cases where we load a value from memory    into two different registers, and (if memory is more expensive than    registers) changes it to simply copy the first register into the    second register.       Another optimization is performed that scans the operands of each    instruction to see whether the value is already available in a    hard register.  It then replaces the operand with the hard register    if possible, much like an optional reload would.  */
end_comment

begin_function
specifier|static
name|void
name|reload_cse_regs_1
parameter_list|(
name|first
parameter_list|)
name|rtx
name|first
decl_stmt|;
block|{
name|char
modifier|*
name|firstobj
decl_stmt|;
name|rtx
name|callmem
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|init_alias_analysis
argument_list|()
expr_stmt|;
name|reg_values
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|FIRST_PSEUDO_REGISTER
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_values
argument_list|,
name|FIRST_PSEUDO_REGISTER
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create our EXPR_LIST structures on reload_obstack, so that we can      free them when we are done.  */
name|push_obstacks
argument_list|(
operator|&
name|reload_obstack
argument_list|,
operator|&
name|reload_obstack
argument_list|)
expr_stmt|;
name|firstobj
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|reload_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* We pass this to reload_cse_invalidate_mem to invalidate all of      memory for a non-const call instruction.  */
name|callmem
operator|=
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
comment|/* This is used in reload_cse_invalidate_regno to avoid consing a      new REG in a loop in that function.  */
name|invalidate_regno_rtx
operator|=
name|gen_rtx_REG
argument_list|(
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|rtx
name|body
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
block|{
comment|/* Forget all the register values at a code label.  We don't              try to do anything clever around jumps.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
name|reg_values
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
ifdef|#
directive|ifdef
name|NON_SAVING_SETJMP
if|if
condition|(
name|NON_SAVING_SETJMP
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_SETJMP
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
name|reg_values
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
literal|'i'
condition|)
continue|continue;
comment|/* If this is a call instruction, forget anything stored in a 	 call clobbered register, or, if this is not a const call, in 	 memory.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|call_used_regs
index|[
name|i
index|]
condition|)
name|reload_cse_invalidate_regno
argument_list|(
name|i
argument_list|,
name|VOIDmode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CONST_CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
name|reload_cse_invalidate_mem
argument_list|(
name|callmem
argument_list|)
expr_stmt|;
block|}
comment|/* Forget all the register values at a volatile asm.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ASM_OPERANDS
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
name|reg_values
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|body
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SET
condition|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|reload_cse_noop_set_p
argument_list|(
name|body
argument_list|,
name|insn
argument_list|)
condition|)
block|{
comment|/* If this sets the return value of the function, we must keep 		 a USE around, in case this is in a different basic block 		 than the final USE.  Otherwise, we could loose important 		 register lifeness information on SMALL_REGISTER_CLASSES 		 machines, where return registers might be used as spills: 		 subsequent passes assume that spill registers are dead at 		 the end of a basic block.  */
if|if
condition|(
name|REG_FUNCTION_VALUE_P
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
condition|)
block|{
name|pop_obstacks
argument_list|()
expr_stmt|;
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
expr_stmt|;
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|NULL_RTX
expr_stmt|;
name|push_obstacks
argument_list|(
operator|&
name|reload_obstack
argument_list|,
operator|&
name|reload_obstack
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PUT_CODE
argument_list|(
name|insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
comment|/* We're done with this insn.  */
continue|continue;
block|}
comment|/* It's not a no-op, but we can try to simplify it.  */
name|count
operator|+=
name|reload_cse_simplify_set
argument_list|(
name|body
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
name|apply_change_group
argument_list|()
expr_stmt|;
else|else
name|reload_cse_simplify_operands
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|reload_cse_record_set
argument_list|(
name|body
argument_list|,
name|body
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
name|rtx
name|value
init|=
name|NULL_RTX
decl_stmt|;
comment|/* If every action in a PARALLEL is a noop, we can delete              the entire PARALLEL.  */
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|rtx
name|part
init|=
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|part
argument_list|)
operator|==
name|SET
condition|)
block|{
if|if
condition|(
operator|!
name|reload_cse_noop_set_p
argument_list|(
name|part
argument_list|,
name|insn
argument_list|)
condition|)
break|break;
if|if
condition|(
name|REG_FUNCTION_VALUE_P
argument_list|(
name|SET_DEST
argument_list|(
name|part
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|value
condition|)
break|break;
name|value
operator|=
name|SET_DEST
argument_list|(
name|part
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|part
argument_list|)
operator|!=
name|CLOBBER
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|value
condition|)
block|{
name|pop_obstacks
argument_list|()
expr_stmt|;
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|NULL_RTX
expr_stmt|;
name|push_obstacks
argument_list|(
operator|&
name|reload_obstack
argument_list|,
operator|&
name|reload_obstack
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PUT_CODE
argument_list|(
name|insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
comment|/* We're done with this insn.  */
continue|continue;
block|}
comment|/* It's not a no-op, but we can try to simplify it.  */
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
name|count
operator|+=
name|reload_cse_simplify_set
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
name|apply_change_group
argument_list|()
expr_stmt|;
else|else
name|reload_cse_simplify_operands
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Look through the PARALLEL and record the values being              set, if possible.  Also handle any CLOBBERs.  */
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|rtx
name|x
init|=
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
condition|)
name|reload_cse_record_set
argument_list|(
name|x
argument_list|,
name|body
argument_list|)
expr_stmt|;
else|else
name|note_stores
argument_list|(
name|x
argument_list|,
name|reload_cse_invalidate_rtx
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|note_stores
argument_list|(
name|body
argument_list|,
name|reload_cse_invalidate_rtx
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
comment|/* Clobber any registers which appear in REG_INC notes.  We          could keep track of the changes to their values, but it is          unlikely to help.  */
block|{
name|rtx
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|x
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|x
argument_list|)
operator|==
name|REG_INC
condition|)
name|reload_cse_invalidate_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Look for any CLOBBERs in CALL_INSN_FUNCTION_USAGE, but only          after we have processed the insn.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|rtx
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
init|;
name|x
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
name|reload_cse_invalidate_rtx
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Free all the temporary structures we created, and go back to the      regular obstacks.  */
name|obstack_free
argument_list|(
operator|&
name|reload_obstack
argument_list|,
name|firstobj
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Call cse / combine like post-reload optimization phases.    FIRST is the first instruction.  */
end_comment

begin_function
name|void
name|reload_cse_regs
parameter_list|(
name|first
parameter_list|)
name|rtx
name|first
decl_stmt|;
block|{
name|reload_cse_regs_1
argument_list|(
name|first
argument_list|)
expr_stmt|;
name|reload_combine
argument_list|()
expr_stmt|;
name|reload_cse_move2add
argument_list|(
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_expensive_optimizations
condition|)
name|reload_cse_regs_1
argument_list|(
name|first
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return whether the values known for REGNO are equal to VAL.  MODE    is the mode of the object that VAL is being copied to; this matters    if VAL is a CONST_INT.  */
end_comment

begin_function
specifier|static
name|int
name|reload_cse_regno_equal_p
parameter_list|(
name|regno
parameter_list|,
name|val
parameter_list|,
name|mode
parameter_list|)
name|int
name|regno
decl_stmt|;
name|rtx
name|val
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|rtx
name|x
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
return|return
literal|0
return|;
for|for
control|(
name|x
operator|=
name|reg_values
index|[
name|regno
index|]
init|;
name|x
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|val
argument_list|)
operator|&&
operator|(
operator|!
name|flag_float_store
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|MODE_FLOAT
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|val
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|mode
operator|==
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|||
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
comment|/* On a big endian machine if the value spans more than 		   one register then this register holds the high part of 		   it and we can't use it.  		   ??? We should also compare with the high part of the 		   value.  */
operator|&&
operator|!
operator|(
name|WORDS_BIG_ENDIAN
operator|&&
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|>
literal|1
operator|)
operator|&&
name|TRULY_NOOP_TRUNCATION
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* See whether a single set is a noop.  SET is the set instruction we    are should check, and INSN is the instruction from which it came.  */
end_comment

begin_function
specifier|static
name|int
name|reload_cse_noop_set_p
parameter_list|(
name|set
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|set
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|src
decl_stmt|,
name|dest
decl_stmt|;
name|enum
name|machine_mode
name|dest_mode
decl_stmt|;
name|int
name|dreg
decl_stmt|,
name|sreg
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|src
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|dest
operator|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|dest_mode
operator|=
name|GET_MODE
argument_list|(
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|side_effects_p
argument_list|(
name|src
argument_list|)
condition|)
return|return
literal|0
return|;
name|dreg
operator|=
name|true_regnum
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|sreg
operator|=
name|true_regnum
argument_list|(
name|src
argument_list|)
expr_stmt|;
comment|/* Check for setting a register to itself.  In this case, we don't      have to worry about REG_DEAD notes.  */
if|if
condition|(
name|dreg
operator|>=
literal|0
operator|&&
name|dreg
operator|==
name|sreg
condition|)
return|return
literal|1
return|;
name|ret
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dreg
operator|>=
literal|0
condition|)
block|{
comment|/* Check for setting a register to itself.  */
if|if
condition|(
name|dreg
operator|==
name|sreg
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
comment|/* Check for setting a register to a value which we already know          is in the register.  */
elseif|else
if|if
condition|(
name|reload_cse_regno_equal_p
argument_list|(
name|dreg
argument_list|,
name|src
argument_list|,
name|dest_mode
argument_list|)
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
comment|/* Check for setting a register DREG to another register SREG          where SREG is equal to a value which is already in DREG.  */
elseif|else
if|if
condition|(
name|sreg
operator|>=
literal|0
condition|)
block|{
name|rtx
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
name|reg_values
index|[
name|sreg
index|]
init|;
name|x
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|rtx
name|tmp
decl_stmt|;
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|dest_mode
operator|==
name|GET_MODE
argument_list|(
name|x
argument_list|)
condition|)
name|tmp
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|dest_mode
argument_list|)
operator|<
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|tmp
operator|=
name|gen_lowpart_common
argument_list|(
name|dest_mode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
continue|continue;
if|if
condition|(
name|tmp
operator|&&
name|reload_cse_regno_equal_p
argument_list|(
name|dreg
argument_list|,
name|tmp
argument_list|,
name|dest_mode
argument_list|)
condition|)
block|{
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
condition|)
block|{
comment|/* Check for storing a register to memory when we know that the          register is equivalent to the memory location. */
if|if
condition|(
name|sreg
operator|>=
literal|0
operator|&&
name|reload_cse_regno_equal_p
argument_list|(
name|sreg
argument_list|,
name|dest
argument_list|,
name|dest_mode
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|dest
argument_list|)
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Try to simplify a single SET instruction.  SET is the set pattern.    INSN is the instruction it came from.    This function only handles one case: if we set a register to a value    which is not a register, we try to find that value in some other register    and change the set into a register copy.  */
end_comment

begin_function
specifier|static
name|int
name|reload_cse_simplify_set
parameter_list|(
name|set
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|set
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|dreg
decl_stmt|;
name|rtx
name|src
decl_stmt|;
name|enum
name|machine_mode
name|dest_mode
decl_stmt|;
name|enum
name|reg_class
name|dclass
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|dreg
operator|=
name|true_regnum
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dreg
operator|<
literal|0
condition|)
return|return
literal|0
return|;
name|src
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
if|if
condition|(
name|side_effects_p
argument_list|(
name|src
argument_list|)
operator|||
name|true_regnum
argument_list|(
name|src
argument_list|)
operator|>=
literal|0
condition|)
return|return
literal|0
return|;
name|dclass
operator|=
name|REGNO_REG_CLASS
argument_list|(
name|dreg
argument_list|)
expr_stmt|;
comment|/* If memory loads are cheaper than register copies, don't change them.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|MEM
operator|&&
name|MEMORY_MOVE_COST
argument_list|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|,
name|dclass
argument_list|,
literal|1
argument_list|)
operator|<
literal|2
condition|)
return|return
literal|0
return|;
comment|/* If the constant is cheaper than a register, don't change it.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|src
argument_list|)
operator|&&
name|rtx_cost
argument_list|(
name|src
argument_list|,
name|SET
argument_list|)
operator|<
literal|2
condition|)
return|return
literal|0
return|;
name|dest_mode
operator|=
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|!=
name|dreg
operator|&&
name|REGISTER_MOVE_COST
argument_list|(
name|REGNO_REG_CLASS
argument_list|(
name|i
argument_list|)
argument_list|,
name|dclass
argument_list|)
operator|==
literal|2
operator|&&
name|reload_cse_regno_equal_p
argument_list|(
name|i
argument_list|,
name|src
argument_list|,
name|dest_mode
argument_list|)
condition|)
block|{
name|int
name|validated
decl_stmt|;
comment|/* Pop back to the real obstacks while changing the insn.  */
name|pop_obstacks
argument_list|()
expr_stmt|;
name|validated
operator|=
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|gen_rtx_REG
argument_list|(
name|dest_mode
argument_list|,
name|i
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Go back to the obstack we are using for temporary              storage.  */
name|push_obstacks
argument_list|(
operator|&
name|reload_obstack
argument_list|,
operator|&
name|reload_obstack
argument_list|)
expr_stmt|;
if|if
condition|(
name|validated
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Try to replace operands in INSN with equivalent values that are already    in registers.  This can be viewed as optional reloading.        For each non-register operand in the insn, see if any hard regs are    known to be equivalent to that operand.  Record the alternatives which    can accept these hard registers.  Among all alternatives, select the    ones which are better or equal to the one currently matching, where    "better" is in terms of '?' and '!' constraints.  Among the remaining    alternatives, select the one which replaces most operands with    hard registers.  */
end_comment

begin_function
specifier|static
name|int
name|reload_cse_simplify_operands
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|REGISTER_CONSTRAINTS
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|constraints
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
comment|/* Vector recording how bad an alternative is.  */
name|int
modifier|*
name|alternative_reject
decl_stmt|;
comment|/* Vector recording how many registers can be introduced by choosing      this alternative.  */
name|int
modifier|*
name|alternative_nregs
decl_stmt|;
comment|/* Array of vectors recording, for each operand and each alternative,      which hard register to substitute, or -1 if the operand should be      left as it is.  */
name|int
modifier|*
name|op_alt_regno
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
comment|/* Array of alternatives, sorted in order of decreasing desirability.  */
name|int
modifier|*
name|alternative_order
decl_stmt|;
name|rtx
name|reg
init|=
name|gen_rtx_REG
argument_list|(
name|VOIDmode
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
name|extract_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|recog_n_alternatives
operator|==
literal|0
operator|||
name|recog_n_operands
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Figure out which alternative currently matches.  */
if|if
condition|(
operator|!
name|constrain_operands
argument_list|(
literal|1
argument_list|)
condition|)
name|fatal_insn_not_found
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|alternative_reject
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|recog_n_alternatives
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|alternative_nregs
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|recog_n_alternatives
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|alternative_order
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|recog_n_alternatives
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|alternative_reject
argument_list|,
name|recog_n_alternatives
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|alternative_nregs
argument_list|,
name|recog_n_alternatives
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|recog_n_operands
condition|;
name|i
operator|++
control|)
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|regno
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|op_alt_regno
index|[
name|i
index|]
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|recog_n_alternatives
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|recog_n_alternatives
condition|;
name|j
operator|++
control|)
name|op_alt_regno
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|p
operator|=
name|constraints
index|[
name|i
index|]
operator|=
name|recog_constraints
index|[
name|i
index|]
expr_stmt|;
name|mode
operator|=
name|recog_operand_mode
index|[
name|i
index|]
expr_stmt|;
comment|/* Add the reject values for each alternative given by the constraints 	 for this operand.  */
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
name|char
name|c
init|=
operator|*
name|p
operator|++
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|','
condition|)
name|j
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'?'
condition|)
name|alternative_reject
index|[
name|j
index|]
operator|+=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'!'
condition|)
name|alternative_reject
index|[
name|j
index|]
operator|+=
literal|300
expr_stmt|;
block|}
comment|/* We won't change operands which are already registers.  We 	 also don't want to modify output operands.  */
name|regno
operator|=
name|true_regnum
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
literal|0
operator|||
name|constraints
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'='
operator|||
name|constraints
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'+'
condition|)
continue|continue;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
block|{
name|int
name|class
init|=
operator|(
name|int
operator|)
name|NO_REGS
decl_stmt|;
if|if
condition|(
operator|!
name|reload_cse_regno_equal_p
argument_list|(
name|regno
argument_list|,
name|recog_operand
index|[
name|i
index|]
argument_list|,
name|mode
argument_list|)
condition|)
continue|continue;
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|=
name|regno
expr_stmt|;
name|PUT_MODE
argument_list|(
name|reg
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* We found a register equal to this operand.  Now look for all 	     alternatives that can accept this register and have not been 	     assigned a register they can use yet.  */
name|j
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|constraints
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
name|c
init|=
operator|*
name|p
operator|++
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'='
case|:
case|case
literal|'+'
case|:
case|case
literal|'?'
case|:
case|case
literal|'#'
case|:
case|case
literal|'&'
case|:
case|case
literal|'!'
case|:
case|case
literal|'*'
case|:
case|case
literal|'%'
case|:
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'m'
case|:
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
case|case
literal|'V'
case|:
case|case
literal|'o'
case|:
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
case|case
literal|'G'
case|:
case|case
literal|'H'
case|:
case|case
literal|'s'
case|:
case|case
literal|'i'
case|:
case|case
literal|'n'
case|:
case|case
literal|'I'
case|:
case|case
literal|'J'
case|:
case|case
literal|'K'
case|:
case|case
literal|'L'
case|:
case|case
literal|'M'
case|:
case|case
literal|'N'
case|:
case|case
literal|'O'
case|:
case|case
literal|'P'
case|:
ifdef|#
directive|ifdef
name|EXTRA_CONSTRAINT
case|case
literal|'Q'
case|:
case|case
literal|'R'
case|:
case|case
literal|'S'
case|:
case|case
literal|'T'
case|:
case|case
literal|'U'
case|:
endif|#
directive|endif
case|case
literal|'p'
case|:
case|case
literal|'X'
case|:
comment|/* These don't say anything we care about.  */
break|break;
case|case
literal|'g'
case|:
case|case
literal|'r'
case|:
name|class
operator|=
name|reg_class_subunion
index|[
operator|(
name|int
operator|)
name|class
index|]
index|[
operator|(
name|int
operator|)
name|GENERAL_REGS
index|]
expr_stmt|;
break|break;
default|default:
name|class
operator|=
name|reg_class_subunion
index|[
operator|(
name|int
operator|)
name|class
index|]
index|[
operator|(
name|int
operator|)
name|REG_CLASS_FROM_LETTER
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|c
argument_list|)
index|]
expr_stmt|;
break|break;
case|case
literal|','
case|:
case|case
literal|'\0'
case|:
comment|/* See if REGNO fits this alternative, and set it up as the 		     replacement register if we don't have one for this 		     alternative yet and the operand being replaced is not 		     a cheap CONST_INT. */
if|if
condition|(
name|op_alt_regno
index|[
name|i
index|]
index|[
name|j
index|]
operator|==
operator|-
literal|1
operator|&&
name|reg_fits_class_p
argument_list|(
name|reg
argument_list|,
name|class
argument_list|,
literal|0
argument_list|,
name|mode
argument_list|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|rtx_cost
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|,
name|SET
argument_list|)
operator|>
name|rtx_cost
argument_list|(
name|reg
argument_list|,
name|SET
argument_list|)
operator|)
condition|)
block|{
name|alternative_nregs
index|[
name|j
index|]
operator|++
expr_stmt|;
name|op_alt_regno
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|regno
expr_stmt|;
block|}
name|j
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
break|break;
block|}
block|}
block|}
comment|/* Record all alternatives which are better or equal to the currently      matching one in the alternative_order array.  */
for|for
control|(
name|i
operator|=
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|recog_n_alternatives
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|alternative_reject
index|[
name|i
index|]
operator|<=
name|alternative_reject
index|[
name|which_alternative
index|]
condition|)
name|alternative_order
index|[
name|j
operator|++
index|]
operator|=
name|i
expr_stmt|;
name|recog_n_alternatives
operator|=
name|j
expr_stmt|;
comment|/* Sort it.  Given a small number of alternatives, a dumb algorithm      won't hurt too much.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|recog_n_alternatives
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|int
name|best
init|=
name|i
decl_stmt|;
name|int
name|best_reject
init|=
name|alternative_reject
index|[
name|alternative_order
index|[
name|i
index|]
index|]
decl_stmt|;
name|int
name|best_nregs
init|=
name|alternative_nregs
index|[
name|alternative_order
index|[
name|i
index|]
index|]
decl_stmt|;
name|int
name|tmp
decl_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|recog_n_alternatives
condition|;
name|j
operator|++
control|)
block|{
name|int
name|this_reject
init|=
name|alternative_reject
index|[
name|alternative_order
index|[
name|j
index|]
index|]
decl_stmt|;
name|int
name|this_nregs
init|=
name|alternative_nregs
index|[
name|alternative_order
index|[
name|j
index|]
index|]
decl_stmt|;
if|if
condition|(
name|this_reject
operator|<
name|best_reject
operator|||
operator|(
name|this_reject
operator|==
name|best_reject
operator|&&
name|this_nregs
operator|<
name|best_nregs
operator|)
condition|)
block|{
name|best
operator|=
name|j
expr_stmt|;
name|best_reject
operator|=
name|this_reject
expr_stmt|;
name|best_nregs
operator|=
name|this_nregs
expr_stmt|;
block|}
block|}
name|tmp
operator|=
name|alternative_order
index|[
name|best
index|]
expr_stmt|;
name|alternative_order
index|[
name|best
index|]
operator|=
name|alternative_order
index|[
name|i
index|]
expr_stmt|;
name|alternative_order
index|[
name|i
index|]
operator|=
name|tmp
expr_stmt|;
block|}
comment|/* Substitute the operands as determined by op_alt_regno for the best      alternative.  */
name|j
operator|=
name|alternative_order
index|[
literal|0
index|]
expr_stmt|;
comment|/* Pop back to the real obstacks while changing the insn.  */
name|pop_obstacks
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|recog_n_operands
condition|;
name|i
operator|++
control|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|recog_operand_mode
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|op_alt_regno
index|[
name|i
index|]
index|[
name|j
index|]
operator|==
operator|-
literal|1
condition|)
continue|continue;
name|validate_change
argument_list|(
name|insn
argument_list|,
name|recog_operand_loc
index|[
name|i
index|]
argument_list|,
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|op_alt_regno
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|recog_n_dups
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|int
name|op
init|=
name|recog_dup_num
index|[
name|i
index|]
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|recog_operand_mode
index|[
name|op
index|]
decl_stmt|;
if|if
condition|(
name|op_alt_regno
index|[
name|op
index|]
index|[
name|j
index|]
operator|==
operator|-
literal|1
condition|)
continue|continue;
name|validate_change
argument_list|(
name|insn
argument_list|,
name|recog_dup_loc
index|[
name|i
index|]
argument_list|,
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|op_alt_regno
index|[
name|op
index|]
index|[
name|j
index|]
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Go back to the obstack we are using for temporary      storage.  */
name|push_obstacks
argument_list|(
operator|&
name|reload_obstack
argument_list|,
operator|&
name|reload_obstack
argument_list|)
expr_stmt|;
return|return
name|apply_change_group
argument_list|()
return|;
else|#
directive|else
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* These two variables are used to pass information from    reload_cse_record_set to reload_cse_check_clobber.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|reload_cse_check_clobbered
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|reload_cse_check_src
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* See if DEST overlaps with RELOAD_CSE_CHECK_SRC. If it does, set    RELOAD_CSE_CHECK_CLOBBERED.  This is called via note_stores.  The    second argument, which is passed by note_stores, is ignored.  */
end_comment

begin_function
specifier|static
name|void
name|reload_cse_check_clobber
parameter_list|(
name|dest
parameter_list|,
name|ignore
parameter_list|)
name|rtx
name|dest
decl_stmt|;
name|rtx
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|dest
argument_list|,
name|reload_cse_check_src
argument_list|)
condition|)
name|reload_cse_check_clobbered
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record the result of a SET instruction.  SET is the set pattern.    BODY is the pattern of the insn that it came from.  */
end_comment

begin_function
specifier|static
name|void
name|reload_cse_record_set
parameter_list|(
name|set
parameter_list|,
name|body
parameter_list|)
name|rtx
name|set
decl_stmt|;
name|rtx
name|body
decl_stmt|;
block|{
name|rtx
name|dest
decl_stmt|,
name|src
decl_stmt|,
name|x
decl_stmt|;
name|int
name|dreg
decl_stmt|,
name|sreg
decl_stmt|;
name|enum
name|machine_mode
name|dest_mode
decl_stmt|;
name|dest
operator|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|src
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|dreg
operator|=
name|true_regnum
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|sreg
operator|=
name|true_regnum
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|dest_mode
operator|=
name|GET_MODE
argument_list|(
name|dest
argument_list|)
expr_stmt|;
comment|/* Some machines don't define AUTO_INC_DEC, but they still use push      instructions.  We need to catch that case here in order to      invalidate the stack pointer correctly.  Note that invalidating      the stack pointer is different from invalidating DEST.  */
name|x
operator|=
name|dest
expr_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|push_operand
argument_list|(
name|x
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
name|reload_cse_invalidate_rtx
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|reload_cse_invalidate_rtx
argument_list|(
name|dest
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* We can only handle an assignment to a register, or a store of a      register to a memory location.  For other cases, we just clobber      the destination.  We also have to just clobber if there are side      effects in SRC or DEST.  */
if|if
condition|(
operator|(
name|dreg
operator|<
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|!=
name|MEM
operator|)
operator|||
name|side_effects_p
argument_list|(
name|src
argument_list|)
operator|||
name|side_effects_p
argument_list|(
name|dest
argument_list|)
condition|)
block|{
name|reload_cse_invalidate_rtx
argument_list|(
name|dest
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* We don't try to handle values involving CC, because it's a pain      to keep track of when they have to be invalidated.  */
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|cc0_rtx
argument_list|,
name|src
argument_list|)
operator|||
name|reg_mentioned_p
argument_list|(
name|cc0_rtx
argument_list|,
name|dest
argument_list|)
condition|)
block|{
name|reload_cse_invalidate_rtx
argument_list|(
name|dest
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* If BODY is a PARALLEL, then we need to see whether the source of      SET is clobbered by some other instruction in the PARALLEL.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|rtx
name|x
decl_stmt|;
name|x
operator|=
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|set
condition|)
continue|continue;
name|reload_cse_check_clobbered
operator|=
literal|0
expr_stmt|;
name|reload_cse_check_src
operator|=
name|src
expr_stmt|;
name|note_stores
argument_list|(
name|x
argument_list|,
name|reload_cse_check_clobber
argument_list|)
expr_stmt|;
if|if
condition|(
name|reload_cse_check_clobbered
condition|)
block|{
name|reload_cse_invalidate_rtx
argument_list|(
name|dest
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
if|if
condition|(
name|dreg
operator|>=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* This is an assignment to a register.  Update the value we          have stored for the register.  */
if|if
condition|(
name|sreg
operator|>=
literal|0
condition|)
block|{
name|rtx
name|x
decl_stmt|;
comment|/* This is a copy from one register to another.  Any values 	     which were valid for SREG are now valid for DREG.  If the 	     mode changes, we use gen_lowpart_common to extract only 	     the part of the value that is copied.  */
name|reg_values
index|[
name|dreg
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|x
operator|=
name|reg_values
index|[
name|sreg
index|]
init|;
name|x
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|rtx
name|tmp
decl_stmt|;
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|dest_mode
operator|==
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|tmp
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|dest_mode
argument_list|)
operator|>
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
continue|continue;
else|else
name|tmp
operator|=
name|gen_lowpart_common
argument_list|(
name|dest_mode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
condition|)
name|reg_values
index|[
name|dreg
index|]
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|dest_mode
argument_list|,
name|tmp
argument_list|,
name|reg_values
index|[
name|dreg
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|reg_values
index|[
name|dreg
index|]
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|dest_mode
argument_list|,
name|src
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
comment|/* We've changed DREG, so invalidate any values held by other          registers that depend upon it.  */
name|reload_cse_invalidate_regno
argument_list|(
name|dreg
argument_list|,
name|dest_mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If this assignment changes more than one hard register,          forget anything we know about the others.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|HARD_REGNO_NREGS
argument_list|(
name|dreg
argument_list|,
name|dest_mode
argument_list|)
condition|;
name|i
operator|++
control|)
name|reg_values
index|[
name|dreg
operator|+
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
condition|)
block|{
comment|/* Invalidate conflicting memory locations.  */
name|reload_cse_invalidate_mem
argument_list|(
name|dest
argument_list|)
expr_stmt|;
comment|/* If we're storing a register to memory, add DEST to the list          in REG_VALUES.  */
if|if
condition|(
name|sreg
operator|>=
literal|0
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|dest
argument_list|)
condition|)
name|reg_values
index|[
name|sreg
index|]
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|dest_mode
argument_list|,
name|dest
argument_list|,
name|reg_values
index|[
name|sreg
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We should have bailed out earlier.  */
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If reload couldn't use reg+reg+offset addressing, try to use reg+reg    addressing now.    This code might also be useful when reload gave up on reg+reg addresssing    because of clashes between the return register and INDEX_REG_CLASS.  */
end_comment

begin_comment
comment|/* The maximum number of uses of a register we can keep track of to    replace them with reg+reg addressing.  */
end_comment

begin_define
define|#
directive|define
name|RELOAD_COMBINE_MAX_USES
value|6
end_define

begin_comment
comment|/* INSN is the insn where a register has ben used, and USEP points to the    location of the register within the rtl.  */
end_comment

begin_struct
struct|struct
name|reg_use
block|{
name|rtx
name|insn
decl_stmt|,
modifier|*
name|usep
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* If the register is used in some unknown fashion, USE_INDEX is negative.    If it is dead, USE_INDEX is RELOAD_COMBINE_MAX_USES, and STORE_RUID    indicates where it becomes live again.    Otherwise, USE_INDEX is the index of the last encountered use of the    register (which is first among these we have seen since we scan backwards),    OFFSET contains the constant offset that is added to the register in    all encountered uses, and USE_RUID indicates the first encountered, i.e.    last, of these uses.    STORE_RUID is always meaningful if we only want to use a value in a    register in a different place: it denotes the next insn in the insn    stream (i.e. the last ecountered) that sets or clobbers the register.  */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|struct
name|reg_use
name|reg_use
index|[
name|RELOAD_COMBINE_MAX_USES
index|]
decl_stmt|;
name|int
name|use_index
decl_stmt|;
name|rtx
name|offset
decl_stmt|;
name|int
name|store_ruid
decl_stmt|;
name|int
name|use_ruid
decl_stmt|;
block|}
name|reg_state
index|[
name|FIRST_PSEUDO_REGISTER
index|]
struct|;
end_struct

begin_comment
comment|/* Reverse linear uid.  This is increased in reload_combine while scanning    the instructions from last to first.  It is used to set last_label_ruid    and the store_ruid / use_ruid fields in reg_state.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|reload_combine_ruid
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|LABEL_LIVE
parameter_list|(
name|LABEL
parameter_list|)
define|\
value|(label_live[CODE_LABEL_NUMBER (LABEL) - min_labelno])
end_define

begin_function
specifier|static
name|void
name|reload_combine
parameter_list|()
block|{
name|rtx
name|insn
decl_stmt|,
name|set
decl_stmt|;
name|int
name|first_index_reg
init|=
literal|1
decl_stmt|,
name|last_index_reg
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|last_label_ruid
decl_stmt|;
name|int
name|min_labelno
decl_stmt|,
name|n_labels
decl_stmt|;
name|HARD_REG_SET
name|ever_live_at_start
decl_stmt|,
modifier|*
name|label_live
decl_stmt|;
comment|/* If reg+reg can be used in offsetable memory adresses, the main chunk of      reload has already used it where appropriate, so there is no use in      trying to generate it now.  */
if|if
condition|(
name|double_reg_address_ok
operator|&&
name|INDEX_REG_CLASS
operator|!=
name|NO_REGS
condition|)
return|return;
comment|/* To avoid wasting too much time later searching for an index register,      determine the minimum and maximum index register numbers.  */
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|INDEX_REG_CLASS
index|]
argument_list|,
name|i
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|last_index_reg
condition|)
name|last_index_reg
operator|=
name|i
expr_stmt|;
name|first_index_reg
operator|=
name|i
expr_stmt|;
block|}
block|}
comment|/* If no index register is available, we can quit now.  */
if|if
condition|(
name|first_index_reg
operator|>
name|last_index_reg
condition|)
return|return;
comment|/* Set up LABEL_LIVE and EVER_LIVE_AT_START.  The register lifetime      information is a bit fuzzy immediately after reload, but it's      still good enough to determine which registers are live at a jump      destination.  */
name|min_labelno
operator|=
name|get_first_label_num
argument_list|()
expr_stmt|;
name|n_labels
operator|=
name|max_label_num
argument_list|()
operator|-
name|min_labelno
expr_stmt|;
name|label_live
operator|=
operator|(
name|HARD_REG_SET
operator|*
operator|)
name|xmalloc
argument_list|(
name|n_labels
operator|*
sizeof|sizeof
argument_list|(
name|HARD_REG_SET
argument_list|)
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|ever_live_at_start
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|n_basic_blocks
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|insn
operator|=
name|BLOCK_HEAD
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
block|{
name|HARD_REG_SET
name|live
decl_stmt|;
name|REG_SET_TO_HARD_REG_SET
argument_list|(
name|live
argument_list|,
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
operator|->
name|global_live_at_start
argument_list|)
expr_stmt|;
name|compute_use_by_pseudos
argument_list|(
operator|&
name|live
argument_list|,
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
operator|->
name|global_live_at_start
argument_list|)
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|LABEL_LIVE
argument_list|(
name|insn
argument_list|)
argument_list|,
name|live
argument_list|)
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|ever_live_at_start
argument_list|,
name|live
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Initialize last_label_ruid, reload_combine_ruid and reg_state.  */
name|last_label_ruid
operator|=
name|reload_combine_ruid
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|reg_state
index|[
name|i
index|]
operator|.
name|store_ruid
operator|=
name|reload_combine_ruid
expr_stmt|;
if|if
condition|(
name|fixed_regs
index|[
name|i
index|]
condition|)
name|reg_state
index|[
name|i
index|]
operator|.
name|use_index
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|reg_state
index|[
name|i
index|]
operator|.
name|use_index
operator|=
name|RELOAD_COMBINE_MAX_USES
expr_stmt|;
block|}
for|for
control|(
name|insn
operator|=
name|get_last_insn
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|rtx
name|note
decl_stmt|;
comment|/* We cannot do our optimization across labels.  Invalidating all the use 	 information we have would be costly, so we just note where the label          is and then later disable any optimization that would cross it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|last_label_ruid
operator|=
name|reload_combine_ruid
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|BARRIER
condition|)
block|{
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
name|reg_state
index|[
name|i
index|]
operator|.
name|use_index
operator|=
name|RELOAD_COMBINE_MAX_USES
expr_stmt|;
block|}
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
literal|'i'
condition|)
continue|continue;
name|reload_combine_ruid
operator|++
expr_stmt|;
comment|/* Look for (set (REGX) (CONST_INT)) 		  (set (REGX) (PLUS (REGX) (REGY))) 		  ... 		  ... (MEM (REGX)) ... 	 and convert it to 		  (set (REGZ) (CONST_INT)) 		  ... 		  ... (MEM (PLUS (REGZ) (REGY)))... .  	 First, check that we have (set (REGX) (PLUS (REGX) (REGY))) 	 and that we know all uses of REGX before it dies.  */
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
operator|!=
name|NULL_RTX
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|HARD_REGNO_NREGS
argument_list|(
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|1
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|&&
name|last_label_ruid
operator|<
name|reg_state
index|[
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
index|]
operator|.
name|use_ruid
condition|)
block|{
name|rtx
name|reg
init|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
decl_stmt|;
name|rtx
name|plus
init|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
decl_stmt|;
name|rtx
name|base
init|=
name|XEXP
argument_list|(
name|plus
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|prev
init|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|prev_set
init|=
name|prev
condition|?
name|single_set
argument_list|(
name|prev
argument_list|)
else|:
name|NULL_RTX
decl_stmt|;
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|reg
argument_list|)
decl_stmt|;
name|rtx
name|const_reg
decl_stmt|;
name|rtx
name|reg_sum
init|=
name|NULL_RTX
decl_stmt|;
comment|/* Now, we need an index register. 	     We'll set index_reg to this index register, const_reg to the 	     register that is to be loaded with the constant 	     (denoted as REGZ in the substitution illustration above), 	     and reg_sum to the register-register that we want to use to 	     substitute uses of REG (typically in MEMs) with. 	     First check REG and BASE for being index registers; 	     we can use them even if they are not dead.  */
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|INDEX_REG_CLASS
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|INDEX_REG_CLASS
index|]
argument_list|,
name|REGNO
argument_list|(
name|base
argument_list|)
argument_list|)
condition|)
block|{
name|const_reg
operator|=
name|reg
expr_stmt|;
name|reg_sum
operator|=
name|plus
expr_stmt|;
block|}
else|else
block|{
comment|/* Otherwise, look for a free index register.  Since we have 		  checked above that neiter REG nor BASE are index registers, 		  if we find anything at all, it will be different from these 		  two registers.  */
for|for
control|(
name|i
operator|=
name|first_index_reg
init|;
name|i
operator|<=
name|last_index_reg
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|INDEX_REG_CLASS
index|]
argument_list|,
name|i
argument_list|)
operator|&&
name|reg_state
index|[
name|i
index|]
operator|.
name|use_index
operator|==
name|RELOAD_COMBINE_MAX_USES
operator|&&
name|reg_state
index|[
name|i
index|]
operator|.
name|store_ruid
operator|<=
name|reg_state
index|[
name|regno
index|]
operator|.
name|use_ruid
operator|&&
name|HARD_REGNO_NREGS
argument_list|(
name|i
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|==
literal|1
condition|)
block|{
name|rtx
name|index_reg
init|=
name|gen_rtx_REG
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|const_reg
operator|=
name|index_reg
expr_stmt|;
name|reg_sum
operator|=
name|gen_rtx_PLUS
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|index_reg
argument_list|,
name|base
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* Check that PREV_SET is indeed (set (REGX) (CONST_INT)) and that 	     (REGY), i.e. BASE, is not clobbered before the last use we'll 	     create.  */
if|if
condition|(
name|prev_set
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|prev_set
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_DEST
argument_list|(
name|prev_set
argument_list|)
argument_list|,
name|reg
argument_list|)
operator|&&
name|reg_state
index|[
name|regno
index|]
operator|.
name|use_index
operator|>=
literal|0
operator|&&
name|reg_state
index|[
name|REGNO
argument_list|(
name|base
argument_list|)
index|]
operator|.
name|store_ruid
operator|<=
name|reg_state
index|[
name|regno
index|]
operator|.
name|use_ruid
operator|&&
name|reg_sum
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Change destination register and - if necessary - the 		 constant value in PREV, the constant loading instruction.  */
name|validate_change
argument_list|(
name|prev
argument_list|,
operator|&
name|SET_DEST
argument_list|(
name|prev_set
argument_list|)
argument_list|,
name|const_reg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_state
index|[
name|regno
index|]
operator|.
name|offset
operator|!=
name|const0_rtx
condition|)
name|validate_change
argument_list|(
name|prev
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|prev_set
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|SET_SRC
argument_list|(
name|prev_set
argument_list|)
argument_list|)
operator|+
name|INTVAL
argument_list|(
name|reg_state
index|[
name|regno
index|]
operator|.
name|offset
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Now for every use of REG that we have recorded, replace REG 		 with REG_SUM.  */
for|for
control|(
name|i
operator|=
name|reg_state
index|[
name|regno
index|]
operator|.
name|use_index
init|;
name|i
operator|<
name|RELOAD_COMBINE_MAX_USES
condition|;
name|i
operator|++
control|)
name|validate_change
argument_list|(
name|reg_state
index|[
name|regno
index|]
operator|.
name|reg_use
index|[
name|i
index|]
operator|.
name|insn
argument_list|,
name|reg_state
index|[
name|regno
index|]
operator|.
name|reg_use
index|[
name|i
index|]
operator|.
name|usep
argument_list|,
name|reg_sum
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|apply_change_group
argument_list|()
condition|)
block|{
name|rtx
modifier|*
name|np
decl_stmt|;
comment|/* Delete the reg-reg addition.  */
name|PUT_CODE
argument_list|(
name|insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|reg_state
index|[
name|regno
index|]
operator|.
name|offset
operator|!=
name|const0_rtx
condition|)
block|{
comment|/* Previous REG_EQUIV / REG_EQUAL notes for PREV 			 are now invalid.  */
for|for
control|(
name|np
operator|=
operator|&
name|REG_NOTES
argument_list|(
name|prev
argument_list|)
init|;
operator|*
name|np
condition|;
control|)
block|{
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
operator|*
name|np
argument_list|)
operator|==
name|REG_EQUAL
operator|||
name|REG_NOTE_KIND
argument_list|(
operator|*
name|np
argument_list|)
operator|==
name|REG_EQUIV
condition|)
operator|*
name|np
operator|=
name|XEXP
argument_list|(
operator|*
name|np
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|np
operator|=
operator|&
name|XEXP
argument_list|(
operator|*
name|np
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|reg_state
index|[
name|regno
index|]
operator|.
name|use_index
operator|=
name|RELOAD_COMBINE_MAX_USES
expr_stmt|;
name|reg_state
index|[
name|REGNO
argument_list|(
name|const_reg
argument_list|)
index|]
operator|.
name|store_ruid
operator|=
name|reload_combine_ruid
expr_stmt|;
continue|continue;
block|}
block|}
block|}
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|reload_combine_note_store
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|rtx
name|link
decl_stmt|;
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
name|call_used_regs
index|[
name|i
index|]
condition|)
block|{
name|reg_state
index|[
name|i
index|]
operator|.
name|use_index
operator|=
name|RELOAD_COMBINE_MAX_USES
expr_stmt|;
name|reg_state
index|[
name|i
index|]
operator|.
name|store_ruid
operator|=
name|reload_combine_ruid
expr_stmt|;
block|}
block|}
for|for
control|(
name|link
operator|=
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|rtx
name|use
init|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|use
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|use
argument_list|)
operator|==
name|CLOBBER
condition|)
block|{
name|reg_state
index|[
name|regno
index|]
operator|.
name|use_index
operator|=
name|RELOAD_COMBINE_MAX_USES
expr_stmt|;
name|reg_state
index|[
name|regno
index|]
operator|.
name|store_ruid
operator|=
name|reload_combine_ruid
expr_stmt|;
block|}
else|else
name|reg_state
index|[
name|regno
index|]
operator|.
name|use_index
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|RETURN
condition|)
block|{
comment|/* Non-spill registers might be used at the call destination in 	     some unknown fashion, so we have to mark the unknown use.  */
name|HARD_REG_SET
modifier|*
name|live
decl_stmt|;
if|if
condition|(
operator|(
name|condjump_p
argument_list|(
name|insn
argument_list|)
operator|||
name|condjump_in_parallel_p
argument_list|(
name|insn
argument_list|)
operator|)
operator|&&
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
condition|)
name|live
operator|=
operator|&
name|LABEL_LIVE
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|live
operator|=
operator|&
name|ever_live_at_start
expr_stmt|;
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
operator|*
name|live
argument_list|,
name|i
argument_list|)
condition|)
name|reg_state
index|[
name|i
index|]
operator|.
name|use_index
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
name|reload_combine_note_use
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
block|{
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_INC
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|reg_state
index|[
name|regno
index|]
operator|.
name|store_ruid
operator|=
name|reload_combine_ruid
expr_stmt|;
name|reg_state
index|[
name|regno
index|]
operator|.
name|use_index
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
name|free
argument_list|(
name|label_live
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check if DST is a register or a subreg of a register; if it is,    update reg_state[regno].store_ruid and reg_state[regno].use_index    accordingly.  Called via note_stores from reload_combine.  */
end_comment

begin_function
specifier|static
name|void
name|reload_combine_note_store
parameter_list|(
name|dst
parameter_list|,
name|set
parameter_list|)
name|rtx
name|dst
decl_stmt|,
name|set
decl_stmt|;
block|{
name|int
name|regno
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|size
init|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|dst
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|regno
operator|=
name|SUBREG_WORD
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|dst
operator|=
name|SUBREG_REG
argument_list|(
name|dst
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|!=
name|REG
condition|)
return|return;
name|regno
operator|+=
name|REGNO
argument_list|(
name|dst
argument_list|)
expr_stmt|;
comment|/* note_stores might have stripped a STRICT_LOW_PART, so we have to be      careful with registers / register parts that are not full words.        Similarly for ZERO_EXTRACT and SIGN_EXTRACT.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|set
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
block|{
for|for
control|(
name|i
operator|=
operator|(
name|size
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
operator|+
name|regno
init|;
name|i
operator|>=
name|regno
condition|;
name|i
operator|--
control|)
block|{
name|reg_state
index|[
name|i
index|]
operator|.
name|use_index
operator|=
operator|-
literal|1
expr_stmt|;
name|reg_state
index|[
name|i
index|]
operator|.
name|store_ruid
operator|=
name|reload_combine_ruid
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
operator|(
name|size
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
operator|+
name|regno
init|;
name|i
operator|>=
name|regno
condition|;
name|i
operator|--
control|)
block|{
name|reg_state
index|[
name|i
index|]
operator|.
name|store_ruid
operator|=
name|reload_combine_ruid
expr_stmt|;
name|reg_state
index|[
name|i
index|]
operator|.
name|use_index
operator|=
name|RELOAD_COMBINE_MAX_USES
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* XP points to a piece of rtl that has to be checked for any uses of    registers.    *XP is the pattern of INSN, or a part of it.    Called from reload_combine, and recursively by itself.  */
end_comment

begin_function
specifier|static
name|void
name|reload_combine_note_use
parameter_list|(
name|xp
parameter_list|,
name|insn
parameter_list|)
name|rtx
modifier|*
name|xp
decl_stmt|,
name|insn
decl_stmt|;
block|{
name|rtx
name|x
init|=
operator|*
name|xp
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|x
operator|->
name|code
decl_stmt|;
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|rtx
name|offset
init|=
name|const0_rtx
decl_stmt|;
comment|/* For the REG case below.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|SET
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|reload_combine_note_use
argument_list|(
operator|&
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|CLOBBER
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
return|return;
break|break;
case|case
name|PLUS
case|:
comment|/* We are interested in (plus (reg) (const_int)) .  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
break|break;
name|offset
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|REG
case|:
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|use_index
decl_stmt|;
comment|/* Some spurious USEs of pseudo registers might remain. 	   Just ignore them.  */
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
return|return;
comment|/* If this register is already used in some unknown fashion, we 	   can't do anything. 	   If we decrement the index from zero to -1, we can't store more 	   uses, so this register becomes used in an unknown fashion.  */
name|use_index
operator|=
operator|--
name|reg_state
index|[
name|regno
index|]
operator|.
name|use_index
expr_stmt|;
if|if
condition|(
name|use_index
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|use_index
operator|!=
name|RELOAD_COMBINE_MAX_USES
operator|-
literal|1
condition|)
block|{
comment|/* We have found another use for a register that is already 	       used later.  Check if the offsets match; if not, mark the 	       register as used in an unknown fashion.  */
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|offset
argument_list|,
name|reg_state
index|[
name|regno
index|]
operator|.
name|offset
argument_list|)
condition|)
block|{
name|reg_state
index|[
name|regno
index|]
operator|.
name|use_index
operator|=
operator|-
literal|1
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
comment|/* This is the first use of this register we have seen since we 	       marked it as dead.  */
name|reg_state
index|[
name|regno
index|]
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
name|reg_state
index|[
name|regno
index|]
operator|.
name|use_ruid
operator|=
name|reload_combine_ruid
expr_stmt|;
block|}
name|reg_state
index|[
name|regno
index|]
operator|.
name|reg_use
index|[
name|use_index
index|]
operator|.
name|insn
operator|=
name|insn
expr_stmt|;
name|reg_state
index|[
name|regno
index|]
operator|.
name|reg_use
index|[
name|use_index
index|]
operator|.
name|usep
operator|=
name|xp
expr_stmt|;
return|return;
block|}
default|default:
break|break;
block|}
comment|/* Recursively process the components of X.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|reload_combine_note_use
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|reload_combine_note_use
argument_list|(
operator|&
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* See if we can reduce the cost of a constant by replacing a move with    an add.  */
end_comment

begin_comment
comment|/* We cannot do our optimization across labels.  Invalidating all the    information about register contents we have would be costly, so we    use last_label_luid (local variable of reload_cse_move2add) to note    where the label is and then later disable any optimization that would    cross it.    reg_offset[n] / reg_base_reg[n] / reg_mode[n] are only valid if    reg_set_luid[n] is larger than last_label_luid[n] .  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|reg_set_luid
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* reg_offset[n] has to be CONST_INT for it and reg_base_reg[n] /    reg_mode[n] to be valid.    If reg_offset[n] is a CONST_INT and reg_base_reg[n] is negative, register n    has been set to reg_offset[n] in mode reg_mode[n] .    If reg_offset[n] is a CONST_INT and reg_base_reg[n] is non-negative,    register n has been set to the sum of reg_offset[n] and register    reg_base_reg[n], calculated in mode reg_mode[n] .  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|reg_offset
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reg_base_reg
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|machine_mode
name|reg_mode
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* move2add_luid is linearily increased while scanning the instructions    from first to last.  It is used to set reg_set_luid in    reload_cse_move2add and move2add_note_store.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|move2add_luid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Generate a CONST_INT and force it in the range of MODE.  */
end_comment

begin_function
specifier|static
name|rtx
name|gen_mode_int
parameter_list|(
name|mode
parameter_list|,
name|value
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|HOST_WIDE_INT
name|value
decl_stmt|;
block|{
name|HOST_WIDE_INT
name|cval
init|=
name|value
operator|&
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|int
name|width
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
comment|/* If MODE is narrower than HOST_WIDE_INT and CVAL is a negative number,      sign extend it.  */
if|if
condition|(
name|width
operator|>
literal|0
operator|&&
name|width
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
name|cval
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
operator|)
operator|!=
literal|0
condition|)
name|cval
operator||=
operator|(
name|HOST_WIDE_INT
operator|)
operator|-
literal|1
operator|<<
name|width
expr_stmt|;
return|return
name|GEN_INT
argument_list|(
name|cval
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|reload_cse_move2add
parameter_list|(
name|first
parameter_list|)
name|rtx
name|first
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|last_label_luid
decl_stmt|;
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|reg_set_luid
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|last_label_luid
operator|=
literal|0
expr_stmt|;
name|move2add_luid
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|,
name|move2add_luid
operator|++
control|)
block|{
name|rtx
name|pat
decl_stmt|,
name|note
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|last_label_luid
operator|=
name|move2add_luid
expr_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
literal|'i'
condition|)
continue|continue;
name|pat
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* For simplicity, we only perform this optimization on 	 straightforward SETs.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|rtx
name|reg
init|=
name|SET_DEST
argument_list|(
name|pat
argument_list|)
decl_stmt|;
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|reg
argument_list|)
decl_stmt|;
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|pat
argument_list|)
decl_stmt|;
comment|/* Check if we have valid information on the contents of this 	     register in the mode of REG.  */
comment|/* ??? We don't know how zero / sign extension is handled, hence 	     we can't go from a narrower to a wider mode.  */
if|if
condition|(
name|reg_set_luid
index|[
name|regno
index|]
operator|>
name|last_label_luid
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|<=
name|GET_MODE_SIZE
argument_list|(
name|reg_mode
index|[
name|regno
index|]
argument_list|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|reg_offset
index|[
name|regno
index|]
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
comment|/* Try to transform (set (REGX) (CONST_INT A)) 				  ... 				  (set (REGX) (CONST_INT B)) 		 to 				  (set (REGX) (CONST_INT A)) 				  ... 				  (set (REGX) (plus (REGX) (CONST_INT B-A)))  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|reg_base_reg
index|[
name|regno
index|]
operator|<
literal|0
condition|)
block|{
name|int
name|success
init|=
literal|0
decl_stmt|;
name|rtx
name|new_src
init|=
name|gen_mode_int
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|INTVAL
argument_list|(
name|src
argument_list|)
operator|-
name|INTVAL
argument_list|(
name|reg_offset
index|[
name|regno
index|]
argument_list|)
argument_list|)
decl_stmt|;
comment|/* (set (reg) (plus (reg) (const_int 0))) is not canonical; 		     use (set (reg) (reg)) instead. 		     We don't delete this insn, nor do we convert it into a 		     note, to avoid losing register notes or the return 		     value flag.  jump2 already knowns how to get rid of 		     no-op moves.  */
if|if
condition|(
name|new_src
operator|==
name|const0_rtx
condition|)
name|success
operator|=
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rtx_cost
argument_list|(
name|new_src
argument_list|,
name|PLUS
argument_list|)
operator|<
name|rtx_cost
argument_list|(
name|src
argument_list|,
name|SET
argument_list|)
operator|&&
name|have_add2_insn
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
condition|)
name|success
operator|=
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|gen_add2_insn
argument_list|(
name|reg
argument_list|,
name|new_src
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|reg_set_luid
index|[
name|regno
index|]
operator|=
name|move2add_luid
expr_stmt|;
name|reg_mode
index|[
name|regno
index|]
operator|=
name|GET_MODE
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|reg_offset
index|[
name|regno
index|]
operator|=
name|src
expr_stmt|;
continue|continue;
block|}
comment|/* Try to transform (set (REGX) (REGY)) 				  (set (REGX) (PLUS (REGX) (CONST_INT A))) 				  ... 				  (set (REGX) (REGY)) 				  (set (REGX) (PLUS (REGX) (CONST_INT B))) 		 to 				  (REGX) (REGY)) 				  (set (REGX) (PLUS (REGX) (CONST_INT A))) 				  ... 				  (set (REGX) (plus (REGX) (CONST_INT B-A)))  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|REG
operator|&&
name|reg_base_reg
index|[
name|regno
index|]
operator|==
name|REGNO
argument_list|(
name|src
argument_list|)
operator|&&
name|reg_set_luid
index|[
name|regno
index|]
operator|>
name|reg_set_luid
index|[
name|REGNO
argument_list|(
name|src
argument_list|)
index|]
condition|)
block|{
name|rtx
name|next
init|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|set
decl_stmt|;
if|if
condition|(
name|next
condition|)
name|set
operator|=
name|single_set
argument_list|(
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|&&
name|set
operator|&&
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|==
name|reg
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|reg
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|rtx
name|src3
init|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|new_src
init|=
name|gen_mode_int
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|INTVAL
argument_list|(
name|src3
argument_list|)
operator|-
name|INTVAL
argument_list|(
name|reg_offset
index|[
name|regno
index|]
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|success
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|new_src
operator|==
name|const0_rtx
condition|)
comment|/* See above why we create (set (reg) (reg)) here.  */
name|success
operator|=
name|validate_change
argument_list|(
name|next
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|rtx_cost
argument_list|(
name|new_src
argument_list|,
name|PLUS
argument_list|)
operator|<
literal|2
operator|+
name|rtx_cost
argument_list|(
name|src3
argument_list|,
name|SET
argument_list|)
operator|)
operator|&&
name|have_add2_insn
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
condition|)
name|success
operator|=
name|validate_change
argument_list|(
name|next
argument_list|,
operator|&
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|,
name|gen_add2_insn
argument_list|(
name|reg
argument_list|,
name|new_src
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
comment|/* INSN might be the first insn in a basic block 			     if the preceding insn is a conditional jump 			     or a possible-throwing call.  */
name|PUT_CODE
argument_list|(
name|insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|insn
operator|=
name|next
expr_stmt|;
name|reg_set_luid
index|[
name|regno
index|]
operator|=
name|move2add_luid
expr_stmt|;
name|reg_mode
index|[
name|regno
index|]
operator|=
name|GET_MODE
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|reg_offset
index|[
name|regno
index|]
operator|=
name|src3
expr_stmt|;
continue|continue;
block|}
block|}
block|}
block|}
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
block|{
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_INC
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
comment|/* Indicate that this register has been recently written to, 		 but the exact contents are not available.  */
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|reg_set_luid
index|[
name|regno
index|]
operator|=
name|move2add_luid
expr_stmt|;
name|reg_offset
index|[
name|regno
index|]
operator|=
name|note
expr_stmt|;
block|}
block|}
block|}
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|move2add_note_store
argument_list|)
expr_stmt|;
comment|/* If this is a CALL_INSN, all call used registers are stored with 	 unknown values.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|call_used_regs
index|[
name|i
index|]
condition|)
block|{
name|reg_set_luid
index|[
name|i
index|]
operator|=
name|move2add_luid
expr_stmt|;
name|reg_offset
index|[
name|i
index|]
operator|=
name|insn
expr_stmt|;
comment|/* Invalidate contents.  */
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* SET is a SET or CLOBBER that sets DST.    Update reg_set_luid, reg_offset and reg_base_reg accordingly.    Called from reload_cse_move2add via note_stores.  */
end_comment

begin_function
specifier|static
name|void
name|move2add_note_store
parameter_list|(
name|dst
parameter_list|,
name|set
parameter_list|)
name|rtx
name|dst
decl_stmt|,
name|set
decl_stmt|;
block|{
name|int
name|regno
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|dst
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|regno
operator|=
name|SUBREG_WORD
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|dst
operator|=
name|SUBREG_REG
argument_list|(
name|dst
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|!=
name|REG
condition|)
return|return;
name|regno
operator|+=
name|REGNO
argument_list|(
name|dst
argument_list|)
expr_stmt|;
if|if
condition|(
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|==
literal|1
operator|&&
name|GET_CODE
argument_list|(
name|set
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|!=
name|ZERO_EXTRACT
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|!=
name|SIGN_EXTRACT
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|!=
name|STRICT_LOW_PART
condition|)
block|{
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
decl_stmt|;
name|reg_mode
index|[
name|regno
index|]
operator|=
name|mode
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
condition|)
block|{
case|case
name|PLUS
case|:
block|{
name|rtx
name|src0
init|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src0
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|REGNO
argument_list|(
name|src0
argument_list|)
operator|!=
name|regno
operator|||
name|reg_offset
index|[
name|regno
index|]
operator|!=
name|const0_rtx
condition|)
block|{
name|reg_base_reg
index|[
name|regno
index|]
operator|=
name|REGNO
argument_list|(
name|src0
argument_list|)
expr_stmt|;
name|reg_set_luid
index|[
name|regno
index|]
operator|=
name|move2add_luid
expr_stmt|;
block|}
name|reg_offset
index|[
name|regno
index|]
operator|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
name|reg_set_luid
index|[
name|regno
index|]
operator|=
name|move2add_luid
expr_stmt|;
name|reg_offset
index|[
name|regno
index|]
operator|=
name|set
expr_stmt|;
comment|/* Invalidate contents.  */
break|break;
block|}
case|case
name|REG
case|:
name|reg_base_reg
index|[
name|regno
index|]
operator|=
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
name|reg_offset
index|[
name|regno
index|]
operator|=
name|const0_rtx
expr_stmt|;
name|reg_set_luid
index|[
name|regno
index|]
operator|=
name|move2add_luid
expr_stmt|;
break|break;
default|default:
name|reg_base_reg
index|[
name|regno
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|reg_offset
index|[
name|regno
index|]
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|reg_set_luid
index|[
name|regno
index|]
operator|=
name|move2add_luid
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
name|regno
condition|;
name|i
operator|--
control|)
block|{
comment|/* Indicate that this register has been recently written to, 	     but the exact contents are not available.  */
name|reg_set_luid
index|[
name|i
index|]
operator|=
name|move2add_luid
expr_stmt|;
name|reg_offset
index|[
name|i
index|]
operator|=
name|dst
expr_stmt|;
block|}
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
end_ifdef

begin_function
specifier|static
name|void
name|add_auto_inc_notes
parameter_list|(
name|insn
parameter_list|,
name|x
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|MEM
operator|&&
name|auto_inc_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_INC
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Scan all the operand sub-expressions.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|add_auto_inc_notes
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|add_auto_inc_notes
argument_list|(
name|insn
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

