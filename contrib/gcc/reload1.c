begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Reload pseudo regs into hard regs for insns that require hard regs.    Copyright (C) 1987, 88, 89, 92-97, 1998 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"machmode.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"insn-flags.h"
end_include

begin_include
include|#
directive|include
file|"insn-codes.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_comment
comment|/* This file contains the reload pass of the compiler, which is    run after register allocation has been done.  It checks that    each insn is valid (operands required to be in registers really    are in registers of the proper class) and fixes up invalid ones    by copying values temporarily into registers for the insns    that need them.     The results of register allocation are described by the vector    reg_renumber; the insns still contain pseudo regs, but reg_renumber    can be used to find which hard reg, if any, a pseudo reg is in.     The technique we always use is to free up a few hard regs that are    called ``reload regs'', and for each place where a pseudo reg    must be in a hard reg, copy it temporarily into one of the reload regs.     All the pseudos that were formerly allocated to the hard regs that    are now in use as reload regs must be ``spilled''.  This means    that they go to other hard regs, or to stack slots if no other    available hard regs can be found.  Spilling can invalidate more    insns, requiring additional need for reloads, so we must keep checking    until the process stabilizes.     For machines with different classes of registers, we must keep track    of the register class needed for each reload, and make sure that    we allocate enough reload registers of each class.     The file reload.c contains the code that checks one insn for    validity and reports the reloads that it needs.  This file    is in charge of scanning the entire rtl code, accumulating the    reload needs, spilling, assigning reload registers to use for    fixing up each insn, and generating the new insns to copy values    into the reload registers.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|REGISTER_MOVE_COST
end_ifndef

begin_define
define|#
directive|define
name|REGISTER_MOVE_COST
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* During reload_as_needed, element N contains a REG rtx for the hard reg    into which reg N has been reloaded (perhaps for a previous insn).  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|reg_last_reload_reg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Elt N nonzero if reg_last_reload_reg[N] has been set in this insn    for an output reload that stores into reg N.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|reg_has_output_reload
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indicates which hard regs are reload-registers for an output reload    in the current insn.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|reg_is_output_reload
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element N is the constant value to which pseudo reg N is equivalent,    or zero if pseudo reg N is not equivalent to a constant.    find_reloads looks at this in order to replace pseudo reg N    with the constant it stands for.  */
end_comment

begin_decl_stmt
name|rtx
modifier|*
name|reg_equiv_constant
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element N is a memory location to which pseudo reg N is equivalent,    prior to any register elimination (such as frame pointer to stack    pointer).  Depending on whether or not it is a valid address, this value    is transferred to either reg_equiv_address or reg_equiv_mem.  */
end_comment

begin_decl_stmt
name|rtx
modifier|*
name|reg_equiv_memory_loc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element N is the address of stack slot to which pseudo reg N is equivalent.    This is used when the address is not valid as a memory address    (because its displacement is too big for the machine.)  */
end_comment

begin_decl_stmt
name|rtx
modifier|*
name|reg_equiv_address
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element N is the memory slot to which pseudo reg N is equivalent,    or zero if pseudo reg N is not equivalent to a memory slot.  */
end_comment

begin_decl_stmt
name|rtx
modifier|*
name|reg_equiv_mem
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Widest width in which each pseudo reg is referred to (via subreg).  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|reg_max_ref_width
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element N is the insn that initialized reg N from its equivalent    constant or memory slot.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|reg_equiv_init
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* During reload_as_needed, element N contains the last pseudo regno reloaded   into hard register N.  If that pseudo reg occupied more than one register,    reg_reloaded_contents points to that pseudo for each spill register in    use; all of these must remain set for an inheritance to occur.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|reg_reloaded_contents
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* During reload_as_needed, element N contains the insn for which    hard register N was last used.   Its contents are significant only    when reg_reloaded_valid is set for this register.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|reg_reloaded_insn
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indicate if reg_reloaded_insn / reg_reloaded_contents is valid */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|reg_reloaded_valid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indicate if the register was dead at the end of the reload.    This is only valid if reg_reloaded_contents is set and valid.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|reg_reloaded_dead
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of spill-regs so far; number of valid elements of spill_regs.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|n_spills
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* In parallel with spill_regs, contains REG rtx's for those regs.    Holds the last rtx used for any given reg, or 0 if it has never    been used for spilling yet.  This rtx is reused, provided it has    the proper mode.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|spill_reg_rtx
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* In parallel with spill_regs, contains nonzero for a spill reg    that was stored after the last time it was used.    The precise value is the insn generated to do the store.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|spill_reg_store
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This table is the inverse mapping of spill_regs:    indexed by hard reg number,    it contains the position of that reg in spill_regs,    or -1 for something that is not in spill_regs.  */
end_comment

begin_decl_stmt
specifier|static
name|short
name|spill_reg_order
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This reg set indicates registers that may not be used for retrying global    allocation.  The registers that may not be used include all spill registers    and the frame pointer (if we are using one).  */
end_comment

begin_decl_stmt
name|HARD_REG_SET
name|forbidden_regs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This reg set indicates registers that are not good for spill registers.    They will not be used to complete groups of spill registers.  This includes    all fixed registers, registers that may be eliminated, and, if    SMALL_REGISTER_CLASSES is zero, registers explicitly used in the rtl.     (spill_reg_order prevents these registers from being used to start a    group.)  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|bad_spill_regs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Describes order of use of registers for reloading    of spilled pseudo-registers.  `spills' is the number of    elements that are actually valid; new ones are added at the end.  */
end_comment

begin_decl_stmt
specifier|static
name|short
name|spill_regs
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This reg set indicates those registers that have been used a spill    registers.  This information is used in reorg.c, to help figure out    what registers are live at any point.  It is assumed that all spill_regs    are dead at every CODE_LABEL.  */
end_comment

begin_decl_stmt
name|HARD_REG_SET
name|used_spill_regs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index of last register assigned as a spill register.  We allocate in    a round-robin fashion.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|last_spill_reg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Describes order of preference for putting regs into spill_regs.    Contains the numbers of all the hard regs, in order most preferred first.    This order is different for each function.    It is set up by order_regs_for_reload.    Empty elements at the end contain -1.  */
end_comment

begin_decl_stmt
specifier|static
name|short
name|potential_reload_regs
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 for a hard register that appears explicitly in the rtl    (for example, function value registers, special registers    used by insns, structure value pointer registers).  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|regs_explicitly_used
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indicates if a register was counted against the need for    groups.  0 means it can count against max_nongroup instead.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|counted_for_groups
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indicates if a register was counted against the need for    non-groups.  0 means it can become part of a new group.    During choose_reload_regs, 1 here means don't use this reg    as part of a group, even if it seems to be otherwise ok.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|counted_for_nongroups
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if indirect addressing is supported on the machine; this means    that spilling (REG n) does not require reloading it into a register in    order to do (MEM (REG n)) or (MEM (PLUS (REG n) (CONST_INT c))).  The    value indicates the level of indirect addressing supported, e.g., two    means that (MEM (MEM (REG n))) is also valid if (REG n) does not get    a hard register.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|spill_indirect_levels
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if indirect addressing is supported when the innermost MEM is    of the form (MEM (SYMBOL_REF sym)).  It is assumed that the level to    which these are valid is the same as spill_indirect_levels, above.   */
end_comment

begin_decl_stmt
name|char
name|indirect_symref_ok
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if an address (plus (reg frame_pointer) (reg ...)) is valid.  */
end_comment

begin_decl_stmt
name|char
name|double_reg_address_ok
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record the stack slot for each spilled hard register.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|spill_stack_slot
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Width allocated so far for that stack slot.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|spill_stack_slot_width
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by register class and basic block number, nonzero if there is    any need for a spill register of that class in that basic block.    The pointer is 0 if we did stupid allocation and don't know    the structure of basic blocks.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|basic_block_needs
index|[
name|N_REG_CLASSES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* First uid used by insns created by reload in this function.    Used in find_equiv_reg.  */
end_comment

begin_decl_stmt
name|int
name|reload_first_uid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag set by local-alloc or global-alloc if anything is live in    a call-clobbered reg across calls.  */
end_comment

begin_decl_stmt
name|int
name|caller_save_needed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The register class to use for a base register when reloading an    address.  This is normally BASE_REG_CLASS, but it may be different    when using SMALL_REGISTER_CLASSES and passing parameters in    registers.  */
end_comment

begin_decl_stmt
name|enum
name|reg_class
name|reload_address_base_reg_class
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The register class to use for an index register when reloading an    address.  This is normally INDEX_REG_CLASS, but it may be different    when using SMALL_REGISTER_CLASSES and passing parameters in    registers.  */
end_comment

begin_decl_stmt
name|enum
name|reg_class
name|reload_address_index_reg_class
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to 1 while reload_as_needed is operating.    Required by some machines to handle any generated moves differently.  */
end_comment

begin_decl_stmt
name|int
name|reload_in_progress
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These arrays record the insn_code of insns that may be needed to    perform input and output reloads of special objects.  They provide a    place to pass a scratch register.  */
end_comment

begin_decl_stmt
name|enum
name|insn_code
name|reload_in_optab
index|[
name|NUM_MACHINE_MODES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|insn_code
name|reload_out_optab
index|[
name|NUM_MACHINE_MODES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This obstack is used for allocation of rtl during register elimination.    The allocated storage can be freed once find_reloads has processed the    insn.  */
end_comment

begin_decl_stmt
name|struct
name|obstack
name|reload_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|reload_firstobj
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_comment
comment|/* List of labels that must never be deleted.  */
end_comment

begin_decl_stmt
specifier|extern
name|rtx
name|forced_labels
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Allocation number table from global register allocation.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
modifier|*
name|reg_allocno
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* This structure is used to record information about register eliminations.    Each array entry describes one possible way of eliminating a register    in favor of another.   If there is more than one way of eliminating a    particular register, the most preferred should be specified first.  */
end_comment

begin_struct
specifier|static
struct|struct
name|elim_table
block|{
name|int
name|from
decl_stmt|;
comment|/* Register number to be eliminated.  */
name|int
name|to
decl_stmt|;
comment|/* Register number used as replacement.  */
name|int
name|initial_offset
decl_stmt|;
comment|/* Initial difference between values.  */
name|int
name|can_eliminate
decl_stmt|;
comment|/* Non-zero if this elimination can be done.  */
name|int
name|can_eliminate_previous
decl_stmt|;
comment|/* Value of CAN_ELIMINATE in previous scan over 				   insns made by reload.  */
name|int
name|offset
decl_stmt|;
comment|/* Current offset between the two regs.  */
name|int
name|max_offset
decl_stmt|;
comment|/* Maximum offset between the two regs.  */
name|int
name|previous_offset
decl_stmt|;
comment|/* Offset at end of previous insn.  */
name|int
name|ref_outside_mem
decl_stmt|;
comment|/* "to" has been referenced outside a MEM.  */
name|rtx
name|from_rtx
decl_stmt|;
comment|/* REG rtx for the register to be eliminated. 				   We cannot simply compare the number since 				   we might then spuriously replace a hard 				   register corresponding to a pseudo 				   assigned to the reg to be eliminated.  */
name|rtx
name|to_rtx
decl_stmt|;
comment|/* REG rtx for the replacement.  */
block|}
name|reg_eliminate
index|[]
init|=
comment|/* If a set of eliminable registers was specified, define the table from it.    Otherwise, default to the normal case of the frame pointer being    replaced by the stack pointer.  */
ifdef|#
directive|ifdef
name|ELIMINABLE_REGS
name|ELIMINABLE_REGS
struct|;
end_struct

begin_else
else|#
directive|else
end_else

begin_block
block|{
block|{
name|FRAME_POINTER_REGNUM
operator|,
name|STACK_POINTER_REGNUM
block|}
block|}
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|NUM_ELIMINABLE_REGS
value|(sizeof reg_eliminate / sizeof reg_eliminate[0])
end_define

begin_comment
comment|/* Record the number of pending eliminations that have an offset not equal    to their initial offset.  If non-zero, we use a new copy of each    replacement result in any insns encountered.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|num_not_at_initial_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Count the number of registers that we may be able to eliminate.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|num_eliminable
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For each label, we record the offset of each elimination.  If we reach    a label by more than one path and an offset differs, we cannot do the    elimination.  This information is indexed by the number of the label.    The first table is an array of flags that records whether we have yet    encountered a label and the second table is an array of arrays, one    entry in the latter array for each elimination.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|offsets_known_at
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|int
argument_list|(
operator|*
name|offsets_at
argument_list|)
index|[
name|NUM_ELIMINABLE_REGS
index|]
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Number of labels in the current function.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|num_labels
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|hard_reg_n_uses
block|{
name|int
name|regno
decl_stmt|;
name|int
name|uses
decl_stmt|;
block|}
struct|;
end_struct

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|int
name|possible_group_p
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|count_possible_groups
name|PROTO
argument_list|(
operator|(
name|int
operator|*
operator|,
expr|enum
name|machine_mode
operator|*
operator|,
name|int
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|modes_equiv_for_class_p
name|PROTO
argument_list|(
operator|(
expr|enum
name|machine_mode
operator|,
expr|enum
name|machine_mode
operator|,
expr|enum
name|reg_class
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|spill_failure
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|new_spill_reg
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|,
name|int
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|delete_dead_insn
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|alter_reg
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_scratch_live
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_label_offsets
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|eliminate_regs_in_insn
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_not_eliminable
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|spill_hard_reg
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|FILE
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|scan_paradoxical_subregs
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hard_reg_use_compare
name|PROTO
argument_list|(
operator|(
specifier|const
name|GENERIC_PTR
operator|,
specifier|const
name|GENERIC_PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|order_regs_for_reload
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|compare_spill_regs
name|PROTO
argument_list|(
operator|(
specifier|const
name|GENERIC_PTR
operator|,
specifier|const
name|GENERIC_PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reload_as_needed
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|forget_old_reloads_1
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reload_reg_class_lower
name|PROTO
argument_list|(
operator|(
specifier|const
name|GENERIC_PTR
operator|,
specifier|const
name|GENERIC_PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_reload_reg_in_use
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
expr|enum
name|reload_type
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|clear_reload_reg_in_use
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
expr|enum
name|reload_type
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reload_reg_free_p
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
expr|enum
name|reload_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reload_reg_free_before_p
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
expr|enum
name|reload_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reload_reg_free_for_value_p
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
expr|enum
name|reload_type
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reload_reg_reaches_end_p
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
expr|enum
name|reload_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|allocate_reload_reg
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|rtx
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|choose_reload_regs
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|merge_assigned_reloads
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|emit_reload_insns
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|delete_output_reload
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|inc_for_reload
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|constraint_accepts_reg_p
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reload_cse_invalidate_regno
name|PROTO
argument_list|(
operator|(
name|int
operator|,
expr|enum
name|machine_mode
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reload_cse_mem_conflict_p
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reload_cse_invalidate_mem
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reload_cse_invalidate_rtx
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reload_cse_regno_equal_p
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|rtx
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reload_cse_noop_set_p
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reload_cse_simplify_set
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reload_cse_simplify_operands
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reload_cse_check_clobber
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reload_cse_record_set
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reload_cse_delete_death_notes
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reload_cse_no_longer_dead
name|PROTO
argument_list|(
operator|(
name|int
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Initialize the reload pass once per compilation.  */
end_comment

begin_function
name|void
name|init_reload
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Often (MEM (REG n)) is still valid even if (REG n) is put on the stack.      Set spill_indirect_levels to the number of levels such addressing is      permitted, zero if it is not permitted at all.  */
specifier|register
name|rtx
name|tem
init|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|LAST_VIRTUAL_REGISTER
operator|+
literal|1
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|4
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|spill_indirect_levels
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|memory_address_p
argument_list|(
name|QImode
argument_list|,
name|tem
argument_list|)
condition|)
block|{
name|spill_indirect_levels
operator|++
expr_stmt|;
name|tem
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|tem
argument_list|)
expr_stmt|;
block|}
comment|/* See if indirect addressing is valid for (MEM (SYMBOL_REF ...)).  */
name|tem
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
literal|"foo"
argument_list|)
argument_list|)
expr_stmt|;
name|indirect_symref_ok
operator|=
name|memory_address_p
argument_list|(
name|QImode
argument_list|,
name|tem
argument_list|)
expr_stmt|;
comment|/* See if reg+reg is a valid (and offsettable) address.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
name|tem
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|HARD_FRAME_POINTER_REGNUM
argument_list|)
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This way, we make sure that reg+reg is an offsettable address.  */
name|tem
operator|=
name|plus_constant
argument_list|(
name|tem
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|memory_address_p
argument_list|(
name|QImode
argument_list|,
name|tem
argument_list|)
condition|)
block|{
name|double_reg_address_ok
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* Initialize obstack for our rtl allocation.  */
name|gcc_obstack_init
argument_list|(
operator|&
name|reload_obstack
argument_list|)
expr_stmt|;
name|reload_firstobj
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|reload_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Decide which register class should be used when reloading      addresses.  If we are using SMALL_REGISTER_CLASSES, and any      parameters are passed in registers, then we do not want to use      those registers when reloading an address.  Otherwise, if a      function argument needs a reload, we may wind up clobbering      another argument to the function which was already computed.  If      we find a subset class which simply avoids those registers, we      use it instead.  ??? It would be better to only use the      restricted class when we actually are loading function arguments,      but that is hard to determine.  */
name|reload_address_base_reg_class
operator|=
name|BASE_REG_CLASS
expr_stmt|;
name|reload_address_index_reg_class
operator|=
name|INDEX_REG_CLASS
expr_stmt|;
if|if
condition|(
name|SMALL_REGISTER_CLASSES
condition|)
block|{
name|int
name|regno
decl_stmt|;
name|HARD_REG_SET
name|base
decl_stmt|,
name|index
decl_stmt|;
name|enum
name|reg_class
modifier|*
name|p
decl_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|base
argument_list|,
name|reg_class_contents
index|[
name|BASE_REG_CLASS
index|]
argument_list|)
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|index
argument_list|,
name|reg_class_contents
index|[
name|INDEX_REG_CLASS
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
block|{
if|if
condition|(
name|FUNCTION_ARG_REGNO_P
argument_list|(
name|regno
argument_list|)
condition|)
block|{
name|CLEAR_HARD_REG_BIT
argument_list|(
name|base
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_BIT
argument_list|(
name|index
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
name|GO_IF_HARD_REG_EQUAL
argument_list|(
name|base
argument_list|,
name|reg_class_contents
index|[
name|BASE_REG_CLASS
index|]
argument_list|,
name|baseok
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|reg_class_subclasses
index|[
name|BASE_REG_CLASS
index|]
init|;
operator|*
name|p
operator|!=
name|LIM_REG_CLASSES
condition|;
name|p
operator|++
control|)
block|{
name|GO_IF_HARD_REG_EQUAL
argument_list|(
name|base
argument_list|,
name|reg_class_contents
index|[
operator|*
name|p
index|]
argument_list|,
name|usebase
argument_list|)
expr_stmt|;
continue|continue;
name|usebase
label|:
name|reload_address_base_reg_class
operator|=
operator|*
name|p
expr_stmt|;
break|break;
block|}
name|baseok
label|:
empty_stmt|;
name|GO_IF_HARD_REG_EQUAL
argument_list|(
name|index
argument_list|,
name|reg_class_contents
index|[
name|INDEX_REG_CLASS
index|]
argument_list|,
name|indexok
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|reg_class_subclasses
index|[
name|INDEX_REG_CLASS
index|]
init|;
operator|*
name|p
operator|!=
name|LIM_REG_CLASSES
condition|;
name|p
operator|++
control|)
block|{
name|GO_IF_HARD_REG_EQUAL
argument_list|(
name|index
argument_list|,
name|reg_class_contents
index|[
operator|*
name|p
index|]
argument_list|,
name|useindex
argument_list|)
expr_stmt|;
continue|continue;
name|useindex
label|:
name|reload_address_index_reg_class
operator|=
operator|*
name|p
expr_stmt|;
break|break;
block|}
name|indexok
label|:
empty_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Main entry point for the reload pass.     FIRST is the first insn of the function being compiled.     GLOBAL nonzero means we were called from global_alloc    and should attempt to reallocate any pseudoregs that we    displace from hard regs we will use for reloads.    If GLOBAL is zero, we do not have enough information to do that,    so any pseudo reg that is spilled must go to the stack.     DUMPFILE is the global-reg debugging dump file stream, or 0.    If it is nonzero, messages are written to it to describe    which registers are seized as reload regs, which pseudo regs    are spilled from them, and where the pseudo regs are reallocated to.     Return value is nonzero if reload failed    and we must not do any more for this function.  */
end_comment

begin_function
name|int
name|reload
parameter_list|(
name|first
parameter_list|,
name|global
parameter_list|,
name|dumpfile
parameter_list|)
name|rtx
name|first
decl_stmt|;
name|int
name|global
decl_stmt|;
name|FILE
modifier|*
name|dumpfile
decl_stmt|;
block|{
specifier|register
name|int
name|class
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
specifier|register
name|rtx
name|insn
decl_stmt|;
specifier|register
name|struct
name|elim_table
modifier|*
name|ep
decl_stmt|;
comment|/* The two pointers used to track the true location of the memory used      for label offsets.  */
name|char
modifier|*
name|real_known_ptr
init|=
name|NULL_PTR
decl_stmt|;
name|int
argument_list|(
operator|*
name|real_at_ptr
argument_list|)
index|[
name|NUM_ELIMINABLE_REGS
index|]
expr_stmt|;
name|int
name|something_changed
decl_stmt|;
name|int
name|something_needs_reloads
decl_stmt|;
name|int
name|something_needs_elimination
decl_stmt|;
name|int
name|new_basic_block_needs
decl_stmt|;
name|enum
name|reg_class
name|caller_save_spill_class
init|=
name|NO_REGS
decl_stmt|;
name|int
name|caller_save_group_size
init|=
literal|1
decl_stmt|;
comment|/* Nonzero means we couldn't get enough spill regs.  */
name|int
name|failure
init|=
literal|0
decl_stmt|;
comment|/* The basic block number currently being processed for INSN.  */
name|int
name|this_block
decl_stmt|;
comment|/* Make sure even insns with volatile mem refs are recognizable.  */
name|init_recog
argument_list|()
expr_stmt|;
comment|/* Enable find_equiv_reg to distinguish insns made by reload.  */
name|reload_first_uid
operator|=
name|get_max_uid
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_REG_CLASSES
condition|;
name|i
operator|++
control|)
name|basic_block_needs
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|SECONDARY_MEMORY_NEEDED
comment|/* Initialize the secondary memory table.  */
name|clear_secondary_mem
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Remember which hard regs appear explicitly      before we merge into `regs_ever_live' the ones in which      pseudo regs have been allocated.  */
name|bcopy
argument_list|(
name|regs_ever_live
argument_list|,
name|regs_explicitly_used
argument_list|,
sizeof|sizeof
name|regs_ever_live
argument_list|)
expr_stmt|;
comment|/* We don't have a stack slot for any spill reg yet.  */
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|spill_stack_slot
argument_list|,
sizeof|sizeof
name|spill_stack_slot
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|spill_stack_slot_width
argument_list|,
sizeof|sizeof
name|spill_stack_slot_width
argument_list|)
expr_stmt|;
comment|/* Initialize the save area information for caller-save, in case some      are needed.  */
name|init_save_areas
argument_list|()
expr_stmt|;
comment|/* Compute which hard registers are now in use      as homes for pseudo registers.      This is done here rather than (eg) in global_alloc      because this point is reached even if not optimizing.  */
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
name|mark_home_live
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* A function that receives a nonlocal goto must save all call-saved      registers.  */
if|if
condition|(
name|current_function_has_nonlocal_label
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|call_used_regs
index|[
name|i
index|]
operator|&&
operator|!
name|fixed_regs
index|[
name|i
index|]
condition|)
name|regs_ever_live
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|scratch_list_length
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|scratch_list
index|[
name|i
index|]
condition|)
name|mark_scratch_live
argument_list|(
name|scratch_list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Make sure that the last insn in the chain      is not something that needs reloading.  */
name|emit_note
argument_list|(
name|NULL_PTR
argument_list|,
name|NOTE_INSN_DELETED
argument_list|)
expr_stmt|;
comment|/* Find all the pseudo registers that didn't get hard regs      but do have known equivalent constants or memory slots.      These include parameters (known equivalent to parameter slots)      and cse'd or loop-moved constant memory addresses.       Record constant equivalents in reg_equiv_constant      so they will be substituted by find_reloads.      Record memory equivalents in reg_mem_equiv so they can      be substituted eventually by altering the REG-rtx's.  */
name|reg_equiv_constant
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_equiv_constant
argument_list|,
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|reg_equiv_memory_loc
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_equiv_memory_loc
argument_list|,
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|reg_equiv_mem
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_equiv_mem
argument_list|,
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|reg_equiv_init
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_equiv_init
argument_list|,
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|reg_equiv_address
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_equiv_address
argument_list|,
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|reg_max_ref_width
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_max_ref_width
argument_list|,
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SMALL_REGISTER_CLASSES
condition|)
name|CLEAR_HARD_REG_SET
argument_list|(
name|forbidden_regs
argument_list|)
expr_stmt|;
comment|/* Look for REG_EQUIV notes; record what each pseudo is equivalent to.      Also find all paradoxical subregs and find largest such for each pseudo.      On machines with small register classes, record hard registers that      are used for user variables.  These can never be used for spills.       Also look for a "constant" NOTE_INSN_SETJMP.  This means that all      caller-saved registers must be marked live.  */
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|CONST_CALL_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_SETJMP
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|call_used_regs
index|[
name|i
index|]
condition|)
name|regs_ever_live
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|set
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUIV
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
if|if
condition|(
name|note
ifdef|#
directive|ifdef
name|LEGITIMATE_PIC_OPERAND_P
operator|&&
operator|(
operator|!
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
operator|!
name|flag_pic
operator|||
name|LEGITIMATE_PIC_OPERAND_P
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
endif|#
directive|endif
condition|)
block|{
name|rtx
name|x
init|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|i
operator|=
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|LAST_VIRTUAL_REGISTER
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
block|{
comment|/* If the operand is a PLUS, the MEM may be shared, 			 so make sure we have an unshared copy here.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
name|x
operator|=
name|copy_rtx
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|reg_equiv_memory_loc
index|[
name|i
index|]
operator|=
name|x
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
name|LEGITIMATE_CONSTANT_P
argument_list|(
name|x
argument_list|)
condition|)
name|reg_equiv_constant
index|[
name|i
index|]
operator|=
name|x
expr_stmt|;
else|else
name|reg_equiv_memory_loc
index|[
name|i
index|]
operator|=
name|force_const_mem
argument_list|(
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
else|else
continue|continue;
comment|/* If this register is being made equivalent to a MEM 		     and the MEM is not SET_SRC, the equivalencing insn 		     is one with the MEM as a SET_DEST and it occurs later. 		     So don't mark this insn now.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
operator|||
name|rtx_equal_p
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|x
argument_list|)
condition|)
name|reg_equiv_init
index|[
name|i
index|]
operator|=
name|insn
expr_stmt|;
block|}
block|}
block|}
comment|/* If this insn is setting a MEM from a register equivalent to it, 	 this is the equivalencing insn.  */
elseif|else
if|if
condition|(
name|set
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|reg_equiv_memory_loc
index|[
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
index|]
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|reg_equiv_memory_loc
index|[
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
index|]
argument_list|)
condition|)
name|reg_equiv_init
index|[
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
index|]
operator|=
name|insn
expr_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
name|scan_paradoxical_subregs
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Does this function require a frame pointer?  */
name|frame_pointer_needed
operator|=
operator|(
operator|!
name|flag_omit_frame_pointer
ifdef|#
directive|ifdef
name|EXIT_IGNORE_STACK
comment|/* ?? If EXIT_IGNORE_STACK is set, we will not save 			     and restore sp for alloca.  So we can't eliminate 			     the frame pointer in that case.  At some point, 			     we should improve this by emitting the 			     sp-adjusting insns for this case.  */
operator|||
operator|(
name|current_function_calls_alloca
operator|&&
name|EXIT_IGNORE_STACK
operator|)
endif|#
directive|endif
operator|||
name|FRAME_POINTER_REQUIRED
operator|)
expr_stmt|;
name|num_eliminable
operator|=
literal|0
expr_stmt|;
comment|/* Initialize the table of registers to eliminate.  The way we do this      depends on how the eliminable registers were defined.  */
ifdef|#
directive|ifdef
name|ELIMINABLE_REGS
for|for
control|(
name|ep
operator|=
name|reg_eliminate
init|;
name|ep
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|ep
operator|++
control|)
block|{
name|ep
operator|->
name|can_eliminate
operator|=
name|ep
operator|->
name|can_eliminate_previous
operator|=
operator|(
name|CAN_ELIMINATE
argument_list|(
name|ep
operator|->
name|from
argument_list|,
name|ep
operator|->
name|to
argument_list|)
operator|&&
operator|!
operator|(
name|ep
operator|->
name|to
operator|==
name|STACK_POINTER_REGNUM
operator|&&
name|frame_pointer_needed
operator|)
operator|)
expr_stmt|;
block|}
else|#
directive|else
name|reg_eliminate
index|[
literal|0
index|]
operator|.
name|can_eliminate
operator|=
name|reg_eliminate
index|[
literal|0
index|]
operator|.
name|can_eliminate_previous
operator|=
operator|!
name|frame_pointer_needed
expr_stmt|;
endif|#
directive|endif
comment|/* Count the number of eliminable registers and build the FROM and TO      REG rtx's.  Note that code in gen_rtx will cause, e.g.,      gen_rtx (REG, Pmode, STACK_POINTER_REGNUM) to equal stack_pointer_rtx.      We depend on this.  */
for|for
control|(
name|ep
operator|=
name|reg_eliminate
init|;
name|ep
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|ep
operator|++
control|)
block|{
name|num_eliminable
operator|+=
name|ep
operator|->
name|can_eliminate
expr_stmt|;
name|ep
operator|->
name|from_rtx
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|ep
operator|->
name|from
argument_list|)
expr_stmt|;
name|ep
operator|->
name|to_rtx
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|ep
operator|->
name|to
argument_list|)
expr_stmt|;
block|}
name|num_labels
operator|=
name|max_label_num
argument_list|()
operator|-
name|get_first_label_num
argument_list|()
expr_stmt|;
comment|/* Allocate the tables used to store offset information at labels.  */
comment|/* We used to use alloca here, but the size of what it would try to      allocate would occasionally cause it to exceed the stack limit and      cause a core dump.  */
name|real_known_ptr
operator|=
name|xmalloc
argument_list|(
name|num_labels
argument_list|)
expr_stmt|;
name|real_at_ptr
operator|=
operator|(
name|int
argument_list|(
operator|*
argument_list|)
index|[
name|NUM_ELIMINABLE_REGS
index|]
operator|)
name|xmalloc
argument_list|(
name|num_labels
operator|*
name|NUM_ELIMINABLE_REGS
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|offsets_known_at
operator|=
name|real_known_ptr
operator|-
name|get_first_label_num
argument_list|()
expr_stmt|;
name|offsets_at
operator|=
operator|(
name|int
argument_list|(
operator|*
argument_list|)
index|[
name|NUM_ELIMINABLE_REGS
index|]
operator|)
operator|(
name|real_at_ptr
operator|-
name|get_first_label_num
argument_list|()
operator|)
expr_stmt|;
comment|/* Alter each pseudo-reg rtx to contain its hard reg number.      Assign stack slots to the pseudos that lack hard regs or equivalents.      Do not touch virtual registers.  */
for|for
control|(
name|i
operator|=
name|LAST_VIRTUAL_REGISTER
operator|+
literal|1
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
name|alter_reg
argument_list|(
name|i
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* If we have some registers we think can be eliminated, scan all insns to      see if there is an insn that sets one of these registers to something      other than itself plus a constant.  If so, the register cannot be      eliminated.  Doing this scan here eliminates an extra pass through the      main reload loop in the most common case where register elimination      cannot be done.  */
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
operator|&&
name|num_eliminable
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|mark_not_eliminable
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|REGISTER_CONSTRAINTS
comment|/* If all the pseudo regs have hard regs,      except for those that are never referenced,      we know that no reloads are needed.  */
comment|/* But that is not true if there are register constraints, since      in that case some pseudos might be in the wrong kind of hard reg.  */
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reg_renumber
index|[
name|i
index|]
operator|==
operator|-
literal|1
operator|&&
name|REG_N_REFS
argument_list|(
name|i
argument_list|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|max_regno
operator|&&
name|num_eliminable
operator|==
literal|0
operator|&&
operator|!
name|caller_save_needed
condition|)
block|{
name|free
argument_list|(
name|real_known_ptr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|real_at_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* Compute the order of preference for hard registers to spill.      Store them by decreasing preference in potential_reload_regs.  */
name|order_regs_for_reload
argument_list|(
name|global
argument_list|)
expr_stmt|;
comment|/* So far, no hard regs have been spilled.  */
name|n_spills
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
name|spill_reg_order
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Initialize to -1, which means take the first spill register.  */
name|last_spill_reg
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* On most machines, we can't use any register explicitly used in the      rtl as a spill register.  But on some, we have to.  Those will have      taken care to keep the life of hard regs as short as possible.  */
if|if
condition|(
operator|!
name|SMALL_REGISTER_CLASSES
condition|)
name|COPY_HARD_REG_SET
argument_list|(
name|forbidden_regs
argument_list|,
name|bad_spill_regs
argument_list|)
expr_stmt|;
comment|/* Spill any hard regs that we know we can't eliminate.  */
for|for
control|(
name|ep
operator|=
name|reg_eliminate
init|;
name|ep
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|ep
operator|++
control|)
if|if
condition|(
operator|!
name|ep
operator|->
name|can_eliminate
condition|)
name|spill_hard_reg
argument_list|(
name|ep
operator|->
name|from
argument_list|,
name|global
argument_list|,
name|dumpfile
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
name|HARD_FRAME_POINTER_REGNUM
operator|!=
name|FRAME_POINTER_REGNUM
if|if
condition|(
name|frame_pointer_needed
condition|)
name|spill_hard_reg
argument_list|(
name|HARD_FRAME_POINTER_REGNUM
argument_list|,
name|global
argument_list|,
name|dumpfile
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|global
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_REG_CLASSES
condition|;
name|i
operator|++
control|)
block|{
name|basic_block_needs
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|basic_block_needs
index|[
name|i
index|]
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
block|}
comment|/* From now on, we need to emit any moves without making new pseudos.  */
name|reload_in_progress
operator|=
literal|1
expr_stmt|;
comment|/* This loop scans the entire function each go-round      and repeats until one repetition spills no additional hard regs.  */
comment|/* This flag is set when a pseudo reg is spilled,      to require another pass.  Note that getting an additional reload      reg does not necessarily imply any pseudo reg was spilled;      sometimes we find a reload reg that no pseudo reg was allocated in.  */
name|something_changed
operator|=
literal|1
expr_stmt|;
comment|/* This flag is set if there are any insns that require reloading.  */
name|something_needs_reloads
operator|=
literal|0
expr_stmt|;
comment|/* This flag is set if there are any insns that require register      eliminations.  */
name|something_needs_elimination
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|something_changed
condition|)
block|{
name|rtx
name|after_call
init|=
literal|0
decl_stmt|;
comment|/* For each class, number of reload regs needed in that class. 	 This is the maximum over all insns of the needs in that class 	 of the individual insn.  */
name|int
name|max_needs
index|[
name|N_REG_CLASSES
index|]
decl_stmt|;
comment|/* For each class, size of group of consecutive regs 	 that is needed for the reloads of this class.  */
name|int
name|group_size
index|[
name|N_REG_CLASSES
index|]
decl_stmt|;
comment|/* For each class, max number of consecutive groups needed. 	 (Each group contains group_size[CLASS] consecutive registers.)  */
name|int
name|max_groups
index|[
name|N_REG_CLASSES
index|]
decl_stmt|;
comment|/* For each class, max number needed of regs that don't belong 	 to any of the groups.  */
name|int
name|max_nongroups
index|[
name|N_REG_CLASSES
index|]
decl_stmt|;
comment|/* For each class, the machine mode which requires consecutive 	 groups of regs of that class. 	 If two different modes ever require groups of one class, 	 they must be the same size and equally restrictive for that class, 	 otherwise we can't handle the complexity.  */
name|enum
name|machine_mode
name|group_mode
index|[
name|N_REG_CLASSES
index|]
decl_stmt|;
comment|/* Record the insn where each maximum need is first found.  */
name|rtx
name|max_needs_insn
index|[
name|N_REG_CLASSES
index|]
decl_stmt|;
name|rtx
name|max_groups_insn
index|[
name|N_REG_CLASSES
index|]
decl_stmt|;
name|rtx
name|max_nongroups_insn
index|[
name|N_REG_CLASSES
index|]
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|HOST_WIDE_INT
name|starting_frame_size
decl_stmt|;
if|#
directive|if
name|HARD_FRAME_POINTER_REGNUM
operator|!=
name|FRAME_POINTER_REGNUM
name|int
name|previous_frame_pointer_needed
init|=
name|frame_pointer_needed
decl_stmt|;
endif|#
directive|endif
specifier|static
name|char
modifier|*
name|reg_class_names
index|[]
init|=
name|REG_CLASS_NAMES
decl_stmt|;
name|something_changed
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|max_needs
argument_list|,
sizeof|sizeof
name|max_needs
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|max_groups
argument_list|,
sizeof|sizeof
name|max_groups
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|max_nongroups
argument_list|,
sizeof|sizeof
name|max_nongroups
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|max_needs_insn
argument_list|,
sizeof|sizeof
name|max_needs_insn
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|max_groups_insn
argument_list|,
sizeof|sizeof
name|max_groups_insn
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|max_nongroups_insn
argument_list|,
sizeof|sizeof
name|max_nongroups_insn
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|group_size
argument_list|,
sizeof|sizeof
name|group_size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_REG_CLASSES
condition|;
name|i
operator|++
control|)
name|group_mode
index|[
name|i
index|]
operator|=
name|VOIDmode
expr_stmt|;
comment|/* Keep track of which basic blocks are needing the reloads.  */
name|this_block
operator|=
literal|0
expr_stmt|;
comment|/* Remember whether any element of basic_block_needs 	 changes from 0 to 1 in this pass.  */
name|new_basic_block_needs
operator|=
literal|0
expr_stmt|;
comment|/* Round size of stack frame to BIGGEST_ALIGNMENT.  This must be done 	 here because the stack size may be a part of the offset computation 	 for register elimination, and there might have been new stack slots 	 created in the last iteration of this loop.   */
name|assign_stack_local
argument_list|(
name|BLKmode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|starting_frame_size
operator|=
name|get_frame_size
argument_list|()
expr_stmt|;
comment|/* Reset all offsets on eliminable registers to their initial values.  */
ifdef|#
directive|ifdef
name|ELIMINABLE_REGS
for|for
control|(
name|ep
operator|=
name|reg_eliminate
init|;
name|ep
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|ep
operator|++
control|)
block|{
name|INITIAL_ELIMINATION_OFFSET
argument_list|(
name|ep
operator|->
name|from
argument_list|,
name|ep
operator|->
name|to
argument_list|,
name|ep
operator|->
name|initial_offset
argument_list|)
expr_stmt|;
name|ep
operator|->
name|previous_offset
operator|=
name|ep
operator|->
name|offset
operator|=
name|ep
operator|->
name|max_offset
operator|=
name|ep
operator|->
name|initial_offset
expr_stmt|;
block|}
else|#
directive|else
ifdef|#
directive|ifdef
name|INITIAL_FRAME_POINTER_OFFSET
name|INITIAL_FRAME_POINTER_OFFSET
argument_list|(
name|reg_eliminate
index|[
literal|0
index|]
operator|.
name|initial_offset
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|!
name|FRAME_POINTER_REQUIRED
condition|)
name|abort
argument_list|()
expr_stmt|;
name|reg_eliminate
index|[
literal|0
index|]
operator|.
name|initial_offset
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|reg_eliminate
index|[
literal|0
index|]
operator|.
name|previous_offset
operator|=
name|reg_eliminate
index|[
literal|0
index|]
operator|.
name|max_offset
operator|=
name|reg_eliminate
index|[
literal|0
index|]
operator|.
name|offset
operator|=
name|reg_eliminate
index|[
literal|0
index|]
operator|.
name|initial_offset
expr_stmt|;
endif|#
directive|endif
name|num_not_at_initial_offset
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|offsets_known_at
index|[
name|get_first_label_num
argument_list|()
index|]
argument_list|,
name|num_labels
argument_list|)
expr_stmt|;
comment|/* Set a known offset for each forced label to be at the initial offset 	 of each elimination.  We do this because we assume that all 	 computed jumps occur from a location where each elimination is 	 at its initial offset.  */
for|for
control|(
name|x
operator|=
name|forced_labels
init|;
name|x
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|)
name|set_label_offsets
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* For each pseudo register that has an equivalent location defined, 	 try to eliminate any eliminable registers (such as the frame pointer) 	 assuming initial offsets for the replacement register, which 	 is the normal case.  	 If the resulting location is directly addressable, substitute 	 the MEM we just got directly for the old REG.  	 If it is not addressable but is a constant or the sum of a hard reg 	 and constant, it is probably not addressable because the constant is 	 out of range, in that case record the address; we will generate 	 hairy code to compute the address in a register each time it is 	 needed.  Similarly if it is a hard register, but one that is not 	 valid as an address register.  	 If the location is not addressable, but does not have one of the 	 above forms, assign a stack slot.  We have to do this to avoid the 	 potential of producing lots of reloads if, e.g., a location involves 	 a pseudo that didn't get a hard register and has an equivalent memory 	 location that also involves a pseudo that didn't get a hard register.  	 Perhaps at some point we will improve reload_when_needed handling 	 so this problem goes away.  But that's very hairy.  */
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reg_renumber
index|[
name|i
index|]
operator|<
literal|0
operator|&&
name|reg_equiv_memory_loc
index|[
name|i
index|]
condition|)
block|{
name|rtx
name|x
init|=
name|eliminate_regs
argument_list|(
name|reg_equiv_memory_loc
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
if|if
condition|(
name|strict_memory_address_p
argument_list|(
name|GET_MODE
argument_list|(
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|reg_equiv_mem
index|[
name|i
index|]
operator|=
name|x
operator|,
name|reg_equiv_address
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
name|reg_equiv_address
index|[
name|i
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|,
name|reg_equiv_mem
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* Make a new stack slot.  Then indicate that something 		   changed so we go back and recompute offsets for 		   eliminable registers because the allocation of memory 		   below might change some offset.  reg_equiv_{mem,address} 		   will be set up for this pseudo on the next pass around 		   the loop.  */
name|reg_equiv_memory_loc
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|reg_equiv_init
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|alter_reg
argument_list|(
name|i
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|something_changed
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* If we allocated another pseudo to the stack, redo elimination 	 bookkeeping.  */
if|if
condition|(
name|something_changed
condition|)
continue|continue;
comment|/* If caller-saves needs a group, initialize the group to include 	 the size and mode required for caller-saves.  */
if|if
condition|(
name|caller_save_group_size
operator|>
literal|1
condition|)
block|{
name|group_mode
index|[
operator|(
name|int
operator|)
name|caller_save_spill_class
index|]
operator|=
name|Pmode
expr_stmt|;
name|group_size
index|[
operator|(
name|int
operator|)
name|caller_save_spill_class
index|]
operator|=
name|caller_save_group_size
expr_stmt|;
block|}
comment|/* Compute the most additional registers needed by any instruction. 	 Collect information separately for each class of regs.  */
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|global
operator|&&
name|this_block
operator|+
literal|1
operator|<
name|n_basic_blocks
operator|&&
name|insn
operator|==
name|basic_block_head
index|[
name|this_block
operator|+
literal|1
index|]
condition|)
operator|++
name|this_block
expr_stmt|;
comment|/* If this is a label, a JUMP_INSN, or has REG_NOTES (which 	     might include REG_LABEL), we need to see what effects this 	     has on the known offsets at labels.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|||
operator|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|set_label_offsets
argument_list|(
name|insn
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
block|{
comment|/* Nonzero means don't use a reload reg that overlaps 		 the place where a function value can be returned.  */
name|rtx
name|avoid_return_reg
init|=
literal|0
decl_stmt|;
name|rtx
name|old_body
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|old_code
init|=
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|old_notes
init|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|did_elimination
init|=
literal|0
decl_stmt|;
comment|/* To compute the number of reload registers of each class  		 needed for an insn, we must simulate what choose_reload_regs 		 can do.  We do this by splitting an insn into an "input" and 		 an "output" part.  RELOAD_OTHER reloads are used in both.  		 The input part uses those reloads, RELOAD_FOR_INPUT reloads, 		 which must be live over the entire input section of reloads, 		 and the maximum of all the RELOAD_FOR_INPUT_ADDRESS and 		 RELOAD_FOR_OPERAND_ADDRESS reloads, which conflict with the 		 inputs.  		 The registers needed for output are RELOAD_OTHER and 		 RELOAD_FOR_OUTPUT, which are live for the entire output 		 portion, and the maximum of all the RELOAD_FOR_OUTPUT_ADDRESS 		 reloads for each operand.  		 The total number of registers needed is the maximum of the 		 inputs and outputs.  */
struct|struct
name|needs
block|{
comment|/* [0] is normal, [1] is nongroup.  */
name|int
name|regs
index|[
literal|2
index|]
index|[
name|N_REG_CLASSES
index|]
decl_stmt|;
name|int
name|groups
index|[
name|N_REG_CLASSES
index|]
decl_stmt|;
block|}
struct|;
comment|/* Each `struct needs' corresponds to one RELOAD_... type.  */
struct|struct
block|{
name|struct
name|needs
name|other
decl_stmt|;
name|struct
name|needs
name|input
decl_stmt|;
name|struct
name|needs
name|output
decl_stmt|;
name|struct
name|needs
name|insn
decl_stmt|;
name|struct
name|needs
name|other_addr
decl_stmt|;
name|struct
name|needs
name|op_addr
decl_stmt|;
name|struct
name|needs
name|op_addr_reload
decl_stmt|;
name|struct
name|needs
name|in_addr
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|struct
name|needs
name|in_addr_addr
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|struct
name|needs
name|out_addr
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|struct
name|needs
name|out_addr_addr
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
block|}
name|insn_needs
struct|;
comment|/* If needed, eliminate any eliminable registers.  */
if|if
condition|(
name|num_eliminable
condition|)
name|did_elimination
operator|=
name|eliminate_regs_in_insn
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set avoid_return_reg if this is an insn 		 that might use the value of a function call.  */
if|if
condition|(
name|SMALL_REGISTER_CLASSES
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
name|after_call
operator|=
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
name|after_call
operator|=
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|after_call
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SMALL_REGISTER_CLASSES
operator|&&
name|after_call
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|stack_pointer_rtx
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|USE
condition|)
block|{
if|if
condition|(
name|reg_referenced_p
argument_list|(
name|after_call
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
name|avoid_return_reg
operator|=
name|after_call
expr_stmt|;
name|after_call
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Analyze the instruction.  */
name|find_reloads
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|,
name|spill_indirect_levels
argument_list|,
name|global
argument_list|,
name|spill_reg_order
argument_list|)
expr_stmt|;
comment|/* Remember for later shortcuts which insns had any reloads or 		 register eliminations.  		 One might think that it would be worthwhile to mark insns 		 that need register replacements but not reloads, but this is 		 not safe because find_reloads may do some manipulation of 		 the insn (such as swapping commutative operands), which would 		 be lost when we restore the old pattern after register 		 replacement.  So the actions of find_reloads must be redone in 		 subsequent passes or in reload_as_needed.  		 However, it is safe to mark insns that need reloads 		 but not register replacement.  */
name|PUT_MODE
argument_list|(
name|insn
argument_list|,
operator|(
name|did_elimination
condition|?
name|QImode
else|:
name|n_reloads
condition|?
name|HImode
else|:
name|GET_MODE
argument_list|(
name|insn
argument_list|)
operator|==
name|DImode
condition|?
name|DImode
else|:
name|VOIDmode
operator|)
argument_list|)
expr_stmt|;
comment|/* Discard any register replacements done.  */
if|if
condition|(
name|did_elimination
condition|)
block|{
name|obstack_free
argument_list|(
operator|&
name|reload_obstack
argument_list|,
name|reload_firstobj
argument_list|)
expr_stmt|;
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|old_body
expr_stmt|;
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
name|old_code
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|old_notes
expr_stmt|;
name|something_needs_elimination
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If this insn has no reloads, we need not do anything except 		 in the case of a CALL_INSN when we have caller-saves and 		 caller-save needs reloads.  */
if|if
condition|(
name|n_reloads
operator|==
literal|0
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|caller_save_spill_class
operator|!=
name|NO_REGS
operator|)
condition|)
continue|continue;
name|something_needs_reloads
operator|=
literal|1
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|insn_needs
argument_list|,
sizeof|sizeof
name|insn_needs
argument_list|)
expr_stmt|;
comment|/* Count each reload once in every class 		 containing the reload's own class.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_reloads
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|enum
name|reg_class
modifier|*
name|p
decl_stmt|;
name|enum
name|reg_class
name|class
init|=
name|reload_reg_class
index|[
name|i
index|]
decl_stmt|;
name|int
name|size
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|struct
name|needs
modifier|*
name|this_needs
decl_stmt|;
comment|/* Don't count the dummy reloads, for which one of the 		     regs mentioned in the insn can be used for reloading. 		     Don't count optional reloads. 		     Don't count reloads that got combined with others.  */
if|if
condition|(
name|reload_reg_rtx
index|[
name|i
index|]
operator|!=
literal|0
operator|||
name|reload_optional
index|[
name|i
index|]
operator|!=
literal|0
operator|||
operator|(
name|reload_out
index|[
name|i
index|]
operator|==
literal|0
operator|&&
name|reload_in
index|[
name|i
index|]
operator|==
literal|0
operator|&&
operator|!
name|reload_secondary_p
index|[
name|i
index|]
operator|)
condition|)
continue|continue;
comment|/* Show that a reload register of this class is needed 		     in this basic block.  We do not use insn_needs and 		     insn_groups because they are overly conservative for 		     this purpose.  */
if|if
condition|(
name|global
operator|&&
operator|!
name|basic_block_needs
index|[
operator|(
name|int
operator|)
name|class
index|]
index|[
name|this_block
index|]
condition|)
block|{
name|basic_block_needs
index|[
operator|(
name|int
operator|)
name|class
index|]
index|[
name|this_block
index|]
operator|=
literal|1
expr_stmt|;
name|new_basic_block_needs
operator|=
literal|1
expr_stmt|;
block|}
name|mode
operator|=
name|reload_inmode
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|reload_outmode
index|[
name|i
index|]
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
condition|)
name|mode
operator|=
name|reload_outmode
index|[
name|i
index|]
expr_stmt|;
name|size
operator|=
name|CLASS_MAX_NREGS
argument_list|(
name|class
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* Decide which time-of-use to count this reload for.  */
switch|switch
condition|(
name|reload_when_needed
index|[
name|i
index|]
condition|)
block|{
case|case
name|RELOAD_OTHER
case|:
name|this_needs
operator|=
operator|&
name|insn_needs
operator|.
name|other
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_INPUT
case|:
name|this_needs
operator|=
operator|&
name|insn_needs
operator|.
name|input
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OUTPUT
case|:
name|this_needs
operator|=
operator|&
name|insn_needs
operator|.
name|output
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_INSN
case|:
name|this_needs
operator|=
operator|&
name|insn_needs
operator|.
name|insn
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OTHER_ADDRESS
case|:
name|this_needs
operator|=
operator|&
name|insn_needs
operator|.
name|other_addr
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_INPUT_ADDRESS
case|:
name|this_needs
operator|=
operator|&
name|insn_needs
operator|.
name|in_addr
index|[
name|reload_opnum
index|[
name|i
index|]
index|]
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_INPADDR_ADDRESS
case|:
name|this_needs
operator|=
operator|&
name|insn_needs
operator|.
name|in_addr_addr
index|[
name|reload_opnum
index|[
name|i
index|]
index|]
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OUTPUT_ADDRESS
case|:
name|this_needs
operator|=
operator|&
name|insn_needs
operator|.
name|out_addr
index|[
name|reload_opnum
index|[
name|i
index|]
index|]
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OUTADDR_ADDRESS
case|:
name|this_needs
operator|=
operator|&
name|insn_needs
operator|.
name|out_addr_addr
index|[
name|reload_opnum
index|[
name|i
index|]
index|]
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OPERAND_ADDRESS
case|:
name|this_needs
operator|=
operator|&
name|insn_needs
operator|.
name|op_addr
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OPADDR_ADDR
case|:
name|this_needs
operator|=
operator|&
name|insn_needs
operator|.
name|op_addr_reload
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|size
operator|>
literal|1
condition|)
block|{
name|enum
name|machine_mode
name|other_mode
decl_stmt|,
name|allocate_mode
decl_stmt|;
comment|/* Count number of groups needed separately from 			 number of individual regs needed.  */
name|this_needs
operator|->
name|groups
index|[
operator|(
name|int
operator|)
name|class
index|]
operator|++
expr_stmt|;
name|p
operator|=
name|reg_class_superclasses
index|[
operator|(
name|int
operator|)
name|class
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
name|LIM_REG_CLASSES
condition|)
name|this_needs
operator|->
name|groups
index|[
operator|(
name|int
operator|)
operator|*
name|p
operator|++
index|]
operator|++
expr_stmt|;
comment|/* Record size and mode of a group of this class.  */
comment|/* If more than one size group is needed, 			 make all groups the largest needed size.  */
if|if
condition|(
name|group_size
index|[
operator|(
name|int
operator|)
name|class
index|]
operator|<
name|size
condition|)
block|{
name|other_mode
operator|=
name|group_mode
index|[
operator|(
name|int
operator|)
name|class
index|]
expr_stmt|;
name|allocate_mode
operator|=
name|mode
expr_stmt|;
name|group_size
index|[
operator|(
name|int
operator|)
name|class
index|]
operator|=
name|size
expr_stmt|;
name|group_mode
index|[
operator|(
name|int
operator|)
name|class
index|]
operator|=
name|mode
expr_stmt|;
block|}
else|else
block|{
name|other_mode
operator|=
name|mode
expr_stmt|;
name|allocate_mode
operator|=
name|group_mode
index|[
operator|(
name|int
operator|)
name|class
index|]
expr_stmt|;
block|}
comment|/* Crash if two dissimilar machine modes both need 			 groups of consecutive regs of the same class.  */
if|if
condition|(
name|other_mode
operator|!=
name|VOIDmode
operator|&&
name|other_mode
operator|!=
name|allocate_mode
operator|&&
operator|!
name|modes_equiv_for_class_p
argument_list|(
name|allocate_mode
argument_list|,
name|other_mode
argument_list|,
name|class
argument_list|)
condition|)
name|fatal_insn
argument_list|(
literal|"Two dissimilar machine modes both need groups of consecutive regs of the same class"
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|==
literal|1
condition|)
block|{
name|this_needs
operator|->
name|regs
index|[
name|reload_nongroup
index|[
name|i
index|]
index|]
index|[
operator|(
name|int
operator|)
name|class
index|]
operator|+=
literal|1
expr_stmt|;
name|p
operator|=
name|reg_class_superclasses
index|[
operator|(
name|int
operator|)
name|class
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
name|LIM_REG_CLASSES
condition|)
name|this_needs
operator|->
name|regs
index|[
name|reload_nongroup
index|[
name|i
index|]
index|]
index|[
operator|(
name|int
operator|)
operator|*
name|p
operator|++
index|]
operator|+=
literal|1
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* All reloads have been counted for this insn; 		 now merge the various times of use. 		 This sets insn_needs, etc., to the maximum total number 		 of registers needed at any point in this insn.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_REG_CLASSES
condition|;
name|i
operator|++
control|)
block|{
name|int
name|in_max
decl_stmt|,
name|out_max
decl_stmt|;
comment|/* Compute normal and nongroup needs.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
literal|1
condition|;
name|j
operator|++
control|)
block|{
for|for
control|(
name|in_max
operator|=
literal|0
operator|,
name|out_max
operator|=
literal|0
operator|,
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|reload_n_operands
condition|;
name|k
operator|++
control|)
block|{
name|in_max
operator|=
name|MAX
argument_list|(
name|in_max
argument_list|,
operator|(
name|insn_needs
operator|.
name|in_addr
index|[
name|k
index|]
operator|.
name|regs
index|[
name|j
index|]
index|[
name|i
index|]
operator|+
name|insn_needs
operator|.
name|in_addr_addr
index|[
name|k
index|]
operator|.
name|regs
index|[
name|j
index|]
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
name|out_max
operator|=
name|MAX
argument_list|(
name|out_max
argument_list|,
name|insn_needs
operator|.
name|out_addr
index|[
name|k
index|]
operator|.
name|regs
index|[
name|j
index|]
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|out_max
operator|=
name|MAX
argument_list|(
name|out_max
argument_list|,
name|insn_needs
operator|.
name|out_addr_addr
index|[
name|k
index|]
operator|.
name|regs
index|[
name|j
index|]
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* RELOAD_FOR_INSN reloads conflict with inputs, outputs, 			 and operand addresses but not things used to reload 			 them.  Similarly, RELOAD_FOR_OPERAND_ADDRESS reloads 			 don't conflict with things needed to reload inputs or 			 outputs.  */
name|in_max
operator|=
name|MAX
argument_list|(
name|MAX
argument_list|(
name|insn_needs
operator|.
name|op_addr
operator|.
name|regs
index|[
name|j
index|]
index|[
name|i
index|]
argument_list|,
name|insn_needs
operator|.
name|op_addr_reload
operator|.
name|regs
index|[
name|j
index|]
index|[
name|i
index|]
argument_list|)
argument_list|,
name|in_max
argument_list|)
expr_stmt|;
name|out_max
operator|=
name|MAX
argument_list|(
name|out_max
argument_list|,
name|insn_needs
operator|.
name|insn
operator|.
name|regs
index|[
name|j
index|]
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|insn_needs
operator|.
name|input
operator|.
name|regs
index|[
name|j
index|]
index|[
name|i
index|]
operator|=
name|MAX
argument_list|(
name|insn_needs
operator|.
name|input
operator|.
name|regs
index|[
name|j
index|]
index|[
name|i
index|]
operator|+
name|insn_needs
operator|.
name|op_addr
operator|.
name|regs
index|[
name|j
index|]
index|[
name|i
index|]
operator|+
name|insn_needs
operator|.
name|insn
operator|.
name|regs
index|[
name|j
index|]
index|[
name|i
index|]
argument_list|,
name|in_max
operator|+
name|insn_needs
operator|.
name|input
operator|.
name|regs
index|[
name|j
index|]
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|insn_needs
operator|.
name|output
operator|.
name|regs
index|[
name|j
index|]
index|[
name|i
index|]
operator|+=
name|out_max
expr_stmt|;
name|insn_needs
operator|.
name|other
operator|.
name|regs
index|[
name|j
index|]
index|[
name|i
index|]
operator|+=
name|MAX
argument_list|(
name|MAX
argument_list|(
name|insn_needs
operator|.
name|input
operator|.
name|regs
index|[
name|j
index|]
index|[
name|i
index|]
argument_list|,
name|insn_needs
operator|.
name|output
operator|.
name|regs
index|[
name|j
index|]
index|[
name|i
index|]
argument_list|)
argument_list|,
name|insn_needs
operator|.
name|other_addr
operator|.
name|regs
index|[
name|j
index|]
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Now compute group needs.  */
for|for
control|(
name|in_max
operator|=
literal|0
operator|,
name|out_max
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|reload_n_operands
condition|;
name|j
operator|++
control|)
block|{
name|in_max
operator|=
name|MAX
argument_list|(
name|in_max
argument_list|,
name|insn_needs
operator|.
name|in_addr
index|[
name|j
index|]
operator|.
name|groups
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|in_max
operator|=
name|MAX
argument_list|(
name|in_max
argument_list|,
name|insn_needs
operator|.
name|in_addr_addr
index|[
name|j
index|]
operator|.
name|groups
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|out_max
operator|=
name|MAX
argument_list|(
name|out_max
argument_list|,
name|insn_needs
operator|.
name|out_addr
index|[
name|j
index|]
operator|.
name|groups
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|out_max
operator|=
name|MAX
argument_list|(
name|out_max
argument_list|,
name|insn_needs
operator|.
name|out_addr_addr
index|[
name|j
index|]
operator|.
name|groups
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|in_max
operator|=
name|MAX
argument_list|(
name|MAX
argument_list|(
name|insn_needs
operator|.
name|op_addr
operator|.
name|groups
index|[
name|i
index|]
argument_list|,
name|insn_needs
operator|.
name|op_addr_reload
operator|.
name|groups
index|[
name|i
index|]
argument_list|)
argument_list|,
name|in_max
argument_list|)
expr_stmt|;
name|out_max
operator|=
name|MAX
argument_list|(
name|out_max
argument_list|,
name|insn_needs
operator|.
name|insn
operator|.
name|groups
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|insn_needs
operator|.
name|input
operator|.
name|groups
index|[
name|i
index|]
operator|=
name|MAX
argument_list|(
name|insn_needs
operator|.
name|input
operator|.
name|groups
index|[
name|i
index|]
operator|+
name|insn_needs
operator|.
name|op_addr
operator|.
name|groups
index|[
name|i
index|]
operator|+
name|insn_needs
operator|.
name|insn
operator|.
name|groups
index|[
name|i
index|]
argument_list|,
name|in_max
operator|+
name|insn_needs
operator|.
name|input
operator|.
name|groups
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|insn_needs
operator|.
name|output
operator|.
name|groups
index|[
name|i
index|]
operator|+=
name|out_max
expr_stmt|;
name|insn_needs
operator|.
name|other
operator|.
name|groups
index|[
name|i
index|]
operator|+=
name|MAX
argument_list|(
name|MAX
argument_list|(
name|insn_needs
operator|.
name|input
operator|.
name|groups
index|[
name|i
index|]
argument_list|,
name|insn_needs
operator|.
name|output
operator|.
name|groups
index|[
name|i
index|]
argument_list|)
argument_list|,
name|insn_needs
operator|.
name|other_addr
operator|.
name|groups
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* If this is a CALL_INSN and caller-saves will need 		 a spill register, act as if the spill register is 		 needed for this insn.   However, the spill register 		 can be used by any reload of this insn, so we only 		 need do something if no need for that class has 		 been recorded.  		 The assumption that every CALL_INSN will trigger a 		 caller-save is highly conservative, however, the number 		 of cases where caller-saves will need a spill register but 		 a block containing a CALL_INSN won't need a spill register 		 of that class should be quite rare.  		 If a group is needed, the size and mode of the group will 		 have been set up at the beginning of this loop.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|caller_save_spill_class
operator|!=
name|NO_REGS
condition|)
block|{
comment|/* See if this register would conflict with any reload that 		     needs a group or any reload that needs a nongroup.  */
name|int
name|nongroup_need
init|=
literal|0
decl_stmt|;
name|int
modifier|*
name|caller_save_needs
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_reloads
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|reg_classes_intersect_p
argument_list|(
name|caller_save_spill_class
argument_list|,
name|reload_reg_class
index|[
name|j
index|]
argument_list|)
operator|&&
operator|(
operator|(
name|CLASS_MAX_NREGS
argument_list|(
name|reload_reg_class
index|[
name|j
index|]
argument_list|,
operator|(
name|GET_MODE_SIZE
argument_list|(
name|reload_outmode
index|[
name|j
index|]
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|reload_inmode
index|[
name|j
index|]
argument_list|)
operator|)
condition|?
name|reload_outmode
index|[
name|j
index|]
else|:
name|reload_inmode
index|[
name|j
index|]
argument_list|)
operator|>
literal|1
operator|)
operator|||
name|reload_nongroup
index|[
name|j
index|]
operator|)
condition|)
block|{
name|nongroup_need
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|caller_save_needs
operator|=
operator|(
name|caller_save_group_size
operator|>
literal|1
condition|?
name|insn_needs
operator|.
name|other
operator|.
name|groups
else|:
name|insn_needs
operator|.
name|other
operator|.
name|regs
index|[
name|nongroup_need
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|caller_save_needs
index|[
operator|(
name|int
operator|)
name|caller_save_spill_class
index|]
operator|==
literal|0
condition|)
block|{
specifier|register
name|enum
name|reg_class
modifier|*
name|p
init|=
name|reg_class_superclasses
index|[
operator|(
name|int
operator|)
name|caller_save_spill_class
index|]
decl_stmt|;
name|caller_save_needs
index|[
operator|(
name|int
operator|)
name|caller_save_spill_class
index|]
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
name|LIM_REG_CLASSES
condition|)
name|caller_save_needs
index|[
operator|(
name|int
operator|)
operator|*
name|p
operator|++
index|]
operator|+=
literal|1
expr_stmt|;
block|}
comment|/* Show that this basic block will need a register of                    this class.  */
if|if
condition|(
name|global
operator|&&
operator|!
operator|(
name|basic_block_needs
index|[
operator|(
name|int
operator|)
name|caller_save_spill_class
index|]
index|[
name|this_block
index|]
operator|)
condition|)
block|{
name|basic_block_needs
index|[
operator|(
name|int
operator|)
name|caller_save_spill_class
index|]
index|[
name|this_block
index|]
operator|=
literal|1
expr_stmt|;
name|new_basic_block_needs
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* If this insn stores the value of a function call, 		 and that value is in a register that has been spilled, 		 and if the insn needs a reload in a class 		 that might use that register as the reload register, 		 then add an extra need in that class. 		 This makes sure we have a register available that does 		 not overlap the return value.  */
if|if
condition|(
name|SMALL_REGISTER_CLASSES
operator|&&
name|avoid_return_reg
condition|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|avoid_return_reg
argument_list|)
decl_stmt|;
name|int
name|nregs
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|avoid_return_reg
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|r
decl_stmt|;
name|int
name|basic_needs
index|[
name|N_REG_CLASSES
index|]
decl_stmt|,
name|basic_groups
index|[
name|N_REG_CLASSES
index|]
decl_stmt|;
comment|/* First compute the "basic needs", which counts a 		     need only in the smallest class in which it 		     is required.  */
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|insn_needs
operator|.
name|other
operator|.
name|regs
index|[
literal|0
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|basic_needs
argument_list|,
sizeof|sizeof
name|basic_needs
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|insn_needs
operator|.
name|other
operator|.
name|groups
argument_list|,
operator|(
name|char
operator|*
operator|)
name|basic_groups
argument_list|,
sizeof|sizeof
name|basic_groups
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_REG_CLASSES
condition|;
name|i
operator|++
control|)
block|{
name|enum
name|reg_class
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|basic_needs
index|[
name|i
index|]
operator|>=
literal|0
condition|)
for|for
control|(
name|p
operator|=
name|reg_class_superclasses
index|[
name|i
index|]
init|;
operator|*
name|p
operator|!=
name|LIM_REG_CLASSES
condition|;
name|p
operator|++
control|)
name|basic_needs
index|[
operator|(
name|int
operator|)
operator|*
name|p
index|]
operator|-=
name|basic_needs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|basic_groups
index|[
name|i
index|]
operator|>=
literal|0
condition|)
for|for
control|(
name|p
operator|=
name|reg_class_superclasses
index|[
name|i
index|]
init|;
operator|*
name|p
operator|!=
name|LIM_REG_CLASSES
condition|;
name|p
operator|++
control|)
name|basic_groups
index|[
operator|(
name|int
operator|)
operator|*
name|p
index|]
operator|-=
name|basic_groups
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* Now count extra regs if there might be a conflict with 		     the return value register.  */
for|for
control|(
name|r
operator|=
name|regno
init|;
name|r
operator|<
name|regno
operator|+
name|nregs
condition|;
name|r
operator|++
control|)
if|if
condition|(
name|spill_reg_order
index|[
name|r
index|]
operator|>=
literal|0
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_REG_CLASSES
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|i
index|]
argument_list|,
name|r
argument_list|)
condition|)
block|{
if|if
condition|(
name|basic_needs
index|[
name|i
index|]
operator|>
literal|0
condition|)
block|{
name|enum
name|reg_class
modifier|*
name|p
decl_stmt|;
name|insn_needs
operator|.
name|other
operator|.
name|regs
index|[
literal|0
index|]
index|[
name|i
index|]
operator|++
expr_stmt|;
name|p
operator|=
name|reg_class_superclasses
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
name|LIM_REG_CLASSES
condition|)
name|insn_needs
operator|.
name|other
operator|.
name|regs
index|[
literal|0
index|]
index|[
operator|(
name|int
operator|)
operator|*
name|p
operator|++
index|]
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|basic_groups
index|[
name|i
index|]
operator|>
literal|0
condition|)
block|{
name|enum
name|reg_class
modifier|*
name|p
decl_stmt|;
name|insn_needs
operator|.
name|other
operator|.
name|groups
index|[
name|i
index|]
operator|++
expr_stmt|;
name|p
operator|=
name|reg_class_superclasses
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
name|LIM_REG_CLASSES
condition|)
name|insn_needs
operator|.
name|other
operator|.
name|groups
index|[
operator|(
name|int
operator|)
operator|*
name|p
operator|++
index|]
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* For each class, collect maximum need of any insn.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_REG_CLASSES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|max_needs
index|[
name|i
index|]
operator|<
name|insn_needs
operator|.
name|other
operator|.
name|regs
index|[
literal|0
index|]
index|[
name|i
index|]
condition|)
block|{
name|max_needs
index|[
name|i
index|]
operator|=
name|insn_needs
operator|.
name|other
operator|.
name|regs
index|[
literal|0
index|]
index|[
name|i
index|]
expr_stmt|;
name|max_needs_insn
index|[
name|i
index|]
operator|=
name|insn
expr_stmt|;
block|}
if|if
condition|(
name|max_groups
index|[
name|i
index|]
operator|<
name|insn_needs
operator|.
name|other
operator|.
name|groups
index|[
name|i
index|]
condition|)
block|{
name|max_groups
index|[
name|i
index|]
operator|=
name|insn_needs
operator|.
name|other
operator|.
name|groups
index|[
name|i
index|]
expr_stmt|;
name|max_groups_insn
index|[
name|i
index|]
operator|=
name|insn
expr_stmt|;
block|}
if|if
condition|(
name|max_nongroups
index|[
name|i
index|]
operator|<
name|insn_needs
operator|.
name|other
operator|.
name|regs
index|[
literal|1
index|]
index|[
name|i
index|]
condition|)
block|{
name|max_nongroups
index|[
name|i
index|]
operator|=
name|insn_needs
operator|.
name|other
operator|.
name|regs
index|[
literal|1
index|]
index|[
name|i
index|]
expr_stmt|;
name|max_nongroups_insn
index|[
name|i
index|]
operator|=
name|insn
expr_stmt|;
block|}
block|}
block|}
comment|/* Note that there is a continue statement above.  */
block|}
comment|/* If we allocated any new memory locations, make another pass 	 since it might have changed elimination offsets.  */
if|if
condition|(
name|starting_frame_size
operator|!=
name|get_frame_size
argument_list|()
condition|)
name|something_changed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|dumpfile
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_REG_CLASSES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|max_needs
index|[
name|i
index|]
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|dumpfile
argument_list|,
literal|";; Need %d reg%s of class %s (for insn %d).\n"
argument_list|,
name|max_needs
index|[
name|i
index|]
argument_list|,
name|max_needs
index|[
name|i
index|]
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|,
name|reg_class_names
index|[
name|i
index|]
argument_list|,
name|INSN_UID
argument_list|(
name|max_needs_insn
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_nongroups
index|[
name|i
index|]
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|dumpfile
argument_list|,
literal|";; Need %d nongroup reg%s of class %s (for insn %d).\n"
argument_list|,
name|max_nongroups
index|[
name|i
index|]
argument_list|,
name|max_nongroups
index|[
name|i
index|]
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|,
name|reg_class_names
index|[
name|i
index|]
argument_list|,
name|INSN_UID
argument_list|(
name|max_nongroups_insn
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_groups
index|[
name|i
index|]
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|dumpfile
argument_list|,
literal|";; Need %d group%s (%smode) of class %s (for insn %d).\n"
argument_list|,
name|max_groups
index|[
name|i
index|]
argument_list|,
name|max_groups
index|[
name|i
index|]
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|,
name|mode_name
index|[
operator|(
name|int
operator|)
name|group_mode
index|[
name|i
index|]
index|]
argument_list|,
name|reg_class_names
index|[
name|i
index|]
argument_list|,
name|INSN_UID
argument_list|(
name|max_groups_insn
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If we have caller-saves, set up the save areas and see if caller-save 	 will need a spill register.  */
if|if
condition|(
name|caller_save_needed
condition|)
block|{
comment|/* Set the offsets for setup_save_areas.  */
for|for
control|(
name|ep
operator|=
name|reg_eliminate
init|;
name|ep
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|ep
operator|++
control|)
name|ep
operator|->
name|previous_offset
operator|=
name|ep
operator|->
name|max_offset
expr_stmt|;
if|if
condition|(
operator|!
name|setup_save_areas
argument_list|(
operator|&
name|something_changed
argument_list|)
operator|&&
name|caller_save_spill_class
operator|==
name|NO_REGS
condition|)
block|{
comment|/* The class we will need depends on whether the machine 		 supports the sum of two registers for an address; see 	      find_address_reloads for details.  */
name|caller_save_spill_class
operator|=
name|double_reg_address_ok
condition|?
name|INDEX_REG_CLASS
else|:
name|BASE_REG_CLASS
expr_stmt|;
name|caller_save_group_size
operator|=
name|CLASS_MAX_NREGS
argument_list|(
name|caller_save_spill_class
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
name|something_changed
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* See if anything that happened changes which eliminations are valid. 	 For example, on the Sparc, whether or not the frame pointer can 	 be eliminated can depend on what registers have been used.  We need 	 not check some conditions again (such as flag_omit_frame_pointer) 	 since they can't have changed.  */
for|for
control|(
name|ep
operator|=
name|reg_eliminate
init|;
name|ep
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|ep
operator|++
control|)
if|if
condition|(
operator|(
name|ep
operator|->
name|from
operator|==
name|HARD_FRAME_POINTER_REGNUM
operator|&&
name|FRAME_POINTER_REQUIRED
operator|)
ifdef|#
directive|ifdef
name|ELIMINABLE_REGS
operator|||
operator|!
name|CAN_ELIMINATE
argument_list|(
name|ep
operator|->
name|from
argument_list|,
name|ep
operator|->
name|to
argument_list|)
endif|#
directive|endif
condition|)
name|ep
operator|->
name|can_eliminate
operator|=
literal|0
expr_stmt|;
comment|/* Look for the case where we have discovered that we can't replace 	 register A with register B and that means that we will now be 	 trying to replace register A with register C.  This means we can 	 no longer replace register C with register B and we need to disable 	 such an elimination, if it exists.  This occurs often with A == ap, 	 B == sp, and C == fp.  */
for|for
control|(
name|ep
operator|=
name|reg_eliminate
init|;
name|ep
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|ep
operator|++
control|)
block|{
name|struct
name|elim_table
modifier|*
name|op
decl_stmt|;
specifier|register
name|int
name|new_to
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|ep
operator|->
name|can_eliminate
operator|&&
name|ep
operator|->
name|can_eliminate_previous
condition|)
block|{
comment|/* Find the current elimination for ep->from, if there is a 		 new one.  */
for|for
control|(
name|op
operator|=
name|reg_eliminate
init|;
name|op
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|op
operator|++
control|)
if|if
condition|(
name|op
operator|->
name|from
operator|==
name|ep
operator|->
name|from
operator|&&
name|op
operator|->
name|can_eliminate
condition|)
block|{
name|new_to
operator|=
name|op
operator|->
name|to
expr_stmt|;
break|break;
block|}
comment|/* See if there is an elimination of NEW_TO -> EP->TO.  If so, 		 disable it.  */
for|for
control|(
name|op
operator|=
name|reg_eliminate
init|;
name|op
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|op
operator|++
control|)
if|if
condition|(
name|op
operator|->
name|from
operator|==
name|new_to
operator|&&
name|op
operator|->
name|to
operator|==
name|ep
operator|->
name|to
condition|)
name|op
operator|->
name|can_eliminate
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* See if any registers that we thought we could eliminate the previous 	 time are no longer eliminable.  If so, something has changed and we 	 must spill the register.  Also, recompute the number of eliminable 	 registers and see if the frame pointer is needed; it is if there is 	 no elimination of the frame pointer that we can perform.  */
name|frame_pointer_needed
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|ep
operator|=
name|reg_eliminate
init|;
name|ep
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|ep
operator|++
control|)
block|{
if|if
condition|(
name|ep
operator|->
name|can_eliminate
operator|&&
name|ep
operator|->
name|from
operator|==
name|FRAME_POINTER_REGNUM
operator|&&
name|ep
operator|->
name|to
operator|!=
name|HARD_FRAME_POINTER_REGNUM
condition|)
name|frame_pointer_needed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|ep
operator|->
name|can_eliminate
operator|&&
name|ep
operator|->
name|can_eliminate_previous
condition|)
block|{
name|ep
operator|->
name|can_eliminate_previous
operator|=
literal|0
expr_stmt|;
name|spill_hard_reg
argument_list|(
name|ep
operator|->
name|from
argument_list|,
name|global
argument_list|,
name|dumpfile
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|something_changed
operator|=
literal|1
expr_stmt|;
name|num_eliminable
operator|--
expr_stmt|;
block|}
block|}
if|#
directive|if
name|HARD_FRAME_POINTER_REGNUM
operator|!=
name|FRAME_POINTER_REGNUM
comment|/* If we didn't need a frame pointer last time, but we do now, spill 	 the hard frame pointer.  */
if|if
condition|(
name|frame_pointer_needed
operator|&&
operator|!
name|previous_frame_pointer_needed
condition|)
block|{
name|spill_hard_reg
argument_list|(
name|HARD_FRAME_POINTER_REGNUM
argument_list|,
name|global
argument_list|,
name|dumpfile
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|something_changed
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* If all needs are met, we win.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_REG_CLASSES
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|max_needs
index|[
name|i
index|]
operator|>
literal|0
operator|||
name|max_groups
index|[
name|i
index|]
operator|>
literal|0
operator|||
name|max_nongroups
index|[
name|i
index|]
operator|>
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|N_REG_CLASSES
operator|&&
operator|!
name|new_basic_block_needs
operator|&&
operator|!
name|something_changed
condition|)
break|break;
comment|/* Not all needs are met; must spill some hard regs.  */
comment|/* Put all registers spilled so far back in potential_reload_regs, but 	 put them at the front, since we've already spilled most of the 	 pseudos in them (we might have left some pseudos unspilled if they 	 were in a block that didn't need any spill registers of a conflicting 	 class.  We used to try to mark off the need for those registers, 	 but doing so properly is very complex and reallocating them is the 	 simpler approach.  First, "pack" potential_reload_regs by pushing  	 any nonnegative entries towards the end.  That will leave room  	 for the registers we already spilled.  	 Also, undo the marking of the spill registers from the last time 	 around in FORBIDDEN_REGS since we will be probably be allocating 	 them again below.  	 ??? It is theoretically possible that we might end up not using one 	 of our previously-spilled registers in this allocation, even though 	 they are at the head of the list.  It's not clear what to do about 	 this, but it was no better before, when we marked off the needs met 	 by the previously-spilled registers.  With the current code, globals 	 can be allocated into these registers, but locals cannot.  */
if|if
condition|(
name|n_spills
condition|)
block|{
for|for
control|(
name|i
operator|=
name|j
operator|=
name|FIRST_PSEUDO_REGISTER
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|potential_reload_regs
index|[
name|i
index|]
operator|!=
operator|-
literal|1
condition|)
name|potential_reload_regs
index|[
name|j
operator|--
index|]
operator|=
name|potential_reload_regs
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_spills
condition|;
name|i
operator|++
control|)
block|{
name|potential_reload_regs
index|[
name|i
index|]
operator|=
name|spill_regs
index|[
name|i
index|]
expr_stmt|;
name|spill_reg_order
index|[
name|spill_regs
index|[
name|i
index|]
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|CLEAR_HARD_REG_BIT
argument_list|(
name|forbidden_regs
argument_list|,
name|spill_regs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|n_spills
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Now find more reload regs to satisfy the remaining need 	 Do it by ascending class number, since otherwise a reg 	 might be spilled for a big class and might fail to count 	 for a smaller class even though it belongs to that class.  	 Count spilled regs in `spills', and add entries to 	 `spill_regs' and `spill_reg_order'.  	 ??? Note there is a problem here. 	 When there is a need for a group in a high-numbered class, 	 and also need for non-group regs that come from a lower class, 	 the non-group regs are chosen first.  If there aren't many regs, 	 they might leave no room for a group.  	 This was happening on the 386.  To fix it, we added the code 	 that calls possible_group_p, so that the lower class won't 	 break up the last possible group.  	 Really fixing the problem would require changes above 	 in counting the regs already spilled, and in choose_reload_regs. 	 It might be hard to avoid introducing bugs there.  */
name|CLEAR_HARD_REG_SET
argument_list|(
name|counted_for_groups
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|counted_for_nongroups
argument_list|)
expr_stmt|;
for|for
control|(
name|class
operator|=
literal|0
init|;
name|class
operator|<
name|N_REG_CLASSES
condition|;
name|class
operator|++
control|)
block|{
comment|/* First get the groups of registers. 	     If we got single registers first, we might fragment 	     possible groups.  */
while|while
condition|(
name|max_groups
index|[
name|class
index|]
operator|>
literal|0
condition|)
block|{
comment|/* If any single spilled regs happen to form groups, 		 count them now.  Maybe we don't really need 		 to spill another group.  */
name|count_possible_groups
argument_list|(
name|group_size
argument_list|,
name|group_mode
argument_list|,
name|max_groups
argument_list|,
name|class
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_groups
index|[
name|class
index|]
operator|<=
literal|0
condition|)
break|break;
comment|/* Groups of size 2 (the only groups used on most machines) 		 are treated specially.  */
if|if
condition|(
name|group_size
index|[
name|class
index|]
operator|==
literal|2
condition|)
block|{
comment|/* First, look for a register that will complete a group.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
name|int
name|other
decl_stmt|;
name|j
operator|=
name|potential_reload_regs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|j
operator|>=
literal|0
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|bad_spill_regs
argument_list|,
name|j
argument_list|)
operator|&&
operator|(
operator|(
name|j
operator|>
literal|0
operator|&&
operator|(
name|other
operator|=
name|j
operator|-
literal|1
operator|,
name|spill_reg_order
index|[
name|other
index|]
operator|>=
literal|0
operator|)
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|class
index|]
argument_list|,
name|j
argument_list|)
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|class
index|]
argument_list|,
name|other
argument_list|)
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|other
argument_list|,
name|group_mode
index|[
name|class
index|]
argument_list|)
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|counted_for_nongroups
argument_list|,
name|other
argument_list|)
comment|/* We don't want one part of another group. 			       We could get "two groups" that overlap!  */
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|counted_for_groups
argument_list|,
name|other
argument_list|)
operator|)
operator|||
operator|(
name|j
operator|<
name|FIRST_PSEUDO_REGISTER
operator|-
literal|1
operator|&&
operator|(
name|other
operator|=
name|j
operator|+
literal|1
operator|,
name|spill_reg_order
index|[
name|other
index|]
operator|>=
literal|0
operator|)
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|class
index|]
argument_list|,
name|j
argument_list|)
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|class
index|]
argument_list|,
name|other
argument_list|)
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|j
argument_list|,
name|group_mode
index|[
name|class
index|]
argument_list|)
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|counted_for_nongroups
argument_list|,
name|other
argument_list|)
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|counted_for_groups
argument_list|,
name|other
argument_list|)
operator|)
operator|)
condition|)
block|{
specifier|register
name|enum
name|reg_class
modifier|*
name|p
decl_stmt|;
comment|/* We have found one that will complete a group, 			     so count off one group as provided.  */
name|max_groups
index|[
name|class
index|]
operator|--
expr_stmt|;
name|p
operator|=
name|reg_class_superclasses
index|[
name|class
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
name|LIM_REG_CLASSES
condition|)
block|{
if|if
condition|(
name|group_size
index|[
operator|(
name|int
operator|)
operator|*
name|p
index|]
operator|<=
name|group_size
index|[
name|class
index|]
condition|)
name|max_groups
index|[
operator|(
name|int
operator|)
operator|*
name|p
index|]
operator|--
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
comment|/* Indicate both these regs are part of a group.  */
name|SET_HARD_REG_BIT
argument_list|(
name|counted_for_groups
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|counted_for_groups
argument_list|,
name|other
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* We can't complete a group, so start one.  */
comment|/* Look for a pair neither of which is explicitly used.  */
if|if
condition|(
name|SMALL_REGISTER_CLASSES
operator|&&
name|i
operator|==
name|FIRST_PSEUDO_REGISTER
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
name|int
name|k
decl_stmt|;
name|j
operator|=
name|potential_reload_regs
index|[
name|i
index|]
expr_stmt|;
comment|/* Verify that J+1 is a potential reload reg.  */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|potential_reload_regs
index|[
name|k
index|]
operator|==
name|j
operator|+
literal|1
condition|)
break|break;
if|if
condition|(
name|j
operator|>=
literal|0
operator|&&
name|j
operator|+
literal|1
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|k
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|spill_reg_order
index|[
name|j
index|]
operator|<
literal|0
operator|&&
name|spill_reg_order
index|[
name|j
operator|+
literal|1
index|]
operator|<
literal|0
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|class
index|]
argument_list|,
name|j
argument_list|)
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|class
index|]
argument_list|,
name|j
operator|+
literal|1
argument_list|)
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|j
argument_list|,
name|group_mode
index|[
name|class
index|]
argument_list|)
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|counted_for_nongroups
argument_list|,
name|j
operator|+
literal|1
argument_list|)
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|bad_spill_regs
argument_list|,
name|j
operator|+
literal|1
argument_list|)
comment|/* Reject J at this stage 			       if J+1 was explicitly used.  */
operator|&&
operator|!
name|regs_explicitly_used
index|[
name|j
operator|+
literal|1
index|]
condition|)
break|break;
block|}
comment|/* Now try any group at all 		     whose registers are not in bad_spill_regs.  */
if|if
condition|(
name|i
operator|==
name|FIRST_PSEUDO_REGISTER
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
name|int
name|k
decl_stmt|;
name|j
operator|=
name|potential_reload_regs
index|[
name|i
index|]
expr_stmt|;
comment|/* Verify that J+1 is a potential reload reg.  */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|potential_reload_regs
index|[
name|k
index|]
operator|==
name|j
operator|+
literal|1
condition|)
break|break;
if|if
condition|(
name|j
operator|>=
literal|0
operator|&&
name|j
operator|+
literal|1
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|k
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|spill_reg_order
index|[
name|j
index|]
operator|<
literal|0
operator|&&
name|spill_reg_order
index|[
name|j
operator|+
literal|1
index|]
operator|<
literal|0
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|class
index|]
argument_list|,
name|j
argument_list|)
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|class
index|]
argument_list|,
name|j
operator|+
literal|1
argument_list|)
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|j
argument_list|,
name|group_mode
index|[
name|class
index|]
argument_list|)
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|counted_for_nongroups
argument_list|,
name|j
operator|+
literal|1
argument_list|)
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|bad_spill_regs
argument_list|,
name|j
operator|+
literal|1
argument_list|)
condition|)
break|break;
block|}
comment|/* I should be the index in potential_reload_regs 		     of the new reload reg we have found.  */
if|if
condition|(
name|i
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
comment|/* There are no groups left to spill.  */
name|spill_failure
argument_list|(
name|max_groups_insn
index|[
name|class
index|]
argument_list|)
expr_stmt|;
name|failure
operator|=
literal|1
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
else|else
name|something_changed
operator||=
name|new_spill_reg
argument_list|(
name|i
argument_list|,
name|class
argument_list|,
name|max_needs
argument_list|,
name|NULL_PTR
argument_list|,
name|global
argument_list|,
name|dumpfile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* For groups of more than 2 registers, 		     look for a sufficient sequence of unspilled registers, 		     and spill them all at once.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
name|int
name|k
decl_stmt|;
name|j
operator|=
name|potential_reload_regs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|j
operator|>=
literal|0
operator|&&
name|j
operator|+
name|group_size
index|[
name|class
index|]
operator|<=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|j
argument_list|,
name|group_mode
index|[
name|class
index|]
argument_list|)
condition|)
block|{
comment|/* Check each reg in the sequence.  */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|group_size
index|[
name|class
index|]
condition|;
name|k
operator|++
control|)
if|if
condition|(
operator|!
operator|(
name|spill_reg_order
index|[
name|j
operator|+
name|k
index|]
operator|<
literal|0
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|bad_spill_regs
argument_list|,
name|j
operator|+
name|k
argument_list|)
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|class
index|]
argument_list|,
name|j
operator|+
name|k
argument_list|)
operator|)
condition|)
break|break;
comment|/* We got a full sequence, so spill them all.  */
if|if
condition|(
name|k
operator|==
name|group_size
index|[
name|class
index|]
condition|)
block|{
specifier|register
name|enum
name|reg_class
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|group_size
index|[
name|class
index|]
condition|;
name|k
operator|++
control|)
block|{
name|int
name|idx
decl_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|counted_for_groups
argument_list|,
name|j
operator|+
name|k
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|idx
operator|++
control|)
if|if
condition|(
name|potential_reload_regs
index|[
name|idx
index|]
operator|==
name|j
operator|+
name|k
condition|)
break|break;
name|something_changed
operator||=
name|new_spill_reg
argument_list|(
name|idx
argument_list|,
name|class
argument_list|,
name|max_needs
argument_list|,
name|NULL_PTR
argument_list|,
name|global
argument_list|,
name|dumpfile
argument_list|)
expr_stmt|;
block|}
comment|/* We have found one that will complete a group, 				 so count off one group as provided.  */
name|max_groups
index|[
name|class
index|]
operator|--
expr_stmt|;
name|p
operator|=
name|reg_class_superclasses
index|[
name|class
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
name|LIM_REG_CLASSES
condition|)
block|{
if|if
condition|(
name|group_size
index|[
operator|(
name|int
operator|)
operator|*
name|p
index|]
operator|<=
name|group_size
index|[
name|class
index|]
condition|)
name|max_groups
index|[
operator|(
name|int
operator|)
operator|*
name|p
index|]
operator|--
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
comment|/* We couldn't find any registers for this reload. 		     Avoid going into an infinite loop.  */
if|if
condition|(
name|i
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
comment|/* There are no groups left.  */
name|spill_failure
argument_list|(
name|max_groups_insn
index|[
name|class
index|]
argument_list|)
expr_stmt|;
name|failure
operator|=
literal|1
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
block|}
block|}
comment|/* Now similarly satisfy all need for single registers.  */
while|while
condition|(
name|max_needs
index|[
name|class
index|]
operator|>
literal|0
operator|||
name|max_nongroups
index|[
name|class
index|]
operator|>
literal|0
condition|)
block|{
comment|/* If we spilled enough regs, but they weren't counted 		 against the non-group need, see if we can count them now. 		 If so, we can avoid some actual spilling.  */
if|if
condition|(
name|max_needs
index|[
name|class
index|]
operator|<=
literal|0
operator|&&
name|max_nongroups
index|[
name|class
index|]
operator|>
literal|0
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_spills
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|class
index|]
argument_list|,
name|spill_regs
index|[
name|i
index|]
argument_list|)
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|counted_for_groups
argument_list|,
name|spill_regs
index|[
name|i
index|]
argument_list|)
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|counted_for_nongroups
argument_list|,
name|spill_regs
index|[
name|i
index|]
argument_list|)
operator|&&
name|max_nongroups
index|[
name|class
index|]
operator|>
literal|0
condition|)
block|{
specifier|register
name|enum
name|reg_class
modifier|*
name|p
decl_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|counted_for_nongroups
argument_list|,
name|spill_regs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|max_nongroups
index|[
name|class
index|]
operator|--
expr_stmt|;
name|p
operator|=
name|reg_class_superclasses
index|[
name|class
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
name|LIM_REG_CLASSES
condition|)
name|max_nongroups
index|[
operator|(
name|int
operator|)
operator|*
name|p
operator|++
index|]
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|max_needs
index|[
name|class
index|]
operator|<=
literal|0
operator|&&
name|max_nongroups
index|[
name|class
index|]
operator|<=
literal|0
condition|)
break|break;
comment|/* Consider the potential reload regs that aren't 		 yet in use as reload regs, in order of preference. 		 Find the most preferred one that's in this class.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|potential_reload_regs
index|[
name|i
index|]
operator|>=
literal|0
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|class
index|]
argument_list|,
name|potential_reload_regs
index|[
name|i
index|]
argument_list|)
comment|/* If this reg will not be available for groups, 		       pick one that does not foreclose possible groups. 		       This is a kludge, and not very general, 		       but it should be sufficient to make the 386 work, 		       and the problem should not occur on machines with 		       more registers.  */
operator|&&
operator|(
name|max_nongroups
index|[
name|class
index|]
operator|==
literal|0
operator|||
name|possible_group_p
argument_list|(
name|potential_reload_regs
index|[
name|i
index|]
argument_list|,
name|max_groups
argument_list|)
operator|)
condition|)
break|break;
comment|/* If we couldn't get a register, try to get one even if we 		 might foreclose possible groups.  This may cause problems 		 later, but that's better than aborting now, since it is 		 possible that we will, in fact, be able to form the needed 		 group even with this allocation.  */
if|if
condition|(
name|i
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|(
name|asm_noperands
argument_list|(
name|max_needs
index|[
name|class
index|]
operator|>
literal|0
condition|?
name|max_needs_insn
index|[
name|class
index|]
else|:
name|max_nongroups_insn
index|[
name|class
index|]
argument_list|)
operator|<
literal|0
operator|)
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|potential_reload_regs
index|[
name|i
index|]
operator|>=
literal|0
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|class
index|]
argument_list|,
name|potential_reload_regs
index|[
name|i
index|]
argument_list|)
condition|)
break|break;
comment|/* I should be the index in potential_reload_regs 		 of the new reload reg we have found.  */
if|if
condition|(
name|i
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
comment|/* There are no possible registers left to spill.  */
name|spill_failure
argument_list|(
name|max_needs
index|[
name|class
index|]
operator|>
literal|0
condition|?
name|max_needs_insn
index|[
name|class
index|]
else|:
name|max_nongroups_insn
index|[
name|class
index|]
argument_list|)
expr_stmt|;
name|failure
operator|=
literal|1
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
else|else
name|something_changed
operator||=
name|new_spill_reg
argument_list|(
name|i
argument_list|,
name|class
argument_list|,
name|max_needs
argument_list|,
name|max_nongroups
argument_list|,
name|global
argument_list|,
name|dumpfile
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* If global-alloc was run, notify it of any register eliminations we have      done.  */
if|if
condition|(
name|global
condition|)
for|for
control|(
name|ep
operator|=
name|reg_eliminate
init|;
name|ep
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|ep
operator|++
control|)
if|if
condition|(
name|ep
operator|->
name|can_eliminate
condition|)
name|mark_elimination
argument_list|(
name|ep
operator|->
name|from
argument_list|,
name|ep
operator|->
name|to
argument_list|)
expr_stmt|;
comment|/* Insert code to save and restore call-clobbered hard regs      around calls.  Tell if what mode to use so that we will process      those insns in reload_as_needed if we have to.  */
if|if
condition|(
name|caller_save_needed
condition|)
name|save_call_clobbered_regs
argument_list|(
name|num_eliminable
condition|?
name|QImode
else|:
name|caller_save_spill_class
operator|!=
name|NO_REGS
condition|?
name|HImode
else|:
name|VOIDmode
argument_list|)
expr_stmt|;
comment|/* If a pseudo has no hard reg, delete the insns that made the equivalence.      If that insn didn't set the register (i.e., it copied the register to      memory), just delete that insn instead of the equivalencing insn plus      anything now dead.  If we call delete_dead_insn on that insn, we may      delete the insn that actually sets the register if the register die      there and that is incorrect.  */
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reg_renumber
index|[
name|i
index|]
operator|<
literal|0
operator|&&
name|reg_equiv_init
index|[
name|i
index|]
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|reg_equiv_init
index|[
name|i
index|]
argument_list|)
operator|!=
name|NOTE
condition|)
block|{
if|if
condition|(
name|reg_set_p
argument_list|(
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|,
name|PATTERN
argument_list|(
name|reg_equiv_init
index|[
name|i
index|]
argument_list|)
argument_list|)
condition|)
name|delete_dead_insn
argument_list|(
name|reg_equiv_init
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|PUT_CODE
argument_list|(
name|reg_equiv_init
index|[
name|i
index|]
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|reg_equiv_init
index|[
name|i
index|]
argument_list|)
operator|=
literal|0
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|reg_equiv_init
index|[
name|i
index|]
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
block|}
block|}
comment|/* Use the reload registers where necessary      by generating move instructions to move the must-be-register      values into or out of the reload registers.  */
if|if
condition|(
name|something_needs_reloads
operator|||
name|something_needs_elimination
operator|||
operator|(
name|caller_save_needed
operator|&&
name|num_eliminable
operator|)
operator|||
name|caller_save_spill_class
operator|!=
name|NO_REGS
condition|)
name|reload_as_needed
argument_list|(
name|first
argument_list|,
name|global
argument_list|)
expr_stmt|;
comment|/* If we were able to eliminate the frame pointer, show that it is no      longer live at the start of any basic block.  If it ls live by      virtue of being in a pseudo, that pseudo will be marked live      and hence the frame pointer will be known to be live via that      pseudo.  */
if|if
condition|(
operator|!
name|frame_pointer_needed
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
name|CLEAR_REGNO_REG_SET
argument_list|(
name|basic_block_live_at_start
index|[
name|i
index|]
argument_list|,
name|HARD_FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
comment|/* Come here (with failure set nonzero) if we can't get enough spill regs      and we decide not to abort about it.  */
name|failed
label|:
name|reload_in_progress
operator|=
literal|0
expr_stmt|;
comment|/* Now eliminate all pseudo regs by modifying them into      their equivalent memory references.      The REG-rtx's for the pseudos are modified in place,      so all insns that used to refer to them now refer to memory.       For a reg that has a reg_equiv_address, all those insns      were changed by reloading so that no insns refer to it any longer;      but the DECL_RTL of a variable decl may refer to it,      and if so this causes the debugging info to mention the variable.  */
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|addr
init|=
literal|0
decl_stmt|;
name|int
name|in_struct
init|=
literal|0
decl_stmt|;
name|int
name|is_readonly
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|reg_equiv_memory_loc
index|[
name|i
index|]
condition|)
block|{
name|in_struct
operator|=
name|MEM_IN_STRUCT_P
argument_list|(
name|reg_equiv_memory_loc
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|is_readonly
operator|=
name|RTX_UNCHANGING_P
argument_list|(
name|reg_equiv_memory_loc
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reg_equiv_mem
index|[
name|i
index|]
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|reg_equiv_mem
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_equiv_address
index|[
name|i
index|]
condition|)
name|addr
operator|=
name|reg_equiv_address
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|addr
condition|)
block|{
if|if
condition|(
name|reg_renumber
index|[
name|i
index|]
operator|<
literal|0
condition|)
block|{
name|rtx
name|reg
init|=
name|regno_reg_rtx
index|[
name|i
index|]
decl_stmt|;
name|XEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
operator|=
name|addr
expr_stmt|;
name|REG_USERVAR_P
argument_list|(
name|reg
argument_list|)
operator|=
literal|0
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|reg
argument_list|)
operator|=
name|is_readonly
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|reg
argument_list|)
operator|=
name|in_struct
expr_stmt|;
comment|/* We have no alias information about this newly created 		 MEM.  */
name|MEM_ALIAS_SET
argument_list|(
name|reg
argument_list|)
operator|=
literal|0
expr_stmt|;
name|PUT_CODE
argument_list|(
name|reg
argument_list|,
name|MEM
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reg_equiv_mem
index|[
name|i
index|]
condition|)
name|XEXP
argument_list|(
name|reg_equiv_mem
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
operator|=
name|addr
expr_stmt|;
block|}
block|}
comment|/* Make a pass over all the insns and delete all USEs which we inserted      only to tag a REG_EQUAL note on them; if PRESERVE_DEATH_INFO_REGNO_P      is defined, also remove death notes for things that are no longer      registers or no longer die in the insn (e.g., an input and output      pseudo being tied).  */
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
block|{
ifdef|#
directive|ifdef
name|PRESERVE_DEATH_INFO_REGNO_P
name|rtx
name|note
decl_stmt|,
name|next
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|USE
operator|&&
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
block|{
name|PUT_CODE
argument_list|(
name|insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
continue|continue;
block|}
ifdef|#
directive|ifdef
name|PRESERVE_DEATH_INFO_REGNO_P
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|next
control|)
block|{
name|next
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_DEAD
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|reg_set_p
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|)
condition|)
name|remove_note
argument_list|(
name|insn
argument_list|,
name|note
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
comment|/* If we are doing stack checking, give a warning if this function's      frame size is larger than we expect.  */
if|if
condition|(
name|flag_stack_check
operator|&&
operator|!
name|STACK_CHECK_BUILTIN
condition|)
block|{
name|HOST_WIDE_INT
name|size
init|=
name|get_frame_size
argument_list|()
operator|+
name|STACK_CHECK_FIXED_FRAME_SIZE
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
operator|&&
operator|!
name|fixed_regs
index|[
name|i
index|]
operator|&&
name|call_used_regs
index|[
name|i
index|]
condition|)
name|size
operator|+=
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|STACK_CHECK_MAX_FRAME_SIZE
condition|)
name|warning
argument_list|(
literal|"frame size too large for reliable stack checking"
argument_list|)
expr_stmt|;
block|}
comment|/* Indicate that we no longer have known memory locations or constants.  */
name|reg_equiv_constant
operator|=
literal|0
expr_stmt|;
name|reg_equiv_memory_loc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|real_known_ptr
condition|)
name|free
argument_list|(
name|real_known_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|real_at_ptr
condition|)
name|free
argument_list|(
name|real_at_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|scratch_list
condition|)
name|free
argument_list|(
name|scratch_list
argument_list|)
expr_stmt|;
name|scratch_list
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|scratch_block
condition|)
name|free
argument_list|(
name|scratch_block
argument_list|)
expr_stmt|;
name|scratch_block
operator|=
literal|0
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|used_spill_regs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_spills
condition|;
name|i
operator|++
control|)
name|SET_HARD_REG_BIT
argument_list|(
name|used_spill_regs
argument_list|,
name|spill_regs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
name|failure
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Nonzero if, after spilling reg REGNO for non-groups,    it will still be possible to find a group if we still need one.  */
end_comment

begin_function
specifier|static
name|int
name|possible_group_p
parameter_list|(
name|regno
parameter_list|,
name|max_groups
parameter_list|)
name|int
name|regno
decl_stmt|;
name|int
modifier|*
name|max_groups
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|class
init|=
operator|(
name|int
operator|)
name|NO_REGS
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|N_REG_CLASSES
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|max_groups
index|[
name|i
index|]
operator|>
literal|0
condition|)
block|{
name|class
operator|=
name|i
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|class
operator|==
operator|(
name|int
operator|)
name|NO_REGS
condition|)
return|return
literal|1
return|;
comment|/* Consider each pair of consecutive registers.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
comment|/* Ignore pairs that include reg REGNO.  */
if|if
condition|(
name|i
operator|==
name|regno
operator|||
name|i
operator|+
literal|1
operator|==
name|regno
condition|)
continue|continue;
comment|/* Ignore pairs that are outside the class that needs the group. 	 ??? Here we fail to handle the case where two different classes 	 independently need groups.  But this never happens with our 	 current machine descriptions.  */
if|if
condition|(
operator|!
operator|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|class
index|]
argument_list|,
name|i
argument_list|)
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|class
index|]
argument_list|,
name|i
operator|+
literal|1
argument_list|)
operator|)
condition|)
continue|continue;
comment|/* A pair of consecutive regs we can still spill does the trick.  */
if|if
condition|(
name|spill_reg_order
index|[
name|i
index|]
operator|<
literal|0
operator|&&
name|spill_reg_order
index|[
name|i
operator|+
literal|1
index|]
operator|<
literal|0
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|bad_spill_regs
argument_list|,
name|i
argument_list|)
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|bad_spill_regs
argument_list|,
name|i
operator|+
literal|1
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* A pair of one already spilled and one we can spill does it 	 provided the one already spilled is not otherwise reserved.  */
if|if
condition|(
name|spill_reg_order
index|[
name|i
index|]
operator|<
literal|0
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|bad_spill_regs
argument_list|,
name|i
argument_list|)
operator|&&
name|spill_reg_order
index|[
name|i
operator|+
literal|1
index|]
operator|>=
literal|0
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|counted_for_groups
argument_list|,
name|i
operator|+
literal|1
argument_list|)
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|counted_for_nongroups
argument_list|,
name|i
operator|+
literal|1
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|spill_reg_order
index|[
name|i
operator|+
literal|1
index|]
operator|<
literal|0
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|bad_spill_regs
argument_list|,
name|i
operator|+
literal|1
argument_list|)
operator|&&
name|spill_reg_order
index|[
name|i
index|]
operator|>=
literal|0
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|counted_for_groups
argument_list|,
name|i
argument_list|)
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|counted_for_nongroups
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Count any groups of CLASS that can be formed from the registers recently    spilled.  */
end_comment

begin_function
specifier|static
name|void
name|count_possible_groups
parameter_list|(
name|group_size
parameter_list|,
name|group_mode
parameter_list|,
name|max_groups
parameter_list|,
name|class
parameter_list|)
name|int
modifier|*
name|group_size
decl_stmt|;
name|enum
name|machine_mode
modifier|*
name|group_mode
decl_stmt|;
name|int
modifier|*
name|max_groups
decl_stmt|;
name|int
name|class
decl_stmt|;
block|{
name|HARD_REG_SET
name|new
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* Now find all consecutive groups of spilled registers      and mark each group off against the need for such groups.      But don't count them against ordinary need, yet.  */
if|if
condition|(
name|group_size
index|[
name|class
index|]
operator|==
literal|0
condition|)
return|return;
name|CLEAR_HARD_REG_SET
argument_list|(
name|new
argument_list|)
expr_stmt|;
comment|/* Make a mask of all the regs that are spill regs in class I.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_spills
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|class
index|]
argument_list|,
name|spill_regs
index|[
name|i
index|]
argument_list|)
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|counted_for_groups
argument_list|,
name|spill_regs
index|[
name|i
index|]
argument_list|)
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|counted_for_nongroups
argument_list|,
name|spill_regs
index|[
name|i
index|]
argument_list|)
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|new
argument_list|,
name|spill_regs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Find each consecutive group of them.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|max_groups
index|[
name|class
index|]
operator|>
literal|0
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|new
argument_list|,
name|i
argument_list|)
operator|&&
name|i
operator|+
name|group_size
index|[
name|class
index|]
operator|<=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|i
argument_list|,
name|group_mode
index|[
name|class
index|]
argument_list|)
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|group_size
index|[
name|class
index|]
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|new
argument_list|,
name|i
operator|+
name|j
argument_list|)
condition|)
break|break;
if|if
condition|(
name|j
operator|==
name|group_size
index|[
name|class
index|]
condition|)
block|{
comment|/* We found a group.  Mark it off against this class's need for 	       groups, and against each superclass too.  */
specifier|register
name|enum
name|reg_class
modifier|*
name|p
decl_stmt|;
name|max_groups
index|[
name|class
index|]
operator|--
expr_stmt|;
name|p
operator|=
name|reg_class_superclasses
index|[
name|class
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
name|LIM_REG_CLASSES
condition|)
block|{
if|if
condition|(
name|group_size
index|[
operator|(
name|int
operator|)
operator|*
name|p
index|]
operator|<=
name|group_size
index|[
name|class
index|]
condition|)
name|max_groups
index|[
operator|(
name|int
operator|)
operator|*
name|p
index|]
operator|--
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
comment|/* Don't count these registers again.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|group_size
index|[
name|class
index|]
condition|;
name|j
operator|++
control|)
name|SET_HARD_REG_BIT
argument_list|(
name|counted_for_groups
argument_list|,
name|i
operator|+
name|j
argument_list|)
expr_stmt|;
block|}
comment|/* Skip to the last reg in this group.  When i is incremented above, 	   it will then point to the first reg of the next possible group.  */
name|i
operator|+=
name|j
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ALLOCATE_MODE is a register mode that needs to be reloaded.  OTHER_MODE is    another mode that needs to be reloaded for the same register class CLASS.    If any reg in CLASS allows ALLOCATE_MODE but not OTHER_MODE, fail.    ALLOCATE_MODE will never be smaller than OTHER_MODE.     This code used to also fail if any reg in CLASS allows OTHER_MODE but not    ALLOCATE_MODE.  This test is unnecessary, because we will never try to put    something of mode ALLOCATE_MODE into an OTHER_MODE register.  Testing this    causes unnecessary failures on machines requiring alignment of register    groups when the two modes are different sizes, because the larger mode has    more strict alignment rules than the smaller mode.  */
end_comment

begin_function
specifier|static
name|int
name|modes_equiv_for_class_p
parameter_list|(
name|allocate_mode
parameter_list|,
name|other_mode
parameter_list|,
name|class
parameter_list|)
name|enum
name|machine_mode
name|allocate_mode
decl_stmt|,
name|other_mode
decl_stmt|;
name|enum
name|reg_class
name|class
decl_stmt|;
block|{
specifier|register
name|int
name|regno
decl_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
block|{
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|class
index|]
argument_list|,
name|regno
argument_list|)
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|allocate_mode
argument_list|)
operator|&&
operator|!
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|other_mode
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Handle the failure to find a register to spill.    INSN should be one of the insns which needed this particular spill reg.  */
end_comment

begin_function
specifier|static
name|void
name|spill_failure
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
if|if
condition|(
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
name|error_for_asm
argument_list|(
name|insn
argument_list|,
literal|"`asm' needs too many reloads"
argument_list|)
expr_stmt|;
else|else
name|fatal_insn
argument_list|(
literal|"Unable to find a register to spill."
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a new register to the tables of available spill-registers     (as well as spilling all pseudos allocated to the register).    I is the index of this register in potential_reload_regs.    CLASS is the regclass whose need is being satisfied.    MAX_NEEDS and MAX_NONGROUPS are the vectors of needs,     so that this register can count off against them.     MAX_NONGROUPS is 0 if this register is part of a group.    GLOBAL and DUMPFILE are the same as the args that `reload' got.  */
end_comment

begin_function
specifier|static
name|int
name|new_spill_reg
parameter_list|(
name|i
parameter_list|,
name|class
parameter_list|,
name|max_needs
parameter_list|,
name|max_nongroups
parameter_list|,
name|global
parameter_list|,
name|dumpfile
parameter_list|)
name|int
name|i
decl_stmt|;
name|int
name|class
decl_stmt|;
name|int
modifier|*
name|max_needs
decl_stmt|;
name|int
modifier|*
name|max_nongroups
decl_stmt|;
name|int
name|global
decl_stmt|;
name|FILE
modifier|*
name|dumpfile
decl_stmt|;
block|{
specifier|register
name|enum
name|reg_class
modifier|*
name|p
decl_stmt|;
name|int
name|val
decl_stmt|;
name|int
name|regno
init|=
name|potential_reload_regs
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|i
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Caller failed to find any register.  */
if|if
condition|(
name|fixed_regs
index|[
name|regno
index|]
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|forbidden_regs
argument_list|,
name|regno
argument_list|)
condition|)
block|{
specifier|static
name|char
modifier|*
name|reg_class_names
index|[]
init|=
name|REG_CLASS_NAMES
decl_stmt|;
name|fatal
argument_list|(
literal|"fixed or forbidden register %d (%s) was spilled for class %s.\n\ This may be due to a compiler bug or to impossible asm\n\ statements or clauses."
argument_list|,
name|regno
argument_list|,
name|reg_names
index|[
name|regno
index|]
argument_list|,
name|reg_class_names
index|[
name|class
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Make reg REGNO an additional reload reg.  */
name|potential_reload_regs
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|spill_regs
index|[
name|n_spills
index|]
operator|=
name|regno
expr_stmt|;
name|spill_reg_order
index|[
name|regno
index|]
operator|=
name|n_spills
expr_stmt|;
if|if
condition|(
name|dumpfile
condition|)
name|fprintf
argument_list|(
name|dumpfile
argument_list|,
literal|"Spilling reg %d.\n"
argument_list|,
name|spill_regs
index|[
name|n_spills
index|]
argument_list|)
expr_stmt|;
comment|/* Clear off the needs we just satisfied.  */
name|max_needs
index|[
name|class
index|]
operator|--
expr_stmt|;
name|p
operator|=
name|reg_class_superclasses
index|[
name|class
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
name|LIM_REG_CLASSES
condition|)
name|max_needs
index|[
operator|(
name|int
operator|)
operator|*
name|p
operator|++
index|]
operator|--
expr_stmt|;
if|if
condition|(
name|max_nongroups
operator|&&
name|max_nongroups
index|[
name|class
index|]
operator|>
literal|0
condition|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|counted_for_nongroups
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|max_nongroups
index|[
name|class
index|]
operator|--
expr_stmt|;
name|p
operator|=
name|reg_class_superclasses
index|[
name|class
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
name|LIM_REG_CLASSES
condition|)
name|max_nongroups
index|[
operator|(
name|int
operator|)
operator|*
name|p
operator|++
index|]
operator|--
expr_stmt|;
block|}
comment|/* Spill every pseudo reg that was allocated to this reg      or to something that overlaps this reg.  */
name|val
operator|=
name|spill_hard_reg
argument_list|(
name|spill_regs
index|[
name|n_spills
index|]
argument_list|,
name|global
argument_list|,
name|dumpfile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If there are some registers still to eliminate and this register      wasn't ever used before, additional stack space may have to be      allocated to store this register.  Thus, we may have changed the offset      between the stack and frame pointers, so mark that something has changed.      (If new pseudos were spilled, thus requiring more space, VAL would have      been set non-zero by the call to spill_hard_reg above since additional      reloads may be needed in that case.       One might think that we need only set VAL to 1 if this is a call-used      register.  However, the set of registers that must be saved by the      prologue is not identical to the call-used set.  For example, the      register used by the call insn for the return PC is a call-used register,      but must be saved by the prologue.  */
if|if
condition|(
name|num_eliminable
operator|&&
operator|!
name|regs_ever_live
index|[
name|spill_regs
index|[
name|n_spills
index|]
index|]
condition|)
name|val
operator|=
literal|1
expr_stmt|;
name|regs_ever_live
index|[
name|spill_regs
index|[
name|n_spills
index|]
index|]
operator|=
literal|1
expr_stmt|;
name|n_spills
operator|++
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Delete an unneeded INSN and any previous insns who sole purpose is loading    data that is dead in INSN.  */
end_comment

begin_function
specifier|static
name|void
name|delete_dead_insn
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|prev
init|=
name|prev_real_insn
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|prev_dest
decl_stmt|;
comment|/* If the previous insn sets a register that dies in our insn, delete it      too.  */
if|if
condition|(
name|prev
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
operator|(
name|prev_dest
operator|=
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|)
operator|,
name|GET_CODE
argument_list|(
name|prev_dest
argument_list|)
operator|==
name|REG
operator|)
operator|&&
name|reg_mentioned_p
argument_list|(
name|prev_dest
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|&&
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
name|prev_dest
argument_list|)
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|)
argument_list|)
condition|)
name|delete_dead_insn
argument_list|(
name|prev
argument_list|)
expr_stmt|;
name|PUT_CODE
argument_list|(
name|insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Modify the home of pseudo-reg I.    The new home is present in reg_renumber[I].     FROM_REG may be the hard reg that the pseudo-reg is being spilled from;    or it may be -1, meaning there is none or it is not relevant.    This is used so that all pseudos spilled from a given hard reg    can share one stack slot.  */
end_comment

begin_function
specifier|static
name|void
name|alter_reg
parameter_list|(
name|i
parameter_list|,
name|from_reg
parameter_list|)
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|from_reg
decl_stmt|;
block|{
comment|/* When outputting an inline function, this can happen      for a reg that isn't actually used.  */
if|if
condition|(
name|regno_reg_rtx
index|[
name|i
index|]
operator|==
literal|0
condition|)
return|return;
comment|/* If the reg got changed to a MEM at rtl-generation time,      ignore it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|)
operator|!=
name|REG
condition|)
return|return;
comment|/* Modify the reg-rtx to contain the new hard reg      number or else to contain its pseudo reg number.  */
name|REGNO
argument_list|(
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|)
operator|=
name|reg_renumber
index|[
name|i
index|]
operator|>=
literal|0
condition|?
name|reg_renumber
index|[
name|i
index|]
else|:
name|i
expr_stmt|;
comment|/* If we have a pseudo that is needed but has no hard reg or equivalent,      allocate a stack slot for it.  */
if|if
condition|(
name|reg_renumber
index|[
name|i
index|]
operator|<
literal|0
operator|&&
name|REG_N_REFS
argument_list|(
name|i
argument_list|)
operator|>
literal|0
operator|&&
name|reg_equiv_constant
index|[
name|i
index|]
operator|==
literal|0
operator|&&
name|reg_equiv_memory_loc
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
specifier|register
name|rtx
name|x
decl_stmt|;
name|int
name|inherent_size
init|=
name|PSEUDO_REGNO_BYTES
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|int
name|total_size
init|=
name|MAX
argument_list|(
name|inherent_size
argument_list|,
name|reg_max_ref_width
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|int
name|adjust
init|=
literal|0
decl_stmt|;
comment|/* Each pseudo reg has an inherent size which comes from its own mode, 	 and a total size which provides room for paradoxical subregs 	 which refer to the pseudo reg in wider modes.  	 We can use a slot already allocated if it provides both 	 enough inherent space and enough total space. 	 Otherwise, we allocate a new slot, making sure that it has no less 	 inherent space, and no less total space, then the previous slot.  */
if|if
condition|(
name|from_reg
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* No known place to spill from => no slot to reuse.  */
name|x
operator|=
name|assign_stack_local
argument_list|(
name|GET_MODE
argument_list|(
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|)
argument_list|,
name|total_size
argument_list|,
name|inherent_size
operator|==
name|total_size
condition|?
literal|0
else|:
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
comment|/* Cancel the  big-endian correction done in assign_stack_local. 	       Get the address of the beginning of the slot. 	       This is so we can do a big-endian correction unconditionally 	       below.  */
name|adjust
operator|=
name|inherent_size
operator|-
name|total_size
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|x
argument_list|)
operator|=
name|RTX_UNCHANGING_P
argument_list|(
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Reuse a stack slot if possible.  */
elseif|else
if|if
condition|(
name|spill_stack_slot
index|[
name|from_reg
index|]
operator|!=
literal|0
operator|&&
name|spill_stack_slot_width
index|[
name|from_reg
index|]
operator|>=
name|total_size
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|spill_stack_slot
index|[
name|from_reg
index|]
argument_list|)
argument_list|)
operator|>=
name|inherent_size
operator|)
condition|)
name|x
operator|=
name|spill_stack_slot
index|[
name|from_reg
index|]
expr_stmt|;
comment|/* Allocate a bigger slot.  */
else|else
block|{
comment|/* Compute maximum size needed, both for inherent size 	     and for total size.  */
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|rtx
name|stack_slot
decl_stmt|;
if|if
condition|(
name|spill_stack_slot
index|[
name|from_reg
index|]
condition|)
block|{
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|spill_stack_slot
index|[
name|from_reg
index|]
argument_list|)
argument_list|)
operator|>
name|inherent_size
condition|)
name|mode
operator|=
name|GET_MODE
argument_list|(
name|spill_stack_slot
index|[
name|from_reg
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|spill_stack_slot_width
index|[
name|from_reg
index|]
operator|>
name|total_size
condition|)
name|total_size
operator|=
name|spill_stack_slot_width
index|[
name|from_reg
index|]
expr_stmt|;
block|}
comment|/* Make a slot with that size.  */
name|x
operator|=
name|assign_stack_local
argument_list|(
name|mode
argument_list|,
name|total_size
argument_list|,
name|inherent_size
operator|==
name|total_size
condition|?
literal|0
else|:
operator|-
literal|1
argument_list|)
expr_stmt|;
name|stack_slot
operator|=
name|x
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
block|{
comment|/* Cancel the  big-endian correction done in assign_stack_local. 		 Get the address of the beginning of the slot. 		 This is so we can do a big-endian correction unconditionally 		 below.  */
name|adjust
operator|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|-
name|total_size
expr_stmt|;
if|if
condition|(
name|adjust
condition|)
name|stack_slot
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode_for_size
argument_list|(
name|total_size
operator|*
name|BITS_PER_UNIT
argument_list|,
name|MODE_INT
argument_list|,
literal|1
argument_list|)
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|adjust
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|spill_stack_slot
index|[
name|from_reg
index|]
operator|=
name|stack_slot
expr_stmt|;
name|spill_stack_slot_width
index|[
name|from_reg
index|]
operator|=
name|total_size
expr_stmt|;
block|}
comment|/* On a big endian machine, the "address" of the slot 	 is the address of the low part that fits its inherent mode.  */
if|if
condition|(
name|BYTES_BIG_ENDIAN
operator|&&
name|inherent_size
operator|<
name|total_size
condition|)
name|adjust
operator|+=
operator|(
name|total_size
operator|-
name|inherent_size
operator|)
expr_stmt|;
comment|/* If we have any adjustment to make, or if the stack slot is the 	 wrong mode, make a new stack slot.  */
if|if
condition|(
name|adjust
operator|!=
literal|0
operator|||
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|x
operator|=
name|gen_rtx_MEM
argument_list|(
name|GET_MODE
argument_list|(
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|)
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|adjust
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this was shared among registers, must ensure we never 	     set it readonly since that can cause scheduling 	     problems.  Note we would only have in this adjustment 	     case in any event, since the code above doesn't set it.  */
if|if
condition|(
name|from_reg
operator|==
operator|-
literal|1
condition|)
name|RTX_UNCHANGING_P
argument_list|(
name|x
argument_list|)
operator|=
name|RTX_UNCHANGING_P
argument_list|(
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Save the stack slot for later.   */
name|reg_equiv_memory_loc
index|[
name|i
index|]
operator|=
name|x
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Mark the slots in regs_ever_live for the hard regs    used by pseudo-reg number REGNO.  */
end_comment

begin_function
name|void
name|mark_home_live
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|lim
decl_stmt|;
name|i
operator|=
name|reg_renumber
index|[
name|regno
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
return|return;
name|lim
operator|=
name|i
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|i
argument_list|,
name|PSEUDO_REGNO_MODE
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|lim
condition|)
name|regs_ever_live
index|[
name|i
operator|++
index|]
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Mark the registers used in SCRATCH as being live.  */
end_comment

begin_function
specifier|static
name|void
name|mark_scratch_live
parameter_list|(
name|scratch
parameter_list|)
name|rtx
name|scratch
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|scratch
argument_list|)
decl_stmt|;
name|int
name|lim
init|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|scratch
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
name|regno
init|;
name|i
operator|<
name|lim
condition|;
name|i
operator|++
control|)
name|regs_ever_live
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This function handles the tracking of elimination offsets around branches.     X is a piece of RTL being scanned.     INSN is the insn that it came from, if any.     INITIAL_P is non-zero if we are to set the offset to be the initial    offset and zero if we are setting the offset of the label to be the    current offset.  */
end_comment

begin_function
specifier|static
name|void
name|set_label_offsets
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|,
name|initial_p
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|initial_p
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|elim_table
modifier|*
name|p
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LABEL_REF
case|:
if|if
condition|(
name|LABEL_REF_NONLOCAL_P
argument_list|(
name|x
argument_list|)
condition|)
return|return;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* ... fall through ...  */
case|case
name|CODE_LABEL
case|:
comment|/* If we know nothing about this label, set the desired offsets.  Note 	 that this sets the offset at a label to be the offset before a label 	 if we don't know anything about the label.  This is not correct for 	 the label after a BARRIER, but is the best guess we can make.  If 	 we guessed wrong, we will suppress an elimination that might have 	 been possible had we been able to guess correctly.  */
if|if
condition|(
operator|!
name|offsets_known_at
index|[
name|CODE_LABEL_NUMBER
argument_list|(
name|x
argument_list|)
index|]
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_ELIMINABLE_REGS
condition|;
name|i
operator|++
control|)
name|offsets_at
index|[
name|CODE_LABEL_NUMBER
argument_list|(
name|x
argument_list|)
index|]
index|[
name|i
index|]
operator|=
operator|(
name|initial_p
condition|?
name|reg_eliminate
index|[
name|i
index|]
operator|.
name|initial_offset
else|:
name|reg_eliminate
index|[
name|i
index|]
operator|.
name|offset
operator|)
expr_stmt|;
name|offsets_known_at
index|[
name|CODE_LABEL_NUMBER
argument_list|(
name|x
argument_list|)
index|]
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Otherwise, if this is the definition of a label and it is 	 preceded by a BARRIER, set our offsets to the known offset of 	 that label.  */
elseif|else
if|if
condition|(
name|x
operator|==
name|insn
operator|&&
operator|(
name|tem
operator|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|BARRIER
condition|)
block|{
name|num_not_at_initial_offset
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_ELIMINABLE_REGS
condition|;
name|i
operator|++
control|)
block|{
name|reg_eliminate
index|[
name|i
index|]
operator|.
name|offset
operator|=
name|reg_eliminate
index|[
name|i
index|]
operator|.
name|previous_offset
operator|=
name|offsets_at
index|[
name|CODE_LABEL_NUMBER
argument_list|(
name|x
argument_list|)
index|]
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|reg_eliminate
index|[
name|i
index|]
operator|.
name|can_eliminate
operator|&&
operator|(
name|reg_eliminate
index|[
name|i
index|]
operator|.
name|offset
operator|!=
name|reg_eliminate
index|[
name|i
index|]
operator|.
name|initial_offset
operator|)
condition|)
name|num_not_at_initial_offset
operator|++
expr_stmt|;
block|}
block|}
else|else
comment|/* If neither of the above cases is true, compare each offset 	   with those previously recorded and suppress any eliminations 	   where the offsets disagree.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_ELIMINABLE_REGS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|offsets_at
index|[
name|CODE_LABEL_NUMBER
argument_list|(
name|x
argument_list|)
index|]
index|[
name|i
index|]
operator|!=
operator|(
name|initial_p
condition|?
name|reg_eliminate
index|[
name|i
index|]
operator|.
name|initial_offset
else|:
name|reg_eliminate
index|[
name|i
index|]
operator|.
name|offset
operator|)
condition|)
name|reg_eliminate
index|[
name|i
index|]
operator|.
name|can_eliminate
operator|=
literal|0
expr_stmt|;
return|return;
case|case
name|JUMP_INSN
case|:
name|set_label_offsets
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
name|initial_p
argument_list|)
expr_stmt|;
comment|/* ... fall through ...  */
case|case
name|INSN
case|:
case|case
name|CALL_INSN
case|:
comment|/* Any labels mentioned in REG_LABEL notes can be branched to indirectly 	 and hence must have all eliminations at their initial offsets.  */
for|for
control|(
name|tem
operator|=
name|REG_NOTES
argument_list|(
name|x
argument_list|)
init|;
name|tem
condition|;
name|tem
operator|=
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|tem
argument_list|)
operator|==
name|REG_LABEL
condition|)
name|set_label_offsets
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
comment|/* Each of the labels in the address vector must be at their initial 	 offsets.  We want the first field for ADDR_VEC and the second 	 field for ADDR_DIFF_VEC.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|code
operator|==
name|ADDR_DIFF_VEC
argument_list|)
condition|;
name|i
operator|++
control|)
name|set_label_offsets
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|code
operator|==
name|ADDR_DIFF_VEC
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|,
name|initial_p
argument_list|)
expr_stmt|;
return|return;
case|case
name|SET
case|:
comment|/* We only care about setting PC.  If the source is not RETURN, 	 IF_THEN_ELSE, or a label, disable any eliminations not at 	 their initial offsets.  Similarly if any arm of the IF_THEN_ELSE 	 isn't one of those possibilities.  For branches to a label, 	 call ourselves recursively.  	 Note that this can disable elimination unnecessarily when we have 	 a non-local goto since it will look like a non-constant jump to 	 someplace in the current function.  This isn't a significant 	 problem since such jumps will normally be when all elimination 	 pairs are back to their initial offsets.  */
if|if
condition|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|!=
name|pc_rtx
condition|)
return|return;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|PC
case|:
case|case
name|RETURN
case|:
return|return;
case|case
name|LABEL_REF
case|:
name|set_label_offsets
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|,
name|initial_p
argument_list|)
expr_stmt|;
return|return;
case|case
name|IF_THEN_ELSE
case|:
name|tem
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|set_label_offsets
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|,
name|initial_p
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|!=
name|PC
operator|&&
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|!=
name|RETURN
condition|)
break|break;
name|tem
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|set_label_offsets
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|,
name|initial_p
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|!=
name|PC
operator|&&
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|!=
name|RETURN
condition|)
break|break;
return|return;
default|default:
break|break;
block|}
comment|/* If we reach here, all eliminations must be at their initial 	 offset because we are doing a jump to a variable address.  */
for|for
control|(
name|p
operator|=
name|reg_eliminate
init|;
name|p
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|p
operator|->
name|offset
operator|!=
name|p
operator|->
name|initial_offset
condition|)
name|p
operator|->
name|can_eliminate
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Used for communication between the next two function to properly share    the vector for an ASM_OPERANDS.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|rtvec_def
modifier|*
name|old_asm_operands_vec
decl_stmt|,
modifier|*
name|new_asm_operands_vec
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Scan X and replace any eliminable registers (such as fp) with a    replacement (such as sp), plus an offset.     MEM_MODE is the mode of an enclosing MEM.  We need this to know how    much to adjust a register for, e.g., PRE_DEC.  Also, if we are inside a    MEM, we are allowed to replace a sum of a register and the constant zero    with the register, which we cannot do outside a MEM.  In addition, we need    to record the fact that a register is referenced outside a MEM.     If INSN is an insn, it is the insn containing X.  If we replace a REG    in a SET_DEST with an equivalent MEM and INSN is non-zero, write a    CLOBBER of the pseudo after INSN so find_equiv_regs will know that    the REG is being modified.     Alternatively, INSN may be a note (an EXPR_LIST or INSN_LIST).    That's used when we eliminate in expressions stored in notes.    This means, do not set ref_outside_mem even if the reference    is outside of MEMs.     If we see a modification to a register we know about, take the    appropriate action (see case SET, below).     REG_EQUIV_MEM and REG_EQUIV_ADDRESS contain address that have had    replacements done assuming all offsets are at their initial values.  If    they are not, or if REG_EQUIV_ADDRESS is nonzero for a pseudo we    encounter, return the actual location so that find_reloads will do    the proper thing.  */
end_comment

begin_function
name|rtx
name|eliminate_regs
parameter_list|(
name|x
parameter_list|,
name|mem_mode
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|enum
name|machine_mode
name|mem_mode
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|struct
name|elim_table
modifier|*
name|ep
decl_stmt|;
name|int
name|regno
decl_stmt|;
name|rtx
name|new
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|copied
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CODE_LABEL
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|ASM_INPUT
case|:
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
case|case
name|RETURN
case|:
return|return
name|x
return|;
case|case
name|ADDRESSOF
case|:
comment|/* This is only for the benefit of the debugging backends, which call 	 eliminate_regs on DECL_RTL; any ADDRESSOFs in the actual insns are 	 removed after CSE.  */
name|new
operator|=
name|eliminate_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|new
argument_list|)
operator|==
name|MEM
condition|)
return|return
name|XEXP
argument_list|(
name|new
argument_list|,
literal|0
argument_list|)
return|;
return|return
name|x
return|;
case|case
name|REG
case|:
name|regno
operator|=
name|REGNO
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* First handle the case where we encounter a bare register that 	 is eliminable.  Replace it with a PLUS.  */
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
for|for
control|(
name|ep
operator|=
name|reg_eliminate
init|;
name|ep
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|ep
operator|++
control|)
if|if
condition|(
name|ep
operator|->
name|from_rtx
operator|==
name|x
operator|&&
name|ep
operator|->
name|can_eliminate
condition|)
block|{
if|if
condition|(
operator|!
name|mem_mode
comment|/* Refs inside notes don't count for this purpose.  */
operator|&&
operator|!
operator|(
name|insn
operator|!=
literal|0
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|EXPR_LIST
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN_LIST
operator|)
operator|)
condition|)
name|ep
operator|->
name|ref_outside_mem
operator|=
literal|1
expr_stmt|;
return|return
name|plus_constant
argument_list|(
name|ep
operator|->
name|to_rtx
argument_list|,
name|ep
operator|->
name|previous_offset
argument_list|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|reg_equiv_memory_loc
operator|&&
name|reg_equiv_memory_loc
index|[
name|regno
index|]
operator|&&
operator|(
name|reg_equiv_address
index|[
name|regno
index|]
operator|||
name|num_not_at_initial_offset
operator|)
condition|)
block|{
comment|/* In this case, find_reloads would attempt to either use an 	     incorrect address (if something is not at its initial offset) 	     or substitute an replaced address into an insn (which loses 	     if the offset is changed by some later action).  So we simply 	     return the replaced stack slot (assuming it is changed by 	     elimination) and ignore the fact that this is actually a 	     reference to the pseudo.  Ensure we make a copy of the 	     address in case it is shared.  */
name|new
operator|=
name|eliminate_regs
argument_list|(
name|reg_equiv_memory_loc
index|[
name|regno
index|]
argument_list|,
name|mem_mode
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|!=
name|reg_equiv_memory_loc
index|[
name|regno
index|]
condition|)
block|{
if|if
condition|(
name|insn
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|EXPR_LIST
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|INSN_LIST
condition|)
name|REG_NOTES
argument_list|(
name|emit_insn_before
argument_list|(
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|x
argument_list|)
argument_list|,
name|insn
argument_list|)
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_EQUAL
argument_list|,
name|new
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
return|return
name|copy_rtx
argument_list|(
name|new
argument_list|)
return|;
block|}
block|}
return|return
name|x
return|;
case|case
name|PLUS
case|:
comment|/* If this is the sum of an eliminable register and a constant, rework 	 the sum.   */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
for|for
control|(
name|ep
operator|=
name|reg_eliminate
init|;
name|ep
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|ep
operator|++
control|)
if|if
condition|(
name|ep
operator|->
name|from_rtx
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|&&
name|ep
operator|->
name|can_eliminate
condition|)
block|{
if|if
condition|(
operator|!
name|mem_mode
comment|/* Refs inside notes don't count for this purpose.  */
operator|&&
operator|!
operator|(
name|insn
operator|!=
literal|0
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|EXPR_LIST
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN_LIST
operator|)
operator|)
condition|)
name|ep
operator|->
name|ref_outside_mem
operator|=
literal|1
expr_stmt|;
comment|/* The only time we want to replace a PLUS with a REG (this 		   occurs when the constant operand of the PLUS is the negative 		   of the offset) is when we are inside a MEM.  We won't want 		   to do so at other times because that would change the 		   structure of the insn in a way that reload can't handle. 		   We special-case the commonest situation in 		   eliminate_regs_in_insn, so just replace a PLUS with a 		   PLUS here, unless inside a MEM.  */
if|if
condition|(
name|mem_mode
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
operator|-
name|ep
operator|->
name|previous_offset
condition|)
return|return
name|ep
operator|->
name|to_rtx
return|;
else|else
return|return
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|ep
operator|->
name|to_rtx
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|ep
operator|->
name|previous_offset
argument_list|)
argument_list|)
return|;
block|}
comment|/* If the register is not eliminable, we are done since the other 	     operand is a constant.  */
return|return
name|x
return|;
block|}
comment|/* If this is part of an address, we want to bring any constant to the 	 outermost PLUS.  We will do this by doing register replacement in 	 our operands and seeing if a constant shows up in one of them.  	 We assume here this is part of an address (or a "load address" insn) 	 since an eliminable register is not likely to appear in any other 	 context.  	 If we have (plus (eliminable) (reg)), we want to produce 	 (plus (plus (replacement) (reg) (const))).  If this was part of a 	 normal add insn, (plus (replacement) (reg)) will be pushed as a 	 reload.  This is the desired action.  */
block|{
name|rtx
name|new0
init|=
name|eliminate_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mem_mode
argument_list|,
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|new1
init|=
name|eliminate_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mem_mode
argument_list|,
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|new0
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|||
name|new1
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|/* If one side is a PLUS and the other side is a pseudo that 	       didn't get a hard register but has a reg_equiv_constant, 	       we must replace the constant here since it may no longer 	       be in the position of any operand.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|new0
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|new1
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|new1
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_renumber
index|[
name|REGNO
argument_list|(
name|new1
argument_list|)
index|]
operator|<
literal|0
operator|&&
name|reg_equiv_constant
operator|!=
literal|0
operator|&&
name|reg_equiv_constant
index|[
name|REGNO
argument_list|(
name|new1
argument_list|)
index|]
operator|!=
literal|0
condition|)
name|new1
operator|=
name|reg_equiv_constant
index|[
name|REGNO
argument_list|(
name|new1
argument_list|)
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|new1
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|new0
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|new0
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_renumber
index|[
name|REGNO
argument_list|(
name|new0
argument_list|)
index|]
operator|<
literal|0
operator|&&
name|reg_equiv_constant
index|[
name|REGNO
argument_list|(
name|new0
argument_list|)
index|]
operator|!=
literal|0
condition|)
name|new0
operator|=
name|reg_equiv_constant
index|[
name|REGNO
argument_list|(
name|new0
argument_list|)
index|]
expr_stmt|;
name|new
operator|=
name|form_sum
argument_list|(
name|new0
argument_list|,
name|new1
argument_list|)
expr_stmt|;
comment|/* As above, if we are not inside a MEM we do not want to 	       turn a PLUS into something else.  We might try to do so here 	       for an addition of 0 if we aren't optimizing.  */
if|if
condition|(
operator|!
name|mem_mode
operator|&&
name|GET_CODE
argument_list|(
name|new
argument_list|)
operator|!=
name|PLUS
condition|)
return|return
name|gen_rtx_PLUS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|new
argument_list|,
name|const0_rtx
argument_list|)
return|;
else|else
return|return
name|new
return|;
block|}
block|}
return|return
name|x
return|;
case|case
name|MULT
case|:
comment|/* If this is the product of an eliminable register and a  	 constant, apply the distribute law and move the constant out 	 so that we have (plus (mult ..) ..).  This is needed in order 	 to keep load-address insns valid.   This case is pathological. 	 We ignore the possibility of overflow here.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
for|for
control|(
name|ep
operator|=
name|reg_eliminate
init|;
name|ep
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|ep
operator|++
control|)
if|if
condition|(
name|ep
operator|->
name|from_rtx
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|&&
name|ep
operator|->
name|can_eliminate
condition|)
block|{
if|if
condition|(
operator|!
name|mem_mode
comment|/* Refs inside notes don't count for this purpose.  */
operator|&&
operator|!
operator|(
name|insn
operator|!=
literal|0
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|EXPR_LIST
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN_LIST
operator|)
operator|)
condition|)
name|ep
operator|->
name|ref_outside_mem
operator|=
literal|1
expr_stmt|;
return|return
name|plus_constant
argument_list|(
name|gen_rtx_MULT
argument_list|(
name|Pmode
argument_list|,
name|ep
operator|->
name|to_rtx
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|ep
operator|->
name|previous_offset
operator|*
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/* ... fall through ...  */
case|case
name|CALL
case|:
case|case
name|COMPARE
case|:
case|case
name|MINUS
case|:
case|case
name|DIV
case|:
case|case
name|UDIV
case|:
case|case
name|MOD
case|:
case|case
name|UMOD
case|:
case|case
name|AND
case|:
case|case
name|IOR
case|:
case|case
name|XOR
case|:
case|case
name|ROTATERT
case|:
case|case
name|ROTATE
case|:
case|case
name|ASHIFTRT
case|:
case|case
name|LSHIFTRT
case|:
case|case
name|ASHIFT
case|:
case|case
name|NE
case|:
case|case
name|EQ
case|:
case|case
name|GE
case|:
case|case
name|GT
case|:
case|case
name|GEU
case|:
case|case
name|GTU
case|:
case|case
name|LE
case|:
case|case
name|LT
case|:
case|case
name|LEU
case|:
case|case
name|LTU
case|:
block|{
name|rtx
name|new0
init|=
name|eliminate_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mem_mode
argument_list|,
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|new1
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|?
name|eliminate_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mem_mode
argument_list|,
name|insn
argument_list|)
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|new0
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|||
name|new1
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|new0
argument_list|,
name|new1
argument_list|)
return|;
block|}
return|return
name|x
return|;
case|case
name|EXPR_LIST
case|:
comment|/* If we have something in XEXP (x, 0), the usual case, eliminate it.  */
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|new
operator|=
name|eliminate_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mem_mode
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|)
name|x
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_NOTE_KIND
argument_list|(
name|x
argument_list|)
argument_list|,
name|new
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* ... fall through ...  */
case|case
name|INSN_LIST
case|:
comment|/* Now do eliminations in the rest of the chain.  If this was 	 an EXPR_LIST, this might result in allocating more memory than is 	 strictly needed, but it simplifies the code.  */
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|new
operator|=
name|eliminate_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mem_mode
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|gen_rtx_fmt_ee
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|new
argument_list|)
return|;
block|}
return|return
name|x
return|;
case|case
name|PRE_INC
case|:
case|case
name|POST_INC
case|:
case|case
name|PRE_DEC
case|:
case|case
name|POST_DEC
case|:
for|for
control|(
name|ep
operator|=
name|reg_eliminate
init|;
name|ep
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|ep
operator|++
control|)
if|if
condition|(
name|ep
operator|->
name|to_rtx
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|int
name|size
init|=
name|GET_MODE_SIZE
argument_list|(
name|mem_mode
argument_list|)
decl_stmt|;
comment|/* If more bytes than MEM_MODE are pushed, account for them.  */
ifdef|#
directive|ifdef
name|PUSH_ROUNDING
if|if
condition|(
name|ep
operator|->
name|to_rtx
operator|==
name|stack_pointer_rtx
condition|)
name|size
operator|=
name|PUSH_ROUNDING
argument_list|(
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|code
operator|==
name|PRE_DEC
operator|||
name|code
operator|==
name|POST_DEC
condition|)
name|ep
operator|->
name|offset
operator|+=
name|size
expr_stmt|;
else|else
name|ep
operator|->
name|offset
operator|-=
name|size
expr_stmt|;
block|}
comment|/* Fall through to generic unary operation case.  */
case|case
name|STRICT_LOW_PART
case|:
case|case
name|NEG
case|:
case|case
name|NOT
case|:
case|case
name|SIGN_EXTEND
case|:
case|case
name|ZERO_EXTEND
case|:
case|case
name|TRUNCATE
case|:
case|case
name|FLOAT_EXTEND
case|:
case|case
name|FLOAT_TRUNCATE
case|:
case|case
name|FLOAT
case|:
case|case
name|FIX
case|:
case|case
name|UNSIGNED_FIX
case|:
case|case
name|UNSIGNED_FLOAT
case|:
case|case
name|ABS
case|:
case|case
name|SQRT
case|:
case|case
name|FFS
case|:
name|new
operator|=
name|eliminate_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mem_mode
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|gen_rtx_fmt_e
argument_list|(
name|code
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|new
argument_list|)
return|;
return|return
name|x
return|;
case|case
name|SUBREG
case|:
comment|/* Similar to above processing, but preserve SUBREG_WORD. 	 Convert (subreg (mem)) to (mem) if not paradoxical. 	 Also, if we have a non-paradoxical (subreg (pseudo)) and the 	 pseudo didn't get a hard reg, we must replace this with the 	 eliminated version of the memory location because push_reloads 	 may do the replacement in certain circumstances.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
name|reg_equiv_memory_loc
operator|!=
literal|0
operator|&&
name|reg_equiv_memory_loc
index|[
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
index|]
operator|!=
literal|0
condition|)
block|{
name|new
operator|=
name|eliminate_regs
argument_list|(
name|reg_equiv_memory_loc
index|[
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
index|]
argument_list|,
name|mem_mode
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* If we didn't change anything, we must retain the pseudo.  */
if|if
condition|(
name|new
operator|==
name|reg_equiv_memory_loc
index|[
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
index|]
condition|)
name|new
operator|=
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* In this case, we must show that the pseudo is used in this 		 insn so that delete_output_reload will do the right thing.  */
if|if
condition|(
name|insn
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|EXPR_LIST
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|INSN_LIST
condition|)
name|REG_NOTES
argument_list|(
name|emit_insn_before
argument_list|(
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_EQUAL
argument_list|,
name|new
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
comment|/* Ensure NEW isn't shared in case we have to reload it.  */
name|new
operator|=
name|copy_rtx
argument_list|(
name|new
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|new
operator|=
name|eliminate_regs
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
name|mem_mode
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|int
name|x_size
init|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|new_size
init|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|new
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|new
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
operator|(
name|x_size
operator|<
name|new_size
ifdef|#
directive|ifdef
name|WORD_REGISTER_OPERATIONS
comment|/* On these machines, combine can create rtl of the form 		      (set (subreg:m1 (reg:m2 R) 0) ...) 		      where m1< m2, and expects something interesting to  		      happen to the entire word.  Moreover, it will use the 		      (reg:m2 R) later, expecting all bits to be preserved. 		      So if the number of words is the same, preserve the  		      subreg so that push_reloads can see it.  */
operator|&&
operator|!
operator|(
operator|(
name|x_size
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
operator|==
operator|(
name|new_size
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
endif|#
directive|endif
operator|)
operator|||
operator|(
name|x_size
operator|==
name|new_size
operator|)
operator|)
condition|)
block|{
name|int
name|offset
init|=
name|SUBREG_WORD
argument_list|(
name|x
argument_list|)
operator|*
name|UNITS_PER_WORD
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
name|offset
operator|+=
operator|(
name|MIN
argument_list|(
name|UNITS_PER_WORD
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|new
argument_list|)
argument_list|)
argument_list|)
operator|-
name|MIN
argument_list|(
name|UNITS_PER_WORD
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|new
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|new
argument_list|,
literal|0
argument_list|)
operator|=
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|new
argument_list|,
literal|0
argument_list|)
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
else|else
return|return
name|gen_rtx_SUBREG
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|new
argument_list|,
name|SUBREG_WORD
argument_list|(
name|x
argument_list|)
argument_list|)
return|;
block|}
return|return
name|x
return|;
case|case
name|USE
case|:
comment|/* If using a register that is the source of an eliminate we still 	 think can be performed, note it cannot be performed since we don't 	 know how this register is used.  */
for|for
control|(
name|ep
operator|=
name|reg_eliminate
init|;
name|ep
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|ep
operator|++
control|)
if|if
condition|(
name|ep
operator|->
name|from_rtx
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|)
name|ep
operator|->
name|can_eliminate
operator|=
literal|0
expr_stmt|;
name|new
operator|=
name|eliminate_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mem_mode
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|gen_rtx_fmt_e
argument_list|(
name|code
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|new
argument_list|)
return|;
return|return
name|x
return|;
case|case
name|CLOBBER
case|:
comment|/* If clobbering a register that is the replacement register for an 	 elimination we still think can be performed, note that it cannot 	 be performed.  Otherwise, we need not be concerned about it.  */
for|for
control|(
name|ep
operator|=
name|reg_eliminate
init|;
name|ep
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|ep
operator|++
control|)
if|if
condition|(
name|ep
operator|->
name|to_rtx
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|)
name|ep
operator|->
name|can_eliminate
operator|=
literal|0
expr_stmt|;
name|new
operator|=
name|eliminate_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mem_mode
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|gen_rtx_fmt_e
argument_list|(
name|code
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|new
argument_list|)
return|;
return|return
name|x
return|;
case|case
name|ASM_OPERANDS
case|:
block|{
name|rtx
modifier|*
name|temp_vec
decl_stmt|;
comment|/* Properly handle sharing input and constraint vectors.  */
if|if
condition|(
name|ASM_OPERANDS_INPUT_VEC
argument_list|(
name|x
argument_list|)
operator|!=
name|old_asm_operands_vec
condition|)
block|{
comment|/* When we come to a new vector not seen before, 	       scan all its elements; keep the old vector if none 	       of them changes; otherwise, make a copy.  */
name|old_asm_operands_vec
operator|=
name|ASM_OPERANDS_INPUT_VEC
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|temp_vec
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|3
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|x
argument_list|)
condition|;
name|i
operator|++
control|)
name|temp_vec
index|[
name|i
index|]
operator|=
name|eliminate_regs
argument_list|(
name|ASM_OPERANDS_INPUT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|mem_mode
argument_list|,
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|x
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|temp_vec
index|[
name|i
index|]
operator|!=
name|ASM_OPERANDS_INPUT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|x
argument_list|)
condition|)
name|new_asm_operands_vec
operator|=
name|old_asm_operands_vec
expr_stmt|;
else|else
name|new_asm_operands_vec
operator|=
name|gen_rtvec_v
argument_list|(
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|x
argument_list|)
argument_list|,
name|temp_vec
argument_list|)
expr_stmt|;
block|}
comment|/* If we had to copy the vector, copy the entire ASM_OPERANDS.  */
if|if
condition|(
name|new_asm_operands_vec
operator|==
name|old_asm_operands_vec
condition|)
return|return
name|x
return|;
name|new
operator|=
name|gen_rtx_ASM_OPERANDS
argument_list|(
name|VOIDmode
argument_list|,
name|ASM_OPERANDS_TEMPLATE
argument_list|(
name|x
argument_list|)
argument_list|,
name|ASM_OPERANDS_OUTPUT_CONSTRAINT
argument_list|(
name|x
argument_list|)
argument_list|,
name|ASM_OPERANDS_OUTPUT_IDX
argument_list|(
name|x
argument_list|)
argument_list|,
name|new_asm_operands_vec
argument_list|,
name|ASM_OPERANDS_INPUT_CONSTRAINT_VEC
argument_list|(
name|x
argument_list|)
argument_list|,
name|ASM_OPERANDS_SOURCE_FILE
argument_list|(
name|x
argument_list|)
argument_list|,
name|ASM_OPERANDS_SOURCE_LINE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|volatil
operator|=
name|x
operator|->
name|volatil
expr_stmt|;
return|return
name|new
return|;
block|}
case|case
name|SET
case|:
comment|/* Check for setting a register that we know about.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
comment|/* See if this is setting the replacement register for an 	     elimination.  	     If DEST is the hard frame pointer, we do nothing because we 	     assume that all assignments to the frame pointer are for 	     non-local gotos and are being done at a time when they are valid 	     and do not disturb anything else.  Some machines want to 	     eliminate a fake argument pointer (or even a fake frame pointer) 	     with either the real frame or the stack pointer.  Assignments to 	     the hard frame pointer must not prevent this elimination.  */
for|for
control|(
name|ep
operator|=
name|reg_eliminate
init|;
name|ep
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|ep
operator|++
control|)
if|if
condition|(
name|ep
operator|->
name|to_rtx
operator|==
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|&&
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|!=
name|hard_frame_pointer_rtx
condition|)
block|{
comment|/* If it is being incremented, adjust the offset.  Otherwise, 		   this elimination can't be done.  */
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
operator|==
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|ep
operator|->
name|offset
operator|-=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|ep
operator|->
name|can_eliminate
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Now check to see we are assigning to a register that can be 	     eliminated.  If so, it must be as part of a PARALLEL, since we 	     will not have been called if this is a single SET.  So indicate 	     that we can no longer eliminate this reg.  */
for|for
control|(
name|ep
operator|=
name|reg_eliminate
init|;
name|ep
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|ep
operator|++
control|)
if|if
condition|(
name|ep
operator|->
name|from_rtx
operator|==
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|&&
name|ep
operator|->
name|can_eliminate
condition|)
name|ep
operator|->
name|can_eliminate
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Now avoid the loop below in this common case.  */
block|{
name|rtx
name|new0
init|=
name|eliminate_regs
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|,
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|new1
init|=
name|eliminate_regs
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|,
name|insn
argument_list|)
decl_stmt|;
comment|/* If SET_DEST changed from a REG to a MEM and INSN is an insn, 	   write a CLOBBER insn.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|new0
argument_list|)
operator|==
name|MEM
operator|&&
name|insn
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|EXPR_LIST
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|INSN_LIST
condition|)
name|emit_insn_after
argument_list|(
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|new0
operator|!=
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|||
name|new1
operator|!=
name|SET_SRC
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|new0
argument_list|,
name|new1
argument_list|)
return|;
block|}
return|return
name|x
return|;
case|case
name|MEM
case|:
comment|/* This is only for the benefit of the debugging backends, which call 	 eliminate_regs on DECL_RTL; any ADDRESSOFs in the actual insns are 	 removed after CSE.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDRESSOF
condition|)
return|return
name|eliminate_regs
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
name|insn
argument_list|)
return|;
comment|/* Our only special processing is to pass the mode of the MEM to our 	 recursive call and copy the flags.  While we are here, handle this 	 case more efficiently.  */
name|new
operator|=
name|eliminate_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|new
operator|=
name|gen_rtx_MEM
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|->
name|volatil
operator|=
name|x
operator|->
name|volatil
expr_stmt|;
name|new
operator|->
name|unchanging
operator|=
name|x
operator|->
name|unchanging
expr_stmt|;
name|new
operator|->
name|in_struct
operator|=
name|x
operator|->
name|in_struct
expr_stmt|;
return|return
name|new
return|;
block|}
else|else
return|return
name|x
return|;
default|default:
break|break;
block|}
comment|/* Process each of our operands recursively.  If any have changed, make a      copy of the rtx.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
condition|;
name|i
operator|++
operator|,
name|fmt
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'e'
condition|)
block|{
name|new
operator|=
name|eliminate_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|mem_mode
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|&&
operator|!
name|copied
condition|)
block|{
name|rtx
name|new_x
init|=
name|rtx_alloc
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|x
argument_list|,
operator|(
name|char
operator|*
operator|)
name|new_x
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|new_x
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|new_x
operator|->
name|fld
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|new_x
operator|->
name|fld
index|[
literal|0
index|]
argument_list|)
operator|*
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|new_x
expr_stmt|;
name|copied
operator|=
literal|1
expr_stmt|;
block|}
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|=
name|new
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'E'
condition|)
block|{
name|int
name|copied_vec
init|=
literal|0
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|new
operator|=
name|eliminate_regs
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|mem_mode
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|!=
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|&&
operator|!
name|copied_vec
condition|)
block|{
name|rtvec
name|new_v
init|=
name|gen_rtvec_vv
argument_list|(
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|XVEC
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|->
name|elem
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|copied
condition|)
block|{
name|rtx
name|new_x
init|=
name|rtx_alloc
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|x
argument_list|,
operator|(
name|char
operator|*
operator|)
name|new_x
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|new_x
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|new_x
operator|->
name|fld
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|new_x
operator|->
name|fld
index|[
literal|0
index|]
argument_list|)
operator|*
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|)
operator|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|new_x
expr_stmt|;
name|copied
operator|=
literal|1
expr_stmt|;
block|}
name|XVEC
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|=
name|new_v
expr_stmt|;
name|copied_vec
operator|=
literal|1
expr_stmt|;
block|}
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|=
name|new
expr_stmt|;
block|}
block|}
block|}
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Scan INSN and eliminate all eliminable registers in it.     If REPLACE is nonzero, do the replacement destructively.  Also    delete the insn as dead it if it is setting an eliminable register.     If REPLACE is zero, do all our allocations in reload_obstack.     If no eliminations were done and this insn doesn't require any elimination    processing (these are not identical conditions: it might be updating sp,    but not referencing fp; this needs to be seen during reload_as_needed so    that the offset between fp and sp can be taken into consideration), zero    is returned.  Otherwise, 1 is returned.  */
end_comment

begin_function
specifier|static
name|int
name|eliminate_regs_in_insn
parameter_list|(
name|insn
parameter_list|,
name|replace
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|int
name|replace
decl_stmt|;
block|{
name|rtx
name|old_body
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|old_set
init|=
name|single_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|new_body
decl_stmt|;
name|int
name|val
init|=
literal|0
decl_stmt|;
name|struct
name|elim_table
modifier|*
name|ep
decl_stmt|;
if|if
condition|(
operator|!
name|replace
condition|)
name|push_obstacks
argument_list|(
operator|&
name|reload_obstack
argument_list|,
operator|&
name|reload_obstack
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_set
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|old_set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|old_set
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
comment|/* Check for setting an eliminable register.  */
for|for
control|(
name|ep
operator|=
name|reg_eliminate
init|;
name|ep
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|ep
operator|++
control|)
if|if
condition|(
name|ep
operator|->
name|from_rtx
operator|==
name|SET_DEST
argument_list|(
name|old_set
argument_list|)
operator|&&
name|ep
operator|->
name|can_eliminate
condition|)
block|{
if|#
directive|if
name|HARD_FRAME_POINTER_REGNUM
operator|!=
name|FRAME_POINTER_REGNUM
comment|/* If this is setting the frame pointer register to the 	       hardware frame pointer register and this is an elimination 	       that will be done (tested above), this insn is really 	       adjusting the frame pointer downward to compensate for 	       the adjustment done before a nonlocal goto.  */
if|if
condition|(
name|ep
operator|->
name|from
operator|==
name|FRAME_POINTER_REGNUM
operator|&&
name|ep
operator|->
name|to
operator|==
name|HARD_FRAME_POINTER_REGNUM
condition|)
block|{
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|old_set
argument_list|)
decl_stmt|;
name|int
name|offset
decl_stmt|,
name|ok
init|=
literal|0
decl_stmt|;
name|rtx
name|prev_insn
decl_stmt|,
name|prev_set
decl_stmt|;
if|if
condition|(
name|src
operator|==
name|ep
operator|->
name|to_rtx
condition|)
name|offset
operator|=
literal|0
operator|,
name|ok
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
operator|==
name|ep
operator|->
name|to_rtx
condition|)
name|offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|,
name|ok
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
operator|==
name|ep
operator|->
name|to_rtx
condition|)
name|offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|,
name|ok
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|prev_insn
operator|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|prev_set
operator|=
name|single_set
argument_list|(
name|prev_insn
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_DEST
argument_list|(
name|prev_set
argument_list|)
argument_list|,
name|src
argument_list|)
condition|)
block|{
name|src
operator|=
name|SET_SRC
argument_list|(
name|prev_set
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
operator|==
name|ep
operator|->
name|to_rtx
condition|)
name|offset
operator|=
literal|0
operator|,
name|ok
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
operator|==
name|ep
operator|->
name|to_rtx
condition|)
name|offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|,
name|ok
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
operator|==
name|ep
operator|->
name|to_rtx
condition|)
name|offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|,
name|ok
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ok
condition|)
block|{
if|if
condition|(
name|replace
condition|)
block|{
name|rtx
name|src
init|=
name|plus_constant
argument_list|(
name|ep
operator|->
name|to_rtx
argument_list|,
name|offset
operator|-
name|ep
operator|->
name|offset
argument_list|)
decl_stmt|;
comment|/* First see if this insn remains valid when we 			   make the change.  If not, keep the INSN_CODE 			   the same and let reload fit it up.  */
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|old_set
argument_list|)
argument_list|,
name|src
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_DEST
argument_list|(
name|old_set
argument_list|)
argument_list|,
name|ep
operator|->
name|to_rtx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|apply_change_group
argument_list|()
condition|)
block|{
name|SET_SRC
argument_list|(
name|old_set
argument_list|)
operator|=
name|src
expr_stmt|;
name|SET_DEST
argument_list|(
name|old_set
argument_list|)
operator|=
name|ep
operator|->
name|to_rtx
expr_stmt|;
block|}
block|}
name|val
operator|=
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
endif|#
directive|endif
comment|/* In this case this insn isn't serving a useful purpose.  We 	       will delete it in reload_as_needed once we know that this 	       elimination is, in fact, being done.  	       If REPLACE isn't set, we can't delete this insn, but needn't 	       process it since it won't be used unless something changes.  */
if|if
condition|(
name|replace
condition|)
name|delete_dead_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|val
operator|=
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Check for (set (reg) (plus (reg from) (offset))) where the offset 	 in the insn is the negative of the offset in FROM.  Substitute 	 (set (reg) (reg to)) for the insn and change its code.  	 We have to do this here, rather than in eliminate_regs, do that we can 	 change the insn code.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|old_set
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|old_set
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|old_set
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
for|for
control|(
name|ep
operator|=
name|reg_eliminate
init|;
name|ep
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|ep
operator|++
control|)
if|if
condition|(
name|ep
operator|->
name|from_rtx
operator|==
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|old_set
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|&&
name|ep
operator|->
name|can_eliminate
condition|)
block|{
comment|/* We must stop at the first elimination that will be used. 		 If this one would replace the PLUS with a REG, do it 		 now.  Otherwise, quit the loop and let eliminate_regs 		 do its normal replacement.  */
if|if
condition|(
name|ep
operator|->
name|offset
operator|==
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|old_set
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
comment|/* We assume here that we don't need a PARALLEL of 		     any CLOBBERs for this assignment.  There's not 		     much we can do if we do need it.  */
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|SET_DEST
argument_list|(
name|old_set
argument_list|)
argument_list|,
name|ep
operator|->
name|to_rtx
argument_list|)
expr_stmt|;
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|val
operator|=
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
break|break;
block|}
block|}
name|old_asm_operands_vec
operator|=
literal|0
expr_stmt|;
comment|/* Replace the body of this insn with a substituted form.  If we changed      something, return non-zero.         If we are replacing a body that was a (set X (plus Y Z)), try to      re-recognize the insn.  We do this in case we had a simple addition      but now can do this as a load-address.  This saves an insn in this      common case.  */
name|new_body
operator|=
name|eliminate_regs
argument_list|(
name|old_body
argument_list|,
literal|0
argument_list|,
name|replace
condition|?
name|insn
else|:
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_body
operator|!=
name|old_body
condition|)
block|{
comment|/* If we aren't replacing things permanently and we changed something, 	 make another copy to ensure that all the RTL is new.  Otherwise 	 things can go wrong if find_reload swaps commutative operands 	 and one is inside RTL that has been copied while the other is not.  */
comment|/* Don't copy an asm_operands because (1) there's no need and (2) 	 copy_rtx can't do it properly when there are multiple outputs.  */
if|if
condition|(
operator|!
name|replace
operator|&&
name|asm_noperands
argument_list|(
name|old_body
argument_list|)
operator|<
literal|0
condition|)
name|new_body
operator|=
name|copy_rtx
argument_list|(
name|new_body
argument_list|)
expr_stmt|;
comment|/* If we had a move insn but now we don't, rerecognize it.  This will 	 cause spurious re-recognition if the old move had a PARALLEL since 	 the new one still will, but we can't call single_set without 	 having put NEW_BODY into the insn and the re-recognition won't 	 hurt in this rare case.  */
if|if
condition|(
name|old_set
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|old_set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|new_body
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|new_body
argument_list|)
argument_list|)
operator|!=
name|REG
operator|)
operator|)
comment|/* If this was a load from or store to memory, compare 		 the MEM in recog_operand to the one in the insn.  If they 		 are not equal, then rerecognize the insn.  */
operator|||
operator|(
name|old_set
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|old_set
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|SET_SRC
argument_list|(
name|old_set
argument_list|)
operator|!=
name|recog_operand
index|[
literal|1
index|]
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|old_set
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|SET_DEST
argument_list|(
name|old_set
argument_list|)
operator|!=
name|recog_operand
index|[
literal|0
index|]
operator|)
operator|)
operator|)
comment|/* If this was an add insn before, rerecognize.  */
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|old_set
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|new_body
argument_list|,
literal|0
argument_list|)
condition|)
comment|/* If recognition fails, store the new body anyway. 	       It's normal to have recognition failures here 	       due to bizarre memory addresses; reloading will fix them.  */
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|new_body
expr_stmt|;
block|}
else|else
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|new_body
expr_stmt|;
name|val
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Loop through all elimination pairs.  See if any have changed and      recalculate the number not at initial offset.       Compute the maximum offset (minimum offset if the stack does not      grow downward) for each elimination pair.       We also detect a cases where register elimination cannot be done,      namely, if a register would be both changed and referenced outside a MEM      in the resulting insn since such an insn is often undefined and, even if      not, we cannot know what meaning will be given to it.  Note that it is      valid to have a register used in an address in an insn that changes it      (presumably with a pre- or post-increment or decrement).       If anything changes, return nonzero.  */
name|num_not_at_initial_offset
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ep
operator|=
name|reg_eliminate
init|;
name|ep
operator|<
operator|&
name|reg_eliminate
index|[
name|NUM_ELIMINABLE_REGS
index|]
condition|;
name|ep
operator|++
control|)
block|{
if|if
condition|(
name|ep
operator|->
name|previous_offset
operator|!=
name|ep
operator|->
name|offset
operator|&&
name|ep
operator|->
name|ref_outside_mem
condition|)
name|ep
operator|->
name|can_eliminate
operator|=
literal|0
expr_stmt|;
name|ep
operator|->
name|ref_outside_mem
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|previous_offset
operator|!=
name|ep
operator|->
name|offset
condition|)
name|val
operator|=
literal|1
expr_stmt|;
name|ep
operator|->
name|previous_offset
operator|=
name|ep
operator|->
name|offset
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|can_eliminate
operator|&&
name|ep
operator|->
name|offset
operator|!=
name|ep
operator|->
name|initial_offset
condition|)
name|num_not_at_initial_offset
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
name|ep
operator|->
name|max_offset
operator|=
name|MAX
argument_list|(
name|ep
operator|->
name|max_offset
argument_list|,
name|ep
operator|->
name|offset
argument_list|)
expr_stmt|;
else|#
directive|else
name|ep
operator|->
name|max_offset
operator|=
name|MIN
argument_list|(
name|ep
operator|->
name|max_offset
argument_list|,
name|ep
operator|->
name|offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|done
label|:
comment|/* If we changed something, perform elimination in REG_NOTES.  This is      needed even when REPLACE is zero because a REG_DEAD note might refer      to a register that we eliminate and could cause a different number      of spill registers to be needed in the final reload pass than in      the pre-passes.  */
if|if
condition|(
name|val
operator|&&
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|!=
literal|0
condition|)
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|eliminate_regs
argument_list|(
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|replace
condition|)
name|pop_obstacks
argument_list|()
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Given X, a SET or CLOBBER of DEST, if DEST is the target of a register    replacement we currently believe is valid, mark it as not eliminable if X    modifies DEST in any way other than by adding a constant integer to it.     If DEST is the frame pointer, we do nothing because we assume that    all assignments to the hard frame pointer are nonlocal gotos and are being    done at a time when they are valid and do not disturb anything else.    Some machines want to eliminate a fake argument pointer with either the    frame or stack pointer.  Assignments to the hard frame pointer must not    prevent this elimination.     Called via note_stores from reload before starting its passes to scan    the insns of the function.  */
end_comment

begin_function
specifier|static
name|void
name|mark_not_eliminable
parameter_list|(
name|dest
parameter_list|,
name|x
parameter_list|)
name|rtx
name|dest
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* A SUBREG of a hard register here is just changing its mode.  We should      not see a SUBREG of an eliminable hard register, but check just in      case.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
condition|)
name|dest
operator|=
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
operator|==
name|hard_frame_pointer_rtx
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_ELIMINABLE_REGS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reg_eliminate
index|[
name|i
index|]
operator|.
name|can_eliminate
operator|&&
name|dest
operator|==
name|reg_eliminate
index|[
name|i
index|]
operator|.
name|to_rtx
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|PLUS
operator|||
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|!=
name|dest
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|)
condition|)
block|{
name|reg_eliminate
index|[
name|i
index|]
operator|.
name|can_eliminate_previous
operator|=
name|reg_eliminate
index|[
name|i
index|]
operator|.
name|can_eliminate
operator|=
literal|0
expr_stmt|;
name|num_eliminable
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Kick all pseudos out of hard register REGNO.    If GLOBAL is nonzero, try to find someplace else to put them.    If DUMPFILE is nonzero, log actions taken on that file.     If CANT_ELIMINATE is nonzero, it means that we are doing this spill    because we found we can't eliminate some register.  In the case, no pseudos    are allowed to be in the register, even if they are only in a block that    doesn't require spill registers, unlike the case when we are spilling this    hard reg to produce another spill register.     Return nonzero if any pseudos needed to be kicked out.  */
end_comment

begin_function
specifier|static
name|int
name|spill_hard_reg
parameter_list|(
name|regno
parameter_list|,
name|global
parameter_list|,
name|dumpfile
parameter_list|,
name|cant_eliminate
parameter_list|)
specifier|register
name|int
name|regno
decl_stmt|;
name|int
name|global
decl_stmt|;
name|FILE
modifier|*
name|dumpfile
decl_stmt|;
name|int
name|cant_eliminate
decl_stmt|;
block|{
name|enum
name|reg_class
name|class
init|=
name|REGNO_REG_CLASS
argument_list|(
name|regno
argument_list|)
decl_stmt|;
name|int
name|something_changed
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|forbidden_regs
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|cant_eliminate
condition|)
name|regs_ever_live
index|[
name|regno
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Spill every pseudo reg that was allocated to this reg      or to something that overlaps this reg.  */
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reg_renumber
index|[
name|i
index|]
operator|>=
literal|0
operator|&&
name|reg_renumber
index|[
name|i
index|]
operator|<=
name|regno
operator|&&
operator|(
name|reg_renumber
index|[
name|i
index|]
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|reg_renumber
index|[
name|i
index|]
argument_list|,
name|PSEUDO_REGNO_MODE
argument_list|(
name|i
argument_list|)
argument_list|)
operator|>
name|regno
operator|)
condition|)
block|{
comment|/* If this register belongs solely to a basic block which needed no 	   spilling of any class that this register is contained in, 	   leave it be, unless we are spilling this register because 	   it was a hard register that can't be eliminated.   */
if|if
condition|(
operator|!
name|cant_eliminate
operator|&&
name|basic_block_needs
index|[
literal|0
index|]
operator|&&
name|REG_BASIC_BLOCK
argument_list|(
name|i
argument_list|)
operator|>=
literal|0
operator|&&
name|basic_block_needs
index|[
operator|(
name|int
operator|)
name|class
index|]
index|[
name|REG_BASIC_BLOCK
argument_list|(
name|i
argument_list|)
index|]
operator|==
literal|0
condition|)
block|{
name|enum
name|reg_class
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|reg_class_superclasses
index|[
operator|(
name|int
operator|)
name|class
index|]
init|;
operator|*
name|p
operator|!=
name|LIM_REG_CLASSES
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|basic_block_needs
index|[
operator|(
name|int
operator|)
operator|*
name|p
index|]
index|[
name|REG_BASIC_BLOCK
argument_list|(
name|i
argument_list|)
index|]
operator|>
literal|0
condition|)
break|break;
if|if
condition|(
operator|*
name|p
operator|==
name|LIM_REG_CLASSES
condition|)
continue|continue;
block|}
comment|/* Mark it as no longer having a hard register home.  */
name|reg_renumber
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* We will need to scan everything again.  */
name|something_changed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|global
condition|)
name|retry_global_alloc
argument_list|(
name|i
argument_list|,
name|forbidden_regs
argument_list|)
expr_stmt|;
name|alter_reg
argument_list|(
name|i
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|dumpfile
condition|)
block|{
if|if
condition|(
name|reg_renumber
index|[
name|i
index|]
operator|==
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|dumpfile
argument_list|,
literal|" Register %d now on stack.\n\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|dumpfile
argument_list|,
literal|" Register %d now in %d.\n\n"
argument_list|,
name|i
argument_list|,
name|reg_renumber
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|scratch_list_length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|scratch_list
index|[
name|i
index|]
operator|&&
name|regno
operator|>=
name|REGNO
argument_list|(
name|scratch_list
index|[
name|i
index|]
argument_list|)
operator|&&
name|regno
operator|<
name|REGNO
argument_list|(
name|scratch_list
index|[
name|i
index|]
argument_list|)
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|REGNO
argument_list|(
name|scratch_list
index|[
name|i
index|]
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|scratch_list
index|[
name|i
index|]
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|cant_eliminate
operator|&&
name|basic_block_needs
index|[
literal|0
index|]
operator|&&
operator|!
name|basic_block_needs
index|[
operator|(
name|int
operator|)
name|class
index|]
index|[
name|scratch_block
index|[
name|i
index|]
index|]
condition|)
block|{
name|enum
name|reg_class
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|reg_class_superclasses
index|[
operator|(
name|int
operator|)
name|class
index|]
init|;
operator|*
name|p
operator|!=
name|LIM_REG_CLASSES
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|basic_block_needs
index|[
operator|(
name|int
operator|)
operator|*
name|p
index|]
index|[
name|scratch_block
index|[
name|i
index|]
index|]
operator|>
literal|0
condition|)
break|break;
if|if
condition|(
operator|*
name|p
operator|==
name|LIM_REG_CLASSES
condition|)
continue|continue;
block|}
name|PUT_CODE
argument_list|(
name|scratch_list
index|[
name|i
index|]
argument_list|,
name|SCRATCH
argument_list|)
expr_stmt|;
name|scratch_list
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|something_changed
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
return|return
name|something_changed
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find all paradoxical subregs within X and update reg_max_ref_width.     Also mark any hard registers used to store user variables as    forbidden from being used for spill registers.  */
end_comment

begin_function
specifier|static
name|void
name|scan_paradoxical_subregs
parameter_list|(
name|x
parameter_list|)
specifier|register
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
if|if
condition|(
name|SMALL_REGISTER_CLASSES
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|REG_USERVAR_P
argument_list|(
name|x
argument_list|)
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|forbidden_regs
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|CONST_INT
case|:
case|case
name|CONST
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CC0
case|:
case|case
name|PC
case|:
case|case
name|USE
case|:
case|case
name|CLOBBER
case|:
return|return;
case|case
name|SUBREG
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
condition|)
name|reg_max_ref_width
index|[
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
index|]
operator|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return;
default|default:
break|break;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|scan_paradoxical_subregs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|scan_paradoxical_subregs
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|int
name|hard_reg_use_compare
parameter_list|(
name|p1p
parameter_list|,
name|p2p
parameter_list|)
specifier|const
name|GENERIC_PTR
name|p1p
decl_stmt|;
specifier|const
name|GENERIC_PTR
name|p2p
decl_stmt|;
block|{
name|struct
name|hard_reg_n_uses
modifier|*
name|p1
init|=
operator|(
expr|struct
name|hard_reg_n_uses
operator|*
operator|)
name|p1p
decl_stmt|,
modifier|*
name|p2
init|=
operator|(
expr|struct
name|hard_reg_n_uses
operator|*
operator|)
name|p2p
decl_stmt|;
name|int
name|tem
init|=
name|p1
operator|->
name|uses
operator|-
name|p2
operator|->
name|uses
decl_stmt|;
if|if
condition|(
name|tem
operator|!=
literal|0
condition|)
return|return
name|tem
return|;
comment|/* If regs are equally good, sort by regno,      so that the results of qsort leave nothing to chance.  */
return|return
name|p1
operator|->
name|regno
operator|-
name|p2
operator|->
name|regno
return|;
block|}
end_function

begin_comment
comment|/* Choose the order to consider regs for use as reload registers    based on how much trouble would be caused by spilling one.    Store them in order of decreasing preference in potential_reload_regs.  */
end_comment

begin_function
specifier|static
name|void
name|order_regs_for_reload
parameter_list|(
name|global
parameter_list|)
name|int
name|global
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|o
init|=
literal|0
decl_stmt|;
name|int
name|large
init|=
literal|0
decl_stmt|;
name|struct
name|hard_reg_n_uses
name|hard_reg_n_uses
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|bad_spill_regs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
name|potential_reload_regs
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Count number of uses of each hard reg by pseudo regs allocated to it      and then order them by decreasing use.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
name|hard_reg_n_uses
index|[
name|i
index|]
operator|.
name|uses
operator|=
literal|0
expr_stmt|;
name|hard_reg_n_uses
index|[
name|i
index|]
operator|.
name|regno
operator|=
name|i
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
block|{
name|int
name|regno
init|=
name|reg_renumber
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|regno
operator|>=
literal|0
condition|)
block|{
name|int
name|lim
init|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|PSEUDO_REGNO_MODE
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|regno
operator|<
name|lim
condition|)
block|{
comment|/* If allocated by local-alloc, show more uses since 		 we're not going to be able to reallocate it, but 		 we might if allocated by global alloc.  */
if|if
condition|(
name|global
operator|&&
name|reg_allocno
index|[
name|i
index|]
operator|<
literal|0
condition|)
name|hard_reg_n_uses
index|[
name|regno
index|]
operator|.
name|uses
operator|+=
operator|(
name|REG_N_REFS
argument_list|(
name|i
argument_list|)
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
name|hard_reg_n_uses
index|[
name|regno
operator|++
index|]
operator|.
name|uses
operator|+=
name|REG_N_REFS
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
name|large
operator|+=
name|REG_N_REFS
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* Now fixed registers (which cannot safely be used for reloading)      get a very high use count so they will be considered least desirable.      Registers used explicitly in the rtl code are almost as bad.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fixed_regs
index|[
name|i
index|]
condition|)
block|{
name|hard_reg_n_uses
index|[
name|i
index|]
operator|.
name|uses
operator|+=
literal|2
operator|*
name|large
operator|+
literal|2
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|bad_spill_regs
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regs_explicitly_used
index|[
name|i
index|]
condition|)
block|{
name|hard_reg_n_uses
index|[
name|i
index|]
operator|.
name|uses
operator|+=
name|large
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|SMALL_REGISTER_CLASSES
condition|)
comment|/* ??? We are doing this here because of the potential 	     that bad code may be generated if a register explicitly 	     used in an insn was used as a spill register for that 	     insn.  But not using these are spill registers may lose 	     on some machine.  We'll have to see how this works out.  */
name|SET_HARD_REG_BIT
argument_list|(
name|bad_spill_regs
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
name|hard_reg_n_uses
index|[
name|HARD_FRAME_POINTER_REGNUM
index|]
operator|.
name|uses
operator|+=
literal|2
operator|*
name|large
operator|+
literal|2
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|bad_spill_regs
argument_list|,
name|HARD_FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ELIMINABLE_REGS
comment|/* If registers other than the frame pointer are eliminable, mark them as      poor choices.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_ELIMINABLE_REGS
condition|;
name|i
operator|++
control|)
block|{
name|hard_reg_n_uses
index|[
name|reg_eliminate
index|[
name|i
index|]
operator|.
name|from
index|]
operator|.
name|uses
operator|+=
literal|2
operator|*
name|large
operator|+
literal|2
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|bad_spill_regs
argument_list|,
name|reg_eliminate
index|[
name|i
index|]
operator|.
name|from
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Prefer registers not so far used, for use in temporary loading.      Among them, if REG_ALLOC_ORDER is defined, use that order.      Otherwise, prefer registers not preserved by calls.  */
ifdef|#
directive|ifdef
name|REG_ALLOC_ORDER
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
name|int
name|regno
init|=
name|reg_alloc_order
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|hard_reg_n_uses
index|[
name|regno
index|]
operator|.
name|uses
operator|==
literal|0
condition|)
name|potential_reload_regs
index|[
name|o
operator|++
index|]
operator|=
name|regno
expr_stmt|;
block|}
else|#
directive|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|hard_reg_n_uses
index|[
name|i
index|]
operator|.
name|uses
operator|==
literal|0
operator|&&
name|call_used_regs
index|[
name|i
index|]
condition|)
name|potential_reload_regs
index|[
name|o
operator|++
index|]
operator|=
name|i
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|hard_reg_n_uses
index|[
name|i
index|]
operator|.
name|uses
operator|==
literal|0
operator|&&
operator|!
name|call_used_regs
index|[
name|i
index|]
condition|)
name|potential_reload_regs
index|[
name|o
operator|++
index|]
operator|=
name|i
expr_stmt|;
block|}
endif|#
directive|endif
name|qsort
argument_list|(
name|hard_reg_n_uses
argument_list|,
name|FIRST_PSEUDO_REGISTER
argument_list|,
sizeof|sizeof
name|hard_reg_n_uses
index|[
literal|0
index|]
argument_list|,
name|hard_reg_use_compare
argument_list|)
expr_stmt|;
comment|/* Now add the regs that are already used,      preferring those used less often.  The fixed and otherwise forbidden      registers will be at the end of this list.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|hard_reg_n_uses
index|[
name|i
index|]
operator|.
name|uses
operator|!=
literal|0
condition|)
name|potential_reload_regs
index|[
name|o
operator|++
index|]
operator|=
name|hard_reg_n_uses
index|[
name|i
index|]
operator|.
name|regno
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Used in reload_as_needed to sort the spilled regs.  */
end_comment

begin_function
specifier|static
name|int
name|compare_spill_regs
parameter_list|(
name|r1p
parameter_list|,
name|r2p
parameter_list|)
specifier|const
name|GENERIC_PTR
name|r1p
decl_stmt|;
specifier|const
name|GENERIC_PTR
name|r2p
decl_stmt|;
block|{
name|short
name|r1
init|=
operator|*
operator|(
name|short
operator|*
operator|)
name|r1p
decl_stmt|,
name|r2
init|=
operator|*
operator|(
name|short
operator|*
operator|)
name|r2p
decl_stmt|;
return|return
name|r1
operator|-
name|r2
return|;
block|}
end_function

begin_comment
comment|/* Reload pseudo-registers into hard regs around each insn as needed.    Additional register load insns are output before the insn that needs it    and perhaps store insns after insns that modify the reloaded pseudo reg.     reg_last_reload_reg and reg_reloaded_contents keep track of    which registers are already available in reload registers.    We update these for the reloads that we perform,    as the insns are scanned.  */
end_comment

begin_function
specifier|static
name|void
name|reload_as_needed
parameter_list|(
name|first
parameter_list|,
name|live_known
parameter_list|)
name|rtx
name|first
decl_stmt|;
name|int
name|live_known
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|this_block
init|=
literal|0
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|rtx
name|after_call
init|=
literal|0
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|spill_reg_rtx
argument_list|,
sizeof|sizeof
name|spill_reg_rtx
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|spill_reg_store
argument_list|,
sizeof|sizeof
name|spill_reg_store
argument_list|)
expr_stmt|;
name|reg_last_reload_reg
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_last_reload_reg
argument_list|,
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|reg_has_output_reload
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|max_regno
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|reg_reloaded_valid
argument_list|)
expr_stmt|;
comment|/* Reset all offsets on eliminable registers to their initial values.  */
ifdef|#
directive|ifdef
name|ELIMINABLE_REGS
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_ELIMINABLE_REGS
condition|;
name|i
operator|++
control|)
block|{
name|INITIAL_ELIMINATION_OFFSET
argument_list|(
name|reg_eliminate
index|[
name|i
index|]
operator|.
name|from
argument_list|,
name|reg_eliminate
index|[
name|i
index|]
operator|.
name|to
argument_list|,
name|reg_eliminate
index|[
name|i
index|]
operator|.
name|initial_offset
argument_list|)
expr_stmt|;
name|reg_eliminate
index|[
name|i
index|]
operator|.
name|previous_offset
operator|=
name|reg_eliminate
index|[
name|i
index|]
operator|.
name|offset
operator|=
name|reg_eliminate
index|[
name|i
index|]
operator|.
name|initial_offset
expr_stmt|;
block|}
else|#
directive|else
name|INITIAL_FRAME_POINTER_OFFSET
argument_list|(
name|reg_eliminate
index|[
literal|0
index|]
operator|.
name|initial_offset
argument_list|)
expr_stmt|;
name|reg_eliminate
index|[
literal|0
index|]
operator|.
name|previous_offset
operator|=
name|reg_eliminate
index|[
literal|0
index|]
operator|.
name|offset
operator|=
name|reg_eliminate
index|[
literal|0
index|]
operator|.
name|initial_offset
expr_stmt|;
endif|#
directive|endif
name|num_not_at_initial_offset
operator|=
literal|0
expr_stmt|;
comment|/* Order the spilled regs, so that allocate_reload_regs can guarantee to      pack registers with group needs.  */
if|if
condition|(
name|n_spills
operator|>
literal|1
condition|)
block|{
name|qsort
argument_list|(
name|spill_regs
argument_list|,
name|n_spills
argument_list|,
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|,
name|compare_spill_regs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_spills
condition|;
name|i
operator|++
control|)
name|spill_reg_order
index|[
name|spill_regs
index|[
name|i
index|]
index|]
operator|=
name|i
expr_stmt|;
block|}
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
condition|;
control|)
block|{
specifier|register
name|rtx
name|next
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* Notice when we move to a new basic block.  */
if|if
condition|(
name|live_known
operator|&&
name|this_block
operator|+
literal|1
operator|<
name|n_basic_blocks
operator|&&
name|insn
operator|==
name|basic_block_head
index|[
name|this_block
operator|+
literal|1
index|]
condition|)
operator|++
name|this_block
expr_stmt|;
comment|/* If we pass a label, copy the offsets from the label information 	 into the current offsets of each elimination.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
block|{
name|num_not_at_initial_offset
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_ELIMINABLE_REGS
condition|;
name|i
operator|++
control|)
block|{
name|reg_eliminate
index|[
name|i
index|]
operator|.
name|offset
operator|=
name|reg_eliminate
index|[
name|i
index|]
operator|.
name|previous_offset
operator|=
name|offsets_at
index|[
name|CODE_LABEL_NUMBER
argument_list|(
name|insn
argument_list|)
index|]
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|reg_eliminate
index|[
name|i
index|]
operator|.
name|can_eliminate
operator|&&
operator|(
name|reg_eliminate
index|[
name|i
index|]
operator|.
name|offset
operator|!=
name|reg_eliminate
index|[
name|i
index|]
operator|.
name|initial_offset
operator|)
condition|)
name|num_not_at_initial_offset
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
block|{
name|rtx
name|avoid_return_reg
init|=
literal|0
decl_stmt|;
name|rtx
name|oldpat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* Set avoid_return_reg if this is an insn 	     that might use the value of a function call.  */
if|if
condition|(
name|SMALL_REGISTER_CLASSES
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
name|after_call
operator|=
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
name|after_call
operator|=
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|after_call
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SMALL_REGISTER_CLASSES
operator|&&
name|after_call
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|stack_pointer_rtx
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|USE
condition|)
block|{
if|if
condition|(
name|reg_referenced_p
argument_list|(
name|after_call
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
name|avoid_return_reg
operator|=
name|after_call
expr_stmt|;
name|after_call
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If this is a USE and CLOBBER of a MEM, ensure that any 	     references to eliminable registers have been removed.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|=
name|eliminate_regs
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
comment|/* If we need to do register elimination processing, do so. 	     This might delete the insn, in which case we are done.  */
if|if
condition|(
name|num_eliminable
operator|&&
name|GET_MODE
argument_list|(
name|insn
argument_list|)
operator|==
name|QImode
condition|)
block|{
name|eliminate_regs_in_insn
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
block|{
name|insn
operator|=
name|next
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|GET_MODE
argument_list|(
name|insn
argument_list|)
operator|==
name|VOIDmode
condition|)
name|n_reloads
operator|=
literal|0
expr_stmt|;
comment|/* First find the pseudo regs that must be reloaded for this insn. 	     This info is returned in the tables reload_... (see reload.h). 	     Also modify the body of INSN by substituting RELOAD 	     rtx's for those pseudo regs.  */
else|else
block|{
name|bzero
argument_list|(
name|reg_has_output_reload
argument_list|,
name|max_regno
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|reg_is_output_reload
argument_list|)
expr_stmt|;
name|find_reloads
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|,
name|spill_indirect_levels
argument_list|,
name|live_known
argument_list|,
name|spill_reg_order
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n_reloads
operator|>
literal|0
condition|)
block|{
name|rtx
name|prev
init|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|,
name|next
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|p
decl_stmt|;
name|int
name|class
decl_stmt|;
comment|/* If this block has not had spilling done for a 		 particular clas and we have any non-optionals that need a 		 spill reg in that class, abort.  */
for|for
control|(
name|class
operator|=
literal|0
init|;
name|class
operator|<
name|N_REG_CLASSES
condition|;
name|class
operator|++
control|)
if|if
condition|(
name|basic_block_needs
index|[
name|class
index|]
operator|!=
literal|0
operator|&&
name|basic_block_needs
index|[
name|class
index|]
index|[
name|this_block
index|]
operator|==
literal|0
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_reloads
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|class
operator|==
operator|(
name|int
operator|)
name|reload_reg_class
index|[
name|i
index|]
operator|&&
name|reload_reg_rtx
index|[
name|i
index|]
operator|==
literal|0
operator|&&
operator|!
name|reload_optional
index|[
name|i
index|]
operator|&&
operator|(
name|reload_in
index|[
name|i
index|]
operator|!=
literal|0
operator|||
name|reload_out
index|[
name|i
index|]
operator|!=
literal|0
operator|||
name|reload_secondary_p
index|[
name|i
index|]
operator|!=
literal|0
operator|)
condition|)
name|fatal_insn
argument_list|(
literal|"Non-optional registers need a spill register"
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Now compute which reload regs to reload them into.  Perhaps 		 reusing reload regs from previous insns, or else output 		 load insns to reload them.  Maybe output store insns too. 		 Record the choices of reload reg in reload_reg_rtx.  */
name|choose_reload_regs
argument_list|(
name|insn
argument_list|,
name|avoid_return_reg
argument_list|)
expr_stmt|;
comment|/* Merge any reloads that we didn't combine for fear of  		 increasing the number of spill registers needed but now 		 discover can be safely merged.  */
if|if
condition|(
name|SMALL_REGISTER_CLASSES
condition|)
name|merge_assigned_reloads
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Generate the insns to reload operands into or out of 		 their reload regs.  */
name|emit_reload_insns
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Substitute the chosen reload regs from reload_reg_rtx 		 into the insn's body (or perhaps into the bodies of other 		 load and store insn that we just made for reloading 		 and that we moved the structure into).  */
name|subst_reloads
argument_list|()
expr_stmt|;
comment|/* If this was an ASM, make sure that all the reload insns 		 we have generated are valid.  If not, give an error 		 and delete them.  */
if|if
condition|(
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
for|for
control|(
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|prev
argument_list|)
init|;
name|p
operator|!=
name|next
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
if|if
condition|(
name|p
operator|!=
name|insn
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
operator|(
name|recog_memoized
argument_list|(
name|p
argument_list|)
operator|<
literal|0
operator|||
operator|(
name|insn_extract
argument_list|(
name|p
argument_list|)
operator|,
operator|!
name|constrain_operands
argument_list|(
name|INSN_CODE
argument_list|(
name|p
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|)
operator|)
condition|)
block|{
name|error_for_asm
argument_list|(
name|insn
argument_list|,
literal|"`asm' operand requires impossible reload"
argument_list|)
expr_stmt|;
name|PUT_CODE
argument_list|(
name|p
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|p
argument_list|)
operator|=
literal|0
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|p
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
block|}
block|}
comment|/* Any previously reloaded spilled pseudo reg, stored in this insn, 	     is no longer validly lying around to save a future reload. 	     Note that this does not detect pseudos that were reloaded 	     for this insn in order to be stored in 	     (obeying register constraints).  That is correct; such reload 	     registers ARE still valid.  */
name|note_stores
argument_list|(
name|oldpat
argument_list|,
name|forget_old_reloads_1
argument_list|)
expr_stmt|;
comment|/* There may have been CLOBBER insns placed after INSN.  So scan 	     between INSN and NEXT and use them to forget old reloads.  */
for|for
control|(
name|x
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
init|;
name|x
operator|!=
name|next
condition|;
name|x
operator|=
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|x
argument_list|)
argument_list|,
name|forget_old_reloads_1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
comment|/* Likewise for regs altered by auto-increment in this insn. 	     But note that the reg-notes are not changed by reloading: 	     they still contain the pseudo-regs, not the spill regs.  */
for|for
control|(
name|x
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|x
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|x
argument_list|)
operator|==
name|REG_INC
condition|)
block|{
comment|/* See if this pseudo reg was reloaded in this insn. 		   If so, its last-reload info is still valid 		   because it is based on this insn's reload.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_reloads
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reload_out
index|[
name|i
index|]
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|n_reloads
condition|)
name|forget_old_reloads_1
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
comment|/* A reload reg's contents are unknown after a label.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|CLEAR_HARD_REG_SET
argument_list|(
name|reg_reloaded_valid
argument_list|)
expr_stmt|;
comment|/* Don't assume a reload reg is still good after a call insn 	 if it is a call-used reg.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|reg_reloaded_valid
argument_list|,
name|call_used_reg_set
argument_list|)
expr_stmt|;
comment|/* In case registers overlap, allow certain insns to invalidate 	 particular hard registers.  */
ifdef|#
directive|ifdef
name|INSN_CLOBBERS_REGNO_P
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_reloaded_valid
argument_list|,
name|i
argument_list|)
operator|&&
name|INSN_CLOBBERS_REGNO_P
argument_list|(
name|insn
argument_list|,
name|i
argument_list|)
condition|)
name|CLEAR_HARD_REG_BIT
argument_list|(
name|reg_reloaded_valid
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|insn
operator|=
name|next
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_C_ALLOCA
name|alloca
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/* Discard all record of any value reloaded from X,    or reloaded in X from someplace else;    unless X is an output reload reg of the current insn.     X may be a hard reg (the reload reg)    or it may be a pseudo reg that was reloaded from.  */
end_comment

begin_function
specifier|static
name|void
name|forget_old_reloads_1
parameter_list|(
name|x
parameter_list|,
name|ignored
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|ignored
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
specifier|register
name|int
name|regno
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|nr
decl_stmt|;
comment|/* note_stores does give us subregs of hard regs.       This is a egcs-1.1 tree hack only.  A better solution is being      developed for mainline sources.  Do not import this back to the      mainline tree.       We want to strip all the SUBREGs, but also keep track of the      largest mode we encounter so that we can invalidate all the      hard regs which are needed to hold the widest mode.       This avoids a bug in choose_reload_regs (which is where the real      fix for the mainline tree will be).  */
while|while
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|>
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
condition|)
name|mode
operator|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
operator|=
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|>
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
condition|)
name|mode
operator|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
condition|)
return|return;
name|regno
operator|=
name|REGNO
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|nr
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|int
name|i
decl_stmt|;
name|nr
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* Storing into a spilled-reg invalidates its contents. 	 This can happen if a block-local pseudo is allocated to that reg 	 and it wasn't spilled because this block's total need is 0. 	 Then some insn might have an optional reload and use this reg.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nr
condition|;
name|i
operator|++
control|)
comment|/* But don't do this if the reg actually serves as an output 	   reload reg in the current instruction.  */
if|if
condition|(
name|n_reloads
operator|==
literal|0
operator|||
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_is_output_reload
argument_list|,
name|regno
operator|+
name|i
argument_list|)
condition|)
name|CLEAR_HARD_REG_BIT
argument_list|(
name|reg_reloaded_valid
argument_list|,
name|regno
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* Since value of X has changed,      forget any value previously copied from it.  */
while|while
condition|(
name|nr
operator|--
operator|>
literal|0
condition|)
comment|/* But don't forget a copy if this is the output reload        that establishes the copy's validity.  */
if|if
condition|(
name|n_reloads
operator|==
literal|0
operator|||
name|reg_has_output_reload
index|[
name|regno
operator|+
name|nr
index|]
operator|==
literal|0
condition|)
name|reg_last_reload_reg
index|[
name|regno
operator|+
name|nr
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* For each reload, the mode of the reload register.  */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|machine_mode
name|reload_mode
index|[
name|MAX_RELOADS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For each reload, the largest number of registers it will require.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|reload_nregs
index|[
name|MAX_RELOADS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Comparison function for qsort to decide which of two reloads    should be handled first.  *P1 and *P2 are the reload numbers.  */
end_comment

begin_function
specifier|static
name|int
name|reload_reg_class_lower
parameter_list|(
name|r1p
parameter_list|,
name|r2p
parameter_list|)
specifier|const
name|GENERIC_PTR
name|r1p
decl_stmt|;
specifier|const
name|GENERIC_PTR
name|r2p
decl_stmt|;
block|{
specifier|register
name|int
name|r1
init|=
operator|*
operator|(
name|short
operator|*
operator|)
name|r1p
decl_stmt|,
name|r2
init|=
operator|*
operator|(
name|short
operator|*
operator|)
name|r2p
decl_stmt|;
specifier|register
name|int
name|t
decl_stmt|;
comment|/* Consider required reloads before optional ones.  */
name|t
operator|=
name|reload_optional
index|[
name|r1
index|]
operator|-
name|reload_optional
index|[
name|r2
index|]
expr_stmt|;
if|if
condition|(
name|t
operator|!=
literal|0
condition|)
return|return
name|t
return|;
comment|/* Count all solitary classes before non-solitary ones.  */
name|t
operator|=
operator|(
operator|(
name|reg_class_size
index|[
operator|(
name|int
operator|)
name|reload_reg_class
index|[
name|r2
index|]
index|]
operator|==
literal|1
operator|)
operator|-
operator|(
name|reg_class_size
index|[
operator|(
name|int
operator|)
name|reload_reg_class
index|[
name|r1
index|]
index|]
operator|==
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
literal|0
condition|)
return|return
name|t
return|;
comment|/* Aside from solitaires, consider all multi-reg groups first.  */
name|t
operator|=
name|reload_nregs
index|[
name|r2
index|]
operator|-
name|reload_nregs
index|[
name|r1
index|]
expr_stmt|;
if|if
condition|(
name|t
operator|!=
literal|0
condition|)
return|return
name|t
return|;
comment|/* Consider reloads in order of increasing reg-class number.  */
name|t
operator|=
operator|(
name|int
operator|)
name|reload_reg_class
index|[
name|r1
index|]
operator|-
operator|(
name|int
operator|)
name|reload_reg_class
index|[
name|r2
index|]
expr_stmt|;
if|if
condition|(
name|t
operator|!=
literal|0
condition|)
return|return
name|t
return|;
comment|/* If reloads are equally urgent, sort by reload number,      so that the results of qsort leave nothing to chance.  */
return|return
name|r1
operator|-
name|r2
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The following HARD_REG_SETs indicate when each hard register is    used for a reload of various parts of the current insn.  */
end_comment

begin_comment
comment|/* If reg is in use as a reload reg for a RELOAD_OTHER reload.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|reload_reg_used
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If reg is in use for a RELOAD_FOR_INPUT_ADDRESS reload for operand I.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|reload_reg_used_in_input_addr
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If reg is in use for a RELOAD_FOR_INPADDR_ADDRESS reload for operand I.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|reload_reg_used_in_inpaddr_addr
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If reg is in use for a RELOAD_FOR_OUTPUT_ADDRESS reload for operand I.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|reload_reg_used_in_output_addr
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If reg is in use for a RELOAD_FOR_OUTADDR_ADDRESS reload for operand I.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|reload_reg_used_in_outaddr_addr
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If reg is in use for a RELOAD_FOR_INPUT reload for operand I.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|reload_reg_used_in_input
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If reg is in use for a RELOAD_FOR_OUTPUT reload for operand I.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|reload_reg_used_in_output
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If reg is in use for a RELOAD_FOR_OPERAND_ADDRESS reload.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|reload_reg_used_in_op_addr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If reg is in use for a RELOAD_FOR_OPADDR_ADDR reload.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|reload_reg_used_in_op_addr_reload
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If reg is in use for a RELOAD_FOR_INSN reload.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|reload_reg_used_in_insn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If reg is in use for a RELOAD_FOR_OTHER_ADDRESS reload.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|reload_reg_used_in_other_addr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If reg is in use as a reload reg for any sort of reload.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|reload_reg_used_at_all
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If reg is use as an inherited reload.  We just mark the first register    in the group.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|reload_reg_used_for_inherit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mark reg REGNO as in use for a reload of the sort spec'd by OPNUM and    TYPE. MODE is used to indicate how many consecutive regs are    actually used.  */
end_comment

begin_function
specifier|static
name|void
name|mark_reload_reg_in_use
parameter_list|(
name|regno
parameter_list|,
name|opnum
parameter_list|,
name|type
parameter_list|,
name|mode
parameter_list|)
name|int
name|regno
decl_stmt|;
name|int
name|opnum
decl_stmt|;
name|enum
name|reload_type
name|type
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|int
name|nregs
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|regno
init|;
name|i
operator|<
name|nregs
operator|+
name|regno
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|RELOAD_OTHER
case|:
name|SET_HARD_REG_BIT
argument_list|(
name|reload_reg_used
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_INPUT_ADDRESS
case|:
name|SET_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_input_addr
index|[
name|opnum
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_INPADDR_ADDRESS
case|:
name|SET_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_inpaddr_addr
index|[
name|opnum
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OUTPUT_ADDRESS
case|:
name|SET_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_output_addr
index|[
name|opnum
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OUTADDR_ADDRESS
case|:
name|SET_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_outaddr_addr
index|[
name|opnum
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OPERAND_ADDRESS
case|:
name|SET_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_op_addr
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OPADDR_ADDR
case|:
name|SET_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_op_addr_reload
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OTHER_ADDRESS
case|:
name|SET_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_other_addr
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_INPUT
case|:
name|SET_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_input
index|[
name|opnum
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OUTPUT
case|:
name|SET_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_output
index|[
name|opnum
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_INSN
case|:
name|SET_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_insn
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
name|SET_HARD_REG_BIT
argument_list|(
name|reload_reg_used_at_all
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Similarly, but show REGNO is no longer in use for a reload.  */
end_comment

begin_function
specifier|static
name|void
name|clear_reload_reg_in_use
parameter_list|(
name|regno
parameter_list|,
name|opnum
parameter_list|,
name|type
parameter_list|,
name|mode
parameter_list|)
name|int
name|regno
decl_stmt|;
name|int
name|opnum
decl_stmt|;
name|enum
name|reload_type
name|type
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|int
name|nregs
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|regno
init|;
name|i
operator|<
name|nregs
operator|+
name|regno
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|RELOAD_OTHER
case|:
name|CLEAR_HARD_REG_BIT
argument_list|(
name|reload_reg_used
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_INPUT_ADDRESS
case|:
name|CLEAR_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_input_addr
index|[
name|opnum
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_INPADDR_ADDRESS
case|:
name|CLEAR_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_inpaddr_addr
index|[
name|opnum
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OUTPUT_ADDRESS
case|:
name|CLEAR_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_output_addr
index|[
name|opnum
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OUTADDR_ADDRESS
case|:
name|CLEAR_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_outaddr_addr
index|[
name|opnum
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OPERAND_ADDRESS
case|:
name|CLEAR_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_op_addr
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OPADDR_ADDR
case|:
name|CLEAR_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_op_addr_reload
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OTHER_ADDRESS
case|:
name|CLEAR_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_other_addr
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_INPUT
case|:
name|CLEAR_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_input
index|[
name|opnum
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OUTPUT
case|:
name|CLEAR_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_output
index|[
name|opnum
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_INSN
case|:
name|CLEAR_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_insn
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* 1 if reg REGNO is free as a reload reg for a reload of the sort    specified by OPNUM and TYPE.  */
end_comment

begin_function
specifier|static
name|int
name|reload_reg_free_p
parameter_list|(
name|regno
parameter_list|,
name|opnum
parameter_list|,
name|type
parameter_list|)
name|int
name|regno
decl_stmt|;
name|int
name|opnum
decl_stmt|;
name|enum
name|reload_type
name|type
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/* In use for a RELOAD_OTHER means it's not available for anything.  */
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|RELOAD_OTHER
case|:
comment|/* In use for anything means we can't use it for RELOAD_OTHER.  */
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_other_addr
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_op_addr
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_insn
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reload_n_operands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_input_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_inpaddr_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_output_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_outaddr_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_input
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_output
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
case|case
name|RELOAD_FOR_INPUT
case|:
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_insn
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_op_addr
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_op_addr_reload
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If it is used for some other input, can't use it.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reload_n_operands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_input
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If it is used in a later operand's address, can't use it.  */
for|for
control|(
name|i
operator|=
name|opnum
operator|+
literal|1
init|;
name|i
operator|<
name|reload_n_operands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_input_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_inpaddr_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
case|case
name|RELOAD_FOR_INPUT_ADDRESS
case|:
comment|/* Can't use a register if it is used for an input address for this 	 operand or used as an input in an earlier one.  */
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_input_addr
index|[
name|opnum
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_inpaddr_addr
index|[
name|opnum
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|opnum
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_input
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
case|case
name|RELOAD_FOR_INPADDR_ADDRESS
case|:
comment|/* Can't use a register if it is used for an input address          for this operand or used as an input in an earlier          one.  */
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_inpaddr_addr
index|[
name|opnum
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|opnum
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_input
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
case|case
name|RELOAD_FOR_OUTPUT_ADDRESS
case|:
comment|/* Can't use a register if it is used for an output address for this 	 operand or used as an output in this or a later operand.  */
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_output_addr
index|[
name|opnum
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
name|opnum
init|;
name|i
operator|<
name|reload_n_operands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_output
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
case|case
name|RELOAD_FOR_OUTADDR_ADDRESS
case|:
comment|/* Can't use a register if it is used for an output address          for this operand or used as an output in this or a          later operand.  */
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_outaddr_addr
index|[
name|opnum
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
name|opnum
init|;
name|i
operator|<
name|reload_n_operands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_output
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
case|case
name|RELOAD_FOR_OPERAND_ADDRESS
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reload_n_operands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_input
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
operator|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_insn
argument_list|,
name|regno
argument_list|)
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_op_addr
argument_list|,
name|regno
argument_list|)
operator|)
return|;
case|case
name|RELOAD_FOR_OPADDR_ADDR
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reload_n_operands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_input
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
operator|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_op_addr_reload
argument_list|,
name|regno
argument_list|)
operator|)
return|;
case|case
name|RELOAD_FOR_OUTPUT
case|:
comment|/* This cannot share a register with RELOAD_FOR_INSN reloads, other 	 outputs, or an operand address for this or an earlier output.  */
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_insn
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reload_n_operands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_output
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|opnum
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_output_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_outaddr_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
case|case
name|RELOAD_FOR_INSN
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reload_n_operands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_input
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_output
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
operator|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_insn
argument_list|,
name|regno
argument_list|)
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_op_addr
argument_list|,
name|regno
argument_list|)
operator|)
return|;
case|case
name|RELOAD_FOR_OTHER_ADDRESS
case|:
return|return
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_other_addr
argument_list|,
name|regno
argument_list|)
return|;
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return 1 if the value in reload reg REGNO, as used by a reload    needed for the part of the insn specified by OPNUM and TYPE,    is not in use for a reload in any prior part of the insn.     We can assume that the reload reg was already tested for availability    at the time it is needed, and we should not check this again,    in case the reg has already been marked in use.  */
end_comment

begin_function
specifier|static
name|int
name|reload_reg_free_before_p
parameter_list|(
name|regno
parameter_list|,
name|opnum
parameter_list|,
name|type
parameter_list|)
name|int
name|regno
decl_stmt|;
name|int
name|opnum
decl_stmt|;
name|enum
name|reload_type
name|type
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|RELOAD_FOR_OTHER_ADDRESS
case|:
comment|/* These always come first.  */
return|return
literal|1
return|;
case|case
name|RELOAD_OTHER
case|:
return|return
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_other_addr
argument_list|,
name|regno
argument_list|)
return|;
comment|/* If this use is for part of the insn, 	 check the reg is not in use for any prior part.  It is tempting 	 to try to do this by falling through from objecs that occur 	 later in the insn to ones that occur earlier, but that will not 	 correctly take into account the fact that here we MUST ignore 	 things that would prevent the register from being allocated in 	 the first place, since we know that it was allocated.  */
case|case
name|RELOAD_FOR_OUTPUT_ADDRESS
case|:
comment|/* Earlier reloads include RELOAD_FOR_OUTADDR_ADDRESS reloads.  */
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_outaddr_addr
index|[
name|opnum
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* ... fall through ...  */
case|case
name|RELOAD_FOR_OUTADDR_ADDRESS
case|:
comment|/* Earlier reloads are for earlier outputs or their addresses, 	 any RELOAD_FOR_INSN reloads, any inputs or their addresses, or any 	 RELOAD_FOR_OTHER_ADDRESS reloads (we know it can't conflict with 	 RELOAD_OTHER)..  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|opnum
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_output_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_outaddr_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_output
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_insn
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reload_n_operands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_input_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_inpaddr_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_input
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
operator|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_other_addr
argument_list|,
name|regno
argument_list|)
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_insn
argument_list|,
name|regno
argument_list|)
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_op_addr_reload
argument_list|,
name|regno
argument_list|)
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_op_addr
argument_list|,
name|regno
argument_list|)
operator|)
return|;
case|case
name|RELOAD_FOR_OUTPUT
case|:
comment|/* There is no reason to call this function for output reloads, thus 	 anything we'd put here wouldn't be tested.  So just abort.  */
name|abort
argument_list|()
expr_stmt|;
case|case
name|RELOAD_FOR_OPERAND_ADDRESS
case|:
comment|/* Earlier reloads include RELOAD_FOR_OPADDR_ADDR reloads.  */
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_op_addr_reload
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* ... fall through ...  */
case|case
name|RELOAD_FOR_OPADDR_ADDR
case|:
case|case
name|RELOAD_FOR_INSN
case|:
comment|/* These can't conflict with inputs, or each other, so all we have to 	 test is input addresses and the addresses of OTHER items.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reload_n_operands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_input_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_inpaddr_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_other_addr
argument_list|,
name|regno
argument_list|)
return|;
case|case
name|RELOAD_FOR_INPUT
case|:
comment|/* The only things earlier are the address for this and 	 earlier inputs, other inputs (which we know we don't conflict 	 with), and addresses of RELOAD_OTHER objects.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|opnum
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_input_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_inpaddr_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_other_addr
argument_list|,
name|regno
argument_list|)
return|;
case|case
name|RELOAD_FOR_INPUT_ADDRESS
case|:
comment|/* Earlier reloads include RELOAD_FOR_INPADDR_ADDRESS reloads.  */
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_inpaddr_addr
index|[
name|opnum
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* ... fall through ...  */
case|case
name|RELOAD_FOR_INPADDR_ADDRESS
case|:
comment|/* Similarly, all we have to check is for use in earlier inputs' 	 addresses.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|opnum
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_input_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_inpaddr_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_other_addr
argument_list|,
name|regno
argument_list|)
return|;
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return 1 if the value in reload reg REGNO, as used by a reload    needed for the part of the insn specified by OPNUM and TYPE,    is still available in REGNO at the end of the insn.     We can assume that the reload reg was already tested for availability    at the time it is needed, and we should not check this again,    in case the reg has already been marked in use.  */
end_comment

begin_function
specifier|static
name|int
name|reload_reg_reaches_end_p
parameter_list|(
name|regno
parameter_list|,
name|opnum
parameter_list|,
name|type
parameter_list|)
name|int
name|regno
decl_stmt|;
name|int
name|opnum
decl_stmt|;
name|enum
name|reload_type
name|type
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|RELOAD_OTHER
case|:
comment|/* Since a RELOAD_OTHER reload claims the reg for the entire insn, 	 its value must reach the end.  */
return|return
literal|1
return|;
comment|/* If this use is for part of the insn, 	 its value reaches if no subsequent part uses the same register.  	 Just like the above function, don't try to do this with lots 	 of fallthroughs.  */
case|case
name|RELOAD_FOR_OTHER_ADDRESS
case|:
comment|/* Here we check for everything else, since these don't conflict 	 with anything else and everything comes later.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reload_n_operands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_output_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_outaddr_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_output
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_input_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_inpaddr_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_input
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
operator|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_op_addr
argument_list|,
name|regno
argument_list|)
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_insn
argument_list|,
name|regno
argument_list|)
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used
argument_list|,
name|regno
argument_list|)
operator|)
return|;
case|case
name|RELOAD_FOR_INPUT_ADDRESS
case|:
case|case
name|RELOAD_FOR_INPADDR_ADDRESS
case|:
comment|/* Similar, except that we check only for this and subsequent inputs 	 and the address of only subsequent inputs and we do not need 	 to check for RELOAD_OTHER objects since they are known not to 	 conflict.  */
for|for
control|(
name|i
operator|=
name|opnum
init|;
name|i
operator|<
name|reload_n_operands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_input
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
name|opnum
operator|+
literal|1
init|;
name|i
operator|<
name|reload_n_operands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_input_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_inpaddr_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reload_n_operands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_output_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_outaddr_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_output
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_op_addr_reload
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
operator|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_op_addr
argument_list|,
name|regno
argument_list|)
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_insn
argument_list|,
name|regno
argument_list|)
operator|)
return|;
case|case
name|RELOAD_FOR_INPUT
case|:
comment|/* Similar to input address, except we start at the next operand for 	 both input and input address and we do not check for  	 RELOAD_FOR_OPERAND_ADDRESS and RELOAD_FOR_INSN since these 	 would conflict.  */
for|for
control|(
name|i
operator|=
name|opnum
operator|+
literal|1
init|;
name|i
operator|<
name|reload_n_operands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_input_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_inpaddr_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_input
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* ... fall through ...  */
case|case
name|RELOAD_FOR_OPERAND_ADDRESS
case|:
comment|/* Check outputs and their addresses.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reload_n_operands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_output_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_outaddr_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_output
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
case|case
name|RELOAD_FOR_OPADDR_ADDR
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reload_n_operands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_output_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_outaddr_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_output
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
operator|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_op_addr
argument_list|,
name|regno
argument_list|)
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_insn
argument_list|,
name|regno
argument_list|)
operator|)
return|;
case|case
name|RELOAD_FOR_INSN
case|:
comment|/* These conflict with other outputs with RELOAD_OTHER.  So 	 we need only check for output addresses.  */
name|opnum
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* ... fall through ...  */
case|case
name|RELOAD_FOR_OUTPUT
case|:
case|case
name|RELOAD_FOR_OUTPUT_ADDRESS
case|:
case|case
name|RELOAD_FOR_OUTADDR_ADDRESS
case|:
comment|/* We already know these can't conflict with a later output.  So the 	 only thing to check are later output addresses.  */
for|for
control|(
name|i
operator|=
name|opnum
operator|+
literal|1
init|;
name|i
operator|<
name|reload_n_operands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_output_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_in_outaddr_addr
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if the reloads denoted by R1 and R2 cannot share a register.    Return 0 otherwise.     This function uses the same algorithm as reload_reg_free_p above.  */
end_comment

begin_function
name|int
name|reloads_conflict
parameter_list|(
name|r1
parameter_list|,
name|r2
parameter_list|)
name|int
name|r1
decl_stmt|,
name|r2
decl_stmt|;
block|{
name|enum
name|reload_type
name|r1_type
init|=
name|reload_when_needed
index|[
name|r1
index|]
decl_stmt|;
name|enum
name|reload_type
name|r2_type
init|=
name|reload_when_needed
index|[
name|r2
index|]
decl_stmt|;
name|int
name|r1_opnum
init|=
name|reload_opnum
index|[
name|r1
index|]
decl_stmt|;
name|int
name|r2_opnum
init|=
name|reload_opnum
index|[
name|r2
index|]
decl_stmt|;
comment|/* RELOAD_OTHER conflicts with everything.  */
if|if
condition|(
name|r2_type
operator|==
name|RELOAD_OTHER
condition|)
return|return
literal|1
return|;
comment|/* Otherwise, check conflicts differently for each type.  */
switch|switch
condition|(
name|r1_type
condition|)
block|{
case|case
name|RELOAD_FOR_INPUT
case|:
return|return
operator|(
name|r2_type
operator|==
name|RELOAD_FOR_INSN
operator|||
name|r2_type
operator|==
name|RELOAD_FOR_OPERAND_ADDRESS
operator|||
name|r2_type
operator|==
name|RELOAD_FOR_OPADDR_ADDR
operator|||
name|r2_type
operator|==
name|RELOAD_FOR_INPUT
operator|||
operator|(
operator|(
name|r2_type
operator|==
name|RELOAD_FOR_INPUT_ADDRESS
operator|||
name|r2_type
operator|==
name|RELOAD_FOR_INPADDR_ADDRESS
operator|)
operator|&&
name|r2_opnum
operator|>
name|r1_opnum
operator|)
operator|)
return|;
case|case
name|RELOAD_FOR_INPUT_ADDRESS
case|:
return|return
operator|(
operator|(
name|r2_type
operator|==
name|RELOAD_FOR_INPUT_ADDRESS
operator|&&
name|r1_opnum
operator|==
name|r2_opnum
operator|)
operator|||
operator|(
name|r2_type
operator|==
name|RELOAD_FOR_INPUT
operator|&&
name|r2_opnum
operator|<
name|r1_opnum
operator|)
operator|)
return|;
case|case
name|RELOAD_FOR_INPADDR_ADDRESS
case|:
return|return
operator|(
operator|(
name|r2_type
operator|==
name|RELOAD_FOR_INPADDR_ADDRESS
operator|&&
name|r1_opnum
operator|==
name|r2_opnum
operator|)
operator|||
operator|(
name|r2_type
operator|==
name|RELOAD_FOR_INPUT
operator|&&
name|r2_opnum
operator|<
name|r1_opnum
operator|)
operator|)
return|;
case|case
name|RELOAD_FOR_OUTPUT_ADDRESS
case|:
return|return
operator|(
operator|(
name|r2_type
operator|==
name|RELOAD_FOR_OUTPUT_ADDRESS
operator|&&
name|r2_opnum
operator|==
name|r1_opnum
operator|)
operator|||
operator|(
name|r2_type
operator|==
name|RELOAD_FOR_OUTPUT
operator|&&
name|r2_opnum
operator|>=
name|r1_opnum
operator|)
operator|)
return|;
case|case
name|RELOAD_FOR_OUTADDR_ADDRESS
case|:
return|return
operator|(
operator|(
name|r2_type
operator|==
name|RELOAD_FOR_OUTADDR_ADDRESS
operator|&&
name|r2_opnum
operator|==
name|r1_opnum
operator|)
operator|||
operator|(
name|r2_type
operator|==
name|RELOAD_FOR_OUTPUT
operator|&&
name|r2_opnum
operator|>=
name|r1_opnum
operator|)
operator|)
return|;
case|case
name|RELOAD_FOR_OPERAND_ADDRESS
case|:
return|return
operator|(
name|r2_type
operator|==
name|RELOAD_FOR_INPUT
operator|||
name|r2_type
operator|==
name|RELOAD_FOR_INSN
operator|||
name|r2_type
operator|==
name|RELOAD_FOR_OPERAND_ADDRESS
operator|)
return|;
case|case
name|RELOAD_FOR_OPADDR_ADDR
case|:
return|return
operator|(
name|r2_type
operator|==
name|RELOAD_FOR_INPUT
operator|||
name|r2_type
operator|==
name|RELOAD_FOR_OPADDR_ADDR
operator|)
return|;
case|case
name|RELOAD_FOR_OUTPUT
case|:
return|return
operator|(
name|r2_type
operator|==
name|RELOAD_FOR_INSN
operator|||
name|r2_type
operator|==
name|RELOAD_FOR_OUTPUT
operator|||
operator|(
operator|(
name|r2_type
operator|==
name|RELOAD_FOR_OUTPUT_ADDRESS
operator|||
name|r2_type
operator|==
name|RELOAD_FOR_OUTADDR_ADDRESS
operator|)
operator|&&
name|r2_opnum
operator|>=
name|r1_opnum
operator|)
operator|)
return|;
case|case
name|RELOAD_FOR_INSN
case|:
return|return
operator|(
name|r2_type
operator|==
name|RELOAD_FOR_INPUT
operator|||
name|r2_type
operator|==
name|RELOAD_FOR_OUTPUT
operator|||
name|r2_type
operator|==
name|RELOAD_FOR_INSN
operator|||
name|r2_type
operator|==
name|RELOAD_FOR_OPERAND_ADDRESS
operator|)
return|;
case|case
name|RELOAD_FOR_OTHER_ADDRESS
case|:
return|return
name|r2_type
operator|==
name|RELOAD_FOR_OTHER_ADDRESS
return|;
case|case
name|RELOAD_OTHER
case|:
return|return
literal|1
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Vector of reload-numbers showing the order in which the reloads should    be processed.  */
end_comment

begin_decl_stmt
name|short
name|reload_order
index|[
name|MAX_RELOADS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by reload number, 1 if incoming value    inherited from previous insns.  */
end_comment

begin_decl_stmt
name|char
name|reload_inherited
index|[
name|MAX_RELOADS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For an inherited reload, this is the insn the reload was inherited from,    if we know it.  Otherwise, this is 0.  */
end_comment

begin_decl_stmt
name|rtx
name|reload_inheritance_insn
index|[
name|MAX_RELOADS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If non-zero, this is a place to get the value of the reload,    rather than using reload_in.  */
end_comment

begin_decl_stmt
name|rtx
name|reload_override_in
index|[
name|MAX_RELOADS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For each reload, the hard register number of the register used,    or -1 if we did not need a register for this reload.  */
end_comment

begin_decl_stmt
name|int
name|reload_spill_index
index|[
name|MAX_RELOADS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return 1 if the value in reload reg REGNO, as used by a reload    needed for the part of the insn specified by OPNUM and TYPE,    may be used to load VALUE into it.     Other read-only reloads with the same value do not conflict    unless OUT is non-zero and these other reloads have to live while    output reloads live.     RELOADNUM is the number of the reload we want to load this value for;    a reload does not conflict with itself.     The caller has to make sure that there is no conflict with the return    register.  */
end_comment

begin_function
specifier|static
name|int
name|reload_reg_free_for_value_p
parameter_list|(
name|regno
parameter_list|,
name|opnum
parameter_list|,
name|type
parameter_list|,
name|value
parameter_list|,
name|out
parameter_list|,
name|reloadnum
parameter_list|)
name|int
name|regno
decl_stmt|;
name|int
name|opnum
decl_stmt|;
name|enum
name|reload_type
name|type
decl_stmt|;
name|rtx
name|value
decl_stmt|,
name|out
decl_stmt|;
name|int
name|reloadnum
decl_stmt|;
block|{
name|int
name|time1
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* We use some pseudo 'time' value to check if the lifetimes of the      new register use would overlap with the one of a previous reload      that is not read-only or uses a different value.      The 'time' used doesn't have to be linear in any shape or form, just      monotonic.      Some reload types use different 'buckets' for each operand.      So there are MAX_RECOG_OPERANDS different time values for each      such reload type.      We compute TIME1 as the time when the register for the prospective      new reload ceases to be live, and TIME2 for each existing      reload as the time when that the reload register of that reload      becomes live.      Where there is little to be gained by exact lifetime calculations,      we just make conservative assumptions, i.e. a longer lifetime;      this is done in the 'default:' cases.  */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|RELOAD_FOR_OTHER_ADDRESS
case|:
name|time1
operator|=
literal|0
expr_stmt|;
break|break;
comment|/* For each input, we might have a sequence of RELOAD_FOR_INPADDR_ADDRESS,        RELOAD_FOR_INPUT_ADDRESS and RELOAD_FOR_INPUT.  By adding 0 / 1 / 2 ,        respectively, to the time values for these, we get distinct time        values.  To get distinct time values for each operand, we have to        multiply opnum by at least three.  We round that up to four because        multiply by four is often cheaper.  */
case|case
name|RELOAD_FOR_INPADDR_ADDRESS
case|:
name|time1
operator|=
name|opnum
operator|*
literal|4
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_INPUT_ADDRESS
case|:
name|time1
operator|=
name|opnum
operator|*
literal|4
operator|+
literal|2
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_INPUT
case|:
comment|/* All RELOAD_FOR_INPUT reloads remain live till just before the 	 instruction is executed.  */
name|time1
operator|=
operator|(
name|MAX_RECOG_OPERANDS
operator|-
literal|1
operator|)
operator|*
literal|4
operator|+
literal|3
expr_stmt|;
break|break;
comment|/* opnum * 4 + 3< opnum * 4 + 4<= (MAX_RECOG_OPERANDS - 1) * 4 + 4 == MAX_RECOG_OPERANDS * 4 */
case|case
name|RELOAD_FOR_OUTPUT_ADDRESS
case|:
name|time1
operator|=
name|MAX_RECOG_OPERANDS
operator|*
literal|4
operator|+
name|opnum
expr_stmt|;
break|break;
default|default:
name|time1
operator|=
name|MAX_RECOG_OPERANDS
operator|*
literal|5
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_reloads
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|reg
init|=
name|reload_reg_rtx
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|reg
operator|&&
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|REG
operator|&&
operator|(
operator|(
name|unsigned
operator|)
name|regno
operator|-
name|true_regnum
argument_list|(
name|reg
argument_list|)
operator|<=
name|HARD_REGNO_NREGS
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|-
operator|(
name|unsigned
operator|)
literal|1
operator|)
operator|&&
name|i
operator|!=
name|reloadnum
condition|)
block|{
if|if
condition|(
name|out
operator|&&
name|reload_when_needed
index|[
name|i
index|]
operator|!=
name|RELOAD_FOR_INPUT
operator|&&
name|reload_when_needed
index|[
name|i
index|]
operator|!=
name|RELOAD_FOR_INPUT_ADDRESS
operator|&&
name|reload_when_needed
index|[
name|i
index|]
operator|!=
name|RELOAD_FOR_INPADDR_ADDRESS
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|reload_in
index|[
name|i
index|]
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|reload_in
index|[
name|i
index|]
argument_list|,
name|value
argument_list|)
operator|||
name|reload_out
index|[
name|i
index|]
condition|)
block|{
name|int
name|time2
decl_stmt|;
switch|switch
condition|(
name|reload_when_needed
index|[
name|i
index|]
condition|)
block|{
case|case
name|RELOAD_FOR_OTHER_ADDRESS
case|:
name|time2
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_INPADDR_ADDRESS
case|:
name|time2
operator|=
name|reload_opnum
index|[
name|i
index|]
operator|*
literal|4
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_INPUT_ADDRESS
case|:
name|time2
operator|=
name|reload_opnum
index|[
name|i
index|]
operator|*
literal|4
operator|+
literal|2
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_INPUT
case|:
name|time2
operator|=
name|reload_opnum
index|[
name|i
index|]
operator|*
literal|4
operator|+
literal|3
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OUTPUT
case|:
comment|/* All RELOAD_FOR_OUTPUT reloads become live just after the 		   instruction is executed.  */
name|time2
operator|=
name|MAX_RECOG_OPERANDS
operator|*
literal|4
expr_stmt|;
break|break;
comment|/* The first RELOAD_FOR_OUTPUT_ADDRESS reload conflicts with the 		   RELOAD_FOR_OUTPUT reloads, so assign it the same time value.  */
case|case
name|RELOAD_FOR_OUTPUT_ADDRESS
case|:
name|time2
operator|=
name|MAX_RECOG_OPERANDS
operator|*
literal|4
operator|+
name|reload_opnum
index|[
name|i
index|]
expr_stmt|;
break|break;
case|case
name|RELOAD_OTHER
case|:
if|if
condition|(
operator|!
name|reload_in
index|[
name|i
index|]
operator|||
name|rtx_equal_p
argument_list|(
name|reload_in
index|[
name|i
index|]
argument_list|,
name|value
argument_list|)
condition|)
block|{
name|time2
operator|=
name|MAX_RECOG_OPERANDS
operator|*
literal|4
expr_stmt|;
break|break;
block|}
default|default:
name|time2
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|time1
operator|>=
name|time2
condition|)
return|return
literal|0
return|;
block|}
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Find a spill register to use as a reload register for reload R.    LAST_RELOAD is non-zero if this is the last reload for the insn being    processed.     Set reload_reg_rtx[R] to the register allocated.     If NOERROR is nonzero, we return 1 if successful,    or 0 if we couldn't find a spill reg and we didn't change anything.  */
end_comment

begin_function
specifier|static
name|int
name|allocate_reload_reg
parameter_list|(
name|r
parameter_list|,
name|insn
parameter_list|,
name|last_reload
parameter_list|,
name|noerror
parameter_list|)
name|int
name|r
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|last_reload
decl_stmt|;
name|int
name|noerror
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|pass
decl_stmt|;
name|int
name|count
decl_stmt|;
name|rtx
name|new
decl_stmt|;
name|int
name|regno
decl_stmt|;
comment|/* If we put this reload ahead, thinking it is a group,      then insist on finding a group.  Otherwise we can grab a      reg that some other reload needs.      (That can happen when we have a 68000 DATA_OR_FP_REG      which is a group of data regs or one fp reg.)      We need not be so restrictive if there are no more reloads      for this insn.       ??? Really it would be nicer to have smarter handling      for that kind of reg class, where a problem like this is normal.      Perhaps those classes should be avoided for reloading      by use of more alternatives.  */
name|int
name|force_group
init|=
name|reload_nregs
index|[
name|r
index|]
operator|>
literal|1
operator|&&
operator|!
name|last_reload
decl_stmt|;
comment|/* If we want a single register and haven't yet found one,      take any reg in the right class and not in use.      If we want a consecutive group, here is where we look for it.       We use two passes so we can first look for reload regs to      reuse, which are already in use for other reloads in this insn,      and only then use additional registers.      I think that maximizing reuse is needed to make sure we don't      run out of reload regs.  Suppose we have three reloads, and      reloads A and B can share regs.  These need two regs.      Suppose A and B are given different regs.      That leaves none for C.  */
for|for
control|(
name|pass
operator|=
literal|0
init|;
name|pass
operator|<
literal|2
condition|;
name|pass
operator|++
control|)
block|{
comment|/* I is the index in spill_regs. 	 We advance it round-robin between insns to use all spill regs 	 equally, so that inherited reloads have a chance 	 of leapfrogging each other.  Don't do this, however, when we have 	 group needs and failure would be fatal; if we only have a relatively 	 small number of spill registers, and more than one of them has 	 group needs, then by starting in the middle, we may end up  	 allocating the first one in such a way that we are not left with 	 sufficient groups to handle the rest.  */
if|if
condition|(
name|noerror
operator|||
operator|!
name|force_group
condition|)
name|i
operator|=
name|last_spill_reg
expr_stmt|;
else|else
name|i
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|n_spills
condition|;
name|count
operator|++
control|)
block|{
name|int
name|class
init|=
operator|(
name|int
operator|)
name|reload_reg_class
index|[
name|r
index|]
decl_stmt|;
name|i
operator|=
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
name|n_spills
expr_stmt|;
if|if
condition|(
operator|(
name|reload_reg_free_p
argument_list|(
name|spill_regs
index|[
name|i
index|]
argument_list|,
name|reload_opnum
index|[
name|r
index|]
argument_list|,
name|reload_when_needed
index|[
name|r
index|]
argument_list|)
operator|||
operator|(
name|reload_in
index|[
name|r
index|]
comment|/* We check reload_reg_used to make sure we 			 don't clobber the return register.  */
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used
argument_list|,
name|spill_regs
index|[
name|i
index|]
argument_list|)
operator|&&
name|reload_reg_free_for_value_p
argument_list|(
name|spill_regs
index|[
name|i
index|]
argument_list|,
name|reload_opnum
index|[
name|r
index|]
argument_list|,
name|reload_when_needed
index|[
name|r
index|]
argument_list|,
name|reload_in
index|[
name|r
index|]
argument_list|,
name|reload_out
index|[
name|r
index|]
argument_list|,
name|r
argument_list|)
operator|)
operator|)
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|class
index|]
argument_list|,
name|spill_regs
index|[
name|i
index|]
argument_list|)
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|spill_regs
index|[
name|i
index|]
argument_list|,
name|reload_mode
index|[
name|r
index|]
argument_list|)
comment|/* Look first for regs to share, then for unshared.  But 		 don't share regs used for inherited reloads; they are 		 the ones we want to preserve.  */
operator|&&
operator|(
name|pass
operator|||
operator|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_at_all
argument_list|,
name|spill_regs
index|[
name|i
index|]
argument_list|)
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_for_inherit
argument_list|,
name|spill_regs
index|[
name|i
index|]
argument_list|)
operator|)
operator|)
condition|)
block|{
name|int
name|nr
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|spill_regs
index|[
name|i
index|]
argument_list|,
name|reload_mode
index|[
name|r
index|]
argument_list|)
decl_stmt|;
comment|/* Avoid the problem where spilling a GENERAL_OR_FP_REG 		 (on 68000) got us two FP regs.  If NR is 1, 		 we would reject both of them.  */
if|if
condition|(
name|force_group
condition|)
name|nr
operator|=
name|CLASS_MAX_NREGS
argument_list|(
name|reload_reg_class
index|[
name|r
index|]
argument_list|,
name|reload_mode
index|[
name|r
index|]
argument_list|)
expr_stmt|;
comment|/* If we need only one reg, we have already won.  */
if|if
condition|(
name|nr
operator|==
literal|1
condition|)
block|{
comment|/* But reject a single reg if we demand a group.  */
if|if
condition|(
name|force_group
condition|)
continue|continue;
break|break;
block|}
comment|/* Otherwise check that as many consecutive regs as we need 		 are available here. 		 Also, don't use for a group registers that are 		 needed for nongroups.  */
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|counted_for_nongroups
argument_list|,
name|spill_regs
index|[
name|i
index|]
argument_list|)
condition|)
while|while
condition|(
name|nr
operator|>
literal|1
condition|)
block|{
name|regno
operator|=
name|spill_regs
index|[
name|i
index|]
operator|+
name|nr
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|class
index|]
argument_list|,
name|regno
argument_list|)
operator|&&
name|spill_reg_order
index|[
name|regno
index|]
operator|>=
literal|0
operator|&&
name|reload_reg_free_p
argument_list|(
name|regno
argument_list|,
name|reload_opnum
index|[
name|r
index|]
argument_list|,
name|reload_when_needed
index|[
name|r
index|]
argument_list|)
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|counted_for_nongroups
argument_list|,
name|regno
argument_list|)
operator|)
condition|)
break|break;
name|nr
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|nr
operator|==
literal|1
condition|)
break|break;
block|}
block|}
comment|/* If we found something on pass 1, omit pass 2.  */
if|if
condition|(
name|count
operator|<
name|n_spills
condition|)
break|break;
block|}
comment|/* We should have found a spill register by now.  */
if|if
condition|(
name|count
operator|==
name|n_spills
condition|)
block|{
if|if
condition|(
name|noerror
condition|)
return|return
literal|0
return|;
goto|goto
name|failure
goto|;
block|}
comment|/* I is the index in SPILL_REG_RTX of the reload register we are to      allocate.  Get an rtx for it and find its register number.  */
name|new
operator|=
name|spill_reg_rtx
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|new
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|new
argument_list|)
operator|!=
name|reload_mode
index|[
name|r
index|]
condition|)
name|spill_reg_rtx
index|[
name|i
index|]
operator|=
name|new
operator|=
name|gen_rtx_REG
argument_list|(
name|reload_mode
index|[
name|r
index|]
argument_list|,
name|spill_regs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|regno
operator|=
name|true_regnum
argument_list|(
name|new
argument_list|)
expr_stmt|;
comment|/* Detect when the reload reg can't hold the reload mode.      This used to be one `if', but Sequent compiler can't handle that.  */
if|if
condition|(
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|reload_mode
index|[
name|r
index|]
argument_list|)
condition|)
block|{
name|enum
name|machine_mode
name|test_mode
init|=
name|VOIDmode
decl_stmt|;
if|if
condition|(
name|reload_in
index|[
name|r
index|]
condition|)
name|test_mode
operator|=
name|GET_MODE
argument_list|(
name|reload_in
index|[
name|r
index|]
argument_list|)
expr_stmt|;
comment|/* If reload_in[r] has VOIDmode, it means we will load it 	 in whatever mode the reload reg has: to wit, reload_mode[r]. 	 We have already tested that for validity.  */
comment|/* Aside from that, we need to test that the expressions 	 to reload from or into have modes which are valid for this 	 reload register.  Otherwise the reload insns would be invalid.  */
if|if
condition|(
operator|!
operator|(
name|reload_in
index|[
name|r
index|]
operator|!=
literal|0
operator|&&
name|test_mode
operator|!=
name|VOIDmode
operator|&&
operator|!
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|test_mode
argument_list|)
operator|)
condition|)
if|if
condition|(
operator|!
operator|(
name|reload_out
index|[
name|r
index|]
operator|!=
literal|0
operator|&&
operator|!
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|reload_out
index|[
name|r
index|]
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/* The reg is OK.  */
name|last_spill_reg
operator|=
name|i
expr_stmt|;
comment|/* Mark as in use for this insn the reload regs we use 	       for this.  */
name|mark_reload_reg_in_use
argument_list|(
name|spill_regs
index|[
name|i
index|]
argument_list|,
name|reload_opnum
index|[
name|r
index|]
argument_list|,
name|reload_when_needed
index|[
name|r
index|]
argument_list|,
name|reload_mode
index|[
name|r
index|]
argument_list|)
expr_stmt|;
name|reload_reg_rtx
index|[
name|r
index|]
operator|=
name|new
expr_stmt|;
name|reload_spill_index
index|[
name|r
index|]
operator|=
name|spill_regs
index|[
name|i
index|]
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
comment|/* The reg is not OK.  */
if|if
condition|(
name|noerror
condition|)
return|return
literal|0
return|;
name|failure
label|:
if|if
condition|(
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
comment|/* It's the compiler's fault.  */
name|fatal_insn
argument_list|(
literal|"Could not find a spill register"
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* It's the user's fault; the operand's mode and constraint      don't match.  Disable this reload so we don't crash in final.  */
name|error_for_asm
argument_list|(
name|insn
argument_list|,
literal|"`asm' operand constraint incompatible with operand size"
argument_list|)
expr_stmt|;
name|reload_in
index|[
name|r
index|]
operator|=
literal|0
expr_stmt|;
name|reload_out
index|[
name|r
index|]
operator|=
literal|0
expr_stmt|;
name|reload_reg_rtx
index|[
name|r
index|]
operator|=
literal|0
expr_stmt|;
name|reload_optional
index|[
name|r
index|]
operator|=
literal|1
expr_stmt|;
name|reload_secondary_p
index|[
name|r
index|]
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Assign hard reg targets for the pseudo-registers we must reload    into hard regs for this insn.    Also output the instructions to copy them in and out of the hard regs.     For machines with register classes, we are responsible for    finding a reload reg in the proper class.  */
end_comment

begin_function
specifier|static
name|void
name|choose_reload_regs
parameter_list|(
name|insn
parameter_list|,
name|avoid_return_reg
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|avoid_return_reg
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|max_group_size
init|=
literal|1
decl_stmt|;
name|enum
name|reg_class
name|group_class
init|=
name|NO_REGS
decl_stmt|;
name|int
name|inheritance
decl_stmt|;
name|rtx
name|save_reload_reg_rtx
index|[
name|MAX_RELOADS
index|]
decl_stmt|;
name|char
name|save_reload_inherited
index|[
name|MAX_RELOADS
index|]
decl_stmt|;
name|rtx
name|save_reload_inheritance_insn
index|[
name|MAX_RELOADS
index|]
decl_stmt|;
name|rtx
name|save_reload_override_in
index|[
name|MAX_RELOADS
index|]
decl_stmt|;
name|int
name|save_reload_spill_index
index|[
name|MAX_RELOADS
index|]
decl_stmt|;
name|HARD_REG_SET
name|save_reload_reg_used
decl_stmt|;
name|HARD_REG_SET
name|save_reload_reg_used_in_input_addr
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|HARD_REG_SET
name|save_reload_reg_used_in_inpaddr_addr
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|HARD_REG_SET
name|save_reload_reg_used_in_output_addr
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|HARD_REG_SET
name|save_reload_reg_used_in_outaddr_addr
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|HARD_REG_SET
name|save_reload_reg_used_in_input
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|HARD_REG_SET
name|save_reload_reg_used_in_output
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|HARD_REG_SET
name|save_reload_reg_used_in_op_addr
decl_stmt|;
name|HARD_REG_SET
name|save_reload_reg_used_in_op_addr_reload
decl_stmt|;
name|HARD_REG_SET
name|save_reload_reg_used_in_insn
decl_stmt|;
name|HARD_REG_SET
name|save_reload_reg_used_in_other_addr
decl_stmt|;
name|HARD_REG_SET
name|save_reload_reg_used_at_all
decl_stmt|;
name|bzero
argument_list|(
name|reload_inherited
argument_list|,
name|MAX_RELOADS
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reload_inheritance_insn
argument_list|,
name|MAX_RELOADS
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reload_override_in
argument_list|,
name|MAX_RELOADS
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|reload_reg_used
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|reload_reg_used_at_all
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|reload_reg_used_in_op_addr
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|reload_reg_used_in_op_addr_reload
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|reload_reg_used_in_insn
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|reload_reg_used_in_other_addr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reload_n_operands
condition|;
name|i
operator|++
control|)
block|{
name|CLEAR_HARD_REG_SET
argument_list|(
name|reload_reg_used_in_output
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|reload_reg_used_in_input
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|reload_reg_used_in_input_addr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|reload_reg_used_in_inpaddr_addr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|reload_reg_used_in_output_addr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|reload_reg_used_in_outaddr_addr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Don't bother with avoiding the return reg      if we have no mandatory reload that could use it.  */
if|if
condition|(
name|SMALL_REGISTER_CLASSES
operator|&&
name|avoid_return_reg
condition|)
block|{
name|int
name|do_avoid
init|=
literal|0
decl_stmt|;
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|avoid_return_reg
argument_list|)
decl_stmt|;
name|int
name|nregs
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|avoid_return_reg
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|r
decl_stmt|;
for|for
control|(
name|r
operator|=
name|regno
init|;
name|r
operator|<
name|regno
operator|+
name|nregs
condition|;
name|r
operator|++
control|)
if|if
condition|(
name|spill_reg_order
index|[
name|r
index|]
operator|>=
literal|0
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_reloads
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|reload_optional
index|[
name|j
index|]
operator|&&
name|reload_reg_rtx
index|[
name|j
index|]
operator|==
literal|0
operator|&&
operator|(
name|reload_in
index|[
name|j
index|]
operator|!=
literal|0
operator|||
name|reload_out
index|[
name|j
index|]
operator|!=
literal|0
operator|||
name|reload_secondary_p
index|[
name|j
index|]
operator|)
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|reload_reg_class
index|[
name|j
index|]
index|]
argument_list|,
name|r
argument_list|)
condition|)
name|do_avoid
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|do_avoid
condition|)
name|avoid_return_reg
operator|=
literal|0
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* Not needed, now that we can always retry without inheritance.  */
comment|/* See if we have more mandatory reloads than spill regs.      If so, then we cannot risk optimizations that could prevent      reloads from sharing one spill register.       Since we will try finding a better register than reload_reg_rtx      unless it is equal to reload_in or reload_out, count such reloads.  */
block|{     int tem = SMALL_REGISTER_CLASSES? (avoid_return_reg != 0): 0;     for (j = 0; j< n_reloads; j++)       if (! reload_optional[j]&& (reload_in[j] != 0 || reload_out[j] != 0 || reload_secondary_p[j])&& (reload_reg_rtx[j] == 0 	      || (! rtx_equal_p (reload_reg_rtx[j], reload_in[j])&& ! rtx_equal_p (reload_reg_rtx[j], reload_out[j])))) 	tem++;     if (tem> n_spills)       must_reuse = 1;   }
endif|#
directive|endif
comment|/* Don't use the subroutine call return reg for a reload      if we are supposed to avoid it.  */
if|if
condition|(
name|SMALL_REGISTER_CLASSES
operator|&&
name|avoid_return_reg
condition|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|avoid_return_reg
argument_list|)
decl_stmt|;
name|int
name|nregs
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|avoid_return_reg
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|r
decl_stmt|;
for|for
control|(
name|r
operator|=
name|regno
init|;
name|r
operator|<
name|regno
operator|+
name|nregs
condition|;
name|r
operator|++
control|)
if|if
condition|(
name|spill_reg_order
index|[
name|r
index|]
operator|>=
literal|0
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|reload_reg_used
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
comment|/* In order to be certain of getting the registers we need,      we must sort the reloads into order of increasing register class.      Then our grabbing of reload registers will parallel the process      that provided the reload registers.       Also note whether any of the reloads wants a consecutive group of regs.      If so, record the maximum size of the group desired and what      register class contains all the groups needed by this insn.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_reloads
condition|;
name|j
operator|++
control|)
block|{
name|reload_order
index|[
name|j
index|]
operator|=
name|j
expr_stmt|;
name|reload_spill_index
index|[
name|j
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|reload_mode
index|[
name|j
index|]
operator|=
operator|(
name|reload_inmode
index|[
name|j
index|]
operator|==
name|VOIDmode
operator|||
operator|(
name|GET_MODE_SIZE
argument_list|(
name|reload_outmode
index|[
name|j
index|]
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|reload_inmode
index|[
name|j
index|]
argument_list|)
operator|)
operator|)
condition|?
name|reload_outmode
index|[
name|j
index|]
else|:
name|reload_inmode
index|[
name|j
index|]
expr_stmt|;
name|reload_nregs
index|[
name|j
index|]
operator|=
name|CLASS_MAX_NREGS
argument_list|(
name|reload_reg_class
index|[
name|j
index|]
argument_list|,
name|reload_mode
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|reload_nregs
index|[
name|j
index|]
operator|>
literal|1
condition|)
block|{
name|max_group_size
operator|=
name|MAX
argument_list|(
name|reload_nregs
index|[
name|j
index|]
argument_list|,
name|max_group_size
argument_list|)
expr_stmt|;
name|group_class
operator|=
name|reg_class_superunion
index|[
operator|(
name|int
operator|)
name|reload_reg_class
index|[
name|j
index|]
index|]
index|[
operator|(
name|int
operator|)
name|group_class
index|]
expr_stmt|;
block|}
comment|/* If we have already decided to use a certain register, 	 don't use it in another way.  */
if|if
condition|(
name|reload_reg_rtx
index|[
name|j
index|]
condition|)
name|mark_reload_reg_in_use
argument_list|(
name|REGNO
argument_list|(
name|reload_reg_rtx
index|[
name|j
index|]
argument_list|)
argument_list|,
name|reload_opnum
index|[
name|j
index|]
argument_list|,
name|reload_when_needed
index|[
name|j
index|]
argument_list|,
name|reload_mode
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n_reloads
operator|>
literal|1
condition|)
name|qsort
argument_list|(
name|reload_order
argument_list|,
name|n_reloads
argument_list|,
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|,
name|reload_reg_class_lower
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reload_reg_rtx
argument_list|,
operator|(
name|char
operator|*
operator|)
name|save_reload_reg_rtx
argument_list|,
sizeof|sizeof
name|reload_reg_rtx
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|reload_inherited
argument_list|,
name|save_reload_inherited
argument_list|,
sizeof|sizeof
name|reload_inherited
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reload_inheritance_insn
argument_list|,
operator|(
name|char
operator|*
operator|)
name|save_reload_inheritance_insn
argument_list|,
sizeof|sizeof
name|reload_inheritance_insn
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reload_override_in
argument_list|,
operator|(
name|char
operator|*
operator|)
name|save_reload_override_in
argument_list|,
sizeof|sizeof
name|reload_override_in
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reload_spill_index
argument_list|,
operator|(
name|char
operator|*
operator|)
name|save_reload_spill_index
argument_list|,
sizeof|sizeof
name|reload_spill_index
argument_list|)
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|save_reload_reg_used
argument_list|,
name|reload_reg_used
argument_list|)
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|save_reload_reg_used_at_all
argument_list|,
name|reload_reg_used_at_all
argument_list|)
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|save_reload_reg_used_in_op_addr
argument_list|,
name|reload_reg_used_in_op_addr
argument_list|)
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|save_reload_reg_used_in_op_addr_reload
argument_list|,
name|reload_reg_used_in_op_addr_reload
argument_list|)
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|save_reload_reg_used_in_insn
argument_list|,
name|reload_reg_used_in_insn
argument_list|)
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|save_reload_reg_used_in_other_addr
argument_list|,
name|reload_reg_used_in_other_addr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reload_n_operands
condition|;
name|i
operator|++
control|)
block|{
name|COPY_HARD_REG_SET
argument_list|(
name|save_reload_reg_used_in_output
index|[
name|i
index|]
argument_list|,
name|reload_reg_used_in_output
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|save_reload_reg_used_in_input
index|[
name|i
index|]
argument_list|,
name|reload_reg_used_in_input
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|save_reload_reg_used_in_input_addr
index|[
name|i
index|]
argument_list|,
name|reload_reg_used_in_input_addr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|save_reload_reg_used_in_inpaddr_addr
index|[
name|i
index|]
argument_list|,
name|reload_reg_used_in_inpaddr_addr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|save_reload_reg_used_in_output_addr
index|[
name|i
index|]
argument_list|,
name|reload_reg_used_in_output_addr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|save_reload_reg_used_in_outaddr_addr
index|[
name|i
index|]
argument_list|,
name|reload_reg_used_in_outaddr_addr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* If -O, try first with inheritance, then turning it off.      If not -O, don't do inheritance.      Using inheritance when not optimizing leads to paradoxes      with fp on the 68k: fp numbers (not NaNs) fail to be equal to themselves      because one side of the comparison might be inherited.  */
for|for
control|(
name|inheritance
operator|=
name|optimize
operator|>
literal|0
init|;
name|inheritance
operator|>=
literal|0
condition|;
name|inheritance
operator|--
control|)
block|{
comment|/* Process the reloads in order of preference just found. 	 Beyond this point, subregs can be found in reload_reg_rtx.  	 This used to look for an existing reloaded home for all 	 of the reloads, and only then perform any new reloads. 	 But that could lose if the reloads were done out of reg-class order 	 because a later reload with a looser constraint might have an old 	 home in a register needed by an earlier reload with a tighter constraint.  	 To solve this, we make two passes over the reloads, in the order 	 described above.  In the first pass we try to inherit a reload 	 from a previous insn.  If there is a later reload that needs a 	 class that is a proper subset of the class being processed, we must 	 also allocate a spill register during the first pass.  	 Then make a second pass over the reloads to allocate any reloads 	 that haven't been given registers yet.  */
name|CLEAR_HARD_REG_SET
argument_list|(
name|reload_reg_used_for_inherit
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_reloads
condition|;
name|j
operator|++
control|)
block|{
specifier|register
name|int
name|r
init|=
name|reload_order
index|[
name|j
index|]
decl_stmt|;
comment|/* Ignore reloads that got marked inoperative.  */
if|if
condition|(
name|reload_out
index|[
name|r
index|]
operator|==
literal|0
operator|&&
name|reload_in
index|[
name|r
index|]
operator|==
literal|0
operator|&&
operator|!
name|reload_secondary_p
index|[
name|r
index|]
condition|)
continue|continue;
comment|/* If find_reloads chose a to use reload_in or reload_out as a reload 	     register, we don't need to chose one.  Otherwise, try even if it 	     found one since we might save an insn if we find the value lying 	     around.  */
if|if
condition|(
name|reload_in
index|[
name|r
index|]
operator|!=
literal|0
operator|&&
name|reload_reg_rtx
index|[
name|r
index|]
operator|!=
literal|0
operator|&&
operator|(
name|rtx_equal_p
argument_list|(
name|reload_in
index|[
name|r
index|]
argument_list|,
name|reload_reg_rtx
index|[
name|r
index|]
argument_list|)
operator|||
name|rtx_equal_p
argument_list|(
name|reload_out
index|[
name|r
index|]
argument_list|,
name|reload_reg_rtx
index|[
name|r
index|]
argument_list|)
operator|)
condition|)
continue|continue;
if|#
directive|if
literal|0
comment|/* No longer needed for correct operation. 	 It might give better code, or might not; worth an experiment?  */
comment|/* If this is an optional reload, we can't inherit from earlier insns 	     until we are sure that any non-optional reloads have been allocated. 	     The following code takes advantage of the fact that optional reloads 	     are at the end of reload_order.  */
block|if (reload_optional[r] != 0) 	    for (i = 0; i< j; i++) 	      if ((reload_out[reload_order[i]] != 0 		   || reload_in[reload_order[i]] != 0 		   || reload_secondary_p[reload_order[i]])&& ! reload_optional[reload_order[i]]&& reload_reg_rtx[reload_order[i]] == 0) 		allocate_reload_reg (reload_order[i], insn, 0, inheritance);
endif|#
directive|endif
comment|/* First see if this pseudo is already available as reloaded 	     for a previous insn.  We cannot try to inherit for reloads 	     that are smaller than the maximum number of registers needed 	     for groups unless the register we would allocate cannot be used 	     for the groups.  	     We could check here to see if this is a secondary reload for 	     an object that is already in a register of the desired class. 	     This would avoid the need for the secondary reload register. 	     But this is complex because we can't easily determine what 	     objects might want to be loaded via this reload.  So let a 	     register be allocated here.  In `emit_reload_insns' we suppress 	     one of the loads in the case described above.  */
if|if
condition|(
name|inheritance
condition|)
block|{
specifier|register
name|int
name|regno
init|=
operator|-
literal|1
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
if|if
condition|(
name|reload_in
index|[
name|r
index|]
operator|==
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|reload_in
index|[
name|r
index|]
argument_list|)
operator|==
name|REG
condition|)
block|{
name|regno
operator|=
name|REGNO
argument_list|(
name|reload_in
index|[
name|r
index|]
argument_list|)
expr_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|reload_in
index|[
name|r
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|reload_in_reg
index|[
name|r
index|]
argument_list|)
operator|==
name|REG
condition|)
block|{
name|regno
operator|=
name|REGNO
argument_list|(
name|reload_in_reg
index|[
name|r
index|]
argument_list|)
expr_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|reload_in_reg
index|[
name|r
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|reload_in
index|[
name|r
index|]
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|rtx
name|prev
init|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
decl_stmt|,
name|note
decl_stmt|;
if|if
condition|(
name|prev
operator|&&
name|GET_CODE
argument_list|(
name|prev
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|)
operator|==
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|&&
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|prev
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|rtx
name|addr
init|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|size_diff
init|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|addr
argument_list|)
argument_list|)
operator|-
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|reload_in
index|[
name|r
index|]
argument_list|)
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|size_diff
operator|>=
literal|0
operator|&&
name|rtx_equal_p
argument_list|(
operator|(
name|BYTES_BIG_ENDIAN
condition|?
name|plus_constant
argument_list|(
name|addr
argument_list|,
name|size_diff
argument_list|)
else|:
name|addr
operator|)
argument_list|,
name|XEXP
argument_list|(
name|reload_in
index|[
name|r
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|regno
operator|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|reload_in
index|[
name|r
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|#
directive|if
literal|0
comment|/* This won't work, since REGNO can be a pseudo reg number. 		 Also, it takes much more hair to keep track of all the things 		 that can invalidate an inherited reload of part of a pseudoreg.  */
block|else if (GET_CODE (reload_in[r]) == SUBREG&& GET_CODE (SUBREG_REG (reload_in[r])) == REG) 		regno = REGNO (SUBREG_REG (reload_in[r])) + SUBREG_WORD (reload_in[r]);
endif|#
directive|endif
if|if
condition|(
name|regno
operator|>=
literal|0
operator|&&
name|reg_last_reload_reg
index|[
name|regno
index|]
operator|!=
literal|0
condition|)
block|{
name|i
operator|=
name|REGNO
argument_list|(
name|reg_last_reload_reg
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_reloaded_contents
index|[
name|i
index|]
operator|==
name|regno
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_reloaded_valid
argument_list|,
name|i
argument_list|)
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|reg_last_reload_reg
index|[
name|regno
index|]
argument_list|)
argument_list|)
operator|>=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|)
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|i
argument_list|,
name|reload_mode
index|[
name|r
index|]
argument_list|)
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|reload_reg_class
index|[
name|r
index|]
index|]
argument_list|,
name|i
argument_list|)
operator|&&
operator|(
name|reload_nregs
index|[
name|r
index|]
operator|==
name|max_group_size
operator|||
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|group_class
index|]
argument_list|,
name|i
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|reload_reg_free_p
argument_list|(
name|i
argument_list|,
name|reload_opnum
index|[
name|r
index|]
argument_list|,
name|reload_when_needed
index|[
name|r
index|]
argument_list|)
operator|&&
name|reload_reg_free_before_p
argument_list|(
name|i
argument_list|,
name|reload_opnum
index|[
name|r
index|]
argument_list|,
name|reload_when_needed
index|[
name|r
index|]
argument_list|)
operator|)
operator|||
name|reload_reg_free_for_value_p
argument_list|(
name|i
argument_list|,
name|reload_opnum
index|[
name|r
index|]
argument_list|,
name|reload_when_needed
index|[
name|r
index|]
argument_list|,
name|reload_in
index|[
name|r
index|]
argument_list|,
name|reload_out
index|[
name|r
index|]
argument_list|,
name|r
argument_list|)
operator|)
condition|)
block|{
comment|/* If a group is needed, verify that all the subsequent 			 registers still have their values intact.  */
name|int
name|nr
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|i
argument_list|,
name|reload_mode
index|[
name|r
index|]
argument_list|)
decl_stmt|;
name|int
name|k
decl_stmt|;
for|for
control|(
name|k
operator|=
literal|1
init|;
name|k
operator|<
name|nr
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|reg_reloaded_contents
index|[
name|i
operator|+
name|k
index|]
operator|!=
name|regno
operator|||
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_reloaded_valid
argument_list|,
name|i
operator|+
name|k
argument_list|)
condition|)
break|break;
if|if
condition|(
name|k
operator|==
name|nr
condition|)
block|{
name|int
name|i1
decl_stmt|;
comment|/* We found a register that contains the 			     value we need.  If this register is the 			     same as an `earlyclobber' operand of the 			     current insn, just mark it as a place to 			     reload from since we can't use it as the 			     reload register itself.  */
for|for
control|(
name|i1
operator|=
literal|0
init|;
name|i1
operator|<
name|n_earlyclobbers
condition|;
name|i1
operator|++
control|)
if|if
condition|(
name|reg_overlap_mentioned_for_reload_p
argument_list|(
name|reg_last_reload_reg
index|[
name|regno
index|]
argument_list|,
name|reload_earlyclobbers
index|[
name|i1
index|]
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i1
operator|!=
name|n_earlyclobbers
comment|/* Don't use it if we'd clobber a pseudo reg.  */
operator|||
operator|(
name|spill_reg_order
index|[
name|i
index|]
operator|<
literal|0
operator|&&
name|reload_out
index|[
name|r
index|]
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_reloaded_dead
argument_list|,
name|i
argument_list|)
operator|)
comment|/* Don't really use the inherited spill reg 				 if we need it wider than we've got it.  */
operator|||
operator|(
name|GET_MODE_SIZE
argument_list|(
name|reload_mode
index|[
name|r
index|]
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|)
condition|)
name|reload_override_in
index|[
name|r
index|]
operator|=
name|reg_last_reload_reg
index|[
name|regno
index|]
expr_stmt|;
else|else
block|{
name|int
name|k
decl_stmt|;
comment|/* We can use this as a reload reg.  */
comment|/* Mark the register as in use for this part of 				 the insn.  */
name|mark_reload_reg_in_use
argument_list|(
name|i
argument_list|,
name|reload_opnum
index|[
name|r
index|]
argument_list|,
name|reload_when_needed
index|[
name|r
index|]
argument_list|,
name|reload_mode
index|[
name|r
index|]
argument_list|)
expr_stmt|;
name|reload_reg_rtx
index|[
name|r
index|]
operator|=
name|reg_last_reload_reg
index|[
name|regno
index|]
expr_stmt|;
name|reload_inherited
index|[
name|r
index|]
operator|=
literal|1
expr_stmt|;
name|reload_inheritance_insn
index|[
name|r
index|]
operator|=
name|reg_reloaded_insn
index|[
name|i
index|]
expr_stmt|;
name|reload_spill_index
index|[
name|r
index|]
operator|=
name|i
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|nr
condition|;
name|k
operator|++
control|)
name|SET_HARD_REG_BIT
argument_list|(
name|reload_reg_used_for_inherit
argument_list|,
name|i
operator|+
name|k
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/* Here's another way to see if the value is already lying around.  */
if|if
condition|(
name|inheritance
operator|&&
name|reload_in
index|[
name|r
index|]
operator|!=
literal|0
operator|&&
operator|!
name|reload_inherited
index|[
name|r
index|]
operator|&&
name|reload_out
index|[
name|r
index|]
operator|==
literal|0
operator|&&
operator|(
name|CONSTANT_P
argument_list|(
name|reload_in
index|[
name|r
index|]
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|reload_in
index|[
name|r
index|]
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|reload_in
index|[
name|r
index|]
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|reload_in
index|[
name|r
index|]
argument_list|)
operator|==
name|MEM
operator|)
operator|&&
operator|(
name|reload_nregs
index|[
name|r
index|]
operator|==
name|max_group_size
operator|||
operator|!
name|reg_classes_intersect_p
argument_list|(
name|reload_reg_class
index|[
name|r
index|]
argument_list|,
name|group_class
argument_list|)
operator|)
condition|)
block|{
specifier|register
name|rtx
name|equiv
init|=
name|find_equiv_reg
argument_list|(
name|reload_in
index|[
name|r
index|]
argument_list|,
name|insn
argument_list|,
name|reload_reg_class
index|[
name|r
index|]
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL_PTR
argument_list|,
literal|0
argument_list|,
name|reload_mode
index|[
name|r
index|]
argument_list|)
decl_stmt|;
name|int
name|regno
decl_stmt|;
if|if
condition|(
name|equiv
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|equiv
argument_list|)
operator|==
name|REG
condition|)
name|regno
operator|=
name|REGNO
argument_list|(
name|equiv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|equiv
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
comment|/* This must be a SUBREG of a hard register. 			 Make a new REG since this might be used in an 			 address and not all machines support SUBREGs 			 there.  */
name|regno
operator|=
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|equiv
argument_list|)
argument_list|)
operator|+
name|SUBREG_WORD
argument_list|(
name|equiv
argument_list|)
expr_stmt|;
name|equiv
operator|=
name|gen_rtx_REG
argument_list|(
name|reload_mode
index|[
name|r
index|]
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* If we found a spill reg, reject it unless it is free 		 and of the desired class.  */
if|if
condition|(
name|equiv
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|spill_reg_order
index|[
name|regno
index|]
operator|>=
literal|0
operator|&&
operator|!
operator|(
name|reload_reg_free_before_p
argument_list|(
name|regno
argument_list|,
name|reload_opnum
index|[
name|r
index|]
argument_list|,
name|reload_when_needed
index|[
name|r
index|]
argument_list|)
operator|||
name|reload_reg_free_for_value_p
argument_list|(
name|regno
argument_list|,
name|reload_opnum
index|[
name|r
index|]
argument_list|,
name|reload_when_needed
index|[
name|r
index|]
argument_list|,
name|reload_in
index|[
name|r
index|]
argument_list|,
name|reload_out
index|[
name|r
index|]
argument_list|,
name|r
argument_list|)
operator|)
operator|)
operator|||
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|reload_reg_class
index|[
name|r
index|]
index|]
argument_list|,
name|regno
argument_list|)
operator|)
condition|)
name|equiv
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|equiv
operator|!=
literal|0
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|reload_reg_used_at_all
argument_list|,
name|regno
argument_list|)
condition|)
name|equiv
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|equiv
operator|!=
literal|0
operator|&&
operator|!
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|reload_mode
index|[
name|r
index|]
argument_list|)
condition|)
name|equiv
operator|=
literal|0
expr_stmt|;
comment|/* We found a register that contains the value we need. 		 If this register is the same as an `earlyclobber' operand 		 of the current insn, just mark it as a place to reload from 		 since we can't use it as the reload register itself.  */
if|if
condition|(
name|equiv
operator|!=
literal|0
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_earlyclobbers
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reg_overlap_mentioned_for_reload_p
argument_list|(
name|equiv
argument_list|,
name|reload_earlyclobbers
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|reload_override_in
index|[
name|r
index|]
operator|=
name|equiv
expr_stmt|;
name|equiv
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* If the equiv register we have found is explicitly clobbered 		 in the current insn, it depends on the reload type if we 		 can use it, use it for reload_override_in, or not at all. 		 In particular, we then can't use EQUIV for a 		 RELOAD_FOR_OUTPUT_ADDRESS reload.  */
if|if
condition|(
name|equiv
operator|!=
literal|0
operator|&&
name|regno_clobbered_p
argument_list|(
name|regno
argument_list|,
name|insn
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|reload_when_needed
index|[
name|r
index|]
condition|)
block|{
case|case
name|RELOAD_FOR_OTHER_ADDRESS
case|:
case|case
name|RELOAD_FOR_INPADDR_ADDRESS
case|:
case|case
name|RELOAD_FOR_INPUT_ADDRESS
case|:
case|case
name|RELOAD_FOR_OPADDR_ADDR
case|:
break|break;
case|case
name|RELOAD_OTHER
case|:
case|case
name|RELOAD_FOR_INPUT
case|:
case|case
name|RELOAD_FOR_OPERAND_ADDRESS
case|:
name|reload_override_in
index|[
name|r
index|]
operator|=
name|equiv
expr_stmt|;
comment|/* Fall through. */
default|default:
name|equiv
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
comment|/* If we found an equivalent reg, say no code need be generated 		 to load it, and use it as our reload reg.  */
if|if
condition|(
name|equiv
operator|!=
literal|0
operator|&&
name|regno
operator|!=
name|HARD_FRAME_POINTER_REGNUM
condition|)
block|{
name|int
name|nr
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|reload_mode
index|[
name|r
index|]
argument_list|)
decl_stmt|;
name|int
name|k
decl_stmt|;
name|reload_reg_rtx
index|[
name|r
index|]
operator|=
name|equiv
expr_stmt|;
name|reload_inherited
index|[
name|r
index|]
operator|=
literal|1
expr_stmt|;
comment|/* If reg_reloaded_valid is not set for this register, 		     there might be a stale spill_reg_store lying around. 		     We must clear it, since otherwise emit_reload_insns 		     might delete the store.  */
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_reloaded_valid
argument_list|,
name|regno
argument_list|)
condition|)
name|spill_reg_store
index|[
name|regno
index|]
operator|=
name|NULL_RTX
expr_stmt|;
comment|/* If any of the hard registers in EQUIV are spill 		     registers, mark them as in use for this insn.  */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|nr
condition|;
name|k
operator|++
control|)
block|{
name|i
operator|=
name|spill_reg_order
index|[
name|regno
operator|+
name|k
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
name|mark_reload_reg_in_use
argument_list|(
name|regno
argument_list|,
name|reload_opnum
index|[
name|r
index|]
argument_list|,
name|reload_when_needed
index|[
name|r
index|]
argument_list|,
name|reload_mode
index|[
name|r
index|]
argument_list|)
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|reload_reg_used_for_inherit
argument_list|,
name|regno
operator|+
name|k
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* If we found a register to use already, or if this is an optional 	     reload, we are done.  */
if|if
condition|(
name|reload_reg_rtx
index|[
name|r
index|]
operator|!=
literal|0
operator|||
name|reload_optional
index|[
name|r
index|]
operator|!=
literal|0
condition|)
continue|continue;
if|#
directive|if
literal|0
comment|/* No longer needed for correct operation.  Might or might not 	 give better code on the average.  Want to experiment?  */
comment|/* See if there is a later reload that has a class different from our 	     class that intersects our class or that requires less register 	     than our reload.  If so, we must allocate a register to this 	     reload now, since that reload might inherit a previous reload 	     and take the only available register in our class.  Don't do this 	     for optional reloads since they will force all previous reloads 	     to be allocated.  Also don't do this for reloads that have been 	     turned off.  */
block|for (i = j + 1; i< n_reloads; i++) 	    { 	      int s = reload_order[i];  	      if ((reload_in[s] == 0&& reload_out[s] == 0&& ! reload_secondary_p[s]) 		  || reload_optional[s]) 		continue;  	      if ((reload_reg_class[s] != reload_reg_class[r]&& reg_classes_intersect_p (reload_reg_class[r], 					       reload_reg_class[s])) 		  || reload_nregs[s]< reload_nregs[r]) 	      break; 	    }  	  if (i == n_reloads) 	    continue;  	  allocate_reload_reg (r, insn, j == n_reloads - 1, inheritance);
endif|#
directive|endif
block|}
comment|/* Now allocate reload registers for anything non-optional that 	 didn't get one yet.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_reloads
condition|;
name|j
operator|++
control|)
block|{
specifier|register
name|int
name|r
init|=
name|reload_order
index|[
name|j
index|]
decl_stmt|;
comment|/* Ignore reloads that got marked inoperative.  */
if|if
condition|(
name|reload_out
index|[
name|r
index|]
operator|==
literal|0
operator|&&
name|reload_in
index|[
name|r
index|]
operator|==
literal|0
operator|&&
operator|!
name|reload_secondary_p
index|[
name|r
index|]
condition|)
continue|continue;
comment|/* Skip reloads that already have a register allocated or are 	     optional.  */
if|if
condition|(
name|reload_reg_rtx
index|[
name|r
index|]
operator|!=
literal|0
operator|||
name|reload_optional
index|[
name|r
index|]
condition|)
continue|continue;
if|if
condition|(
operator|!
name|allocate_reload_reg
argument_list|(
name|r
argument_list|,
name|insn
argument_list|,
name|j
operator|==
name|n_reloads
operator|-
literal|1
argument_list|,
name|inheritance
argument_list|)
condition|)
break|break;
block|}
comment|/* If that loop got all the way, we have won.  */
if|if
condition|(
name|j
operator|==
name|n_reloads
condition|)
break|break;
name|fail
label|:
comment|/* Loop around and try without any inheritance.  */
comment|/* First undo everything done by the failed attempt 	 to allocate with inheritance.  */
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|save_reload_reg_rtx
argument_list|,
operator|(
name|char
operator|*
operator|)
name|reload_reg_rtx
argument_list|,
sizeof|sizeof
name|reload_reg_rtx
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|save_reload_inherited
argument_list|,
operator|(
name|char
operator|*
operator|)
name|reload_inherited
argument_list|,
sizeof|sizeof
name|reload_inherited
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|save_reload_inheritance_insn
argument_list|,
operator|(
name|char
operator|*
operator|)
name|reload_inheritance_insn
argument_list|,
sizeof|sizeof
name|reload_inheritance_insn
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|save_reload_override_in
argument_list|,
operator|(
name|char
operator|*
operator|)
name|reload_override_in
argument_list|,
sizeof|sizeof
name|reload_override_in
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|save_reload_spill_index
argument_list|,
operator|(
name|char
operator|*
operator|)
name|reload_spill_index
argument_list|,
sizeof|sizeof
name|reload_spill_index
argument_list|)
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|reload_reg_used
argument_list|,
name|save_reload_reg_used
argument_list|)
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|reload_reg_used_at_all
argument_list|,
name|save_reload_reg_used_at_all
argument_list|)
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|reload_reg_used_in_op_addr
argument_list|,
name|save_reload_reg_used_in_op_addr
argument_list|)
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|reload_reg_used_in_op_addr_reload
argument_list|,
name|save_reload_reg_used_in_op_addr_reload
argument_list|)
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|reload_reg_used_in_insn
argument_list|,
name|save_reload_reg_used_in_insn
argument_list|)
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|reload_reg_used_in_other_addr
argument_list|,
name|save_reload_reg_used_in_other_addr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reload_n_operands
condition|;
name|i
operator|++
control|)
block|{
name|COPY_HARD_REG_SET
argument_list|(
name|reload_reg_used_in_input
index|[
name|i
index|]
argument_list|,
name|save_reload_reg_used_in_input
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|reload_reg_used_in_output
index|[
name|i
index|]
argument_list|,
name|save_reload_reg_used_in_output
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|reload_reg_used_in_input_addr
index|[
name|i
index|]
argument_list|,
name|save_reload_reg_used_in_input_addr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|reload_reg_used_in_inpaddr_addr
index|[
name|i
index|]
argument_list|,
name|save_reload_reg_used_in_inpaddr_addr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|reload_reg_used_in_output_addr
index|[
name|i
index|]
argument_list|,
name|save_reload_reg_used_in_output_addr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|reload_reg_used_in_outaddr_addr
index|[
name|i
index|]
argument_list|,
name|save_reload_reg_used_in_outaddr_addr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If we thought we could inherit a reload, because it seemed that      nothing else wanted the same reload register earlier in the insn,      verify that assumption, now that all reloads have been assigned.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_reloads
condition|;
name|j
operator|++
control|)
block|{
specifier|register
name|int
name|r
init|=
name|reload_order
index|[
name|j
index|]
decl_stmt|;
if|if
condition|(
name|reload_inherited
index|[
name|r
index|]
operator|&&
name|reload_reg_rtx
index|[
name|r
index|]
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|reload_reg_free_before_p
argument_list|(
name|true_regnum
argument_list|(
name|reload_reg_rtx
index|[
name|r
index|]
argument_list|)
argument_list|,
name|reload_opnum
index|[
name|r
index|]
argument_list|,
name|reload_when_needed
index|[
name|r
index|]
argument_list|)
operator|||
name|reload_reg_free_for_value_p
argument_list|(
name|true_regnum
argument_list|(
name|reload_reg_rtx
index|[
name|r
index|]
argument_list|)
argument_list|,
name|reload_opnum
index|[
name|r
index|]
argument_list|,
name|reload_when_needed
index|[
name|r
index|]
argument_list|,
name|reload_in
index|[
name|r
index|]
argument_list|,
name|reload_out
index|[
name|r
index|]
argument_list|,
name|r
argument_list|)
operator|)
condition|)
name|reload_inherited
index|[
name|r
index|]
operator|=
literal|0
expr_stmt|;
comment|/* If we can inherit a RELOAD_FOR_INPUT, then we do not need its related 	 RELOAD_FOR_INPUT_ADDRESS / RELOAD_FOR_INPADDR_ADDRESS reloads. 	 ??? This could be extended to other reload types, but these are          more tricky to handle: 	 RELOAD_FOR_OTHER_ADDRESS reloads might have been merged, so we 	 can't eliminate them without a check that *all* references are 	 now unused due to inheritance. 	 While RELOAD_FOR_INPADDR_ADDRESS and RELOAD_FOR_OUTADDR_ADDRESS are 	 not merged, we can't be sure that we have eliminated the use of 	 that particular reload if we have seen just one 	 RELOAD_FOR_INPUT_ADDRESS / RELOAD_FOR_OUTPUT_ADDRESS being inherited, 	 since there might be multiple of the latter two reloads for a single 	 operand. 	 RELOAD_FOR_OPADDR_ADDR reloads for different operands are not 	 merged, but might share the same register by courtesy of 	 reload_reg_free_for_value_p.  reload_reg_used_in_op_addr_reload 	 does not differentiate by opnum, thus calling clear_reload_reg_in_use 	 for one of these reloads would mark the register as free even though 	 another RELOAD_FOR_OPADDR_ADDR reload might still use it.  */
elseif|else
if|if
condition|(
name|reload_inherited
index|[
name|r
index|]
operator|&&
name|reload_when_needed
index|[
name|r
index|]
operator|==
name|RELOAD_FOR_INPUT
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_reloads
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|reload_when_needed
index|[
name|i
index|]
operator|==
name|RELOAD_FOR_INPUT_ADDRESS
operator|||
name|reload_when_needed
index|[
name|i
index|]
operator|==
name|RELOAD_FOR_INPADDR_ADDRESS
operator|)
operator|&&
name|reload_opnum
index|[
name|i
index|]
operator|==
name|reload_opnum
index|[
name|r
index|]
operator|&&
name|reload_in
index|[
name|i
index|]
operator|&&
name|reload_reg_rtx
index|[
name|i
index|]
condition|)
block|{
name|int
name|regno
init|=
name|true_regnum
argument_list|(
name|reload_reg_rtx
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|reload_in
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|spill_reg_order
index|[
name|regno
index|]
operator|>=
literal|0
condition|)
name|clear_reload_reg_in_use
argument_list|(
name|regno
argument_list|,
name|reload_opnum
index|[
name|i
index|]
argument_list|,
name|reload_when_needed
index|[
name|i
index|]
argument_list|,
name|reload_mode
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|reload_reg_rtx
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|reload_spill_index
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|remove_replacements
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* If we found a better place to reload from, 	 validate it in the same fashion, if it is a reload reg.  */
if|if
condition|(
name|reload_override_in
index|[
name|r
index|]
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|reload_override_in
index|[
name|r
index|]
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|reload_override_in
index|[
name|r
index|]
argument_list|)
operator|==
name|SUBREG
operator|)
condition|)
block|{
name|int
name|regno
init|=
name|true_regnum
argument_list|(
name|reload_override_in
index|[
name|r
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|spill_reg_order
index|[
name|regno
index|]
operator|>=
literal|0
operator|&&
operator|!
name|reload_reg_free_before_p
argument_list|(
name|regno
argument_list|,
name|reload_opnum
index|[
name|r
index|]
argument_list|,
name|reload_when_needed
index|[
name|r
index|]
argument_list|)
condition|)
name|reload_override_in
index|[
name|r
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Now that reload_override_in is known valid,      actually override reload_in.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_reloads
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|reload_override_in
index|[
name|j
index|]
condition|)
name|reload_in
index|[
name|j
index|]
operator|=
name|reload_override_in
index|[
name|j
index|]
expr_stmt|;
comment|/* If this reload won't be done because it has been cancelled or is      optional and not inherited, clear reload_reg_rtx so other      routines (such as subst_reloads) don't get confused.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_reloads
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|reload_reg_rtx
index|[
name|j
index|]
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|reload_optional
index|[
name|j
index|]
operator|&&
operator|!
name|reload_inherited
index|[
name|j
index|]
operator|)
operator|||
operator|(
name|reload_in
index|[
name|j
index|]
operator|==
literal|0
operator|&&
name|reload_out
index|[
name|j
index|]
operator|==
literal|0
operator|&&
operator|!
name|reload_secondary_p
index|[
name|j
index|]
operator|)
operator|)
condition|)
block|{
name|int
name|regno
init|=
name|true_regnum
argument_list|(
name|reload_reg_rtx
index|[
name|j
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|spill_reg_order
index|[
name|regno
index|]
operator|>=
literal|0
condition|)
name|clear_reload_reg_in_use
argument_list|(
name|regno
argument_list|,
name|reload_opnum
index|[
name|j
index|]
argument_list|,
name|reload_when_needed
index|[
name|j
index|]
argument_list|,
name|reload_mode
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|reload_reg_rtx
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Record which pseudos and which spill regs have output reloads.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_reloads
condition|;
name|j
operator|++
control|)
block|{
specifier|register
name|int
name|r
init|=
name|reload_order
index|[
name|j
index|]
decl_stmt|;
name|i
operator|=
name|reload_spill_index
index|[
name|r
index|]
expr_stmt|;
comment|/* I is nonneg if this reload uses a register. 	 If reload_reg_rtx[r] is 0, this is an optional reload 	 that we opted to ignore.  */
if|if
condition|(
name|reload_out
index|[
name|r
index|]
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|reload_out
index|[
name|r
index|]
argument_list|)
operator|==
name|REG
operator|&&
name|reload_reg_rtx
index|[
name|r
index|]
operator|!=
literal|0
condition|)
block|{
specifier|register
name|int
name|nregno
init|=
name|REGNO
argument_list|(
name|reload_out
index|[
name|r
index|]
argument_list|)
decl_stmt|;
name|int
name|nr
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|nregno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|nr
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|nregno
argument_list|,
name|reload_mode
index|[
name|r
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|nr
operator|>=
literal|0
condition|)
name|reg_has_output_reload
index|[
name|nregno
operator|+
name|nr
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
name|nr
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|i
argument_list|,
name|reload_mode
index|[
name|r
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|nr
operator|>=
literal|0
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|reg_is_output_reload
argument_list|,
name|i
operator|+
name|nr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reload_when_needed
index|[
name|r
index|]
operator|!=
name|RELOAD_OTHER
operator|&&
name|reload_when_needed
index|[
name|r
index|]
operator|!=
name|RELOAD_FOR_OUTPUT
operator|&&
name|reload_when_needed
index|[
name|r
index|]
operator|!=
name|RELOAD_FOR_INSN
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If SMALL_REGISTER_CLASSES is non-zero, we may not have merged two    reloads of the same item for fear that we might not have enough reload    registers. However, normally they will get the same reload register    and hence actually need not be loaded twice.       Here we check for the most common case of this phenomenon: when we have    a number of reloads for the same object, each of which were allocated    the same reload_reg_rtx, that reload_reg_rtx is not used for any other    reload, and is not modified in the insn itself.  If we find such,    merge all the reloads and set the resulting reload to RELOAD_OTHER.    This will not increase the number of spill registers needed and will    prevent redundant code.  */
end_comment

begin_function
specifier|static
name|void
name|merge_assigned_reloads
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* Scan all the reloads looking for ones that only load values and      are not already RELOAD_OTHER and ones whose reload_reg_rtx are      assigned and not modified by INSN.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_reloads
condition|;
name|i
operator|++
control|)
block|{
name|int
name|conflicting_input
init|=
literal|0
decl_stmt|;
name|int
name|max_input_address_opnum
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|min_conflicting_input_opnum
init|=
name|MAX_RECOG_OPERANDS
decl_stmt|;
if|if
condition|(
name|reload_in
index|[
name|i
index|]
operator|==
literal|0
operator|||
name|reload_when_needed
index|[
name|i
index|]
operator|==
name|RELOAD_OTHER
operator|||
name|reload_out
index|[
name|i
index|]
operator|!=
literal|0
operator|||
name|reload_reg_rtx
index|[
name|i
index|]
operator|==
literal|0
operator|||
name|reg_set_p
argument_list|(
name|reload_reg_rtx
index|[
name|i
index|]
argument_list|,
name|insn
argument_list|)
condition|)
continue|continue;
comment|/* Look at all other reloads.  Ensure that the only use of this 	 reload_reg_rtx is in a reload that just loads the same value 	 as we do.  Note that any secondary reloads must be of the identical 	 class since the values, modes, and result registers are the 	 same, so we need not do anything with any secondary reloads.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_reloads
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|j
operator|||
name|reload_reg_rtx
index|[
name|j
index|]
operator|==
literal|0
operator|||
operator|!
name|reg_overlap_mentioned_p
argument_list|(
name|reload_reg_rtx
index|[
name|j
index|]
argument_list|,
name|reload_reg_rtx
index|[
name|i
index|]
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|reload_when_needed
index|[
name|j
index|]
operator|==
name|RELOAD_FOR_INPUT_ADDRESS
operator|&&
name|reload_opnum
index|[
name|j
index|]
operator|>
name|max_input_address_opnum
condition|)
name|max_input_address_opnum
operator|=
name|reload_opnum
index|[
name|j
index|]
expr_stmt|;
comment|/* If the reload regs aren't exactly the same (e.g, different modes) 	     or if the values are different, we can't merge this reload. 	     But if it is an input reload, we might still merge 	     RELOAD_FOR_INPUT_ADDRESS and RELOAD_FOR_OTHER_ADDRESS reloads.  */
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|reload_reg_rtx
index|[
name|i
index|]
argument_list|,
name|reload_reg_rtx
index|[
name|j
index|]
argument_list|)
operator|||
name|reload_out
index|[
name|j
index|]
operator|!=
literal|0
operator|||
name|reload_in
index|[
name|j
index|]
operator|==
literal|0
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|reload_in
index|[
name|i
index|]
argument_list|,
name|reload_in
index|[
name|j
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|reload_when_needed
index|[
name|j
index|]
operator|!=
name|RELOAD_FOR_INPUT
operator|||
operator|(
operator|(
name|reload_when_needed
index|[
name|i
index|]
operator|!=
name|RELOAD_FOR_INPUT_ADDRESS
operator|||
name|reload_opnum
index|[
name|i
index|]
operator|>
name|reload_opnum
index|[
name|j
index|]
operator|)
operator|&&
name|reload_when_needed
index|[
name|i
index|]
operator|!=
name|RELOAD_FOR_OTHER_ADDRESS
operator|)
condition|)
break|break;
name|conflicting_input
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|min_conflicting_input_opnum
operator|>
name|reload_opnum
index|[
name|j
index|]
condition|)
name|min_conflicting_input_opnum
operator|=
name|reload_opnum
index|[
name|j
index|]
expr_stmt|;
block|}
block|}
comment|/* If all is OK, merge the reloads.  Only set this to RELOAD_OTHER if 	 we, in fact, found any matching reloads.  */
if|if
condition|(
name|j
operator|==
name|n_reloads
operator|&&
name|max_input_address_opnum
operator|<=
name|min_conflicting_input_opnum
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_reloads
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|i
operator|!=
name|j
operator|&&
name|reload_reg_rtx
index|[
name|j
index|]
operator|!=
literal|0
operator|&&
name|rtx_equal_p
argument_list|(
name|reload_reg_rtx
index|[
name|i
index|]
argument_list|,
name|reload_reg_rtx
index|[
name|j
index|]
argument_list|)
operator|&&
operator|(
operator|!
name|conflicting_input
operator|||
name|reload_when_needed
index|[
name|j
index|]
operator|==
name|RELOAD_FOR_INPUT_ADDRESS
operator|||
name|reload_when_needed
index|[
name|j
index|]
operator|==
name|RELOAD_FOR_OTHER_ADDRESS
operator|)
condition|)
block|{
name|reload_when_needed
index|[
name|i
index|]
operator|=
name|RELOAD_OTHER
expr_stmt|;
name|reload_in
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
name|reload_spill_index
index|[
name|j
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|transfer_replacements
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
comment|/* If this is now RELOAD_OTHER, look for any reloads that load 	     parts of this operand and set them to RELOAD_FOR_OTHER_ADDRESS 	     if they were for inputs, RELOAD_OTHER for outputs.  Note that 	     this test is equivalent to looking for reloads for this operand 	     number.  */
if|if
condition|(
name|reload_when_needed
index|[
name|i
index|]
operator|==
name|RELOAD_OTHER
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_reloads
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|reload_in
index|[
name|j
index|]
operator|!=
literal|0
operator|&&
name|reload_when_needed
index|[
name|i
index|]
operator|!=
name|RELOAD_OTHER
operator|&&
name|reg_overlap_mentioned_for_reload_p
argument_list|(
name|reload_in
index|[
name|j
index|]
argument_list|,
name|reload_in
index|[
name|i
index|]
argument_list|)
condition|)
name|reload_when_needed
index|[
name|j
index|]
operator|=
operator|(
operator|(
name|reload_when_needed
index|[
name|i
index|]
operator|==
name|RELOAD_FOR_INPUT_ADDRESS
operator|||
name|reload_when_needed
index|[
name|i
index|]
operator|==
name|RELOAD_FOR_INPADDR_ADDRESS
operator|)
condition|?
name|RELOAD_FOR_OTHER_ADDRESS
else|:
name|RELOAD_OTHER
operator|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output insns to reload values in and out of the chosen reload regs.  */
end_comment

begin_function
specifier|static
name|void
name|emit_reload_insns
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
specifier|register
name|int
name|j
decl_stmt|;
name|rtx
name|input_reload_insns
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|rtx
name|other_input_address_reload_insns
init|=
literal|0
decl_stmt|;
name|rtx
name|other_input_reload_insns
init|=
literal|0
decl_stmt|;
name|rtx
name|input_address_reload_insns
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|rtx
name|inpaddr_address_reload_insns
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|rtx
name|output_reload_insns
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|rtx
name|output_address_reload_insns
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|rtx
name|outaddr_address_reload_insns
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|rtx
name|operand_reload_insns
init|=
literal|0
decl_stmt|;
name|rtx
name|other_operand_reload_insns
init|=
literal|0
decl_stmt|;
name|rtx
name|other_output_reload_insns
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|rtx
name|following_insn
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|before_insn
init|=
name|insn
decl_stmt|;
name|int
name|special
decl_stmt|;
comment|/* Values to be put in spill_reg_store are put here first.  */
name|rtx
name|new_spill_reg_store
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
name|HARD_REG_SET
name|reg_reloaded_died
decl_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|reg_reloaded_died
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|reload_n_operands
condition|;
name|j
operator|++
control|)
name|input_reload_insns
index|[
name|j
index|]
operator|=
name|input_address_reload_insns
index|[
name|j
index|]
operator|=
name|inpaddr_address_reload_insns
index|[
name|j
index|]
operator|=
name|output_reload_insns
index|[
name|j
index|]
operator|=
name|output_address_reload_insns
index|[
name|j
index|]
operator|=
name|outaddr_address_reload_insns
index|[
name|j
index|]
operator|=
name|other_output_reload_insns
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Now output the instructions to copy the data into and out of the      reload registers.  Do these in the order that the reloads were reported,      since reloads of base and index registers precede reloads of operands      and the operands may need the base and index registers reloaded.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_reloads
condition|;
name|j
operator|++
control|)
block|{
specifier|register
name|rtx
name|old
decl_stmt|;
name|rtx
name|oldequiv_reg
init|=
literal|0
decl_stmt|;
name|rtx
name|this_reload_insn
init|=
literal|0
decl_stmt|;
name|int
name|expect_occurrences
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|reload_spill_index
index|[
name|j
index|]
operator|>=
literal|0
condition|)
name|new_spill_reg_store
index|[
name|reload_spill_index
index|[
name|j
index|]
index|]
operator|=
literal|0
expr_stmt|;
name|old
operator|=
name|reload_in
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|old
operator|!=
literal|0
operator|&&
operator|!
name|reload_inherited
index|[
name|j
index|]
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|reload_reg_rtx
index|[
name|j
index|]
argument_list|,
name|old
argument_list|)
operator|&&
name|reload_reg_rtx
index|[
name|j
index|]
operator|!=
literal|0
condition|)
block|{
specifier|register
name|rtx
name|reloadreg
init|=
name|reload_reg_rtx
index|[
name|j
index|]
decl_stmt|;
name|rtx
name|oldequiv
init|=
literal|0
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
modifier|*
name|where
decl_stmt|;
comment|/* Determine the mode to reload in. 	     This is very tricky because we have three to choose from. 	     There is the mode the insn operand wants (reload_inmode[J]). 	     There is the mode of the reload register RELOADREG. 	     There is the intrinsic mode of the operand, which we could find 	     by stripping some SUBREGs. 	     It turns out that RELOADREG's mode is irrelevant: 	     we can change that arbitrarily.  	     Consider (SUBREG:SI foo:QI) as an operand that must be SImode; 	     then the reload reg may not support QImode moves, so use SImode. 	     If foo is in memory due to spilling a pseudo reg, this is safe, 	     because the QImode value is in the least significant part of a 	     slot big enough for a SImode.  If foo is some other sort of 	     memory reference, then it is impossible to reload this case, 	     so previous passes had better make sure this never happens.  	     Then consider a one-word union which has SImode and one of its 	     members is a float, being fetched as (SUBREG:SF union:SI). 	     We must fetch that as SFmode because we could be loading into 	     a float-only register.  In this case OLD's mode is correct.  	     Consider an immediate integer: it has VOIDmode.  Here we need 	     to get a mode from something else.  	     In some cases, there is a fourth mode, the operand's 	     containing mode.  If the insn specifies a containing mode for 	     this operand, it overrides all others.  	     I am not sure whether the algorithm here is always right, 	     but it does the right things in those cases.  */
name|mode
operator|=
name|GET_MODE
argument_list|(
name|old
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|mode
operator|=
name|reload_inmode
index|[
name|j
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|SECONDARY_INPUT_RELOAD_CLASS
comment|/* If we need a secondary register for this operation, see if 	     the value is already in a register in that class.  Don't 	     do this if the secondary register will be used as a scratch 	     register.  */
if|if
condition|(
name|reload_secondary_in_reload
index|[
name|j
index|]
operator|>=
literal|0
operator|&&
name|reload_secondary_in_icode
index|[
name|j
index|]
operator|==
name|CODE_FOR_nothing
operator|&&
name|optimize
condition|)
name|oldequiv
operator|=
name|find_equiv_reg
argument_list|(
name|old
argument_list|,
name|insn
argument_list|,
name|reload_reg_class
index|[
name|reload_secondary_in_reload
index|[
name|j
index|]
index|]
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL_PTR
argument_list|,
literal|0
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If reloading from memory, see if there is a register 	     that already holds the same value.  If so, reload from there. 	     We can pass 0 as the reload_reg_p argument because 	     any other reload has either already been emitted, 	     in which case find_equiv_reg will see the reload-insn, 	     or has yet to be emitted, in which case it doesn't matter 	     because we will use this equiv reg right away.  */
if|if
condition|(
name|oldequiv
operator|==
literal|0
operator|&&
name|optimize
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|old
argument_list|)
operator|==
name|MEM
operator|||
operator|(
name|GET_CODE
argument_list|(
name|old
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|old
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_renumber
index|[
name|REGNO
argument_list|(
name|old
argument_list|)
index|]
operator|<
literal|0
operator|)
operator|)
condition|)
name|oldequiv
operator|=
name|find_equiv_reg
argument_list|(
name|old
argument_list|,
name|insn
argument_list|,
name|ALL_REGS
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL_PTR
argument_list|,
literal|0
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldequiv
condition|)
block|{
name|int
name|regno
init|=
name|true_regnum
argument_list|(
name|oldequiv
argument_list|)
decl_stmt|;
comment|/* If OLDEQUIV is a spill register, don't use it for this 		 if any other reload needs it at an earlier stage of this insn 		 or at this stage.  */
if|if
condition|(
name|spill_reg_order
index|[
name|regno
index|]
operator|>=
literal|0
operator|&&
operator|(
operator|!
name|reload_reg_free_p
argument_list|(
name|regno
argument_list|,
name|reload_opnum
index|[
name|j
index|]
argument_list|,
name|reload_when_needed
index|[
name|j
index|]
argument_list|)
operator|||
operator|!
name|reload_reg_free_before_p
argument_list|(
name|regno
argument_list|,
name|reload_opnum
index|[
name|j
index|]
argument_list|,
name|reload_when_needed
index|[
name|j
index|]
argument_list|)
operator|)
condition|)
name|oldequiv
operator|=
literal|0
expr_stmt|;
comment|/* If OLDEQUIV is not a spill register, 		 don't use it if any other reload wants it.  */
if|if
condition|(
name|spill_reg_order
index|[
name|regno
index|]
operator|<
literal|0
condition|)
block|{
name|int
name|k
decl_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|n_reloads
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|reload_reg_rtx
index|[
name|k
index|]
operator|!=
literal|0
operator|&&
name|k
operator|!=
name|j
operator|&&
name|reg_overlap_mentioned_for_reload_p
argument_list|(
name|reload_reg_rtx
index|[
name|k
index|]
argument_list|,
name|oldequiv
argument_list|)
condition|)
block|{
name|oldequiv
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
comment|/* If it is no cheaper to copy from OLDEQUIV into the 		 reload register than it would be to move from memory, 		 don't use it. Likewise, if we need a secondary register 		 or memory.   */
if|if
condition|(
name|oldequiv
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|REGNO_REG_CLASS
argument_list|(
name|regno
argument_list|)
operator|!=
name|reload_reg_class
index|[
name|j
index|]
operator|&&
operator|(
name|REGISTER_MOVE_COST
argument_list|(
name|REGNO_REG_CLASS
argument_list|(
name|regno
argument_list|)
argument_list|,
name|reload_reg_class
index|[
name|j
index|]
argument_list|)
operator|>=
name|MEMORY_MOVE_COST
argument_list|(
name|mode
argument_list|,
name|reload_reg_class
index|[
name|j
index|]
argument_list|,
literal|1
argument_list|)
operator|)
operator|)
ifdef|#
directive|ifdef
name|SECONDARY_INPUT_RELOAD_CLASS
operator|||
operator|(
name|SECONDARY_INPUT_RELOAD_CLASS
argument_list|(
name|reload_reg_class
index|[
name|j
index|]
argument_list|,
name|mode
argument_list|,
name|oldequiv
argument_list|)
operator|!=
name|NO_REGS
operator|)
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SECONDARY_MEMORY_NEEDED
operator|||
name|SECONDARY_MEMORY_NEEDED
argument_list|(
name|REGNO_REG_CLASS
argument_list|(
name|regno
argument_list|)
argument_list|,
name|reload_reg_class
index|[
name|j
index|]
argument_list|,
name|mode
argument_list|)
endif|#
directive|endif
operator|)
condition|)
name|oldequiv
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|oldequiv
operator|==
literal|0
condition|)
name|oldequiv
operator|=
name|old
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|oldequiv
argument_list|)
operator|==
name|REG
condition|)
name|oldequiv_reg
operator|=
name|oldequiv
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|oldequiv
argument_list|)
operator|==
name|SUBREG
condition|)
name|oldequiv_reg
operator|=
name|SUBREG_REG
argument_list|(
name|oldequiv
argument_list|)
expr_stmt|;
comment|/* If we are reloading from a register that was recently stored in 	     with an output-reload, see if we can prove there was 	     actually no need to store the old value in it.  */
if|if
condition|(
name|optimize
operator|&&
name|GET_CODE
argument_list|(
name|oldequiv
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|oldequiv
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|spill_reg_store
index|[
name|REGNO
argument_list|(
name|oldequiv
argument_list|)
index|]
operator|&&
name|GET_CODE
argument_list|(
name|old
argument_list|)
operator|==
name|REG
operator|&&
name|dead_or_set_p
argument_list|(
name|insn
argument_list|,
name|old
argument_list|)
comment|/* This is unsafe if operand occurs more than once in current 		 insn.  Perhaps some occurrences weren't reloaded.  */
operator|&&
name|count_occurrences
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|old
argument_list|)
operator|==
literal|1
condition|)
name|delete_output_reload
argument_list|(
name|insn
argument_list|,
name|j
argument_list|,
name|spill_reg_store
index|[
name|REGNO
argument_list|(
name|oldequiv
argument_list|)
index|]
argument_list|)
expr_stmt|;
comment|/* Encapsulate both RELOADREG and OLDEQUIV into that mode, 	     then load RELOADREG from OLDEQUIV.  Note that we cannot use 	     gen_lowpart_common since it can do the wrong thing when 	     RELOADREG has a multi-word mode.  Note that RELOADREG 	     must always be a REG here.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|reloadreg
argument_list|)
operator|!=
name|mode
condition|)
name|reloadreg
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|REGNO
argument_list|(
name|reloadreg
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|oldequiv
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_MODE
argument_list|(
name|oldequiv
argument_list|)
operator|!=
name|mode
condition|)
name|oldequiv
operator|=
name|SUBREG_REG
argument_list|(
name|oldequiv
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|oldequiv
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|oldequiv
argument_list|)
condition|)
name|oldequiv
operator|=
name|gen_rtx_SUBREG
argument_list|(
name|mode
argument_list|,
name|oldequiv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Switch to the right place to emit the reload insns.  */
switch|switch
condition|(
name|reload_when_needed
index|[
name|j
index|]
condition|)
block|{
case|case
name|RELOAD_OTHER
case|:
name|where
operator|=
operator|&
name|other_input_reload_insns
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_INPUT
case|:
name|where
operator|=
operator|&
name|input_reload_insns
index|[
name|reload_opnum
index|[
name|j
index|]
index|]
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_INPUT_ADDRESS
case|:
name|where
operator|=
operator|&
name|input_address_reload_insns
index|[
name|reload_opnum
index|[
name|j
index|]
index|]
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_INPADDR_ADDRESS
case|:
name|where
operator|=
operator|&
name|inpaddr_address_reload_insns
index|[
name|reload_opnum
index|[
name|j
index|]
index|]
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OUTPUT_ADDRESS
case|:
name|where
operator|=
operator|&
name|output_address_reload_insns
index|[
name|reload_opnum
index|[
name|j
index|]
index|]
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OUTADDR_ADDRESS
case|:
name|where
operator|=
operator|&
name|outaddr_address_reload_insns
index|[
name|reload_opnum
index|[
name|j
index|]
index|]
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OPERAND_ADDRESS
case|:
name|where
operator|=
operator|&
name|operand_reload_insns
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OPADDR_ADDR
case|:
name|where
operator|=
operator|&
name|other_operand_reload_insns
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OTHER_ADDRESS
case|:
name|where
operator|=
operator|&
name|other_input_address_reload_insns
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|push_to_sequence
argument_list|(
operator|*
name|where
argument_list|)
expr_stmt|;
name|special
operator|=
literal|0
expr_stmt|;
comment|/* Auto-increment addresses must be reloaded in a special way.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|oldequiv
argument_list|)
operator|==
name|POST_INC
operator|||
name|GET_CODE
argument_list|(
name|oldequiv
argument_list|)
operator|==
name|POST_DEC
operator|||
name|GET_CODE
argument_list|(
name|oldequiv
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|oldequiv
argument_list|)
operator|==
name|PRE_DEC
condition|)
block|{
comment|/* We are not going to bother supporting the case where a 		 incremented register can't be copied directly from 		 OLDEQUIV since this seems highly unlikely.  */
if|if
condition|(
name|reload_secondary_in_reload
index|[
name|j
index|]
operator|>=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Prevent normal processing of this reload.  */
name|special
operator|=
literal|1
expr_stmt|;
comment|/* Output a special code sequence for this case.  */
name|inc_for_reload
argument_list|(
name|reloadreg
argument_list|,
name|oldequiv
argument_list|,
name|reload_inc
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* If we are reloading a pseudo-register that was set by the previous 	     insn, see if we can get rid of that pseudo-register entirely 	     by redirecting the previous insn into our reload register.  */
elseif|else
if|if
condition|(
name|optimize
operator|&&
name|GET_CODE
argument_list|(
name|old
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|old
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|dead_or_set_p
argument_list|(
name|insn
argument_list|,
name|old
argument_list|)
comment|/* This is unsafe if some other reload 		      uses the same reg first.  */
operator|&&
name|reload_reg_free_before_p
argument_list|(
name|REGNO
argument_list|(
name|reloadreg
argument_list|)
argument_list|,
name|reload_opnum
index|[
name|j
index|]
argument_list|,
name|reload_when_needed
index|[
name|j
index|]
argument_list|)
condition|)
block|{
name|rtx
name|temp
init|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
while|while
condition|(
name|temp
operator|&&
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|NOTE
condition|)
name|temp
operator|=
name|PREV_INSN
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|&&
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|==
name|old
comment|/* Make sure we can access insn_operand_constraint.  */
operator|&&
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|<
literal|0
comment|/* This is unsafe if prev insn rejects our reload reg.  */
operator|&&
name|constraint_accepts_reg_p
argument_list|(
name|insn_operand_constraint
index|[
name|recog_memoized
argument_list|(
name|temp
argument_list|)
index|]
index|[
literal|0
index|]
argument_list|,
name|reloadreg
argument_list|)
comment|/* This is unsafe if operand occurs more than once in current 		     insn.  Perhaps some occurrences aren't reloaded.  */
operator|&&
name|count_occurrences
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|old
argument_list|)
operator|==
literal|1
comment|/* Don't risk splitting a matching pair of operands.  */
operator|&&
operator|!
name|reg_mentioned_p
argument_list|(
name|old
argument_list|,
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|temp
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Store into the reload register instead of the pseudo.  */
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|=
name|reloadreg
expr_stmt|;
comment|/* If these are the only uses of the pseudo reg, 		     pretend for GDB it lives in the reload reg we used.  */
if|if
condition|(
name|REG_N_DEATHS
argument_list|(
name|REGNO
argument_list|(
name|old
argument_list|)
argument_list|)
operator|==
literal|1
operator|&&
name|REG_N_SETS
argument_list|(
name|REGNO
argument_list|(
name|old
argument_list|)
argument_list|)
operator|==
literal|1
condition|)
block|{
name|reg_renumber
index|[
name|REGNO
argument_list|(
name|old
argument_list|)
index|]
operator|=
name|REGNO
argument_list|(
name|reload_reg_rtx
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|alter_reg
argument_list|(
name|REGNO
argument_list|(
name|old
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|special
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* We can't do that, so output an insn to load RELOADREG.  */
if|if
condition|(
operator|!
name|special
condition|)
block|{
ifdef|#
directive|ifdef
name|SECONDARY_INPUT_RELOAD_CLASS
name|rtx
name|second_reload_reg
init|=
literal|0
decl_stmt|;
name|enum
name|insn_code
name|icode
decl_stmt|;
comment|/* If we have a secondary reload, pick up the secondary register 		 and icode, if any.  If OLDEQUIV and OLD are different or 		 if this is an in-out reload, recompute whether or not we 		 still need a secondary register and what the icode should 		 be.  If we still need a secondary register and the class or 		 icode is different, go back to reloading from OLD if using 		 OLDEQUIV means that we got the wrong type of register.  We 		 cannot have different class or icode due to an in-out reload 		 because we don't make such reloads when both the input and 		 output need secondary reload registers.  */
if|if
condition|(
name|reload_secondary_in_reload
index|[
name|j
index|]
operator|>=
literal|0
condition|)
block|{
name|int
name|secondary_reload
init|=
name|reload_secondary_in_reload
index|[
name|j
index|]
decl_stmt|;
name|rtx
name|real_oldequiv
init|=
name|oldequiv
decl_stmt|;
name|rtx
name|real_old
init|=
name|old
decl_stmt|;
comment|/* If OLDEQUIV is a pseudo with a MEM, get the real MEM 		     and similarly for OLD. 		     See comments in get_secondary_reload in reload.c.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|oldequiv
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|oldequiv
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_equiv_mem
index|[
name|REGNO
argument_list|(
name|oldequiv
argument_list|)
index|]
operator|!=
literal|0
condition|)
name|real_oldequiv
operator|=
name|reg_equiv_mem
index|[
name|REGNO
argument_list|(
name|oldequiv
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|old
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|old
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_equiv_mem
index|[
name|REGNO
argument_list|(
name|old
argument_list|)
index|]
operator|!=
literal|0
condition|)
name|real_old
operator|=
name|reg_equiv_mem
index|[
name|REGNO
argument_list|(
name|old
argument_list|)
index|]
expr_stmt|;
name|second_reload_reg
operator|=
name|reload_reg_rtx
index|[
name|secondary_reload
index|]
expr_stmt|;
name|icode
operator|=
name|reload_secondary_in_icode
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|old
operator|!=
name|oldequiv
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|old
argument_list|,
name|oldequiv
argument_list|)
operator|)
operator|||
operator|(
name|reload_in
index|[
name|j
index|]
operator|!=
literal|0
operator|&&
name|reload_out
index|[
name|j
index|]
operator|!=
literal|0
operator|)
condition|)
block|{
name|enum
name|reg_class
name|new_class
init|=
name|SECONDARY_INPUT_RELOAD_CLASS
argument_list|(
name|reload_reg_class
index|[
name|j
index|]
argument_list|,
name|mode
argument_list|,
name|real_oldequiv
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_class
operator|==
name|NO_REGS
condition|)
name|second_reload_reg
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|enum
name|insn_code
name|new_icode
decl_stmt|;
name|enum
name|machine_mode
name|new_mode
decl_stmt|;
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|new_class
index|]
argument_list|,
name|REGNO
argument_list|(
name|second_reload_reg
argument_list|)
argument_list|)
condition|)
name|oldequiv
operator|=
name|old
operator|,
name|real_oldequiv
operator|=
name|real_old
expr_stmt|;
else|else
block|{
name|new_icode
operator|=
name|reload_in_optab
index|[
operator|(
name|int
operator|)
name|mode
index|]
expr_stmt|;
if|if
condition|(
name|new_icode
operator|!=
name|CODE_FOR_nothing
operator|&&
operator|(
operator|(
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|new_icode
index|]
index|[
literal|0
index|]
operator|&&
operator|!
operator|(
call|(
modifier|*
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|new_icode
index|]
index|[
literal|0
index|]
call|)
argument_list|(
name|reloadreg
argument_list|,
name|mode
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|new_icode
index|]
index|[
literal|1
index|]
operator|&&
operator|!
operator|(
call|(
modifier|*
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|new_icode
index|]
index|[
literal|1
index|]
call|)
argument_list|(
name|real_oldequiv
argument_list|,
name|mode
argument_list|)
operator|)
operator|)
operator|)
condition|)
name|new_icode
operator|=
name|CODE_FOR_nothing
expr_stmt|;
if|if
condition|(
name|new_icode
operator|==
name|CODE_FOR_nothing
condition|)
name|new_mode
operator|=
name|mode
expr_stmt|;
else|else
name|new_mode
operator|=
name|insn_operand_mode
index|[
operator|(
name|int
operator|)
name|new_icode
index|]
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|second_reload_reg
argument_list|)
operator|!=
name|new_mode
condition|)
block|{
if|if
condition|(
operator|!
name|HARD_REGNO_MODE_OK
argument_list|(
name|REGNO
argument_list|(
name|second_reload_reg
argument_list|)
argument_list|,
name|new_mode
argument_list|)
condition|)
name|oldequiv
operator|=
name|old
operator|,
name|real_oldequiv
operator|=
name|real_old
expr_stmt|;
else|else
name|second_reload_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|new_mode
argument_list|,
name|REGNO
argument_list|(
name|second_reload_reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* If we still need a secondary reload register, check 		     to see if it is being used as a scratch or intermediate 		     register and generate code appropriately.  If we need 		     a scratch register, use REAL_OLDEQUIV since the form of 		     the insn may depend on the actual address if it is  		     a MEM.  */
if|if
condition|(
name|second_reload_reg
condition|)
block|{
if|if
condition|(
name|icode
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|emit_insn
argument_list|(
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|reloadreg
argument_list|,
name|real_oldequiv
argument_list|,
name|second_reload_reg
argument_list|)
argument_list|)
expr_stmt|;
name|special
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* See if we need a scratch register to load the 			     intermediate register (a tertiary reload).  */
name|enum
name|insn_code
name|tertiary_icode
init|=
name|reload_secondary_in_icode
index|[
name|secondary_reload
index|]
decl_stmt|;
if|if
condition|(
name|tertiary_icode
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|rtx
name|third_reload_reg
init|=
name|reload_reg_rtx
index|[
name|reload_secondary_in_reload
index|[
name|secondary_reload
index|]
index|]
decl_stmt|;
name|emit_insn
argument_list|(
operator|(
name|GEN_FCN
argument_list|(
name|tertiary_icode
argument_list|)
argument_list|(
name|second_reload_reg
argument_list|,
name|real_oldequiv
argument_list|,
name|third_reload_reg
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
name|gen_reload
argument_list|(
name|second_reload_reg
argument_list|,
name|oldequiv
argument_list|,
name|reload_opnum
index|[
name|j
index|]
argument_list|,
name|reload_when_needed
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|oldequiv
operator|=
name|second_reload_reg
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|special
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|reloadreg
argument_list|,
name|oldequiv
argument_list|)
condition|)
name|gen_reload
argument_list|(
name|reloadreg
argument_list|,
name|oldequiv
argument_list|,
name|reload_opnum
index|[
name|j
index|]
argument_list|,
name|reload_when_needed
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SECONDARY_INPUT_RELOAD_CLASS
argument_list|)
operator|&&
name|defined
argument_list|(
name|PRESERVE_DEATH_INFO_REGNO_P
argument_list|)
comment|/* We may have to make a REG_DEAD note for the secondary reload 		 register in the insns we just made.  Find the last insn that 		 mentioned the register.  */
if|if
condition|(
operator|!
name|special
operator|&&
name|second_reload_reg
operator|&&
name|PRESERVE_DEATH_INFO_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|second_reload_reg
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|prev
decl_stmt|;
for|for
control|(
name|prev
operator|=
name|get_last_insn
argument_list|()
init|;
name|prev
condition|;
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|prev
argument_list|)
control|)
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|prev
argument_list|)
operator|==
literal|'i'
argument_list|)
operator|&&
name|reg_overlap_mentioned_for_reload_p
argument_list|(
name|second_reload_reg
argument_list|,
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|)
condition|)
block|{
name|REG_NOTES
argument_list|(
name|prev
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_DEAD
argument_list|,
name|second_reload_reg
argument_list|,
name|REG_NOTES
argument_list|(
name|prev
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
endif|#
directive|endif
block|}
name|this_reload_insn
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
comment|/* End this sequence.  */
operator|*
name|where
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
block|}
comment|/* When inheriting a wider reload, we have a MEM in reload_in[j], 	 e.g. inheriting a SImode output reload for 	 (mem:HI (plus:SI (reg:SI 14 fp) (const_int 10)))  */
if|if
condition|(
name|optimize
operator|&&
name|reload_inherited
index|[
name|j
index|]
operator|&&
name|reload_in
index|[
name|j
index|]
operator|&&
name|GET_CODE
argument_list|(
name|reload_in
index|[
name|j
index|]
argument_list|)
operator|==
name|MEM
operator|&&
name|reload_spill_index
index|[
name|j
index|]
operator|>=
literal|0
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_reloaded_valid
argument_list|,
name|reload_spill_index
index|[
name|j
index|]
argument_list|)
condition|)
block|{
name|expect_occurrences
operator|=
name|count_occurrences
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|reload_in
index|[
name|j
index|]
argument_list|)
operator|==
literal|1
condition|?
literal|0
else|:
operator|-
literal|1
expr_stmt|;
name|reload_in
index|[
name|j
index|]
operator|=
name|regno_reg_rtx
index|[
name|reg_reloaded_contents
index|[
name|reload_spill_index
index|[
name|j
index|]
index|]
index|]
expr_stmt|;
block|}
comment|/* Add a note saying the input reload reg 	 dies in this insn, if anyone cares.  */
ifdef|#
directive|ifdef
name|PRESERVE_DEATH_INFO_REGNO_P
if|if
condition|(
name|old
operator|!=
literal|0
operator|&&
name|reload_reg_rtx
index|[
name|j
index|]
operator|!=
name|old
operator|&&
name|reload_reg_rtx
index|[
name|j
index|]
operator|!=
literal|0
operator|&&
name|reload_out
index|[
name|j
index|]
operator|==
literal|0
operator|&&
operator|!
name|reload_inherited
index|[
name|j
index|]
operator|&&
name|PRESERVE_DEATH_INFO_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|reload_reg_rtx
index|[
name|j
index|]
argument_list|)
argument_list|)
condition|)
block|{
specifier|register
name|rtx
name|reloadreg
init|=
name|reload_reg_rtx
index|[
name|j
index|]
decl_stmt|;
if|#
directive|if
literal|0
comment|/* We can't abort here because we need to support this for sched.c. 	     It's not terrible to miss a REG_DEAD note, but we should try 	     to figure out how to do this correctly.  */
comment|/* The code below is incorrect for address-only reloads.  */
block|if (reload_when_needed[j] != RELOAD_OTHER&& reload_when_needed[j] != RELOAD_FOR_INPUT) 	    abort ();
endif|#
directive|endif
comment|/* Add a death note to this insn, for an input reload.  */
if|if
condition|(
operator|(
name|reload_when_needed
index|[
name|j
index|]
operator|==
name|RELOAD_OTHER
operator|||
name|reload_when_needed
index|[
name|j
index|]
operator|==
name|RELOAD_FOR_INPUT
operator|)
operator|&&
operator|!
name|dead_or_set_p
argument_list|(
name|insn
argument_list|,
name|reloadreg
argument_list|)
condition|)
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_DEAD
argument_list|,
name|reloadreg
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* When we inherit a reload, the last marked death of the reload reg 	 may no longer really be a death.  */
if|if
condition|(
name|reload_reg_rtx
index|[
name|j
index|]
operator|!=
literal|0
operator|&&
name|PRESERVE_DEATH_INFO_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|reload_reg_rtx
index|[
name|j
index|]
argument_list|)
argument_list|)
operator|&&
name|reload_inherited
index|[
name|j
index|]
condition|)
block|{
comment|/* Handle inheriting an output reload. 	     Remove the death note from the output reload insn.  */
if|if
condition|(
name|reload_spill_index
index|[
name|j
index|]
operator|>=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|reload_in
index|[
name|j
index|]
argument_list|)
operator|==
name|REG
operator|&&
name|spill_reg_store
index|[
name|reload_spill_index
index|[
name|j
index|]
index|]
operator|!=
literal|0
operator|&&
name|find_regno_note
argument_list|(
name|spill_reg_store
index|[
name|reload_spill_index
index|[
name|j
index|]
index|]
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
name|reload_reg_rtx
index|[
name|j
index|]
argument_list|)
argument_list|)
condition|)
name|remove_death
argument_list|(
name|REGNO
argument_list|(
name|reload_reg_rtx
index|[
name|j
index|]
argument_list|)
argument_list|,
name|spill_reg_store
index|[
name|reload_spill_index
index|[
name|j
index|]
index|]
argument_list|)
expr_stmt|;
comment|/* Likewise for input reloads that were inherited.  */
elseif|else
if|if
condition|(
name|reload_spill_index
index|[
name|j
index|]
operator|>=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|reload_in
index|[
name|j
index|]
argument_list|)
operator|==
name|REG
operator|&&
name|spill_reg_store
index|[
name|reload_spill_index
index|[
name|j
index|]
index|]
operator|==
literal|0
operator|&&
name|reload_inheritance_insn
index|[
name|j
index|]
operator|!=
literal|0
operator|&&
name|find_regno_note
argument_list|(
name|reload_inheritance_insn
index|[
name|j
index|]
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
name|reload_reg_rtx
index|[
name|j
index|]
argument_list|)
argument_list|)
condition|)
name|remove_death
argument_list|(
name|REGNO
argument_list|(
name|reload_reg_rtx
index|[
name|j
index|]
argument_list|)
argument_list|,
name|reload_inheritance_insn
index|[
name|j
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|rtx
name|prev
decl_stmt|;
comment|/* We got this register from find_equiv_reg. 		 Search back for its last death note and get rid of it. 		 But don't search back too far. 		 Don't go past a place where this reg is set, 		 since a death note before that remains valid.  */
for|for
control|(
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
init|;
name|prev
operator|&&
name|GET_CODE
argument_list|(
name|prev
argument_list|)
operator|!=
name|CODE_LABEL
condition|;
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|prev
argument_list|)
control|)
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|prev
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
name|dead_or_set_p
argument_list|(
name|prev
argument_list|,
name|reload_reg_rtx
index|[
name|j
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|find_regno_note
argument_list|(
name|prev
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
name|reload_reg_rtx
index|[
name|j
index|]
argument_list|)
argument_list|)
condition|)
name|remove_death
argument_list|(
name|REGNO
argument_list|(
name|reload_reg_rtx
index|[
name|j
index|]
argument_list|)
argument_list|,
name|prev
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* We might have used find_equiv_reg above to choose an alternate 	 place from which to reload.  If so, and it died, we need to remove 	 that death and move it to one of the insns we just made.  */
if|if
condition|(
name|oldequiv_reg
operator|!=
literal|0
operator|&&
name|PRESERVE_DEATH_INFO_REGNO_P
argument_list|(
name|true_regnum
argument_list|(
name|oldequiv_reg
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|prev
decl_stmt|,
name|prev1
decl_stmt|;
for|for
control|(
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
init|;
name|prev
operator|&&
name|GET_CODE
argument_list|(
name|prev
argument_list|)
operator|!=
name|CODE_LABEL
condition|;
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|prev
argument_list|)
control|)
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|prev
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
name|dead_or_set_p
argument_list|(
name|prev
argument_list|,
name|oldequiv_reg
argument_list|)
condition|)
block|{
if|if
condition|(
name|find_regno_note
argument_list|(
name|prev
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
name|oldequiv_reg
argument_list|)
argument_list|)
condition|)
block|{
for|for
control|(
name|prev1
operator|=
name|this_reload_insn
init|;
name|prev1
condition|;
name|prev1
operator|=
name|PREV_INSN
argument_list|(
name|prev1
argument_list|)
control|)
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|prev1
argument_list|)
operator|==
literal|'i'
argument_list|)
operator|&&
name|reg_overlap_mentioned_for_reload_p
argument_list|(
name|oldequiv_reg
argument_list|,
name|PATTERN
argument_list|(
name|prev1
argument_list|)
argument_list|)
condition|)
block|{
name|REG_NOTES
argument_list|(
name|prev1
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_DEAD
argument_list|,
name|oldequiv_reg
argument_list|,
name|REG_NOTES
argument_list|(
name|prev1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|remove_death
argument_list|(
name|REGNO
argument_list|(
name|oldequiv_reg
argument_list|)
argument_list|,
name|prev
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
endif|#
directive|endif
comment|/* If we are reloading a register that was recently stored in with an 	 output-reload, see if we can prove there was 	 actually no need to store the old value in it.  */
if|if
condition|(
name|optimize
operator|&&
name|reload_inherited
index|[
name|j
index|]
operator|&&
name|reload_spill_index
index|[
name|j
index|]
operator|>=
literal|0
operator|&&
name|reload_in
index|[
name|j
index|]
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|reload_in
index|[
name|j
index|]
argument_list|)
operator|==
name|REG
if|#
directive|if
literal|0
comment|/* There doesn't seem to be any reason to restrict this to pseudos 	     and doing so loses in the case where we are copying from a 	     register of the wrong class.  */
expr|&& REGNO (reload_in[j])>= FIRST_PSEUDO_REGISTER
endif|#
directive|endif
operator|&&
name|spill_reg_store
index|[
name|reload_spill_index
index|[
name|j
index|]
index|]
operator|!=
literal|0
comment|/* This is unsafe if some other reload uses the same reg first.  */
operator|&&
name|reload_reg_free_before_p
argument_list|(
name|reload_spill_index
index|[
name|j
index|]
argument_list|,
name|reload_opnum
index|[
name|j
index|]
argument_list|,
name|reload_when_needed
index|[
name|j
index|]
argument_list|)
operator|&&
name|dead_or_set_p
argument_list|(
name|insn
argument_list|,
name|reload_in
index|[
name|j
index|]
argument_list|)
comment|/* This is unsafe if operand occurs more than once in current 	     insn.  Perhaps some occurrences weren't reloaded.  */
operator|&&
operator|(
name|count_occurrences
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|reload_in
index|[
name|j
index|]
argument_list|)
operator|==
name|expect_occurrences
operator|)
condition|)
name|delete_output_reload
argument_list|(
name|insn
argument_list|,
name|j
argument_list|,
name|spill_reg_store
index|[
name|reload_spill_index
index|[
name|j
index|]
index|]
argument_list|)
expr_stmt|;
comment|/* Input-reloading is done.  Now do output-reloading, 	 storing the value from the reload-register after the main insn 	 if reload_out[j] is nonzero.  	 ??? At some point we need to support handling output reloads of 	 JUMP_INSNs or insns that set cc0.  */
name|old
operator|=
name|reload_out
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|old
operator|!=
literal|0
operator|&&
name|reload_reg_rtx
index|[
name|j
index|]
operator|!=
name|old
operator|&&
name|reload_reg_rtx
index|[
name|j
index|]
operator|!=
literal|0
condition|)
block|{
specifier|register
name|rtx
name|reloadreg
init|=
name|reload_reg_rtx
index|[
name|j
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|SECONDARY_OUTPUT_RELOAD_CLASS
specifier|register
name|rtx
name|second_reloadreg
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|rtx
name|note
decl_stmt|,
name|p
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|special
init|=
literal|0
decl_stmt|;
comment|/* An output operand that dies right away does need a reload, 	     but need not be copied from it.  Show the new location in the 	     REG_UNUSED note.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|old
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|old
argument_list|)
operator|==
name|SCRATCH
operator|)
operator|&&
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_UNUSED
argument_list|,
name|old
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
operator|=
name|reload_reg_rtx
index|[
name|j
index|]
expr_stmt|;
continue|continue;
block|}
comment|/* Likewise for a SUBREG of an operand that dies.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|old
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|old
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
literal|0
operator|!=
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_UNUSED
argument_list|,
name|SUBREG_REG
argument_list|(
name|old
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
operator|=
name|gen_lowpart_common
argument_list|(
name|GET_MODE
argument_list|(
name|old
argument_list|)
argument_list|,
name|reload_reg_rtx
index|[
name|j
index|]
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|old
argument_list|)
operator|==
name|SCRATCH
condition|)
comment|/* If we aren't optimizing, there won't be a REG_UNUSED note, 	       but we don't want to make an output reload.  */
continue|continue;
if|#
directive|if
literal|0
comment|/* Strip off of OLD any size-increasing SUBREGs such as 	     (SUBREG:SI foo:QI 0).  */
block|while (GET_CODE (old) == SUBREG&& SUBREG_WORD (old) == 0&& (GET_MODE_SIZE (GET_MODE (old))> GET_MODE_SIZE (GET_MODE (SUBREG_REG (old))))) 	    old = SUBREG_REG (old);
endif|#
directive|endif
comment|/* If is a JUMP_INSN, we can't support output reloads yet.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|reload_when_needed
index|[
name|j
index|]
operator|==
name|RELOAD_OTHER
condition|)
name|start_sequence
argument_list|()
expr_stmt|;
else|else
name|push_to_sequence
argument_list|(
name|output_reload_insns
index|[
name|reload_opnum
index|[
name|j
index|]
index|]
argument_list|)
expr_stmt|;
comment|/* Determine the mode to reload in. 	     See comments above (for input reloading).  */
name|mode
operator|=
name|GET_MODE
argument_list|(
name|old
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
block|{
comment|/* VOIDmode should never happen for an output.  */
if|if
condition|(
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
comment|/* It's the compiler's fault.  */
name|fatal_insn
argument_list|(
literal|"VOIDmode on an output"
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|error_for_asm
argument_list|(
name|insn
argument_list|,
literal|"output operand is constant in `asm'"
argument_list|)
expr_stmt|;
comment|/* Prevent crash--use something we know is valid.  */
name|mode
operator|=
name|word_mode
expr_stmt|;
name|old
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|REGNO
argument_list|(
name|reloadreg
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_MODE
argument_list|(
name|reloadreg
argument_list|)
operator|!=
name|mode
condition|)
name|reloadreg
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|REGNO
argument_list|(
name|reloadreg
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SECONDARY_OUTPUT_RELOAD_CLASS
comment|/* If we need two reload regs, set RELOADREG to the intermediate 	     one, since it will be stored into OLD.  We might need a secondary 	     register only for an input reload, so check again here.  */
if|if
condition|(
name|reload_secondary_out_reload
index|[
name|j
index|]
operator|>=
literal|0
condition|)
block|{
name|rtx
name|real_old
init|=
name|old
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|old
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|old
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_equiv_mem
index|[
name|REGNO
argument_list|(
name|old
argument_list|)
index|]
operator|!=
literal|0
condition|)
name|real_old
operator|=
name|reg_equiv_mem
index|[
name|REGNO
argument_list|(
name|old
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|SECONDARY_OUTPUT_RELOAD_CLASS
argument_list|(
name|reload_reg_class
index|[
name|j
index|]
argument_list|,
name|mode
argument_list|,
name|real_old
argument_list|)
operator|!=
name|NO_REGS
operator|)
condition|)
block|{
name|second_reloadreg
operator|=
name|reloadreg
expr_stmt|;
name|reloadreg
operator|=
name|reload_reg_rtx
index|[
name|reload_secondary_out_reload
index|[
name|j
index|]
index|]
expr_stmt|;
comment|/* See if RELOADREG is to be used as a scratch register 		     or as an intermediate register.  */
if|if
condition|(
name|reload_secondary_out_icode
index|[
name|j
index|]
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|emit_insn
argument_list|(
operator|(
name|GEN_FCN
argument_list|(
name|reload_secondary_out_icode
index|[
name|j
index|]
argument_list|)
argument_list|(
name|real_old
argument_list|,
name|second_reloadreg
argument_list|,
name|reloadreg
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|special
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* See if we need both a scratch and intermediate reload 			 register.  */
name|int
name|secondary_reload
init|=
name|reload_secondary_out_reload
index|[
name|j
index|]
decl_stmt|;
name|enum
name|insn_code
name|tertiary_icode
init|=
name|reload_secondary_out_icode
index|[
name|secondary_reload
index|]
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|reloadreg
argument_list|)
operator|!=
name|mode
condition|)
name|reloadreg
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|REGNO
argument_list|(
name|reloadreg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tertiary_icode
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|rtx
name|third_reloadreg
init|=
name|reload_reg_rtx
index|[
name|reload_secondary_out_reload
index|[
name|secondary_reload
index|]
index|]
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
comment|/* Copy primary reload reg to secondary reload reg. 			     (Note that these have been swapped above, then 			     secondary reload reg to OLD using our insn.  */
comment|/* If REAL_OLD is a paradoxical SUBREG, remove it 			     and try to put the opposite SUBREG on 			     RELOADREG.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|real_old
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|real_old
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|real_old
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
literal|0
operator|!=
operator|(
name|tem
operator|=
name|gen_lowpart_common
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|real_old
argument_list|)
argument_list|)
argument_list|,
name|reloadreg
argument_list|)
operator|)
condition|)
name|real_old
operator|=
name|SUBREG_REG
argument_list|(
name|real_old
argument_list|)
operator|,
name|reloadreg
operator|=
name|tem
expr_stmt|;
name|gen_reload
argument_list|(
name|reloadreg
argument_list|,
name|second_reloadreg
argument_list|,
name|reload_opnum
index|[
name|j
index|]
argument_list|,
name|reload_when_needed
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
operator|(
name|GEN_FCN
argument_list|(
name|tertiary_icode
argument_list|)
argument_list|(
name|real_old
argument_list|,
name|reloadreg
argument_list|,
name|third_reloadreg
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|special
operator|=
literal|1
expr_stmt|;
block|}
else|else
comment|/* Copy between the reload regs here and then to 			   OUT later.  */
name|gen_reload
argument_list|(
name|reloadreg
argument_list|,
name|second_reloadreg
argument_list|,
name|reload_opnum
index|[
name|j
index|]
argument_list|,
name|reload_when_needed
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* Output the last reload insn.  */
if|if
condition|(
operator|!
name|special
condition|)
block|{
name|rtx
name|set
decl_stmt|;
comment|/* Don't output the last reload if OLD is not the dest of 		 INSN and is in the src and is clobbered by INSN. */
if|if
condition|(
operator|!
name|flag_expensive_optimizations
operator|||
name|GET_CODE
argument_list|(
name|old
argument_list|)
operator|!=
name|REG
operator|||
operator|!
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
operator|)
operator|||
name|rtx_equal_p
argument_list|(
name|old
argument_list|,
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|||
operator|!
name|reg_mentioned_p
argument_list|(
name|old
argument_list|,
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|||
operator|!
name|regno_clobbered_p
argument_list|(
name|REGNO
argument_list|(
name|old
argument_list|)
argument_list|,
name|insn
argument_list|)
condition|)
name|gen_reload
argument_list|(
name|old
argument_list|,
name|reloadreg
argument_list|,
name|reload_opnum
index|[
name|j
index|]
argument_list|,
name|reload_when_needed
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PRESERVE_DEATH_INFO_REGNO_P
comment|/* If final will look at death notes for this reg, 	     put one on the last output-reload insn to use it.  Similarly 	     for any secondary register.  */
if|if
condition|(
name|PRESERVE_DEATH_INFO_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|reloadreg
argument_list|)
argument_list|)
condition|)
for|for
control|(
name|p
operator|=
name|get_last_insn
argument_list|()
init|;
name|p
condition|;
name|p
operator|=
name|PREV_INSN
argument_list|(
name|p
argument_list|)
control|)
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
name|reg_overlap_mentioned_for_reload_p
argument_list|(
name|reloadreg
argument_list|,
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
name|REG_NOTES
argument_list|(
name|p
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_DEAD
argument_list|,
name|reloadreg
argument_list|,
name|REG_NOTES
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SECONDARY_OUTPUT_RELOAD_CLASS
if|if
condition|(
operator|!
name|special
operator|&&
name|second_reloadreg
operator|&&
name|PRESERVE_DEATH_INFO_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|second_reloadreg
argument_list|)
argument_list|)
condition|)
for|for
control|(
name|p
operator|=
name|get_last_insn
argument_list|()
init|;
name|p
condition|;
name|p
operator|=
name|PREV_INSN
argument_list|(
name|p
argument_list|)
control|)
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
name|reg_overlap_mentioned_for_reload_p
argument_list|(
name|second_reloadreg
argument_list|,
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
name|REG_NOTES
argument_list|(
name|p
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_DEAD
argument_list|,
name|second_reloadreg
argument_list|,
name|REG_NOTES
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* Look at all insns we emitted, just to be safe.  */
for|for
control|(
name|p
operator|=
name|get_insns
argument_list|()
init|;
name|p
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|p
argument_list|)
decl_stmt|;
comment|/* If this output reload doesn't come from a spill reg, 		   clear any memory of reloaded copies of the pseudo reg. 		   If this output reload comes from a spill reg, 		   reg_has_output_reload will make this do nothing.  */
name|note_stores
argument_list|(
name|pat
argument_list|,
name|forget_old_reloads_1
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|reload_reg_rtx
index|[
name|j
index|]
argument_list|,
name|pat
argument_list|)
condition|)
block|{
if|if
condition|(
name|reload_spill_index
index|[
name|j
index|]
operator|<
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
operator|&&
name|SET_SRC
argument_list|(
name|pat
argument_list|)
operator|==
name|reload_reg_rtx
index|[
name|j
index|]
condition|)
block|{
name|int
name|src
init|=
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
decl_stmt|;
name|reload_spill_index
index|[
name|j
index|]
operator|=
name|src
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|reg_is_output_reload
argument_list|,
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|src
argument_list|)
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|reg_reloaded_died
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reload_spill_index
index|[
name|j
index|]
operator|>=
literal|0
condition|)
block|{
name|int
name|s
init|=
name|reload_secondary_out_reload
index|[
name|j
index|]
decl_stmt|;
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|p
argument_list|)
decl_stmt|;
comment|/* If this reload copies only to the secondary reload 			   register, the secondary reload does the actual 			   store.  */
if|if
condition|(
name|s
operator|>=
literal|0
operator|&&
name|set
operator|==
name|NULL_RTX
condition|)
empty_stmt|;
comment|/* We can't tell what function the secondary reload 			       has and where the actual store to the pseudo is 			       made; leave new_spill_reg_store alone.  */
elseif|else
if|if
condition|(
name|s
operator|>=
literal|0
operator|&&
name|SET_SRC
argument_list|(
name|set
argument_list|)
operator|==
name|reload_reg_rtx
index|[
name|j
index|]
operator|&&
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|==
name|reload_reg_rtx
index|[
name|s
index|]
condition|)
block|{
comment|/* Usually the next instruction will be the 			       secondary reload insn;  if we can confirm 			       that it is, setting new_spill_reg_store to 			       that insn will allow an extra optimization.  */
name|rtx
name|s_reg
init|=
name|reload_reg_rtx
index|[
name|s
index|]
decl_stmt|;
name|rtx
name|next
init|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|reload_out
index|[
name|s
index|]
operator|=
name|reload_out
index|[
name|j
index|]
expr_stmt|;
name|set
operator|=
name|single_set
argument_list|(
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
operator|&&
name|SET_SRC
argument_list|(
name|set
argument_list|)
operator|==
name|s_reg
operator|&&
operator|!
name|new_spill_reg_store
index|[
name|REGNO
argument_list|(
name|s_reg
argument_list|)
index|]
condition|)
name|new_spill_reg_store
index|[
name|REGNO
argument_list|(
name|s_reg
argument_list|)
index|]
operator|=
name|next
expr_stmt|;
block|}
else|else
name|new_spill_reg_store
index|[
name|reload_spill_index
index|[
name|j
index|]
index|]
operator|=
name|p
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|reload_when_needed
index|[
name|j
index|]
operator|==
name|RELOAD_OTHER
condition|)
block|{
name|emit_insns
argument_list|(
name|other_output_reload_insns
index|[
name|reload_opnum
index|[
name|j
index|]
index|]
argument_list|)
expr_stmt|;
name|other_output_reload_insns
index|[
name|reload_opnum
index|[
name|j
index|]
index|]
operator|=
name|get_insns
argument_list|()
expr_stmt|;
block|}
else|else
name|output_reload_insns
index|[
name|reload_opnum
index|[
name|j
index|]
index|]
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Now write all the insns we made for reloads in the order expected by      the allocation functions.  Prior to the insn being reloaded, we write      the following reloads:       RELOAD_FOR_OTHER_ADDRESS reloads for input addresses.       RELOAD_OTHER reloads.       For each operand, any RELOAD_FOR_INPADDR_ADDRESS reloads followed      by any RELOAD_FOR_INPUT_ADDRESS reloads followed by the      RELOAD_FOR_INPUT reload for the operand.       RELOAD_FOR_OPADDR_ADDRS reloads.       RELOAD_FOR_OPERAND_ADDRESS reloads.       After the insn being reloaded, we write the following:       For each operand, any RELOAD_FOR_OUTADDR_ADDRESS reloads followed      by any RELOAD_FOR_OUTPUT_ADDRESS reload followed by the      RELOAD_FOR_OUTPUT reload, followed by any RELOAD_OTHER output      reloads for the operand.  The RELOAD_OTHER output reloads are      output in descending order by reload number.  */
name|emit_insns_before
argument_list|(
name|other_input_address_reload_insns
argument_list|,
name|before_insn
argument_list|)
expr_stmt|;
name|emit_insns_before
argument_list|(
name|other_input_reload_insns
argument_list|,
name|before_insn
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|reload_n_operands
condition|;
name|j
operator|++
control|)
block|{
name|emit_insns_before
argument_list|(
name|inpaddr_address_reload_insns
index|[
name|j
index|]
argument_list|,
name|before_insn
argument_list|)
expr_stmt|;
name|emit_insns_before
argument_list|(
name|input_address_reload_insns
index|[
name|j
index|]
argument_list|,
name|before_insn
argument_list|)
expr_stmt|;
name|emit_insns_before
argument_list|(
name|input_reload_insns
index|[
name|j
index|]
argument_list|,
name|before_insn
argument_list|)
expr_stmt|;
block|}
name|emit_insns_before
argument_list|(
name|other_operand_reload_insns
argument_list|,
name|before_insn
argument_list|)
expr_stmt|;
name|emit_insns_before
argument_list|(
name|operand_reload_insns
argument_list|,
name|before_insn
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|reload_n_operands
condition|;
name|j
operator|++
control|)
block|{
name|emit_insns_before
argument_list|(
name|outaddr_address_reload_insns
index|[
name|j
index|]
argument_list|,
name|following_insn
argument_list|)
expr_stmt|;
name|emit_insns_before
argument_list|(
name|output_address_reload_insns
index|[
name|j
index|]
argument_list|,
name|following_insn
argument_list|)
expr_stmt|;
name|emit_insns_before
argument_list|(
name|output_reload_insns
index|[
name|j
index|]
argument_list|,
name|following_insn
argument_list|)
expr_stmt|;
name|emit_insns_before
argument_list|(
name|other_output_reload_insns
index|[
name|j
index|]
argument_list|,
name|following_insn
argument_list|)
expr_stmt|;
block|}
comment|/* Move death notes from INSN      to output-operand-address and output reload insns.  */
ifdef|#
directive|ifdef
name|PRESERVE_DEATH_INFO_REGNO_P
block|{
name|rtx
name|insn1
decl_stmt|;
comment|/* Loop over those insns, last ones first.  */
for|for
control|(
name|insn1
operator|=
name|PREV_INSN
argument_list|(
name|following_insn
argument_list|)
init|;
name|insn1
operator|!=
name|insn
condition|;
name|insn1
operator|=
name|PREV_INSN
argument_list|(
name|insn1
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn1
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn1
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
block|{
name|rtx
name|source
init|=
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn1
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn1
argument_list|)
argument_list|)
decl_stmt|;
comment|/* The note we will examine next.  */
name|rtx
name|reg_notes
init|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* The place that pointed to this note.  */
name|rtx
modifier|*
name|prev_reg_note
init|=
operator|&
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* If the note is for something used in the source of this 	     reload insn, or in the output address, move the note.  */
while|while
condition|(
name|reg_notes
condition|)
block|{
name|rtx
name|next_reg_notes
init|=
name|XEXP
argument_list|(
name|reg_notes
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|reg_notes
argument_list|)
operator|==
name|REG_DEAD
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|reg_notes
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|!=
name|REG
operator|&&
name|reg_overlap_mentioned_for_reload_p
argument_list|(
name|XEXP
argument_list|(
name|reg_notes
argument_list|,
literal|0
argument_list|)
argument_list|,
name|dest
argument_list|)
operator|)
operator|||
name|reg_overlap_mentioned_for_reload_p
argument_list|(
name|XEXP
argument_list|(
name|reg_notes
argument_list|,
literal|0
argument_list|)
argument_list|,
name|source
argument_list|)
operator|)
condition|)
block|{
operator|*
name|prev_reg_note
operator|=
name|next_reg_notes
expr_stmt|;
name|XEXP
argument_list|(
name|reg_notes
argument_list|,
literal|1
argument_list|)
operator|=
name|REG_NOTES
argument_list|(
name|insn1
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn1
argument_list|)
operator|=
name|reg_notes
expr_stmt|;
block|}
else|else
name|prev_reg_note
operator|=
operator|&
name|XEXP
argument_list|(
name|reg_notes
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|reg_notes
operator|=
name|next_reg_notes
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* For all the spill regs newly reloaded in this instruction,      record what they were reloaded from, so subsequent instructions      can inherit the reloads.       Update spill_reg_store for the reloads of this insn.      Copy the elements that were updated in the loop above.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_reloads
condition|;
name|j
operator|++
control|)
block|{
specifier|register
name|int
name|r
init|=
name|reload_order
index|[
name|j
index|]
decl_stmt|;
specifier|register
name|int
name|i
init|=
name|reload_spill_index
index|[
name|r
index|]
decl_stmt|;
comment|/* I is nonneg if this reload used a register. 	 If reload_reg_rtx[r] is 0, this is an optional reload 	 that we opted to ignore.  */
if|if
condition|(
name|i
operator|>=
literal|0
operator|&&
name|reload_reg_rtx
index|[
name|r
index|]
operator|!=
literal|0
condition|)
block|{
name|int
name|nr
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|i
argument_list|,
name|GET_MODE
argument_list|(
name|reload_reg_rtx
index|[
name|r
index|]
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|k
decl_stmt|;
name|int
name|part_reaches_end
init|=
literal|0
decl_stmt|;
name|int
name|all_reaches_end
init|=
literal|1
decl_stmt|;
comment|/* For a multi register reload, we need to check if all or part 	     of the value lives to the end.  */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|nr
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|reload_reg_reaches_end_p
argument_list|(
name|i
operator|+
name|k
argument_list|,
name|reload_opnum
index|[
name|r
index|]
argument_list|,
name|reload_when_needed
index|[
name|r
index|]
argument_list|)
condition|)
name|part_reaches_end
operator|=
literal|1
expr_stmt|;
else|else
name|all_reaches_end
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Ignore reloads that don't reach the end of the insn in 	     entirety.  */
if|if
condition|(
name|all_reaches_end
condition|)
block|{
comment|/* First, clear out memory of what used to be in this spill reg. 		 If consecutive registers are used, clear them all.  */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|nr
condition|;
name|k
operator|++
control|)
name|CLEAR_HARD_REG_BIT
argument_list|(
name|reg_reloaded_valid
argument_list|,
name|i
operator|+
name|k
argument_list|)
expr_stmt|;
comment|/* Maybe the spill reg contains a copy of reload_out.  */
if|if
condition|(
name|reload_out
index|[
name|r
index|]
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|reload_out
index|[
name|r
index|]
argument_list|)
operator|==
name|REG
condition|)
block|{
specifier|register
name|int
name|nregno
init|=
name|REGNO
argument_list|(
name|reload_out
index|[
name|r
index|]
argument_list|)
decl_stmt|;
name|int
name|nnr
init|=
operator|(
name|nregno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|?
literal|1
else|:
name|HARD_REGNO_NREGS
argument_list|(
name|nregno
argument_list|,
name|GET_MODE
argument_list|(
name|reload_reg_rtx
index|[
name|r
index|]
argument_list|)
argument_list|)
operator|)
decl_stmt|;
name|spill_reg_store
index|[
name|i
index|]
operator|=
name|new_spill_reg_store
index|[
name|i
index|]
expr_stmt|;
name|reg_last_reload_reg
index|[
name|nregno
index|]
operator|=
name|reload_reg_rtx
index|[
name|r
index|]
expr_stmt|;
comment|/* If NREGNO is a hard register, it may occupy more than 		     one register.  If it does, say what is in the  		     rest of the registers assuming that both registers 		     agree on how many words the object takes.  If not, 		     invalidate the subsequent registers.  */
if|if
condition|(
name|nregno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
for|for
control|(
name|k
operator|=
literal|1
init|;
name|k
operator|<
name|nnr
condition|;
name|k
operator|++
control|)
name|reg_last_reload_reg
index|[
name|nregno
operator|+
name|k
index|]
operator|=
operator|(
name|nr
operator|==
name|nnr
condition|?
name|gen_rtx_REG
argument_list|(
name|reg_raw_mode
index|[
name|REGNO
argument_list|(
name|reload_reg_rtx
index|[
name|r
index|]
argument_list|)
operator|+
name|k
index|]
argument_list|,
name|REGNO
argument_list|(
name|reload_reg_rtx
index|[
name|r
index|]
argument_list|)
operator|+
name|k
argument_list|)
else|:
literal|0
operator|)
expr_stmt|;
comment|/* Now do the inverse operation.  */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|nr
condition|;
name|k
operator|++
control|)
block|{
name|CLEAR_HARD_REG_BIT
argument_list|(
name|reg_reloaded_dead
argument_list|,
name|i
operator|+
name|k
argument_list|)
expr_stmt|;
name|reg_reloaded_contents
index|[
name|i
operator|+
name|k
index|]
operator|=
operator|(
name|nregno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
name|nr
operator|!=
name|nnr
condition|?
name|nregno
else|:
name|nregno
operator|+
name|k
operator|)
expr_stmt|;
name|reg_reloaded_insn
index|[
name|i
operator|+
name|k
index|]
operator|=
name|insn
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|reg_reloaded_valid
argument_list|,
name|i
operator|+
name|k
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Maybe the spill reg contains a copy of reload_in.  Only do 		 something if there will not be an output reload for 		 the register being reloaded.  */
elseif|else
if|if
condition|(
name|reload_out
index|[
name|r
index|]
operator|==
literal|0
operator|&&
name|reload_in
index|[
name|r
index|]
operator|!=
literal|0
operator|&&
name|spill_reg_order
index|[
name|i
index|]
operator|>=
literal|0
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|reload_in
index|[
name|r
index|]
argument_list|)
operator|==
name|REG
operator|&&
operator|!
name|reg_has_output_reload
index|[
name|REGNO
argument_list|(
name|reload_in
index|[
name|r
index|]
argument_list|)
index|]
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|reload_in_reg
index|[
name|r
index|]
argument_list|)
operator|==
name|REG
operator|&&
operator|!
name|reg_has_output_reload
index|[
name|REGNO
argument_list|(
name|reload_in_reg
index|[
name|r
index|]
argument_list|)
index|]
operator|)
operator|)
condition|)
block|{
specifier|register
name|int
name|nregno
decl_stmt|;
name|int
name|nnr
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reload_in
index|[
name|r
index|]
argument_list|)
operator|==
name|REG
condition|)
name|nregno
operator|=
name|REGNO
argument_list|(
name|reload_in
index|[
name|r
index|]
argument_list|)
expr_stmt|;
else|else
name|nregno
operator|=
name|REGNO
argument_list|(
name|reload_in_reg
index|[
name|r
index|]
argument_list|)
expr_stmt|;
name|nnr
operator|=
operator|(
name|nregno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|?
literal|1
else|:
name|HARD_REGNO_NREGS
argument_list|(
name|nregno
argument_list|,
name|GET_MODE
argument_list|(
name|reload_reg_rtx
index|[
name|r
index|]
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|reg_last_reload_reg
index|[
name|nregno
index|]
operator|=
name|reload_reg_rtx
index|[
name|r
index|]
expr_stmt|;
if|if
condition|(
name|nregno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
for|for
control|(
name|k
operator|=
literal|1
init|;
name|k
operator|<
name|nnr
condition|;
name|k
operator|++
control|)
name|reg_last_reload_reg
index|[
name|nregno
operator|+
name|k
index|]
operator|=
operator|(
name|nr
operator|==
name|nnr
condition|?
name|gen_rtx_REG
argument_list|(
name|reg_raw_mode
index|[
name|REGNO
argument_list|(
name|reload_reg_rtx
index|[
name|r
index|]
argument_list|)
operator|+
name|k
index|]
argument_list|,
name|REGNO
argument_list|(
name|reload_reg_rtx
index|[
name|r
index|]
argument_list|)
operator|+
name|k
argument_list|)
else|:
literal|0
operator|)
expr_stmt|;
comment|/* Unless we inherited this reload, show we haven't 		     recently done a store.  */
if|if
condition|(
operator|!
name|reload_inherited
index|[
name|r
index|]
condition|)
name|spill_reg_store
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|nr
condition|;
name|k
operator|++
control|)
block|{
name|CLEAR_HARD_REG_BIT
argument_list|(
name|reg_reloaded_dead
argument_list|,
name|i
operator|+
name|k
argument_list|)
expr_stmt|;
name|reg_reloaded_contents
index|[
name|i
operator|+
name|k
index|]
operator|=
operator|(
name|nregno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
name|nr
operator|!=
name|nnr
condition|?
name|nregno
else|:
name|nregno
operator|+
name|k
operator|)
expr_stmt|;
name|reg_reloaded_insn
index|[
name|i
operator|+
name|k
index|]
operator|=
name|insn
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|reg_reloaded_valid
argument_list|,
name|i
operator|+
name|k
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* However, if part of the reload reaches the end, then we must 	     invalidate the old info for the part that survives to the end.  */
elseif|else
if|if
condition|(
name|part_reaches_end
condition|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|nr
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|reload_reg_reaches_end_p
argument_list|(
name|i
operator|+
name|k
argument_list|,
name|reload_opnum
index|[
name|r
index|]
argument_list|,
name|reload_when_needed
index|[
name|r
index|]
argument_list|)
condition|)
name|CLEAR_HARD_REG_BIT
argument_list|(
name|reg_reloaded_valid
argument_list|,
name|i
operator|+
name|k
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* The following if-statement was #if 0'd in 1.34 (or before...). 	 It's reenabled in 1.35 because supposedly nothing else 	 deals with this problem.  */
comment|/* If a register gets output-reloaded from a non-spill register, 	 that invalidates any previous reloaded copy of it. 	 But forget_old_reloads_1 won't get to see it, because 	 it thinks only about the original insn.  So invalidate it here.  */
if|if
condition|(
name|i
operator|<
literal|0
operator|&&
name|reload_out
index|[
name|r
index|]
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|reload_out
index|[
name|r
index|]
argument_list|)
operator|==
name|REG
condition|)
block|{
specifier|register
name|int
name|nregno
init|=
name|REGNO
argument_list|(
name|reload_out
index|[
name|r
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|nregno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|reg_last_reload_reg
index|[
name|nregno
index|]
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|int
name|num_regs
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|nregno
argument_list|,
name|GET_MODE
argument_list|(
name|reload_out
index|[
name|r
index|]
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|num_regs
operator|--
operator|>
literal|0
condition|)
name|reg_last_reload_reg
index|[
name|nregno
operator|+
name|num_regs
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
name|IOR_HARD_REG_SET
argument_list|(
name|reg_reloaded_dead
argument_list|,
name|reg_reloaded_died
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit code to perform a reload from IN (which may be a reload register) to    OUT (which may also be a reload register).  IN or OUT is from operand    OPNUM with reload type TYPE.      Returns first insn emitted.  */
end_comment

begin_function
name|rtx
name|gen_reload
parameter_list|(
name|out
parameter_list|,
name|in
parameter_list|,
name|opnum
parameter_list|,
name|type
parameter_list|)
name|rtx
name|out
decl_stmt|;
name|rtx
name|in
decl_stmt|;
name|int
name|opnum
decl_stmt|;
name|enum
name|reload_type
name|type
decl_stmt|;
block|{
name|rtx
name|last
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
comment|/* If IN is a paradoxical SUBREG, remove it and try to put the      opposite SUBREG on OUT.  Likewise for a paradoxical SUBREG on OUT.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|in
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|tem
operator|=
name|gen_lowpart_common
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|)
argument_list|,
name|out
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|in
operator|=
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
operator|,
name|out
operator|=
name|tem
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|out
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|out
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|out
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|tem
operator|=
name|gen_lowpart_common
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|out
argument_list|)
argument_list|)
argument_list|,
name|in
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|out
operator|=
name|SUBREG_REG
argument_list|(
name|out
argument_list|)
operator|,
name|in
operator|=
name|tem
expr_stmt|;
comment|/* How to do this reload can get quite tricky.  Normally, we are being      asked to reload a simple operand, such as a MEM, a constant, or a pseudo      register that didn't get a hard register.  In that case we can just      call emit_move_insn.       We can also be asked to reload a PLUS that adds a register or a MEM to      another register, constant or MEM.  This can occur during frame pointer      elimination and while reloading addresses.  This case is handled by      trying to emit a single insn to perform the add.  If it is not valid,      we use a two insn sequence.       Finally, we could be called to handle an 'o' constraint by putting      an address into a register.  In that case, we first try to do this      with a named pattern of "reload_load_address".  If no such pattern      exists, we just emit a SET insn and hope for the best (it will normally      be valid on machines that use 'o').       This entire process is made complex because reload will never      process the insns we generate here and so we must ensure that      they will fit their constraints and also by the fact that parts of      IN might be being reloaded separately and replaced with spill registers.      Because of this, we are, in some sense, just guessing the right approach      here.  The one listed above seems to work.       ??? At some point, this whole thing needs to be rethought.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|PLUS
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|in
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|in
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|in
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|in
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|in
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|||
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|in
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|in
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|MEM
operator|)
condition|)
block|{
comment|/* We need to compute the sum of a register or a MEM and another 	 register, constant, or MEM, and put it into the reload 	 register.  The best possible way of doing this is if the machine 	 has a three-operand ADD insn that accepts the required operands.  	 The simplest approach is to try to generate such an insn and see if it 	 is recognized and matches its constraints.  If so, it can be used.  	 It might be better not to actually emit the insn unless it is valid, 	 but we need to pass the insn as an operand to `recog' and 	 `insn_extract' and it is simpler to emit and then delete the insn if 	 not valid than to dummy things up.  */
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|,
name|tem
decl_stmt|,
name|insn
decl_stmt|;
name|int
name|code
decl_stmt|;
name|op0
operator|=
name|find_replacement
argument_list|(
operator|&
name|XEXP
argument_list|(
name|in
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|op1
operator|=
name|find_replacement
argument_list|(
operator|&
name|XEXP
argument_list|(
name|in
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Since constraint checking is strict, commutativity won't be 	 checked, so we need to do that here to avoid spurious failure 	 if the add instruction is two-address and the second operand 	 of the add is the same as the reload reg, which is frequently 	 the case.  If the insn would be A = B + A, rearrange it so 	 it will be A = A + B as constrain_operands expects.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|in
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|out
argument_list|)
operator|==
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|in
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|tem
operator|=
name|op0
operator|,
name|op0
operator|=
name|op1
operator|,
name|op1
operator|=
name|tem
expr_stmt|;
if|if
condition|(
name|op0
operator|!=
name|XEXP
argument_list|(
name|in
argument_list|,
literal|0
argument_list|)
operator|||
name|op1
operator|!=
name|XEXP
argument_list|(
name|in
argument_list|,
literal|1
argument_list|)
condition|)
name|in
operator|=
name|gen_rtx_PLUS
argument_list|(
name|GET_MODE
argument_list|(
name|in
argument_list|)
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|out
argument_list|,
name|in
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|recog_memoized
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|>=
literal|0
condition|)
block|{
name|insn_extract
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* We want constrain operands to treat this insn strictly in 	     its validity determination, i.e., the way it would after reload 	     has completed.  */
if|if
condition|(
name|constrain_operands
argument_list|(
name|code
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|insn
return|;
block|}
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
comment|/* If that failed, we must use a conservative two-insn sequence. 	 use move to copy constant, MEM, or pseudo register to the reload 	 register since "move" will be able to handle an arbitrary operand, 	 unlike add which can't, in general.  Then add the registers.  	 If there is another way to do this for a specific machine, a 	 DEFINE_PEEPHOLE should be specified that recognizes the sequence 	 we emit below.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op1
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|MEM
operator|||
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|SUBREG
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|op1
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
name|tem
operator|=
name|op0
operator|,
name|op0
operator|=
name|op1
operator|,
name|op1
operator|=
name|tem
expr_stmt|;
name|gen_reload
argument_list|(
name|out
argument_list|,
name|op0
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* If OP0 and OP1 are the same, we can use OUT for OP1. 	 This fixes a problem on the 32K where the stack pointer cannot 	 be used as an operand of an add insn.  */
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
condition|)
name|op1
operator|=
name|out
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_add2_insn
argument_list|(
name|out
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If that failed, copy the address register to the reload register. 	 Then add the constant to the reload register.  */
name|code
operator|=
name|recog_memoized
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|>=
literal|0
condition|)
block|{
name|insn_extract
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* We want constrain operands to treat this insn strictly in 	     its validity determination, i.e., the way it would after reload 	     has completed.  */
if|if
condition|(
name|constrain_operands
argument_list|(
name|code
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|/* Add a REG_EQUIV note so that find_equiv_reg can find it.  */
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_EQUIV
argument_list|,
name|in
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|insn
return|;
block|}
block|}
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
name|gen_reload
argument_list|(
name|out
argument_list|,
name|op1
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_add2_insn
argument_list|(
name|out
argument_list|,
name|op0
argument_list|)
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_EQUIV
argument_list|,
name|in
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SECONDARY_MEMORY_NEEDED
comment|/* If we need a memory location to do the move, do it that way.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|in
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|GET_CODE
argument_list|(
name|out
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|out
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|SECONDARY_MEMORY_NEEDED
argument_list|(
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|in
argument_list|)
argument_list|)
argument_list|,
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|out
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|out
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Get the memory to use and rewrite both registers to its mode.  */
name|rtx
name|loc
init|=
name|get_secondary_mem
argument_list|(
name|in
argument_list|,
name|GET_MODE
argument_list|(
name|out
argument_list|)
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|loc
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|out
argument_list|)
condition|)
name|out
operator|=
name|gen_rtx_REG
argument_list|(
name|GET_MODE
argument_list|(
name|loc
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|out
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|loc
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|in
argument_list|)
condition|)
name|in
operator|=
name|gen_rtx_REG
argument_list|(
name|GET_MODE
argument_list|(
name|loc
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|in
argument_list|)
argument_list|)
expr_stmt|;
name|gen_reload
argument_list|(
name|loc
argument_list|,
name|in
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|gen_reload
argument_list|(
name|out
argument_list|,
name|loc
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* If IN is a simple operand, use gen_move_insn.  */
elseif|else
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|in
argument_list|)
argument_list|)
operator|==
literal|'o'
operator|||
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|SUBREG
condition|)
name|emit_insn
argument_list|(
name|gen_move_insn
argument_list|(
name|out
argument_list|,
name|in
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_reload_load_address
elseif|else
if|if
condition|(
name|HAVE_reload_load_address
condition|)
name|emit_insn
argument_list|(
name|gen_reload_load_address
argument_list|(
name|out
argument_list|,
name|in
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Otherwise, just write (set OUT IN) and hope for the best.  */
else|else
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|out
argument_list|,
name|in
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Return the first insn emitted.      We can not just return get_last_insn, because there may have      been multiple instructions emitted.  Also note that gen_move_insn may      emit more than one insn itself, so we can not assume that there is one      insn emitted per emit_insn_before call.  */
return|return
name|last
condition|?
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
else|:
name|get_insns
argument_list|()
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Delete a previously made output-reload    whose result we now believe is not needed.    First we double-check.     INSN is the insn now being processed.    OUTPUT_RELOAD_INSN is the insn of the output reload.    J is the reload-number for this insn.  */
end_comment

begin_function
specifier|static
name|void
name|delete_output_reload
parameter_list|(
name|insn
parameter_list|,
name|j
parameter_list|,
name|output_reload_insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|int
name|j
decl_stmt|;
name|rtx
name|output_reload_insn
decl_stmt|;
block|{
specifier|register
name|rtx
name|i1
decl_stmt|;
comment|/* Get the raw pseudo-register referred to.  */
name|rtx
name|reg
init|=
name|reload_in
index|[
name|j
index|]
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
condition|)
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
expr_stmt|;
comment|/* If the pseudo-reg we are reloading is no longer referenced      anywhere between the store into it and here,      and no jumps or labels intervene, then the value can get      here through the reload reg alone.      Otherwise, give up--return.  */
for|for
control|(
name|i1
operator|=
name|NEXT_INSN
argument_list|(
name|output_reload_insn
argument_list|)
init|;
name|i1
operator|!=
name|insn
condition|;
name|i1
operator|=
name|NEXT_INSN
argument_list|(
name|i1
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|i1
argument_list|)
operator|==
name|CODE_LABEL
operator|||
name|GET_CODE
argument_list|(
name|i1
argument_list|)
operator|==
name|JUMP_INSN
condition|)
return|return;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|i1
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|i1
argument_list|)
operator|==
name|CALL_INSN
operator|)
operator|&&
name|reg_mentioned_p
argument_list|(
name|reg
argument_list|,
name|PATTERN
argument_list|(
name|i1
argument_list|)
argument_list|)
condition|)
block|{
comment|/* If this is just a single USE with an REG_EQUAL note in front 	     of INSN, this is no problem, because this mentions just the 	     address that we are using here. 	     But if there is more than one such USE, the insn might use 	     the operand directly, or another reload might do that. 	     This is analogous to the count_occurences check in the callers.  */
name|int
name|num_occurences
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|i1
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|i1
argument_list|)
argument_list|)
operator|==
name|USE
operator|&&
name|find_reg_note
argument_list|(
name|i1
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
block|{
name|num_occurences
operator|+=
name|rtx_equal_p
argument_list|(
name|reg
argument_list|,
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|i1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
literal|0
expr_stmt|;
name|i1
operator|=
name|NEXT_INSN
argument_list|(
name|i1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|num_occurences
operator|==
literal|1
operator|&&
name|i1
operator|==
name|insn
condition|)
break|break;
return|return;
block|}
block|}
comment|/* The caller has already checked that REG dies or is set in INSN.      It has also checked that we are optimizing, and thus some inaccurancies      in the debugging information are acceptable.      So we could just delete output_reload_insn.      But in some cases we can improve the debugging information without      sacrificing optimization - maybe even improving the code:      See if the pseudo reg has been completely replaced      with reload regs.  If so, delete the store insn      and forget we had a stack slot for the pseudo.  */
if|if
condition|(
name|reload_out
index|[
name|j
index|]
operator|!=
name|reload_in
index|[
name|j
index|]
operator|&&
name|REG_N_DEATHS
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|==
literal|1
operator|&&
name|REG_BASIC_BLOCK
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|>=
literal|0
operator|&&
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|i2
decl_stmt|;
comment|/* We know that it was used only between here 	 and the beginning of the current basic block. 	 (We also know that the last use before INSN was 	 the output reload we are thinking of deleting, but never mind that.) 	 Search that range; see if any ref remains.  */
for|for
control|(
name|i2
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
init|;
name|i2
condition|;
name|i2
operator|=
name|PREV_INSN
argument_list|(
name|i2
argument_list|)
control|)
block|{
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|i2
argument_list|)
decl_stmt|;
comment|/* Uses which just store in the pseudo don't count, 	     since if they are the only uses, they are dead.  */
if|if
condition|(
name|set
operator|!=
literal|0
operator|&&
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|==
name|reg
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|i2
argument_list|)
operator|==
name|CODE_LABEL
operator|||
name|GET_CODE
argument_list|(
name|i2
argument_list|)
operator|==
name|JUMP_INSN
condition|)
break|break;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|i2
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|i2
argument_list|)
operator|==
name|CALL_INSN
operator|)
operator|&&
name|reg_mentioned_p
argument_list|(
name|reg
argument_list|,
name|PATTERN
argument_list|(
name|i2
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Some other ref remains; just delete the output reload we 		 know to be dead.  */
name|delete_insn
argument_list|(
name|output_reload_insn
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Delete the now-dead stores into this pseudo.  */
for|for
control|(
name|i2
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
init|;
name|i2
condition|;
name|i2
operator|=
name|PREV_INSN
argument_list|(
name|i2
argument_list|)
control|)
block|{
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|i2
argument_list|)
decl_stmt|;
if|if
condition|(
name|set
operator|!=
literal|0
operator|&&
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|==
name|reg
condition|)
block|{
comment|/* This might be a basic block head, 		 thus don't use delete_insn.  */
name|PUT_CODE
argument_list|(
name|i2
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|i2
argument_list|)
operator|=
literal|0
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|i2
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|i2
argument_list|)
operator|==
name|CODE_LABEL
operator|||
name|GET_CODE
argument_list|(
name|i2
argument_list|)
operator|==
name|JUMP_INSN
condition|)
break|break;
block|}
comment|/* For the debugging info, 	 say the pseudo lives in this reload reg.  */
name|reg_renumber
index|[
name|REGNO
argument_list|(
name|reg
argument_list|)
index|]
operator|=
name|REGNO
argument_list|(
name|reload_reg_rtx
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|alter_reg
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|delete_insn
argument_list|(
name|output_reload_insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output reload-insns to reload VALUE into RELOADREG.    VALUE is an autoincrement or autodecrement RTX whose operand    is a register or memory location;    so reloading involves incrementing that location.     INC_AMOUNT is the number to increment or decrement by (always positive).    This cannot be deduced from VALUE.  */
end_comment

begin_function
specifier|static
name|void
name|inc_for_reload
parameter_list|(
name|reloadreg
parameter_list|,
name|value
parameter_list|,
name|inc_amount
parameter_list|)
name|rtx
name|reloadreg
decl_stmt|;
name|rtx
name|value
decl_stmt|;
name|int
name|inc_amount
decl_stmt|;
block|{
comment|/* REG or MEM to be copied and incremented.  */
name|rtx
name|incloc
init|=
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* Nonzero if increment after copying.  */
name|int
name|post
init|=
operator|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|POST_DEC
operator|||
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|POST_INC
operator|)
decl_stmt|;
name|rtx
name|last
decl_stmt|;
name|rtx
name|inc
decl_stmt|;
name|rtx
name|add_insn
decl_stmt|;
name|int
name|code
decl_stmt|;
comment|/* No hard register is equivalent to this register after      inc/dec operation.  If REG_LAST_RELOAD_REG were non-zero,      we could inc/dec that register as well (maybe even using it for      the source), but I'm not sure it's worth worrying about.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|incloc
argument_list|)
operator|==
name|REG
condition|)
name|reg_last_reload_reg
index|[
name|REGNO
argument_list|(
name|incloc
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|PRE_DEC
operator|||
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|POST_DEC
condition|)
name|inc_amount
operator|=
operator|-
name|inc_amount
expr_stmt|;
name|inc
operator|=
name|GEN_INT
argument_list|(
name|inc_amount
argument_list|)
expr_stmt|;
comment|/* If this is post-increment, first copy the location to the reload reg.  */
if|if
condition|(
name|post
condition|)
name|emit_insn
argument_list|(
name|gen_move_insn
argument_list|(
name|reloadreg
argument_list|,
name|incloc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* See if we can directly increment INCLOC.  Use a method similar to that      in gen_reload.  */
name|last
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|add_insn
operator|=
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|incloc
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|GET_MODE
argument_list|(
name|incloc
argument_list|)
argument_list|,
name|incloc
argument_list|,
name|inc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|recog_memoized
argument_list|(
name|add_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|>=
literal|0
condition|)
block|{
name|insn_extract
argument_list|(
name|add_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|constrain_operands
argument_list|(
name|code
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|/* If this is a pre-increment and we have incremented the value 	     where it lives, copy the incremented value to RELOADREG to 	     be used as an address.  */
if|if
condition|(
operator|!
name|post
condition|)
name|emit_insn
argument_list|(
name|gen_move_insn
argument_list|(
name|reloadreg
argument_list|,
name|incloc
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
comment|/* If couldn't do the increment directly, must increment in RELOADREG.      The way we do this depends on whether this is pre- or post-increment.      For pre-increment, copy INCLOC to the reload register, increment it      there, then save back.  */
if|if
condition|(
operator|!
name|post
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_move_insn
argument_list|(
name|reloadreg
argument_list|,
name|incloc
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_add2_insn
argument_list|(
name|reloadreg
argument_list|,
name|inc
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_move_insn
argument_list|(
name|incloc
argument_list|,
name|reloadreg
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Postincrement. 	 Because this might be a jump insn or a compare, and because RELOADREG 	 may not be available after the insn in an input reload, we must do 	 the incrementation before the insn being reloaded for.  	 We have already copied INCLOC to RELOADREG.  Increment the copy in 	 RELOADREG, save that back, then decrement RELOADREG so it has 	 the original value.  */
name|emit_insn
argument_list|(
name|gen_add2_insn
argument_list|(
name|reloadreg
argument_list|,
name|inc
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_move_insn
argument_list|(
name|incloc
argument_list|,
name|reloadreg
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_add2_insn
argument_list|(
name|reloadreg
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|inc_amount
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if we are certain that the constraint-string STRING allows    the hard register REG.  Return 0 if we can't be sure of this.  */
end_comment

begin_function
specifier|static
name|int
name|constraint_accepts_reg_p
parameter_list|(
name|string
parameter_list|,
name|reg
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
block|{
name|int
name|value
init|=
literal|0
decl_stmt|;
name|int
name|regno
init|=
name|true_regnum
argument_list|(
name|reg
argument_list|)
decl_stmt|;
name|int
name|c
decl_stmt|;
comment|/* Initialize for first alternative.  */
name|value
operator|=
literal|0
expr_stmt|;
comment|/* Check that each alternative contains `g' or `r'.  */
while|while
condition|(
literal|1
condition|)
switch|switch
condition|(
name|c
operator|=
operator|*
name|string
operator|++
condition|)
block|{
case|case
literal|0
case|:
comment|/* If an alternative lacks `g' or `r', we lose.  */
return|return
name|value
return|;
case|case
literal|','
case|:
comment|/* If an alternative lacks `g' or `r', we lose.  */
if|if
condition|(
name|value
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Initialize for next alternative.  */
name|value
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
case|case
literal|'r'
case|:
comment|/* Any general reg wins for this alternative.  */
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|GENERAL_REGS
index|]
argument_list|,
name|regno
argument_list|)
condition|)
name|value
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
comment|/* Any reg in specified class wins for this alternative.  */
block|{
name|enum
name|reg_class
name|class
init|=
name|REG_CLASS_FROM_LETTER
argument_list|(
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|class
index|]
argument_list|,
name|regno
argument_list|)
condition|)
name|value
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the number of places FIND appears within X, but don't count    an occurrence if some SET_DEST is FIND.  */
end_comment

begin_function
name|int
name|count_occurrences
parameter_list|(
name|x
parameter_list|,
name|find
parameter_list|)
specifier|register
name|rtx
name|x
decl_stmt|,
name|find
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|char
modifier|*
name|format_ptr
decl_stmt|;
name|int
name|count
decl_stmt|;
if|if
condition|(
name|x
operator|==
name|find
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
case|case
name|QUEUED
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CODE_LABEL
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
return|return
literal|0
return|;
case|case
name|SET
case|:
if|if
condition|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|==
name|find
condition|)
return|return
name|count_occurrences
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|find
argument_list|)
return|;
break|break;
default|default:
break|break;
block|}
name|format_ptr
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|format_ptr
operator|++
condition|)
block|{
case|case
literal|'e'
case|:
name|count
operator|+=
name|count_occurrences
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|find
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
if|if
condition|(
name|XVEC
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|count
operator|+=
name|count_occurrences
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|find
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
return|return
name|count
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This array holds values which are equivalent to a hard register    during reload_cse_regs.  Each array element is an EXPR_LIST of    values.  Each time a hard register is set, we set the corresponding    array element to the value.  Each time a hard register is copied    into memory, we add the memory location to the corresponding array    element.  We don't store values or memory addresses with side    effects in this array.     If the value is a CONST_INT, then the mode of the containing    EXPR_LIST is the mode in which that CONST_INT was referenced.     We sometimes clobber a specific entry in a list.  In that case, we    just set XEXP (list-entry, 0) to 0.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|reg_values
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is a preallocated REG rtx which we use as a temporary in    reload_cse_invalidate_regno, so that we don't need to allocate a    new one each time through a loop in that function.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|invalidate_regno_rtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is a set of registers for which we must remove REG_DEAD notes in    previous insns, because our modifications made them invalid.  That can    happen if we introduced the register into the current insn, or we deleted    the current insn which used to set the register.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|no_longer_dead_regs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Invalidate any entries in reg_values which depend on REGNO,    including those for REGNO itself.  This is called if REGNO is    changing.  If CLOBBER is true, then always forget anything we    currently know about REGNO.  MODE is the mode of the assignment to    REGNO, which is used to determine how many hard registers are being    changed.  If MODE is VOIDmode, then only REGNO is being changed;    this is used when invalidating call clobbered registers across a    call.  */
end_comment

begin_function
specifier|static
name|void
name|reload_cse_invalidate_regno
parameter_list|(
name|regno
parameter_list|,
name|mode
parameter_list|,
name|clobber
parameter_list|)
name|int
name|regno
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|clobber
decl_stmt|;
block|{
name|int
name|endregno
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Our callers don't always go through true_regnum; we may see a      pseudo-register here from a CLOBBER or the like.  We probably      won't ever see a pseudo-register that has a real register number,      for we check anyhow for safety.  */
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|regno
operator|=
name|reg_renumber
index|[
name|regno
index|]
expr_stmt|;
if|if
condition|(
name|regno
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|endregno
operator|=
name|regno
operator|+
literal|1
expr_stmt|;
else|else
name|endregno
operator|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|clobber
condition|)
for|for
control|(
name|i
operator|=
name|regno
init|;
name|i
operator|<
name|endregno
condition|;
name|i
operator|++
control|)
name|reg_values
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
name|reg_values
index|[
name|i
index|]
init|;
name|x
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
control|)
block|{
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
operator|&&
name|refers_to_regno_p
argument_list|(
name|regno
argument_list|,
name|endregno
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_PTR
argument_list|)
condition|)
block|{
comment|/* If this is the only entry on the list, clear                  reg_values[i].  Otherwise, just clear this entry on                  the list.  */
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
operator|&&
name|x
operator|==
name|reg_values
index|[
name|i
index|]
condition|)
block|{
name|reg_values
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
comment|/* We must look at earlier registers, in case REGNO is part of a      multi word value but is not the first register.  If an earlier      register has a value in a mode which overlaps REGNO, then we must      invalidate that earlier register.  Note that we do not need to      check REGNO or later registers (we must not check REGNO itself,      because we would incorrectly conclude that there was a conflict).  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|regno
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
name|reg_values
index|[
name|i
index|]
init|;
name|x
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
control|)
block|{
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|PUT_MODE
argument_list|(
name|invalidate_regno_rtx
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|REGNO
argument_list|(
name|invalidate_regno_rtx
argument_list|)
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|refers_to_regno_p
argument_list|(
name|regno
argument_list|,
name|endregno
argument_list|,
name|invalidate_regno_rtx
argument_list|,
name|NULL_PTR
argument_list|)
condition|)
block|{
name|reload_cse_invalidate_regno
argument_list|(
name|i
argument_list|,
name|VOIDmode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* The memory at address MEM_BASE is being changed.    Return whether this change will invalidate VAL.  */
end_comment

begin_function
specifier|static
name|int
name|reload_cse_mem_conflict_p
parameter_list|(
name|mem_base
parameter_list|,
name|val
parameter_list|)
name|rtx
name|mem_base
decl_stmt|;
name|rtx
name|val
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
decl_stmt|;
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|val
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
comment|/* Get rid of a few simple cases quickly. */
case|case
name|REG
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|SCRATCH
case|:
case|case
name|CONST
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
return|return
literal|0
return|;
case|case
name|MEM
case|:
if|if
condition|(
name|GET_MODE
argument_list|(
name|mem_base
argument_list|)
operator|==
name|BLKmode
operator|||
name|GET_MODE
argument_list|(
name|val
argument_list|)
operator|==
name|BLKmode
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|anti_dependence
argument_list|(
name|val
argument_list|,
name|mem_base
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* The address may contain nested MEMs.  */
break|break;
default|default:
break|break;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
name|reload_cse_mem_conflict_p
argument_list|(
name|mem_base
argument_list|,
name|XEXP
argument_list|(
name|val
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|val
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|reload_cse_mem_conflict_p
argument_list|(
name|mem_base
argument_list|,
name|XVECEXP
argument_list|(
name|val
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Invalidate any entries in reg_values which are changed because of a    store to MEM_RTX.  If this is called because of a non-const call    instruction, MEM_RTX is (mem:BLK const0_rtx).  */
end_comment

begin_function
specifier|static
name|void
name|reload_cse_invalidate_mem
parameter_list|(
name|mem_rtx
parameter_list|)
name|rtx
name|mem_rtx
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
name|reg_values
index|[
name|i
index|]
init|;
name|x
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
control|)
block|{
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
operator|&&
name|reload_cse_mem_conflict_p
argument_list|(
name|mem_rtx
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
comment|/* If this is the only entry on the list, clear                  reg_values[i].  Otherwise, just clear this entry on                  the list.  */
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
operator|&&
name|x
operator|==
name|reg_values
index|[
name|i
index|]
condition|)
block|{
name|reg_values
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Invalidate DEST, which is being assigned to or clobbered.  The    second parameter exists so that this function can be passed to    note_stores; it is ignored.  */
end_comment

begin_function
specifier|static
name|void
name|reload_cse_invalidate_rtx
parameter_list|(
name|dest
parameter_list|,
name|ignore
parameter_list|)
name|rtx
name|dest
decl_stmt|;
name|rtx
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
while|while
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
condition|)
name|dest
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
condition|)
name|reload_cse_invalidate_regno
argument_list|(
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
condition|)
name|reload_cse_invalidate_mem
argument_list|(
name|dest
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Possibly delete death notes on the insns before INSN if modifying INSN    extended the lifespan of the registers.  */
end_comment

begin_function
specifier|static
name|void
name|reload_cse_delete_death_notes
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|dreg
decl_stmt|;
for|for
control|(
name|dreg
operator|=
literal|0
init|;
name|dreg
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|dreg
operator|++
control|)
block|{
name|rtx
name|trial
decl_stmt|;
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|no_longer_dead_regs
argument_list|,
name|dreg
argument_list|)
condition|)
continue|continue;
for|for
control|(
name|trial
operator|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
init|;
operator|(
name|trial
operator|&&
name|GET_CODE
argument_list|(
name|trial
argument_list|)
operator|!=
name|CODE_LABEL
operator|&&
name|GET_CODE
argument_list|(
name|trial
argument_list|)
operator|!=
name|BARRIER
operator|)
condition|;
name|trial
operator|=
name|prev_nonnote_insn
argument_list|(
name|trial
argument_list|)
control|)
block|{
if|if
condition|(
name|find_regno_note
argument_list|(
name|trial
argument_list|,
name|REG_DEAD
argument_list|,
name|dreg
argument_list|)
condition|)
block|{
name|remove_death
argument_list|(
name|dreg
argument_list|,
name|trial
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Record that the current insn uses hard reg REGNO in mode MODE.  This    will be used in reload_cse_delete_death_notes to delete prior REG_DEAD    notes for this register.  */
end_comment

begin_function
specifier|static
name|void
name|reload_cse_no_longer_dead
parameter_list|(
name|regno
parameter_list|,
name|mode
parameter_list|)
name|int
name|regno
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|int
name|nregs
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
decl_stmt|;
while|while
condition|(
name|nregs
operator|--
operator|>
literal|0
condition|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|no_longer_dead_regs
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|regno
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Do a very simple CSE pass over the hard registers.     This function detects no-op moves where we happened to assign two    different pseudo-registers to the same hard register, and then    copied one to the other.  Reload will generate a useless    instruction copying a register to itself.     This function also detects cases where we load a value from memory    into two different registers, and (if memory is more expensive than    registers) changes it to simply copy the first register into the    second register.       Another optimization is performed that scans the operands of each    instruction to see whether the value is already available in a    hard register.  It then replaces the operand with the hard register    if possible, much like an optional reload would.  */
end_comment

begin_function
name|void
name|reload_cse_regs
parameter_list|(
name|first
parameter_list|)
name|rtx
name|first
decl_stmt|;
block|{
name|char
modifier|*
name|firstobj
decl_stmt|;
name|rtx
name|callmem
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|init_alias_analysis
argument_list|()
expr_stmt|;
name|reg_values
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|FIRST_PSEUDO_REGISTER
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_values
argument_list|,
name|FIRST_PSEUDO_REGISTER
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create our EXPR_LIST structures on reload_obstack, so that we can      free them when we are done.  */
name|push_obstacks
argument_list|(
operator|&
name|reload_obstack
argument_list|,
operator|&
name|reload_obstack
argument_list|)
expr_stmt|;
name|firstobj
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|reload_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* We pass this to reload_cse_invalidate_mem to invalidate all of      memory for a non-const call instruction.  */
name|callmem
operator|=
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
comment|/* This is used in reload_cse_invalidate_regno to avoid consing a      new REG in a loop in that function.  */
name|invalidate_regno_rtx
operator|=
name|gen_rtx_REG
argument_list|(
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|rtx
name|body
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
block|{
comment|/* Forget all the register values at a code label.  We don't              try to do anything clever around jumps.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
name|reg_values
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
ifdef|#
directive|ifdef
name|NON_SAVING_SETJMP
if|if
condition|(
name|NON_SAVING_SETJMP
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_SETJMP
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
name|reg_values
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
literal|'i'
condition|)
continue|continue;
name|CLEAR_HARD_REG_SET
argument_list|(
name|no_longer_dead_regs
argument_list|)
expr_stmt|;
comment|/* If this is a call instruction, forget anything stored in a 	 call clobbered register, or, if this is not a const call, in 	 memory.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|call_used_regs
index|[
name|i
index|]
condition|)
name|reload_cse_invalidate_regno
argument_list|(
name|i
argument_list|,
name|VOIDmode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CONST_CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
name|reload_cse_invalidate_mem
argument_list|(
name|callmem
argument_list|)
expr_stmt|;
block|}
name|body
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SET
condition|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|reload_cse_noop_set_p
argument_list|(
name|body
argument_list|,
name|insn
argument_list|)
condition|)
block|{
name|PUT_CODE
argument_list|(
name|insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
name|reload_cse_delete_death_notes
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* We're done with this insn.  */
continue|continue;
block|}
comment|/* It's not a no-op, but we can try to simplify it.  */
name|CLEAR_HARD_REG_SET
argument_list|(
name|no_longer_dead_regs
argument_list|)
expr_stmt|;
name|count
operator|+=
name|reload_cse_simplify_set
argument_list|(
name|body
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
operator|&&
name|apply_change_group
argument_list|()
condition|)
name|reload_cse_delete_death_notes
argument_list|(
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|reload_cse_simplify_operands
argument_list|(
name|insn
argument_list|)
condition|)
name|reload_cse_delete_death_notes
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|reload_cse_record_set
argument_list|(
name|body
argument_list|,
name|body
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
comment|/* If every action in a PARALLEL is a noop, we can delete              the entire PARALLEL.  */
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|!=
name|SET
operator|||
operator|!
name|reload_cse_noop_set_p
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|!=
name|CLOBBER
condition|)
break|break;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|PUT_CODE
argument_list|(
name|insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
name|reload_cse_delete_death_notes
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* We're done with this insn.  */
continue|continue;
block|}
comment|/* It's not a no-op, but we can try to simplify it.  */
name|CLEAR_HARD_REG_SET
argument_list|(
name|no_longer_dead_regs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
name|count
operator|+=
name|reload_cse_simplify_set
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
operator|&&
name|apply_change_group
argument_list|()
condition|)
name|reload_cse_delete_death_notes
argument_list|(
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|reload_cse_simplify_operands
argument_list|(
name|insn
argument_list|)
condition|)
name|reload_cse_delete_death_notes
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Look through the PARALLEL and record the values being              set, if possible.  Also handle any CLOBBERs.  */
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|rtx
name|x
init|=
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
condition|)
name|reload_cse_record_set
argument_list|(
name|x
argument_list|,
name|body
argument_list|)
expr_stmt|;
else|else
name|note_stores
argument_list|(
name|x
argument_list|,
name|reload_cse_invalidate_rtx
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|note_stores
argument_list|(
name|body
argument_list|,
name|reload_cse_invalidate_rtx
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
comment|/* Clobber any registers which appear in REG_INC notes.  We          could keep track of the changes to their values, but it is          unlikely to help.  */
block|{
name|rtx
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|x
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|x
argument_list|)
operator|==
name|REG_INC
condition|)
name|reload_cse_invalidate_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Look for any CLOBBERs in CALL_INSN_FUNCTION_USAGE, but only          after we have processed the insn.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|rtx
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
init|;
name|x
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
name|reload_cse_invalidate_rtx
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Free all the temporary structures we created, and go back to the      regular obstacks.  */
name|obstack_free
argument_list|(
operator|&
name|reload_obstack
argument_list|,
name|firstobj
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return whether the values known for REGNO are equal to VAL.  MODE    is the mode of the object that VAL is being copied to; this matters    if VAL is a CONST_INT.  */
end_comment

begin_function
specifier|static
name|int
name|reload_cse_regno_equal_p
parameter_list|(
name|regno
parameter_list|,
name|val
parameter_list|,
name|mode
parameter_list|)
name|int
name|regno
decl_stmt|;
name|rtx
name|val
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|rtx
name|x
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
return|return
literal|0
return|;
for|for
control|(
name|x
operator|=
name|reg_values
index|[
name|regno
index|]
init|;
name|x
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|val
argument_list|)
operator|&&
operator|(
operator|!
name|flag_float_store
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|MODE_FLOAT
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|val
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|mode
operator|==
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|||
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
comment|/* On a big endian machine if the value spans more than 		   one register then this register holds the high part of 		   it and we can't use it.  		   ??? We should also compare with the high part of the 		   value.  */
operator|&&
operator|!
operator|(
name|WORDS_BIG_ENDIAN
operator|&&
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|>
literal|1
operator|)
operator|&&
name|TRULY_NOOP_TRUNCATION
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* See whether a single set is a noop.  SET is the set instruction we    are should check, and INSN is the instruction from which it came.  */
end_comment

begin_function
specifier|static
name|int
name|reload_cse_noop_set_p
parameter_list|(
name|set
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|set
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|src
decl_stmt|,
name|dest
decl_stmt|;
name|enum
name|machine_mode
name|dest_mode
decl_stmt|;
name|int
name|dreg
decl_stmt|,
name|sreg
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|src
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|dest
operator|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|dest_mode
operator|=
name|GET_MODE
argument_list|(
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|side_effects_p
argument_list|(
name|src
argument_list|)
condition|)
return|return
literal|0
return|;
name|dreg
operator|=
name|true_regnum
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|sreg
operator|=
name|true_regnum
argument_list|(
name|src
argument_list|)
expr_stmt|;
comment|/* Check for setting a register to itself.  In this case, we don't      have to worry about REG_DEAD notes.  */
if|if
condition|(
name|dreg
operator|>=
literal|0
operator|&&
name|dreg
operator|==
name|sreg
condition|)
return|return
literal|1
return|;
name|ret
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dreg
operator|>=
literal|0
condition|)
block|{
comment|/* Check for setting a register to itself.  */
if|if
condition|(
name|dreg
operator|==
name|sreg
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
comment|/* Check for setting a register to a value which we already know          is in the register.  */
elseif|else
if|if
condition|(
name|reload_cse_regno_equal_p
argument_list|(
name|dreg
argument_list|,
name|src
argument_list|,
name|dest_mode
argument_list|)
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
comment|/* Check for setting a register DREG to another register SREG          where SREG is equal to a value which is already in DREG.  */
elseif|else
if|if
condition|(
name|sreg
operator|>=
literal|0
condition|)
block|{
name|rtx
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
name|reg_values
index|[
name|sreg
index|]
init|;
name|x
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|rtx
name|tmp
decl_stmt|;
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|dest_mode
operator|==
name|GET_MODE
argument_list|(
name|x
argument_list|)
condition|)
name|tmp
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|dest_mode
argument_list|)
operator|<
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|tmp
operator|=
name|gen_lowpart_common
argument_list|(
name|dest_mode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
continue|continue;
if|if
condition|(
name|tmp
operator|&&
name|reload_cse_regno_equal_p
argument_list|(
name|dreg
argument_list|,
name|tmp
argument_list|,
name|dest_mode
argument_list|)
condition|)
block|{
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
condition|)
block|{
comment|/* Check for storing a register to memory when we know that the          register is equivalent to the memory location. */
if|if
condition|(
name|sreg
operator|>=
literal|0
operator|&&
name|reload_cse_regno_equal_p
argument_list|(
name|sreg
argument_list|,
name|dest
argument_list|,
name|dest_mode
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|dest
argument_list|)
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If we can delete this SET, then we need to look for an earlier      REG_DEAD note on DREG, and remove it if it exists.  */
if|if
condition|(
name|ret
operator|&&
name|dreg
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_UNUSED
argument_list|,
name|dreg
argument_list|)
condition|)
name|reload_cse_no_longer_dead
argument_list|(
name|dreg
argument_list|,
name|dest_mode
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Try to simplify a single SET instruction.  SET is the set pattern.    INSN is the instruction it came from.    This function only handles one case: if we set a register to a value    which is not a register, we try to find that value in some other register    and change the set into a register copy.  */
end_comment

begin_function
specifier|static
name|int
name|reload_cse_simplify_set
parameter_list|(
name|set
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|set
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|dreg
decl_stmt|;
name|rtx
name|src
decl_stmt|;
name|enum
name|machine_mode
name|dest_mode
decl_stmt|;
name|enum
name|reg_class
name|dclass
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|dreg
operator|=
name|true_regnum
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dreg
operator|<
literal|0
condition|)
return|return
literal|0
return|;
name|src
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
if|if
condition|(
name|side_effects_p
argument_list|(
name|src
argument_list|)
operator|||
name|true_regnum
argument_list|(
name|src
argument_list|)
operator|>=
literal|0
condition|)
return|return
literal|0
return|;
name|dclass
operator|=
name|REGNO_REG_CLASS
argument_list|(
name|dreg
argument_list|)
expr_stmt|;
comment|/* If memory loads are cheaper than register copies, don't change them.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|MEM
operator|&&
name|MEMORY_MOVE_COST
argument_list|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|,
name|dclass
argument_list|,
literal|1
argument_list|)
operator|<
literal|2
condition|)
return|return
literal|0
return|;
comment|/* If the constant is cheaper than a register, don't change it.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|src
argument_list|)
operator|&&
name|rtx_cost
argument_list|(
name|src
argument_list|,
name|SET
argument_list|)
operator|<
literal|2
condition|)
return|return
literal|0
return|;
name|dest_mode
operator|=
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|!=
name|dreg
operator|&&
name|REGISTER_MOVE_COST
argument_list|(
name|REGNO_REG_CLASS
argument_list|(
name|i
argument_list|)
argument_list|,
name|dclass
argument_list|)
operator|==
literal|2
operator|&&
name|reload_cse_regno_equal_p
argument_list|(
name|i
argument_list|,
name|src
argument_list|,
name|dest_mode
argument_list|)
condition|)
block|{
name|int
name|validated
decl_stmt|;
comment|/* Pop back to the real obstacks while changing the insn.  */
name|pop_obstacks
argument_list|()
expr_stmt|;
name|validated
operator|=
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|gen_rtx_REG
argument_list|(
name|dest_mode
argument_list|,
name|i
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Go back to the obstack we are using for temporary              storage.  */
name|push_obstacks
argument_list|(
operator|&
name|reload_obstack
argument_list|,
operator|&
name|reload_obstack
argument_list|)
expr_stmt|;
if|if
condition|(
name|validated
operator|&&
operator|!
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_UNUSED
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|reload_cse_no_longer_dead
argument_list|(
name|i
argument_list|,
name|dest_mode
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Try to replace operands in INSN with equivalent values that are already    in registers.  This can be viewed as optional reloading.        For each non-register operand in the insn, see if any hard regs are    known to be equivalent to that operand.  Record the alternatives which    can accept these hard registers.  Among all alternatives, select the    ones which are better or equal to the one currently matching, where    "better" is in terms of '?' and '!' constraints.  Among the remaining    alternatives, select the one which replaces most operands with    hard registers.  */
end_comment

begin_function
specifier|static
name|int
name|reload_cse_simplify_operands
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|REGISTER_CONSTRAINTS
name|int
name|insn_code_number
decl_stmt|,
name|n_operands
decl_stmt|,
name|n_alternatives
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
modifier|*
name|constraints
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
comment|/* Vector recording how bad an alternative is.  */
name|int
modifier|*
name|alternative_reject
decl_stmt|;
comment|/* Vector recording how many registers can be introduced by choosing      this alternative.  */
name|int
modifier|*
name|alternative_nregs
decl_stmt|;
comment|/* Array of vectors recording, for each operand and each alternative,      which hard register to substitute, or -1 if the operand should be      left as it is.  */
name|int
modifier|*
name|op_alt_regno
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
comment|/* Array of alternatives, sorted in order of decreasing desirability.  */
name|int
modifier|*
name|alternative_order
decl_stmt|;
name|rtx
name|reg
init|=
name|gen_rtx_REG
argument_list|(
name|VOIDmode
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
comment|/* Find out some information about this insn.  */
name|insn_code_number
operator|=
name|recog_memoized
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* We don't modify asm instructions.  */
if|if
condition|(
name|insn_code_number
operator|<
literal|0
condition|)
return|return
literal|0
return|;
name|n_operands
operator|=
name|insn_n_operands
index|[
name|insn_code_number
index|]
expr_stmt|;
name|n_alternatives
operator|=
name|insn_n_alternatives
index|[
name|insn_code_number
index|]
expr_stmt|;
if|if
condition|(
name|n_alternatives
operator|==
literal|0
operator|||
name|n_operands
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|insn_extract
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Figure out which alternative currently matches.  */
if|if
condition|(
operator|!
name|constrain_operands
argument_list|(
name|insn_code_number
argument_list|,
literal|1
argument_list|)
condition|)
name|fatal_insn_not_found
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|alternative_reject
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|n_alternatives
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|alternative_nregs
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|n_alternatives
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|alternative_order
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|n_alternatives
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|alternative_reject
argument_list|,
name|n_alternatives
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|alternative_nregs
argument_list|,
name|n_alternatives
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_operands
condition|;
name|i
operator|++
control|)
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|regno
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|op_alt_regno
index|[
name|i
index|]
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|n_alternatives
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_alternatives
condition|;
name|j
operator|++
control|)
name|op_alt_regno
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|p
operator|=
name|constraints
index|[
name|i
index|]
operator|=
name|insn_operand_constraint
index|[
name|insn_code_number
index|]
index|[
name|i
index|]
expr_stmt|;
name|mode
operator|=
name|insn_operand_mode
index|[
name|insn_code_number
index|]
index|[
name|i
index|]
expr_stmt|;
comment|/* Add the reject values for each alternative given by the constraints 	 for this operand.  */
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
name|char
name|c
init|=
operator|*
name|p
operator|++
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|','
condition|)
name|j
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'?'
condition|)
name|alternative_reject
index|[
name|j
index|]
operator|+=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'!'
condition|)
name|alternative_reject
index|[
name|j
index|]
operator|+=
literal|300
expr_stmt|;
block|}
comment|/* We won't change operands which are already registers.  We 	 also don't want to modify output operands.  */
name|regno
operator|=
name|true_regnum
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
literal|0
operator|||
name|constraints
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'='
operator|||
name|constraints
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'+'
condition|)
continue|continue;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
block|{
name|int
name|class
init|=
operator|(
name|int
operator|)
name|NO_REGS
decl_stmt|;
if|if
condition|(
operator|!
name|reload_cse_regno_equal_p
argument_list|(
name|regno
argument_list|,
name|recog_operand
index|[
name|i
index|]
argument_list|,
name|mode
argument_list|)
condition|)
continue|continue;
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|=
name|regno
expr_stmt|;
name|PUT_MODE
argument_list|(
name|reg
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* We found a register equal to this operand.  Now look for all 	     alternatives that can accept this register and have not been 	     assigned a register they can use yet.  */
name|j
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|constraints
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
name|c
init|=
operator|*
name|p
operator|++
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'='
case|:
case|case
literal|'+'
case|:
case|case
literal|'?'
case|:
case|case
literal|'#'
case|:
case|case
literal|'&'
case|:
case|case
literal|'!'
case|:
case|case
literal|'*'
case|:
case|case
literal|'%'
case|:
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'m'
case|:
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
case|case
literal|'V'
case|:
case|case
literal|'o'
case|:
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
case|case
literal|'G'
case|:
case|case
literal|'H'
case|:
case|case
literal|'s'
case|:
case|case
literal|'i'
case|:
case|case
literal|'n'
case|:
case|case
literal|'I'
case|:
case|case
literal|'J'
case|:
case|case
literal|'K'
case|:
case|case
literal|'L'
case|:
case|case
literal|'M'
case|:
case|case
literal|'N'
case|:
case|case
literal|'O'
case|:
case|case
literal|'P'
case|:
ifdef|#
directive|ifdef
name|EXTRA_CONSTRAINT
case|case
literal|'Q'
case|:
case|case
literal|'R'
case|:
case|case
literal|'S'
case|:
case|case
literal|'T'
case|:
case|case
literal|'U'
case|:
endif|#
directive|endif
case|case
literal|'p'
case|:
case|case
literal|'X'
case|:
comment|/* These don't say anything we care about.  */
break|break;
case|case
literal|'g'
case|:
case|case
literal|'r'
case|:
name|class
operator|=
name|reg_class_subunion
index|[
operator|(
name|int
operator|)
name|class
index|]
index|[
operator|(
name|int
operator|)
name|GENERAL_REGS
index|]
expr_stmt|;
break|break;
default|default:
name|class
operator|=
name|reg_class_subunion
index|[
operator|(
name|int
operator|)
name|class
index|]
index|[
operator|(
name|int
operator|)
name|REG_CLASS_FROM_LETTER
argument_list|(
name|c
argument_list|)
index|]
expr_stmt|;
break|break;
case|case
literal|','
case|:
case|case
literal|'\0'
case|:
comment|/* See if REGNO fits this alternative, and set it up as the 		     replacement register if we don't have one for this 		     alternative yet and the operand being replaced is not 		     a cheap CONST_INT. */
if|if
condition|(
name|op_alt_regno
index|[
name|i
index|]
index|[
name|j
index|]
operator|==
operator|-
literal|1
operator|&&
name|reg_fits_class_p
argument_list|(
name|reg
argument_list|,
name|class
argument_list|,
literal|0
argument_list|,
name|mode
argument_list|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|rtx_cost
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|,
name|SET
argument_list|)
operator|>
name|rtx_cost
argument_list|(
name|reg
argument_list|,
name|SET
argument_list|)
operator|)
condition|)
block|{
name|alternative_nregs
index|[
name|j
index|]
operator|++
expr_stmt|;
name|op_alt_regno
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|regno
expr_stmt|;
block|}
name|j
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
break|break;
block|}
block|}
block|}
comment|/* Record all alternatives which are better or equal to the currently      matching one in the alternative_order array.  */
for|for
control|(
name|i
operator|=
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|n_alternatives
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|alternative_reject
index|[
name|i
index|]
operator|<=
name|alternative_reject
index|[
name|which_alternative
index|]
condition|)
name|alternative_order
index|[
name|j
operator|++
index|]
operator|=
name|i
expr_stmt|;
name|n_alternatives
operator|=
name|j
expr_stmt|;
comment|/* Sort it.  Given a small number of alternatives, a dumb algorithm      won't hurt too much.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_alternatives
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|int
name|best
init|=
name|i
decl_stmt|;
name|int
name|best_reject
init|=
name|alternative_reject
index|[
name|alternative_order
index|[
name|i
index|]
index|]
decl_stmt|;
name|int
name|best_nregs
init|=
name|alternative_nregs
index|[
name|alternative_order
index|[
name|i
index|]
index|]
decl_stmt|;
name|int
name|tmp
decl_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|n_alternatives
condition|;
name|j
operator|++
control|)
block|{
name|int
name|this_reject
init|=
name|alternative_reject
index|[
name|alternative_order
index|[
name|j
index|]
index|]
decl_stmt|;
name|int
name|this_nregs
init|=
name|alternative_nregs
index|[
name|alternative_order
index|[
name|j
index|]
index|]
decl_stmt|;
if|if
condition|(
name|this_reject
operator|<
name|best_reject
operator|||
operator|(
name|this_reject
operator|==
name|best_reject
operator|&&
name|this_nregs
operator|<
name|best_nregs
operator|)
condition|)
block|{
name|best
operator|=
name|j
expr_stmt|;
name|best_reject
operator|=
name|this_reject
expr_stmt|;
name|best_nregs
operator|=
name|this_nregs
expr_stmt|;
block|}
block|}
name|tmp
operator|=
name|alternative_order
index|[
name|best
index|]
expr_stmt|;
name|alternative_order
index|[
name|best
index|]
operator|=
name|alternative_order
index|[
name|i
index|]
expr_stmt|;
name|alternative_order
index|[
name|i
index|]
operator|=
name|tmp
expr_stmt|;
block|}
comment|/* Substitute the operands as determined by op_alt_regno for the best      alternative.  */
name|j
operator|=
name|alternative_order
index|[
literal|0
index|]
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|no_longer_dead_regs
argument_list|)
expr_stmt|;
comment|/* Pop back to the real obstacks while changing the insn.  */
name|pop_obstacks
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_operands
condition|;
name|i
operator|++
control|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|insn_operand_mode
index|[
name|insn_code_number
index|]
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|op_alt_regno
index|[
name|i
index|]
index|[
name|j
index|]
operator|==
operator|-
literal|1
condition|)
continue|continue;
name|reload_cse_no_longer_dead
argument_list|(
name|op_alt_regno
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|validate_change
argument_list|(
name|insn
argument_list|,
name|recog_operand_loc
index|[
name|i
index|]
argument_list|,
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|op_alt_regno
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|insn_n_dups
index|[
name|insn_code_number
index|]
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|int
name|op
init|=
name|recog_dup_num
index|[
name|i
index|]
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|insn_operand_mode
index|[
name|insn_code_number
index|]
index|[
name|op
index|]
decl_stmt|;
if|if
condition|(
name|op_alt_regno
index|[
name|op
index|]
index|[
name|j
index|]
operator|==
operator|-
literal|1
condition|)
continue|continue;
name|reload_cse_no_longer_dead
argument_list|(
name|op_alt_regno
index|[
name|op
index|]
index|[
name|j
index|]
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|validate_change
argument_list|(
name|insn
argument_list|,
name|recog_dup_loc
index|[
name|i
index|]
argument_list|,
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|op_alt_regno
index|[
name|op
index|]
index|[
name|j
index|]
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Go back to the obstack we are using for temporary      storage.  */
name|push_obstacks
argument_list|(
operator|&
name|reload_obstack
argument_list|,
operator|&
name|reload_obstack
argument_list|)
expr_stmt|;
return|return
name|apply_change_group
argument_list|()
return|;
else|#
directive|else
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* These two variables are used to pass information from    reload_cse_record_set to reload_cse_check_clobber.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|reload_cse_check_clobbered
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|reload_cse_check_src
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* See if DEST overlaps with RELOAD_CSE_CHECK_SRC. If it does, set    RELOAD_CSE_CHECK_CLOBBERED.  This is called via note_stores.  The    second argument, which is passed by note_stores, is ignored.  */
end_comment

begin_function
specifier|static
name|void
name|reload_cse_check_clobber
parameter_list|(
name|dest
parameter_list|,
name|ignore
parameter_list|)
name|rtx
name|dest
decl_stmt|;
name|rtx
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|dest
argument_list|,
name|reload_cse_check_src
argument_list|)
condition|)
name|reload_cse_check_clobbered
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record the result of a SET instruction.  SET is the set pattern.    BODY is the pattern of the insn that it came from.  */
end_comment

begin_function
specifier|static
name|void
name|reload_cse_record_set
parameter_list|(
name|set
parameter_list|,
name|body
parameter_list|)
name|rtx
name|set
decl_stmt|;
name|rtx
name|body
decl_stmt|;
block|{
name|rtx
name|dest
decl_stmt|,
name|src
decl_stmt|,
name|x
decl_stmt|;
name|int
name|dreg
decl_stmt|,
name|sreg
decl_stmt|;
name|enum
name|machine_mode
name|dest_mode
decl_stmt|;
name|dest
operator|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|src
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|dreg
operator|=
name|true_regnum
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|sreg
operator|=
name|true_regnum
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|dest_mode
operator|=
name|GET_MODE
argument_list|(
name|dest
argument_list|)
expr_stmt|;
comment|/* Some machines don't define AUTO_INC_DEC, but they still use push      instructions.  We need to catch that case here in order to      invalidate the stack pointer correctly.  Note that invalidating      the stack pointer is different from invalidating DEST.  */
name|x
operator|=
name|dest
expr_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|push_operand
argument_list|(
name|x
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
name|reload_cse_invalidate_rtx
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|reload_cse_invalidate_rtx
argument_list|(
name|dest
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* We can only handle an assignment to a register, or a store of a      register to a memory location.  For other cases, we just clobber      the destination.  We also have to just clobber if there are side      effects in SRC or DEST.  */
if|if
condition|(
operator|(
name|dreg
operator|<
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|!=
name|MEM
operator|)
operator|||
name|side_effects_p
argument_list|(
name|src
argument_list|)
operator|||
name|side_effects_p
argument_list|(
name|dest
argument_list|)
condition|)
block|{
name|reload_cse_invalidate_rtx
argument_list|(
name|dest
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* We don't try to handle values involving CC, because it's a pain      to keep track of when they have to be invalidated.  */
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|cc0_rtx
argument_list|,
name|src
argument_list|)
operator|||
name|reg_mentioned_p
argument_list|(
name|cc0_rtx
argument_list|,
name|dest
argument_list|)
condition|)
block|{
name|reload_cse_invalidate_rtx
argument_list|(
name|dest
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* If BODY is a PARALLEL, then we need to see whether the source of      SET is clobbered by some other instruction in the PARALLEL.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|rtx
name|x
decl_stmt|;
name|x
operator|=
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|set
condition|)
continue|continue;
name|reload_cse_check_clobbered
operator|=
literal|0
expr_stmt|;
name|reload_cse_check_src
operator|=
name|src
expr_stmt|;
name|note_stores
argument_list|(
name|x
argument_list|,
name|reload_cse_check_clobber
argument_list|)
expr_stmt|;
if|if
condition|(
name|reload_cse_check_clobbered
condition|)
block|{
name|reload_cse_invalidate_rtx
argument_list|(
name|dest
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
if|if
condition|(
name|dreg
operator|>=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* This is an assignment to a register.  Update the value we          have stored for the register.  */
if|if
condition|(
name|sreg
operator|>=
literal|0
condition|)
block|{
name|rtx
name|x
decl_stmt|;
comment|/* This is a copy from one register to another.  Any values 	     which were valid for SREG are now valid for DREG.  If the 	     mode changes, we use gen_lowpart_common to extract only 	     the part of the value that is copied.  */
name|reg_values
index|[
name|dreg
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|x
operator|=
name|reg_values
index|[
name|sreg
index|]
init|;
name|x
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|rtx
name|tmp
decl_stmt|;
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|dest_mode
operator|==
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|tmp
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|dest_mode
argument_list|)
operator|>
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
continue|continue;
else|else
name|tmp
operator|=
name|gen_lowpart_common
argument_list|(
name|dest_mode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
condition|)
name|reg_values
index|[
name|dreg
index|]
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|dest_mode
argument_list|,
name|tmp
argument_list|,
name|reg_values
index|[
name|dreg
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|reg_values
index|[
name|dreg
index|]
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|dest_mode
argument_list|,
name|src
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
comment|/* We've changed DREG, so invalidate any values held by other          registers that depend upon it.  */
name|reload_cse_invalidate_regno
argument_list|(
name|dreg
argument_list|,
name|dest_mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If this assignment changes more than one hard register,          forget anything we know about the others.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|HARD_REGNO_NREGS
argument_list|(
name|dreg
argument_list|,
name|dest_mode
argument_list|)
condition|;
name|i
operator|++
control|)
name|reg_values
index|[
name|dreg
operator|+
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
condition|)
block|{
comment|/* Invalidate conflicting memory locations.  */
name|reload_cse_invalidate_mem
argument_list|(
name|dest
argument_list|)
expr_stmt|;
comment|/* If we're storing a register to memory, add DEST to the list          in REG_VALUES.  */
if|if
condition|(
name|sreg
operator|>=
literal|0
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|dest
argument_list|)
condition|)
name|reg_values
index|[
name|sreg
index|]
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|dest_mode
argument_list|,
name|dest
argument_list|,
name|reg_values
index|[
name|sreg
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We should have bailed out earlier.  */
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

end_unit

