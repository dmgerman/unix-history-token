begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Analyze loop dependencies    Copyright (C) 2000, 2002 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* References:    Practical Dependence Testing, Goff, Kennedy, Tseng, PLDI, 1991    High Performance Compilers for Parallel Computing, Wolfe */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"c-common.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"varray.h"
end_include

begin_define
define|#
directive|define
name|MAX_SUBSCRIPTS
value|13
end_define

begin_comment
comment|/*    We perform the following steps:     Build the data structures def_use_chain, loop_chain, and induction_chain.     Determine if a loop index is a normalized induction variable.    A loop is currently considered to be a for loop having an index set to an    initial value, conditional check of the index, and increment/decrement of    the index.     Determine the distance and direction vectors.  Both are two dimensioned    arrays where the first dimension represents a loop and the second    dimension represents a subscript.  Dependencies are actually per loop, not    per subscript.  So for:    for (i = 0; i< 10; i++)        for (j = 0; j< 10; j++)            array [i][j] = array[i][j-1]    We find the dependencies: loop1/sub_i, loop1/sub_j, loop2/sub_i, loop2/sub_j    and then intersect loop1/sub_i V loop2/sub_i and loop1/sub_i V loop2/sub_j    We determine the type of dependence, which determines which test we use.    We then try to refine the type of dependence we have and add the    dependence to the dep_chain */
end_comment

begin_enum
enum|enum
name|dependence_type
block|{
name|dt_flow
block|,
name|dt_anti
block|,
name|dt_output
block|,
name|dt_none
block|}
enum|;
end_enum

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static const char *const dependence_string [] = {"flow", "anti", "output", "none"};
endif|#
directive|endif
end_endif

begin_enum
enum|enum
name|direction_type
block|{
name|lt
block|,
name|le
block|,
name|eq
block|,
name|gt
block|,
name|ge
block|,
name|star
block|,
name|independent
block|,
name|undef
block|}
enum|;
end_enum

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static const char *const direction_string [] = {"<", "<=", "=", ">", ">=", "*", 					   "INDEPENDENT", "UNDEFINED"};
endif|#
directive|endif
end_endif

begin_enum
enum|enum
name|def_use_type
block|{
name|def
block|,
name|use
block|,
name|init_def_use
block|}
enum|;
end_enum

begin_enum
enum|enum
name|du_status_type
block|{
name|seen
block|,
name|unseen
block|}
enum|;
end_enum

begin_enum
enum|enum
name|loop_status_type
block|{
name|normal
block|,
name|unnormal
block|}
enum|;
end_enum

begin_enum
enum|enum
name|complexity_type
block|{
name|ziv
block|,
name|strong_siv
block|,
name|weak_siv
block|,
name|weak_zero_siv
block|,
name|weak_crossing_siv
block|,
name|miv
block|}
enum|;
end_enum

begin_comment
comment|/* Given a def/use one can chase the next chain to follow the def/use    for that variable.  Alternately one can sequentially follow each    element of def_use_chain.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|def_use
block|{
comment|/* outermost loop */
name|tree
name|outer_loop
decl_stmt|;
comment|/* loop containing this def/use */
name|tree
name|containing_loop
decl_stmt|;
comment|/* this expression */
name|tree
name|expression
decl_stmt|;
comment|/* our name */
specifier|const
name|char
modifier|*
name|variable
decl_stmt|;
comment|/* def or use */
name|enum
name|def_use_type
name|type
decl_stmt|;
comment|/* status flags */
name|enum
name|du_status_type
name|status
decl_stmt|;
comment|/* next def/use for this same name */
name|struct
name|def_use
modifier|*
name|next
decl_stmt|;
comment|/* dependencies for this def */
name|struct
name|dependence
modifier|*
name|dep
decl_stmt|;
block|}
name|def_use
typedef|;
end_typedef

begin_comment
comment|/* Given a loop* one can chase the next_nest chain to follow the nested    loops for that loop.  Alternately one can sequentially follow each    element of loop_chain and check outer_loop to get all loops    contained within a certain loop.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|loop
block|{
comment|/* outermost loop containing this loop */
name|tree
name|outer_loop
decl_stmt|;
comment|/* this loop */
name|tree
name|containing_loop
decl_stmt|;
comment|/* nest level for this loop */
name|int
name|depth
decl_stmt|;
comment|/* can loop be normalized? */
name|enum
name|loop_status_type
name|status
decl_stmt|;
comment|/* loop* for loop contained in this loop */
name|struct
name|loop
modifier|*
name|next_nest
decl_stmt|;
comment|/* induction variables for this loop.  Currently only the index variable.  */
name|struct
name|induction
modifier|*
name|ind
decl_stmt|;
block|}
name|loop
typedef|;
end_typedef

begin_comment
comment|/* Pointed to by loop. One per induction variable.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|induction
block|{
comment|/* our name */
specifier|const
name|char
modifier|*
name|variable
decl_stmt|;
comment|/* increment.  Currently only +1 or -1 */
name|int
name|increment
decl_stmt|;
comment|/* lower bound */
name|int
name|low_bound
decl_stmt|;
comment|/* upper bound */
name|int
name|high_bound
decl_stmt|;
comment|/* next induction variable for this loop.  Currently null.  */
name|struct
name|induction
modifier|*
name|next
decl_stmt|;
block|}
name|induction
typedef|;
end_typedef

begin_comment
comment|/* Pointed to by def/use.  One per dependence.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|dependence
block|{
name|tree
name|source
decl_stmt|;
name|tree
name|destination
decl_stmt|;
name|enum
name|dependence_type
name|dependence
decl_stmt|;
name|enum
name|direction_type
name|direction
index|[
name|MAX_SUBSCRIPTS
index|]
decl_stmt|;
name|int
name|distance
index|[
name|MAX_SUBSCRIPTS
index|]
decl_stmt|;
name|struct
name|dependence
modifier|*
name|next
decl_stmt|;
block|}
name|dependence
typedef|;
end_typedef

begin_comment
comment|/* subscripts are represented by an array of these.  Each reflects one    X * i + Y term, where X and Y are constants.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|subscript
block|{
comment|/* ordinal subscript number */
name|int
name|position
decl_stmt|;
comment|/* X in X * i + Y */
name|int
name|coefficient
decl_stmt|;
comment|/* Y in X * i + Y */
name|int
name|offset
decl_stmt|;
comment|/* our name */
specifier|const
name|char
modifier|*
name|variable
decl_stmt|;
comment|/* next subscript term.  Currently null.  */
name|struct
name|subscript
modifier|*
name|next
decl_stmt|;
block|}
name|subscript
typedef|;
end_typedef

begin_comment
comment|/* Remember the destination the front end encountered.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|dest_to_remember
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain for def_use */
end_comment

begin_decl_stmt
specifier|static
name|varray_type
name|def_use_chain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain for dependence */
end_comment

begin_decl_stmt
specifier|static
name|varray_type
name|dep_chain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain for loop */
end_comment

begin_decl_stmt
specifier|static
name|varray_type
name|loop_chain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain for induction */
end_comment

begin_decl_stmt
specifier|static
name|varray_type
name|induction_chain
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|init_dependence_analysis
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|build_def_use
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
expr|enum
name|def_use_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|loop
modifier|*
name|add_loop
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|find_induction_variable
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|loop
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_low_bound
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|have_induction_variable
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|link_loops
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|get_node_dependence
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|check_node_dependence
name|PARAMS
argument_list|(
operator|(
name|def_use
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_coefficients
name|PARAMS
argument_list|(
operator|(
name|def_use
operator|*
operator|,
name|subscript
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_one_coefficient
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|subscript
operator|*
operator|,
name|def_use
operator|*
operator|,
expr|enum
name|tree_code
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|normalize_coefficients
name|PARAMS
argument_list|(
operator|(
name|subscript
index|[]
operator|,
name|loop
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|classify_dependence
name|PARAMS
argument_list|(
operator|(
name|subscript
index|[]
operator|,
name|subscript
index|[]
operator|,
expr|enum
name|complexity_type
index|[]
operator|,
name|int
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ziv_test
name|PARAMS
argument_list|(
operator|(
name|subscript
index|[]
operator|,
name|subscript
index|[]
operator|,
expr|enum
name|direction_type
index|[]
index|[
name|MAX_SUBSCRIPTS
index|]
operator|,
name|int
index|[]
index|[
name|MAX_SUBSCRIPTS
index|]
operator|,
name|loop
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|siv_test
name|PARAMS
argument_list|(
operator|(
name|subscript
index|[]
operator|,
name|subscript
index|[]
operator|,
expr|enum
name|direction_type
index|[]
index|[
name|MAX_SUBSCRIPTS
index|]
operator|,
name|int
index|[]
index|[
name|MAX_SUBSCRIPTS
index|]
operator|,
name|loop
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|check_subscript_induction
name|PARAMS
argument_list|(
operator|(
name|subscript
operator|*
operator|,
name|subscript
operator|*
operator|,
name|loop
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gcd_test
name|PARAMS
argument_list|(
operator|(
name|subscript
index|[]
operator|,
name|subscript
index|[]
operator|,
expr|enum
name|direction_type
index|[]
index|[
name|MAX_SUBSCRIPTS
index|]
operator|,
name|int
index|[]
index|[
name|MAX_SUBSCRIPTS
index|]
operator|,
name|loop
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|find_gcd
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|merge_dependencies
name|PARAMS
argument_list|(
operator|(
expr|enum
name|direction_type
index|[]
index|[
name|MAX_SUBSCRIPTS
index|]
operator|,
name|int
index|[]
index|[
name|MAX_SUBSCRIPTS
index|]
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_array_ref
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void dump_one_node PARAMS ((def_use*, varray_type*)); static void dump_node_dependence PARAMS ((void));
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|search_dependence
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|remember_dest_for_dependence
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|have_dependence_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
expr|enum
name|direction_type
index|[]
operator|,
name|int
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|end_dependence_analysis
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Build dependence chain 'dep_chain', which is used by have_dependence_p,    for the function given by EXP.  */
end_comment

begin_function
name|void
name|init_dependence_analysis
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|def_use
modifier|*
name|du_ptr
decl_stmt|;
name|VARRAY_GENERIC_PTR_INIT
argument_list|(
name|def_use_chain
argument_list|,
literal|50
argument_list|,
literal|"def_use_chain"
argument_list|)
expr_stmt|;
name|VARRAY_GENERIC_PTR_INIT
argument_list|(
name|dep_chain
argument_list|,
literal|50
argument_list|,
literal|"dep_chain"
argument_list|)
expr_stmt|;
name|VARRAY_GENERIC_PTR_INIT
argument_list|(
name|loop_chain
argument_list|,
literal|50
argument_list|,
literal|"loop_chain"
argument_list|)
expr_stmt|;
name|VARRAY_GENERIC_PTR_INIT
argument_list|(
name|induction_chain
argument_list|,
literal|50
argument_list|,
literal|"induction_chain"
argument_list|)
expr_stmt|;
name|build_def_use
argument_list|(
name|exp
argument_list|,
name|init_def_use
argument_list|)
expr_stmt|;
name|link_loops
argument_list|()
expr_stmt|;
name|get_node_dependence
argument_list|()
expr_stmt|;
comment|/* dump_node_dependence (&def_use_chain);*/
for|for
control|(
name|du_ptr
operator|=
name|VARRAY_TOP
argument_list|(
name|def_use_chain
argument_list|,
name|generic
argument_list|)
init|;
name|VARRAY_POP
argument_list|(
name|def_use_chain
argument_list|)
condition|;
name|du_ptr
operator|=
name|VARRAY_TOP
argument_list|(
name|def_use_chain
argument_list|,
name|generic
argument_list|)
control|)
block|{
name|free
argument_list|(
name|du_ptr
argument_list|)
expr_stmt|;
block|}
name|VARRAY_FREE
argument_list|(
name|def_use_chain
argument_list|)
expr_stmt|;
name|VARRAY_FREE
argument_list|(
name|loop_chain
argument_list|)
expr_stmt|;
name|VARRAY_FREE
argument_list|(
name|induction_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Build ARRAY_REF def/use info 'def_use_chain' starting at EXP which is a def    or use DU_TYPE */
end_comment

begin_function
specifier|static
name|void
name|build_def_use
parameter_list|(
name|exp
parameter_list|,
name|du_type
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|enum
name|def_use_type
name|du_type
decl_stmt|;
block|{
specifier|static
name|tree
name|outer_loop
decl_stmt|;
specifier|static
name|int
name|nloop
decl_stmt|;
specifier|static
name|tree
name|current_loop
decl_stmt|;
specifier|static
name|int
name|du_idx
decl_stmt|;
specifier|static
name|loop
modifier|*
name|loop_def
decl_stmt|;
name|tree
name|node
init|=
name|exp
decl_stmt|;
name|tree
name|array_ref
decl_stmt|;
name|def_use
modifier|*
name|du_ptr
decl_stmt|;
if|if
condition|(
name|du_type
operator|==
name|init_def_use
condition|)
block|{
name|outer_loop
operator|=
literal|0
expr_stmt|;
name|nloop
operator|=
literal|0
expr_stmt|;
name|du_idx
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|node
condition|)
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
condition|)
block|{
case|case
name|COMPOUND_STMT
case|:
name|node
operator|=
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|TREE_LIST
case|:
name|build_def_use
argument_list|(
name|TREE_VALUE
argument_list|(
name|node
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|node
operator|=
name|TREE_CHAIN
argument_list|(
name|node
argument_list|)
expr_stmt|;
break|break;
case|case
name|CALL_EXPR
case|:
name|node
operator|=
name|TREE_CHAIN
argument_list|(
name|node
argument_list|)
expr_stmt|;
break|break;
case|case
name|FOR_STMT
case|:
if|if
condition|(
operator|!
name|nloop
condition|)
name|outer_loop
operator|=
name|node
expr_stmt|;
name|nloop
operator|++
expr_stmt|;
name|current_loop
operator|=
name|node
expr_stmt|;
name|loop_def
operator|=
name|add_loop
argument_list|(
name|node
argument_list|,
name|outer_loop
argument_list|,
name|nloop
argument_list|)
expr_stmt|;
if|if
condition|(
name|find_induction_variable
argument_list|(
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|2
argument_list|)
argument_list|,
name|loop_def
argument_list|)
operator|==
literal|0
condition|)
name|loop_def
operator|->
name|status
operator|=
name|unnormal
expr_stmt|;
name|build_def_use
argument_list|(
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|3
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nloop
operator|--
expr_stmt|;
name|current_loop
operator|=
literal|0
expr_stmt|;
name|node
operator|=
name|TREE_CHAIN
argument_list|(
name|node
argument_list|)
expr_stmt|;
break|break;
case|case
name|MODIFY_EXPR
case|:
comment|/* Is an induction variable modified? */
if|if
condition|(
name|loop_def
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|have_induction_variable
argument_list|(
name|loop_def
operator|->
name|outer_loop
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
name|loop_def
operator|->
name|status
operator|=
name|unnormal
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ARRAY_REF
operator|||
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
name|build_def_use
argument_list|(
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
argument_list|,
name|def
argument_list|)
expr_stmt|;
name|build_def_use
argument_list|(
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|1
argument_list|)
argument_list|,
name|use
argument_list|)
expr_stmt|;
name|node
operator|=
name|TREE_CHAIN
argument_list|(
name|node
argument_list|)
expr_stmt|;
break|break;
case|case
name|INDIRECT_REF
case|:
if|if
condition|(
operator|!
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|1
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|ARRAY_REF
condition|)
block|{
name|node
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|node
operator|=
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
case|case
name|ARRAY_REF
case|:
if|if
condition|(
name|nloop
condition|)
block|{
name|int
name|i
decl_stmt|;
name|char
name|null_string
init|=
literal|'\0'
decl_stmt|;
name|VARRAY_PUSH_GENERIC_PTR
argument_list|(
name|def_use_chain
argument_list|,
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|def_use
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|du_ptr
operator|=
name|VARRAY_GENERIC_PTR
argument_list|(
name|def_use_chain
argument_list|,
name|du_idx
operator|++
argument_list|)
expr_stmt|;
name|du_ptr
operator|->
name|type
operator|=
name|du_type
expr_stmt|;
name|du_ptr
operator|->
name|status
operator|=
name|unseen
expr_stmt|;
name|du_ptr
operator|->
name|outer_loop
operator|=
name|outer_loop
expr_stmt|;
name|du_ptr
operator|->
name|containing_loop
operator|=
name|current_loop
expr_stmt|;
name|du_ptr
operator|->
name|expression
operator|=
name|node
expr_stmt|;
name|du_ptr
operator|->
name|variable
operator|=
operator|&
name|null_string
expr_stmt|;
name|du_ptr
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|du_ptr
operator|->
name|dep
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|array_ref
operator|=
name|node
init|;
name|TREE_CODE
argument_list|(
name|array_ref
argument_list|)
operator|==
name|ARRAY_REF
condition|;
name|array_ref
operator|=
name|TREE_OPERAND
argument_list|(
name|array_ref
argument_list|,
literal|0
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|array_ref
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
block|{
name|array_ref
operator|=
name|TREE_OPERAND
argument_list|(
name|array_ref
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|array_ref
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|array_ref
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|)
condition|)
block|{
name|node
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|du_idx
operator|&&
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|array_ref
argument_list|)
argument_list|)
argument_list|,
operator|(
operator|(
name|def_use
operator|*
operator|)
operator|(
name|VARRAY_GENERIC_PTR
argument_list|(
name|def_use_chain
argument_list|,
name|i
argument_list|)
operator|)
operator|)
operator|->
name|variable
argument_list|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|!=
name|du_idx
condition|)
block|{
name|def_use
modifier|*
name|tmp_duc
decl_stmt|;
for|for
control|(
name|tmp_duc
operator|=
operator|(
operator|(
name|def_use
operator|*
operator|)
operator|(
name|VARRAY_GENERIC_PTR
argument_list|(
name|def_use_chain
argument_list|,
name|i
argument_list|)
operator|)
operator|)
init|;
name|tmp_duc
operator|->
name|next
condition|;
name|tmp_duc
operator|=
operator|(
operator|(
name|def_use
operator|*
operator|)
name|tmp_duc
operator|->
name|next
operator|)
control|)
empty_stmt|;
name|tmp_duc
operator|->
name|next
operator|=
name|du_ptr
expr_stmt|;
block|}
else|else
name|du_ptr
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|du_ptr
operator|->
name|variable
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|array_ref
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|node
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SCOPE_STMT
case|:
case|case
name|DECL_STMT
case|:
name|node
operator|=
name|TREE_CHAIN
argument_list|(
name|node
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXPR_STMT
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MODIFY_EXPR
condition|)
name|build_def_use
argument_list|(
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
argument_list|,
name|def
argument_list|)
expr_stmt|;
name|node
operator|=
name|TREE_CHAIN
argument_list|(
name|node
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
argument_list|)
operator|==
literal|'2'
condition|)
block|{
name|build_def_use
argument_list|(
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
argument_list|,
name|use
argument_list|)
expr_stmt|;
name|build_def_use
argument_list|(
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|1
argument_list|)
argument_list|,
name|use
argument_list|)
expr_stmt|;
name|node
operator|=
name|TREE_CHAIN
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|node
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Add a loop to 'loop_chain' corresponding to for loop LOOP_NODE at depth    NLOOP, whose outermost loop is OUTER_LOOP */
end_comment

begin_function
specifier|static
name|loop
modifier|*
name|add_loop
parameter_list|(
name|loop_node
parameter_list|,
name|outer_loop
parameter_list|,
name|nloop
parameter_list|)
name|tree
name|loop_node
decl_stmt|;
name|tree
name|outer_loop
decl_stmt|;
name|int
name|nloop
decl_stmt|;
block|{
name|loop
modifier|*
name|loop_ptr
decl_stmt|;
name|VARRAY_PUSH_GENERIC_PTR
argument_list|(
name|loop_chain
argument_list|,
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|loop
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|loop_ptr
operator|=
name|VARRAY_TOP
argument_list|(
name|loop_chain
argument_list|,
name|generic
argument_list|)
expr_stmt|;
name|loop_ptr
operator|->
name|outer_loop
operator|=
name|outer_loop
expr_stmt|;
name|loop_ptr
operator|->
name|containing_loop
operator|=
name|loop_node
expr_stmt|;
name|loop_ptr
operator|->
name|depth
operator|=
name|nloop
expr_stmt|;
name|loop_ptr
operator|->
name|status
operator|=
name|normal
expr_stmt|;
name|loop_ptr
operator|->
name|next_nest
operator|=
literal|0
expr_stmt|;
name|loop_ptr
operator|->
name|ind
operator|=
literal|0
expr_stmt|;
return|return
name|loop_ptr
return|;
block|}
end_function

begin_comment
comment|/* Update LOOP_DEF if for loop's COND_NODE and INCR_NODE define an index that    is a normalized induction variable.  */
end_comment

begin_function
specifier|static
name|int
name|find_induction_variable
parameter_list|(
name|init_node
parameter_list|,
name|cond_node
parameter_list|,
name|incr_node
parameter_list|,
name|loop_def
parameter_list|)
name|tree
name|init_node
decl_stmt|;
name|tree
name|cond_node
decl_stmt|;
name|tree
name|incr_node
decl_stmt|;
name|loop
modifier|*
name|loop_def
decl_stmt|;
block|{
name|induction
modifier|*
name|ind_ptr
decl_stmt|;
name|enum
name|tree_code
name|incr_code
decl_stmt|;
name|tree
name|incr
decl_stmt|;
if|if
condition|(
operator|!
name|init_node
operator|||
operator|!
name|incr_node
operator|||
operator|!
name|cond_node
condition|)
return|return
literal|0
return|;
comment|/* Allow for ',' operator in increment expression of FOR */
name|incr
operator|=
name|incr_node
expr_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|incr
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
block|{
name|incr_code
operator|=
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|incr
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|incr_code
operator|==
name|PREDECREMENT_EXPR
operator|||
name|incr_code
operator|==
name|POSTDECREMENT_EXPR
operator|||
name|incr_code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|incr_code
operator|==
name|POSTINCREMENT_EXPR
condition|)
block|{
name|incr_node
operator|=
name|TREE_OPERAND
argument_list|(
name|incr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|incr_code
operator|=
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|incr
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|incr_code
operator|==
name|PREDECREMENT_EXPR
operator|||
name|incr_code
operator|==
name|POSTDECREMENT_EXPR
operator|||
name|incr_code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|incr_code
operator|==
name|POSTINCREMENT_EXPR
condition|)
block|{
name|incr_node
operator|=
name|TREE_OPERAND
argument_list|(
name|incr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
name|incr
operator|=
name|TREE_OPERAND
argument_list|(
name|incr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Allow index condition to be part of logical expression */
name|cond_node
operator|=
name|TREE_VALUE
argument_list|(
name|cond_node
argument_list|)
expr_stmt|;
name|incr
operator|=
name|cond_node
expr_stmt|;
define|#
directive|define
name|INDEX_LIMIT_CHECK
parameter_list|(
name|NODE
parameter_list|)
define|\
value|(TREE_CODE_CLASS (TREE_CODE (NODE)) == '<') \&& (TREE_CODE (TREE_OPERAND (NODE, 0)) == VAR_DECL \&& (IDENTIFIER_POINTER (DECL_NAME (TREE_OPERAND (NODE, 0))) \ 		== IDENTIFIER_POINTER (DECL_NAME (TREE_OPERAND (incr_node, 0))))) \       ? 1 : 0
while|while
condition|(
name|TREE_CODE
argument_list|(
name|incr
argument_list|)
operator|==
name|TRUTH_ANDIF_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|incr
argument_list|)
operator|==
name|TRUTH_ORIF_EXPR
condition|)
block|{
if|if
condition|(
name|INDEX_LIMIT_CHECK
argument_list|(
name|TREE_OPERAND
argument_list|(
name|incr
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|cond_node
operator|=
name|TREE_OPERAND
argument_list|(
name|incr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|INDEX_LIMIT_CHECK
argument_list|(
name|TREE_OPERAND
argument_list|(
name|incr
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|cond_node
operator|=
name|TREE_OPERAND
argument_list|(
name|incr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
name|incr
operator|=
name|TREE_OPERAND
argument_list|(
name|incr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|incr_code
operator|=
name|TREE_CODE
argument_list|(
name|incr_node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|incr_code
operator|==
name|PREDECREMENT_EXPR
operator|||
name|incr_code
operator|==
name|POSTDECREMENT_EXPR
operator|||
name|incr_code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|incr_code
operator|==
name|POSTINCREMENT_EXPR
operator|)
operator|&&
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|cond_node
argument_list|)
argument_list|)
operator|==
literal|'<'
condition|)
block|{
if|if
condition|(
operator|!
name|INDEX_LIMIT_CHECK
argument_list|(
name|cond_node
argument_list|)
condition|)
return|return
literal|0
return|;
name|VARRAY_PUSH_GENERIC_PTR
argument_list|(
name|induction_chain
argument_list|,
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|induction
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ind_ptr
operator|=
name|VARRAY_TOP
argument_list|(
name|induction_chain
argument_list|,
name|generic
argument_list|)
expr_stmt|;
name|loop_def
operator|->
name|ind
operator|=
name|ind_ptr
expr_stmt|;
name|ind_ptr
operator|->
name|variable
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|TREE_OPERAND
argument_list|(
name|incr_node
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ind_ptr
operator|->
name|increment
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|incr_node
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|incr_node
argument_list|)
operator|==
name|PREDECREMENT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|incr_node
argument_list|)
operator|==
name|POSTDECREMENT_EXPR
condition|)
name|ind_ptr
operator|->
name|increment
operator|=
operator|-
name|ind_ptr
operator|->
name|increment
expr_stmt|;
name|ind_ptr
operator|->
name|low_bound
operator|=
name|get_low_bound
argument_list|(
name|init_node
argument_list|,
name|ind_ptr
operator|->
name|variable
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|cond_node
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|TREE_OPERAND
argument_list|(
name|cond_node
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|ind_ptr
operator|->
name|variable
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|cond_node
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|ind_ptr
operator|->
name|high_bound
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|cond_node
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|ind_ptr
operator|->
name|high_bound
operator|=
name|ind_ptr
operator|->
name|increment
operator|<
literal|0
condition|?
name|INT_MIN
else|:
name|INT_MAX
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|cond_node
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|TREE_OPERAND
argument_list|(
name|cond_node
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|==
name|ind_ptr
operator|->
name|variable
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|cond_node
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|ind_ptr
operator|->
name|high_bound
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|cond_node
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|ind_ptr
operator|->
name|high_bound
operator|=
name|ind_ptr
operator|->
name|increment
operator|<
literal|0
condition|?
name|INT_MIN
else|:
name|INT_MAX
expr_stmt|;
block|}
name|ind_ptr
operator|->
name|next
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the low bound for induction VARIABLE in NODE */
end_comment

begin_function
specifier|static
name|int
name|get_low_bound
parameter_list|(
name|node
parameter_list|,
name|variable
parameter_list|)
name|tree
name|node
decl_stmt|;
specifier|const
name|char
modifier|*
name|variable
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|SCOPE_STMT
condition|)
name|node
operator|=
name|TREE_CHAIN
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|node
condition|)
return|return
name|INT_MIN
return|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MODIFY_EXPR
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|variable
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|EXPR_STMT
condition|)
name|node
operator|=
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|MODIFY_EXPR
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|variable
operator|)
condition|)
block|{
return|return
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
return|return
name|INT_MIN
return|;
block|}
end_function

begin_comment
comment|/* Return the ordinal subscript position for IND_VAR if it is an induction    variable contained in OUTER_LOOP, otherwise return -1.  */
end_comment

begin_function
specifier|static
name|int
name|have_induction_variable
parameter_list|(
name|outer_loop
parameter_list|,
name|ind_var
parameter_list|)
name|tree
name|outer_loop
decl_stmt|;
specifier|const
name|char
modifier|*
name|ind_var
decl_stmt|;
block|{
name|induction
modifier|*
name|ind_ptr
decl_stmt|;
name|loop
modifier|*
name|loop_ptr
decl_stmt|;
name|unsigned
name|int
name|ind_idx
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|loop_idx
init|=
literal|0
decl_stmt|;
for|for
control|(
name|loop_ptr
operator|=
name|VARRAY_GENERIC_PTR
argument_list|(
name|loop_chain
argument_list|,
name|loop_idx
argument_list|)
init|;
name|loop_ptr
operator|&&
name|loop_idx
operator|<
name|VARRAY_SIZE
argument_list|(
name|loop_chain
argument_list|)
condition|;
name|loop_ptr
operator|=
name|VARRAY_GENERIC_PTR
argument_list|(
name|loop_chain
argument_list|,
operator|++
name|loop_idx
argument_list|)
control|)
if|if
condition|(
name|loop_ptr
operator|->
name|outer_loop
operator|==
name|outer_loop
condition|)
for|for
control|(
name|ind_ptr
operator|=
name|loop_ptr
operator|->
name|ind
init|;
name|ind_ptr
operator|&&
name|ind_idx
operator|<
name|VARRAY_SIZE
argument_list|(
name|induction_chain
argument_list|)
condition|;
name|ind_ptr
operator|=
name|ind_ptr
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ind_ptr
operator|->
name|variable
argument_list|,
name|ind_var
argument_list|)
condition|)
return|return
name|loop_idx
operator|+
literal|1
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Chain the nodes of 'loop_chain'.  */
end_comment

begin_function
specifier|static
name|void
name|link_loops
parameter_list|()
block|{
name|unsigned
name|int
name|loop_idx
init|=
literal|0
decl_stmt|;
name|loop
modifier|*
name|loop_ptr
decl_stmt|,
modifier|*
name|prev_loop_ptr
init|=
literal|0
decl_stmt|;
name|prev_loop_ptr
operator|=
name|VARRAY_GENERIC_PTR
argument_list|(
name|loop_chain
argument_list|,
name|loop_idx
argument_list|)
expr_stmt|;
for|for
control|(
name|loop_ptr
operator|=
name|VARRAY_GENERIC_PTR
argument_list|(
name|loop_chain
argument_list|,
operator|++
name|loop_idx
argument_list|)
init|;
name|loop_ptr
operator|&&
name|loop_idx
operator|<
name|VARRAY_SIZE
argument_list|(
name|loop_chain
argument_list|)
condition|;
name|loop_ptr
operator|=
name|VARRAY_GENERIC_PTR
argument_list|(
name|loop_chain
argument_list|,
operator|++
name|loop_idx
argument_list|)
control|)
block|{
if|if
condition|(
name|prev_loop_ptr
operator|->
name|outer_loop
operator|==
name|loop_ptr
operator|->
name|outer_loop
condition|)
block|{
if|if
condition|(
name|prev_loop_ptr
operator|->
name|depth
operator|==
name|loop_ptr
operator|->
name|depth
operator|-
literal|1
condition|)
name|prev_loop_ptr
operator|->
name|next_nest
operator|=
name|loop_ptr
expr_stmt|;
name|prev_loop_ptr
operator|=
name|loop_ptr
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Check the dependence for each member of 'def_use_chain'.  */
end_comment

begin_function
specifier|static
name|void
name|get_node_dependence
parameter_list|()
block|{
name|unsigned
name|int
name|du_idx
decl_stmt|;
name|def_use
modifier|*
name|du_ptr
decl_stmt|;
name|du_idx
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|du_ptr
operator|=
name|VARRAY_GENERIC_PTR
argument_list|(
name|def_use_chain
argument_list|,
name|du_idx
argument_list|)
init|;
name|du_ptr
operator|&&
name|du_idx
operator|<
name|VARRAY_SIZE
argument_list|(
name|def_use_chain
argument_list|)
condition|;
name|du_ptr
operator|=
name|VARRAY_GENERIC_PTR
argument_list|(
name|def_use_chain
argument_list|,
name|du_idx
operator|++
argument_list|)
control|)
block|{
if|if
condition|(
name|du_ptr
operator|->
name|status
operator|==
name|unseen
condition|)
name|check_node_dependence
argument_list|(
name|du_ptr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Check the dependence for definition DU.  */
end_comment

begin_function
specifier|static
name|void
name|check_node_dependence
parameter_list|(
name|du
parameter_list|)
name|def_use
modifier|*
name|du
decl_stmt|;
block|{
name|def_use
modifier|*
name|def_ptr
decl_stmt|,
modifier|*
name|use_ptr
decl_stmt|;
name|dependence
modifier|*
name|dep_ptr
decl_stmt|,
modifier|*
name|dep_list
decl_stmt|;
name|subscript
name|icoefficients
index|[
name|MAX_SUBSCRIPTS
index|]
decl_stmt|;
name|subscript
name|ocoefficients
index|[
name|MAX_SUBSCRIPTS
index|]
decl_stmt|;
name|loop
modifier|*
name|loop_ptr
decl_stmt|,
modifier|*
name|ck_loop_ptr
decl_stmt|;
name|unsigned
name|int
name|loop_idx
init|=
literal|0
decl_stmt|;
name|int
name|distance
index|[
name|MAX_SUBSCRIPTS
index|]
index|[
name|MAX_SUBSCRIPTS
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|subscript_count
decl_stmt|;
name|int
name|unnormal_loop
decl_stmt|;
name|enum
name|direction_type
name|direction
index|[
name|MAX_SUBSCRIPTS
index|]
index|[
name|MAX_SUBSCRIPTS
index|]
decl_stmt|;
name|enum
name|complexity_type
name|complexity
index|[
name|MAX_SUBSCRIPTS
index|]
decl_stmt|;
name|int
name|separability
decl_stmt|;
name|int
name|have_dependence
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|MAX_SUBSCRIPTS
condition|;
name|j
operator|++
control|)
block|{
name|direction
index|[
name|j
index|]
index|[
literal|0
index|]
operator|=
name|undef
expr_stmt|;
name|distance
index|[
name|j
index|]
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|def_ptr
operator|=
name|du
init|;
name|def_ptr
condition|;
name|def_ptr
operator|=
name|def_ptr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|def_ptr
operator|->
name|type
operator|!=
name|def
condition|)
continue|continue;
name|subscript_count
operator|=
name|get_coefficients
argument_list|(
name|def_ptr
argument_list|,
name|ocoefficients
argument_list|)
expr_stmt|;
if|if
condition|(
name|subscript_count
operator|<
literal|0
condition|)
continue|continue;
name|loop_idx
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|loop_ptr
operator|=
name|VARRAY_GENERIC_PTR
argument_list|(
name|loop_chain
argument_list|,
name|loop_idx
argument_list|)
init|;
name|loop_ptr
operator|&&
name|loop_idx
operator|<
name|VARRAY_SIZE
argument_list|(
name|loop_chain
argument_list|)
condition|;
name|loop_ptr
operator|=
name|VARRAY_GENERIC_PTR
argument_list|(
name|loop_chain
argument_list|,
operator|++
name|loop_idx
argument_list|)
control|)
block|{
if|if
condition|(
name|loop_ptr
operator|->
name|outer_loop
operator|==
name|def_ptr
operator|->
name|outer_loop
condition|)
break|break;
block|}
name|unnormal_loop
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ck_loop_ptr
operator|=
name|loop_ptr
init|;
name|ck_loop_ptr
operator|&&
name|loop_idx
operator|<
name|VARRAY_SIZE
argument_list|(
name|loop_chain
argument_list|)
condition|;
name|ck_loop_ptr
operator|=
name|VARRAY_GENERIC_PTR
argument_list|(
name|loop_chain
argument_list|,
operator|++
name|loop_idx
argument_list|)
control|)
block|{
if|if
condition|(
name|ck_loop_ptr
operator|->
name|outer_loop
operator|==
name|def_ptr
operator|->
name|outer_loop
operator|&&
name|ck_loop_ptr
operator|->
name|status
operator|==
name|unnormal
condition|)
name|unnormal_loop
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|unnormal_loop
condition|)
continue|continue;
name|normalize_coefficients
argument_list|(
name|ocoefficients
argument_list|,
name|loop_ptr
argument_list|,
name|subscript_count
argument_list|)
expr_stmt|;
for|for
control|(
name|use_ptr
operator|=
name|du
init|;
name|use_ptr
condition|;
name|use_ptr
operator|=
name|use_ptr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|def_ptr
operator|==
name|use_ptr
operator|||
name|def_ptr
operator|->
name|outer_loop
operator|!=
name|use_ptr
operator|->
name|outer_loop
condition|)
continue|continue;
name|def_ptr
operator|->
name|status
operator|=
name|seen
expr_stmt|;
name|use_ptr
operator|->
name|status
operator|=
name|seen
expr_stmt|;
name|subscript_count
operator|=
name|get_coefficients
argument_list|(
name|use_ptr
argument_list|,
name|icoefficients
argument_list|)
expr_stmt|;
name|normalize_coefficients
argument_list|(
name|icoefficients
argument_list|,
name|loop_ptr
argument_list|,
name|subscript_count
argument_list|)
expr_stmt|;
name|classify_dependence
argument_list|(
name|icoefficients
argument_list|,
name|ocoefficients
argument_list|,
name|complexity
argument_list|,
operator|&
name|separability
argument_list|,
name|subscript_count
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|ck_loop_ptr
operator|=
name|loop_ptr
init|;
name|ck_loop_ptr
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|subscript_count
condition|;
name|j
operator|++
control|)
block|{
name|direction
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|star
expr_stmt|;
name|distance
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|INT_MAX
expr_stmt|;
if|if
condition|(
name|separability
operator|&&
name|complexity
index|[
name|j
index|]
operator|==
name|ziv
condition|)
name|ziv_test
argument_list|(
name|icoefficients
argument_list|,
name|ocoefficients
argument_list|,
name|direction
argument_list|,
name|distance
argument_list|,
name|ck_loop_ptr
argument_list|,
name|j
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|separability
operator|&&
operator|(
name|complexity
index|[
name|j
index|]
operator|==
name|strong_siv
operator|||
name|complexity
index|[
name|j
index|]
operator|==
name|weak_zero_siv
operator|||
name|complexity
index|[
name|j
index|]
operator|==
name|weak_crossing_siv
operator|)
condition|)
name|siv_test
argument_list|(
name|icoefficients
argument_list|,
name|ocoefficients
argument_list|,
name|direction
argument_list|,
name|distance
argument_list|,
name|ck_loop_ptr
argument_list|,
name|j
argument_list|)
expr_stmt|;
else|else
name|gcd_test
argument_list|(
name|icoefficients
argument_list|,
name|ocoefficients
argument_list|,
name|direction
argument_list|,
name|distance
argument_list|,
name|ck_loop_ptr
argument_list|,
name|j
argument_list|)
expr_stmt|;
comment|/* ?? Add other tests: single variable exact test, banerjee */
block|}
name|ck_loop_ptr
operator|=
name|ck_loop_ptr
operator|->
name|next_nest
expr_stmt|;
block|}
name|merge_dependencies
argument_list|(
name|direction
argument_list|,
name|distance
argument_list|,
name|i
operator|-
literal|1
argument_list|,
name|j
operator|-
literal|1
argument_list|)
expr_stmt|;
name|have_dependence
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|i
operator|-
literal|1
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|direction
index|[
name|j
index|]
index|[
literal|0
index|]
operator|!=
name|independent
condition|)
name|have_dependence
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|have_dependence
condition|)
continue|continue;
name|VARRAY_PUSH_GENERIC_PTR
argument_list|(
name|dep_chain
argument_list|,
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dependence
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|dep_ptr
operator|=
name|VARRAY_TOP
argument_list|(
name|dep_chain
argument_list|,
name|generic
argument_list|)
expr_stmt|;
name|dep_ptr
operator|->
name|source
operator|=
name|use_ptr
operator|->
name|expression
expr_stmt|;
name|dep_ptr
operator|->
name|destination
operator|=
name|def_ptr
operator|->
name|expression
expr_stmt|;
name|dep_ptr
operator|->
name|next
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|def_ptr
operator|<
name|use_ptr
operator|&&
name|use_ptr
operator|->
name|type
operator|==
name|use
condition|)
name|dep_ptr
operator|->
name|dependence
operator|=
name|dt_flow
expr_stmt|;
elseif|else
if|if
condition|(
name|def_ptr
operator|>
name|use_ptr
operator|&&
name|use_ptr
operator|->
name|type
operator|==
name|use
condition|)
name|dep_ptr
operator|->
name|dependence
operator|=
name|dt_anti
expr_stmt|;
else|else
name|dep_ptr
operator|->
name|dependence
operator|=
name|dt_output
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|i
operator|-
literal|1
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|direction
index|[
name|j
index|]
index|[
literal|0
index|]
operator|==
name|gt
condition|)
block|{
name|dep_ptr
operator|->
name|dependence
operator|=
name|dt_anti
expr_stmt|;
name|direction
index|[
name|j
index|]
index|[
literal|0
index|]
operator|=
name|lt
expr_stmt|;
name|distance
index|[
name|j
index|]
index|[
literal|0
index|]
operator|=
operator|-
name|distance
index|[
name|j
index|]
index|[
literal|0
index|]
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|direction
index|[
name|j
index|]
index|[
literal|0
index|]
operator|==
name|lt
condition|)
block|{
name|dep_ptr
operator|->
name|dependence
operator|=
name|dt_flow
expr_stmt|;
break|break;
block|}
block|}
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|MAX_SUBSCRIPTS
condition|;
name|j
operator|++
control|)
block|{
name|dep_ptr
operator|->
name|direction
index|[
name|j
index|]
operator|=
name|direction
index|[
name|j
index|]
index|[
literal|0
index|]
expr_stmt|;
name|dep_ptr
operator|->
name|distance
index|[
name|j
index|]
operator|=
name|distance
index|[
name|j
index|]
index|[
literal|0
index|]
expr_stmt|;
block|}
for|for
control|(
name|dep_list
operator|=
name|def_ptr
operator|->
name|dep
init|;
name|dep_list
operator|&&
name|dep_list
operator|->
name|next
condition|;
name|dep_list
operator|=
name|dep_list
operator|->
name|next
control|)
empty_stmt|;
if|if
condition|(
operator|!
name|dep_list
condition|)
block|{
comment|/* Dummy for rtl interface */
name|dependence
modifier|*
name|dep_root_ptr
decl_stmt|;
name|VARRAY_PUSH_GENERIC_PTR
argument_list|(
name|dep_chain
argument_list|,
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dependence
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|dep_root_ptr
operator|=
name|VARRAY_TOP
argument_list|(
name|dep_chain
argument_list|,
name|generic
argument_list|)
expr_stmt|;
name|dep_root_ptr
operator|->
name|source
operator|=
literal|0
expr_stmt|;
name|dep_root_ptr
operator|->
name|destination
operator|=
name|def_ptr
operator|->
name|expression
expr_stmt|;
name|dep_root_ptr
operator|->
name|dependence
operator|=
name|dt_none
expr_stmt|;
name|dep_root_ptr
operator|->
name|next
operator|=
name|dep_ptr
expr_stmt|;
name|def_ptr
operator|->
name|dep
operator|=
name|dep_ptr
expr_stmt|;
block|}
else|else
name|dep_list
operator|->
name|next
operator|=
name|dep_ptr
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Get the COEFFICIENTS and offset for def/use DU.  */
end_comment

begin_function
specifier|static
name|int
name|get_coefficients
parameter_list|(
name|du
parameter_list|,
name|coefficients
parameter_list|)
name|def_use
modifier|*
name|du
decl_stmt|;
name|subscript
name|coefficients
index|[
name|MAX_SUBSCRIPTS
index|]
decl_stmt|;
block|{
name|int
name|idx
init|=
literal|0
decl_stmt|;
name|int
name|array_count
decl_stmt|;
name|int
name|i
decl_stmt|;
name|tree
name|array_ref
decl_stmt|;
name|array_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|array_ref
operator|=
name|du
operator|->
name|expression
init|;
name|TREE_CODE
argument_list|(
name|array_ref
argument_list|)
operator|==
name|ARRAY_REF
condition|;
name|array_ref
operator|=
name|TREE_OPERAND
argument_list|(
name|array_ref
argument_list|,
literal|0
argument_list|)
control|)
name|array_count
operator|+=
literal|1
expr_stmt|;
name|idx
operator|=
name|array_count
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_SUBSCRIPTS
condition|;
name|i
operator|++
control|)
block|{
name|coefficients
index|[
name|i
index|]
operator|.
name|position
operator|=
literal|0
expr_stmt|;
name|coefficients
index|[
name|i
index|]
operator|.
name|coefficient
operator|=
name|INT_MIN
expr_stmt|;
name|coefficients
index|[
name|i
index|]
operator|.
name|offset
operator|=
name|INT_MIN
expr_stmt|;
name|coefficients
index|[
name|i
index|]
operator|.
name|variable
operator|=
literal|0
expr_stmt|;
name|coefficients
index|[
name|i
index|]
operator|.
name|next
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|array_ref
operator|=
name|du
operator|->
name|expression
init|;
name|TREE_CODE
argument_list|(
name|array_ref
argument_list|)
operator|==
name|ARRAY_REF
condition|;
name|array_ref
operator|=
name|TREE_OPERAND
argument_list|(
name|array_ref
argument_list|,
literal|0
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|array_ref
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|coefficients
index|[
name|idx
index|]
operator|.
name|offset
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|array_ref
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|get_one_coefficient
argument_list|(
name|TREE_OPERAND
argument_list|(
name|array_ref
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|&
name|coefficients
index|[
name|idx
index|]
argument_list|,
name|du
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|idx
operator|=
name|idx
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|array_count
return|;
block|}
end_function

begin_comment
comment|/* Get the COEFFICIENTS and offset for NODE having TYPE and defined in DU.  */
end_comment

begin_function
specifier|static
name|int
name|get_one_coefficient
parameter_list|(
name|node
parameter_list|,
name|coefficients
parameter_list|,
name|du
parameter_list|,
name|type
parameter_list|)
name|tree
name|node
decl_stmt|;
name|subscript
modifier|*
name|coefficients
decl_stmt|;
name|def_use
modifier|*
name|du
decl_stmt|;
name|enum
name|tree_code
modifier|*
name|type
decl_stmt|;
block|{
name|enum
name|tree_code
name|tree_op
decl_stmt|,
name|tree_op_code
decl_stmt|;
name|int
name|index
decl_stmt|,
name|value
decl_stmt|;
name|tree_op
operator|=
name|TREE_CODE
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
condition|)
operator|*
name|type
operator|=
name|tree_op
expr_stmt|;
if|if
condition|(
name|tree_op
operator|==
name|VAR_DECL
condition|)
block|{
name|index
operator|=
name|have_induction_variable
argument_list|(
name|du
operator|->
name|outer_loop
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|>=
literal|0
condition|)
block|{
name|coefficients
operator|->
name|position
operator|=
name|index
expr_stmt|;
name|coefficients
operator|->
name|variable
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|coefficients
operator|->
name|coefficient
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|coefficients
operator|->
name|offset
operator|==
name|INT_MIN
condition|)
name|coefficients
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|index
return|;
block|}
elseif|else
if|if
condition|(
name|tree_op
operator|==
name|INTEGER_CST
condition|)
block|{
return|return
name|TREE_INT_CST_LOW
argument_list|(
name|node
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|tree_op
operator|==
name|NON_LVALUE_EXPR
condition|)
block|{
return|return
name|get_one_coefficient
argument_list|(
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
argument_list|,
name|coefficients
argument_list|,
name|du
argument_list|,
operator|&
name|tree_op_code
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|tree_op
operator|==
name|PLUS_EXPR
condition|)
block|{
name|value
operator|=
name|get_one_coefficient
argument_list|(
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
argument_list|,
name|coefficients
argument_list|,
name|du
argument_list|,
operator|&
name|tree_op_code
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree_op_code
operator|==
name|INTEGER_CST
condition|)
name|coefficients
operator|->
name|offset
operator|=
name|value
expr_stmt|;
name|value
operator|=
name|get_one_coefficient
argument_list|(
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|1
argument_list|)
argument_list|,
name|coefficients
argument_list|,
name|du
argument_list|,
operator|&
name|tree_op_code
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree_op_code
operator|==
name|INTEGER_CST
condition|)
name|coefficients
operator|->
name|offset
operator|=
name|value
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|tree_op
operator|==
name|MINUS_EXPR
condition|)
block|{
name|value
operator|=
name|get_one_coefficient
argument_list|(
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
argument_list|,
name|coefficients
argument_list|,
name|du
argument_list|,
operator|&
name|tree_op_code
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree_op_code
operator|==
name|INTEGER_CST
condition|)
name|coefficients
operator|->
name|offset
operator|=
name|value
expr_stmt|;
name|value
operator|=
name|get_one_coefficient
argument_list|(
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|1
argument_list|)
argument_list|,
name|coefficients
argument_list|,
name|du
argument_list|,
operator|&
name|tree_op_code
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree_op_code
operator|==
name|INTEGER_CST
condition|)
name|coefficients
operator|->
name|offset
operator|=
operator|-
name|value
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|tree_op
operator|==
name|MULT_EXPR
condition|)
block|{
name|int
name|value0
decl_stmt|,
name|value1
decl_stmt|,
name|value0_is_idx
init|=
literal|0
decl_stmt|,
name|value1_is_idx
init|=
literal|0
decl_stmt|;
name|value0
operator|=
name|get_one_coefficient
argument_list|(
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
argument_list|,
name|coefficients
argument_list|,
name|du
argument_list|,
operator|&
name|tree_op_code
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree_op_code
operator|==
name|VAR_DECL
condition|)
name|value0_is_idx
operator|=
literal|1
expr_stmt|;
name|value1
operator|=
name|get_one_coefficient
argument_list|(
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|1
argument_list|)
argument_list|,
name|coefficients
argument_list|,
name|du
argument_list|,
operator|&
name|tree_op_code
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree_op_code
operator|==
name|VAR_DECL
condition|)
name|value1_is_idx
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|value0_is_idx
condition|)
name|coefficients
operator|->
name|coefficient
operator|=
name|value1
expr_stmt|;
elseif|else
if|if
condition|(
name|value1_is_idx
condition|)
name|coefficients
operator|->
name|coefficient
operator|=
name|value0
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Adjust the COEFFICIENTS as if loop LOOP_PTR were normalized to start at 0.  */
end_comment

begin_function
specifier|static
name|void
name|normalize_coefficients
parameter_list|(
name|coefficients
parameter_list|,
name|loop_ptr
parameter_list|,
name|count
parameter_list|)
name|subscript
name|coefficients
index|[
name|MAX_SUBSCRIPTS
index|]
decl_stmt|;
name|loop
modifier|*
name|loop_ptr
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
name|induction
modifier|*
name|ind_ptr
decl_stmt|;
name|loop
modifier|*
name|ck_loop_ptr
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|count
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|ck_loop_ptr
operator|=
name|loop_ptr
init|;
name|ck_loop_ptr
condition|;
name|ck_loop_ptr
operator|=
name|ck_loop_ptr
operator|->
name|next_nest
control|)
for|for
control|(
name|ind_ptr
operator|=
name|ck_loop_ptr
operator|->
name|ind
init|;
name|ind_ptr
condition|;
name|ind_ptr
operator|=
name|ind_ptr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|coefficients
index|[
name|i
index|]
operator|.
name|variable
operator|==
name|ind_ptr
operator|->
name|variable
condition|)
block|{
if|if
condition|(
name|ind_ptr
operator|->
name|low_bound
operator|<
name|ind_ptr
operator|->
name|high_bound
condition|)
name|coefficients
index|[
name|i
index|]
operator|.
name|offset
operator|+=
name|coefficients
index|[
name|i
index|]
operator|.
name|coefficient
operator|*
name|ind_ptr
operator|->
name|low_bound
expr_stmt|;
elseif|else
if|if
condition|(
name|ind_ptr
operator|->
name|high_bound
operator|!=
name|INT_MIN
condition|)
block|{
name|coefficients
index|[
name|i
index|]
operator|.
name|offset
operator|=
name|coefficients
index|[
name|i
index|]
operator|.
name|coefficient
operator|*
name|ind_ptr
operator|->
name|high_bound
expr_stmt|;
name|coefficients
index|[
name|i
index|]
operator|.
name|coefficient
operator|=
name|coefficients
index|[
name|i
index|]
operator|.
name|coefficient
operator|*
operator|-
literal|1
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Determine the COMPLEXITY and SEPARABILITY for COUNT subscripts of    inputs ICOEFFICIENTS and outputs OCOEFFICIENTS */
end_comment

begin_function
specifier|static
name|void
name|classify_dependence
parameter_list|(
name|icoefficients
parameter_list|,
name|ocoefficients
parameter_list|,
name|complexity
parameter_list|,
name|separability
parameter_list|,
name|count
parameter_list|)
name|subscript
name|icoefficients
index|[
name|MAX_SUBSCRIPTS
index|]
decl_stmt|;
name|subscript
name|ocoefficients
index|[
name|MAX_SUBSCRIPTS
index|]
decl_stmt|;
name|enum
name|complexity_type
name|complexity
index|[
name|MAX_SUBSCRIPTS
index|]
decl_stmt|;
name|int
modifier|*
name|separability
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|iiv_used
index|[
name|MAX_SUBSCRIPTS
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|oiv_used
index|[
name|MAX_SUBSCRIPTS
index|]
decl_stmt|;
name|int
name|ocoeff
index|[
name|MAX_SUBSCRIPTS
index|]
decl_stmt|;
name|int
name|icoeff
index|[
name|MAX_SUBSCRIPTS
index|]
decl_stmt|;
name|int
name|idx
decl_stmt|,
name|cidx
decl_stmt|;
name|memset
argument_list|(
name|iiv_used
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
operator|*
name|MAX_SUBSCRIPTS
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|oiv_used
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
operator|*
name|MAX_SUBSCRIPTS
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|icoeff
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|MAX_SUBSCRIPTS
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ocoeff
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|MAX_SUBSCRIPTS
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|1
init|;
name|idx
operator|<=
name|count
condition|;
name|idx
operator|++
control|)
block|{
if|if
condition|(
name|icoefficients
index|[
name|idx
index|]
operator|.
name|variable
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|iiv_used
index|[
name|idx
index|]
condition|)
block|{
name|iiv_used
index|[
name|idx
index|]
operator|=
name|icoefficients
index|[
name|idx
index|]
operator|.
name|variable
expr_stmt|;
name|icoeff
index|[
name|idx
index|]
operator|=
name|icoefficients
index|[
name|idx
index|]
operator|.
name|coefficient
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ocoefficients
index|[
name|idx
index|]
operator|.
name|variable
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|oiv_used
index|[
name|idx
index|]
condition|)
block|{
name|oiv_used
index|[
name|idx
index|]
operator|=
name|ocoefficients
index|[
name|idx
index|]
operator|.
name|variable
expr_stmt|;
name|ocoeff
index|[
name|idx
index|]
operator|=
name|ocoefficients
index|[
name|idx
index|]
operator|.
name|coefficient
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|idx
operator|=
literal|1
init|;
name|idx
operator|<=
name|count
condition|;
name|idx
operator|++
control|)
block|{
if|if
condition|(
name|iiv_used
index|[
name|idx
index|]
operator|==
literal|0
operator|&&
name|oiv_used
index|[
name|idx
index|]
operator|==
literal|0
condition|)
name|complexity
index|[
name|idx
index|]
operator|=
name|ziv
expr_stmt|;
elseif|else
if|if
condition|(
name|iiv_used
index|[
name|idx
index|]
operator|==
name|oiv_used
index|[
name|idx
index|]
condition|)
block|{
if|if
condition|(
name|icoeff
index|[
name|idx
index|]
operator|==
name|ocoeff
index|[
name|idx
index|]
condition|)
name|complexity
index|[
name|idx
index|]
operator|=
name|strong_siv
expr_stmt|;
elseif|else
if|if
condition|(
name|icoeff
index|[
name|idx
index|]
operator|==
operator|-
literal|1
operator|*
name|ocoeff
index|[
name|idx
index|]
condition|)
name|complexity
index|[
name|idx
index|]
operator|=
name|weak_crossing_siv
expr_stmt|;
else|else
name|complexity
index|[
name|idx
index|]
operator|=
name|weak_siv
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|icoeff
index|[
name|idx
index|]
operator|==
literal|0
operator|||
name|ocoeff
index|[
name|idx
index|]
operator|==
literal|0
condition|)
name|complexity
index|[
name|idx
index|]
operator|=
name|weak_zero_siv
expr_stmt|;
else|else
name|complexity
index|[
name|idx
index|]
operator|=
name|miv
expr_stmt|;
block|}
operator|*
name|separability
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|1
init|;
name|idx
operator|<=
name|count
condition|;
name|idx
operator|++
control|)
block|{
for|for
control|(
name|cidx
operator|=
literal|1
init|;
name|cidx
operator|<=
name|count
condition|;
name|cidx
operator|++
control|)
block|{
if|if
condition|(
name|idx
operator|!=
name|cidx
operator|&&
name|iiv_used
index|[
name|idx
index|]
operator|&&
name|oiv_used
index|[
name|cidx
index|]
operator|&&
name|iiv_used
index|[
name|idx
index|]
operator|==
name|oiv_used
index|[
name|cidx
index|]
condition|)
operator|*
name|separability
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Determine the DIRECTION and DISTANCE dependency for subscript SUB of    inputs ICOEFFICIENTS and outputs OCOEFFICIENTS of loop LOOP_PTR using    the zero induction variable test */
end_comment

begin_function
specifier|static
name|void
name|ziv_test
parameter_list|(
name|icoefficients
parameter_list|,
name|ocoefficients
parameter_list|,
name|direction
parameter_list|,
name|distance
parameter_list|,
name|loop_ptr
parameter_list|,
name|sub
parameter_list|)
name|subscript
name|icoefficients
index|[
name|MAX_SUBSCRIPTS
index|]
decl_stmt|;
name|subscript
name|ocoefficients
index|[
name|MAX_SUBSCRIPTS
index|]
decl_stmt|;
name|enum
name|direction_type
name|direction
index|[
name|MAX_SUBSCRIPTS
index|]
index|[
name|MAX_SUBSCRIPTS
index|]
decl_stmt|;
name|int
name|distance
index|[
name|MAX_SUBSCRIPTS
index|]
index|[
name|MAX_SUBSCRIPTS
index|]
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|loop
modifier|*
name|loop_ptr
decl_stmt|;
name|int
name|sub
decl_stmt|;
block|{
if|if
condition|(
name|ocoefficients
index|[
name|sub
index|]
operator|.
name|offset
operator|!=
name|icoefficients
index|[
name|sub
index|]
operator|.
name|offset
condition|)
name|direction
index|[
name|loop_ptr
operator|->
name|depth
index|]
index|[
name|sub
index|]
operator|=
name|independent
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Determine the DIRECTION and DISTANCE dependency for subscript SUB of    inputs ICOEFFICIENTS and outputs OCOEFFICIENTS of loop LOOP_PTR using    the single induction variable test */
end_comment

begin_function
specifier|static
name|void
name|siv_test
parameter_list|(
name|icoefficients
parameter_list|,
name|ocoefficients
parameter_list|,
name|direction
parameter_list|,
name|distance
parameter_list|,
name|loop_ptr
parameter_list|,
name|sub
parameter_list|)
name|subscript
name|icoefficients
index|[
name|MAX_SUBSCRIPTS
index|]
decl_stmt|;
name|subscript
name|ocoefficients
index|[
name|MAX_SUBSCRIPTS
index|]
decl_stmt|;
name|enum
name|direction_type
name|direction
index|[
name|MAX_SUBSCRIPTS
index|]
index|[
name|MAX_SUBSCRIPTS
index|]
decl_stmt|;
name|int
name|distance
index|[
name|MAX_SUBSCRIPTS
index|]
index|[
name|MAX_SUBSCRIPTS
index|]
decl_stmt|;
name|loop
modifier|*
name|loop_ptr
decl_stmt|;
name|int
name|sub
decl_stmt|;
block|{
name|int
name|coef_diff
decl_stmt|;
name|int
name|coef
decl_stmt|;
name|int
name|gcd
decl_stmt|;
if|if
condition|(
operator|!
name|check_subscript_induction
argument_list|(
operator|&
name|icoefficients
index|[
name|sub
index|]
argument_list|,
operator|&
name|ocoefficients
index|[
name|sub
index|]
argument_list|,
name|loop_ptr
argument_list|)
condition|)
return|return;
name|coef_diff
operator|=
name|icoefficients
index|[
name|sub
index|]
operator|.
name|offset
operator|-
name|ocoefficients
index|[
name|sub
index|]
operator|.
name|offset
expr_stmt|;
comment|/* strong_siv requires equal coefficients.  weak_crossing_siv requires      coefficients to have equal absolute value.  weak_zero_siv uses the      nonzero coefficient.  */
if|if
condition|(
name|ocoefficients
index|[
name|sub
index|]
operator|.
name|coefficient
operator|==
name|INT_MIN
condition|)
name|coef
operator|=
name|icoefficients
index|[
name|sub
index|]
operator|.
name|coefficient
expr_stmt|;
elseif|else
if|if
condition|(
name|icoefficients
index|[
name|sub
index|]
operator|.
name|coefficient
operator|==
name|INT_MIN
condition|)
name|coef
operator|=
name|ocoefficients
index|[
name|sub
index|]
operator|.
name|coefficient
expr_stmt|;
elseif|else
if|if
condition|(
name|ocoefficients
index|[
name|sub
index|]
operator|.
name|coefficient
operator|==
operator|-
literal|1
operator|*
name|icoefficients
index|[
name|sub
index|]
operator|.
name|coefficient
condition|)
name|coef
operator|=
literal|2
operator|*
name|abs
argument_list|(
name|ocoefficients
index|[
name|sub
index|]
operator|.
name|coefficient
argument_list|)
expr_stmt|;
else|else
name|coef
operator|=
name|icoefficients
index|[
name|sub
index|]
operator|.
name|coefficient
expr_stmt|;
name|gcd
operator|=
operator|-
name|coef_diff
operator|/
name|coef
expr_stmt|;
if|if
condition|(
name|gcd
operator|*
name|coef
operator|!=
operator|-
name|coef_diff
condition|)
block|{
name|direction
index|[
name|loop_ptr
operator|->
name|depth
index|]
index|[
name|sub
index|]
operator|=
name|independent
expr_stmt|;
block|}
else|else
block|{
name|distance
index|[
name|loop_ptr
operator|->
name|depth
index|]
index|[
name|sub
index|]
operator|=
name|gcd
expr_stmt|;
if|if
condition|(
name|gcd
operator|<
literal|0
condition|)
name|direction
index|[
name|loop_ptr
operator|->
name|depth
index|]
index|[
name|sub
index|]
operator|=
name|gt
expr_stmt|;
elseif|else
if|if
condition|(
name|gcd
operator|>
literal|0
condition|)
name|direction
index|[
name|loop_ptr
operator|->
name|depth
index|]
index|[
name|sub
index|]
operator|=
name|lt
expr_stmt|;
else|else
name|direction
index|[
name|loop_ptr
operator|->
name|depth
index|]
index|[
name|sub
index|]
operator|=
name|eq
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return 1 if an induction variable of LOOP_PTR is used by either    input ICOEFFICIENT or output OCOEFFICIENT */
end_comment

begin_function
specifier|static
name|int
name|check_subscript_induction
parameter_list|(
name|icoefficient
parameter_list|,
name|ocoefficient
parameter_list|,
name|loop_ptr
parameter_list|)
name|subscript
modifier|*
name|icoefficient
decl_stmt|;
name|subscript
modifier|*
name|ocoefficient
decl_stmt|;
name|loop
modifier|*
name|loop_ptr
decl_stmt|;
block|{
name|induction
modifier|*
name|ind_ptr
decl_stmt|;
name|int
name|sub_ind_input
init|=
literal|0
decl_stmt|;
name|int
name|sub_ind_output
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ind_ptr
operator|=
name|loop_ptr
operator|->
name|ind
init|;
name|ind_ptr
condition|;
name|ind_ptr
operator|=
name|ind_ptr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|icoefficient
operator|->
name|variable
operator|==
name|ind_ptr
operator|->
name|variable
condition|)
name|sub_ind_input
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ocoefficient
operator|->
name|variable
operator|==
name|ind_ptr
operator|->
name|variable
condition|)
name|sub_ind_output
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|sub_ind_input
operator|||
name|sub_ind_output
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|abs
parameter_list|(
name|N
parameter_list|)
value|((N)< 0 ? -(N) : (N))
end_define

begin_comment
comment|/* Determine the DIRECTION and DISTANCE dependency for subscript SUB of    inputs ICOEFFICIENTS and outputs OCOEFFICIENTS of loop LOOP_PTR using    the greatest common denominator test */
end_comment

begin_function
specifier|static
name|void
name|gcd_test
parameter_list|(
name|icoefficients
parameter_list|,
name|ocoefficients
parameter_list|,
name|direction
parameter_list|,
name|distance
parameter_list|,
name|loop_ptr
parameter_list|,
name|sub
parameter_list|)
name|subscript
name|icoefficients
index|[
name|MAX_SUBSCRIPTS
index|]
decl_stmt|;
name|subscript
name|ocoefficients
index|[
name|MAX_SUBSCRIPTS
index|]
decl_stmt|;
name|enum
name|direction_type
name|direction
index|[
name|MAX_SUBSCRIPTS
index|]
index|[
name|MAX_SUBSCRIPTS
index|]
decl_stmt|;
name|int
name|distance
index|[
name|MAX_SUBSCRIPTS
index|]
index|[
name|MAX_SUBSCRIPTS
index|]
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|loop
modifier|*
name|loop_ptr
decl_stmt|;
name|int
name|sub
decl_stmt|;
block|{
name|int
name|coef_diff
decl_stmt|;
name|int
name|g
decl_stmt|,
name|gg
decl_stmt|;
if|if
condition|(
operator|!
name|check_subscript_induction
argument_list|(
operator|&
name|icoefficients
index|[
name|sub
index|]
argument_list|,
operator|&
name|ocoefficients
index|[
name|sub
index|]
argument_list|,
name|loop_ptr
argument_list|)
condition|)
return|return;
name|g
operator|=
name|find_gcd
argument_list|(
name|icoefficients
index|[
name|sub
index|]
operator|.
name|coefficient
argument_list|,
name|ocoefficients
index|[
name|sub
index|]
operator|.
name|coefficient
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|>
literal|1
condition|)
block|{
name|coef_diff
operator|=
name|icoefficients
index|[
name|sub
index|]
operator|.
name|offset
operator|-
name|ocoefficients
index|[
name|sub
index|]
operator|.
name|offset
expr_stmt|;
name|gg
operator|=
name|coef_diff
operator|/
name|g
expr_stmt|;
if|if
condition|(
name|gg
operator|*
name|g
operator|!=
name|coef_diff
condition|)
block|{
name|direction
index|[
name|loop_ptr
operator|->
name|depth
index|]
index|[
name|sub
index|]
operator|=
name|independent
expr_stmt|;
block|}
block|}
comment|/* ?? gcd does not yield direction and distance.  Wolfe's direction      vector hierarchy can be used to give this.  */
block|}
end_function

begin_comment
comment|/* Find the gcd of X and Y using Euclid's algorithm */
end_comment

begin_function
specifier|static
name|int
name|find_gcd
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
name|int
name|g
decl_stmt|,
name|g0
decl_stmt|,
name|g1
decl_stmt|,
name|r
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
block|{
name|g
operator|=
name|abs
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|y
operator|==
literal|0
condition|)
block|{
name|g
operator|=
name|abs
argument_list|(
name|y
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|g0
operator|=
name|abs
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|g1
operator|=
name|abs
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|r
operator|=
name|g0
operator|%
name|g1
expr_stmt|;
while|while
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|g0
operator|=
name|g1
expr_stmt|;
name|g1
operator|=
name|r
expr_stmt|;
name|r
operator|=
name|g0
operator|%
name|g1
expr_stmt|;
block|}
name|g
operator|=
name|g1
expr_stmt|;
block|}
return|return
name|g
return|;
block|}
end_function

begin_comment
comment|/* Merge SUBSCRIPT_COUNT DIRECTIONs and DISTANCEs for LOOP_COUNT loops.    We use a predefined array to handle the direction merge.      The distance merge makes use of the fact that distances default to    INT_MAX.  Distances are '&' together.  Watch out for a negative distance. */
end_comment

begin_function
specifier|static
name|void
name|merge_dependencies
parameter_list|(
name|direction
parameter_list|,
name|distance
parameter_list|,
name|loop_count
parameter_list|,
name|subscript_count
parameter_list|)
name|enum
name|direction_type
name|direction
index|[
name|MAX_SUBSCRIPTS
index|]
index|[
name|MAX_SUBSCRIPTS
index|]
decl_stmt|;
name|int
name|distance
index|[
name|MAX_SUBSCRIPTS
index|]
index|[
name|MAX_SUBSCRIPTS
index|]
decl_stmt|;
name|int
name|loop_count
decl_stmt|;
name|int
name|subscript_count
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|sign
decl_stmt|;
specifier|static
specifier|const
name|enum
name|direction_type
name|direction_merge
index|[
literal|8
index|]
index|[
literal|8
index|]
init|=
block|{
block|{
name|lt
block|,
name|le
block|,
name|le
block|,
name|star
block|,
name|star
block|,
name|lt
block|,
name|independent
block|,
name|lt
block|}
block|,
block|{
name|le
block|,
name|le
block|,
name|le
block|,
name|star
block|,
name|star
block|,
name|le
block|,
name|independent
block|,
name|le
block|}
block|,
block|{
name|le
block|,
name|le
block|,
name|eq
block|,
name|ge
block|,
name|ge
block|,
name|eq
block|,
name|independent
block|,
name|eq
block|}
block|,
block|{
name|star
block|,
name|star
block|,
name|ge
block|,
name|gt
block|,
name|ge
block|,
name|gt
block|,
name|independent
block|,
name|ge
block|}
block|,
block|{
name|star
block|,
name|star
block|,
name|ge
block|,
name|ge
block|,
name|ge
block|,
name|ge
block|,
name|independent
block|,
name|ge
block|}
block|,
block|{
name|lt
block|,
name|le
block|,
name|eq
block|,
name|gt
block|,
name|ge
block|,
name|star
block|,
name|independent
block|,
name|star
block|}
block|,
block|{
name|independent
block|,
name|independent
block|,
name|independent
block|,
name|independent
block|,
name|independent
block|}
block|,
block|{
name|independent
block|,
name|independent
block|,
name|independent
block|}
block|}
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|loop_count
condition|;
name|i
operator|++
control|)
block|{
name|distance
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
name|INT_MAX
expr_stmt|;
name|direction
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
name|star
expr_stmt|;
name|sign
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|subscript_count
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|distance
index|[
name|i
index|]
index|[
name|j
index|]
operator|<
literal|0
condition|)
block|{
name|distance
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
name|distance
index|[
name|i
index|]
index|[
literal|0
index|]
operator|&
name|abs
argument_list|(
name|distance
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|sign
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|distance
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
name|distance
index|[
name|i
index|]
index|[
literal|0
index|]
operator|&
name|distance
index|[
name|i
index|]
index|[
name|j
index|]
expr_stmt|;
name|direction
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
name|direction_merge
index|[
operator|(
name|int
operator|)
name|direction
index|[
name|i
index|]
index|[
literal|0
index|]
index|]
index|[
operator|(
name|int
operator|)
name|direction
index|[
name|i
index|]
index|[
name|j
index|]
index|]
expr_stmt|;
block|}
name|distance
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
name|sign
operator|*
name|distance
index|[
name|i
index|]
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Dump ARRAY_REF NODE.  */
end_comment

begin_function
specifier|static
name|void
name|dump_array_ref
parameter_list|(
name|node
parameter_list|)
name|tree
name|node
decl_stmt|;
block|{
name|enum
name|tree_code
name|tree_op
init|=
name|TREE_CODE
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|tree_op
operator|==
name|VAR_DECL
condition|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tree_op
operator|==
name|INTEGER_CST
condition|)
block|{
name|printf
argument_list|(
literal|"%d"
argument_list|,
operator|(
name|int
operator|)
name|TREE_INT_CST_LOW
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tree_op
operator|==
name|PLUS_EXPR
condition|)
block|{
name|dump_array_ref
argument_list|(
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"+"
argument_list|)
expr_stmt|;
name|dump_array_ref
argument_list|(
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tree_op
operator|==
name|MINUS_EXPR
condition|)
block|{
name|dump_array_ref
argument_list|(
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"-"
argument_list|)
expr_stmt|;
name|dump_array_ref
argument_list|(
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tree_op
operator|==
name|MULT_EXPR
condition|)
block|{
name|dump_array_ref
argument_list|(
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"*"
argument_list|)
expr_stmt|;
name|dump_array_ref
argument_list|(
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Dump def/use DU.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static void dump_one_node (du, seen)      def_use *du;      varray_type *seen; {   def_use *du_ptr;   dependence *dep_ptr;   tree array_ref;    for (du_ptr = du; du_ptr; du_ptr = du_ptr->next)     {       printf ("%s ", du_ptr->variable);       for (array_ref = du_ptr->expression; 	   TREE_CODE (array_ref) == ARRAY_REF; 	   array_ref = TREE_OPERAND (array_ref, 0)) 	{	 	  printf ("["); 	  dump_array_ref (TREE_OPERAND (array_ref, 1)); 	  printf ("]"); 	}        printf (" Outer Loop %x Containing Loop %x Expression %x %s\n", 	      (int)du_ptr->outer_loop, 	      (int)du_ptr->containing_loop, 	      (int)du_ptr->expression, du_ptr->type == def ? "Def" : "Use");       VARRAY_PUSH_GENERIC_PTR (*seen, du_ptr);        for (dep_ptr = du_ptr->dep; dep_ptr; dep_ptr = dep_ptr->next) 	{ 	  int i; 	  printf ("%s Dependence with %x ", 		  dependence_string[(int)dep_ptr->dependence], 		  (int)dep_ptr->source); 	  printf ("Dir/Dist "); 	  for (i = 1 ; i< MAX_SUBSCRIPTS ; i++) 	    if (dep_ptr->direction[i] != undef) 	      printf ("[%d] %s/%d ", i, 		      direction_string[(int)dep_ptr->direction[i]], 		      dep_ptr->distance[i]); 	  printf ("\n"); 	}     } }
comment|/* Dump dependence info.  */
end_comment

begin_endif
unit|static void dump_node_dependence (void) {   varray_type seen;   unsigned int du_idx, seen_idx, i;   def_use *du_ptr;    VARRAY_GENERIC_PTR_INIT (seen, 20, "seen");   du_idx = 0;   seen_idx = 0;   for (du_ptr = VARRAY_GENERIC_PTR (def_use_chain, du_idx);        du_idx< VARRAY_SIZE (def_use_chain);        du_ptr = VARRAY_GENERIC_PTR (def_use_chain, du_idx++))     {       for (i = 0; i< VARRAY_SIZE (seen)&& VARRAY_GENERIC_PTR (seen, i) 	     != du_ptr ; i++);       if (i>= VARRAY_SIZE (seen)) 	dump_one_node (du_ptr,&seen);     }   VARRAY_FREE (seen); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Return the index into 'dep_chain' if there is a dependency for destination    dest_to_remember (set by remember_dest_for_dependence) and source node.    Called by the front end, which adds the index onto a MEM rtx.  */
end_comment

begin_function
name|int
name|search_dependence
parameter_list|(
name|node
parameter_list|)
name|tree
name|node
decl_stmt|;
block|{
name|dependence
modifier|*
name|dep_ptr
decl_stmt|;
name|int
name|dep_idx
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|dep_chain
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|INDIRECT_REF
operator|&&
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|1
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|ARRAY_REF
condition|)
name|node
operator|=
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|dep_ptr
operator|=
name|VARRAY_GENERIC_PTR
argument_list|(
name|dep_chain
argument_list|,
literal|0
argument_list|)
init|;
name|dep_ptr
condition|;
name|dep_ptr
operator|=
name|VARRAY_GENERIC_PTR
argument_list|(
name|dep_chain
argument_list|,
name|dep_idx
operator|++
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|node
operator|==
name|dep_ptr
operator|->
name|source
operator|&&
name|dest_to_remember
operator|==
name|dep_ptr
operator|->
name|destination
operator|)
operator|||
operator|(
operator|!
name|dep_ptr
operator|->
name|source
operator|&&
name|node
operator|==
name|dep_ptr
operator|->
name|destination
operator|)
condition|)
return|return
name|dep_idx
operator|+
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Remember a destination NODE for search_dependence.  */
end_comment

begin_function
name|void
name|remember_dest_for_dependence
parameter_list|(
name|node
parameter_list|)
name|tree
name|node
decl_stmt|;
block|{
if|if
condition|(
name|node
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|INDIRECT_REF
operator|&&
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|1
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|ARRAY_REF
condition|)
name|node
operator|=
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dest_to_remember
operator|=
name|node
expr_stmt|;
block|}
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|MEM_DEPENDENCY
end_ifndef

begin_define
define|#
directive|define
name|MEM_DEPENDENCY
parameter_list|(
name|RTX
parameter_list|)
value|XCWINT (RTX, 2, MEM)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Return 1 along with the dependence DIRECTION and DISTANCE if there is a     dependence from dest_rtx to src_rtx.  */
end_comment

begin_function
name|int
name|have_dependence_p
parameter_list|(
name|dest_rtx
parameter_list|,
name|src_rtx
parameter_list|,
name|direction
parameter_list|,
name|distance
parameter_list|)
name|rtx
name|dest_rtx
decl_stmt|;
name|rtx
name|src_rtx
decl_stmt|;
name|enum
name|direction_type
name|direction
index|[
name|MAX_SUBSCRIPTS
index|]
decl_stmt|;
name|int
name|distance
index|[
name|MAX_SUBSCRIPTS
index|]
decl_stmt|;
block|{
name|int
name|dest_idx
init|=
literal|0
decl_stmt|,
name|src_idx
init|=
literal|0
decl_stmt|;
name|rtx
name|dest
decl_stmt|,
name|src
decl_stmt|;
name|dependence
modifier|*
name|dep_ptr
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|dest_rtx
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|dest
operator|=
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|dest_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|dest_idx
operator|=
name|MEM_DEPENDENCY
argument_list|(
name|dest
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|src_rtx
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|src
operator|=
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|src_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|src_idx
operator|=
name|MEM_DEPENDENCY
argument_list|(
name|src
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|dest_idx
operator|>=
literal|0
operator|||
name|src_idx
operator|>=
literal|0
condition|)
return|return
literal|0
return|;
for|for
control|(
name|dep_ptr
operator|=
name|VARRAY_GENERIC_PTR
argument_list|(
name|dep_chain
argument_list|,
operator|-
name|dest_idx
argument_list|)
init|;
name|dep_ptr
condition|;
name|dep_ptr
operator|=
name|dep_ptr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|dep_ptr
operator|==
name|VARRAY_GENERIC_PTR
argument_list|(
name|dep_chain
argument_list|,
operator|-
name|src_idx
argument_list|)
condition|)
block|{
name|direction
operator|=
operator|(
expr|enum
name|direction_type
operator|*
operator|)
operator|&
name|dep_ptr
operator|->
name|direction
expr_stmt|;
name|distance
operator|=
operator|(
name|int
operator|*
operator|)
operator|&
name|dep_ptr
operator|->
name|distance
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Cleanup when dependency analysis is complete.  */
end_comment

begin_function
name|void
name|end_dependence_analysis
parameter_list|()
block|{
name|VARRAY_FREE
argument_list|(
name|dep_chain
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

