begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Dead store elimination    Copyright (C) 2004, 2005 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"tree-dump.h"
end_include

begin_include
include|#
directive|include
file|"domwalk.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_comment
comment|/* This file implements dead store elimination.     A dead store is a store into a memory location which will later be    overwritten by another store without any intervening loads.  In this    case the earlier store can be deleted.     In our SSA + virtual operand world we use immediate uses of virtual    operands to detect dead stores.  If a store's virtual definition    is used precisely once by a later store to the same location which    post dominates the first store, then the first store is dead.      The single use of the store's virtual definition ensures that    there are no intervening aliased loads and the requirement that    the second load post dominate the first ensures that if the earlier    store executes, then the later stores will execute before the function    exits.     It may help to think of this as first moving the earlier store to    the point immediately before the later store.  Again, the single    use of the virtual definition and the post-dominance relationship    ensure that such movement would be safe.  Clearly if there are     back to back stores, then the second is redundant.     Reviewing section 10.7.2 in Morgan's "Building an Optimizing Compiler"    may also help in understanding this code since it discusses the    relationship between dead store and redundant load elimination.  In    fact, they are the same transformation applied to different views of    the CFG.  */
end_comment

begin_struct
struct|struct
name|dse_global_data
block|{
comment|/* This is the global bitmap for store statements.       Each statement has a unique ID.  When we encounter a store statement      that we want to record, set the bit corresponding to the statement's      unique ID in this bitmap.  */
name|bitmap
name|stores
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* We allocate a bitmap-per-block for stores which are encountered    during the scan of that block.  This allows us to restore the     global bitmap of stores when we finish processing a block.  */
end_comment

begin_struct
struct|struct
name|dse_block_local_data
block|{
name|bitmap
name|stores
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Basic blocks of the potentially dead store and the following    store, for memory_address_same.  */
end_comment

begin_struct
struct|struct
name|address_walk_data
block|{
name|basic_block
name|store1_bb
decl_stmt|,
name|store2_bb
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|bool
name|gate_dse
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|int
name|tree_ssa_dse
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dse_initialize_block_local_data
parameter_list|(
name|struct
name|dom_walk_data
modifier|*
parameter_list|,
name|basic_block
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dse_optimize_stmt
parameter_list|(
name|struct
name|dom_walk_data
modifier|*
parameter_list|,
name|basic_block
parameter_list|,
name|block_stmt_iterator
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dse_record_phis
parameter_list|(
name|struct
name|dom_walk_data
modifier|*
parameter_list|,
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dse_finalize_block
parameter_list|(
name|struct
name|dom_walk_data
modifier|*
parameter_list|,
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|record_voperand_set
parameter_list|(
name|bitmap
parameter_list|,
name|bitmap
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|unsigned
name|max_stmt_uid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maximal uid of a statement.  Uids to phi 				   nodes are assigned using the versions of 				   ssa names they define.  */
end_comment

begin_comment
comment|/* Returns uid of statement STMT.  */
end_comment

begin_function
specifier|static
name|unsigned
name|get_stmt_uid
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|PHI_NODE
condition|)
return|return
name|SSA_NAME_VERSION
argument_list|(
name|PHI_RESULT
argument_list|(
name|stmt
argument_list|)
argument_list|)
operator|+
name|max_stmt_uid
return|;
return|return
name|stmt_ann
argument_list|(
name|stmt
argument_list|)
operator|->
name|uid
return|;
block|}
end_function

begin_comment
comment|/* Set bit UID in bitmaps GLOBAL and *LOCAL, creating *LOCAL as needed.  */
end_comment

begin_function
specifier|static
name|void
name|record_voperand_set
parameter_list|(
name|bitmap
name|global
parameter_list|,
name|bitmap
modifier|*
name|local
parameter_list|,
name|unsigned
name|int
name|uid
parameter_list|)
block|{
comment|/* Lazily allocate the bitmap.  Note that we do not get a notification      when the block local data structures die, so we allocate the local      bitmap backed by the GC system.  */
if|if
condition|(
operator|*
name|local
operator|==
name|NULL
condition|)
operator|*
name|local
operator|=
name|BITMAP_GGC_ALLOC
argument_list|()
expr_stmt|;
comment|/* Set the bit in the local and global bitmaps.  */
name|bitmap_set_bit
argument_list|(
operator|*
name|local
argument_list|,
name|uid
argument_list|)
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|global
argument_list|,
name|uid
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize block local data structures.  */
end_comment

begin_function
specifier|static
name|void
name|dse_initialize_block_local_data
parameter_list|(
name|struct
name|dom_walk_data
modifier|*
name|walk_data
parameter_list|,
name|basic_block
name|bb
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bool
name|recycled
parameter_list|)
block|{
name|struct
name|dse_block_local_data
modifier|*
name|bd
init|=
name|VEC_last
argument_list|(
name|void_p
argument_list|,
name|walk_data
operator|->
name|block_data_stack
argument_list|)
decl_stmt|;
comment|/* If we are given a recycled block local data structure, ensure any      bitmap associated with the block is cleared.  */
if|if
condition|(
name|recycled
condition|)
block|{
if|if
condition|(
name|bd
operator|->
name|stores
condition|)
name|bitmap_clear
argument_list|(
name|bd
operator|->
name|stores
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Helper function for memory_address_same via walk_tree.  Returns    non-NULL if it finds an SSA_NAME which is part of the address,    such that the definition of the SSA_NAME post-dominates the store    we want to delete but not the store that we believe makes it    redundant.  This indicates that the address may change between    the two stores.  */
end_comment

begin_function
specifier|static
name|tree
name|memory_ssa_name_same
parameter_list|(
name|tree
modifier|*
name|expr_p
parameter_list|,
name|int
modifier|*
name|walk_subtrees
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|address_walk_data
modifier|*
name|walk_data
init|=
name|data
decl_stmt|;
name|tree
name|expr
init|=
operator|*
name|expr_p
decl_stmt|;
name|tree
name|def_stmt
decl_stmt|;
name|basic_block
name|def_bb
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|!=
name|SSA_NAME
condition|)
return|return
name|NULL_TREE
return|;
comment|/* If we've found a default definition, then there's no problem.  Both      stores will post-dominate it.  And def_bb will be NULL.  */
if|if
condition|(
name|expr
operator|==
name|default_def
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
name|def_stmt
operator|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|def_bb
operator|=
name|bb_for_stmt
argument_list|(
name|def_stmt
argument_list|)
expr_stmt|;
comment|/* DEF_STMT must dominate both stores.  So if it is in the same      basic block as one, it does not post-dominate that store.  */
if|if
condition|(
name|walk_data
operator|->
name|store1_bb
operator|!=
name|def_bb
operator|&&
name|dominated_by_p
argument_list|(
name|CDI_POST_DOMINATORS
argument_list|,
name|walk_data
operator|->
name|store1_bb
argument_list|,
name|def_bb
argument_list|)
condition|)
block|{
if|if
condition|(
name|walk_data
operator|->
name|store2_bb
operator|==
name|def_bb
operator|||
operator|!
name|dominated_by_p
argument_list|(
name|CDI_POST_DOMINATORS
argument_list|,
name|walk_data
operator|->
name|store2_bb
argument_list|,
name|def_bb
argument_list|)
condition|)
comment|/* Return non-NULL to stop the walk.  */
return|return
name|def_stmt
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if the destination memory address in STORE1 and STORE2    might be modified after STORE1, before control reaches STORE2.  */
end_comment

begin_function
specifier|static
name|bool
name|memory_address_same
parameter_list|(
name|tree
name|store1
parameter_list|,
name|tree
name|store2
parameter_list|)
block|{
name|struct
name|address_walk_data
name|walk_data
decl_stmt|;
name|walk_data
operator|.
name|store1_bb
operator|=
name|bb_for_stmt
argument_list|(
name|store1
argument_list|)
expr_stmt|;
name|walk_data
operator|.
name|store2_bb
operator|=
name|bb_for_stmt
argument_list|(
name|store2
argument_list|)
expr_stmt|;
return|return
operator|(
name|walk_tree
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
name|store1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|memory_ssa_name_same
argument_list|,
operator|&
name|walk_data
argument_list|,
name|NULL
argument_list|)
operator|==
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Attempt to eliminate dead stores in the statement referenced by BSI.     A dead store is a store into a memory location which will later be    overwritten by another store without any intervening loads.  In this    case the earlier store can be deleted.     In our SSA + virtual operand world we use immediate uses of virtual    operands to detect dead stores.  If a store's virtual definition    is used precisely once by a later store to the same location which    post dominates the first store, then the first store is dead.  */
end_comment

begin_function
specifier|static
name|void
name|dse_optimize_stmt
parameter_list|(
name|struct
name|dom_walk_data
modifier|*
name|walk_data
parameter_list|,
name|basic_block
name|bb
name|ATTRIBUTE_UNUSED
parameter_list|,
name|block_stmt_iterator
name|bsi
parameter_list|)
block|{
name|struct
name|dse_block_local_data
modifier|*
name|bd
init|=
name|VEC_last
argument_list|(
name|void_p
argument_list|,
name|walk_data
operator|->
name|block_data_stack
argument_list|)
decl_stmt|;
name|struct
name|dse_global_data
modifier|*
name|dse_gd
init|=
name|walk_data
operator|->
name|global_data
decl_stmt|;
name|tree
name|stmt
init|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
decl_stmt|;
name|stmt_ann_t
name|ann
init|=
name|stmt_ann
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
comment|/* If this statement has no virtual defs, then there is nothing      to do.  */
if|if
condition|(
name|ZERO_SSA_OPERANDS
argument_list|(
name|stmt
argument_list|,
operator|(
name|SSA_OP_VMAYDEF
operator||
name|SSA_OP_VMUSTDEF
operator|)
argument_list|)
condition|)
return|return;
comment|/* We know we have virtual definitions.  If this is a MODIFY_EXPR that's      not also a function call, then record it into our table.  */
if|if
condition|(
name|get_call_expr_in
argument_list|(
name|stmt
argument_list|)
condition|)
return|return;
if|if
condition|(
name|ann
operator|->
name|has_volatile_ops
condition|)
return|return;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|MODIFY_EXPR
condition|)
block|{
name|use_operand_p
name|first_use_p
init|=
name|NULL_USE_OPERAND_P
decl_stmt|;
name|use_operand_p
name|use_p
init|=
name|NULL
decl_stmt|;
name|tree
name|use_stmt
decl_stmt|,
name|temp
decl_stmt|;
name|tree
name|defvar
init|=
name|NULL_TREE
decl_stmt|,
name|usevar
init|=
name|NULL_TREE
decl_stmt|;
name|bool
name|fail
init|=
name|false
decl_stmt|;
name|use_operand_p
name|var2
decl_stmt|;
name|def_operand_p
name|var1
decl_stmt|;
name|ssa_op_iter
name|op_iter
decl_stmt|;
comment|/* We want to verify that each virtual definition in STMT has 	 precisely one use and that all the virtual definitions are 	 used by the same single statement.  When complete, we 	 want USE_STMT to refer to the one statement which uses 	 all of the virtual definitions from STMT.  */
name|use_stmt
operator|=
name|NULL
expr_stmt|;
name|FOR_EACH_SSA_MUST_AND_MAY_DEF_OPERAND
argument_list|(
argument|var1
argument_list|,
argument|var2
argument_list|,
argument|stmt
argument_list|,
argument|op_iter
argument_list|)
block|{
name|defvar
operator|=
name|DEF_FROM_PTR
argument_list|(
name|var1
argument_list|)
expr_stmt|;
name|usevar
operator|=
name|USE_FROM_PTR
argument_list|(
name|var2
argument_list|)
expr_stmt|;
comment|/* If this virtual def does not have precisely one use, then 	     we will not be able to eliminate STMT.  */
if|if
condition|(
operator|!
name|has_single_use
argument_list|(
name|defvar
argument_list|)
condition|)
block|{
name|fail
operator|=
name|true
expr_stmt|;
break|break;
block|}
comment|/* Get the one and only immediate use of DEFVAR.  */
name|single_imm_use
argument_list|(
name|defvar
argument_list|,
operator|&
name|use_p
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|use_p
operator|!=
name|NULL_USE_OPERAND_P
argument_list|)
expr_stmt|;
name|first_use_p
operator|=
name|use_p
expr_stmt|;
comment|/* If the immediate use of DEF_VAR is not the same as the 	     previously find immediate uses, then we will not be able 	     to eliminate STMT.  */
if|if
condition|(
name|use_stmt
operator|==
name|NULL
condition|)
name|use_stmt
operator|=
name|temp
expr_stmt|;
elseif|else
if|if
condition|(
name|temp
operator|!=
name|use_stmt
condition|)
block|{
name|fail
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|fail
condition|)
block|{
name|record_voperand_set
argument_list|(
name|dse_gd
operator|->
name|stores
argument_list|,
operator|&
name|bd
operator|->
name|stores
argument_list|,
name|ann
operator|->
name|uid
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Skip through any PHI nodes we have already seen if the PHI 	 represents the only use of this store.  	 Note this does not handle the case where the store has 	 multiple V_{MAY,MUST}_DEFs which all reach a set of PHI nodes in the 	 same block.  */
while|while
condition|(
name|use_p
operator|!=
name|NULL_USE_OPERAND_P
operator|&&
name|TREE_CODE
argument_list|(
name|use_stmt
argument_list|)
operator|==
name|PHI_NODE
operator|&&
name|bitmap_bit_p
argument_list|(
name|dse_gd
operator|->
name|stores
argument_list|,
name|get_stmt_uid
argument_list|(
name|use_stmt
argument_list|)
argument_list|)
condition|)
block|{
comment|/* A PHI node can both define and use the same SSA_NAME if 	     the PHI is at the top of a loop and the PHI_RESULT is 	     a loop invariant and copies have not been fully propagated.  	     The safe thing to do is exit assuming no optimization is 	     possible.  */
if|if
condition|(
name|SSA_NAME_DEF_STMT
argument_list|(
name|PHI_RESULT
argument_list|(
name|use_stmt
argument_list|)
argument_list|)
operator|==
name|use_stmt
condition|)
return|return;
comment|/* Skip past this PHI and loop again in case we had a PHI 	     chain.  */
name|single_imm_use
argument_list|(
name|PHI_RESULT
argument_list|(
name|use_stmt
argument_list|)
argument_list|,
operator|&
name|use_p
argument_list|,
operator|&
name|use_stmt
argument_list|)
expr_stmt|;
block|}
comment|/* If we have precisely one immediate use at this point, then we may 	 have found redundant store.  Make sure that the stores are to 	 the same memory location.  This includes checking that any 	 SSA-form variables in the address will have the same values.  */
if|if
condition|(
name|use_p
operator|!=
name|NULL_USE_OPERAND_P
operator|&&
name|bitmap_bit_p
argument_list|(
name|dse_gd
operator|->
name|stores
argument_list|,
name|get_stmt_uid
argument_list|(
name|use_stmt
argument_list|)
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|use_stmt
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|&&
name|memory_address_same
argument_list|(
name|stmt
argument_list|,
name|use_stmt
argument_list|)
condition|)
block|{
comment|/* Make sure we propagate the ABNORMAL bit setting.  */
if|if
condition|(
name|SSA_NAME_OCCURS_IN_ABNORMAL_PHI
argument_list|(
name|USE_FROM_PTR
argument_list|(
name|first_use_p
argument_list|)
argument_list|)
condition|)
name|SSA_NAME_OCCURS_IN_ABNORMAL_PHI
argument_list|(
name|usevar
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  Deleted dead store '"
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"'\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Then we need to fix the operand of the consuming stmt.  */
name|FOR_EACH_SSA_MUST_AND_MAY_DEF_OPERAND
argument_list|(
argument|var1
argument_list|,
argument|var2
argument_list|,
argument|stmt
argument_list|,
argument|op_iter
argument_list|)
block|{
name|single_imm_use
argument_list|(
name|DEF_FROM_PTR
argument_list|(
name|var1
argument_list|)
argument_list|,
operator|&
name|use_p
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
name|SET_USE
argument_list|(
name|use_p
argument_list|,
name|USE_FROM_PTR
argument_list|(
name|var2
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Remove the dead store.  */
name|bsi_remove
argument_list|(
operator|&
name|bsi
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* And release any SSA_NAMEs set in this statement back to the 	     SSA_NAME manager.  */
name|release_defs
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
name|record_voperand_set
argument_list|(
name|dse_gd
operator|->
name|stores
argument_list|,
operator|&
name|bd
operator|->
name|stores
argument_list|,
name|ann
operator|->
name|uid
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Record that we have seen the PHIs at the start of BB which correspond    to virtual operands.  */
end_comment

begin_function
specifier|static
name|void
name|dse_record_phis
parameter_list|(
name|struct
name|dom_walk_data
modifier|*
name|walk_data
parameter_list|,
name|basic_block
name|bb
parameter_list|)
block|{
name|struct
name|dse_block_local_data
modifier|*
name|bd
init|=
name|VEC_last
argument_list|(
name|void_p
argument_list|,
name|walk_data
operator|->
name|block_data_stack
argument_list|)
decl_stmt|;
name|struct
name|dse_global_data
modifier|*
name|dse_gd
init|=
name|walk_data
operator|->
name|global_data
decl_stmt|;
name|tree
name|phi
decl_stmt|;
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|bb
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
if|if
condition|(
operator|!
name|is_gimple_reg
argument_list|(
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
argument_list|)
condition|)
name|record_voperand_set
argument_list|(
name|dse_gd
operator|->
name|stores
argument_list|,
operator|&
name|bd
operator|->
name|stores
argument_list|,
name|get_stmt_uid
argument_list|(
name|phi
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dse_finalize_block
parameter_list|(
name|struct
name|dom_walk_data
modifier|*
name|walk_data
parameter_list|,
name|basic_block
name|bb
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|struct
name|dse_block_local_data
modifier|*
name|bd
init|=
name|VEC_last
argument_list|(
name|void_p
argument_list|,
name|walk_data
operator|->
name|block_data_stack
argument_list|)
decl_stmt|;
name|struct
name|dse_global_data
modifier|*
name|dse_gd
init|=
name|walk_data
operator|->
name|global_data
decl_stmt|;
name|bitmap
name|stores
init|=
name|dse_gd
operator|->
name|stores
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
comment|/* Unwind the stores noted in this basic block.  */
if|if
condition|(
name|bd
operator|->
name|stores
condition|)
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|bd->stores
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
name|bitmap_clear_bit
argument_list|(
name|stores
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|tree_ssa_dse
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|dom_walk_data
name|walk_data
decl_stmt|;
name|struct
name|dse_global_data
name|dse_gd
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
comment|/* Create a UID for each statement in the function.  Ordering of the      UIDs is not important for this pass.  */
name|max_stmt_uid
operator|=
literal|0
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|block_stmt_iterator
name|bsi
decl_stmt|;
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
name|stmt_ann
argument_list|(
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
argument_list|)
operator|->
name|uid
operator|=
name|max_stmt_uid
operator|++
expr_stmt|;
block|}
comment|/* We might consider making this a property of each pass so that it      can be [re]computed on an as-needed basis.  Particularly since      this pass could be seen as an extension of DCE which needs post      dominators.  */
name|calculate_dominance_info
argument_list|(
name|CDI_POST_DOMINATORS
argument_list|)
expr_stmt|;
comment|/* Dead store elimination is fundamentally a walk of the post-dominator      tree and a backwards walk of statements within each block.  */
name|walk_data
operator|.
name|walk_stmts_backward
operator|=
name|true
expr_stmt|;
name|walk_data
operator|.
name|dom_direction
operator|=
name|CDI_POST_DOMINATORS
expr_stmt|;
name|walk_data
operator|.
name|initialize_block_local_data
operator|=
name|dse_initialize_block_local_data
expr_stmt|;
name|walk_data
operator|.
name|before_dom_children_before_stmts
operator|=
name|NULL
expr_stmt|;
name|walk_data
operator|.
name|before_dom_children_walk_stmts
operator|=
name|dse_optimize_stmt
expr_stmt|;
name|walk_data
operator|.
name|before_dom_children_after_stmts
operator|=
name|dse_record_phis
expr_stmt|;
name|walk_data
operator|.
name|after_dom_children_before_stmts
operator|=
name|NULL
expr_stmt|;
name|walk_data
operator|.
name|after_dom_children_walk_stmts
operator|=
name|NULL
expr_stmt|;
name|walk_data
operator|.
name|after_dom_children_after_stmts
operator|=
name|dse_finalize_block
expr_stmt|;
name|walk_data
operator|.
name|interesting_blocks
operator|=
name|NULL
expr_stmt|;
name|walk_data
operator|.
name|block_local_data_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|dse_block_local_data
argument_list|)
expr_stmt|;
comment|/* This is the main hash table for the dead store elimination pass.  */
name|dse_gd
operator|.
name|stores
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|walk_data
operator|.
name|global_data
operator|=
operator|&
name|dse_gd
expr_stmt|;
comment|/* Initialize the dominator walker.  */
name|init_walk_dominator_tree
argument_list|(
operator|&
name|walk_data
argument_list|)
expr_stmt|;
comment|/* Recursively walk the dominator tree.  */
name|walk_dominator_tree
argument_list|(
operator|&
name|walk_data
argument_list|,
name|EXIT_BLOCK_PTR
argument_list|)
expr_stmt|;
comment|/* Finalize the dominator walker.  */
name|fini_walk_dominator_tree
argument_list|(
operator|&
name|walk_data
argument_list|)
expr_stmt|;
comment|/* Release the main bitmap.  */
name|BITMAP_FREE
argument_list|(
name|dse_gd
operator|.
name|stores
argument_list|)
expr_stmt|;
comment|/* For now, just wipe the post-dominator information.  */
name|free_dominance_info
argument_list|(
name|CDI_POST_DOMINATORS
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|gate_dse
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|flag_tree_dse
operator|!=
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_dse
init|=
block|{
literal|"dse"
block|,
comment|/* name */
name|gate_dse
block|,
comment|/* gate */
name|tree_ssa_dse
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
name|TV_TREE_DSE
block|,
comment|/* tv_id */
name|PROP_cfg
operator||
name|PROP_ssa
operator||
name|PROP_alias
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_dump_func
operator||
name|TODO_ggc_collect
operator||
name|TODO_verify_ssa
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

end_unit

