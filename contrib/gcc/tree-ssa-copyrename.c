begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Rename SSA copies.    Copyright (C) 2004 Free Software Foundation, Inc.    Contributed by Andrew MacLeod<amacleod@redhat.com>  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"bitmap.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"tree-gimple.h"
end_include

begin_include
include|#
directive|include
file|"tree-inline.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"tree-dump.h"
end_include

begin_include
include|#
directive|include
file|"tree-ssa-live.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_comment
comment|/* The following routines implement the SSA copy renaming phase.     This optimization looks for copies between 2 SSA_NAMES, either through a    direct copy, or an implicit one via a PHI node result and its arguments.     Each copy is examined to determine if it is possible to rename the base    variable of one of the operands to the same variable as the other operand.    i.e.    T.3_5 =<blah>    a_1 = T.3_5     If this copy couldn't be copy propagated, it could possibly remain in the     program throughout the optimization phases.   After SSA->normal, it would     become:     T.3 =<blah>    a = T.3        Since T.3_5 is distinct from all other SSA versions of T.3, there is no     fundamental reason why the base variable needs to be T.3, subject to     certain restrictions.  This optimization attempts to determine if we can     change the base variable on copies like this, and result in code such as:     a_5 =<blah>    a_1 = a_5     This gives the SSA->normal pass a shot at coalescing a_1 and a_5. If it is     possible, the copy goes away completely. If it isn't possible, a new temp    will be created for a_5, and you will end up with the exact same code:     a.8 =<blah>    a = a.8     The other benefit of performing this optimization relates to what variables    are chosen in copies.  Gimplification of the program uses temporaries for    a lot of things. expressions like     a_1 =<blah><blah2> = a_1     get turned into          T.3_5 =<blah>    a_1 = T.3_5<blah2> = a_1     Copy propagation is done in a forward direction, and if we can propagate    through the copy, we end up with:     T.3_5 =<blah><blah2> = T.3_5     The copy is gone, but so is all reference to the user variable 'a'. By    performing this optimization, we would see the sequence:     a_5 =<blah>    a_1 = a_5<blah2> = a_1     which copy propagation would then turn into:        a_5 =<blah><blah2> = a_5     and so we still retain the user variable whenever possible.  */
end_comment

begin_comment
comment|/* Coalesce the partitions in MAP representing VAR1 and VAR2 if it is valid.    Choose a representative for the partition, and send debug info to DEBUG.  */
end_comment

begin_function
specifier|static
name|void
name|copy_rename_partition_coalesce
parameter_list|(
name|var_map
name|map
parameter_list|,
name|tree
name|var1
parameter_list|,
name|tree
name|var2
parameter_list|,
name|FILE
modifier|*
name|debug
parameter_list|)
block|{
name|int
name|p1
decl_stmt|,
name|p2
decl_stmt|,
name|p3
decl_stmt|;
name|tree
name|root1
decl_stmt|,
name|root2
decl_stmt|;
name|tree
name|rep1
decl_stmt|,
name|rep2
decl_stmt|;
name|var_ann_t
name|ann1
decl_stmt|,
name|ann2
decl_stmt|,
name|ann3
decl_stmt|;
name|bool
name|ign1
decl_stmt|,
name|ign2
decl_stmt|,
name|abnorm
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|var1
argument_list|)
operator|==
name|SSA_NAME
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|var2
argument_list|)
operator|==
name|SSA_NAME
argument_list|)
expr_stmt|;
name|register_ssa_partition
argument_list|(
name|map
argument_list|,
name|var1
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|register_ssa_partition
argument_list|(
name|map
argument_list|,
name|var2
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|p1
operator|=
name|partition_find
argument_list|(
name|map
operator|->
name|var_partition
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|var1
argument_list|)
argument_list|)
expr_stmt|;
name|p2
operator|=
name|partition_find
argument_list|(
name|map
operator|->
name|var_partition
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|var2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
block|{
name|fprintf
argument_list|(
name|debug
argument_list|,
literal|"Try : "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|debug
argument_list|,
name|var1
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|debug
argument_list|,
literal|"(P%d)& "
argument_list|,
name|p1
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|debug
argument_list|,
name|var2
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|debug
argument_list|,
literal|"(P%d)"
argument_list|,
name|p2
argument_list|)
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|p1
operator|!=
name|NO_PARTITION
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|p2
operator|!=
name|NO_PARTITION
argument_list|)
expr_stmt|;
name|rep1
operator|=
name|partition_to_var
argument_list|(
name|map
argument_list|,
name|p1
argument_list|)
expr_stmt|;
name|rep2
operator|=
name|partition_to_var
argument_list|(
name|map
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|root1
operator|=
name|SSA_NAME_VAR
argument_list|(
name|rep1
argument_list|)
expr_stmt|;
name|root2
operator|=
name|SSA_NAME_VAR
argument_list|(
name|rep2
argument_list|)
expr_stmt|;
name|ann1
operator|=
name|var_ann
argument_list|(
name|root1
argument_list|)
expr_stmt|;
name|ann2
operator|=
name|var_ann
argument_list|(
name|root2
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|==
name|p2
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|debug
argument_list|,
literal|" : Already coalesced.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Don't coalesce if one of the variables occurs in an abnormal PHI.  */
name|abnorm
operator|=
operator|(
name|SSA_NAME_OCCURS_IN_ABNORMAL_PHI
argument_list|(
name|rep1
argument_list|)
operator|||
name|SSA_NAME_OCCURS_IN_ABNORMAL_PHI
argument_list|(
name|rep2
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|abnorm
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|debug
argument_list|,
literal|" : Abnormal PHI barrier.  No coalesce.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Partitions already have the same root, simply merge them.  */
if|if
condition|(
name|root1
operator|==
name|root2
condition|)
block|{
name|p1
operator|=
name|partition_union
argument_list|(
name|map
operator|->
name|var_partition
argument_list|,
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|debug
argument_list|,
literal|" : Same root, coalesced --> P%d.\n"
argument_list|,
name|p1
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Never attempt to coalesce 2 difference parameters.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|root1
argument_list|)
operator|==
name|PARM_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|root2
argument_list|)
operator|==
name|PARM_DECL
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|debug
argument_list|,
literal|" : 2 different PARM_DECLS. No coalesce.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|root1
argument_list|)
operator|==
name|RESULT_DECL
operator|)
operator|!=
operator|(
name|TREE_CODE
argument_list|(
name|root2
argument_list|)
operator|==
name|RESULT_DECL
operator|)
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|debug
argument_list|,
literal|" : One root a RESULT_DECL. No coalesce.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|ign1
operator|=
name|TREE_CODE
argument_list|(
name|root1
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_IGNORED_P
argument_list|(
name|root1
argument_list|)
expr_stmt|;
name|ign2
operator|=
name|TREE_CODE
argument_list|(
name|root2
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_IGNORED_P
argument_list|(
name|root2
argument_list|)
expr_stmt|;
comment|/* Never attempt to coalesce 2 user variables unless one is an inline       variable.  */
if|if
condition|(
operator|!
name|ign1
operator|&&
operator|!
name|ign2
condition|)
block|{
if|if
condition|(
name|DECL_FROM_INLINE
argument_list|(
name|root2
argument_list|)
condition|)
name|ign2
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_FROM_INLINE
argument_list|(
name|root1
argument_list|)
condition|)
name|ign1
operator|=
name|true
expr_stmt|;
else|else
block|{
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|debug
argument_list|,
literal|" : 2 different USER vars. No coalesce.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Don't coalesce if there are two different memory tags.  */
if|if
condition|(
name|ann1
operator|->
name|symbol_mem_tag
operator|&&
name|ann2
operator|->
name|symbol_mem_tag
operator|&&
name|ann1
operator|->
name|symbol_mem_tag
operator|!=
name|ann2
operator|->
name|symbol_mem_tag
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|debug
argument_list|,
literal|" : 2 memory tags. No coalesce.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If both values have default defs, we can't coalesce.  If only one has a       tag, make sure that variable is the new root partition.  */
if|if
condition|(
name|default_def
argument_list|(
name|root1
argument_list|)
condition|)
block|{
if|if
condition|(
name|default_def
argument_list|(
name|root2
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|debug
argument_list|,
literal|" : 2 default defs. No coalesce.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|ign2
operator|=
name|true
expr_stmt|;
name|ign1
operator|=
name|false
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|default_def
argument_list|(
name|root2
argument_list|)
condition|)
block|{
name|ign1
operator|=
name|true
expr_stmt|;
name|ign2
operator|=
name|false
expr_stmt|;
block|}
comment|/* Don't coalesce if the two variables aren't type compatible.  */
if|if
condition|(
operator|!
name|lang_hooks
operator|.
name|types_compatible_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|root1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|root2
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|debug
argument_list|,
literal|" : Incompatible types.  No coalesce.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Don't coalesce if the aliasing sets of the types are different.  */
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|root1
argument_list|)
argument_list|)
operator|&&
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|root2
argument_list|)
argument_list|)
operator|&&
name|get_alias_set
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|root1
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|get_alias_set
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|root2
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|debug
argument_list|,
literal|" : 2 different aliasing sets. No coalesce.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Merge the two partitions.  */
name|p3
operator|=
name|partition_union
argument_list|(
name|map
operator|->
name|var_partition
argument_list|,
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
comment|/* Set the root variable of the partition to the better choice, if there is       one.  */
if|if
condition|(
operator|!
name|ign2
condition|)
name|replace_ssa_name_symbol
argument_list|(
name|partition_to_var
argument_list|(
name|map
argument_list|,
name|p3
argument_list|)
argument_list|,
name|root2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|ign1
condition|)
name|replace_ssa_name_symbol
argument_list|(
name|partition_to_var
argument_list|(
name|map
argument_list|,
name|p3
argument_list|)
argument_list|,
name|root1
argument_list|)
expr_stmt|;
comment|/* Update the various flag widgitry of the current base representative.  */
name|ann3
operator|=
name|var_ann
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|partition_to_var
argument_list|(
name|map
argument_list|,
name|p3
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ann1
operator|->
name|symbol_mem_tag
condition|)
name|ann3
operator|->
name|symbol_mem_tag
operator|=
name|ann1
operator|->
name|symbol_mem_tag
expr_stmt|;
else|else
name|ann3
operator|->
name|symbol_mem_tag
operator|=
name|ann2
operator|->
name|symbol_mem_tag
expr_stmt|;
if|if
condition|(
name|debug
condition|)
block|{
name|fprintf
argument_list|(
name|debug
argument_list|,
literal|" --> P%d "
argument_list|,
name|p3
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|debug
argument_list|,
name|SSA_NAME_VAR
argument_list|(
name|partition_to_var
argument_list|(
name|map
argument_list|,
name|p3
argument_list|)
argument_list|)
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|debug
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This function will make a pass through the IL, and attempt to coalesce any    SSA versions which occur in PHI's or copies.  Coalescing is accomplished by    changing the underlying root variable of all coalesced version.  This will     then cause the SSA->normal pass to attempt to coalesce them all to the same     variable.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|rename_ssa_copies
parameter_list|(
name|void
parameter_list|)
block|{
name|var_map
name|map
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|tree
name|phi
decl_stmt|,
name|stmt
decl_stmt|,
name|var
decl_stmt|,
name|part_var
decl_stmt|;
name|unsigned
name|x
decl_stmt|;
name|FILE
modifier|*
name|debug
decl_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|debug
operator|=
name|dump_file
expr_stmt|;
else|else
name|debug
operator|=
name|NULL
expr_stmt|;
name|map
operator|=
name|init_var_map
argument_list|(
name|num_ssa_names
operator|+
literal|1
argument_list|)
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
comment|/* Scan for real copies.  */
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
block|{
name|stmt
operator|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|MODIFY_EXPR
condition|)
block|{
name|tree
name|lhs
init|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|rhs
init|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|SSA_NAME
operator|&&
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|SSA_NAME
condition|)
name|copy_rename_partition_coalesce
argument_list|(
name|map
argument_list|,
name|lhs
argument_list|,
name|rhs
argument_list|,
name|debug
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
comment|/* Treat PHI nodes as copies between the result and each argument.  */
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|bb
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
block|{
name|int
name|i
decl_stmt|;
name|tree
name|res
init|=
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
decl_stmt|;
comment|/* Do not process virtual SSA_NAMES.  */
if|if
condition|(
operator|!
name|is_gimple_reg
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|res
argument_list|)
argument_list|)
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PHI_NUM_ARGS
argument_list|(
name|phi
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|arg
init|=
name|PHI_ARG_DEF
argument_list|(
name|phi
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|SSA_NAME
condition|)
name|copy_rename_partition_coalesce
argument_list|(
name|map
argument_list|,
name|res
argument_list|,
name|arg
argument_list|,
name|debug
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|debug
condition|)
name|dump_var_map
argument_list|(
name|debug
argument_list|,
name|map
argument_list|)
expr_stmt|;
comment|/* Now one more pass to make all elements of a partition share the same      root variable.  */
for|for
control|(
name|x
operator|=
literal|1
init|;
name|x
operator|<=
name|num_ssa_names
condition|;
name|x
operator|++
control|)
block|{
name|part_var
operator|=
name|partition_to_var
argument_list|(
name|map
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|part_var
condition|)
continue|continue;
name|var
operator|=
name|map
operator|->
name|partition_to_var
index|[
name|x
index|]
expr_stmt|;
if|if
condition|(
name|debug
condition|)
block|{
if|if
condition|(
name|SSA_NAME_VAR
argument_list|(
name|var
argument_list|)
operator|!=
name|SSA_NAME_VAR
argument_list|(
name|part_var
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug
argument_list|,
literal|"Coalesced "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|debug
argument_list|,
name|var
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|debug
argument_list|,
literal|" to "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|debug
argument_list|,
name|part_var
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|debug
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|replace_ssa_name_symbol
argument_list|(
name|var
argument_list|,
name|SSA_NAME_VAR
argument_list|(
name|part_var
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|delete_var_map
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return true if copy rename is to be performed.  */
end_comment

begin_function
specifier|static
name|bool
name|gate_copyrename
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|flag_tree_copyrename
operator|!=
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_rename_ssa_copies
init|=
block|{
literal|"copyrename"
block|,
comment|/* name */
name|gate_copyrename
block|,
comment|/* gate */
name|rename_ssa_copies
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
name|TV_TREE_COPY_RENAME
block|,
comment|/* tv_id */
name|PROP_cfg
operator||
name|PROP_ssa
operator||
name|PROP_alias
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_dump_func
operator||
name|TODO_verify_ssa
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

end_unit

