begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Convert a program in SSA form into Normal form.    Copyright (C) 2004, 2005 Free Software Foundation, Inc.    Contributed by Andrew Macleod<amacleod@redhat.com>  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"bitmap.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"tree-gimple.h"
end_include

begin_include
include|#
directive|include
file|"tree-inline.h"
end_include

begin_include
include|#
directive|include
file|"varray.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"tree-dump.h"
end_include

begin_include
include|#
directive|include
file|"tree-ssa-live.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"vecprim.h"
end_include

begin_comment
comment|/* Flags to pass to remove_ssa_form.  */
end_comment

begin_define
define|#
directive|define
name|SSANORM_PERFORM_TER
value|0x1
end_define

begin_define
define|#
directive|define
name|SSANORM_COMBINE_TEMPS
value|0x2
end_define

begin_define
define|#
directive|define
name|SSANORM_COALESCE_PARTITIONS
value|0x4
end_define

begin_comment
comment|/* Used to hold all the components required to do SSA PHI elimination.    The node and pred/succ list is a simple linear list of nodes and    edges represented as pairs of nodes.     The predecessor and successor list:  Nodes are entered in pairs, where    [0] ->PRED, [1]->SUCC.  All the even indexes in the array represent     predecessors, all the odd elements are successors.         Rationale:    When implemented as bitmaps, very large programs SSA->Normal times were     being dominated by clearing the interference graph.     Typically this list of edges is extremely small since it only includes     PHI results and uses from a single edge which have not coalesced with     each other.  This means that no virtual PHI nodes are included, and    empirical evidence suggests that the number of edges rarely exceed    3, and in a bootstrap of GCC, the maximum size encountered was 7.    This also limits the number of possible nodes that are involved to    rarely more than 6, and in the bootstrap of gcc, the maximum number    of nodes encountered was 12.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|_elim_graph
block|{
comment|/* Size of the elimination vectors.  */
name|int
name|size
decl_stmt|;
comment|/* List of nodes in the elimination graph.  */
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
name|nodes
expr_stmt|;
comment|/*  The predecessor and successor edge list.  */
name|VEC
argument_list|(
name|int
argument_list|,
name|heap
argument_list|)
operator|*
name|edge_list
expr_stmt|;
comment|/* Visited vector.  */
name|sbitmap
name|visited
decl_stmt|;
comment|/* Stack for visited nodes.  */
name|VEC
argument_list|(
name|int
argument_list|,
name|heap
argument_list|)
operator|*
name|stack
expr_stmt|;
comment|/* The variable partition map.  */
name|var_map
name|map
decl_stmt|;
comment|/* Edge being eliminated by this graph.  */
name|edge
name|e
decl_stmt|;
comment|/* List of constant copies to emit.  These are pushed on in pairs.  */
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
name|const_copies
expr_stmt|;
block|}
typedef|*
name|elim_graph
typedef|;
end_typedef

begin_comment
comment|/* Local functions.  */
end_comment

begin_function_decl
specifier|static
name|tree
name|create_temp
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|insert_copy_on_edge
parameter_list|(
name|edge
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|elim_graph
name|new_elim_graph
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|delete_elim_graph
parameter_list|(
name|elim_graph
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|clear_elim_graph
parameter_list|(
name|elim_graph
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|int
name|elim_graph_size
parameter_list|(
name|elim_graph
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|elim_graph_add_node
parameter_list|(
name|elim_graph
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|elim_graph_add_edge
parameter_list|(
name|elim_graph
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|int
name|elim_graph_remove_succ_edge
parameter_list|(
name|elim_graph
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|eliminate_name
parameter_list|(
name|elim_graph
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|eliminate_build
parameter_list|(
name|elim_graph
parameter_list|,
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|elim_forward
parameter_list|(
name|elim_graph
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|elim_unvisited_predecessor
parameter_list|(
name|elim_graph
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|elim_backward
parameter_list|(
name|elim_graph
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|elim_create
parameter_list|(
name|elim_graph
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|eliminate_phi
parameter_list|(
name|edge
parameter_list|,
name|elim_graph
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree_live_info_p
name|coalesce_ssa_name
parameter_list|(
name|var_map
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|assign_vars
parameter_list|(
name|var_map
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|replace_use_variable
parameter_list|(
name|var_map
parameter_list|,
name|use_operand_p
parameter_list|,
name|tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|replace_def_variable
parameter_list|(
name|var_map
parameter_list|,
name|def_operand_p
parameter_list|,
name|tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|eliminate_virtual_phis
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|coalesce_abnormal_edges
parameter_list|(
name|var_map
parameter_list|,
name|conflict_graph
parameter_list|,
name|root_var_p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_exprs
parameter_list|(
name|FILE
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|tree
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|tree
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_exprs_edge
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|edge
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|tree
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Create a temporary variable based on the type of variable T.  Use T's name    as the prefix.  */
end_comment

begin_function
specifier|static
name|tree
name|create_temp
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|tree
name|tmp
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|SSA_NAME
condition|)
name|t
operator|=
name|SSA_NAME_VAR
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|PARM_DECL
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|DECL_NAME
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
condition|)
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|name
operator|=
literal|"temp"
expr_stmt|;
name|tmp
operator|=
name|create_tmp_var
argument_list|(
name|type
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_DEBUG_EXPR_IS_FROM
argument_list|(
name|t
argument_list|)
operator|&&
name|DECL_DEBUG_EXPR
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|SET_DECL_DEBUG_EXPR
argument_list|(
name|tmp
argument_list|,
name|DECL_DEBUG_EXPR
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_DEBUG_EXPR_IS_FROM
argument_list|(
name|tmp
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|DECL_IGNORED_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|SET_DECL_DEBUG_EXPR
argument_list|(
name|tmp
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|DECL_DEBUG_EXPR_IS_FROM
argument_list|(
name|tmp
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|DECL_ARTIFICIAL
argument_list|(
name|tmp
argument_list|)
operator|=
name|DECL_ARTIFICIAL
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|DECL_IGNORED_P
argument_list|(
name|tmp
argument_list|)
operator|=
name|DECL_IGNORED_P
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|add_referenced_var
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
comment|/* add_referenced_var will create the annotation and set up some      of the flags in the annotation.  However, some flags we need to      inherit from our original variable.  */
name|var_ann
argument_list|(
name|tmp
argument_list|)
operator|->
name|symbol_mem_tag
operator|=
name|var_ann
argument_list|(
name|t
argument_list|)
operator|->
name|symbol_mem_tag
expr_stmt|;
if|if
condition|(
name|is_call_clobbered
argument_list|(
name|t
argument_list|)
condition|)
name|mark_call_clobbered
argument_list|(
name|tmp
argument_list|,
name|var_ann
argument_list|(
name|t
argument_list|)
operator|->
name|escape_mask
argument_list|)
expr_stmt|;
return|return
name|tmp
return|;
block|}
end_function

begin_comment
comment|/* This helper function fill insert a copy from a constant or variable SRC to     variable DEST on edge E.  */
end_comment

begin_function
specifier|static
name|void
name|insert_copy_on_edge
parameter_list|(
name|edge
name|e
parameter_list|,
name|tree
name|dest
parameter_list|,
name|tree
name|src
parameter_list|)
block|{
name|tree
name|copy
decl_stmt|;
name|copy
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|dest
argument_list|)
argument_list|,
name|dest
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|set_is_used
argument_list|(
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
name|src
operator|=
name|TREE_OPERAND
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|PARM_DECL
condition|)
name|set_is_used
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Inserting a copy on edge BB%d->BB%d :"
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|copy
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|bsi_insert_on_edge
argument_list|(
name|e
argument_list|,
name|copy
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create an elimination graph with SIZE nodes and associated data    structures.  */
end_comment

begin_function
specifier|static
name|elim_graph
name|new_elim_graph
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|elim_graph
name|g
init|=
operator|(
name|elim_graph
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|_elim_graph
argument_list|)
argument_list|)
decl_stmt|;
name|g
operator|->
name|nodes
operator|=
name|VEC_alloc
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|g
operator|->
name|const_copies
operator|=
name|VEC_alloc
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|g
operator|->
name|edge_list
operator|=
name|VEC_alloc
argument_list|(
name|int
argument_list|,
name|heap
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|g
operator|->
name|stack
operator|=
name|VEC_alloc
argument_list|(
name|int
argument_list|,
name|heap
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|g
operator|->
name|visited
operator|=
name|sbitmap_alloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
return|return
name|g
return|;
block|}
end_function

begin_comment
comment|/* Empty elimination graph G.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|clear_elim_graph
parameter_list|(
name|elim_graph
name|g
parameter_list|)
block|{
name|VEC_truncate
argument_list|(
name|tree
argument_list|,
name|g
operator|->
name|nodes
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VEC_truncate
argument_list|(
name|int
argument_list|,
name|g
operator|->
name|edge_list
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Delete elimination graph G.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|delete_elim_graph
parameter_list|(
name|elim_graph
name|g
parameter_list|)
block|{
name|sbitmap_free
argument_list|(
name|g
operator|->
name|visited
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|int
argument_list|,
name|heap
argument_list|,
name|g
operator|->
name|stack
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|int
argument_list|,
name|heap
argument_list|,
name|g
operator|->
name|edge_list
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|g
operator|->
name|const_copies
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|g
operator|->
name|nodes
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|g
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the number of nodes in graph G.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|elim_graph_size
parameter_list|(
name|elim_graph
name|g
parameter_list|)
block|{
return|return
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|g
operator|->
name|nodes
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Add NODE to graph G, if it doesn't exist already.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|elim_graph_add_node
parameter_list|(
name|elim_graph
name|g
parameter_list|,
name|tree
name|node
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
name|tree
name|t
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
name|g
operator|->
name|nodes
argument_list|,
name|x
argument_list|,
name|t
argument_list|)
condition|;
name|x
operator|++
control|)
if|if
condition|(
name|t
operator|==
name|node
condition|)
return|return;
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|g
operator|->
name|nodes
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add the edge PRED->SUCC to graph G.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|elim_graph_add_edge
parameter_list|(
name|elim_graph
name|g
parameter_list|,
name|int
name|pred
parameter_list|,
name|int
name|succ
parameter_list|)
block|{
name|VEC_safe_push
argument_list|(
name|int
argument_list|,
name|heap
argument_list|,
name|g
operator|->
name|edge_list
argument_list|,
name|pred
argument_list|)
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|int
argument_list|,
name|heap
argument_list|,
name|g
operator|->
name|edge_list
argument_list|,
name|succ
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove an edge from graph G for which NODE is the predecessor, and    return the successor node.  -1 is returned if there is no such edge.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|elim_graph_remove_succ_edge
parameter_list|(
name|elim_graph
name|g
parameter_list|,
name|int
name|node
parameter_list|)
block|{
name|int
name|y
decl_stmt|;
name|unsigned
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|VEC_length
argument_list|(
name|int
argument_list|,
name|g
operator|->
name|edge_list
argument_list|)
condition|;
name|x
operator|+=
literal|2
control|)
if|if
condition|(
name|VEC_index
argument_list|(
name|int
argument_list|,
name|g
operator|->
name|edge_list
argument_list|,
name|x
argument_list|)
operator|==
name|node
condition|)
block|{
name|VEC_replace
argument_list|(
name|int
argument_list|,
name|g
operator|->
name|edge_list
argument_list|,
name|x
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|y
operator|=
name|VEC_index
argument_list|(
name|int
argument_list|,
name|g
operator|->
name|edge_list
argument_list|,
name|x
operator|+
literal|1
argument_list|)
expr_stmt|;
name|VEC_replace
argument_list|(
name|int
argument_list|,
name|g
operator|->
name|edge_list
argument_list|,
name|x
operator|+
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|y
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Find all the nodes in GRAPH which are successors to NODE in the    edge list.  VAR will hold the partition number found.  CODE is the    code fragment executed for every node found.  */
end_comment

begin_define
define|#
directive|define
name|FOR_EACH_ELIM_GRAPH_SUCC
parameter_list|(
name|GRAPH
parameter_list|,
name|NODE
parameter_list|,
name|VAR
parameter_list|,
name|CODE
parameter_list|)
define|\
value|do {									\   unsigned x_;								\   int y_;								\   for (x_ = 0; x_< VEC_length (int, (GRAPH)->edge_list); x_ += 2)	\     {									\       y_ = VEC_index (int, (GRAPH)->edge_list, x_);			\       if (y_ != (NODE))							\         continue;							\       (VAR) = VEC_index (int, (GRAPH)->edge_list, x_ + 1);		\       CODE;								\     }									\ } while (0)
end_define

begin_comment
comment|/* Find all the nodes which are predecessors of NODE in the edge list for    GRAPH.  VAR will hold the partition number found.  CODE is the    code fragment executed for every node found.  */
end_comment

begin_define
define|#
directive|define
name|FOR_EACH_ELIM_GRAPH_PRED
parameter_list|(
name|GRAPH
parameter_list|,
name|NODE
parameter_list|,
name|VAR
parameter_list|,
name|CODE
parameter_list|)
define|\
value|do {									\   unsigned x_;								\   int y_;								\   for (x_ = 0; x_< VEC_length (int, (GRAPH)->edge_list); x_ += 2)	\     {									\       y_ = VEC_index (int, (GRAPH)->edge_list, x_ + 1);			\       if (y_ != (NODE))							\         continue;							\       (VAR) = VEC_index (int, (GRAPH)->edge_list, x_);			\       CODE;								\     }									\ } while (0)
end_define

begin_comment
comment|/* Add T to elimination graph G.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|eliminate_name
parameter_list|(
name|elim_graph
name|g
parameter_list|,
name|tree
name|T
parameter_list|)
block|{
name|elim_graph_add_node
argument_list|(
name|g
argument_list|,
name|T
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Build elimination graph G for basic block BB on incoming PHI edge    G->e.  */
end_comment

begin_function
specifier|static
name|void
name|eliminate_build
parameter_list|(
name|elim_graph
name|g
parameter_list|,
name|basic_block
name|B
parameter_list|)
block|{
name|tree
name|phi
decl_stmt|;
name|tree
name|T0
decl_stmt|,
name|Ti
decl_stmt|;
name|int
name|p0
decl_stmt|,
name|pi
decl_stmt|;
name|clear_elim_graph
argument_list|(
name|g
argument_list|)
expr_stmt|;
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|B
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
block|{
name|T0
operator|=
name|var_to_partition_to_var
argument_list|(
name|g
operator|->
name|map
argument_list|,
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Ignore results which are not in partitions.  */
if|if
condition|(
name|T0
operator|==
name|NULL_TREE
condition|)
continue|continue;
name|Ti
operator|=
name|PHI_ARG_DEF
argument_list|(
name|phi
argument_list|,
name|g
operator|->
name|e
operator|->
name|dest_idx
argument_list|)
expr_stmt|;
comment|/* If this argument is a constant, or a SSA_NAME which is being 	 left in SSA form, just queue a copy to be emitted on this 	 edge.  */
if|if
condition|(
operator|!
name|phi_ssa_name_p
argument_list|(
name|Ti
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|Ti
argument_list|)
operator|==
name|SSA_NAME
operator|&&
name|var_to_partition
argument_list|(
name|g
operator|->
name|map
argument_list|,
name|Ti
argument_list|)
operator|==
name|NO_PARTITION
operator|)
condition|)
block|{
comment|/* Save constant copies until all other copies have been emitted 	     on this edge.  */
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|g
operator|->
name|const_copies
argument_list|,
name|T0
argument_list|)
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|g
operator|->
name|const_copies
argument_list|,
name|Ti
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Ti
operator|=
name|var_to_partition_to_var
argument_list|(
name|g
operator|->
name|map
argument_list|,
name|Ti
argument_list|)
expr_stmt|;
if|if
condition|(
name|T0
operator|!=
name|Ti
condition|)
block|{
name|eliminate_name
argument_list|(
name|g
argument_list|,
name|T0
argument_list|)
expr_stmt|;
name|eliminate_name
argument_list|(
name|g
argument_list|,
name|Ti
argument_list|)
expr_stmt|;
name|p0
operator|=
name|var_to_partition
argument_list|(
name|g
operator|->
name|map
argument_list|,
name|T0
argument_list|)
expr_stmt|;
name|pi
operator|=
name|var_to_partition
argument_list|(
name|g
operator|->
name|map
argument_list|,
name|Ti
argument_list|)
expr_stmt|;
name|elim_graph_add_edge
argument_list|(
name|g
argument_list|,
name|p0
argument_list|,
name|pi
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Push successors of T onto the elimination stack for G.  */
end_comment

begin_function
specifier|static
name|void
name|elim_forward
parameter_list|(
name|elim_graph
name|g
parameter_list|,
name|int
name|T
parameter_list|)
block|{
name|int
name|S
decl_stmt|;
name|SET_BIT
argument_list|(
name|g
operator|->
name|visited
argument_list|,
name|T
argument_list|)
expr_stmt|;
name|FOR_EACH_ELIM_GRAPH_SUCC
argument_list|(
argument|g
argument_list|,
argument|T
argument_list|,
argument|S
argument_list|,
argument|{       if (!TEST_BIT (g->visited, S))         elim_forward (g, S);     }
argument_list|)
empty_stmt|;
name|VEC_safe_push
argument_list|(
name|int
argument_list|,
name|heap
argument_list|,
name|g
operator|->
name|stack
argument_list|,
name|T
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return 1 if there unvisited predecessors of T in graph G.  */
end_comment

begin_function
specifier|static
name|int
name|elim_unvisited_predecessor
parameter_list|(
name|elim_graph
name|g
parameter_list|,
name|int
name|T
parameter_list|)
block|{
name|int
name|P
decl_stmt|;
name|FOR_EACH_ELIM_GRAPH_PRED
argument_list|(
argument|g
argument_list|,
argument|T
argument_list|,
argument|P
argument_list|,
argument|{       if (!TEST_BIT (g->visited, P))         return
literal|1
argument|;     }
argument_list|)
empty_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Process predecessors first, and insert a copy.  */
end_comment

begin_function
specifier|static
name|void
name|elim_backward
parameter_list|(
name|elim_graph
name|g
parameter_list|,
name|int
name|T
parameter_list|)
block|{
name|int
name|P
decl_stmt|;
name|SET_BIT
argument_list|(
name|g
operator|->
name|visited
argument_list|,
name|T
argument_list|)
expr_stmt|;
name|FOR_EACH_ELIM_GRAPH_PRED
argument_list|(
argument|g
argument_list|,
argument|T
argument_list|,
argument|P
argument_list|,
argument|{       if (!TEST_BIT (g->visited, P))         { 	  elim_backward (g, P); 	  insert_copy_on_edge (g->e,  			       partition_to_var (g->map, P),  			       partition_to_var (g->map, T)); 	}     }
argument_list|)
empty_stmt|;
block|}
end_function

begin_comment
comment|/* Insert required copies for T in graph G.  Check for a strongly connected     region, and create a temporary to break the cycle if one is found.  */
end_comment

begin_function
specifier|static
name|void
name|elim_create
parameter_list|(
name|elim_graph
name|g
parameter_list|,
name|int
name|T
parameter_list|)
block|{
name|tree
name|U
decl_stmt|;
name|int
name|P
decl_stmt|,
name|S
decl_stmt|;
if|if
condition|(
name|elim_unvisited_predecessor
argument_list|(
name|g
argument_list|,
name|T
argument_list|)
condition|)
block|{
name|U
operator|=
name|create_temp
argument_list|(
name|partition_to_var
argument_list|(
name|g
operator|->
name|map
argument_list|,
name|T
argument_list|)
argument_list|)
expr_stmt|;
name|insert_copy_on_edge
argument_list|(
name|g
operator|->
name|e
argument_list|,
name|U
argument_list|,
name|partition_to_var
argument_list|(
name|g
operator|->
name|map
argument_list|,
name|T
argument_list|)
argument_list|)
expr_stmt|;
name|FOR_EACH_ELIM_GRAPH_PRED
argument_list|(
argument|g
argument_list|,
argument|T
argument_list|,
argument|P
argument_list|,
argument|{ 	  if (!TEST_BIT (g->visited, P)) 	    { 	      elim_backward (g, P); 	      insert_copy_on_edge (g->e, partition_to_var (g->map, P), U); 	    } 	}
argument_list|)
empty_stmt|;
block|}
else|else
block|{
name|S
operator|=
name|elim_graph_remove_succ_edge
argument_list|(
name|g
argument_list|,
name|T
argument_list|)
expr_stmt|;
if|if
condition|(
name|S
operator|!=
operator|-
literal|1
condition|)
block|{
name|SET_BIT
argument_list|(
name|g
operator|->
name|visited
argument_list|,
name|T
argument_list|)
expr_stmt|;
name|insert_copy_on_edge
argument_list|(
name|g
operator|->
name|e
argument_list|,
name|partition_to_var
argument_list|(
name|g
operator|->
name|map
argument_list|,
name|T
argument_list|)
argument_list|,
name|partition_to_var
argument_list|(
name|g
operator|->
name|map
argument_list|,
name|S
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Eliminate all the phi nodes on edge E in graph G.  */
end_comment

begin_function
specifier|static
name|void
name|eliminate_phi
parameter_list|(
name|edge
name|e
parameter_list|,
name|elim_graph
name|g
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
name|basic_block
name|B
init|=
name|e
operator|->
name|dest
decl_stmt|;
name|gcc_assert
argument_list|(
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|g
operator|->
name|const_copies
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* Abnormal edges already have everything coalesced.  */
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
condition|)
return|return;
name|g
operator|->
name|e
operator|=
name|e
expr_stmt|;
name|eliminate_build
argument_list|(
name|g
argument_list|,
name|B
argument_list|)
expr_stmt|;
if|if
condition|(
name|elim_graph_size
argument_list|(
name|g
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|tree
name|var
decl_stmt|;
name|sbitmap_zero
argument_list|(
name|g
operator|->
name|visited
argument_list|)
expr_stmt|;
name|VEC_truncate
argument_list|(
name|int
argument_list|,
name|g
operator|->
name|stack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
name|g
operator|->
name|nodes
argument_list|,
name|x
argument_list|,
name|var
argument_list|)
condition|;
name|x
operator|++
control|)
block|{
name|int
name|p
init|=
name|var_to_partition
argument_list|(
name|g
operator|->
name|map
argument_list|,
name|var
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|g
operator|->
name|visited
argument_list|,
name|p
argument_list|)
condition|)
name|elim_forward
argument_list|(
name|g
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|sbitmap_zero
argument_list|(
name|g
operator|->
name|visited
argument_list|)
expr_stmt|;
while|while
condition|(
name|VEC_length
argument_list|(
name|int
argument_list|,
name|g
operator|->
name|stack
argument_list|)
operator|>
literal|0
condition|)
block|{
name|x
operator|=
name|VEC_pop
argument_list|(
name|int
argument_list|,
name|g
operator|->
name|stack
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|g
operator|->
name|visited
argument_list|,
name|x
argument_list|)
condition|)
name|elim_create
argument_list|(
name|g
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If there are any pending constant copies, issue them now.  */
while|while
condition|(
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|g
operator|->
name|const_copies
argument_list|)
operator|>
literal|0
condition|)
block|{
name|tree
name|src
decl_stmt|,
name|dest
decl_stmt|;
name|src
operator|=
name|VEC_pop
argument_list|(
name|tree
argument_list|,
name|g
operator|->
name|const_copies
argument_list|)
expr_stmt|;
name|dest
operator|=
name|VEC_pop
argument_list|(
name|tree
argument_list|,
name|g
operator|->
name|const_copies
argument_list|)
expr_stmt|;
name|insert_copy_on_edge
argument_list|(
name|e
argument_list|,
name|dest
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Shortcut routine to print messages to file F of the form:    "STR1 EXPR1 STR2 EXPR2 STR3."  */
end_comment

begin_function
specifier|static
name|void
name|print_exprs
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
specifier|const
name|char
modifier|*
name|str1
parameter_list|,
name|tree
name|expr1
parameter_list|,
specifier|const
name|char
modifier|*
name|str2
parameter_list|,
name|tree
name|expr2
parameter_list|,
specifier|const
name|char
modifier|*
name|str3
parameter_list|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s"
argument_list|,
name|str1
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|f
argument_list|,
name|expr1
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s"
argument_list|,
name|str2
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|f
argument_list|,
name|expr2
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s"
argument_list|,
name|str3
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Shortcut routine to print abnormal edge messages to file F of the form:    "STR1 EXPR1 STR2 EXPR2 across edge E.  */
end_comment

begin_function
specifier|static
name|void
name|print_exprs_edge
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|edge
name|e
parameter_list|,
specifier|const
name|char
modifier|*
name|str1
parameter_list|,
name|tree
name|expr1
parameter_list|,
specifier|const
name|char
modifier|*
name|str2
parameter_list|,
name|tree
name|expr2
parameter_list|)
block|{
name|print_exprs
argument_list|(
name|f
argument_list|,
name|str1
argument_list|,
name|expr1
argument_list|,
name|str2
argument_list|,
name|expr2
argument_list|,
literal|" across an abnormal edge"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" from BB%d->BB%d\n"
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Coalesce partitions in MAP which are live across abnormal edges in GRAPH.    RV is the root variable groupings of the partitions in MAP.  Since code     cannot be inserted on these edges, failure to coalesce something across    an abnormal edge is an error.  */
end_comment

begin_function
specifier|static
name|void
name|coalesce_abnormal_edges
parameter_list|(
name|var_map
name|map
parameter_list|,
name|conflict_graph
name|graph
parameter_list|,
name|root_var_p
name|rv
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|tree
name|phi
decl_stmt|,
name|var
decl_stmt|,
name|tmp
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|z
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
comment|/* Code cannot be inserted on abnormal edges. Look for all abnormal       edges, and coalesce any PHI results with their arguments across       that edge.  */
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
if|if
condition|(
name|e
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
operator|&&
name|e
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
condition|)
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|e
operator|->
name|dest
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
block|{
comment|/* Visit each PHI on the destination side of this abnormal 	       edge, and attempt to coalesce the argument with the result.  */
name|var
operator|=
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
expr_stmt|;
name|x
operator|=
name|var_to_partition
argument_list|(
name|map
argument_list|,
name|var
argument_list|)
expr_stmt|;
comment|/* Ignore results which are not relevant.  */
if|if
condition|(
name|x
operator|==
name|NO_PARTITION
condition|)
continue|continue;
name|tmp
operator|=
name|PHI_ARG_DEF
argument_list|(
name|phi
argument_list|,
name|e
operator|->
name|dest_idx
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
if|if
condition|(
operator|!
name|phi_ssa_name_p
argument_list|(
name|tmp
argument_list|)
condition|)
block|{
name|print_exprs_edge
argument_list|(
name|stderr
argument_list|,
name|e
argument_list|,
literal|"\nConstant argument in PHI. Can't insert :"
argument_list|,
name|var
argument_list|,
literal|" = "
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|internal_error
argument_list|(
literal|"SSA corruption"
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|gcc_assert
argument_list|(
name|phi_ssa_name_p
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|y
operator|=
name|var_to_partition
argument_list|(
name|map
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|x
operator|!=
name|NO_PARTITION
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|y
operator|!=
name|NO_PARTITION
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
if|if
condition|(
name|root_var_find
argument_list|(
name|rv
argument_list|,
name|x
argument_list|)
operator|!=
name|root_var_find
argument_list|(
name|rv
argument_list|,
name|y
argument_list|)
condition|)
block|{
name|print_exprs_edge
argument_list|(
name|stderr
argument_list|,
name|e
argument_list|,
literal|"\nDifferent root vars: "
argument_list|,
name|root_var
argument_list|(
name|rv
argument_list|,
name|root_var_find
argument_list|(
name|rv
argument_list|,
name|x
argument_list|)
argument_list|)
argument_list|,
literal|" and "
argument_list|,
name|root_var
argument_list|(
name|rv
argument_list|,
name|root_var_find
argument_list|(
name|rv
argument_list|,
name|y
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|internal_error
argument_list|(
literal|"SSA corruption"
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|gcc_assert
argument_list|(
name|root_var_find
argument_list|(
name|rv
argument_list|,
name|x
argument_list|)
operator|==
name|root_var_find
argument_list|(
name|rv
argument_list|,
name|y
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|x
operator|!=
name|y
condition|)
block|{
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
if|if
condition|(
name|conflict_graph_conflict_p
argument_list|(
name|graph
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
condition|)
block|{
name|print_exprs_edge
argument_list|(
name|stderr
argument_list|,
name|e
argument_list|,
literal|"\n Conflict "
argument_list|,
name|partition_to_var
argument_list|(
name|map
argument_list|,
name|x
argument_list|)
argument_list|,
literal|" and "
argument_list|,
name|partition_to_var
argument_list|(
name|map
argument_list|,
name|y
argument_list|)
argument_list|)
expr_stmt|;
name|internal_error
argument_list|(
literal|"SSA corruption"
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|gcc_assert
argument_list|(
operator|!
name|conflict_graph_conflict_p
argument_list|(
name|graph
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Now map the partitions back to their real variables.  */
name|var
operator|=
name|partition_to_var
argument_list|(
name|map
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|partition_to_var
argument_list|(
name|map
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|print_exprs_edge
argument_list|(
name|dump_file
argument_list|,
name|e
argument_list|,
literal|"ABNORMAL: Coalescing "
argument_list|,
name|var
argument_list|,
literal|" and "
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
name|z
operator|=
name|var_union
argument_list|(
name|map
argument_list|,
name|var
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
if|if
condition|(
name|z
operator|==
name|NO_PARTITION
condition|)
block|{
name|print_exprs_edge
argument_list|(
name|stderr
argument_list|,
name|e
argument_list|,
literal|"\nUnable to coalesce"
argument_list|,
name|partition_to_var
argument_list|(
name|map
argument_list|,
name|x
argument_list|)
argument_list|,
literal|" and "
argument_list|,
name|partition_to_var
argument_list|(
name|map
argument_list|,
name|y
argument_list|)
argument_list|)
expr_stmt|;
name|internal_error
argument_list|(
literal|"SSA corruption"
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|gcc_assert
argument_list|(
name|z
operator|!=
name|NO_PARTITION
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|gcc_assert
argument_list|(
name|z
operator|==
name|x
operator|||
name|z
operator|==
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|==
name|x
condition|)
name|conflict_graph_merge_regs
argument_list|(
name|graph
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
else|else
name|conflict_graph_merge_regs
argument_list|(
name|graph
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Coalesce potential copies via PHI arguments.  */
end_comment

begin_function
specifier|static
name|void
name|coalesce_phi_operands
parameter_list|(
name|var_map
name|map
parameter_list|,
name|coalesce_list_p
name|cl
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|tree
name|phi
decl_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|bb
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
block|{
name|tree
name|res
init|=
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
decl_stmt|;
name|int
name|p
init|=
name|var_to_partition
argument_list|(
name|map
argument_list|,
name|res
argument_list|)
decl_stmt|;
name|int
name|x
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NO_PARTITION
condition|)
continue|continue;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|PHI_NUM_ARGS
argument_list|(
name|phi
argument_list|)
condition|;
name|x
operator|++
control|)
block|{
name|tree
name|arg
init|=
name|PHI_ARG_DEF
argument_list|(
name|phi
argument_list|,
name|x
argument_list|)
decl_stmt|;
name|int
name|p2
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|SSA_NAME
condition|)
continue|continue;
if|if
condition|(
name|SSA_NAME_VAR
argument_list|(
name|res
argument_list|)
operator|!=
name|SSA_NAME_VAR
argument_list|(
name|arg
argument_list|)
condition|)
continue|continue;
name|p2
operator|=
name|var_to_partition
argument_list|(
name|map
argument_list|,
name|PHI_ARG_DEF
argument_list|(
name|phi
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2
operator|!=
name|NO_PARTITION
condition|)
block|{
name|edge
name|e
init|=
name|PHI_ARG_EDGE
argument_list|(
name|phi
argument_list|,
name|x
argument_list|)
decl_stmt|;
name|add_coalesce
argument_list|(
name|cl
argument_list|,
name|p
argument_list|,
name|p2
argument_list|,
name|coalesce_cost
argument_list|(
name|EDGE_FREQUENCY
argument_list|(
name|e
argument_list|)
argument_list|,
name|maybe_hot_bb_p
argument_list|(
name|bb
argument_list|)
argument_list|,
name|EDGE_CRITICAL_P
argument_list|(
name|e
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Coalesce all the result decls together.  */
end_comment

begin_function
specifier|static
name|void
name|coalesce_result_decls
parameter_list|(
name|var_map
name|map
parameter_list|,
name|coalesce_list_p
name|cl
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|x
decl_stmt|;
name|tree
name|var
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|i
operator|=
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|num_var_partitions
argument_list|(
name|map
argument_list|)
condition|;
name|x
operator|++
control|)
block|{
name|tree
name|p
init|=
name|partition_to_var
argument_list|(
name|map
argument_list|,
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
name|RESULT_DECL
condition|)
block|{
if|if
condition|(
name|var
operator|==
name|NULL_TREE
condition|)
block|{
name|var
operator|=
name|p
expr_stmt|;
name|i
operator|=
name|x
expr_stmt|;
block|}
else|else
name|add_coalesce
argument_list|(
name|cl
argument_list|,
name|i
argument_list|,
name|x
argument_list|,
name|coalesce_cost
argument_list|(
name|EXIT_BLOCK_PTR
operator|->
name|frequency
argument_list|,
name|maybe_hot_bb_p
argument_list|(
name|EXIT_BLOCK_PTR
argument_list|)
argument_list|,
name|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Coalesce matching constraints in asms.  */
end_comment

begin_function
specifier|static
name|void
name|coalesce_asm_operands
parameter_list|(
name|var_map
name|map
parameter_list|,
name|coalesce_list_p
name|cl
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|block_stmt_iterator
name|bsi
decl_stmt|;
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
block|{
name|tree
name|stmt
init|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|noutputs
decl_stmt|,
name|i
decl_stmt|;
name|tree
modifier|*
name|outputs
decl_stmt|,
name|link
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|!=
name|ASM_EXPR
condition|)
continue|continue;
name|noutputs
operator|=
name|list_length
argument_list|(
name|ASM_OUTPUTS
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|outputs
operator|=
operator|(
name|tree
operator|*
operator|)
name|alloca
argument_list|(
name|noutputs
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|link
operator|=
name|ASM_OUTPUTS
argument_list|(
name|stmt
argument_list|)
init|;
name|link
condition|;
operator|++
name|i
operator|,
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
name|outputs
index|[
name|i
index|]
operator|=
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
expr_stmt|;
for|for
control|(
name|link
operator|=
name|ASM_INPUTS
argument_list|(
name|stmt
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|constraint
init|=
name|TREE_STRING_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|input
init|=
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
name|unsigned
name|long
name|match
decl_stmt|;
name|int
name|p1
decl_stmt|,
name|p2
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|input
argument_list|)
operator|!=
name|SSA_NAME
operator|&&
operator|!
name|DECL_P
argument_list|(
name|input
argument_list|)
condition|)
continue|continue;
name|match
operator|=
name|strtoul
argument_list|(
name|constraint
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|match
operator|>=
name|noutputs
operator|||
name|end
operator|==
name|constraint
condition|)
continue|continue;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|outputs
index|[
name|match
index|]
argument_list|)
operator|!=
name|SSA_NAME
operator|&&
operator|!
name|DECL_P
argument_list|(
name|outputs
index|[
name|match
index|]
argument_list|)
condition|)
continue|continue;
name|p1
operator|=
name|var_to_partition
argument_list|(
name|map
argument_list|,
name|outputs
index|[
name|match
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|==
name|NO_PARTITION
condition|)
continue|continue;
name|p2
operator|=
name|var_to_partition
argument_list|(
name|map
argument_list|,
name|input
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2
operator|==
name|NO_PARTITION
condition|)
continue|continue;
name|add_coalesce
argument_list|(
name|cl
argument_list|,
name|p1
argument_list|,
name|p2
argument_list|,
name|coalesce_cost
argument_list|(
name|REG_BR_PROB_BASE
argument_list|,
name|maybe_hot_bb_p
argument_list|(
name|bb
argument_list|)
argument_list|,
name|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Reduce the number of live ranges in MAP.  Live range information is     returned if FLAGS indicates that we are combining temporaries, otherwise     NULL is returned.  The only partitions which are associated with actual     variables at this point are those which are forced to be coalesced for     various reason. (live on entry, live across abnormal edges, etc.).  */
end_comment

begin_function
specifier|static
name|tree_live_info_p
name|coalesce_ssa_name
parameter_list|(
name|var_map
name|map
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|unsigned
name|num
decl_stmt|,
name|x
decl_stmt|;
name|sbitmap
name|live
decl_stmt|;
name|root_var_p
name|rv
decl_stmt|;
name|tree_live_info_p
name|liveinfo
decl_stmt|;
name|conflict_graph
name|graph
decl_stmt|;
name|coalesce_list_p
name|cl
init|=
name|NULL
decl_stmt|;
name|sbitmap_iterator
name|sbi
decl_stmt|;
if|if
condition|(
name|num_var_partitions
argument_list|(
name|map
argument_list|)
operator|<=
literal|1
condition|)
return|return
name|NULL
return|;
name|liveinfo
operator|=
name|calculate_live_on_entry
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|calculate_live_on_exit
argument_list|(
name|liveinfo
argument_list|)
expr_stmt|;
name|rv
operator|=
name|root_var_init
argument_list|(
name|map
argument_list|)
expr_stmt|;
comment|/* Remove single element variable from the list.  */
name|root_var_compact
argument_list|(
name|rv
argument_list|)
expr_stmt|;
name|cl
operator|=
name|create_coalesce_list
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|coalesce_phi_operands
argument_list|(
name|map
argument_list|,
name|cl
argument_list|)
expr_stmt|;
name|coalesce_result_decls
argument_list|(
name|map
argument_list|,
name|cl
argument_list|)
expr_stmt|;
name|coalesce_asm_operands
argument_list|(
name|map
argument_list|,
name|cl
argument_list|)
expr_stmt|;
comment|/* Build a conflict graph.  */
name|graph
operator|=
name|build_tree_conflict_graph
argument_list|(
name|liveinfo
argument_list|,
name|rv
argument_list|,
name|cl
argument_list|)
expr_stmt|;
if|if
condition|(
name|cl
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Before sorting:\n"
argument_list|)
expr_stmt|;
name|dump_coalesce_list
argument_list|(
name|dump_file
argument_list|,
name|cl
argument_list|)
expr_stmt|;
block|}
name|sort_coalesce_list
argument_list|(
name|cl
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nAfter sorting:\n"
argument_list|)
expr_stmt|;
name|dump_coalesce_list
argument_list|(
name|dump_file
argument_list|,
name|cl
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Put the single element variables back in.  */
name|root_var_decompact
argument_list|(
name|rv
argument_list|)
expr_stmt|;
comment|/* First, coalesce all live on entry variables to their root variable.       This will ensure the first use is coming from the correct location.  */
name|num
operator|=
name|num_var_partitions
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|live
operator|=
name|sbitmap_alloc
argument_list|(
name|num
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|live
argument_list|)
expr_stmt|;
comment|/* Set 'live' vector to indicate live on entry partitions.  */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|num
condition|;
name|x
operator|++
control|)
block|{
name|tree
name|var
init|=
name|partition_to_var
argument_list|(
name|map
argument_list|,
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|default_def
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|var
argument_list|)
argument_list|)
operator|==
name|var
condition|)
name|SET_BIT
argument_list|(
name|live
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|SSANORM_COMBINE_TEMPS
operator|)
operator|==
literal|0
condition|)
block|{
name|delete_tree_live_info
argument_list|(
name|liveinfo
argument_list|)
expr_stmt|;
name|liveinfo
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Assign root variable as partition representative for each live on entry      partition.  */
name|EXECUTE_IF_SET_IN_SBITMAP
argument_list|(
argument|live
argument_list|,
literal|0
argument_list|,
argument|x
argument_list|,
argument|sbi
argument_list|)
block|{
name|tree
name|var
init|=
name|root_var
argument_list|(
name|rv
argument_list|,
name|root_var_find
argument_list|(
name|rv
argument_list|,
name|x
argument_list|)
argument_list|)
decl_stmt|;
name|var_ann_t
name|ann
init|=
name|var_ann
argument_list|(
name|var
argument_list|)
decl_stmt|;
comment|/* If these aren't already coalesced...  */
if|if
condition|(
name|partition_to_var
argument_list|(
name|map
argument_list|,
name|x
argument_list|)
operator|!=
name|var
condition|)
block|{
comment|/* This root variable should have not already been assigned 	     to another partition which is not coalesced with this one.  */
name|gcc_assert
argument_list|(
operator|!
name|ann
operator|->
name|out_of_ssa_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|print_exprs
argument_list|(
name|dump_file
argument_list|,
literal|"Must coalesce "
argument_list|,
name|partition_to_var
argument_list|(
name|map
argument_list|,
name|x
argument_list|)
argument_list|,
literal|" with the root variable "
argument_list|,
name|var
argument_list|,
literal|".\n"
argument_list|)
expr_stmt|;
block|}
name|change_partition_var
argument_list|(
name|map
argument_list|,
name|var
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
block|}
name|sbitmap_free
argument_list|(
name|live
argument_list|)
expr_stmt|;
comment|/* Coalesce partitions live across abnormal edges.  */
name|coalesce_abnormal_edges
argument_list|(
name|map
argument_list|,
name|graph
argument_list|,
name|rv
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|dump_var_map
argument_list|(
name|dump_file
argument_list|,
name|map
argument_list|)
expr_stmt|;
comment|/* Coalesce partitions.  */
name|coalesce_tpa_members
argument_list|(
name|rv
argument_list|,
name|graph
argument_list|,
name|map
argument_list|,
name|cl
argument_list|,
operator|(
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|?
name|dump_file
else|:
name|NULL
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SSANORM_COALESCE_PARTITIONS
condition|)
name|coalesce_tpa_members
argument_list|(
name|rv
argument_list|,
name|graph
argument_list|,
name|map
argument_list|,
name|NULL
argument_list|,
operator|(
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|?
name|dump_file
else|:
name|NULL
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cl
condition|)
name|delete_coalesce_list
argument_list|(
name|cl
argument_list|)
expr_stmt|;
name|root_var_delete
argument_list|(
name|rv
argument_list|)
expr_stmt|;
name|conflict_graph_delete
argument_list|(
name|graph
argument_list|)
expr_stmt|;
return|return
name|liveinfo
return|;
block|}
end_function

begin_comment
comment|/* Take the ssa-name var_map MAP, and assign real variables to each     partition.  */
end_comment

begin_function
specifier|static
name|void
name|assign_vars
parameter_list|(
name|var_map
name|map
parameter_list|)
block|{
name|int
name|x
decl_stmt|,
name|i
decl_stmt|,
name|num
decl_stmt|,
name|rep
decl_stmt|;
name|tree
name|t
decl_stmt|,
name|var
decl_stmt|;
name|var_ann_t
name|ann
decl_stmt|;
name|root_var_p
name|rv
decl_stmt|;
name|rv
operator|=
name|root_var_init
argument_list|(
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rv
condition|)
return|return;
comment|/* Coalescing may already have forced some partitions to their root       variable. Find these and tag them.  */
name|num
operator|=
name|num_var_partitions
argument_list|(
name|map
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|num
condition|;
name|x
operator|++
control|)
block|{
name|var
operator|=
name|partition_to_var
argument_list|(
name|map
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|!=
name|SSA_NAME
condition|)
block|{
comment|/* Coalescing will already have verified that more than one 	     partition doesn't have the same root variable. Simply marked 	     the variable as assigned.  */
name|ann
operator|=
name|var_ann
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|ann
operator|->
name|out_of_ssa_tag
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"partition %d has variable "
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|var
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" assigned to it.\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|num
operator|=
name|root_var_num
argument_list|(
name|rv
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|num
condition|;
name|x
operator|++
control|)
block|{
name|var
operator|=
name|root_var
argument_list|(
name|rv
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|ann
operator|=
name|var_ann
argument_list|(
name|var
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|root_var_first_partition
argument_list|(
name|rv
argument_list|,
name|x
argument_list|)
init|;
name|i
operator|!=
name|ROOT_VAR_NONE
condition|;
name|i
operator|=
name|root_var_next_partition
argument_list|(
name|rv
argument_list|,
name|i
argument_list|)
control|)
block|{
name|t
operator|=
name|partition_to_var
argument_list|(
name|map
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|var
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|SSA_NAME
condition|)
continue|continue;
name|rep
operator|=
name|var_to_partition
argument_list|(
name|map
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ann
operator|->
name|out_of_ssa_tag
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|print_exprs
argument_list|(
name|dump_file
argument_list|,
literal|""
argument_list|,
name|t
argument_list|,
literal|"  --> "
argument_list|,
name|var
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|change_partition_var
argument_list|(
name|map
argument_list|,
name|var
argument_list|,
name|rep
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|print_exprs
argument_list|(
name|dump_file
argument_list|,
literal|""
argument_list|,
name|t
argument_list|,
literal|" not coalesced with "
argument_list|,
name|var
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|var
operator|=
name|create_temp
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|change_partition_var
argument_list|(
name|map
argument_list|,
name|var
argument_list|,
name|rep
argument_list|)
expr_stmt|;
name|ann
operator|=
name|var_ann
argument_list|(
name|var
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" -->  New temp:  '"
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|var
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"'\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|root_var_delete
argument_list|(
name|rv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Replace use operand P with whatever variable it has been rewritten to based     on the partitions in MAP.  EXPR is an optional expression vector over SSA     versions which is used to replace P with an expression instead of a variable.    If the stmt is changed, return true.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|replace_use_variable
parameter_list|(
name|var_map
name|map
parameter_list|,
name|use_operand_p
name|p
parameter_list|,
name|tree
modifier|*
name|expr
parameter_list|)
block|{
name|tree
name|new_var
decl_stmt|;
name|tree
name|var
init|=
name|USE_FROM_PTR
argument_list|(
name|p
argument_list|)
decl_stmt|;
comment|/* Check if we are replacing this variable with an expression.  */
if|if
condition|(
name|expr
condition|)
block|{
name|int
name|version
init|=
name|SSA_NAME_VERSION
argument_list|(
name|var
argument_list|)
decl_stmt|;
if|if
condition|(
name|expr
index|[
name|version
index|]
condition|)
block|{
name|tree
name|new_expr
init|=
name|TREE_OPERAND
argument_list|(
name|expr
index|[
name|version
index|]
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|SET_USE
argument_list|(
name|p
argument_list|,
name|new_expr
argument_list|)
expr_stmt|;
comment|/* Clear the stmt's RHS, or GC might bite us.  */
name|TREE_OPERAND
argument_list|(
name|expr
index|[
name|version
index|]
argument_list|,
literal|1
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
name|new_var
operator|=
name|var_to_partition_to_var
argument_list|(
name|map
argument_list|,
name|var
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_var
condition|)
block|{
name|SET_USE
argument_list|(
name|p
argument_list|,
name|new_var
argument_list|)
expr_stmt|;
name|set_is_used
argument_list|(
name|new_var
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Replace def operand DEF_P with whatever variable it has been rewritten to     based on the partitions in MAP.  EXPR is an optional expression vector over    SSA versions which is used to replace DEF_P with an expression instead of a     variable.  If the stmt is changed, return true.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|replace_def_variable
parameter_list|(
name|var_map
name|map
parameter_list|,
name|def_operand_p
name|def_p
parameter_list|,
name|tree
modifier|*
name|expr
parameter_list|)
block|{
name|tree
name|new_var
decl_stmt|;
name|tree
name|var
init|=
name|DEF_FROM_PTR
argument_list|(
name|def_p
argument_list|)
decl_stmt|;
comment|/* Check if we are replacing this variable with an expression.  */
if|if
condition|(
name|expr
condition|)
block|{
name|int
name|version
init|=
name|SSA_NAME_VERSION
argument_list|(
name|var
argument_list|)
decl_stmt|;
if|if
condition|(
name|expr
index|[
name|version
index|]
condition|)
block|{
name|tree
name|new_expr
init|=
name|TREE_OPERAND
argument_list|(
name|expr
index|[
name|version
index|]
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|SET_DEF
argument_list|(
name|def_p
argument_list|,
name|new_expr
argument_list|)
expr_stmt|;
comment|/* Clear the stmt's RHS, or GC might bite us.  */
name|TREE_OPERAND
argument_list|(
name|expr
index|[
name|version
index|]
argument_list|,
literal|1
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
name|new_var
operator|=
name|var_to_partition_to_var
argument_list|(
name|map
argument_list|,
name|var
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_var
condition|)
block|{
name|SET_DEF
argument_list|(
name|def_p
argument_list|,
name|new_var
argument_list|)
expr_stmt|;
name|set_is_used
argument_list|(
name|new_var
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Remove any PHI node which is a virtual PHI.  */
end_comment

begin_function
specifier|static
name|void
name|eliminate_virtual_phis
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|tree
name|phi
decl_stmt|,
name|next
decl_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|bb
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|next
control|)
block|{
name|next
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_gimple_reg
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|int
name|i
decl_stmt|;
comment|/* There should be no arguments of this PHI which are in 		 the partition list, or we get incorrect results.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PHI_NUM_ARGS
argument_list|(
name|phi
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|arg
init|=
name|PHI_ARG_DEF
argument_list|(
name|phi
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|SSA_NAME
operator|&&
name|is_gimple_reg
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|arg
argument_list|)
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Argument of PHI is not virtual ("
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|stderr
argument_list|,
name|arg
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"), but the result is :"
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|stderr
argument_list|,
name|phi
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|internal_error
argument_list|(
literal|"SSA corruption"
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|remove_phi_node
argument_list|(
name|phi
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* This routine will coalesce variables in MAP of the same type which do not     interfere with each other. LIVEINFO is the live range info for variables    of interest.  This will both reduce the memory footprint of the stack, and     allow us to coalesce together local copies of globals and scalarized     component refs.  */
end_comment

begin_function
specifier|static
name|void
name|coalesce_vars
parameter_list|(
name|var_map
name|map
parameter_list|,
name|tree_live_info_p
name|liveinfo
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|type_var_p
name|tv
decl_stmt|;
name|tree
name|var
decl_stmt|;
name|unsigned
name|x
decl_stmt|,
name|p
decl_stmt|,
name|p2
decl_stmt|;
name|coalesce_list_p
name|cl
decl_stmt|;
name|conflict_graph
name|graph
decl_stmt|;
name|cl
operator|=
name|create_coalesce_list
argument_list|(
name|map
argument_list|)
expr_stmt|;
comment|/* Merge all the live on entry vectors for coalesced partitions.  */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|num_var_partitions
argument_list|(
name|map
argument_list|)
condition|;
name|x
operator|++
control|)
block|{
name|var
operator|=
name|partition_to_var
argument_list|(
name|map
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|p
operator|=
name|var_to_partition
argument_list|(
name|map
argument_list|,
name|var
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|x
condition|)
name|live_merge_and_clear
argument_list|(
name|liveinfo
argument_list|,
name|p
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
comment|/* When PHI nodes are turned into copies, the result of each PHI node      becomes live on entry to the block. Mark these now.  */
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|tree
name|phi
decl_stmt|,
name|arg
decl_stmt|;
name|unsigned
name|p
decl_stmt|;
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|bb
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
block|{
name|p
operator|=
name|var_to_partition
argument_list|(
name|map
argument_list|,
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Skip virtual PHI nodes.  */
if|if
condition|(
name|p
operator|==
operator|(
name|unsigned
operator|)
name|NO_PARTITION
condition|)
continue|continue;
name|make_live_on_entry
argument_list|(
name|liveinfo
argument_list|,
name|bb
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* Each argument is a potential copy operation. Add any arguments  	     which are not coalesced to the result to the coalesce list.  */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
operator|(
name|unsigned
operator|)
name|PHI_NUM_ARGS
argument_list|(
name|phi
argument_list|)
condition|;
name|x
operator|++
control|)
block|{
name|arg
operator|=
name|PHI_ARG_DEF
argument_list|(
name|phi
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|phi_ssa_name_p
argument_list|(
name|arg
argument_list|)
condition|)
continue|continue;
name|p2
operator|=
name|var_to_partition
argument_list|(
name|map
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2
operator|==
operator|(
name|unsigned
operator|)
name|NO_PARTITION
condition|)
continue|continue;
if|if
condition|(
name|p
operator|!=
name|p2
condition|)
block|{
name|edge
name|e
init|=
name|PHI_ARG_EDGE
argument_list|(
name|phi
argument_list|,
name|x
argument_list|)
decl_stmt|;
name|add_coalesce
argument_list|(
name|cl
argument_list|,
name|p
argument_list|,
name|p2
argument_list|,
name|coalesce_cost
argument_list|(
name|EDGE_FREQUENCY
argument_list|(
name|e
argument_list|)
argument_list|,
name|maybe_hot_bb_p
argument_list|(
name|bb
argument_list|)
argument_list|,
name|EDGE_CRITICAL_P
argument_list|(
name|e
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Re-calculate live on exit info.  */
name|calculate_live_on_exit
argument_list|(
name|liveinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Live range info for variable memory coalescing.\n"
argument_list|)
expr_stmt|;
name|dump_live_info
argument_list|(
name|dump_file
argument_list|,
name|liveinfo
argument_list|,
name|LIVEDUMP_ALL
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Coalesce list from phi nodes:\n"
argument_list|)
expr_stmt|;
name|dump_coalesce_list
argument_list|(
name|dump_file
argument_list|,
name|cl
argument_list|)
expr_stmt|;
block|}
name|tv
operator|=
name|type_var_init
argument_list|(
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|type_var_dump
argument_list|(
name|dump_file
argument_list|,
name|tv
argument_list|)
expr_stmt|;
name|type_var_compact
argument_list|(
name|tv
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|type_var_dump
argument_list|(
name|dump_file
argument_list|,
name|tv
argument_list|)
expr_stmt|;
name|graph
operator|=
name|build_tree_conflict_graph
argument_list|(
name|liveinfo
argument_list|,
name|tv
argument_list|,
name|cl
argument_list|)
expr_stmt|;
name|type_var_decompact
argument_list|(
name|tv
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"type var list now looks like:n"
argument_list|)
expr_stmt|;
name|type_var_dump
argument_list|(
name|dump_file
argument_list|,
name|tv
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Coalesce list after conflict graph build:\n"
argument_list|)
expr_stmt|;
name|dump_coalesce_list
argument_list|(
name|dump_file
argument_list|,
name|cl
argument_list|)
expr_stmt|;
block|}
name|sort_coalesce_list
argument_list|(
name|cl
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Coalesce list after sorting:\n"
argument_list|)
expr_stmt|;
name|dump_coalesce_list
argument_list|(
name|dump_file
argument_list|,
name|cl
argument_list|)
expr_stmt|;
block|}
name|coalesce_tpa_members
argument_list|(
name|tv
argument_list|,
name|graph
argument_list|,
name|map
argument_list|,
name|cl
argument_list|,
operator|(
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|?
name|dump_file
else|:
name|NULL
operator|)
argument_list|)
expr_stmt|;
name|type_var_delete
argument_list|(
name|tv
argument_list|)
expr_stmt|;
name|delete_coalesce_list
argument_list|(
name|cl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Temporary Expression Replacement (TER)     Replace SSA version variables during out-of-ssa with their defining    expression if there is only one use of the variable.     A pass is made through the function, one block at a time.  No cross block    information is tracked.     Variables which only have one use, and whose defining stmt is considered    a replaceable expression (see check_replaceable) are entered into     consideration by adding a list of dependent partitions to the version_info    vector for that ssa_name_version.  This information comes from the partition    mapping for each USE.  At the same time, the partition_dep_list vector for     these partitions have this version number entered into their lists.     When the use of a replaceable ssa_variable is encountered, the dependence    list in version_info[] is moved to the "pending_dependence" list in case    the current expression is also replaceable. (To be determined later in     processing this stmt.) version_info[] for the version is then updated to     point to the defining stmt and the 'replaceable' bit is set.     Any partition which is defined by a statement 'kills' any expression which    is dependent on this partition.  Every ssa version in the partitions'     dependence list is removed from future consideration.     All virtual references are lumped together.  Any expression which is    dependent on any virtual variable (via a VUSE) has a dependence added    to the special partition defined by VIRTUAL_PARTITION.     Whenever a V_MAY_DEF is seen, all expressions dependent this     VIRTUAL_PARTITION are removed from consideration.     At the end of a basic block, all expression are removed from consideration    in preparation for the next block.          The end result is a vector over SSA_NAME_VERSION which is passed back to    rewrite_out_of_ssa.  As the SSA variables are being rewritten, instead of    replacing the SSA_NAME tree element with the partition it was assigned,     it is replaced with the RHS of the defining expression.  */
end_comment

begin_comment
comment|/* Dependency list element.  This can contain either a partition index or a    version number, depending on which list it is in.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|value_expr_d
block|{
name|int
name|value
decl_stmt|;
name|struct
name|value_expr_d
modifier|*
name|next
decl_stmt|;
block|}
typedef|*
name|value_expr_p
typedef|;
end_typedef

begin_comment
comment|/* Temporary Expression Replacement (TER) table information.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|temp_expr_table_d
block|{
name|var_map
name|map
decl_stmt|;
name|void
modifier|*
modifier|*
name|version_info
decl_stmt|;
name|bitmap
modifier|*
name|expr_vars
decl_stmt|;
name|value_expr_p
modifier|*
name|partition_dep_list
decl_stmt|;
name|bitmap
name|replaceable
decl_stmt|;
name|bool
name|saw_replaceable
decl_stmt|;
name|int
name|virtual_partition
decl_stmt|;
name|bitmap
name|partition_in_use
decl_stmt|;
name|value_expr_p
name|free_list
decl_stmt|;
name|value_expr_p
name|pending_dependence
decl_stmt|;
block|}
typedef|*
name|temp_expr_table_p
typedef|;
end_typedef

begin_comment
comment|/* Used to indicate a dependency on V_MAY_DEFs.  */
end_comment

begin_define
define|#
directive|define
name|VIRTUAL_PARTITION
parameter_list|(
name|table
parameter_list|)
value|(table->virtual_partition)
end_define

begin_function_decl
specifier|static
name|temp_expr_table_p
name|new_temp_expr_table
parameter_list|(
name|var_map
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
modifier|*
name|free_temp_expr_table
parameter_list|(
name|temp_expr_table_p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|value_expr_p
name|new_value_expr
parameter_list|(
name|temp_expr_table_p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|free_value_expr
parameter_list|(
name|temp_expr_table_p
parameter_list|,
name|value_expr_p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|value_expr_p
name|find_value_in_list
parameter_list|(
name|value_expr_p
parameter_list|,
name|int
parameter_list|,
name|value_expr_p
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|add_value_to_list
parameter_list|(
name|temp_expr_table_p
parameter_list|,
name|value_expr_p
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|add_info_to_list
parameter_list|(
name|temp_expr_table_p
parameter_list|,
name|value_expr_p
modifier|*
parameter_list|,
name|value_expr_p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|value_expr_p
name|remove_value_from_list
parameter_list|(
name|value_expr_p
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_dependence
parameter_list|(
name|temp_expr_table_p
parameter_list|,
name|int
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|check_replaceable
parameter_list|(
name|temp_expr_table_p
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|finish_expr
parameter_list|(
name|temp_expr_table_p
parameter_list|,
name|int
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mark_replaceable
parameter_list|(
name|temp_expr_table_p
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|kill_expr
parameter_list|(
name|temp_expr_table_p
parameter_list|,
name|int
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|kill_virtual_exprs
parameter_list|(
name|temp_expr_table_p
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|find_replaceable_in_bb
parameter_list|(
name|temp_expr_table_p
parameter_list|,
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
modifier|*
name|find_replaceable_exprs
parameter_list|(
name|var_map
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_replaceable_exprs
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Create a new TER table for MAP.  */
end_comment

begin_function
specifier|static
name|temp_expr_table_p
name|new_temp_expr_table
parameter_list|(
name|var_map
name|map
parameter_list|)
block|{
name|temp_expr_table_p
name|t
decl_stmt|;
name|t
operator|=
name|XNEW
argument_list|(
expr|struct
name|temp_expr_table_d
argument_list|)
expr_stmt|;
name|t
operator|->
name|map
operator|=
name|map
expr_stmt|;
name|t
operator|->
name|version_info
operator|=
name|XCNEWVEC
argument_list|(
name|void
operator|*
argument_list|,
name|num_ssa_names
operator|+
literal|1
argument_list|)
expr_stmt|;
name|t
operator|->
name|expr_vars
operator|=
name|XCNEWVEC
argument_list|(
name|bitmap
argument_list|,
name|num_ssa_names
operator|+
literal|1
argument_list|)
expr_stmt|;
name|t
operator|->
name|partition_dep_list
operator|=
name|XCNEWVEC
argument_list|(
name|value_expr_p
argument_list|,
name|num_var_partitions
argument_list|(
name|map
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|t
operator|->
name|replaceable
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|t
operator|->
name|partition_in_use
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|t
operator|->
name|saw_replaceable
operator|=
name|false
expr_stmt|;
name|t
operator|->
name|virtual_partition
operator|=
name|num_var_partitions
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|t
operator|->
name|free_list
operator|=
name|NULL
expr_stmt|;
name|t
operator|->
name|pending_dependence
operator|=
name|NULL
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Free TER table T.  If there are valid replacements, return the expression     vector.  */
end_comment

begin_function
specifier|static
name|tree
modifier|*
name|free_temp_expr_table
parameter_list|(
name|temp_expr_table_p
name|t
parameter_list|)
block|{
name|value_expr_p
name|p
decl_stmt|;
name|tree
modifier|*
name|ret
init|=
name|NULL
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|unsigned
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<=
name|num_var_partitions
argument_list|(
name|t
operator|->
name|map
argument_list|)
condition|;
name|x
operator|++
control|)
name|gcc_assert
argument_list|(
operator|!
name|t
operator|->
name|partition_dep_list
index|[
name|x
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|(
name|p
operator|=
name|t
operator|->
name|free_list
operator|)
condition|)
block|{
name|t
operator|->
name|free_list
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|BITMAP_FREE
argument_list|(
name|t
operator|->
name|partition_in_use
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|t
operator|->
name|replaceable
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|num_ssa_names
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|t
operator|->
name|expr_vars
index|[
name|i
index|]
condition|)
name|BITMAP_FREE
argument_list|(
name|t
operator|->
name|expr_vars
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|t
operator|->
name|expr_vars
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|t
operator|->
name|partition_dep_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|saw_replaceable
condition|)
name|ret
operator|=
operator|(
name|tree
operator|*
operator|)
name|t
operator|->
name|version_info
expr_stmt|;
else|else
name|free
argument_list|(
name|t
operator|->
name|version_info
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Allocate a new value list node. Take it from the free list in TABLE if     possible.  */
end_comment

begin_function
specifier|static
specifier|inline
name|value_expr_p
name|new_value_expr
parameter_list|(
name|temp_expr_table_p
name|table
parameter_list|)
block|{
name|value_expr_p
name|p
decl_stmt|;
if|if
condition|(
name|table
operator|->
name|free_list
condition|)
block|{
name|p
operator|=
name|table
operator|->
name|free_list
expr_stmt|;
name|table
operator|->
name|free_list
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
else|else
name|p
operator|=
operator|(
name|value_expr_p
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|value_expr_d
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Add value list node P to the free list in TABLE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|free_value_expr
parameter_list|(
name|temp_expr_table_p
name|table
parameter_list|,
name|value_expr_p
name|p
parameter_list|)
block|{
name|p
operator|->
name|next
operator|=
name|table
operator|->
name|free_list
expr_stmt|;
name|table
operator|->
name|free_list
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find VALUE if it's in LIST.  Return a pointer to the list object if found,      else return NULL.  If LAST_PTR is provided, it will point to the previous     item upon return, or NULL if this is the first item in the list.  */
end_comment

begin_function
specifier|static
specifier|inline
name|value_expr_p
name|find_value_in_list
parameter_list|(
name|value_expr_p
name|list
parameter_list|,
name|int
name|value
parameter_list|,
name|value_expr_p
modifier|*
name|last_ptr
parameter_list|)
block|{
name|value_expr_p
name|curr
decl_stmt|;
name|value_expr_p
name|last
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|curr
operator|=
name|list
init|;
name|curr
condition|;
name|last
operator|=
name|curr
operator|,
name|curr
operator|=
name|curr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|curr
operator|->
name|value
operator|==
name|value
condition|)
break|break;
block|}
if|if
condition|(
name|last_ptr
condition|)
operator|*
name|last_ptr
operator|=
name|last
expr_stmt|;
return|return
name|curr
return|;
block|}
end_function

begin_comment
comment|/* Add VALUE to LIST, if it isn't already present.  TAB is the expression     table */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_value_to_list
parameter_list|(
name|temp_expr_table_p
name|tab
parameter_list|,
name|value_expr_p
modifier|*
name|list
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|value_expr_p
name|info
decl_stmt|;
if|if
condition|(
operator|!
name|find_value_in_list
argument_list|(
operator|*
name|list
argument_list|,
name|value
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|info
operator|=
name|new_value_expr
argument_list|(
name|tab
argument_list|)
expr_stmt|;
name|info
operator|->
name|value
operator|=
name|value
expr_stmt|;
name|info
operator|->
name|next
operator|=
operator|*
name|list
expr_stmt|;
operator|*
name|list
operator|=
name|info
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Add value node INFO if it's value isn't already in LIST.  Free INFO if    it is already in the list. TAB is the expression table.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_info_to_list
parameter_list|(
name|temp_expr_table_p
name|tab
parameter_list|,
name|value_expr_p
modifier|*
name|list
parameter_list|,
name|value_expr_p
name|info
parameter_list|)
block|{
if|if
condition|(
name|find_value_in_list
argument_list|(
operator|*
name|list
argument_list|,
name|info
operator|->
name|value
argument_list|,
name|NULL
argument_list|)
condition|)
name|free_value_expr
argument_list|(
name|tab
argument_list|,
name|info
argument_list|)
expr_stmt|;
else|else
block|{
name|info
operator|->
name|next
operator|=
operator|*
name|list
expr_stmt|;
operator|*
name|list
operator|=
name|info
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Look for VALUE in LIST.  If found, remove it from the list and return it's     pointer.  */
end_comment

begin_function
specifier|static
name|value_expr_p
name|remove_value_from_list
parameter_list|(
name|value_expr_p
modifier|*
name|list
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|value_expr_p
name|info
decl_stmt|,
name|last
decl_stmt|;
name|info
operator|=
name|find_value_in_list
argument_list|(
operator|*
name|list
argument_list|,
name|value
argument_list|,
operator|&
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|last
condition|)
operator|*
name|list
operator|=
name|info
operator|->
name|next
expr_stmt|;
else|else
name|last
operator|->
name|next
operator|=
name|info
operator|->
name|next
expr_stmt|;
return|return
name|info
return|;
block|}
end_function

begin_comment
comment|/* Add a dependency between the def of ssa VERSION and VAR.  If VAR is     replaceable by an expression, add a dependence each of the elements of the     expression.  These are contained in the pending list.  TAB is the    expression table.  */
end_comment

begin_function
specifier|static
name|void
name|add_dependence
parameter_list|(
name|temp_expr_table_p
name|tab
parameter_list|,
name|int
name|version
parameter_list|,
name|tree
name|var
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|x
decl_stmt|;
name|value_expr_p
name|info
decl_stmt|;
name|i
operator|=
name|SSA_NAME_VERSION
argument_list|(
name|var
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitmap_bit_p
argument_list|(
name|tab
operator|->
name|replaceable
argument_list|,
name|i
argument_list|)
condition|)
block|{
comment|/* This variable is being substituted, so use whatever dependences          were queued up when we marked this as replaceable earlier.  */
while|while
condition|(
operator|(
name|info
operator|=
name|tab
operator|->
name|pending_dependence
operator|)
condition|)
block|{
name|tab
operator|->
name|pending_dependence
operator|=
name|info
operator|->
name|next
expr_stmt|;
comment|/* Get the partition this variable was dependent on. Reuse this 	     object to represent the current  expression instead.  */
name|x
operator|=
name|info
operator|->
name|value
expr_stmt|;
name|info
operator|->
name|value
operator|=
name|version
expr_stmt|;
name|add_info_to_list
argument_list|(
name|tab
argument_list|,
operator|&
operator|(
name|tab
operator|->
name|partition_dep_list
index|[
name|x
index|]
operator|)
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|add_value_to_list
argument_list|(
name|tab
argument_list|,
operator|(
name|value_expr_p
operator|*
operator|)
operator|&
operator|(
name|tab
operator|->
name|version_info
index|[
name|version
index|]
operator|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|tab
operator|->
name|partition_in_use
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|i
operator|=
name|var_to_partition
argument_list|(
name|tab
operator|->
name|map
argument_list|,
name|var
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|i
operator|!=
name|NO_PARTITION
argument_list|)
expr_stmt|;
name|add_value_to_list
argument_list|(
name|tab
argument_list|,
operator|&
operator|(
name|tab
operator|->
name|partition_dep_list
index|[
name|i
index|]
operator|)
argument_list|,
name|version
argument_list|)
expr_stmt|;
name|add_value_to_list
argument_list|(
name|tab
argument_list|,
operator|(
name|value_expr_p
operator|*
operator|)
operator|&
operator|(
name|tab
operator|->
name|version_info
index|[
name|version
index|]
operator|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|tab
operator|->
name|partition_in_use
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Check if expression STMT is suitable for replacement in table TAB.  If so,     create an expression entry.  Return true if this stmt is replaceable.  */
end_comment

begin_function
specifier|static
name|bool
name|check_replaceable
parameter_list|(
name|temp_expr_table_p
name|tab
parameter_list|,
name|tree
name|stmt
parameter_list|)
block|{
name|tree
name|var
decl_stmt|,
name|def
decl_stmt|,
name|basevar
decl_stmt|;
name|int
name|version
decl_stmt|;
name|var_map
name|map
init|=
name|tab
operator|->
name|map
decl_stmt|;
name|ssa_op_iter
name|iter
decl_stmt|;
name|tree
name|call_expr
decl_stmt|;
name|bitmap
name|def_vars
decl_stmt|,
name|use_vars
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|!=
name|MODIFY_EXPR
condition|)
return|return
name|false
return|;
comment|/* Punt if there is more than 1 def, or more than 1 use.  */
name|def
operator|=
name|SINGLE_SSA_TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
name|SSA_OP_DEF
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|def
condition|)
return|return
name|false
return|;
if|if
condition|(
name|version_ref_count
argument_list|(
name|map
argument_list|,
name|def
argument_list|)
operator|!=
literal|1
condition|)
return|return
name|false
return|;
comment|/* There must be no V_MAY_DEFS or V_MUST_DEFS.  */
if|if
condition|(
operator|!
operator|(
name|ZERO_SSA_OPERANDS
argument_list|(
name|stmt
argument_list|,
operator|(
name|SSA_OP_VMAYDEF
operator||
name|SSA_OP_VMUSTDEF
operator|)
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
comment|/* Float expressions must go through memory if float-store is on.  */
if|if
condition|(
name|flag_float_store
operator|&&
name|FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* An assignment with a register variable on the RHS is not      replaceable.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_HARD_REGISTER
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Calls to functions with side-effects cannot be replaced.  */
if|if
condition|(
operator|(
name|call_expr
operator|=
name|get_call_expr_in
argument_list|(
name|stmt
argument_list|)
operator|)
operator|!=
name|NULL_TREE
condition|)
block|{
name|int
name|call_flags
init|=
name|call_expr_flags
argument_list|(
name|call_expr
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|call_expr
argument_list|)
operator|&&
operator|!
operator|(
name|call_flags
operator|&
operator|(
name|ECF_PURE
operator||
name|ECF_CONST
operator||
name|ECF_NORETURN
operator|)
operator|)
condition|)
return|return
name|false
return|;
block|}
name|version
operator|=
name|SSA_NAME_VERSION
argument_list|(
name|def
argument_list|)
expr_stmt|;
name|basevar
operator|=
name|SSA_NAME_VAR
argument_list|(
name|def
argument_list|)
expr_stmt|;
name|def_vars
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|def_vars
argument_list|,
name|DECL_UID
argument_list|(
name|basevar
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Add this expression to the dependency list for each use partition.  */
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|var
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_USE
argument_list|)
block|{
name|add_dependence
argument_list|(
name|tab
argument_list|,
name|version
argument_list|,
name|var
argument_list|)
expr_stmt|;
name|use_vars
operator|=
name|tab
operator|->
name|expr_vars
index|[
name|SSA_NAME_VERSION
argument_list|(
name|var
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|use_vars
condition|)
name|bitmap_ior_into
argument_list|(
name|def_vars
argument_list|,
name|use_vars
argument_list|)
expr_stmt|;
block|}
name|tab
operator|->
name|expr_vars
index|[
name|version
index|]
operator|=
name|def_vars
expr_stmt|;
comment|/* If there are VUSES, add a dependence on virtual defs.  */
if|if
condition|(
operator|!
name|ZERO_SSA_OPERANDS
argument_list|(
name|stmt
argument_list|,
name|SSA_OP_VUSE
argument_list|)
condition|)
block|{
name|add_value_to_list
argument_list|(
name|tab
argument_list|,
operator|(
name|value_expr_p
operator|*
operator|)
operator|&
operator|(
name|tab
operator|->
name|version_info
index|[
name|version
index|]
operator|)
argument_list|,
name|VIRTUAL_PARTITION
argument_list|(
name|tab
argument_list|)
argument_list|)
expr_stmt|;
name|add_value_to_list
argument_list|(
name|tab
argument_list|,
operator|&
operator|(
name|tab
operator|->
name|partition_dep_list
index|[
name|VIRTUAL_PARTITION
argument_list|(
name|tab
argument_list|)
index|]
operator|)
argument_list|,
name|version
argument_list|)
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|tab
operator|->
name|partition_in_use
argument_list|,
name|VIRTUAL_PARTITION
argument_list|(
name|tab
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* This function will remove the expression for VERSION from replacement     consideration.n table TAB  If 'replace' is true, it is marked as     replaceable, otherwise not.  */
end_comment

begin_function
specifier|static
name|void
name|finish_expr
parameter_list|(
name|temp_expr_table_p
name|tab
parameter_list|,
name|int
name|version
parameter_list|,
name|bool
name|replace
parameter_list|)
block|{
name|value_expr_p
name|info
decl_stmt|,
name|tmp
decl_stmt|;
name|int
name|partition
decl_stmt|;
comment|/* Remove this expression from its dependent lists.  The partition dependence      list is retained and transfered later to whomever uses this version.  */
for|for
control|(
name|info
operator|=
operator|(
name|value_expr_p
operator|)
name|tab
operator|->
name|version_info
index|[
name|version
index|]
init|;
name|info
condition|;
name|info
operator|=
name|tmp
control|)
block|{
name|partition
operator|=
name|info
operator|->
name|value
expr_stmt|;
name|gcc_assert
argument_list|(
name|tab
operator|->
name|partition_dep_list
index|[
name|partition
index|]
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|remove_value_from_list
argument_list|(
operator|&
operator|(
name|tab
operator|->
name|partition_dep_list
index|[
name|partition
index|]
operator|)
argument_list|,
name|version
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|free_value_expr
argument_list|(
name|tab
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* Only clear the bit when the dependency list is emptied via           a replacement. Otherwise kill_expr will take care of it.  */
if|if
condition|(
operator|!
operator|(
name|tab
operator|->
name|partition_dep_list
index|[
name|partition
index|]
operator|)
operator|&&
name|replace
condition|)
name|bitmap_clear_bit
argument_list|(
name|tab
operator|->
name|partition_in_use
argument_list|,
name|partition
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|info
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|replace
condition|)
name|free_value_expr
argument_list|(
name|tab
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|replace
condition|)
block|{
name|tab
operator|->
name|saw_replaceable
operator|=
name|true
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|tab
operator|->
name|replaceable
argument_list|,
name|version
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gcc_assert
argument_list|(
operator|!
name|bitmap_bit_p
argument_list|(
name|tab
operator|->
name|replaceable
argument_list|,
name|version
argument_list|)
argument_list|)
expr_stmt|;
name|tab
operator|->
name|version_info
index|[
name|version
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Mark the expression associated with VAR as replaceable, and enter    the defining stmt into the version_info table TAB.  */
end_comment

begin_function
specifier|static
name|void
name|mark_replaceable
parameter_list|(
name|temp_expr_table_p
name|tab
parameter_list|,
name|tree
name|var
parameter_list|)
block|{
name|value_expr_p
name|info
decl_stmt|;
name|int
name|version
init|=
name|SSA_NAME_VERSION
argument_list|(
name|var
argument_list|)
decl_stmt|;
name|finish_expr
argument_list|(
name|tab
argument_list|,
name|version
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* Move the dependence list to the pending list.  */
if|if
condition|(
name|tab
operator|->
name|version_info
index|[
name|version
index|]
condition|)
block|{
name|info
operator|=
operator|(
name|value_expr_p
operator|)
name|tab
operator|->
name|version_info
index|[
name|version
index|]
expr_stmt|;
for|for
control|(
init|;
name|info
operator|->
name|next
condition|;
name|info
operator|=
name|info
operator|->
name|next
control|)
continue|continue;
name|info
operator|->
name|next
operator|=
name|tab
operator|->
name|pending_dependence
expr_stmt|;
name|tab
operator|->
name|pending_dependence
operator|=
operator|(
name|value_expr_p
operator|)
name|tab
operator|->
name|version_info
index|[
name|version
index|]
expr_stmt|;
block|}
name|tab
operator|->
name|version_info
index|[
name|version
index|]
operator|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|var
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function marks any expression in TAB which is dependent on PARTITION    as NOT replaceable.  CLEAR_BIT is used to determine whether partition_in_use    should have its bit cleared.  Since this routine can be called within an    EXECUTE_IF_SET_IN_BITMAP, the bit can't always be cleared.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|kill_expr
parameter_list|(
name|temp_expr_table_p
name|tab
parameter_list|,
name|int
name|partition
parameter_list|,
name|bool
name|clear_bit
parameter_list|)
block|{
name|value_expr_p
name|ptr
decl_stmt|;
comment|/* Mark every active expr dependent on this var as not replaceable.  */
while|while
condition|(
operator|(
name|ptr
operator|=
name|tab
operator|->
name|partition_dep_list
index|[
name|partition
index|]
operator|)
operator|!=
name|NULL
condition|)
name|finish_expr
argument_list|(
name|tab
argument_list|,
name|ptr
operator|->
name|value
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|clear_bit
condition|)
name|bitmap_clear_bit
argument_list|(
name|tab
operator|->
name|partition_in_use
argument_list|,
name|partition
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function kills all expressions in TAB which are dependent on virtual     DEFs.  CLEAR_BIT determines whether partition_in_use gets cleared.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|kill_virtual_exprs
parameter_list|(
name|temp_expr_table_p
name|tab
parameter_list|,
name|bool
name|clear_bit
parameter_list|)
block|{
name|kill_expr
argument_list|(
name|tab
argument_list|,
name|VIRTUAL_PARTITION
argument_list|(
name|tab
argument_list|)
argument_list|,
name|clear_bit
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function processes basic block BB, and looks for variables which can    be replaced by their expressions.  Results are stored in TAB.  */
end_comment

begin_function
specifier|static
name|void
name|find_replaceable_in_bb
parameter_list|(
name|temp_expr_table_p
name|tab
parameter_list|,
name|basic_block
name|bb
parameter_list|)
block|{
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|tree
name|stmt
decl_stmt|,
name|def
decl_stmt|,
name|use
decl_stmt|;
name|stmt_ann_t
name|ann
decl_stmt|;
name|int
name|partition
decl_stmt|;
name|var_map
name|map
init|=
name|tab
operator|->
name|map
decl_stmt|;
name|value_expr_p
name|p
decl_stmt|;
name|ssa_op_iter
name|iter
decl_stmt|;
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
block|{
name|stmt
operator|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
expr_stmt|;
name|ann
operator|=
name|stmt_ann
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
comment|/* Determine if this stmt finishes an existing expression.  */
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|use
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_USE
argument_list|)
block|{
name|unsigned
name|ver
init|=
name|SSA_NAME_VERSION
argument_list|(
name|use
argument_list|)
decl_stmt|;
if|if
condition|(
name|tab
operator|->
name|version_info
index|[
name|ver
index|]
condition|)
block|{
name|bool
name|same_root_var
init|=
name|false
decl_stmt|;
name|ssa_op_iter
name|iter2
decl_stmt|;
name|bitmap
name|vars
init|=
name|tab
operator|->
name|expr_vars
index|[
name|ver
index|]
decl_stmt|;
comment|/* See if the root variables are the same.  If they are, we 		 do not want to do the replacement to avoid problems with 		 code size, see PR tree-optimization/17549.  */
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|def
argument_list|,
argument|stmt
argument_list|,
argument|iter2
argument_list|,
argument|SSA_OP_DEF
argument_list|)
block|{
if|if
condition|(
name|bitmap_bit_p
argument_list|(
name|vars
argument_list|,
name|DECL_UID
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|def
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|same_root_var
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
comment|/* Mark expression as replaceable unless stmt is volatile 		 or DEF sets the same root variable as STMT.  */
if|if
condition|(
operator|!
name|ann
operator|->
name|has_volatile_ops
operator|&&
operator|!
name|same_root_var
condition|)
name|mark_replaceable
argument_list|(
name|tab
argument_list|,
name|use
argument_list|)
expr_stmt|;
else|else
name|finish_expr
argument_list|(
name|tab
argument_list|,
name|ver
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Next, see if this stmt kills off an active expression.  */
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|def
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_DEF
argument_list|)
block|{
name|partition
operator|=
name|var_to_partition
argument_list|(
name|map
argument_list|,
name|def
argument_list|)
expr_stmt|;
if|if
condition|(
name|partition
operator|!=
name|NO_PARTITION
operator|&&
name|tab
operator|->
name|partition_dep_list
index|[
name|partition
index|]
condition|)
name|kill_expr
argument_list|(
name|tab
argument_list|,
name|partition
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
comment|/* Now see if we are creating a new expression or not.  */
if|if
condition|(
operator|!
name|ann
operator|->
name|has_volatile_ops
condition|)
name|check_replaceable
argument_list|(
name|tab
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
comment|/* Free any unused dependency lists.  */
while|while
condition|(
operator|(
name|p
operator|=
name|tab
operator|->
name|pending_dependence
operator|)
condition|)
block|{
name|tab
operator|->
name|pending_dependence
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free_value_expr
argument_list|(
name|tab
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* A V_{MAY,MUST}_DEF kills any expression using a virtual operand.  */
if|if
condition|(
operator|!
name|ZERO_SSA_OPERANDS
argument_list|(
name|stmt
argument_list|,
name|SSA_OP_VIRTUAL_DEFS
argument_list|)
condition|)
name|kill_virtual_exprs
argument_list|(
name|tab
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This function is the driver routine for replacement of temporary expressions    in the SSA->normal phase, operating on MAP.  If there are replaceable     expressions, a table is returned which maps SSA versions to the     expressions they should be replaced with.  A NULL_TREE indicates no     replacement should take place.  If there are no replacements at all,     NULL is returned by the function, otherwise an expression vector indexed    by SSA_NAME version numbers.  */
end_comment

begin_function
specifier|static
name|tree
modifier|*
name|find_replaceable_exprs
parameter_list|(
name|var_map
name|map
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|temp_expr_table_p
name|table
decl_stmt|;
name|tree
modifier|*
name|ret
decl_stmt|;
name|table
operator|=
name|new_temp_expr_table
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|bitmap_iterator
name|bi
decl_stmt|;
name|find_replaceable_in_bb
argument_list|(
name|table
argument_list|,
name|bb
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|(table->partition_in_use)
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
name|kill_expr
argument_list|(
name|table
argument_list|,
name|i
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
block|}
name|ret
operator|=
name|free_temp_expr_table
argument_list|(
name|table
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Dump TER expression table EXPR to file F.  */
end_comment

begin_function
specifier|static
name|void
name|dump_replaceable_exprs
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|tree
modifier|*
name|expr
parameter_list|)
block|{
name|tree
name|stmt
decl_stmt|,
name|var
decl_stmt|;
name|int
name|x
decl_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\nReplacing Expressions\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
operator|(
name|int
operator|)
name|num_ssa_names
operator|+
literal|1
condition|;
name|x
operator|++
control|)
if|if
condition|(
name|expr
index|[
name|x
index|]
condition|)
block|{
name|stmt
operator|=
name|expr
index|[
name|x
index|]
expr_stmt|;
name|var
operator|=
name|SINGLE_SSA_TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
name|SSA_OP_DEF
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|var
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|f
argument_list|,
name|var
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" replace with --> "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|f
argument_list|,
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function will rewrite the current program using the variable mapping    found in MAP.  If the replacement vector VALUES is provided, any     occurrences of partitions with non-null entries in the vector will be     replaced with the expression in the vector instead of its mapped     variable.  */
end_comment

begin_function
specifier|static
name|void
name|rewrite_trees
parameter_list|(
name|var_map
name|map
parameter_list|,
name|tree
modifier|*
name|values
parameter_list|)
block|{
name|elim_graph
name|g
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|block_stmt_iterator
name|si
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|tree
name|phi
decl_stmt|;
name|bool
name|changed
decl_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
comment|/* Search for PHIs where the destination has no partition, but one      or more arguments has a partition.  This should not happen and can      create incorrect code.  */
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|tree
name|phi
decl_stmt|;
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|bb
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
block|{
name|tree
name|T0
init|=
name|var_to_partition_to_var
argument_list|(
name|map
argument_list|,
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|T0
operator|==
name|NULL_TREE
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PHI_NUM_ARGS
argument_list|(
name|phi
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|arg
init|=
name|PHI_ARG_DEF
argument_list|(
name|phi
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|SSA_NAME
operator|&&
name|var_to_partition
argument_list|(
name|map
argument_list|,
name|arg
argument_list|)
operator|!=
name|NO_PARTITION
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Argument of PHI is in a partition :("
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|stderr
argument_list|,
name|arg
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"), but the result is not :"
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|stderr
argument_list|,
name|phi
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|internal_error
argument_list|(
literal|"SSA corruption"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
endif|#
directive|endif
comment|/* Replace PHI nodes with any required copies.  */
name|g
operator|=
name|new_elim_graph
argument_list|(
name|map
operator|->
name|num_partitions
argument_list|)
expr_stmt|;
name|g
operator|->
name|map
operator|=
name|map
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
for|for
control|(
name|si
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|si
argument_list|)
condition|;
control|)
block|{
name|tree
name|stmt
init|=
name|bsi_stmt
argument_list|(
name|si
argument_list|)
decl_stmt|;
name|use_operand_p
name|use_p
decl_stmt|,
name|copy_use_p
decl_stmt|;
name|def_operand_p
name|def_p
decl_stmt|;
name|bool
name|remove
init|=
name|false
decl_stmt|,
name|is_copy
init|=
name|false
decl_stmt|;
name|int
name|num_uses
init|=
literal|0
decl_stmt|;
name|stmt_ann_t
name|ann
decl_stmt|;
name|ssa_op_iter
name|iter
decl_stmt|;
name|ann
operator|=
name|stmt_ann
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|changed
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|MODIFY_EXPR
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|SSA_NAME
operator|)
condition|)
name|is_copy
operator|=
name|true
expr_stmt|;
name|copy_use_p
operator|=
name|NULL_USE_OPERAND_P
expr_stmt|;
name|FOR_EACH_SSA_USE_OPERAND
argument_list|(
argument|use_p
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_USE
argument_list|)
block|{
if|if
condition|(
name|replace_use_variable
argument_list|(
name|map
argument_list|,
name|use_p
argument_list|,
name|values
argument_list|)
condition|)
name|changed
operator|=
name|true
expr_stmt|;
name|copy_use_p
operator|=
name|use_p
expr_stmt|;
name|num_uses
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|num_uses
operator|!=
literal|1
condition|)
name|is_copy
operator|=
name|false
expr_stmt|;
name|def_p
operator|=
name|SINGLE_SSA_DEF_OPERAND
argument_list|(
name|stmt
argument_list|,
name|SSA_OP_DEF
argument_list|)
expr_stmt|;
if|if
condition|(
name|def_p
operator|!=
name|NULL
condition|)
block|{
comment|/* Mark this stmt for removal if it is the list of replaceable  		 expressions.  */
if|if
condition|(
name|values
operator|&&
name|values
index|[
name|SSA_NAME_VERSION
argument_list|(
name|DEF_FROM_PTR
argument_list|(
name|def_p
argument_list|)
argument_list|)
index|]
condition|)
name|remove
operator|=
name|true
expr_stmt|;
else|else
block|{
if|if
condition|(
name|replace_def_variable
argument_list|(
name|map
argument_list|,
name|def_p
argument_list|,
name|NULL
argument_list|)
condition|)
name|changed
operator|=
name|true
expr_stmt|;
comment|/* If both SSA_NAMEs coalesce to the same variable, 		     mark the now redundant copy for removal.  */
if|if
condition|(
name|is_copy
condition|)
block|{
name|gcc_assert
argument_list|(
name|copy_use_p
operator|!=
name|NULL_USE_OPERAND_P
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEF_FROM_PTR
argument_list|(
name|def_p
argument_list|)
operator|==
name|USE_FROM_PTR
argument_list|(
name|copy_use_p
argument_list|)
condition|)
name|remove
operator|=
name|true
expr_stmt|;
block|}
block|}
block|}
else|else
name|FOR_EACH_SSA_DEF_OPERAND
argument_list|(
argument|def_p
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_DEF
argument_list|)
if|if
condition|(
name|replace_def_variable
argument_list|(
name|map
argument_list|,
name|def_p
argument_list|,
name|NULL
argument_list|)
condition|)
name|changed
operator|=
name|true
expr_stmt|;
comment|/* Remove any stmts marked for removal.  */
if|if
condition|(
name|remove
condition|)
name|bsi_remove
argument_list|(
operator|&
name|si
argument_list|,
name|true
argument_list|)
expr_stmt|;
else|else
name|bsi_next
argument_list|(
operator|&
name|si
argument_list|)
expr_stmt|;
block|}
name|phi
operator|=
name|phi_nodes
argument_list|(
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|phi
condition|)
block|{
name|edge_iterator
name|ei
decl_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->preds
argument_list|)
name|eliminate_phi
argument_list|(
name|e
argument_list|,
name|g
argument_list|)
expr_stmt|;
block|}
block|}
name|delete_elim_graph
argument_list|(
name|g
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|DEF_VEC_ALLOC_P
argument_list|(
name|edge
argument_list|,
name|heap
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* These are the local work structures used to determine the best place to     insert the copies that were placed on edges by the SSA->normal pass..  */
end_comment

begin_expr_stmt
specifier|static
name|VEC
argument_list|(
name|edge
argument_list|,
name|heap
argument_list|)
operator|*
name|edge_leader
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
name|stmt_list
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|bitmap
name|leader_has_match
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|edge
name|leader_match
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pass this function to make_forwarder_block so that all the edges with    matching PENDING_STMT lists to 'curr_stmt_list' get redirected.  */
end_comment

begin_function
specifier|static
name|bool
name|same_stmt_list_p
parameter_list|(
name|edge
name|e
parameter_list|)
block|{
return|return
operator|(
name|e
operator|->
name|aux
operator|==
operator|(
name|PTR
operator|)
name|leader_match
operator|)
condition|?
name|true
else|:
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if S1 and S2 are equivalent copies.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|identical_copies_p
parameter_list|(
name|tree
name|s1
parameter_list|,
name|tree
name|s2
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|s1
argument_list|)
operator|==
name|MODIFY_EXPR
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|s2
argument_list|)
operator|==
name|MODIFY_EXPR
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|DECL_P
argument_list|(
name|TREE_OPERAND
argument_list|(
name|s1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|DECL_P
argument_list|(
name|TREE_OPERAND
argument_list|(
name|s2
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|s1
argument_list|,
literal|0
argument_list|)
operator|!=
name|TREE_OPERAND
argument_list|(
name|s2
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
name|s1
operator|=
name|TREE_OPERAND
argument_list|(
name|s1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|s2
operator|=
name|TREE_OPERAND
argument_list|(
name|s2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|s1
operator|!=
name|s2
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Compare the PENDING_STMT list for two edges, and return true if the lists    contain the same sequence of copies.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|identical_stmt_lists_p
parameter_list|(
name|edge
name|e1
parameter_list|,
name|edge
name|e2
parameter_list|)
block|{
name|tree
name|t1
init|=
name|PENDING_STMT
argument_list|(
name|e1
argument_list|)
decl_stmt|;
name|tree
name|t2
init|=
name|PENDING_STMT
argument_list|(
name|e2
argument_list|)
decl_stmt|;
name|tree_stmt_iterator
name|tsi1
decl_stmt|,
name|tsi2
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|STATEMENT_LIST
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|STATEMENT_LIST
argument_list|)
expr_stmt|;
for|for
control|(
name|tsi1
operator|=
name|tsi_start
argument_list|(
name|t1
argument_list|)
operator|,
name|tsi2
operator|=
name|tsi_start
argument_list|(
name|t2
argument_list|)
init|;
operator|!
name|tsi_end_p
argument_list|(
name|tsi1
argument_list|)
operator|&&
operator|!
name|tsi_end_p
argument_list|(
name|tsi2
argument_list|)
condition|;
name|tsi_next
argument_list|(
operator|&
name|tsi1
argument_list|)
operator|,
name|tsi_next
argument_list|(
operator|&
name|tsi2
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|identical_copies_p
argument_list|(
name|tsi_stmt
argument_list|(
name|tsi1
argument_list|)
argument_list|,
name|tsi_stmt
argument_list|(
name|tsi2
argument_list|)
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|tsi_end_p
argument_list|(
name|tsi1
argument_list|)
operator|||
operator|!
name|tsi_end_p
argument_list|(
name|tsi2
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Allocate data structures used in analyze_edges_for_bb.   */
end_comment

begin_function
specifier|static
name|void
name|init_analyze_edges_for_bb
parameter_list|(
name|void
parameter_list|)
block|{
name|edge_leader
operator|=
name|VEC_alloc
argument_list|(
name|edge
argument_list|,
name|heap
argument_list|,
literal|25
argument_list|)
expr_stmt|;
name|stmt_list
operator|=
name|VEC_alloc
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
literal|25
argument_list|)
expr_stmt|;
name|leader_has_match
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free data structures used in analyze_edges_for_bb.   */
end_comment

begin_function
specifier|static
name|void
name|fini_analyze_edges_for_bb
parameter_list|(
name|void
parameter_list|)
block|{
name|VEC_free
argument_list|(
name|edge
argument_list|,
name|heap
argument_list|,
name|edge_leader
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|stmt_list
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|leader_has_match
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Look at all the incoming edges to block BB, and decide where the best place    to insert the stmts on each edge are, and perform those insertions.  */
end_comment

begin_function
specifier|static
name|void
name|analyze_edges_for_bb
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|int
name|count
decl_stmt|;
name|unsigned
name|int
name|x
decl_stmt|;
name|bool
name|have_opportunity
decl_stmt|;
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|tree
name|stmt
decl_stmt|;
name|edge
name|single_edge
init|=
name|NULL
decl_stmt|;
name|bool
name|is_label
decl_stmt|;
name|edge
name|leader
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
comment|/* Blocks which contain at least one abnormal edge cannot use       make_forwarder_block.  Look for these blocks, and commit any PENDING_STMTs      found on edges in these block.  */
name|have_opportunity
operator|=
name|true
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->preds
argument_list|)
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
condition|)
block|{
name|have_opportunity
operator|=
name|false
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|have_opportunity
condition|)
block|{
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->preds
argument_list|)
if|if
condition|(
name|PENDING_STMT
argument_list|(
name|e
argument_list|)
condition|)
name|bsi_commit_one_edge_insert
argument_list|(
name|e
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Find out how many edges there are with interesting pending stmts on them.        Commit the stmts on edges we are not interested in.  */
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->preds
argument_list|)
block|{
if|if
condition|(
name|PENDING_STMT
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|gcc_assert
argument_list|(
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
block|{
name|bsi
operator|=
name|bsi_start
argument_list|(
name|e
operator|->
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|)
block|{
name|stmt
operator|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
expr_stmt|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|stmt
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
name|is_label
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|LABEL_EXPR
operator|)
expr_stmt|;
comment|/* Punt if it has non-label stmts, or isn't local.  */
if|if
condition|(
operator|!
name|is_label
operator|||
name|DECL_NONLOCAL
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|)
block|{
name|bsi_commit_one_edge_insert
argument_list|(
name|e
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
block|}
name|single_edge
operator|=
name|e
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
block|}
comment|/* If there aren't at least 2 edges, no sharing will happen.  */
if|if
condition|(
name|count
operator|<
literal|2
condition|)
block|{
if|if
condition|(
name|single_edge
condition|)
name|bsi_commit_one_edge_insert
argument_list|(
name|single_edge
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Ensure that we have empty worklists.  */
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|gcc_assert
argument_list|(
name|VEC_length
argument_list|(
name|edge
argument_list|,
name|edge_leader
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|stmt_list
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|bitmap_empty_p
argument_list|(
name|leader_has_match
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Find the "leader" block for each set of unique stmt lists.  Preference is      given to FALLTHRU blocks since they would need a GOTO to arrive at another      block.  The leader edge destination is the block which all the other edges      with the same stmt list will be redirected to.  */
name|have_opportunity
operator|=
name|false
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->preds
argument_list|)
block|{
if|if
condition|(
name|PENDING_STMT
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|bool
name|found
init|=
name|false
decl_stmt|;
comment|/* Look for the same stmt list in edge leaders list.  */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|edge
argument_list|,
name|edge_leader
argument_list|,
name|x
argument_list|,
name|leader
argument_list|)
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|identical_stmt_lists_p
argument_list|(
name|leader
argument_list|,
name|e
argument_list|)
condition|)
block|{
comment|/* Give this edge the same stmt list pointer.  */
name|PENDING_STMT
argument_list|(
name|e
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|e
operator|->
name|aux
operator|=
name|leader
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|leader_has_match
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|have_opportunity
operator|=
name|found
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
comment|/* If no similar stmt list, add this edge to the leader list.  */
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|VEC_safe_push
argument_list|(
name|edge
argument_list|,
name|heap
argument_list|,
name|edge_leader
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|stmt_list
argument_list|,
name|PENDING_STMT
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* If there are no similar lists, just issue the stmts.  */
if|if
condition|(
operator|!
name|have_opportunity
condition|)
block|{
for|for
control|(
name|x
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|edge
argument_list|,
name|edge_leader
argument_list|,
name|x
argument_list|,
name|leader
argument_list|)
condition|;
name|x
operator|++
control|)
name|bsi_commit_one_edge_insert
argument_list|(
name|leader
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|VEC_truncate
argument_list|(
name|edge
argument_list|,
name|edge_leader
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VEC_truncate
argument_list|(
name|tree
argument_list|,
name|stmt_list
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bitmap_clear
argument_list|(
name|leader_has_match
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nOpportunities in BB %d for stmt/block reduction:\n"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
comment|/* For each common list, create a forwarding block and issue the stmt's      in that block.  */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|edge
argument_list|,
name|edge_leader
argument_list|,
name|x
argument_list|,
name|leader
argument_list|)
condition|;
name|x
operator|++
control|)
if|if
condition|(
name|bitmap_bit_p
argument_list|(
name|leader_has_match
argument_list|,
name|x
argument_list|)
condition|)
block|{
name|edge
name|new_edge
decl_stmt|;
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|tree
name|curr_stmt_list
decl_stmt|;
name|leader_match
operator|=
name|leader
expr_stmt|;
comment|/* The tree_* cfg manipulation routines use the PENDING_EDGE field 	   for various PHI manipulations, so it gets cleared when calls are  	   made to make_forwarder_block(). So make sure the edge is clear,  	   and use the saved stmt list.  */
name|PENDING_STMT
argument_list|(
name|leader
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|leader
operator|->
name|aux
operator|=
name|leader
expr_stmt|;
name|curr_stmt_list
operator|=
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|stmt_list
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|new_edge
operator|=
name|make_forwarder_block
argument_list|(
name|leader
operator|->
name|dest
argument_list|,
name|same_stmt_list_p
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|bb
operator|=
name|new_edge
operator|->
name|dest
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Splitting BB %d for Common stmt list.  "
argument_list|,
name|leader
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Original block is now BB%d.\n"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|dump_file
argument_list|,
name|curr_stmt_list
argument_list|,
name|TDF_VOPS
argument_list|)
expr_stmt|;
block|}
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|new_edge->src->preds
argument_list|)
block|{
name|e
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  Edge (%d->%d) lands here.\n"
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
name|bsi
operator|=
name|bsi_last
argument_list|(
name|leader
operator|->
name|dest
argument_list|)
expr_stmt|;
name|bsi_insert_after
argument_list|(
operator|&
name|bsi
argument_list|,
name|curr_stmt_list
argument_list|,
name|BSI_NEW_STMT
argument_list|)
expr_stmt|;
name|leader_match
operator|=
name|NULL
expr_stmt|;
comment|/* We should never get a new block now.  */
block|}
else|else
block|{
name|PENDING_STMT
argument_list|(
name|leader
argument_list|)
operator|=
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|stmt_list
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|bsi_commit_one_edge_insert
argument_list|(
name|leader
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* Clear the working data structures.  */
name|VEC_truncate
argument_list|(
name|edge
argument_list|,
name|edge_leader
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VEC_truncate
argument_list|(
name|tree
argument_list|,
name|stmt_list
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bitmap_clear
argument_list|(
name|leader_has_match
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function will analyze the insertions which were performed on edges,    and decide whether they should be left on that edge, or whether it is more    efficient to emit some subset of them in a single block.  All stmts are    inserted somewhere.  */
end_comment

begin_function
specifier|static
name|void
name|perform_edge_inserts
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Analyzing Edge Insertions.\n"
argument_list|)
expr_stmt|;
comment|/* analyze_edges_for_bb calls make_forwarder_block, which tries to      incrementally update the dominator information.  Since we don't      need dominator information after this pass, go ahead and free the      dominator information.  */
name|free_dominance_info
argument_list|(
name|CDI_DOMINATORS
argument_list|)
expr_stmt|;
name|free_dominance_info
argument_list|(
name|CDI_POST_DOMINATORS
argument_list|)
expr_stmt|;
comment|/* Allocate data structures used in analyze_edges_for_bb.   */
name|init_analyze_edges_for_bb
argument_list|()
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
name|analyze_edges_for_bb
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|analyze_edges_for_bb
argument_list|(
name|EXIT_BLOCK_PTR
argument_list|)
expr_stmt|;
comment|/* Free data structures used in analyze_edges_for_bb.   */
name|fini_analyze_edges_for_bb
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
block|{
name|edge_iterator
name|ei
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->preds
argument_list|)
block|{
if|if
condition|(
name|PENDING_STMT
argument_list|(
name|e
argument_list|)
condition|)
name|error
argument_list|(
literal|" Pending stmts not issued on PRED edge (%d, %d)\n"
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
block|{
if|if
condition|(
name|PENDING_STMT
argument_list|(
name|e
argument_list|)
condition|)
name|error
argument_list|(
literal|" Pending stmts not issued on SUCC edge (%d, %d)\n"
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
block|}
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|ENTRY_BLOCK_PTR->succs
argument_list|)
block|{
if|if
condition|(
name|PENDING_STMT
argument_list|(
name|e
argument_list|)
condition|)
name|error
argument_list|(
literal|" Pending stmts not issued on ENTRY edge (%d, %d)\n"
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|EXIT_BLOCK_PTR->preds
argument_list|)
block|{
if|if
condition|(
name|PENDING_STMT
argument_list|(
name|e
argument_list|)
condition|)
name|error
argument_list|(
literal|" Pending stmts not issued on EXIT edge (%d, %d)\n"
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Remove the variables specified in MAP from SSA form.  FLAGS indicate what    options should be used.  */
end_comment

begin_function
specifier|static
name|void
name|remove_ssa_form
parameter_list|(
name|var_map
name|map
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|tree_live_info_p
name|liveinfo
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|tree
name|phi
decl_stmt|,
name|next
decl_stmt|;
name|tree
modifier|*
name|values
init|=
name|NULL
decl_stmt|;
comment|/* If we are not combining temps, don't calculate live ranges for variables      with only one SSA version.  */
if|if
condition|(
operator|(
name|flags
operator|&
name|SSANORM_COMBINE_TEMPS
operator|)
operator|==
literal|0
condition|)
name|compact_var_map
argument_list|(
name|map
argument_list|,
name|VARMAP_NO_SINGLE_DEFS
argument_list|)
expr_stmt|;
else|else
name|compact_var_map
argument_list|(
name|map
argument_list|,
name|VARMAP_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|dump_var_map
argument_list|(
name|dump_file
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|liveinfo
operator|=
name|coalesce_ssa_name
argument_list|(
name|map
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* Make sure even single occurrence variables are in the list now.  */
if|if
condition|(
operator|(
name|flags
operator|&
name|SSANORM_COMBINE_TEMPS
operator|)
operator|==
literal|0
condition|)
name|compact_var_map
argument_list|(
name|map
argument_list|,
name|VARMAP_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"After Coalescing:\n"
argument_list|)
expr_stmt|;
name|dump_var_map
argument_list|(
name|dump_file
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|SSANORM_PERFORM_TER
condition|)
block|{
name|values
operator|=
name|find_replaceable_exprs
argument_list|(
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|values
operator|&&
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|dump_replaceable_exprs
argument_list|(
name|dump_file
argument_list|,
name|values
argument_list|)
expr_stmt|;
block|}
comment|/* Assign real variables to the partitions now.  */
name|assign_vars
argument_list|(
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"After Root variable replacement:\n"
argument_list|)
expr_stmt|;
name|dump_var_map
argument_list|(
name|dump_file
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|SSANORM_COMBINE_TEMPS
operator|)
operator|&&
name|liveinfo
condition|)
block|{
name|coalesce_vars
argument_list|(
name|map
argument_list|,
name|liveinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"After variable memory coalescing:\n"
argument_list|)
expr_stmt|;
name|dump_var_map
argument_list|(
name|dump_file
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|liveinfo
condition|)
name|delete_tree_live_info
argument_list|(
name|liveinfo
argument_list|)
expr_stmt|;
name|rewrite_trees
argument_list|(
name|map
argument_list|,
name|values
argument_list|)
expr_stmt|;
if|if
condition|(
name|values
condition|)
name|free
argument_list|(
name|values
argument_list|)
expr_stmt|;
comment|/* Remove phi nodes which have been translated back to real variables.  */
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|bb
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|next
control|)
block|{
name|next
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
expr_stmt|;
name|remove_phi_node
argument_list|(
name|phi
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* we no longer maintain the SSA operand cache at this point.  */
name|fini_ssa_operands
argument_list|()
expr_stmt|;
comment|/* If any copies were inserted on edges, analyze and insert them now.  */
name|perform_edge_inserts
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Search every PHI node for arguments associated with backedges which    we can trivially determine will need a copy (the argument is either    not an SSA_NAME or the argument has a different underlying variable    than the PHI result).     Insert a copy from the PHI argument to a new destination at the    end of the block with the backedge to the top of the loop.  Update    the PHI argument to reference this new destination.  */
end_comment

begin_function
specifier|static
name|void
name|insert_backedge_copies
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|tree
name|phi
decl_stmt|;
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|bb
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
block|{
name|tree
name|result
init|=
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
decl_stmt|;
name|tree
name|result_var
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|is_gimple_reg
argument_list|(
name|result
argument_list|)
condition|)
continue|continue;
name|result_var
operator|=
name|SSA_NAME_VAR
argument_list|(
name|result
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PHI_NUM_ARGS
argument_list|(
name|phi
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|arg
init|=
name|PHI_ARG_DEF
argument_list|(
name|phi
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|edge
name|e
init|=
name|PHI_ARG_EDGE
argument_list|(
name|phi
argument_list|,
name|i
argument_list|)
decl_stmt|;
comment|/* If the argument is not an SSA_NAME, then we will 		 need a constant initialization.  If the argument is 		 an SSA_NAME with a different underlying variable and 		 we are not combining temporaries, then we will 		 need a copy statement.  */
if|if
condition|(
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_DFS_BACK
operator|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|SSA_NAME
operator|||
operator|(
operator|!
name|flag_tree_combine_temps
operator|&&
name|SSA_NAME_VAR
argument_list|(
name|arg
argument_list|)
operator|!=
name|result_var
operator|)
operator|)
condition|)
block|{
name|tree
name|stmt
decl_stmt|,
name|name
decl_stmt|,
name|last
init|=
name|NULL
decl_stmt|;
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|bsi
operator|=
name|bsi_last
argument_list|(
name|PHI_ARG_EDGE
argument_list|(
name|phi
argument_list|,
name|i
argument_list|)
operator|->
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|)
name|last
operator|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
expr_stmt|;
comment|/* In theory the only way we ought to get back to the 		     start of a loop should be with a COND_EXPR or GOTO_EXPR. 		     However, better safe than sorry.   		     If the block ends with a control statement or 		     something that might throw, then we have to 		     insert this assignment before the last 		     statement.  Else insert it after the last statement.  */
if|if
condition|(
name|last
operator|&&
name|stmt_ends_bb_p
argument_list|(
name|last
argument_list|)
condition|)
block|{
comment|/* If the last statement in the block is the definition 			 site of the PHI argument, then we can't insert 			 anything after it.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|SSA_NAME
operator|&&
name|SSA_NAME_DEF_STMT
argument_list|(
name|arg
argument_list|)
operator|==
name|last
condition|)
continue|continue;
block|}
comment|/* Create a new instance of the underlying 		     variable of the PHI result.  */
name|stmt
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|result_var
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|PHI_ARG_DEF
argument_list|(
name|phi
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|=
name|make_ssa_name
argument_list|(
name|result_var
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
operator|=
name|name
expr_stmt|;
comment|/* Insert the new statement into the block and update 		     the PHI node.  */
if|if
condition|(
name|last
operator|&&
name|stmt_ends_bb_p
argument_list|(
name|last
argument_list|)
condition|)
name|bsi_insert_before
argument_list|(
operator|&
name|bsi
argument_list|,
name|stmt
argument_list|,
name|BSI_NEW_STMT
argument_list|)
expr_stmt|;
else|else
name|bsi_insert_after
argument_list|(
operator|&
name|bsi
argument_list|,
name|stmt
argument_list|,
name|BSI_NEW_STMT
argument_list|)
expr_stmt|;
name|SET_PHI_ARG_DEF
argument_list|(
name|phi
argument_list|,
name|i
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Take the current function out of SSA form, as described in    R. Morgan, ``Building an Optimizing Compiler'',    Butterworth-Heinemann, Boston, MA, 1998. pp 176-186.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|rewrite_out_of_ssa
parameter_list|(
name|void
parameter_list|)
block|{
name|var_map
name|map
decl_stmt|;
name|int
name|var_flags
init|=
literal|0
decl_stmt|;
name|int
name|ssa_flags
init|=
literal|0
decl_stmt|;
comment|/* If elimination of a PHI requires inserting a copy on a backedge,      then we will have to split the backedge which has numerous      undesirable performance effects.       A significant number of such cases can be handled here by inserting      copies into the loop itself.  */
name|insert_backedge_copies
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|flag_tree_live_range_split
condition|)
name|ssa_flags
operator||=
name|SSANORM_COALESCE_PARTITIONS
expr_stmt|;
name|eliminate_virtual_phis
argument_list|()
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|dump_tree_cfg
argument_list|(
name|dump_file
argument_list|,
name|dump_flags
operator|&
operator|~
name|TDF_DETAILS
argument_list|)
expr_stmt|;
comment|/* We cannot allow unssa to un-gimplify trees before we instrument them.  */
if|if
condition|(
name|flag_tree_ter
operator|&&
operator|!
name|flag_mudflap
condition|)
name|var_flags
operator|=
name|SSA_VAR_MAP_REF_COUNT
expr_stmt|;
name|map
operator|=
name|create_ssa_var_map
argument_list|(
name|var_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_tree_combine_temps
condition|)
name|ssa_flags
operator||=
name|SSANORM_COMBINE_TEMPS
expr_stmt|;
if|if
condition|(
name|flag_tree_ter
operator|&&
operator|!
name|flag_mudflap
condition|)
name|ssa_flags
operator||=
name|SSANORM_PERFORM_TER
expr_stmt|;
name|remove_ssa_form
argument_list|(
name|map
argument_list|,
name|ssa_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|dump_tree_cfg
argument_list|(
name|dump_file
argument_list|,
name|dump_flags
operator|&
operator|~
name|TDF_DETAILS
argument_list|)
expr_stmt|;
comment|/* Flush out flow graph and SSA data.  */
name|delete_var_map
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|in_ssa_p
operator|=
name|false
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Define the parameters of the out of SSA pass.  */
end_comment

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_del_ssa
init|=
block|{
literal|"optimized"
block|,
comment|/* name */
name|NULL
block|,
comment|/* gate */
name|rewrite_out_of_ssa
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
name|TV_TREE_SSA_TO_NORMAL
block|,
comment|/* tv_id */
name|PROP_cfg
operator||
name|PROP_ssa
operator||
name|PROP_alias
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
comment|/* ??? If TER is enabled, we also kill gimple.  */
name|PROP_ssa
block|,
comment|/* properties_destroyed */
name|TODO_verify_ssa
operator||
name|TODO_verify_flow
operator||
name|TODO_verify_stmts
block|,
comment|/* todo_flags_start */
name|TODO_dump_func
operator||
name|TODO_ggc_collect
operator||
name|TODO_remove_unused_locals
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

end_unit

