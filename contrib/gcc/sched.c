begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Instruction scheduling pass.    Copyright (C) 1992, 93-98, 1999 Free Software Foundation, Inc.    Contributed by Michael Tiemann (tiemann@cygnus.com)    Enhanced by, and currently maintained by, Jim Wilson (wilson@cygnus.com)  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Instruction scheduling pass.     This pass implements list scheduling within basic blocks.  It is    run after flow analysis, but before register allocation.  The    scheduler works as follows:     We compute insn priorities based on data dependencies.  Flow    analysis only creates a fraction of the data-dependencies we must    observe: namely, only those dependencies which the combiner can be    expected to use.  For this pass, we must therefore create the    remaining dependencies we need to observe: register dependencies,    memory dependencies, dependencies to keep function calls in order,    and the dependence between a conditional branch and the setting of    condition codes are all dealt with here.     The scheduler first traverses the data flow graph, starting with    the last instruction, and proceeding to the first, assigning    values to insn_priority as it goes.  This sorts the instructions    topologically by data dependence.     Once priorities have been established, we order the insns using    list scheduling.  This works as follows: starting with a list of    all the ready insns, and sorted according to priority number, we    schedule the insn from the end of the list by placing its    predecessors in the list according to their priority order.  We    consider this insn scheduled by setting the pointer to the "end" of    the list to point to the previous insn.  When an insn has no    predecessors, we either queue it until sufficient time has elapsed    or add it to the ready list.  As the instructions are scheduled or    when stalls are introduced, the queue advances and dumps insns into    the ready list.  When all insns down to the lowest priority have    been scheduled, the critical path of the basic block has been made    as short as possible.  The remaining insns are then scheduled in    remaining slots.     Function unit conflicts are resolved during reverse list scheduling    by tracking the time when each insn is committed to the schedule    and from that, the time the function units it uses must be free.    As insns on the ready list are considered for scheduling, those    that would result in a blockage of the already committed insns are    queued until no blockage will result.  Among the remaining insns on    the ready list to be considered, the first one with the largest    potential for causing a subsequent blockage is chosen.     The following list shows the order in which we want to break ties    among insns in the ready list:  	1.  choose insn with lowest conflict cost, ties broken by 	2.  choose insn with the longest path to end of bb, ties broken by 	3.  choose insn that kills the most registers, ties broken by 	4.  choose insn that conflicts with the most ready insns, or finally 	5.  choose insn with lowest UID.     Memory references complicate matters.  Only if we can be certain    that memory references are not part of the data dependency graph    (via true, anti, or output dependence), can we move operations past    memory references.  To first approximation, reads can be done    independently, while writes introduce dependencies.  Better    approximations will yield fewer dependencies.     Dependencies set up by memory references are treated in exactly the    same way as other dependencies, by using LOG_LINKS.     Having optimized the critical path, we may have also unduly    extended the lifetimes of some registers.  If an operation requires    that constants be loaded into registers, it is certainly desirable    to load those constants as early as necessary, but no earlier.    I.e., it will not do to load up a bunch of registers at the    beginning of a basic block only to use them at the end, if they    could be loaded later, since this may result in excessive register    utilization.     Note that since branches are never in basic blocks, but only end    basic blocks, this pass will not do any branch scheduling.  But    that is ok, since we can use GNU's delayed branch scheduling    pass to take care of this case.     Also note that no further optimizations based on algebraic identities    are performed, so this pass would be a good one to perform instruction    splitting, such as breaking up a multiply instruction into shifts    and adds where that is profitable.     Given the memory aliasing analysis that this pass should perform,    it should be possible to remove redundant stores to memory, and to    load values from registers instead of hitting memory.     This pass must update information that subsequent passes expect to be    correct.  Namely: reg_n_refs, reg_n_sets, reg_n_deaths,    reg_n_calls_crossed, and reg_live_length.  Also, BLOCK_HEAD,    BLOCK_END.     The information in the line number notes is carefully retained by    this pass.  Notes that refer to the starting and ending of    exception regions are also carefully retained by this pass.  All    other NOTE insns are grouped in their same relative order at the    beginning of basic blocks that have been scheduled.  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|INSN_SCHEDULING
end_ifndef

begin_function
name|void
name|schedule_insns
parameter_list|(
name|dump_file
parameter_list|)
name|FILE
modifier|*
name|dump_file
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{ }
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* INSN_SCHEDULING -- rest of file */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|reg_known_equiv_p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|rtx
modifier|*
name|reg_known_value
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Arrays set up by scheduling for the same respective purposes as    similar-named arrays set up by flow analysis.  We work with these    arrays during the scheduling pass so we can compare values against    unscheduled code.     Values of these arrays are copied at the end of this pass into the    arrays set up by flow analysis.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|sched_reg_n_calls_crossed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
modifier|*
name|sched_reg_live_length
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element N is the next insn that sets (hard or pseudo) register    N within the current basic block; or zero, if there is no    such insn.  Needed for new registers which may be introduced    by splitting insns.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|reg_last_uses
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|reg_last_sets
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|regset
name|reg_pending_sets
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reg_pending_sets_all
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Vector indexed by INSN_UID giving the original ordering of the insns.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|insn_luid
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|INSN_LUID
parameter_list|(
name|INSN
parameter_list|)
value|(insn_luid[INSN_UID (INSN)])
end_define

begin_comment
comment|/* Vector indexed by INSN_UID giving each instruction a priority.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|insn_priority
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|INSN_PRIORITY
parameter_list|(
name|INSN
parameter_list|)
value|(insn_priority[INSN_UID (INSN)])
end_define

begin_decl_stmt
specifier|static
name|short
modifier|*
name|insn_costs
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|INSN_COST
parameter_list|(
name|INSN
parameter_list|)
value|insn_costs[INSN_UID (INSN)]
end_define

begin_comment
comment|/* Vector indexed by INSN_UID giving an encoding of the function units    used.  */
end_comment

begin_decl_stmt
specifier|static
name|short
modifier|*
name|insn_units
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|INSN_UNIT
parameter_list|(
name|INSN
parameter_list|)
value|insn_units[INSN_UID (INSN)]
end_define

begin_comment
comment|/* Vector indexed by INSN_UID giving an encoding of the blockage range    function.  The unit and the range are encoded.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
modifier|*
name|insn_blockage
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|INSN_BLOCKAGE
parameter_list|(
name|INSN
parameter_list|)
value|insn_blockage[INSN_UID (INSN)]
end_define

begin_define
define|#
directive|define
name|UNIT_BITS
value|5
end_define

begin_define
define|#
directive|define
name|BLOCKAGE_MASK
value|((1<< BLOCKAGE_BITS) - 1)
end_define

begin_define
define|#
directive|define
name|ENCODE_BLOCKAGE
parameter_list|(
name|U
parameter_list|,
name|R
parameter_list|)
define|\
value|((((U)<< UNIT_BITS)<< BLOCKAGE_BITS			\     | MIN_BLOCKAGE_COST (R))<< BLOCKAGE_BITS		\    | MAX_BLOCKAGE_COST (R))
end_define

begin_define
define|#
directive|define
name|UNIT_BLOCKED
parameter_list|(
name|B
parameter_list|)
value|((B)>> (2 * BLOCKAGE_BITS))
end_define

begin_define
define|#
directive|define
name|BLOCKAGE_RANGE
parameter_list|(
name|B
parameter_list|)
define|\
value|(((((B)>> BLOCKAGE_BITS)& BLOCKAGE_MASK)<< (HOST_BITS_PER_INT / 2)) \    | ((B)& BLOCKAGE_MASK))
end_define

begin_comment
comment|/* Encodings of the `<name>_unit_blockage_range' function.  */
end_comment

begin_define
define|#
directive|define
name|MIN_BLOCKAGE_COST
parameter_list|(
name|R
parameter_list|)
value|((R)>> (HOST_BITS_PER_INT / 2))
end_define

begin_define
define|#
directive|define
name|MAX_BLOCKAGE_COST
parameter_list|(
name|R
parameter_list|)
value|((R)& ((1<< (HOST_BITS_PER_INT / 2)) - 1))
end_define

begin_define
define|#
directive|define
name|DONE_PRIORITY
value|-1
end_define

begin_define
define|#
directive|define
name|MAX_PRIORITY
value|0x7fffffff
end_define

begin_define
define|#
directive|define
name|TAIL_PRIORITY
value|0x7ffffffe
end_define

begin_define
define|#
directive|define
name|LAUNCH_PRIORITY
value|0x7f000001
end_define

begin_define
define|#
directive|define
name|DONE_PRIORITY_P
parameter_list|(
name|INSN
parameter_list|)
value|(INSN_PRIORITY (INSN)< 0)
end_define

begin_define
define|#
directive|define
name|LOW_PRIORITY_P
parameter_list|(
name|INSN
parameter_list|)
value|((INSN_PRIORITY (INSN)& 0x7f000000) == 0)
end_define

begin_comment
comment|/* Vector indexed by INSN_UID giving number of insns referring to this insn.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|insn_ref_count
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|INSN_REF_COUNT
parameter_list|(
name|INSN
parameter_list|)
value|(insn_ref_count[INSN_UID (INSN)])
end_define

begin_comment
comment|/* Vector indexed by INSN_UID giving line-number note in effect for each    insn.  For line-number notes, this indicates whether the note may be    reused.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|line_note
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|LINE_NOTE
parameter_list|(
name|INSN
parameter_list|)
value|(line_note[INSN_UID (INSN)])
end_define

begin_comment
comment|/* Vector indexed by basic block number giving the starting line-number    for each basic block.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|line_note_head
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of important notes we must keep around.  This is a pointer to the    last element in the list.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|note_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Regsets telling whether a given register is live or dead before the last    scheduled insn.  Must scan the instructions once before scheduling to    determine what registers are live or dead at the end of the block.  */
end_comment

begin_decl_stmt
specifier|static
name|regset
name|bb_dead_regs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|regset
name|bb_live_regs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Regset telling whether a given register is live after the insn currently    being scheduled.  Before processing an insn, this is equal to bb_live_regs    above.  This is used so that we can find registers that are newly born/dead    after processing an insn.  */
end_comment

begin_decl_stmt
specifier|static
name|regset
name|old_live_regs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The chain of REG_DEAD notes.  REG_DEAD notes are removed from all insns    during the initial scan and reused later.  If there are not exactly as    many REG_DEAD notes in the post scheduled code as there were in the    prescheduled code then we trigger an abort because this indicates a bug.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|dead_notes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Queues, etc.  */
end_comment

begin_comment
comment|/* An instruction is ready to be scheduled when all insns following it    have already been scheduled.  It is important to ensure that all    insns which use its result will not be executed until its result    has been computed.  An insn is maintained in one of four structures:     (P) the "Pending" set of insns which cannot be scheduled until    their dependencies have been satisfied.    (Q) the "Queued" set of insns that can be scheduled when sufficient    time has passed.    (R) the "Ready" list of unscheduled, uncommitted insns.    (S) the "Scheduled" list of insns.     Initially, all insns are either "Pending" or "Ready" depending on    whether their dependencies are satisfied.     Insns move from the "Ready" list to the "Scheduled" list as they    are committed to the schedule.  As this occurs, the insns in the    "Pending" list have their dependencies satisfied and move to either    the "Ready" list or the "Queued" set depending on whether    sufficient time has passed to make them ready.  As time passes,    insns move from the "Queued" set to the "Ready" list.  Insns may    move from the "Ready" list to the "Queued" set if they are blocked    due to a function unit conflict.     The "Pending" list (P) are the insns in the LOG_LINKS of the unscheduled    insns, i.e., those that are ready, queued, and pending.    The "Queued" set (Q) is implemented by the variable `insn_queue'.    The "Ready" list (R) is implemented by the variables `ready' and    `n_ready'.    The "Scheduled" list (S) is the new insn chain built by this pass.     The transition (R->S) is implemented in the scheduling loop in    `schedule_block' when the best insn to schedule is chosen.    The transition (R->Q) is implemented in `schedule_select' when an    insn is found to have a function unit conflict with the already    committed insns.    The transitions (P->R and P->Q) are implemented in `schedule_insn' as    insns move from the ready list to the scheduled list.    The transition (Q->R) is implemented at the top of the scheduling    loop in `schedule_block' as time passes or stalls are introduced.  */
end_comment

begin_comment
comment|/* Implement a circular buffer to delay instructions until sufficient    time has passed.  INSN_QUEUE_SIZE is a power of two larger than    MAX_BLOCKAGE and MAX_READY_COST computed by genattr.c.  This is the    longest time an isnsn may be queued.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|insn_queue
index|[
name|INSN_QUEUE_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|q_ptr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|q_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NEXT_Q
parameter_list|(
name|X
parameter_list|)
value|(((X)+1)& (INSN_QUEUE_SIZE-1))
end_define

begin_define
define|#
directive|define
name|NEXT_Q_AFTER
parameter_list|(
name|X
parameter_list|,
name|C
parameter_list|)
value|(((X)+C)& (INSN_QUEUE_SIZE-1))
end_define

begin_comment
comment|/* Vector indexed by INSN_UID giving the minimum clock tick at which    the insn becomes ready.  This is used to note timing constraints for    insns in the pending list.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|insn_tick
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|INSN_TICK
parameter_list|(
name|INSN
parameter_list|)
value|(insn_tick[INSN_UID (INSN)])
end_define

begin_comment
comment|/* Data structure for keeping track of register information    during that register's life.  */
end_comment

begin_struct
struct|struct
name|sometimes
block|{
name|int
name|regno
decl_stmt|;
name|int
name|live_length
decl_stmt|;
name|int
name|calls_crossed
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Forward declarations.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|add_dependence
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
expr|enum
name|reg_note
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remove_dependence
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|find_insn_list
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|insn_unit
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|blockage_range
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|clear_units
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|prepare_unit
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|actual_hazard_this_instance
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|rtx
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|schedule_unit
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|actual_hazard
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|rtx
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|potential_hazard
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|insn_cost
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|priority
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_pending_lists
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_insn_mem_dependence
name|PROTO
argument_list|(
operator|(
name|rtx
operator|*
operator|,
name|rtx
operator|*
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|flush_pending_lists
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sched_analyze_1
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sched_analyze_2
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sched_analyze_insn
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sched_analyze
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sched_note_set
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rank_for_schedule
name|PROTO
argument_list|(
operator|(
specifier|const
name|GENERIC_PTR
operator|,
specifier|const
name|GENERIC_PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|swap_sort
name|PROTO
argument_list|(
operator|(
name|rtx
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|queue_insn
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|birthing_insn_p
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|adjust_priority
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|schedule_insn
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|schedule_select
name|PROTO
argument_list|(
operator|(
name|rtx
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|create_reg_dead_note
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|attach_deaths
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|attach_deaths_insn
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|unlink_notes
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|new_sometimes_live
name|PROTO
argument_list|(
operator|(
expr|struct
name|sometimes
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|finish_sometimes_live
name|PROTO
argument_list|(
operator|(
expr|struct
name|sometimes
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|reemit_notes
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|schedule_block
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|split_hard_reg_notes
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|new_insn_dead_notes
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|update_n_sets
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Main entry point of this file.  */
end_comment

begin_decl_stmt
name|void
name|schedule_insns
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_define
define|#
directive|define
name|SIZE_FOR_MODE
parameter_list|(
name|X
parameter_list|)
value|(GET_MODE_SIZE (GET_MODE (X)))
end_define

begin_comment
comment|/* Helper functions for instruction scheduling.  */
end_comment

begin_comment
comment|/* Add ELEM wrapped in an INSN_LIST with reg note kind DEP_TYPE to the    LOG_LINKS of INSN, if not already there.  DEP_TYPE indicates the type    of dependence that this link represents.  */
end_comment

begin_function
specifier|static
name|void
name|add_dependence
parameter_list|(
name|insn
parameter_list|,
name|elem
parameter_list|,
name|dep_type
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|elem
decl_stmt|;
name|enum
name|reg_note
name|dep_type
decl_stmt|;
block|{
name|rtx
name|link
decl_stmt|,
name|next
decl_stmt|;
comment|/* Don't depend an insn on itself.  */
if|if
condition|(
name|insn
operator|==
name|elem
condition|)
return|return;
comment|/* If elem is part of a sequence that must be scheduled together, then      make the dependence point to the last insn of the sequence.      When HAVE_cc0, it is possible for NOTEs to exist between users and      setters of the condition codes, so we must skip past notes here.      Otherwise, NOTEs are impossible here.  */
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|elem
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
while|while
condition|(
name|next
operator|&&
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|NOTE
condition|)
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|next
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|next
operator|&&
name|SCHED_GROUP_P
argument_list|(
name|next
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
block|{
comment|/* Notes will never intervene here though, so don't bother checking 	 for them.  */
comment|/* We must reject CODE_LABELs, so that we don't get confused by one 	 that has LABEL_PRESERVE_P set, which is represented by the same 	 bit in the rtl as SCHED_GROUP_P.  A CODE_LABEL can never be 	 SCHED_GROUP_P.  */
while|while
condition|(
name|NEXT_INSN
argument_list|(
name|next
argument_list|)
operator|&&
name|SCHED_GROUP_P
argument_list|(
name|NEXT_INSN
argument_list|(
name|next
argument_list|)
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|next
argument_list|)
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|next
argument_list|)
expr_stmt|;
comment|/* Again, don't depend an insn on itself.  */
if|if
condition|(
name|insn
operator|==
name|next
condition|)
return|return;
comment|/* Make the dependence to NEXT, the last insn of the group, instead 	 of the original ELEM.  */
name|elem
operator|=
name|next
expr_stmt|;
block|}
comment|/* Check that we don't already have this dependence.  */
for|for
control|(
name|link
operator|=
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
operator|==
name|elem
condition|)
block|{
comment|/* If this is a more restrictive type of dependence than the existing 	   one, then change the existing dependence to this type.  */
if|if
condition|(
operator|(
name|int
operator|)
name|dep_type
operator|<
operator|(
name|int
operator|)
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
condition|)
name|PUT_REG_NOTE_KIND
argument_list|(
name|link
argument_list|,
name|dep_type
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Might want to check one level of transitivity to save conses.  */
name|link
operator|=
name|rtx_alloc
argument_list|(
name|INSN_LIST
argument_list|)
expr_stmt|;
comment|/* Insn dependency, not data dependency.  */
name|PUT_REG_NOTE_KIND
argument_list|(
name|link
argument_list|,
name|dep_type
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
operator|=
name|elem
expr_stmt|;
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
operator|=
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
operator|=
name|link
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove ELEM wrapped in an INSN_LIST from the LOG_LINKS    of INSN.  Abort if not found.  */
end_comment

begin_function
specifier|static
name|void
name|remove_dependence
parameter_list|(
name|insn
parameter_list|,
name|elem
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|elem
decl_stmt|;
block|{
name|rtx
name|prev
decl_stmt|,
name|link
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
for|for
control|(
name|prev
operator|=
literal|0
operator|,
name|link
operator|=
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
block|{
if|if
condition|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
operator|==
name|elem
condition|)
block|{
name|RTX_INTEGRATED_P
argument_list|(
name|link
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|prev
condition|)
name|XEXP
argument_list|(
name|prev
argument_list|,
literal|1
argument_list|)
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|prev
operator|=
name|link
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_escape
end_escape

begin_ifndef
ifndef|#
directive|ifndef
name|__GNUC__
end_ifndef

begin_define
define|#
directive|define
name|__inline
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Computation of memory dependencies.  */
end_comment

begin_comment
comment|/* The *_insns and *_mems are paired lists.  Each pending memory operation    will have a pointer to the MEM rtx on one list and a pointer to the    containing insn on the other list in the same place in the list.  */
end_comment

begin_comment
comment|/* We can't use add_dependence like the old code did, because a single insn    may have multiple memory accesses, and hence needs to be on the list    once for each memory access.  Add_dependence won't let you add an insn    to a list more than once.  */
end_comment

begin_comment
comment|/* An INSN_LIST containing all insns with pending read operations.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|pending_read_insns
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* An EXPR_LIST containing all MEM rtx's which are pending reads.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|pending_read_mems
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* An INSN_LIST containing all insns with pending write operations.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|pending_write_insns
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* An EXPR_LIST containing all MEM rtx's which are pending writes.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|pending_write_mems
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indicates the combined length of the two pending lists.  We must prevent    these lists from ever growing too large since the number of dependencies    produced is at least O(N*N), and execution time is at least O(4*N*N), as    a function of the length of these pending lists.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pending_lists_length
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* An INSN_LIST containing all INSN_LISTs allocated but currently unused.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|unused_insn_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* An EXPR_LIST containing all EXPR_LISTs allocated but currently unused.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|unused_expr_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The last insn upon which all memory references must depend.    This is an insn which flushed the pending lists, creating a dependency    between it and all previously pending memory references.  This creates    a barrier (or a checkpoint) which no memory reference is allowed to cross.     This includes all non constant CALL_INSNs.  When we do interprocedural    alias analysis, this restriction can be relaxed.    This may also be an INSN that writes memory if the pending lists grow    too large.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|last_pending_memory_flush
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The last function call we have seen.  All hard regs, and, of course,    the last function call, must depend on this.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|last_function_call
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The LOG_LINKS field of this is a list of insns which use a pseudo register    that does not already cross a call.  We create dependencies between each    of those insn and the next call insn, to ensure that they won't cross a call    after scheduling is done.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|sched_before_next_call
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to the last instruction scheduled.  Used by rank_for_schedule,    so that insns independent of the last scheduled insn will be preferred    over dependent instructions.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|last_scheduled_insn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Process an insn's memory dependencies.  There are four kinds of    dependencies:     (0) read dependence: read follows read    (1) true dependence: read follows write    (2) anti dependence: write follows read    (3) output dependence: write follows write     We are careful to build only dependencies which actually exist, and    use transitivity to avoid building too many links.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Return the INSN_LIST containing INSN in LIST, or NULL    if LIST does not contain INSN.  */
end_comment

begin_function
name|__inline
specifier|static
name|rtx
name|find_insn_list
parameter_list|(
name|insn
parameter_list|,
name|list
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|list
decl_stmt|;
block|{
while|while
condition|(
name|list
condition|)
block|{
if|if
condition|(
name|XEXP
argument_list|(
name|list
argument_list|,
literal|0
argument_list|)
operator|==
name|insn
condition|)
return|return
name|list
return|;
name|list
operator|=
name|XEXP
argument_list|(
name|list
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Compute the function units used by INSN.  This caches the value    returned by function_units_used.  A function unit is encoded as the    unit number if the value is non-negative and the compliment of a    mask if the value is negative.  A function unit index is the    non-negative encoding.  */
end_comment

begin_function
name|__inline
specifier|static
name|int
name|insn_unit
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
specifier|register
name|int
name|unit
init|=
name|INSN_UNIT
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|unit
operator|==
literal|0
condition|)
block|{
name|recog_memoized
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* A USE insn, or something else we don't need to understand. 	 We can't pass these directly to function_units_used because it will 	 trigger a fatal error for unrecognizable insns.  */
if|if
condition|(
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|<
literal|0
condition|)
name|unit
operator|=
operator|-
literal|1
expr_stmt|;
else|else
block|{
name|unit
operator|=
name|function_units_used
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Increment non-negative values so we can cache zero.  */
if|if
condition|(
name|unit
operator|>=
literal|0
condition|)
name|unit
operator|++
expr_stmt|;
block|}
comment|/* We only cache 16 bits of the result, so if the value is out of 	 range, don't cache it.  */
if|if
condition|(
name|FUNCTION_UNITS_SIZE
operator|<
name|HOST_BITS_PER_SHORT
operator|||
name|unit
operator|>=
literal|0
operator|||
operator|(
name|unit
operator|&
operator|~
operator|(
operator|(
literal|1
operator|<<
operator|(
name|HOST_BITS_PER_SHORT
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
name|INSN_UNIT
argument_list|(
name|insn
argument_list|)
operator|=
name|unit
expr_stmt|;
block|}
return|return
operator|(
name|unit
operator|>
literal|0
condition|?
name|unit
operator|-
literal|1
else|:
name|unit
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Compute the blockage range for executing INSN on UNIT.  This caches    the value returned by the blockage_range_function for the unit.    These values are encoded in an int where the upper half gives the    minimum value and the lower half gives the maximum value.  */
end_comment

begin_function
name|__inline
specifier|static
name|unsigned
name|int
name|blockage_range
parameter_list|(
name|unit
parameter_list|,
name|insn
parameter_list|)
name|int
name|unit
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|unsigned
name|int
name|blockage
init|=
name|INSN_BLOCKAGE
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|range
decl_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|UNIT_BLOCKED
argument_list|(
name|blockage
argument_list|)
operator|!=
name|unit
operator|+
literal|1
condition|)
block|{
name|range
operator|=
name|function_units
index|[
name|unit
index|]
operator|.
name|blockage_range_function
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* We only cache the blockage range for one unit and then only if 	 the values fit.  */
if|if
condition|(
name|HOST_BITS_PER_INT
operator|>=
name|UNIT_BITS
operator|+
literal|2
operator|*
name|BLOCKAGE_BITS
condition|)
name|INSN_BLOCKAGE
argument_list|(
name|insn
argument_list|)
operator|=
name|ENCODE_BLOCKAGE
argument_list|(
name|unit
operator|+
literal|1
argument_list|,
name|range
argument_list|)
expr_stmt|;
block|}
else|else
name|range
operator|=
name|BLOCKAGE_RANGE
argument_list|(
name|blockage
argument_list|)
expr_stmt|;
return|return
name|range
return|;
block|}
end_function

begin_comment
comment|/* A vector indexed by function unit instance giving the last insn to use    the unit.  The value of the function unit instance index for unit U    instance I is (U + I * FUNCTION_UNITS_SIZE).  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|unit_last_insn
index|[
name|FUNCTION_UNITS_SIZE
operator|*
name|MAX_MULTIPLICITY
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A vector indexed by function unit instance giving the minimum time when    the unit will unblock based on the maximum blockage cost.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|unit_tick
index|[
name|FUNCTION_UNITS_SIZE
operator|*
name|MAX_MULTIPLICITY
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A vector indexed by function unit number giving the number of insns    that remain to use the unit.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|unit_n_insns
index|[
name|FUNCTION_UNITS_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Reset the function unit state to the null state.  */
end_comment

begin_function
specifier|static
name|void
name|clear_units
parameter_list|()
block|{
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|unit_last_insn
argument_list|,
sizeof|sizeof
argument_list|(
name|unit_last_insn
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|unit_tick
argument_list|,
sizeof|sizeof
argument_list|(
name|unit_tick
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|unit_n_insns
argument_list|,
sizeof|sizeof
argument_list|(
name|unit_n_insns
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record an insn as one that will use the units encoded by UNIT.  */
end_comment

begin_function
name|__inline
specifier|static
name|void
name|prepare_unit
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
literal|0
condition|)
name|unit_n_insns
index|[
name|unit
index|]
operator|++
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|unit
operator|=
operator|~
name|unit
init|;
name|unit
condition|;
name|i
operator|++
operator|,
name|unit
operator|>>=
literal|1
control|)
if|if
condition|(
operator|(
name|unit
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|prepare_unit
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the actual hazard cost of executing INSN on the unit UNIT,    instance INSTANCE at time CLOCK if the previous actual hazard cost    was COST.  */
end_comment

begin_function
name|__inline
specifier|static
name|int
name|actual_hazard_this_instance
parameter_list|(
name|unit
parameter_list|,
name|instance
parameter_list|,
name|insn
parameter_list|,
name|clock
parameter_list|,
name|cost
parameter_list|)
name|int
name|unit
decl_stmt|,
name|instance
decl_stmt|,
name|clock
decl_stmt|,
name|cost
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|tick
init|=
name|unit_tick
index|[
name|instance
index|]
decl_stmt|;
if|if
condition|(
name|tick
operator|-
name|clock
operator|>
name|cost
condition|)
block|{
comment|/* The scheduler is operating in reverse, so INSN is the executing 	 insn and the unit's last insn is the candidate insn.  We want a 	 more exact measure of the blockage if we execute INSN at CLOCK 	 given when we committed the execution of the unit's last insn.  	 The blockage value is given by either the unit's max blockage 	 constant, blockage range function, or blockage function.  Use 	 the most exact form for the given unit.  */
if|if
condition|(
name|function_units
index|[
name|unit
index|]
operator|.
name|blockage_range_function
condition|)
block|{
if|if
condition|(
name|function_units
index|[
name|unit
index|]
operator|.
name|blockage_function
condition|)
name|tick
operator|+=
operator|(
name|function_units
index|[
name|unit
index|]
operator|.
name|blockage_function
argument_list|(
name|insn
argument_list|,
name|unit_last_insn
index|[
name|instance
index|]
argument_list|)
operator|-
name|function_units
index|[
name|unit
index|]
operator|.
name|max_blockage
operator|)
expr_stmt|;
else|else
name|tick
operator|+=
operator|(
operator|(
name|int
operator|)
name|MAX_BLOCKAGE_COST
argument_list|(
name|blockage_range
argument_list|(
name|unit
argument_list|,
name|insn
argument_list|)
argument_list|)
operator|-
name|function_units
index|[
name|unit
index|]
operator|.
name|max_blockage
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|tick
operator|-
name|clock
operator|>
name|cost
condition|)
name|cost
operator|=
name|tick
operator|-
name|clock
expr_stmt|;
block|}
return|return
name|cost
return|;
block|}
end_function

begin_comment
comment|/* Record INSN as having begun execution on the units encoded by UNIT at    time CLOCK.  */
end_comment

begin_function
name|__inline
specifier|static
name|void
name|schedule_unit
parameter_list|(
name|unit
parameter_list|,
name|insn
parameter_list|,
name|clock
parameter_list|)
name|int
name|unit
decl_stmt|,
name|clock
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
literal|0
condition|)
block|{
name|int
name|instance
init|=
name|unit
decl_stmt|;
if|#
directive|if
name|MAX_MULTIPLICITY
operator|>
literal|1
comment|/* Find the first free instance of the function unit and use that 	 one.  We assume that one is free.  */
for|for
control|(
name|i
operator|=
name|function_units
index|[
name|unit
index|]
operator|.
name|multiplicity
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
operator|!
name|actual_hazard_this_instance
argument_list|(
name|unit
argument_list|,
name|instance
argument_list|,
name|insn
argument_list|,
name|clock
argument_list|,
literal|0
argument_list|)
condition|)
break|break;
name|instance
operator|+=
name|FUNCTION_UNITS_SIZE
expr_stmt|;
block|}
endif|#
directive|endif
name|unit_last_insn
index|[
name|instance
index|]
operator|=
name|insn
expr_stmt|;
name|unit_tick
index|[
name|instance
index|]
operator|=
operator|(
name|clock
operator|+
name|function_units
index|[
name|unit
index|]
operator|.
name|max_blockage
operator|)
expr_stmt|;
block|}
else|else
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|unit
operator|=
operator|~
name|unit
init|;
name|unit
condition|;
name|i
operator|++
operator|,
name|unit
operator|>>=
literal|1
control|)
if|if
condition|(
operator|(
name|unit
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|schedule_unit
argument_list|(
name|i
argument_list|,
name|insn
argument_list|,
name|clock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the actual hazard cost of executing INSN on the units encoded by    UNIT at time CLOCK if the previous actual hazard cost was COST.  */
end_comment

begin_function
name|__inline
specifier|static
name|int
name|actual_hazard
parameter_list|(
name|unit
parameter_list|,
name|insn
parameter_list|,
name|clock
parameter_list|,
name|cost
parameter_list|)
name|int
name|unit
decl_stmt|,
name|clock
decl_stmt|,
name|cost
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
literal|0
condition|)
block|{
comment|/* Find the instance of the function unit with the minimum hazard.  */
name|int
name|instance
init|=
name|unit
decl_stmt|;
name|int
name|best_cost
init|=
name|actual_hazard_this_instance
argument_list|(
name|unit
argument_list|,
name|instance
argument_list|,
name|insn
argument_list|,
name|clock
argument_list|,
name|cost
argument_list|)
decl_stmt|;
if|#
directive|if
name|MAX_MULTIPLICITY
operator|>
literal|1
name|int
name|this_cost
decl_stmt|;
if|if
condition|(
name|best_cost
operator|>
name|cost
condition|)
block|{
for|for
control|(
name|i
operator|=
name|function_units
index|[
name|unit
index|]
operator|.
name|multiplicity
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|instance
operator|+=
name|FUNCTION_UNITS_SIZE
expr_stmt|;
name|this_cost
operator|=
name|actual_hazard_this_instance
argument_list|(
name|unit
argument_list|,
name|instance
argument_list|,
name|insn
argument_list|,
name|clock
argument_list|,
name|cost
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_cost
operator|<
name|best_cost
condition|)
block|{
name|best_cost
operator|=
name|this_cost
expr_stmt|;
if|if
condition|(
name|this_cost
operator|<=
name|cost
condition|)
break|break;
block|}
block|}
block|}
endif|#
directive|endif
name|cost
operator|=
name|MAX
argument_list|(
name|cost
argument_list|,
name|best_cost
argument_list|)
expr_stmt|;
block|}
else|else
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|unit
operator|=
operator|~
name|unit
init|;
name|unit
condition|;
name|i
operator|++
operator|,
name|unit
operator|>>=
literal|1
control|)
if|if
condition|(
operator|(
name|unit
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|cost
operator|=
name|actual_hazard
argument_list|(
name|i
argument_list|,
name|insn
argument_list|,
name|clock
argument_list|,
name|cost
argument_list|)
expr_stmt|;
return|return
name|cost
return|;
block|}
end_function

begin_comment
comment|/* Return the potential hazard cost of executing an instruction on the    units encoded by UNIT if the previous potential hazard cost was COST.    An insn with a large blockage time is chosen in preference to one    with a smaller time; an insn that uses a unit that is more likely    to be used is chosen in preference to one with a unit that is less    used.  We are trying to minimize a subsequent actual hazard.  */
end_comment

begin_function
name|__inline
specifier|static
name|int
name|potential_hazard
parameter_list|(
name|unit
parameter_list|,
name|insn
parameter_list|,
name|cost
parameter_list|)
name|int
name|unit
decl_stmt|,
name|cost
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|ncost
decl_stmt|;
name|unsigned
name|int
name|minb
decl_stmt|,
name|maxb
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
literal|0
condition|)
block|{
name|minb
operator|=
name|maxb
operator|=
name|function_units
index|[
name|unit
index|]
operator|.
name|max_blockage
expr_stmt|;
if|if
condition|(
name|maxb
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|function_units
index|[
name|unit
index|]
operator|.
name|blockage_range_function
condition|)
block|{
name|maxb
operator|=
name|minb
operator|=
name|blockage_range
argument_list|(
name|unit
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|maxb
operator|=
name|MAX_BLOCKAGE_COST
argument_list|(
name|maxb
argument_list|)
expr_stmt|;
name|minb
operator|=
name|MIN_BLOCKAGE_COST
argument_list|(
name|minb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|maxb
operator|>
literal|1
condition|)
block|{
comment|/* Make the number of instructions left dominate.  Make the 		 minimum delay dominate the maximum delay.  If all these 		 are the same, use the unit number to add an arbitrary 		 ordering.  Other terms can be added.  */
name|ncost
operator|=
name|minb
operator|*
literal|0x40
operator|+
name|maxb
expr_stmt|;
name|ncost
operator|*=
operator|(
name|unit_n_insns
index|[
name|unit
index|]
operator|-
literal|1
operator|)
operator|*
literal|0x1000
operator|+
name|unit
expr_stmt|;
if|if
condition|(
name|ncost
operator|>
name|cost
condition|)
name|cost
operator|=
name|ncost
expr_stmt|;
block|}
block|}
block|}
else|else
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|unit
operator|=
operator|~
name|unit
init|;
name|unit
condition|;
name|i
operator|++
operator|,
name|unit
operator|>>=
literal|1
control|)
if|if
condition|(
operator|(
name|unit
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|cost
operator|=
name|potential_hazard
argument_list|(
name|i
argument_list|,
name|insn
argument_list|,
name|cost
argument_list|)
expr_stmt|;
return|return
name|cost
return|;
block|}
end_function

begin_comment
comment|/* Compute cost of executing INSN given the dependence LINK on the insn USED.    This is the number of virtual cycles taken between instruction issue and    instruction results.  */
end_comment

begin_function
name|__inline
specifier|static
name|int
name|insn_cost
parameter_list|(
name|insn
parameter_list|,
name|link
parameter_list|,
name|used
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|link
decl_stmt|,
name|used
decl_stmt|;
block|{
specifier|register
name|int
name|cost
init|=
name|INSN_COST
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|cost
operator|==
literal|0
condition|)
block|{
name|recog_memoized
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* A USE insn, or something else we don't need to understand. 	 We can't pass these directly to result_ready_cost because it will 	 trigger a fatal error for unrecognizable insns.  */
if|if
condition|(
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|<
literal|0
condition|)
block|{
name|INSN_COST
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
name|cost
operator|=
name|result_ready_cost
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|cost
operator|<
literal|1
condition|)
name|cost
operator|=
literal|1
expr_stmt|;
name|INSN_COST
argument_list|(
name|insn
argument_list|)
operator|=
name|cost
expr_stmt|;
block|}
block|}
comment|/* A USE insn should never require the value used to be computed.  This      allows the computation of a function's result and parameter values to      overlap the return and call.  */
name|recog_memoized
argument_list|(
name|used
argument_list|)
expr_stmt|;
if|if
condition|(
name|INSN_CODE
argument_list|(
name|used
argument_list|)
operator|<
literal|0
condition|)
name|LINK_COST_FREE
argument_list|(
name|link
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If some dependencies vary the cost, compute the adjustment.  Most      commonly, the adjustment is complete: either the cost is ignored      (in the case of an output- or anti-dependence), or the cost is      unchanged.  These values are cached in the link as LINK_COST_FREE      and LINK_COST_ZERO.  */
if|if
condition|(
name|LINK_COST_FREE
argument_list|(
name|link
argument_list|)
condition|)
name|cost
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|ADJUST_COST
elseif|else
if|if
condition|(
operator|!
name|LINK_COST_ZERO
argument_list|(
name|link
argument_list|)
condition|)
block|{
name|int
name|ncost
init|=
name|cost
decl_stmt|;
name|ADJUST_COST
argument_list|(
name|used
argument_list|,
name|link
argument_list|,
name|insn
argument_list|,
name|ncost
argument_list|)
expr_stmt|;
if|if
condition|(
name|ncost
operator|<=
literal|1
condition|)
name|LINK_COST_FREE
argument_list|(
name|link
argument_list|)
operator|=
name|ncost
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|cost
operator|==
name|ncost
condition|)
name|LINK_COST_ZERO
argument_list|(
name|link
argument_list|)
operator|=
literal|1
expr_stmt|;
name|cost
operator|=
name|ncost
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|cost
return|;
block|}
end_function

begin_comment
comment|/* Compute the priority number for INSN.  */
end_comment

begin_function
specifier|static
name|int
name|priority
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
if|if
condition|(
name|insn
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
block|{
name|int
name|prev_priority
decl_stmt|;
name|int
name|max_priority
decl_stmt|;
name|int
name|this_priority
init|=
name|INSN_PRIORITY
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|prev
decl_stmt|;
if|if
condition|(
name|this_priority
operator|>
literal|0
condition|)
return|return
name|this_priority
return|;
name|max_priority
operator|=
literal|1
expr_stmt|;
comment|/* Nonzero if these insns must be scheduled together.  */
if|if
condition|(
name|SCHED_GROUP_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|prev
operator|=
name|insn
expr_stmt|;
while|while
condition|(
name|SCHED_GROUP_P
argument_list|(
name|prev
argument_list|)
condition|)
block|{
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|prev
argument_list|)
expr_stmt|;
name|INSN_REF_COUNT
argument_list|(
name|prev
argument_list|)
operator|+=
literal|1
expr_stmt|;
block|}
block|}
for|for
control|(
name|prev
operator|=
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
init|;
name|prev
condition|;
name|prev
operator|=
name|XEXP
argument_list|(
name|prev
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|rtx
name|x
init|=
name|XEXP
argument_list|(
name|prev
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* If this was a duplicate of a dependence we already deleted, 	     ignore it.  */
if|if
condition|(
name|RTX_INTEGRATED_P
argument_list|(
name|prev
argument_list|)
condition|)
continue|continue;
comment|/* A dependence pointing to a note or deleted insn is always 	     obsolete, because sched_analyze_insn will have created any 	     necessary new dependences which replace it.  Notes and deleted 	     insns can be created when instructions are deleted by insn 	     splitting, or by register allocation.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|NOTE
operator|||
name|INSN_DELETED_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|remove_dependence
argument_list|(
name|insn
argument_list|,
name|x
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Clear the link cost adjustment bits.  */
name|LINK_COST_FREE
argument_list|(
name|prev
argument_list|)
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|ADJUST_COST
name|LINK_COST_ZERO
argument_list|(
name|prev
argument_list|)
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* This priority calculation was chosen because it results in the 	     least instruction movement, and does not hurt the performance 	     of the resulting code compared to the old algorithm. 	     This makes the sched algorithm more stable, which results 	     in better code, because there is less register pressure, 	     cross jumping is more likely to work, and debugging is easier.  	     When all instructions have a latency of 1, there is no need to 	     move any instructions.  Subtracting one here ensures that in such 	     cases all instructions will end up with a priority of one, and 	     hence no scheduling will be done.  	     The original code did not subtract the one, and added the 	     insn_cost of the current instruction to its priority (e.g. 	     move the insn_cost call down to the end).  */
name|prev_priority
operator|=
name|priority
argument_list|(
name|x
argument_list|)
operator|+
name|insn_cost
argument_list|(
name|x
argument_list|,
name|prev
argument_list|,
name|insn
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|prev_priority
operator|>
name|max_priority
condition|)
name|max_priority
operator|=
name|prev_priority
expr_stmt|;
name|INSN_REF_COUNT
argument_list|(
name|x
argument_list|)
operator|+=
literal|1
expr_stmt|;
block|}
name|prepare_unit
argument_list|(
name|insn_unit
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|INSN_PRIORITY
argument_list|(
name|insn
argument_list|)
operator|=
name|max_priority
expr_stmt|;
return|return
name|INSN_PRIORITY
argument_list|(
name|insn
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Remove all INSN_LISTs and EXPR_LISTs from the pending lists and add    them to the unused_*_list variables, so that they can be reused.  */
end_comment

begin_function
specifier|static
name|void
name|free_pending_lists
parameter_list|()
block|{
specifier|register
name|rtx
name|link
decl_stmt|,
name|prev_link
decl_stmt|;
if|if
condition|(
name|pending_read_insns
condition|)
block|{
name|prev_link
operator|=
name|pending_read_insns
expr_stmt|;
name|link
operator|=
name|XEXP
argument_list|(
name|prev_link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|link
condition|)
block|{
name|prev_link
operator|=
name|link
expr_stmt|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|XEXP
argument_list|(
name|prev_link
argument_list|,
literal|1
argument_list|)
operator|=
name|unused_insn_list
expr_stmt|;
name|unused_insn_list
operator|=
name|pending_read_insns
expr_stmt|;
name|pending_read_insns
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|pending_write_insns
condition|)
block|{
name|prev_link
operator|=
name|pending_write_insns
expr_stmt|;
name|link
operator|=
name|XEXP
argument_list|(
name|prev_link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|link
condition|)
block|{
name|prev_link
operator|=
name|link
expr_stmt|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|XEXP
argument_list|(
name|prev_link
argument_list|,
literal|1
argument_list|)
operator|=
name|unused_insn_list
expr_stmt|;
name|unused_insn_list
operator|=
name|pending_write_insns
expr_stmt|;
name|pending_write_insns
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|pending_read_mems
condition|)
block|{
name|prev_link
operator|=
name|pending_read_mems
expr_stmt|;
name|link
operator|=
name|XEXP
argument_list|(
name|prev_link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|link
condition|)
block|{
name|prev_link
operator|=
name|link
expr_stmt|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|XEXP
argument_list|(
name|prev_link
argument_list|,
literal|1
argument_list|)
operator|=
name|unused_expr_list
expr_stmt|;
name|unused_expr_list
operator|=
name|pending_read_mems
expr_stmt|;
name|pending_read_mems
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|pending_write_mems
condition|)
block|{
name|prev_link
operator|=
name|pending_write_mems
expr_stmt|;
name|link
operator|=
name|XEXP
argument_list|(
name|prev_link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|link
condition|)
block|{
name|prev_link
operator|=
name|link
expr_stmt|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|XEXP
argument_list|(
name|prev_link
argument_list|,
literal|1
argument_list|)
operator|=
name|unused_expr_list
expr_stmt|;
name|unused_expr_list
operator|=
name|pending_write_mems
expr_stmt|;
name|pending_write_mems
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Add an INSN and MEM reference pair to a pending INSN_LIST and MEM_LIST.    The MEM is a memory reference contained within INSN, which we are saving    so that we can do memory aliasing on it.  */
end_comment

begin_function
specifier|static
name|void
name|add_insn_mem_dependence
parameter_list|(
name|insn_list
parameter_list|,
name|mem_list
parameter_list|,
name|insn
parameter_list|,
name|mem
parameter_list|)
name|rtx
modifier|*
name|insn_list
decl_stmt|,
decl|*
name|mem_list
decl_stmt|,
name|insn
decl_stmt|,
name|mem
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|rtx
name|link
decl_stmt|;
if|if
condition|(
name|unused_insn_list
condition|)
block|{
name|link
operator|=
name|unused_insn_list
expr_stmt|;
name|unused_insn_list
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|link
operator|=
name|rtx_alloc
argument_list|(
name|INSN_LIST
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
operator|=
name|insn
expr_stmt|;
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
operator|=
operator|*
name|insn_list
expr_stmt|;
operator|*
name|insn_list
operator|=
name|link
expr_stmt|;
if|if
condition|(
name|unused_expr_list
condition|)
block|{
name|link
operator|=
name|unused_expr_list
expr_stmt|;
name|unused_expr_list
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|link
operator|=
name|rtx_alloc
argument_list|(
name|EXPR_LIST
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
operator|=
name|mem
expr_stmt|;
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
operator|=
operator|*
name|mem_list
expr_stmt|;
operator|*
name|mem_list
operator|=
name|link
expr_stmt|;
name|pending_lists_length
operator|++
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Make a dependency between every memory reference on the pending lists    and INSN, thus flushing the pending lists.  If ONLY_WRITE, don't flush    the read list.  */
end_comment

begin_function
specifier|static
name|void
name|flush_pending_lists
parameter_list|(
name|insn
parameter_list|,
name|only_write
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|int
name|only_write
decl_stmt|;
block|{
name|rtx
name|link
decl_stmt|;
while|while
condition|(
name|pending_read_insns
operator|&&
operator|!
name|only_write
condition|)
block|{
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|pending_read_insns
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|link
operator|=
name|pending_read_insns
expr_stmt|;
name|pending_read_insns
operator|=
name|XEXP
argument_list|(
name|pending_read_insns
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
operator|=
name|unused_insn_list
expr_stmt|;
name|unused_insn_list
operator|=
name|link
expr_stmt|;
name|link
operator|=
name|pending_read_mems
expr_stmt|;
name|pending_read_mems
operator|=
name|XEXP
argument_list|(
name|pending_read_mems
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
operator|=
name|unused_expr_list
expr_stmt|;
name|unused_expr_list
operator|=
name|link
expr_stmt|;
block|}
while|while
condition|(
name|pending_write_insns
condition|)
block|{
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|pending_write_insns
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|link
operator|=
name|pending_write_insns
expr_stmt|;
name|pending_write_insns
operator|=
name|XEXP
argument_list|(
name|pending_write_insns
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
operator|=
name|unused_insn_list
expr_stmt|;
name|unused_insn_list
operator|=
name|link
expr_stmt|;
name|link
operator|=
name|pending_write_mems
expr_stmt|;
name|pending_write_mems
operator|=
name|XEXP
argument_list|(
name|pending_write_mems
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
operator|=
name|unused_expr_list
expr_stmt|;
name|unused_expr_list
operator|=
name|link
expr_stmt|;
block|}
name|pending_lists_length
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|last_pending_memory_flush
condition|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|last_pending_memory_flush
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|last_pending_memory_flush
operator|=
name|insn
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Analyze a single SET or CLOBBER rtx, X, creating all dependencies generated    by the write to the destination of X, and reads of everything mentioned.  */
end_comment

begin_function
specifier|static
name|void
name|sched_analyze_1
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
specifier|register
name|int
name|regno
decl_stmt|;
specifier|register
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|dest
operator|==
literal|0
condition|)
return|return;
while|while
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SIGN_EXTRACT
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SIGN_EXTRACT
condition|)
block|{
comment|/* The second and third arguments are values read by this insn.  */
name|sched_analyze_2
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|1
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|sched_analyze_2
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|2
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
name|dest
operator|=
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|regno
operator|=
name|REGNO
argument_list|(
name|dest
argument_list|)
expr_stmt|;
comment|/* A hard reg in a wide mode may really be multiple registers. 	 If so, mark all of them just like the first.  */
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|i
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
block|{
name|rtx
name|u
decl_stmt|;
for|for
control|(
name|u
operator|=
name|reg_last_uses
index|[
name|regno
operator|+
name|i
index|]
init|;
name|u
condition|;
name|u
operator|=
name|XEXP
argument_list|(
name|u
argument_list|,
literal|1
argument_list|)
control|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|u
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|reg_last_uses
index|[
name|regno
operator|+
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|reg_last_sets
index|[
name|regno
operator|+
name|i
index|]
condition|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|reg_last_sets
index|[
name|regno
operator|+
name|i
index|]
argument_list|,
name|REG_DEP_OUTPUT
argument_list|)
expr_stmt|;
name|SET_REGNO_REG_SET
argument_list|(
name|reg_pending_sets
argument_list|,
name|regno
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|call_used_regs
index|[
name|i
index|]
operator|||
name|global_regs
index|[
name|i
index|]
operator|)
operator|&&
name|last_function_call
condition|)
comment|/* Function calls clobber all call_used regs.  */
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|last_function_call
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|rtx
name|u
decl_stmt|;
for|for
control|(
name|u
operator|=
name|reg_last_uses
index|[
name|regno
index|]
init|;
name|u
condition|;
name|u
operator|=
name|XEXP
argument_list|(
name|u
argument_list|,
literal|1
argument_list|)
control|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|u
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|reg_last_uses
index|[
name|regno
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|reg_last_sets
index|[
name|regno
index|]
condition|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|reg_last_sets
index|[
name|regno
index|]
argument_list|,
name|REG_DEP_OUTPUT
argument_list|)
expr_stmt|;
name|SET_REGNO_REG_SET
argument_list|(
name|reg_pending_sets
argument_list|,
name|regno
argument_list|)
expr_stmt|;
comment|/* Pseudos that are REG_EQUIV to something may be replaced 	     by that during reloading.  We need only add dependencies for 	     the address in the REG_EQUIV note.  */
if|if
condition|(
operator|!
name|reload_completed
operator|&&
name|reg_known_equiv_p
index|[
name|regno
index|]
operator|&&
name|GET_CODE
argument_list|(
name|reg_known_value
index|[
name|regno
index|]
argument_list|)
operator|==
name|MEM
condition|)
name|sched_analyze_2
argument_list|(
name|XEXP
argument_list|(
name|reg_known_value
index|[
name|regno
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Don't let it cross a call after scheduling if it doesn't 	     already cross one.  */
if|if
condition|(
name|REG_N_CALLS_CROSSED
argument_list|(
name|regno
argument_list|)
operator|==
literal|0
operator|&&
name|last_function_call
condition|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|last_function_call
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
condition|)
block|{
comment|/* Writing memory.  */
if|if
condition|(
name|pending_lists_length
operator|>
literal|32
condition|)
block|{
comment|/* Flush all pending reads and writes to prevent the pending lists 	     from getting any larger.  Insn scheduling runs too slowly when 	     these lists get long.  The number 32 was chosen because it 	     seems like a reasonable number.  When compiling GCC with itself, 	     this flush occurs 8 times for sparc, and 10 times for m88k using 	     the number 32.  */
name|flush_pending_lists
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|pending
decl_stmt|,
name|pending_mem
decl_stmt|;
name|pending
operator|=
name|pending_read_insns
expr_stmt|;
name|pending_mem
operator|=
name|pending_read_mems
expr_stmt|;
while|while
condition|(
name|pending
condition|)
block|{
comment|/* If a dependency already exists, don't create a new one.  */
if|if
condition|(
operator|!
name|find_insn_list
argument_list|(
name|XEXP
argument_list|(
name|pending
argument_list|,
literal|0
argument_list|)
argument_list|,
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
if|if
condition|(
name|anti_dependence
argument_list|(
name|XEXP
argument_list|(
name|pending_mem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|dest
argument_list|)
condition|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|pending
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|pending
operator|=
name|XEXP
argument_list|(
name|pending
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pending_mem
operator|=
name|XEXP
argument_list|(
name|pending_mem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|pending
operator|=
name|pending_write_insns
expr_stmt|;
name|pending_mem
operator|=
name|pending_write_mems
expr_stmt|;
while|while
condition|(
name|pending
condition|)
block|{
comment|/* If a dependency already exists, don't create a new one.  */
if|if
condition|(
operator|!
name|find_insn_list
argument_list|(
name|XEXP
argument_list|(
name|pending
argument_list|,
literal|0
argument_list|)
argument_list|,
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
if|if
condition|(
name|output_dependence
argument_list|(
name|XEXP
argument_list|(
name|pending_mem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|dest
argument_list|)
condition|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|pending
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_DEP_OUTPUT
argument_list|)
expr_stmt|;
name|pending
operator|=
name|XEXP
argument_list|(
name|pending
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pending_mem
operator|=
name|XEXP
argument_list|(
name|pending_mem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|last_pending_memory_flush
condition|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|last_pending_memory_flush
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|add_insn_mem_dependence
argument_list|(
operator|&
name|pending_write_insns
argument_list|,
operator|&
name|pending_write_mems
argument_list|,
name|insn
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
name|sched_analyze_2
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* Analyze reads.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
condition|)
name|sched_analyze_2
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Analyze the uses of memory and registers in rtx X in INSN.  */
end_comment

begin_function
specifier|static
name|void
name|sched_analyze_2
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST
case|:
case|case
name|LABEL_REF
case|:
comment|/* Ignore constants.  Note that we must handle CONST_DOUBLE here 	 because it may have a cc0_rtx in its CONST_DOUBLE_CHAIN field, but 	 this does not mean that this insn is using cc0.  */
return|return;
ifdef|#
directive|ifdef
name|HAVE_cc0
case|case
name|CC0
case|:
block|{
name|rtx
name|link
decl_stmt|,
name|prev
decl_stmt|;
comment|/* User of CC0 depends on immediately preceding insn.  */
name|SCHED_GROUP_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* There may be a note before this insn now, but all notes will 	   be removed before we actually try to schedule the insns, so 	   it won't cause a problem later.  We must avoid it here though.  */
name|prev
operator|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Make a copy of all dependencies on the immediately previous insn, 	   and add to this insn.  This is so that all the dependencies will 	   apply to the group.  Remove an explicit dependence on this insn 	   as SCHED_GROUP_P now represents it.  */
if|if
condition|(
name|find_insn_list
argument_list|(
name|prev
argument_list|,
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
name|remove_dependence
argument_list|(
name|insn
argument_list|,
name|prev
argument_list|)
expr_stmt|;
for|for
control|(
name|link
operator|=
name|LOG_LINKS
argument_list|(
name|prev
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
case|case
name|REG
case|:
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|i
decl_stmt|;
name|i
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
block|{
name|reg_last_uses
index|[
name|regno
operator|+
name|i
index|]
operator|=
name|gen_rtx_INSN_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|insn
argument_list|,
name|reg_last_uses
index|[
name|regno
operator|+
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_last_sets
index|[
name|regno
operator|+
name|i
index|]
condition|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|reg_last_sets
index|[
name|regno
operator|+
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|call_used_regs
index|[
name|regno
operator|+
name|i
index|]
operator|||
name|global_regs
index|[
name|regno
operator|+
name|i
index|]
operator|)
operator|&&
name|last_function_call
condition|)
comment|/* Function calls clobber all call_used regs.  */
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|last_function_call
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|reg_last_uses
index|[
name|regno
index|]
operator|=
name|gen_rtx_INSN_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|insn
argument_list|,
name|reg_last_uses
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_last_sets
index|[
name|regno
index|]
condition|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|reg_last_sets
index|[
name|regno
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Pseudos that are REG_EQUIV to something may be replaced 	       by that during reloading.  We need only add dependencies for 	       the address in the REG_EQUIV note.  */
if|if
condition|(
operator|!
name|reload_completed
operator|&&
name|reg_known_equiv_p
index|[
name|regno
index|]
operator|&&
name|GET_CODE
argument_list|(
name|reg_known_value
index|[
name|regno
index|]
argument_list|)
operator|==
name|MEM
condition|)
name|sched_analyze_2
argument_list|(
name|XEXP
argument_list|(
name|reg_known_value
index|[
name|regno
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* If the register does not already cross any calls, then add this 	       insn to the sched_before_next_call list so that it will still 	       not cross calls after scheduling.  */
if|if
condition|(
name|REG_N_CALLS_CROSSED
argument_list|(
name|regno
argument_list|)
operator|==
literal|0
condition|)
name|add_dependence
argument_list|(
name|sched_before_next_call
argument_list|,
name|insn
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
case|case
name|MEM
case|:
block|{
comment|/* Reading memory.  */
name|rtx
name|pending
decl_stmt|,
name|pending_mem
decl_stmt|;
name|pending
operator|=
name|pending_read_insns
expr_stmt|;
name|pending_mem
operator|=
name|pending_read_mems
expr_stmt|;
while|while
condition|(
name|pending
condition|)
block|{
comment|/* If a dependency already exists, don't create a new one.  */
if|if
condition|(
operator|!
name|find_insn_list
argument_list|(
name|XEXP
argument_list|(
name|pending
argument_list|,
literal|0
argument_list|)
argument_list|,
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
if|if
condition|(
name|read_dependence
argument_list|(
name|XEXP
argument_list|(
name|pending_mem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|x
argument_list|)
condition|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|pending
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|pending
operator|=
name|XEXP
argument_list|(
name|pending
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pending_mem
operator|=
name|XEXP
argument_list|(
name|pending_mem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|pending
operator|=
name|pending_write_insns
expr_stmt|;
name|pending_mem
operator|=
name|pending_write_mems
expr_stmt|;
while|while
condition|(
name|pending
condition|)
block|{
comment|/* If a dependency already exists, don't create a new one.  */
if|if
condition|(
operator|!
name|find_insn_list
argument_list|(
name|XEXP
argument_list|(
name|pending
argument_list|,
literal|0
argument_list|)
argument_list|,
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
if|if
condition|(
name|true_dependence
argument_list|(
name|XEXP
argument_list|(
name|pending_mem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|VOIDmode
argument_list|,
name|x
argument_list|,
name|rtx_varies_p
argument_list|)
condition|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|pending
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pending
operator|=
name|XEXP
argument_list|(
name|pending
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pending_mem
operator|=
name|XEXP
argument_list|(
name|pending_mem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|last_pending_memory_flush
condition|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|last_pending_memory_flush
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
comment|/* Always add these dependencies to pending_reads, since 	   this insn may be followed by a write.  */
name|add_insn_mem_dependence
argument_list|(
operator|&
name|pending_read_insns
argument_list|,
operator|&
name|pending_read_mems
argument_list|,
name|insn
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* Take advantage of tail recursion here.  */
name|sched_analyze_2
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|ASM_OPERANDS
case|:
case|case
name|ASM_INPUT
case|:
case|case
name|UNSPEC_VOLATILE
case|:
case|case
name|TRAP_IF
case|:
block|{
name|rtx
name|u
decl_stmt|;
comment|/* Traditional and volatile asm instructions must be considered to use 	   and clobber all hard registers, all pseudo-registers and all of 	   memory.  So must TRAP_IF and UNSPEC_VOLATILE operations.  	   Consider for instance a volatile asm that changes the fpu rounding 	   mode.  An insn should not be moved across this even if it only uses 	   pseudo-regs because it might give an incorrectly rounded result.  */
if|if
condition|(
name|code
operator|!=
name|ASM_OPERANDS
operator|||
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|int
name|max_reg
init|=
name|max_reg_num
argument_list|()
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_reg
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|u
operator|=
name|reg_last_uses
index|[
name|i
index|]
init|;
name|u
condition|;
name|u
operator|=
name|XEXP
argument_list|(
name|u
argument_list|,
literal|1
argument_list|)
control|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|u
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|reg_last_uses
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|reg_last_sets
index|[
name|i
index|]
condition|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|reg_last_sets
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|reg_pending_sets_all
operator|=
literal|1
expr_stmt|;
name|flush_pending_lists
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* For all ASM_OPERANDS, we must traverse the vector of input operands. 	   We can not just fall through here since then we would be confused 	   by the ASM_INPUT rtx inside ASM_OPERANDS, which do not indicate 	   traditional asms unlike their normal usage.  */
if|if
condition|(
name|code
operator|==
name|ASM_OPERANDS
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|x
argument_list|)
condition|;
name|j
operator|++
control|)
name|sched_analyze_2
argument_list|(
name|ASM_OPERANDS_INPUT
argument_list|(
name|x
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
block|}
case|case
name|PRE_DEC
case|:
case|case
name|POST_DEC
case|:
case|case
name|PRE_INC
case|:
case|case
name|POST_INC
case|:
comment|/* These both read and modify the result.  We must handle them as writes 	 to get proper dependencies for following instructions.  We must handle 	 them as reads to get proper dependencies from this to previous 	 instructions.  Thus we need to pass them to both sched_analyze_1 	 and sched_analyze_2.  We must call sched_analyze_2 first in order 	 to get the proper antecedent for the read.  */
name|sched_analyze_2
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|sched_analyze_1
argument_list|(
name|x
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return;
default|default:
break|break;
block|}
comment|/* Other cases: walk the insn.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|sched_analyze_2
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|sched_analyze_2
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Analyze an INSN with pattern X to find all dependencies.  */
end_comment

begin_function
specifier|static
name|void
name|sched_analyze_insn
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|,
name|loop_notes
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|insn
decl_stmt|;
name|rtx
name|loop_notes
decl_stmt|;
block|{
specifier|register
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
name|link
decl_stmt|;
name|int
name|maxreg
init|=
name|max_reg_num
argument_list|()
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|SET
operator|||
name|code
operator|==
name|CLOBBER
condition|)
name|sched_analyze_1
argument_list|(
name|x
argument_list|,
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|PARALLEL
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|code
operator|=
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|SET
operator|||
name|code
operator|==
name|CLOBBER
condition|)
name|sched_analyze_1
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
else|else
name|sched_analyze_2
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|sched_analyze_2
argument_list|(
name|x
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Mark registers CLOBBERED or used by called function.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
for|for
control|(
name|link
operator|=
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
name|sched_analyze_1
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
else|else
name|sched_analyze_2
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* If there is a {LOOP,EHREGION}_{BEG,END} note in the middle of a basic block, then      we must be sure that no instructions are scheduled across it.      Otherwise, the reg_n_refs info (which depends on loop_depth) would      become incorrect.  */
if|if
condition|(
name|loop_notes
condition|)
block|{
name|int
name|max_reg
init|=
name|max_reg_num
argument_list|()
decl_stmt|;
name|rtx
name|link
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_reg
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|u
decl_stmt|;
for|for
control|(
name|u
operator|=
name|reg_last_uses
index|[
name|i
index|]
init|;
name|u
condition|;
name|u
operator|=
name|XEXP
argument_list|(
name|u
argument_list|,
literal|1
argument_list|)
control|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|u
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|reg_last_uses
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|reg_last_sets
index|[
name|i
index|]
condition|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|reg_last_sets
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|reg_pending_sets_all
operator|=
literal|1
expr_stmt|;
name|flush_pending_lists
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|link
operator|=
name|loop_notes
expr_stmt|;
while|while
condition|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
condition|)
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|loop_notes
expr_stmt|;
block|}
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|reg_pending_sets
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|{ 			       reg_last_sets[i] = insn; 			     }
argument_list|)
empty_stmt|;
name|CLEAR_REG_SET
argument_list|(
name|reg_pending_sets
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_pending_sets_all
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|maxreg
condition|;
name|i
operator|++
control|)
name|reg_last_sets
index|[
name|i
index|]
operator|=
name|insn
expr_stmt|;
name|reg_pending_sets_all
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Handle function calls and function returns created by the epilogue      threading code.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
name|rtx
name|dep_insn
decl_stmt|;
name|rtx
name|prev_dep_insn
decl_stmt|;
comment|/* When scheduling instructions, we make sure calls don't lose their 	 accompanying USE insns by depending them one on another in order.  	 Also, we must do the same thing for returns created by the epilogue 	 threading code.  Note this code works only in this special case, 	 because other passes make no guarantee that they will never emit 	 an instruction between a USE and a RETURN.  There is such a guarantee 	 for USE instructions immediately before a call.  */
name|prev_dep_insn
operator|=
name|insn
expr_stmt|;
name|dep_insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|dep_insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|dep_insn
argument_list|)
argument_list|)
operator|==
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|dep_insn
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|SCHED_GROUP_P
argument_list|(
name|prev_dep_insn
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Make a copy of all dependencies on dep_insn, and add to insn. 	     This is so that all of the dependencies will apply to the 	     group.  */
for|for
control|(
name|link
operator|=
name|LOG_LINKS
argument_list|(
name|dep_insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
argument_list|)
expr_stmt|;
name|prev_dep_insn
operator|=
name|dep_insn
expr_stmt|;
name|dep_insn
operator|=
name|PREV_INSN
argument_list|(
name|dep_insn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Analyze every insn between HEAD and TAIL inclusive, creating LOG_LINKS    for every dependency.  */
end_comment

begin_function
specifier|static
name|int
name|sched_analyze
parameter_list|(
name|head
parameter_list|,
name|tail
parameter_list|)
name|rtx
name|head
decl_stmt|,
name|tail
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
decl_stmt|;
specifier|register
name|int
name|n_insns
init|=
literal|0
decl_stmt|;
specifier|register
name|rtx
name|u
decl_stmt|;
specifier|register
name|int
name|luid
init|=
literal|0
decl_stmt|;
name|rtx
name|loop_notes
init|=
literal|0
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|head
init|;
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
operator|=
name|luid
operator|++
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
name|sched_analyze_insn
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
name|loop_notes
argument_list|)
expr_stmt|;
name|loop_notes
operator|=
literal|0
expr_stmt|;
name|n_insns
operator|+=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|rtx
name|x
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Any instruction using a hard register which may get clobbered 	     by a call needs to be marked as dependent on this call. 	     This prevents a use of a hard return reg from being moved 	     past a void call (i.e. it does not explicitly set the hard 	     return reg).  */
comment|/* If this call is followed by a NOTE_INSN_SETJMP, then assume that 	     all registers, not just hard registers, may be clobbered by this 	     call.  */
comment|/* Insn, being a CALL_INSN, magically depends on 	     `last_function_call' already.  */
if|if
condition|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|NOTE_INSN_SETJMP
condition|)
block|{
name|int
name|max_reg
init|=
name|max_reg_num
argument_list|()
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_reg
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|u
operator|=
name|reg_last_uses
index|[
name|i
index|]
init|;
name|u
condition|;
name|u
operator|=
name|XEXP
argument_list|(
name|u
argument_list|,
literal|1
argument_list|)
control|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|u
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|reg_last_uses
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|reg_last_sets
index|[
name|i
index|]
condition|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|reg_last_sets
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|reg_pending_sets_all
operator|=
literal|1
expr_stmt|;
comment|/* Add a pair of fake REG_NOTEs which we will later 		 convert back into a NOTE_INSN_SETJMP note.  See 		 reemit_notes for why we use a pair of NOTEs.  */
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_DEAD
argument_list|,
name|GEN_INT
argument_list|(
literal|0
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_DEAD
argument_list|,
name|GEN_INT
argument_list|(
name|NOTE_INSN_SETJMP
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|call_used_regs
index|[
name|i
index|]
operator|||
name|global_regs
index|[
name|i
index|]
condition|)
block|{
for|for
control|(
name|u
operator|=
name|reg_last_uses
index|[
name|i
index|]
init|;
name|u
condition|;
name|u
operator|=
name|XEXP
argument_list|(
name|u
argument_list|,
literal|1
argument_list|)
control|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|u
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|reg_last_uses
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|reg_last_sets
index|[
name|i
index|]
condition|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|reg_last_sets
index|[
name|i
index|]
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|SET_REGNO_REG_SET
argument_list|(
name|reg_pending_sets
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* For each insn which shouldn't cross a call, add a dependence 	     between that insn and this call insn.  */
name|x
operator|=
name|LOG_LINKS
argument_list|(
name|sched_before_next_call
argument_list|)
expr_stmt|;
while|while
condition|(
name|x
condition|)
block|{
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|LOG_LINKS
argument_list|(
name|sched_before_next_call
argument_list|)
operator|=
literal|0
expr_stmt|;
name|sched_analyze_insn
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
name|loop_notes
argument_list|)
expr_stmt|;
name|loop_notes
operator|=
literal|0
expr_stmt|;
comment|/* In the absence of interprocedural alias analysis, we must flush 	     all pending reads and writes, and start new dependencies starting 	     from here.  But only flush writes for constant calls (which may 	     be passed a pointer to something we haven't written yet).  */
name|flush_pending_lists
argument_list|(
name|insn
argument_list|,
name|CONST_CALL_P
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Depend this function call (actually, the user of this 	     function call) on all hard register clobberage.  */
name|last_function_call
operator|=
name|insn
expr_stmt|;
name|n_insns
operator|+=
literal|1
expr_stmt|;
block|}
comment|/* See comments on reemit_notes as to why we do this.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
operator|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_END
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_EH_REGION_BEG
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_EH_REGION_END
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_RANGE_START
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_RANGE_END
operator|||
operator|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_SETJMP
operator|&&
name|GET_CODE
argument_list|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|CALL_INSN
operator|)
operator|)
condition|)
block|{
name|loop_notes
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_DEAD
argument_list|,
name|GEN_INT
argument_list|(
name|NOTE_BLOCK_NUMBER
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
name|loop_notes
argument_list|)
expr_stmt|;
name|loop_notes
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_DEAD
argument_list|,
name|GEN_INT
argument_list|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
name|loop_notes
argument_list|)
expr_stmt|;
name|CONST_CALL_P
argument_list|(
name|loop_notes
argument_list|)
operator|=
name|CONST_CALL_P
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|insn
operator|==
name|tail
condition|)
return|return
name|n_insns
return|;
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Called when we see a set of a register.  If death is true, then we are    scanning backwards.  Mark that register as unborn.  If nobody says    otherwise, that is how things will remain.  If death is false, then we    are scanning forwards.  Mark that register as being born.  */
end_comment

begin_function
specifier|static
name|void
name|sched_note_set
parameter_list|(
name|x
parameter_list|,
name|death
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|int
name|death
decl_stmt|;
block|{
specifier|register
name|int
name|regno
decl_stmt|;
specifier|register
name|rtx
name|reg
init|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|subreg_p
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|reg
operator|==
literal|0
condition|)
return|return;
while|while
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
block|{
comment|/* Must treat modification of just one hardware register of a multi-reg 	 value or just a byte field of a register exactly the same way that 	 mark_set_1 in flow.c does, i.e. anything except a paradoxical subreg 	 does not kill the entire register.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|!=
name|SUBREG
operator|||
name|REG_SIZE
argument_list|(
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|>
name|REG_SIZE
argument_list|(
name|reg
argument_list|)
condition|)
name|subreg_p
operator|=
literal|1
expr_stmt|;
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|!=
name|REG
condition|)
return|return;
comment|/* Global registers are always live, so the code below does not apply      to them.  */
name|regno
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
operator|!
name|global_regs
index|[
name|regno
index|]
condition|)
block|{
if|if
condition|(
name|death
condition|)
block|{
comment|/* If we only set part of the register, then this set does not 	     kill it.  */
if|if
condition|(
name|subreg_p
condition|)
return|return;
comment|/* Try killing this register.  */
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|j
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
operator|--
name|j
operator|>=
literal|0
condition|)
block|{
name|CLEAR_REGNO_REG_SET
argument_list|(
name|bb_live_regs
argument_list|,
name|regno
operator|+
name|j
argument_list|)
expr_stmt|;
name|SET_REGNO_REG_SET
argument_list|(
name|bb_dead_regs
argument_list|,
name|regno
operator|+
name|j
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|CLEAR_REGNO_REG_SET
argument_list|(
name|bb_live_regs
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|SET_REGNO_REG_SET
argument_list|(
name|bb_dead_regs
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Make the register live again.  */
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|j
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
operator|--
name|j
operator|>=
literal|0
condition|)
block|{
name|SET_REGNO_REG_SET
argument_list|(
name|bb_live_regs
argument_list|,
name|regno
operator|+
name|j
argument_list|)
expr_stmt|;
name|CLEAR_REGNO_REG_SET
argument_list|(
name|bb_dead_regs
argument_list|,
name|regno
operator|+
name|j
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|SET_REGNO_REG_SET
argument_list|(
name|bb_live_regs
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|CLEAR_REGNO_REG_SET
argument_list|(
name|bb_dead_regs
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Macros and functions for keeping the priority queue sorted, and    dealing with queueing and dequeueing of instructions.  */
end_comment

begin_define
define|#
directive|define
name|SCHED_SORT
parameter_list|(
name|READY
parameter_list|,
name|NEW_READY
parameter_list|,
name|OLD_READY
parameter_list|)
define|\
value|do { if ((NEW_READY) - (OLD_READY) == 1)				\ 	 swap_sort (READY, NEW_READY);					\        else if ((NEW_READY) - (OLD_READY)> 1)				\ 	 qsort (READY, NEW_READY, sizeof (rtx), rank_for_schedule); }	\   while (0)
end_define

begin_comment
comment|/* Returns a positive value if y is preferred; returns a negative value if    x is preferred.  Should never return 0, since that will make the sort    unstable.  */
end_comment

begin_function
specifier|static
name|int
name|rank_for_schedule
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
specifier|const
name|GENERIC_PTR
name|x
decl_stmt|;
specifier|const
name|GENERIC_PTR
name|y
decl_stmt|;
block|{
name|rtx
name|tmp
init|=
operator|*
operator|(
name|rtx
operator|*
operator|)
name|y
decl_stmt|;
name|rtx
name|tmp2
init|=
operator|*
operator|(
name|rtx
operator|*
operator|)
name|x
decl_stmt|;
name|rtx
name|link
decl_stmt|;
name|int
name|tmp_class
decl_stmt|,
name|tmp2_class
decl_stmt|;
name|int
name|value
decl_stmt|;
comment|/* Choose the instruction with the highest priority, if different.  */
if|if
condition|(
operator|(
name|value
operator|=
name|INSN_PRIORITY
argument_list|(
name|tmp
argument_list|)
operator|-
name|INSN_PRIORITY
argument_list|(
name|tmp2
argument_list|)
operator|)
condition|)
return|return
name|value
return|;
if|if
condition|(
name|last_scheduled_insn
condition|)
block|{
comment|/* Classify the instructions into three classes: 	 1) Data dependent on last schedule insn. 	 2) Anti/Output dependent on last scheduled insn. 	 3) Independent of last scheduled insn, or has latency of one. 	 Choose the insn from the highest numbered class if different.  */
name|link
operator|=
name|find_insn_list
argument_list|(
name|tmp
argument_list|,
name|LOG_LINKS
argument_list|(
name|last_scheduled_insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
operator|==
literal|0
operator|||
name|insn_cost
argument_list|(
name|tmp
argument_list|,
name|link
argument_list|,
name|last_scheduled_insn
argument_list|)
operator|==
literal|1
condition|)
name|tmp_class
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
literal|0
condition|)
comment|/* Data dependence.  */
name|tmp_class
operator|=
literal|1
expr_stmt|;
else|else
name|tmp_class
operator|=
literal|2
expr_stmt|;
name|link
operator|=
name|find_insn_list
argument_list|(
name|tmp2
argument_list|,
name|LOG_LINKS
argument_list|(
name|last_scheduled_insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
operator|==
literal|0
operator|||
name|insn_cost
argument_list|(
name|tmp2
argument_list|,
name|link
argument_list|,
name|last_scheduled_insn
argument_list|)
operator|==
literal|1
condition|)
name|tmp2_class
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
literal|0
condition|)
comment|/* Data dependence.  */
name|tmp2_class
operator|=
literal|1
expr_stmt|;
else|else
name|tmp2_class
operator|=
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|value
operator|=
name|tmp_class
operator|-
name|tmp2_class
operator|)
condition|)
return|return
name|value
return|;
block|}
comment|/* If insns are equally good, sort by INSN_LUID (original insn order),      so that we make the sort stable.  This minimizes instruction movement,      thus minimizing sched's effect on debugging and cross-jumping.  */
return|return
name|INSN_LUID
argument_list|(
name|tmp
argument_list|)
operator|-
name|INSN_LUID
argument_list|(
name|tmp2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Resort the array A in which only element at index N may be out of order.  */
end_comment

begin_function
name|__inline
specifier|static
name|void
name|swap_sort
parameter_list|(
name|a
parameter_list|,
name|n
parameter_list|)
name|rtx
modifier|*
name|a
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|rtx
name|insn
init|=
name|a
index|[
name|n
operator|-
literal|1
index|]
decl_stmt|;
name|int
name|i
init|=
name|n
operator|-
literal|2
decl_stmt|;
while|while
condition|(
name|i
operator|>=
literal|0
operator|&&
name|rank_for_schedule
argument_list|(
name|a
operator|+
name|i
argument_list|,
operator|&
name|insn
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|a
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|a
index|[
name|i
index|]
expr_stmt|;
name|i
operator|-=
literal|1
expr_stmt|;
block|}
name|a
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|insn
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|max_priority
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Add INSN to the insn queue so that it fires at least N_CYCLES    before the currently executing insn.  */
end_comment

begin_function
name|__inline
specifier|static
name|void
name|queue_insn
parameter_list|(
name|insn
parameter_list|,
name|n_cycles
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|int
name|n_cycles
decl_stmt|;
block|{
name|int
name|next_q
init|=
name|NEXT_Q_AFTER
argument_list|(
name|q_ptr
argument_list|,
name|n_cycles
argument_list|)
decl_stmt|;
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|insn_queue
index|[
name|next_q
index|]
expr_stmt|;
name|insn_queue
index|[
name|next_q
index|]
operator|=
name|insn
expr_stmt|;
name|q_size
operator|+=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return nonzero if PAT is the pattern of an insn which makes a    register live.  */
end_comment

begin_function
name|__inline
specifier|static
name|int
name|birthing_insn_p
parameter_list|(
name|pat
parameter_list|)
name|rtx
name|pat
decl_stmt|;
block|{
name|int
name|j
decl_stmt|;
if|if
condition|(
name|reload_completed
operator|==
literal|1
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|pat
argument_list|)
decl_stmt|;
name|int
name|i
init|=
name|REGNO
argument_list|(
name|dest
argument_list|)
decl_stmt|;
comment|/* It would be more accurate to use refers_to_regno_p or 	 reg_mentioned_p to determine when the dest is not live before this 	 insn.  */
if|if
condition|(
name|REGNO_REG_SET_P
argument_list|(
name|bb_live_regs
argument_list|,
name|i
argument_list|)
condition|)
return|return
operator|(
name|REG_N_SETS
argument_list|(
name|i
argument_list|)
operator|==
literal|1
operator|)
return|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|birthing_insn_p
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* PREV is an insn that is ready to execute.  Adjust its priority if that    will help shorten register lifetimes.  */
end_comment

begin_function
name|__inline
specifier|static
name|void
name|adjust_priority
parameter_list|(
name|prev
parameter_list|)
name|rtx
name|prev
decl_stmt|;
block|{
comment|/* Trying to shorten register lives after reload has completed      is useless and wrong.  It gives inaccurate schedules.  */
if|if
condition|(
name|reload_completed
operator|==
literal|0
condition|)
block|{
name|rtx
name|note
decl_stmt|;
name|int
name|n_deaths
init|=
literal|0
decl_stmt|;
comment|/* ??? This code has no effect, because REG_DEAD notes are removed 	 before we ever get here.  */
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|prev
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_DEAD
condition|)
name|n_deaths
operator|+=
literal|1
expr_stmt|;
comment|/* Defer scheduling insns which kill registers, since that 	 shortens register lives.  Prefer scheduling insns which 	 make registers live for the same reason.  */
switch|switch
condition|(
name|n_deaths
condition|)
block|{
default|default:
name|INSN_PRIORITY
argument_list|(
name|prev
argument_list|)
operator|>>=
literal|3
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|INSN_PRIORITY
argument_list|(
name|prev
argument_list|)
operator|>>=
literal|2
expr_stmt|;
break|break;
case|case
literal|2
case|:
case|case
literal|1
case|:
name|INSN_PRIORITY
argument_list|(
name|prev
argument_list|)
operator|>>=
literal|1
expr_stmt|;
break|break;
case|case
literal|0
case|:
if|if
condition|(
name|birthing_insn_p
argument_list|(
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|max
init|=
name|max_priority
decl_stmt|;
if|if
condition|(
name|max
operator|>
name|INSN_PRIORITY
argument_list|(
name|prev
argument_list|)
condition|)
name|INSN_PRIORITY
argument_list|(
name|prev
argument_list|)
operator|=
name|max
expr_stmt|;
block|}
break|break;
block|}
ifdef|#
directive|ifdef
name|ADJUST_PRIORITY
name|ADJUST_PRIORITY
argument_list|(
name|prev
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/* INSN is the "currently executing insn".  Launch each insn which was    waiting on INSN (in the backwards dataflow sense).  READY is a    vector of insns which are ready to fire.  N_READY is the number of    elements in READY.  CLOCK is the current virtual cycle.  */
end_comment

begin_function
specifier|static
name|int
name|schedule_insn
parameter_list|(
name|insn
parameter_list|,
name|ready
parameter_list|,
name|n_ready
parameter_list|,
name|clock
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
modifier|*
name|ready
decl_stmt|;
name|int
name|n_ready
decl_stmt|;
name|int
name|clock
decl_stmt|;
block|{
name|rtx
name|link
decl_stmt|;
name|int
name|new_ready
init|=
name|n_ready
decl_stmt|;
if|if
condition|(
name|MAX_BLOCKAGE
operator|>
literal|1
condition|)
name|schedule_unit
argument_list|(
name|insn_unit
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
name|clock
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
operator|==
literal|0
condition|)
return|return
name|n_ready
return|;
comment|/* This is used by the function adjust_priority above.  */
if|if
condition|(
name|n_ready
operator|>
literal|0
condition|)
name|max_priority
operator|=
name|MAX
argument_list|(
name|INSN_PRIORITY
argument_list|(
name|ready
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|INSN_PRIORITY
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|max_priority
operator|=
name|INSN_PRIORITY
argument_list|(
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
name|link
operator|=
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
init|;
name|link
operator|!=
literal|0
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|rtx
name|prev
init|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|cost
init|=
name|insn_cost
argument_list|(
name|prev
argument_list|,
name|link
argument_list|,
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|INSN_REF_COUNT
argument_list|(
name|prev
argument_list|)
operator|-=
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* We satisfied one requirement to fire PREV.  Record the earliest 	     time when PREV can fire.  No need to do this if the cost is 1, 	     because PREV can fire no sooner than the next cycle.  */
if|if
condition|(
name|cost
operator|>
literal|1
condition|)
name|INSN_TICK
argument_list|(
name|prev
argument_list|)
operator|=
name|MAX
argument_list|(
name|INSN_TICK
argument_list|(
name|prev
argument_list|)
argument_list|,
name|clock
operator|+
name|cost
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We satisfied the last requirement to fire PREV.  Ensure that all 	     timing requirements are satisfied.  */
if|if
condition|(
name|INSN_TICK
argument_list|(
name|prev
argument_list|)
operator|-
name|clock
operator|>
name|cost
condition|)
name|cost
operator|=
name|INSN_TICK
argument_list|(
name|prev
argument_list|)
operator|-
name|clock
expr_stmt|;
comment|/* Adjust the priority of PREV and either put it on the ready 	     list or queue it.  */
name|adjust_priority
argument_list|(
name|prev
argument_list|)
expr_stmt|;
if|if
condition|(
name|cost
operator|<=
literal|1
condition|)
name|ready
index|[
name|new_ready
operator|++
index|]
operator|=
name|prev
expr_stmt|;
else|else
name|queue_insn
argument_list|(
name|prev
argument_list|,
name|cost
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|new_ready
return|;
block|}
end_function

begin_comment
comment|/* Given N_READY insns in the ready list READY at time CLOCK, queue    those that are blocked due to function unit hazards and rearrange    the remaining ones to minimize subsequent function unit hazards.  */
end_comment

begin_function
specifier|static
name|int
name|schedule_select
parameter_list|(
name|ready
parameter_list|,
name|n_ready
parameter_list|,
name|clock
parameter_list|,
name|file
parameter_list|)
name|rtx
modifier|*
name|ready
decl_stmt|;
name|int
name|n_ready
decl_stmt|,
name|clock
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|int
name|pri
init|=
name|INSN_PRIORITY
argument_list|(
name|ready
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|q
decl_stmt|,
name|cost
decl_stmt|,
name|best_cost
decl_stmt|,
name|best_insn
init|=
literal|0
decl_stmt|,
name|new_ready
init|=
name|n_ready
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
comment|/* Work down the ready list in groups of instructions with the same      priority value.  Queue insns in the group that are blocked and      select among those that remain for the one with the largest      potential hazard.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_ready
condition|;
name|i
operator|=
name|j
control|)
block|{
name|int
name|opri
init|=
name|pri
decl_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|n_ready
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|(
name|pri
operator|=
name|INSN_PRIORITY
argument_list|(
name|ready
index|[
name|j
index|]
argument_list|)
operator|)
operator|!=
name|opri
condition|)
break|break;
comment|/* Queue insns in the group that are blocked.  */
for|for
control|(
name|k
operator|=
name|i
operator|,
name|q
operator|=
literal|0
init|;
name|k
operator|<
name|j
condition|;
name|k
operator|++
control|)
block|{
name|insn
operator|=
name|ready
index|[
name|k
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|cost
operator|=
name|actual_hazard
argument_list|(
name|insn_unit
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
name|clock
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|q
operator|++
expr_stmt|;
name|ready
index|[
name|k
index|]
operator|=
literal|0
expr_stmt|;
name|queue_insn
argument_list|(
name|insn
argument_list|,
name|cost
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n;; blocking insn %d for %d cycles"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|cost
argument_list|)
expr_stmt|;
block|}
block|}
name|new_ready
operator|-=
name|q
expr_stmt|;
comment|/* Check the next group if all insns were queued.  */
if|if
condition|(
name|j
operator|-
name|i
operator|-
name|q
operator|==
literal|0
condition|)
continue|continue;
comment|/* If more than one remains, select the first one with the largest 	 potential hazard.  */
elseif|else
if|if
condition|(
name|j
operator|-
name|i
operator|-
name|q
operator|>
literal|1
condition|)
block|{
name|best_cost
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|k
operator|=
name|i
init|;
name|k
operator|<
name|j
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|insn
operator|=
name|ready
index|[
name|k
index|]
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|cost
operator|=
name|potential_hazard
argument_list|(
name|insn_unit
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
operator|)
operator|>
name|best_cost
condition|)
block|{
name|best_cost
operator|=
name|cost
expr_stmt|;
name|best_insn
operator|=
name|k
expr_stmt|;
block|}
block|}
block|}
comment|/* We have found a suitable insn to schedule.  */
break|break;
block|}
comment|/* Move the best insn to be front of the ready list.  */
if|if
condition|(
name|best_insn
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|file
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|", now"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_ready
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ready
index|[
name|i
index|]
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %d"
argument_list|,
name|INSN_UID
argument_list|(
name|ready
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n;; insn %d has a greater potential hazard"
argument_list|,
name|INSN_UID
argument_list|(
name|ready
index|[
name|best_insn
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|best_insn
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|insn
operator|=
name|ready
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|ready
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|ready
index|[
name|i
index|]
expr_stmt|;
name|ready
index|[
name|i
index|]
operator|=
name|insn
expr_stmt|;
block|}
block|}
comment|/* Compact the ready list.  */
if|if
condition|(
name|new_ready
operator|<
name|n_ready
condition|)
for|for
control|(
name|i
operator|=
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|n_ready
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ready
index|[
name|i
index|]
condition|)
name|ready
index|[
name|j
operator|++
index|]
operator|=
name|ready
index|[
name|i
index|]
expr_stmt|;
return|return
name|new_ready
return|;
block|}
end_function

begin_comment
comment|/* Add a REG_DEAD note for REG to INSN, reusing a REG_DEAD note from the    dead_notes list.  */
end_comment

begin_function
specifier|static
name|void
name|create_reg_dead_note
parameter_list|(
name|reg
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|reg
decl_stmt|,
name|insn
decl_stmt|;
block|{
name|rtx
name|link
decl_stmt|;
comment|/* The number of registers killed after scheduling must be the same as the      number of registers killed before scheduling.  The number of REG_DEAD      notes may not be conserved, i.e. two SImode hard register REG_DEAD notes      might become one DImode hard register REG_DEAD note, but the number of      registers killed will be conserved.            We carefully remove REG_DEAD notes from the dead_notes list, so that      there will be none left at the end.  If we run out early, then there      is a bug somewhere in flow, combine and/or sched.  */
if|if
condition|(
name|dead_notes
operator|==
literal|0
condition|)
block|{
if|#
directive|if
literal|1
name|abort
argument_list|()
expr_stmt|;
else|#
directive|else
name|link
operator|=
name|rtx_alloc
argument_list|(
name|EXPR_LIST
argument_list|)
expr_stmt|;
name|PUT_REG_NOTE_KIND
argument_list|(
name|link
argument_list|,
name|REG_DEAD
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* Number of regs killed by REG.  */
name|int
name|regs_killed
init|=
operator|(
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|?
literal|1
else|:
name|HARD_REGNO_NREGS
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|)
decl_stmt|;
comment|/* Number of regs killed by REG_DEAD notes taken off the list.  */
name|int
name|reg_note_regs
decl_stmt|;
name|link
operator|=
name|dead_notes
expr_stmt|;
name|reg_note_regs
operator|=
operator|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|?
literal|1
else|:
name|HARD_REGNO_NREGS
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
expr_stmt|;
while|while
condition|(
name|reg_note_regs
operator|<
name|regs_killed
condition|)
block|{
comment|/* LINK might be zero if we killed more registers after scheduling 	     than before, and the last hard register we kill is actually 	     multiple hard regs.  */
if|if
condition|(
name|link
operator|==
name|NULL_RTX
condition|)
name|abort
argument_list|()
expr_stmt|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|reg_note_regs
operator|+=
operator|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|?
literal|1
else|:
name|HARD_REGNO_NREGS
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
name|dead_notes
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If we took too many regs kills off, put the extra ones back.  */
while|while
condition|(
name|reg_note_regs
operator|>
name|regs_killed
condition|)
block|{
name|rtx
name|temp_reg
decl_stmt|,
name|temp_link
decl_stmt|;
name|temp_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|word_mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|temp_link
operator|=
name|rtx_alloc
argument_list|(
name|EXPR_LIST
argument_list|)
expr_stmt|;
name|PUT_REG_NOTE_KIND
argument_list|(
name|temp_link
argument_list|,
name|REG_DEAD
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|temp_link
argument_list|,
literal|0
argument_list|)
operator|=
name|temp_reg
expr_stmt|;
name|XEXP
argument_list|(
name|temp_link
argument_list|,
literal|1
argument_list|)
operator|=
name|dead_notes
expr_stmt|;
name|dead_notes
operator|=
name|temp_link
expr_stmt|;
name|reg_note_regs
operator|--
expr_stmt|;
block|}
block|}
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
operator|=
name|reg
expr_stmt|;
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|link
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Subroutine on attach_deaths_insn--handles the recursive search    through INSN.  If SET_P is true, then x is being modified by the insn.  */
end_comment

begin_function
specifier|static
name|void
name|attach_deaths
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|,
name|set_p
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|set_p
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST
case|:
case|case
name|CODE_LABEL
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
comment|/* Get rid of the easy cases first.  */
return|return;
case|case
name|REG
case|:
block|{
comment|/* If the register dies in this insn, queue that note, and mark 	   this register as needing to die.  */
comment|/* This code is very similar to mark_used_1 (if set_p is false) 	   and mark_set_1 (if set_p is true) in flow.c.  */
specifier|register
name|int
name|regno
decl_stmt|;
name|int
name|some_needed
decl_stmt|;
name|int
name|all_needed
decl_stmt|;
if|if
condition|(
name|set_p
condition|)
return|return;
name|regno
operator|=
name|REGNO
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|all_needed
operator|=
name|some_needed
operator|=
name|REGNO_REG_SET_P
argument_list|(
name|old_live_regs
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|n
decl_stmt|;
name|n
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|n
operator|>
literal|0
condition|)
block|{
name|int
name|needed
init|=
operator|(
name|REGNO_REG_SET_P
argument_list|(
name|old_live_regs
argument_list|,
name|regno
operator|+
name|n
argument_list|)
operator|)
decl_stmt|;
name|some_needed
operator||=
name|needed
expr_stmt|;
name|all_needed
operator|&=
name|needed
expr_stmt|;
block|}
block|}
comment|/* If it wasn't live before we started, then add a REG_DEAD note. 	   We must check the previous lifetime info not the current info, 	   because we may have to execute this code several times, e.g. 	   once for a clobber (which doesn't add a note) and later 	   for a use (which does add a note). 	    	   Always make the register live.  We must do this even if it was 	   live before, because this may be an insn which sets and uses 	   the same register, in which case the register has already been 	   killed, so we must make it live again.  	   Global registers are always live, and should never have a REG_DEAD 	   note added for them, so none of the code below applies to them.  */
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
operator|!
name|global_regs
index|[
name|regno
index|]
condition|)
block|{
comment|/* Never add REG_DEAD notes for STACK_POINTER_REGNUM 	       since it's always considered to be live.  Similarly 	       for FRAME_POINTER_REGNUM if a frame pointer is needed 	       and for ARG_POINTER_REGNUM if it is fixed.  */
if|if
condition|(
operator|!
operator|(
name|regno
operator|==
name|FRAME_POINTER_REGNUM
operator|&&
operator|(
operator|!
name|reload_completed
operator|||
name|frame_pointer_needed
operator|)
operator|)
if|#
directive|if
name|HARD_FRAME_POINTER_REGNUM
operator|!=
name|FRAME_POINTER_REGNUM
operator|&&
operator|!
operator|(
name|regno
operator|==
name|HARD_FRAME_POINTER_REGNUM
operator|&&
operator|(
operator|!
name|reload_completed
operator|||
name|frame_pointer_needed
operator|)
operator|)
endif|#
directive|endif
if|#
directive|if
name|ARG_POINTER_REGNUM
operator|!=
name|FRAME_POINTER_REGNUM
operator|&&
operator|!
operator|(
name|regno
operator|==
name|ARG_POINTER_REGNUM
operator|&&
name|fixed_regs
index|[
name|regno
index|]
operator|)
endif|#
directive|endif
operator|&&
name|regno
operator|!=
name|STACK_POINTER_REGNUM
condition|)
block|{
if|if
condition|(
operator|!
name|all_needed
operator|&&
operator|!
name|dead_or_set_p
argument_list|(
name|insn
argument_list|,
name|x
argument_list|)
condition|)
block|{
comment|/* Check for the case where the register dying partially 		       overlaps the register set by this insn.  */
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|>
literal|1
condition|)
block|{
name|int
name|n
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
name|some_needed
operator||=
name|dead_or_set_regno_p
argument_list|(
name|insn
argument_list|,
name|regno
operator|+
name|n
argument_list|)
expr_stmt|;
block|}
comment|/* If none of the words in X is needed, make a REG_DEAD 		       note.  Otherwise, we must make partial REG_DEAD 		       notes.  */
if|if
condition|(
operator|!
name|some_needed
condition|)
name|create_reg_dead_note
argument_list|(
name|x
argument_list|,
name|insn
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|i
decl_stmt|;
comment|/* Don't make a REG_DEAD note for a part of a 			   register that is set in the insn.  */
for|for
control|(
name|i
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
operator|!
name|REGNO_REG_SET_P
argument_list|(
name|old_live_regs
argument_list|,
name|regno
operator|+
name|i
argument_list|)
operator|&&
operator|!
name|dead_or_set_regno_p
argument_list|(
name|insn
argument_list|,
name|regno
operator|+
name|i
argument_list|)
condition|)
name|create_reg_dead_note
argument_list|(
name|gen_rtx_REG
argument_list|(
name|reg_raw_mode
index|[
name|regno
operator|+
name|i
index|]
argument_list|,
name|regno
operator|+
name|i
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|j
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
operator|--
name|j
operator|>=
literal|0
condition|)
block|{
name|CLEAR_REGNO_REG_SET
argument_list|(
name|bb_dead_regs
argument_list|,
name|regno
operator|+
name|j
argument_list|)
expr_stmt|;
name|SET_REGNO_REG_SET
argument_list|(
name|bb_live_regs
argument_list|,
name|regno
operator|+
name|j
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|CLEAR_REGNO_REG_SET
argument_list|(
name|bb_dead_regs
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|SET_REGNO_REG_SET
argument_list|(
name|bb_live_regs
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
case|case
name|MEM
case|:
comment|/* Handle tail-recursive case.  */
name|attach_deaths
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|SUBREG
case|:
name|attach_deaths
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
name|insn
argument_list|,
name|set_p
operator|&&
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|<=
name|UNITS_PER_WORD
operator|)
operator|||
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|==
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
operator|(
name|x
operator|)
argument_list|)
argument_list|)
operator|)
operator|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|STRICT_LOW_PART
case|:
name|attach_deaths
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|ZERO_EXTRACT
case|:
case|case
name|SIGN_EXTRACT
case|:
name|attach_deaths
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|attach_deaths
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|attach_deaths
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
default|default:
comment|/* Other cases: walk the insn.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|attach_deaths
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|attach_deaths
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* After INSN has executed, add register death notes for each register    that is dead after INSN.  */
end_comment

begin_function
specifier|static
name|void
name|attach_deaths_insn
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|x
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
specifier|register
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
name|link
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|SET
condition|)
block|{
name|attach_deaths
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* A register might die here even if it is the destination, e.g. 	 it is the target of a volatile read and is otherwise unused. 	 Hence we must always call attach_deaths for the SET_DEST.  */
name|attach_deaths
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|PARALLEL
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|code
operator|=
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|SET
condition|)
block|{
name|attach_deaths
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|attach_deaths
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Flow does not add REG_DEAD notes to registers that die in 	     clobbers, so we can't either.  */
elseif|else
if|if
condition|(
name|code
operator|!=
name|CLOBBER
condition|)
name|attach_deaths
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If this is a CLOBBER, only add REG_DEAD notes to registers inside a      MEM being clobbered, just like flow.  */
elseif|else
if|if
condition|(
name|code
operator|==
name|CLOBBER
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
name|attach_deaths
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Otherwise don't add a death note to things being clobbered.  */
elseif|else
if|if
condition|(
name|code
operator|!=
name|CLOBBER
condition|)
name|attach_deaths
argument_list|(
name|x
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Make death notes for things used in the called function.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
for|for
control|(
name|link
operator|=
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
name|attach_deaths
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|,
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CLOBBER
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Delete notes beginning with INSN and maybe put them in the chain    of notes ended by NOTE_LIST.    Returns the insn following the notes.  */
end_comment

begin_function
specifier|static
name|rtx
name|unlink_notes
parameter_list|(
name|insn
parameter_list|,
name|tail
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|tail
decl_stmt|;
block|{
name|rtx
name|prev
init|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
while|while
condition|(
name|insn
operator|!=
name|tail
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
block|{
name|rtx
name|next
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* Delete the note from its current position.  */
if|if
condition|(
name|prev
condition|)
name|NEXT_INSN
argument_list|(
name|prev
argument_list|)
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|next
condition|)
name|PREV_INSN
argument_list|(
name|next
argument_list|)
operator|=
name|prev
expr_stmt|;
if|if
condition|(
name|write_symbols
operator|!=
name|NO_DEBUG
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|>
literal|0
condition|)
comment|/* Record line-number notes so they can be reused.  */
name|LINE_NOTE
argument_list|(
name|insn
argument_list|)
operator|=
name|insn
expr_stmt|;
comment|/* Don't save away NOTE_INSN_SETJMPs, because they must remain 	 immediately after the call they follow.  We use a fake 	 (REG_DEAD (const_int -1)) note to remember them. 	 Likewise with NOTE_INSN_{LOOP,EHREGION}_{BEG, END}.  */
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_SETJMP
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_LOOP_BEG
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_LOOP_END
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_RANGE_START
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_RANGE_END
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_EH_REGION_BEG
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_EH_REGION_END
condition|)
block|{
comment|/* Insert the note at the end of the notes list.  */
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|note_list
expr_stmt|;
if|if
condition|(
name|note_list
condition|)
name|NEXT_INSN
argument_list|(
name|note_list
argument_list|)
operator|=
name|insn
expr_stmt|;
name|note_list
operator|=
name|insn
expr_stmt|;
block|}
name|insn
operator|=
name|next
expr_stmt|;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Constructor for `sometimes' data structure.  */
end_comment

begin_function
specifier|static
name|int
name|new_sometimes_live
parameter_list|(
name|regs_sometimes_live
parameter_list|,
name|regno
parameter_list|,
name|sometimes_max
parameter_list|)
name|struct
name|sometimes
modifier|*
name|regs_sometimes_live
decl_stmt|;
name|int
name|regno
decl_stmt|;
name|int
name|sometimes_max
decl_stmt|;
block|{
specifier|register
name|struct
name|sometimes
modifier|*
name|p
decl_stmt|;
comment|/* There should never be a register greater than max_regno here.  If there      is, it means that a define_split has created a new pseudo reg.  This      is not allowed, since there will not be flow info available for any      new register, so catch the error here.  */
if|if
condition|(
name|regno
operator|>=
name|max_regno
condition|)
name|abort
argument_list|()
expr_stmt|;
name|p
operator|=
operator|&
name|regs_sometimes_live
index|[
name|sometimes_max
index|]
expr_stmt|;
name|p
operator|->
name|regno
operator|=
name|regno
expr_stmt|;
name|p
operator|->
name|live_length
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|calls_crossed
operator|=
literal|0
expr_stmt|;
name|sometimes_max
operator|++
expr_stmt|;
return|return
name|sometimes_max
return|;
block|}
end_function

begin_comment
comment|/* Count lengths of all regs we are currently tracking,    and find new registers no longer live.  */
end_comment

begin_function
specifier|static
name|void
name|finish_sometimes_live
parameter_list|(
name|regs_sometimes_live
parameter_list|,
name|sometimes_max
parameter_list|)
name|struct
name|sometimes
modifier|*
name|regs_sometimes_live
decl_stmt|;
name|int
name|sometimes_max
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sometimes_max
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|struct
name|sometimes
modifier|*
name|p
init|=
operator|&
name|regs_sometimes_live
index|[
name|i
index|]
decl_stmt|;
name|int
name|regno
init|=
name|p
operator|->
name|regno
decl_stmt|;
name|sched_reg_live_length
index|[
name|regno
index|]
operator|+=
name|p
operator|->
name|live_length
expr_stmt|;
name|sched_reg_n_calls_crossed
index|[
name|regno
index|]
operator|+=
name|p
operator|->
name|calls_crossed
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Search INSN for fake REG_DEAD note pairs for NOTE_INSN_SETJMP,    NOTE_INSN_{LOOP,EHREGION}_{BEG,END}; and convert them back into    NOTEs.  The REG_DEAD note following first one is contains the saved    value for NOTE_BLOCK_NUMBER which is useful for    NOTE_INSN_EH_REGION_{BEG,END} NOTEs.  LAST is the last instruction    output by the instruction scheduler.  Return the new value of LAST.  */
end_comment

begin_function
specifier|static
name|rtx
name|reemit_notes
parameter_list|(
name|insn
parameter_list|,
name|last
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|last
decl_stmt|;
block|{
name|rtx
name|note
decl_stmt|;
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
block|{
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_DEAD
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NOTE_INSN_SETJMP
condition|)
block|{
name|CONST_CALL_P
argument_list|(
name|emit_note_after
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
argument_list|)
operator|=
name|CONST_CALL_P
argument_list|(
name|note
argument_list|)
expr_stmt|;
name|remove_note
argument_list|(
name|insn
argument_list|,
name|note
argument_list|)
expr_stmt|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|last
operator|=
name|emit_note_before
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|remove_note
argument_list|(
name|insn
argument_list|,
name|note
argument_list|)
expr_stmt|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|NOTE_BLOCK_NUMBER
argument_list|(
name|last
argument_list|)
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|remove_note
argument_list|(
name|insn
argument_list|,
name|note
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|last
return|;
block|}
end_function

begin_comment
comment|/* Use modified list scheduling to rearrange insns in basic block    B.  FILE, if nonzero, is where we dump interesting output about    this pass.  */
end_comment

begin_function
specifier|static
name|void
name|schedule_block
parameter_list|(
name|b
parameter_list|,
name|file
parameter_list|)
name|int
name|b
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|,
name|last
decl_stmt|;
name|rtx
modifier|*
name|ready
decl_stmt|,
name|link
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|n_ready
init|=
literal|0
decl_stmt|,
name|new_ready
decl_stmt|,
name|n_insns
decl_stmt|;
name|int
name|sched_n_insns
init|=
literal|0
decl_stmt|;
name|int
name|clock
decl_stmt|;
define|#
directive|define
name|NEED_NOTHING
value|0
define|#
directive|define
name|NEED_HEAD
value|1
define|#
directive|define
name|NEED_TAIL
value|2
name|int
name|new_needs
decl_stmt|;
comment|/* HEAD and TAIL delimit the region being scheduled.  */
name|rtx
name|head
init|=
name|BLOCK_HEAD
argument_list|(
name|b
argument_list|)
decl_stmt|;
name|rtx
name|tail
init|=
name|BLOCK_END
argument_list|(
name|b
argument_list|)
decl_stmt|;
comment|/* PREV_HEAD and NEXT_TAIL are the boundaries of the insns      being scheduled.  When the insns have been ordered,      these insns delimit where the new insns are to be      spliced back into the insn chain.  */
name|rtx
name|next_tail
decl_stmt|;
name|rtx
name|prev_head
decl_stmt|;
comment|/* Keep life information accurate.  */
specifier|register
name|struct
name|sometimes
modifier|*
name|regs_sometimes_live
decl_stmt|;
name|int
name|sometimes_max
decl_stmt|;
if|if
condition|(
name|file
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";;\t -- basic block number %d from %d to %d --\n"
argument_list|,
name|b
argument_list|,
name|INSN_UID
argument_list|(
name|BLOCK_HEAD
argument_list|(
name|b
argument_list|)
argument_list|)
argument_list|,
name|INSN_UID
argument_list|(
name|BLOCK_END
argument_list|(
name|b
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|max_reg_num
argument_list|()
expr_stmt|;
name|reg_last_uses
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|i
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_last_uses
argument_list|,
name|i
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|reg_last_sets
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|i
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_last_sets
argument_list|,
name|i
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|reg_pending_sets
operator|=
name|ALLOCA_REG_SET
argument_list|()
expr_stmt|;
name|CLEAR_REG_SET
argument_list|(
name|reg_pending_sets
argument_list|)
expr_stmt|;
name|reg_pending_sets_all
operator|=
literal|0
expr_stmt|;
name|clear_units
argument_list|()
expr_stmt|;
if|#
directive|if
literal|0
comment|/* We used to have code to avoid getting parameters moved from hard      argument registers into pseudos.       However, it was removed when it proved to be of marginal benefit and      caused problems because of different notions of what the "head" insn      was.  */
comment|/* Remove certain insns at the beginning from scheduling,      by advancing HEAD.  */
comment|/* At the start of a function, before reload has run, don't delay getting      parameters from hard registers into pseudo registers.  */
block|if (reload_completed == 0&& b == 0)     {       while (head != tail&& GET_CODE (head) == NOTE&& NOTE_LINE_NUMBER (head) != NOTE_INSN_FUNCTION_BEG) 	head = NEXT_INSN (head);       while (head != tail&& GET_CODE (head) == INSN&& GET_CODE (PATTERN (head)) == SET) 	{ 	  rtx src = SET_SRC (PATTERN (head)); 	  while (GET_CODE (src) == SUBREG 		 || GET_CODE (src) == SIGN_EXTEND 		 || GET_CODE (src) == ZERO_EXTEND 		 || GET_CODE (src) == SIGN_EXTRACT 		 || GET_CODE (src) == ZERO_EXTRACT) 	    src = XEXP (src, 0); 	  if (GET_CODE (src) != REG 	      || REGNO (src)>= FIRST_PSEUDO_REGISTER) 	    break;
comment|/* Keep this insn from ever being scheduled.  */
block|INSN_REF_COUNT (head) = 1; 	  head = NEXT_INSN (head); 	}     }
endif|#
directive|endif
comment|/* Don't include any notes or labels at the beginning of the      basic block, or notes at the ends of basic blocks.  */
while|while
condition|(
name|head
operator|!=
name|tail
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|head
argument_list|)
operator|==
name|NOTE
condition|)
name|head
operator|=
name|NEXT_INSN
argument_list|(
name|head
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|tail
argument_list|)
operator|==
name|NOTE
condition|)
name|tail
operator|=
name|PREV_INSN
argument_list|(
name|tail
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|head
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|head
operator|=
name|NEXT_INSN
argument_list|(
name|head
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
comment|/* If the only insn left is a NOTE or a CODE_LABEL, then there is no need      to schedule this block.  */
if|if
condition|(
name|head
operator|==
name|tail
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|head
argument_list|)
operator|==
name|NOTE
operator|||
name|GET_CODE
argument_list|(
name|head
argument_list|)
operator|==
name|CODE_LABEL
operator|)
condition|)
goto|goto
name|ret
goto|;
if|#
directive|if
literal|0
comment|/* This short-cut doesn't work.  It does not count call insns crossed by      registers in reg_sometimes_live.  It does not mark these registers as      dead if they die in this block.  It does not mark these registers live      (or create new reg_sometimes_live entries if necessary) if they are born      in this block.       The easy solution is to just always schedule a block.  This block only      has one insn, so this won't slow down this pass by much.  */
block|if (head == tail)     goto ret;
endif|#
directive|endif
comment|/* Now HEAD through TAIL are the insns actually to be rearranged;      Let PREV_HEAD and NEXT_TAIL enclose them.  */
name|prev_head
operator|=
name|PREV_INSN
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|next_tail
operator|=
name|NEXT_INSN
argument_list|(
name|tail
argument_list|)
expr_stmt|;
comment|/* Initialize basic block data structures.  */
name|dead_notes
operator|=
literal|0
expr_stmt|;
name|pending_read_insns
operator|=
literal|0
expr_stmt|;
name|pending_read_mems
operator|=
literal|0
expr_stmt|;
name|pending_write_insns
operator|=
literal|0
expr_stmt|;
name|pending_write_mems
operator|=
literal|0
expr_stmt|;
name|pending_lists_length
operator|=
literal|0
expr_stmt|;
name|last_pending_memory_flush
operator|=
literal|0
expr_stmt|;
name|last_function_call
operator|=
literal|0
expr_stmt|;
name|last_scheduled_insn
operator|=
literal|0
expr_stmt|;
name|LOG_LINKS
argument_list|(
name|sched_before_next_call
argument_list|)
operator|=
literal|0
expr_stmt|;
name|n_insns
operator|=
name|sched_analyze
argument_list|(
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_insns
operator|==
literal|0
condition|)
block|{
name|free_pending_lists
argument_list|()
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
comment|/* Allocate vector to hold insns to be rearranged (except those      insns which are controlled by an insn with SCHED_GROUP_P set).      All these insns are included between ORIG_HEAD and ORIG_TAIL,      as those variables ultimately are set up.  */
name|ready
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|n_insns
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* TAIL is now the last of the insns to be rearranged.      Put those insns into the READY vector.  */
name|insn
operator|=
name|tail
expr_stmt|;
comment|/* For all branches, calls, uses, and cc0 setters, force them to remain      in order at the end of the block by adding dependencies and giving      the last a high priority.  There may be notes present, and prev_head      may also be a note.       Branches must obviously remain at the end.  Calls should remain at the      end since moving them results in worse register allocation.  Uses remain      at the end to ensure proper register allocation.  cc0 setters remaim      at the end because they can't be moved away from their cc0 user.  */
name|last
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|||
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|USE
ifdef|#
directive|ifdef
name|HAVE_cc0
operator|||
name|sets_cc0_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
endif|#
directive|endif
operator|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
condition|)
block|{
name|priority
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|last
operator|==
literal|0
condition|)
block|{
name|ready
index|[
name|n_ready
operator|++
index|]
operator|=
name|insn
expr_stmt|;
name|INSN_PRIORITY
argument_list|(
name|insn
argument_list|)
operator|=
name|TAIL_PRIORITY
operator|-
name|i
expr_stmt|;
name|INSN_REF_COUNT
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|find_insn_list
argument_list|(
name|insn
argument_list|,
name|LOG_LINKS
argument_list|(
name|last
argument_list|)
argument_list|)
condition|)
block|{
name|add_dependence
argument_list|(
name|last
argument_list|,
name|insn
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|INSN_REF_COUNT
argument_list|(
name|insn
argument_list|)
operator|++
expr_stmt|;
block|}
name|last
operator|=
name|insn
expr_stmt|;
comment|/* Skip over insns that are part of a group.  */
while|while
condition|(
name|SCHED_GROUP_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|insn
operator|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|priority
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Don't overrun the bounds of the basic block.  */
if|if
condition|(
name|insn
operator|==
name|prev_head
condition|)
break|break;
block|}
comment|/* Assign priorities to instructions.  Also check whether they      are in priority order already.  If so then I will be nonnegative.      We use this shortcut only before reloading.  */
if|#
directive|if
literal|0
block|i = reload_completed ? DONE_PRIORITY : MAX_PRIORITY;
endif|#
directive|endif
for|for
control|(
init|;
name|insn
operator|!=
name|prev_head
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
block|{
name|priority
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|INSN_REF_COUNT
argument_list|(
name|insn
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|last
operator|==
literal|0
condition|)
name|ready
index|[
name|n_ready
operator|++
index|]
operator|=
name|insn
expr_stmt|;
else|else
block|{
comment|/* Make this dependent on the last of the instructions 		     that must remain in order at the end of the block.  */
name|add_dependence
argument_list|(
name|last
argument_list|,
name|insn
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|INSN_REF_COUNT
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|SCHED_GROUP_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
while|while
condition|(
name|SCHED_GROUP_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|insn
operator|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|priority
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
if|#
directive|if
literal|0
block|if (i< 0) 	    continue; 	  if (INSN_PRIORITY (insn)< i) 	    i = INSN_PRIORITY (insn); 	  else if (INSN_PRIORITY (insn)> i) 	    i = DONE_PRIORITY;
endif|#
directive|endif
block|}
block|}
if|#
directive|if
literal|0
comment|/* This short-cut doesn't work.  It does not count call insns crossed by      registers in reg_sometimes_live.  It does not mark these registers as      dead if they die in this block.  It does not mark these registers live      (or create new reg_sometimes_live entries if necessary) if they are born      in this block.       The easy solution is to just always schedule a block.  These blocks tend      to be very short, so this doesn't slow down this pass by much.  */
comment|/* If existing order is good, don't bother to reorder.  */
block|if (i != DONE_PRIORITY)     {       if (file) 	fprintf (file, ";; already scheduled\n");        if (reload_completed == 0) 	{ 	  for (i = 0; i< sometimes_max; i++) 	    regs_sometimes_live[i].live_length += n_insns;  	  finish_sometimes_live (regs_sometimes_live, sometimes_max); 	}       free_pending_lists ();       goto ret;     }
endif|#
directive|endif
comment|/* Scan all the insns to be scheduled, removing NOTE insns      and register death notes.      Line number NOTE insns end up in NOTE_LIST.      Register death notes end up in DEAD_NOTES.       Recreate the register life information for the end of this basic      block.  */
if|if
condition|(
name|reload_completed
operator|==
literal|0
condition|)
block|{
name|COPY_REG_SET
argument_list|(
name|bb_live_regs
argument_list|,
name|BASIC_BLOCK
argument_list|(
name|b
argument_list|)
operator|->
name|global_live_at_start
argument_list|)
expr_stmt|;
name|CLEAR_REG_SET
argument_list|(
name|bb_dead_regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|==
literal|0
condition|)
block|{
comment|/* This is the first block in the function.  There may be insns 	     before head that we can't schedule.   We still need to examine 	     them though for accurate register lifetime analysis.  */
comment|/* We don't want to remove any REG_DEAD notes as the code below 	     does.  */
for|for
control|(
name|insn
operator|=
name|BLOCK_HEAD
argument_list|(
name|b
argument_list|)
init|;
name|insn
operator|!=
name|head
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
block|{
comment|/* See if the register gets born here.  */
comment|/* We must check for registers being born before we check for 		   registers dying.  It is possible for a register to be born 		   and die in the same insn, e.g. reading from a volatile 		   memory location into an otherwise unused register.  Such 		   a register must be marked as dead after this insn.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
name|sched_note_set
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
name|sched_note_set
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* ??? This code is obsolete and should be deleted.  It 		       is harmless though, so we will leave it in for now.  */
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
name|USE
condition|)
name|sched_note_set
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Each call clobbers (makes live) all call-clobbered regs 		   that are not global or fixed.  Note that the function-value 		   reg is a call_clobbered reg.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|call_used_regs
index|[
name|j
index|]
operator|&&
operator|!
name|global_regs
index|[
name|j
index|]
operator|&&
operator|!
name|fixed_regs
index|[
name|j
index|]
condition|)
block|{
name|SET_REGNO_REG_SET
argument_list|(
name|bb_live_regs
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|CLEAR_REGNO_REG_SET
argument_list|(
name|bb_dead_regs
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_DEAD
operator|||
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_UNUSED
operator|)
comment|/* Verify that the REG_NOTE has a valid value.  */
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
specifier|register
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|j
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
operator|--
name|j
operator|>=
literal|0
condition|)
block|{
name|CLEAR_REGNO_REG_SET
argument_list|(
name|bb_live_regs
argument_list|,
name|regno
operator|+
name|j
argument_list|)
expr_stmt|;
name|SET_REGNO_REG_SET
argument_list|(
name|bb_dead_regs
argument_list|,
name|regno
operator|+
name|j
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|CLEAR_REGNO_REG_SET
argument_list|(
name|bb_live_regs
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|SET_REGNO_REG_SET
argument_list|(
name|bb_dead_regs
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
comment|/* If debugging information is being produced, keep track of the line      number notes for each insn.  */
if|if
condition|(
name|write_symbols
operator|!=
name|NO_DEBUG
condition|)
block|{
comment|/* We must use the true line number for the first insn in the block 	 that was computed and saved at the start of this pass.  We can't 	 use the current line number, because scheduling of the previous 	 block may have changed the current line number.  */
name|rtx
name|line
init|=
name|line_note_head
index|[
name|b
index|]
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|BLOCK_HEAD
argument_list|(
name|b
argument_list|)
init|;
name|insn
operator|!=
name|next_tail
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|>
literal|0
condition|)
name|line
operator|=
name|insn
expr_stmt|;
else|else
name|LINE_NOTE
argument_list|(
name|insn
argument_list|)
operator|=
name|line
expr_stmt|;
block|}
for|for
control|(
name|insn
operator|=
name|head
init|;
name|insn
operator|!=
name|next_tail
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|rtx
name|prev
decl_stmt|,
name|next
decl_stmt|,
name|link
decl_stmt|;
comment|/* Farm out notes.  This is needed to keep the debugger from 	 getting completely deranged.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
block|{
name|prev
operator|=
name|insn
expr_stmt|;
name|insn
operator|=
name|unlink_notes
argument_list|(
name|insn
argument_list|,
name|next_tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|==
name|tail
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|prev
operator|==
name|head
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|next_tail
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|reload_completed
operator|==
literal|0
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
block|{
comment|/* See if the register gets born here.  */
comment|/* We must check for registers being born before we check for 	     registers dying.  It is possible for a register to be born and 	     die in the same insn, e.g. reading from a volatile memory 	     location into an otherwise unused register.  Such a register 	     must be marked as dead after this insn.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
name|sched_note_set
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
name|sched_note_set
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* ??? This code is obsolete and should be deleted.  It 		 is harmless though, so we will leave it in for now.  */
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
name|USE
condition|)
name|sched_note_set
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Each call clobbers (makes live) all call-clobbered regs that are 	     not global or fixed.  Note that the function-value reg is a 	     call_clobbered reg.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|call_used_regs
index|[
name|j
index|]
operator|&&
operator|!
name|global_regs
index|[
name|j
index|]
operator|&&
operator|!
name|fixed_regs
index|[
name|j
index|]
condition|)
block|{
name|SET_REGNO_REG_SET
argument_list|(
name|bb_live_regs
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|CLEAR_REGNO_REG_SET
argument_list|(
name|bb_dead_regs
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Need to know what registers this insn kills.  */
for|for
control|(
name|prev
operator|=
literal|0
operator|,
name|link
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|next
control|)
block|{
name|next
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_DEAD
operator|||
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_UNUSED
operator|)
comment|/* Verify that the REG_NOTE has a valid value.  */
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
specifier|register
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Only unlink REG_DEAD notes; leave REG_UNUSED notes 		     alone.  */
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_DEAD
condition|)
block|{
if|if
condition|(
name|prev
condition|)
name|XEXP
argument_list|(
name|prev
argument_list|,
literal|1
argument_list|)
operator|=
name|next
expr_stmt|;
else|else
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|next
expr_stmt|;
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
operator|=
name|dead_notes
expr_stmt|;
name|dead_notes
operator|=
name|link
expr_stmt|;
block|}
else|else
name|prev
operator|=
name|link
expr_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|j
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
operator|--
name|j
operator|>=
literal|0
condition|)
block|{
name|CLEAR_REGNO_REG_SET
argument_list|(
name|bb_live_regs
argument_list|,
name|regno
operator|+
name|j
argument_list|)
expr_stmt|;
name|SET_REGNO_REG_SET
argument_list|(
name|bb_dead_regs
argument_list|,
name|regno
operator|+
name|j
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|CLEAR_REGNO_REG_SET
argument_list|(
name|bb_live_regs
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|SET_REGNO_REG_SET
argument_list|(
name|bb_dead_regs
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|prev
operator|=
name|link
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|reload_completed
operator|==
literal|0
condition|)
block|{
comment|/* Keep track of register lives.  */
name|old_live_regs
operator|=
name|ALLOCA_REG_SET
argument_list|()
expr_stmt|;
name|regs_sometimes_live
operator|=
operator|(
expr|struct
name|sometimes
operator|*
operator|)
name|alloca
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sometimes
argument_list|)
argument_list|)
expr_stmt|;
name|sometimes_max
operator|=
literal|0
expr_stmt|;
comment|/* Start with registers live at end.  */
name|COPY_REG_SET
argument_list|(
name|old_live_regs
argument_list|,
name|bb_live_regs
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|bb_live_regs
argument_list|,
literal|0
argument_list|,
argument|j
argument_list|,
argument|{ 				   sometimes_max 				     = new_sometimes_live (regs_sometimes_live, 							   j, sometimes_max); 				 }
argument_list|)
empty_stmt|;
block|}
name|SCHED_SORT
argument_list|(
name|ready
argument_list|,
name|n_ready
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";; ready list initially:\n;; "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_ready
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d "
argument_list|,
name|INSN_UID
argument_list|(
name|ready
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|head
init|;
name|insn
operator|!=
name|next_tail
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_PRIORITY
argument_list|(
name|insn
argument_list|)
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";; insn[%4d]: priority = %4d, ref_count = %4d\n"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|INSN_PRIORITY
argument_list|(
name|insn
argument_list|)
argument_list|,
name|INSN_REF_COUNT
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Now HEAD and TAIL are going to become disconnected      entirely from the insn chain.  */
name|tail
operator|=
literal|0
expr_stmt|;
comment|/* Q_SIZE will always be zero here.  */
name|q_ptr
operator|=
literal|0
expr_stmt|;
name|clock
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|insn_queue
argument_list|,
sizeof|sizeof
argument_list|(
name|insn_queue
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now, perform list scheduling.  */
comment|/* Where we start inserting insns is after TAIL.  */
name|last
operator|=
name|next_tail
expr_stmt|;
name|new_needs
operator|=
operator|(
name|NEXT_INSN
argument_list|(
name|prev_head
argument_list|)
operator|==
name|BLOCK_HEAD
argument_list|(
name|b
argument_list|)
condition|?
name|NEED_HEAD
else|:
name|NEED_NOTHING
operator|)
expr_stmt|;
if|if
condition|(
name|PREV_INSN
argument_list|(
name|next_tail
argument_list|)
operator|==
name|BLOCK_END
argument_list|(
name|b
argument_list|)
condition|)
name|new_needs
operator||=
name|NEED_TAIL
expr_stmt|;
name|new_ready
operator|=
name|n_ready
expr_stmt|;
while|while
condition|(
name|sched_n_insns
operator|<
name|n_insns
condition|)
block|{
name|q_ptr
operator|=
name|NEXT_Q
argument_list|(
name|q_ptr
argument_list|)
expr_stmt|;
name|clock
operator|++
expr_stmt|;
comment|/* Add all pending insns that can be scheduled without stalls to the 	 ready list.  */
for|for
control|(
name|insn
operator|=
name|insn_queue
index|[
name|q_ptr
index|]
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|file
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";; launching %d before %d with no stalls at T-%d\n"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|INSN_UID
argument_list|(
name|last
argument_list|)
argument_list|,
name|clock
argument_list|)
expr_stmt|;
name|ready
index|[
name|new_ready
operator|++
index|]
operator|=
name|insn
expr_stmt|;
name|q_size
operator|-=
literal|1
expr_stmt|;
block|}
name|insn_queue
index|[
name|q_ptr
index|]
operator|=
literal|0
expr_stmt|;
comment|/* If there are no ready insns, stall until one is ready and add all 	 of the pending insns at that point to the ready list.  */
if|if
condition|(
name|new_ready
operator|==
literal|0
condition|)
block|{
specifier|register
name|int
name|stalls
decl_stmt|;
for|for
control|(
name|stalls
operator|=
literal|1
init|;
name|stalls
operator|<
name|INSN_QUEUE_SIZE
condition|;
name|stalls
operator|++
control|)
if|if
condition|(
operator|(
name|insn
operator|=
name|insn_queue
index|[
name|NEXT_Q_AFTER
argument_list|(
name|q_ptr
argument_list|,
name|stalls
argument_list|)
index|]
operator|)
condition|)
block|{
for|for
control|(
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|file
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";; launching %d before %d with %d stalls at T-%d\n"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|INSN_UID
argument_list|(
name|last
argument_list|)
argument_list|,
name|stalls
argument_list|,
name|clock
argument_list|)
expr_stmt|;
name|ready
index|[
name|new_ready
operator|++
index|]
operator|=
name|insn
expr_stmt|;
name|q_size
operator|-=
literal|1
expr_stmt|;
block|}
name|insn_queue
index|[
name|NEXT_Q_AFTER
argument_list|(
name|q_ptr
argument_list|,
name|stalls
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|q_ptr
operator|=
name|NEXT_Q_AFTER
argument_list|(
name|q_ptr
argument_list|,
name|stalls
argument_list|)
expr_stmt|;
name|clock
operator|+=
name|stalls
expr_stmt|;
block|}
comment|/* There should be some instructions waiting to fire.  */
if|if
condition|(
name|new_ready
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|file
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";; ready list at T-%d:"
argument_list|,
name|clock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|new_ready
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %d (%x)"
argument_list|,
name|INSN_UID
argument_list|(
name|ready
index|[
name|i
index|]
argument_list|)
argument_list|,
name|INSN_PRIORITY
argument_list|(
name|ready
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Sort the ready list and choose the best insn to schedule.  Select 	 which insn should issue in this cycle and queue those that are 	 blocked by function unit hazards.  	 N_READY holds the number of items that were scheduled the last time, 	 minus the one instruction scheduled on the last loop iteration; it 	 is not modified for any other reason in this loop.  */
name|SCHED_SORT
argument_list|(
name|ready
argument_list|,
name|new_ready
argument_list|,
name|n_ready
argument_list|)
expr_stmt|;
if|if
condition|(
name|MAX_BLOCKAGE
operator|>
literal|1
condition|)
block|{
name|new_ready
operator|=
name|schedule_select
argument_list|(
name|ready
argument_list|,
name|new_ready
argument_list|,
name|clock
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_ready
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|file
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* We must set n_ready here, to ensure that sorting always 		 occurs when we come back to the SCHED_SORT line above.  */
name|n_ready
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
block|}
name|n_ready
operator|=
name|new_ready
expr_stmt|;
name|last_scheduled_insn
operator|=
name|insn
operator|=
name|ready
index|[
literal|0
index|]
expr_stmt|;
comment|/* The first insn scheduled becomes the new tail.  */
if|if
condition|(
name|tail
operator|==
literal|0
condition|)
name|tail
operator|=
name|insn
expr_stmt|;
if|if
condition|(
name|file
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|", now"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_ready
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %d"
argument_list|,
name|INSN_UID
argument_list|(
name|ready
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DONE_PRIORITY_P
argument_list|(
name|insn
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|reload_completed
operator|==
literal|0
condition|)
block|{
comment|/* Process this insn, and each insn linked to this one which must 	     be immediately output after this insn.  */
do|do
block|{
comment|/* First we kill registers set by this insn, and then we 		 make registers used by this insn live.  This is the opposite 		 order used above because we are traversing the instructions 		 backwards.  */
comment|/* Strictly speaking, we should scan REG_UNUSED notes and make 		 every register mentioned there live, however, we will just 		 kill them again immediately below, so there doesn't seem to 		 be any reason why we bother to do this.  */
comment|/* See if this is the last notice we must take of a register.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
name|sched_note_set
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
name|sched_note_set
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* This code keeps life analysis information up to date.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
specifier|register
name|struct
name|sometimes
modifier|*
name|p
decl_stmt|;
comment|/* A call kills all call used registers that are not 		     global or fixed, except for those mentioned in the call 		     pattern which will be made live again later.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|call_used_regs
index|[
name|i
index|]
operator|&&
operator|!
name|global_regs
index|[
name|i
index|]
operator|&&
operator|!
name|fixed_regs
index|[
name|i
index|]
condition|)
block|{
name|CLEAR_REGNO_REG_SET
argument_list|(
name|bb_live_regs
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|SET_REGNO_REG_SET
argument_list|(
name|bb_dead_regs
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* Regs live at the time of a call instruction must not 		     go in a register clobbered by calls.  Record this for 		     all regs now live.  Note that insns which are born or 		     die in a call do not cross a call, so this must be done 		     after the killings (above) and before the births 		     (below).  */
name|p
operator|=
name|regs_sometimes_live
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sometimes_max
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
if|if
condition|(
name|REGNO_REG_SET_P
argument_list|(
name|bb_live_regs
argument_list|,
name|p
operator|->
name|regno
argument_list|)
condition|)
name|p
operator|->
name|calls_crossed
operator|+=
literal|1
expr_stmt|;
block|}
comment|/* Make every register used live, and add REG_DEAD notes for 		 registers which were not live before we started.  */
name|attach_deaths_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Find registers now made live by that instruction.  */
name|EXECUTE_IF_AND_COMPL_IN_REG_SET
argument_list|(
argument|bb_live_regs
argument_list|,
argument|old_live_regs
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|{ 						 sometimes_max 						   = new_sometimes_live (regs_sometimes_live, 									 i, sometimes_max); 					       }
argument_list|)
empty_stmt|;
name|IOR_REG_SET
argument_list|(
name|old_live_regs
argument_list|,
name|bb_live_regs
argument_list|)
expr_stmt|;
comment|/* Count lengths of all regs we are worrying about now, 		 and handle registers no longer live.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sometimes_max
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|struct
name|sometimes
modifier|*
name|p
init|=
operator|&
name|regs_sometimes_live
index|[
name|i
index|]
decl_stmt|;
name|int
name|regno
init|=
name|p
operator|->
name|regno
decl_stmt|;
name|p
operator|->
name|live_length
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|REGNO_REG_SET_P
argument_list|(
name|bb_live_regs
argument_list|,
name|p
operator|->
name|regno
argument_list|)
condition|)
block|{
comment|/* This is the end of one of this register's lifetime 			 segments.  Save the lifetime info collected so far, 			 and clear its bit in the old_live_regs entry.  */
name|sched_reg_live_length
index|[
name|regno
index|]
operator|+=
name|p
operator|->
name|live_length
expr_stmt|;
name|sched_reg_n_calls_crossed
index|[
name|regno
index|]
operator|+=
name|p
operator|->
name|calls_crossed
expr_stmt|;
name|CLEAR_REGNO_REG_SET
argument_list|(
name|old_live_regs
argument_list|,
name|p
operator|->
name|regno
argument_list|)
expr_stmt|;
comment|/* Delete the reg_sometimes_live entry for this reg by 			 copying the last entry over top of it.  */
operator|*
name|p
operator|=
name|regs_sometimes_live
index|[
operator|--
name|sometimes_max
index|]
expr_stmt|;
comment|/* ...and decrement i so that this newly copied entry 			 will be processed.  */
name|i
operator|--
expr_stmt|;
block|}
block|}
name|link
operator|=
name|insn
expr_stmt|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|SCHED_GROUP_P
argument_list|(
name|link
argument_list|)
condition|)
do|;
comment|/* Set INSN back to the insn we are scheduling now.  */
name|insn
operator|=
name|ready
index|[
literal|0
index|]
expr_stmt|;
block|}
comment|/* Schedule INSN.  Remove it from the ready list.  */
name|ready
operator|+=
literal|1
expr_stmt|;
name|n_ready
operator|-=
literal|1
expr_stmt|;
name|sched_n_insns
operator|+=
literal|1
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|last
expr_stmt|;
name|PREV_INSN
argument_list|(
name|last
argument_list|)
operator|=
name|insn
expr_stmt|;
comment|/* Everything that precedes INSN now either becomes "ready", if 	 it can execute immediately before INSN, or "pending", if 	 there must be a delay.  Give INSN high enough priority that 	 at least one (maybe more) reg-killing insns can be launched 	 ahead of all others.  Mark INSN as scheduled by changing its 	 priority to -1.  */
name|INSN_PRIORITY
argument_list|(
name|insn
argument_list|)
operator|=
name|LAUNCH_PRIORITY
expr_stmt|;
name|new_ready
operator|=
name|schedule_insn
argument_list|(
name|insn
argument_list|,
name|ready
argument_list|,
name|n_ready
argument_list|,
name|clock
argument_list|)
expr_stmt|;
name|INSN_PRIORITY
argument_list|(
name|insn
argument_list|)
operator|=
name|DONE_PRIORITY
expr_stmt|;
comment|/* Schedule all prior insns that must not be moved.  */
if|if
condition|(
name|SCHED_GROUP_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
comment|/* Disable these insns from being launched, in case one of the 	     insns in the group has a dependency on an earlier one.  */
name|link
operator|=
name|insn
expr_stmt|;
while|while
condition|(
name|SCHED_GROUP_P
argument_list|(
name|link
argument_list|)
condition|)
block|{
comment|/* Disable these insns from being launched by anybody.  */
name|link
operator|=
name|PREV_INSN
argument_list|(
name|link
argument_list|)
expr_stmt|;
name|INSN_REF_COUNT
argument_list|(
name|link
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Now handle each group insn like the main insn was handled 	     above.  */
name|link
operator|=
name|insn
expr_stmt|;
while|while
condition|(
name|SCHED_GROUP_P
argument_list|(
name|link
argument_list|)
condition|)
block|{
name|link
operator|=
name|PREV_INSN
argument_list|(
name|link
argument_list|)
expr_stmt|;
name|sched_n_insns
operator|+=
literal|1
expr_stmt|;
comment|/* ??? Why don't we set LAUNCH_PRIORITY here?  */
name|new_ready
operator|=
name|schedule_insn
argument_list|(
name|link
argument_list|,
name|ready
argument_list|,
name|new_ready
argument_list|,
name|clock
argument_list|)
expr_stmt|;
name|INSN_PRIORITY
argument_list|(
name|link
argument_list|)
operator|=
name|DONE_PRIORITY
expr_stmt|;
block|}
block|}
comment|/* Put back NOTE_INSN_SETJMP,          NOTE_INSN_{LOOP,EHREGION}_{BEGIN,END} notes.  */
comment|/* To prime the loop.  We need to handle INSN and all the insns in the          sched group.  */
name|last
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
do|do
block|{
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|last
argument_list|)
expr_stmt|;
comment|/* Maintain a valid chain so emit_note_before works. 	     This is necessary because PREV_INSN (insn) isn't valid 	     (if ! SCHED_GROUP_P) and if it points to an insn already 	     scheduled, a circularity will result.  */
if|if
condition|(
operator|!
name|SCHED_GROUP_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|NEXT_INSN
argument_list|(
name|prev_head
argument_list|)
operator|=
name|insn
expr_stmt|;
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|prev_head
expr_stmt|;
block|}
name|last
operator|=
name|reemit_notes
argument_list|(
name|insn
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|SCHED_GROUP_P
argument_list|(
name|insn
argument_list|)
condition|)
do|;
block|}
if|if
condition|(
name|q_size
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|reload_completed
operator|==
literal|0
condition|)
name|finish_sometimes_live
argument_list|(
name|regs_sometimes_live
argument_list|,
name|sometimes_max
argument_list|)
expr_stmt|;
comment|/* HEAD is now the first insn in the chain of insns that      been scheduled by the loop above.      TAIL is the last of those insns.  */
name|head
operator|=
name|last
expr_stmt|;
comment|/* NOTE_LIST is the end of a chain of notes previously found      among the insns.  Insert them at the beginning of the insns.  */
if|if
condition|(
name|note_list
operator|!=
literal|0
condition|)
block|{
name|rtx
name|note_head
init|=
name|note_list
decl_stmt|;
while|while
condition|(
name|PREV_INSN
argument_list|(
name|note_head
argument_list|)
condition|)
name|note_head
operator|=
name|PREV_INSN
argument_list|(
name|note_head
argument_list|)
expr_stmt|;
name|PREV_INSN
argument_list|(
name|head
argument_list|)
operator|=
name|note_list
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|note_list
argument_list|)
operator|=
name|head
expr_stmt|;
name|head
operator|=
name|note_head
expr_stmt|;
block|}
comment|/* There should be no REG_DEAD notes leftover at the end.      In practice, this can occur as the result of bugs in flow, combine.c,      and/or sched.c.  The values of the REG_DEAD notes remaining are      meaningless, because dead_notes is just used as a free list.  */
if|#
directive|if
literal|1
if|if
condition|(
name|dead_notes
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|new_needs
operator|&
name|NEED_HEAD
condition|)
name|BLOCK_HEAD
argument_list|(
name|b
argument_list|)
operator|=
name|head
expr_stmt|;
name|PREV_INSN
argument_list|(
name|head
argument_list|)
operator|=
name|prev_head
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|prev_head
argument_list|)
operator|=
name|head
expr_stmt|;
if|if
condition|(
name|new_needs
operator|&
name|NEED_TAIL
condition|)
name|BLOCK_END
argument_list|(
name|b
argument_list|)
operator|=
name|tail
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|tail
argument_list|)
operator|=
name|next_tail
expr_stmt|;
name|PREV_INSN
argument_list|(
name|next_tail
argument_list|)
operator|=
name|tail
expr_stmt|;
comment|/* Restore the line-number notes of each insn.  */
if|if
condition|(
name|write_symbols
operator|!=
name|NO_DEBUG
condition|)
block|{
name|rtx
name|line
decl_stmt|,
name|note
decl_stmt|,
name|prev
decl_stmt|,
name|new
decl_stmt|;
name|int
name|notes
init|=
literal|0
decl_stmt|;
name|head
operator|=
name|BLOCK_HEAD
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|next_tail
operator|=
name|NEXT_INSN
argument_list|(
name|BLOCK_END
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Determine the current line-number.  We want to know the current 	 line number of the first insn of the block here, in case it is 	 different from the true line number that was saved earlier.  If 	 different, then we need a line number note before the first insn 	 of this block.  If it happens to be the same, then we don't want to 	 emit another line number note here.  */
for|for
control|(
name|line
operator|=
name|head
init|;
name|line
condition|;
name|line
operator|=
name|PREV_INSN
argument_list|(
name|line
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|line
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|line
argument_list|)
operator|>
literal|0
condition|)
break|break;
comment|/* Walk the insns keeping track of the current line-number and inserting 	 the line-number notes as needed.  */
for|for
control|(
name|insn
operator|=
name|head
init|;
name|insn
operator|!=
name|next_tail
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|>
literal|0
condition|)
name|line
operator|=
name|insn
expr_stmt|;
comment|/* This used to emit line number notes before every non-deleted note. 	 However, this confuses a debugger, because line notes not separated 	 by real instructions all end up at the same address.  I can find no 	 use for line number notes before other notes, so none are emitted.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
operator|&&
operator|(
name|note
operator|=
name|LINE_NOTE
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|note
operator|!=
name|line
operator|&&
operator|(
name|line
operator|==
literal|0
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|note
argument_list|)
operator|!=
name|NOTE_LINE_NUMBER
argument_list|(
name|line
argument_list|)
operator|||
name|NOTE_SOURCE_FILE
argument_list|(
name|note
argument_list|)
operator|!=
name|NOTE_SOURCE_FILE
argument_list|(
name|line
argument_list|)
operator|)
condition|)
block|{
name|line
operator|=
name|note
expr_stmt|;
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|LINE_NOTE
argument_list|(
name|note
argument_list|)
condition|)
block|{
comment|/* Re-use the original line-number note.  */
name|LINE_NOTE
argument_list|(
name|note
argument_list|)
operator|=
literal|0
expr_stmt|;
name|PREV_INSN
argument_list|(
name|note
argument_list|)
operator|=
name|prev
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|prev
argument_list|)
operator|=
name|note
expr_stmt|;
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|note
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|note
argument_list|)
operator|=
name|insn
expr_stmt|;
block|}
else|else
block|{
name|notes
operator|++
expr_stmt|;
name|new
operator|=
name|emit_note_after
argument_list|(
name|NOTE_LINE_NUMBER
argument_list|(
name|note
argument_list|)
argument_list|,
name|prev
argument_list|)
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|new
argument_list|)
operator|=
name|NOTE_SOURCE_FILE
argument_list|(
name|note
argument_list|)
expr_stmt|;
name|RTX_INTEGRATED_P
argument_list|(
name|new
argument_list|)
operator|=
name|RTX_INTEGRATED_P
argument_list|(
name|note
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|file
operator|&&
name|notes
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";; added %d line-number notes\n"
argument_list|,
name|notes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|file
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";; total time = %d\n;; new basic block head = %d\n;; new basic block end = %d\n\n"
argument_list|,
name|clock
argument_list|,
name|INSN_UID
argument_list|(
name|BLOCK_HEAD
argument_list|(
name|b
argument_list|)
argument_list|)
argument_list|,
name|INSN_UID
argument_list|(
name|BLOCK_END
argument_list|(
name|b
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Yow! We're done!  */
name|free_pending_lists
argument_list|()
expr_stmt|;
name|ret
label|:
name|FREE_REG_SET
argument_list|(
name|reg_pending_sets
argument_list|)
expr_stmt|;
name|FREE_REG_SET
argument_list|(
name|old_live_regs
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine of update_flow_info.  Determines whether any new REG_NOTEs are    needed for the hard register mentioned in the note.  This can happen    if the reference to the hard register in the original insn was split into    several smaller hard register references in the split insns.  */
end_comment

begin_function
specifier|static
name|void
name|split_hard_reg_notes
parameter_list|(
name|note
parameter_list|,
name|first
parameter_list|,
name|last
parameter_list|)
name|rtx
name|note
decl_stmt|,
name|first
decl_stmt|,
name|last
decl_stmt|;
block|{
name|rtx
name|reg
decl_stmt|,
name|temp
decl_stmt|,
name|link
decl_stmt|;
name|int
name|n_regs
decl_stmt|,
name|i
decl_stmt|,
name|new_reg
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
comment|/* Assume that this is a REG_DEAD note.  */
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|!=
name|REG_DEAD
condition|)
name|abort
argument_list|()
expr_stmt|;
name|reg
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|n_regs
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_regs
condition|;
name|i
operator|++
control|)
block|{
name|new_reg
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|+
name|i
expr_stmt|;
comment|/* Check for references to new_reg in the split insns.  */
for|for
control|(
name|insn
operator|=
name|last
init|;
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
operator|(
name|temp
operator|=
name|regno_use_in
argument_list|(
name|new_reg
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/* Create a new reg dead note here.  */
name|link
operator|=
name|rtx_alloc
argument_list|(
name|EXPR_LIST
argument_list|)
expr_stmt|;
name|PUT_REG_NOTE_KIND
argument_list|(
name|link
argument_list|,
name|REG_DEAD
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
operator|=
name|temp
expr_stmt|;
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|link
expr_stmt|;
comment|/* If killed multiple registers here, then add in the excess.  */
name|i
operator|+=
name|HARD_REGNO_NREGS
argument_list|(
name|REGNO
argument_list|(
name|temp
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|-
literal|1
expr_stmt|;
break|break;
block|}
comment|/* It isn't mentioned anywhere, so no new reg note is needed for 	     this register.  */
if|if
condition|(
name|insn
operator|==
name|first
condition|)
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Subroutine of update_flow_info.  Determines whether a SET or CLOBBER in an    insn created by splitting needs a REG_DEAD or REG_UNUSED note added.  */
end_comment

begin_function
specifier|static
name|void
name|new_insn_dead_notes
parameter_list|(
name|pat
parameter_list|,
name|insn
parameter_list|,
name|last
parameter_list|,
name|orig_insn
parameter_list|)
name|rtx
name|pat
decl_stmt|,
name|insn
decl_stmt|,
name|last
decl_stmt|,
name|orig_insn
decl_stmt|;
block|{
name|rtx
name|dest
decl_stmt|,
name|tem
decl_stmt|,
name|set
decl_stmt|;
comment|/* PAT is either a CLOBBER or a SET here.  */
name|dest
operator|=
name|XEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SIGN_EXTRACT
condition|)
name|dest
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
condition|)
block|{
comment|/* If the original insn already used this register, we may not add new          notes for it.  One example for a split that needs this test is 	 when a multi-word memory access with register-indirect addressing 	 is split into multiple memory accesses with auto-increment and 	 one adjusting add instruction for the address register.  */
if|if
condition|(
name|reg_referenced_p
argument_list|(
name|dest
argument_list|,
name|PATTERN
argument_list|(
name|orig_insn
argument_list|)
argument_list|)
condition|)
return|return;
for|for
control|(
name|tem
operator|=
name|last
init|;
name|tem
operator|!=
name|insn
condition|;
name|tem
operator|=
name|PREV_INSN
argument_list|(
name|tem
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|dest
argument_list|,
name|PATTERN
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|&&
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|tem
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|tem_dest
init|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|tem_dest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|tem_dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|tem_dest
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|tem_dest
argument_list|)
operator|==
name|SIGN_EXTRACT
condition|)
name|tem_dest
operator|=
name|XEXP
argument_list|(
name|tem_dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|tem_dest
argument_list|,
name|dest
argument_list|)
condition|)
block|{
comment|/* Use the same scheme as combine.c, don't put both REG_DEAD 		     and REG_UNUSED notes on the same insn.  */
if|if
condition|(
operator|!
name|find_regno_note
argument_list|(
name|tem
argument_list|,
name|REG_UNUSED
argument_list|,
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|&&
operator|!
name|find_regno_note
argument_list|(
name|tem
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|note
init|=
name|rtx_alloc
argument_list|(
name|EXPR_LIST
argument_list|)
decl_stmt|;
name|PUT_REG_NOTE_KIND
argument_list|(
name|note
argument_list|,
name|REG_DEAD
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
operator|=
name|dest
expr_stmt|;
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
operator|=
name|REG_NOTES
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|tem
argument_list|)
operator|=
name|note
expr_stmt|;
block|}
comment|/* The reg only dies in one insn, the last one that uses 		     it.  */
break|break;
block|}
elseif|else
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|dest
argument_list|,
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
condition|)
comment|/* We found an instruction that both uses the register, 		   and sets it, so no new REG_NOTE is needed for this set.  */
break|break;
block|}
block|}
comment|/* If this is a set, it must die somewhere, unless it is the dest of 	 the original insn, and hence is live after the original insn.  Abort 	 if it isn't supposed to be live after the original insn.  	 If this is a clobber, then just add a REG_UNUSED note.  */
if|if
condition|(
name|tem
operator|==
name|insn
condition|)
block|{
name|int
name|live_after_orig_insn
init|=
literal|0
decl_stmt|;
name|rtx
name|pattern
init|=
name|PATTERN
argument_list|(
name|orig_insn
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|CLOBBER
condition|)
block|{
name|rtx
name|note
init|=
name|rtx_alloc
argument_list|(
name|EXPR_LIST
argument_list|)
decl_stmt|;
name|PUT_REG_NOTE_KIND
argument_list|(
name|note
argument_list|,
name|REG_UNUSED
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
operator|=
name|dest
expr_stmt|;
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|note
expr_stmt|;
return|return;
block|}
comment|/* The original insn could have multiple sets, so search the 	     insn for all sets.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|SET
condition|)
block|{
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|dest
argument_list|,
name|SET_DEST
argument_list|(
name|pattern
argument_list|)
argument_list|)
condition|)
name|live_after_orig_insn
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|dest
argument_list|,
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
condition|)
name|live_after_orig_insn
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|live_after_orig_insn
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Subroutine of update_flow_info.  Update the value of reg_n_sets for all    registers modified by X.  INC is -1 if the containing insn is being deleted,    and is 1 if the containing insn is a newly generated insn.  */
end_comment

begin_function
specifier|static
name|void
name|update_n_sets
parameter_list|(
name|x
parameter_list|,
name|inc
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|int
name|inc
decl_stmt|;
block|{
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SIGN_EXTRACT
condition|)
name|dest
operator|=
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
condition|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|endregno
init|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
name|regno
init|;
name|i
operator|<
name|endregno
condition|;
name|i
operator|++
control|)
name|REG_N_SETS
argument_list|(
name|i
argument_list|)
operator|+=
name|inc
expr_stmt|;
block|}
else|else
name|REG_N_SETS
argument_list|(
name|regno
argument_list|)
operator|+=
name|inc
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Updates all flow-analysis related quantities (including REG_NOTES) for    the insns from FIRST to LAST inclusive that were created by splitting    ORIG_INSN.  NOTES are the original REG_NOTES.  */
end_comment

begin_function
name|void
name|update_flow_info
parameter_list|(
name|notes
parameter_list|,
name|first
parameter_list|,
name|last
parameter_list|,
name|orig_insn
parameter_list|)
name|rtx
name|notes
decl_stmt|;
name|rtx
name|first
decl_stmt|,
name|last
decl_stmt|;
name|rtx
name|orig_insn
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|,
name|note
decl_stmt|;
name|rtx
name|next
decl_stmt|;
name|rtx
name|orig_dest
decl_stmt|,
name|temp
decl_stmt|;
name|rtx
name|set
decl_stmt|;
comment|/* Get and save the destination set by the original insn.  */
name|orig_dest
operator|=
name|single_set
argument_list|(
name|orig_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|orig_dest
condition|)
name|orig_dest
operator|=
name|SET_DEST
argument_list|(
name|orig_dest
argument_list|)
expr_stmt|;
comment|/* Move REG_NOTES from the original insn to where they now belong.  */
for|for
control|(
name|note
operator|=
name|notes
init|;
name|note
condition|;
name|note
operator|=
name|next
control|)
block|{
name|next
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
condition|)
block|{
case|case
name|REG_DEAD
case|:
case|case
name|REG_UNUSED
case|:
comment|/* Move these notes from the original insn to the last new insn where 	     the register is now set.  */
for|for
control|(
name|insn
operator|=
name|last
init|;
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
name|reg_mentioned_p
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
block|{
comment|/* If this note refers to a multiple word hard register, it 		     may have been split into several smaller hard register 		     references, so handle it specially.  */
name|temp
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_DEAD
operator|&&
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|temp
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|HARD_REGNO_NREGS
argument_list|(
name|REGNO
argument_list|(
name|temp
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|>
literal|1
condition|)
name|split_hard_reg_notes
argument_list|(
name|note
argument_list|,
name|first
argument_list|,
name|last
argument_list|)
expr_stmt|;
else|else
block|{
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|note
expr_stmt|;
block|}
comment|/* Sometimes need to convert REG_UNUSED notes to REG_DEAD 		     notes.  */
comment|/* ??? This won't handle multiple word registers correctly, 		     but should be good enough for now.  */
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_UNUSED
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SCRATCH
operator|&&
operator|!
name|dead_or_set_p
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|PUT_REG_NOTE_KIND
argument_list|(
name|note
argument_list|,
name|REG_DEAD
argument_list|)
expr_stmt|;
comment|/* The reg only dies in one insn, the last one that uses 		     it.  */
break|break;
block|}
comment|/* It must die somewhere, fail it we couldn't find where it died.  		 If this is a REG_UNUSED note, then it must be a temporary 		 register that was not needed by this instantiation of the 		 pattern, so we can safely ignore it.  */
if|if
condition|(
name|insn
operator|==
name|first
condition|)
block|{
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|!=
name|REG_UNUSED
condition|)
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
name|REG_WAS_0
case|:
comment|/* If the insn that set the register to 0 was deleted, this 	     note cannot be relied on any longer.  The destination might 	     even have been moved to memory.              This was observed for SH4 with execute/920501-6.c compilation, 	     -O2 -fomit-frame-pointer -finline-functions .  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NOTE
operator|||
name|INSN_DELETED_P
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
break|break;
comment|/* This note applies to the dest of the original insn.  Find the 	     first new insn that now has the same dest, and move the note 	     there.  */
if|if
condition|(
operator|!
name|orig_dest
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|first
init|;
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
operator|(
name|temp
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
operator|)
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_DEST
argument_list|(
name|temp
argument_list|)
argument_list|,
name|orig_dest
argument_list|)
condition|)
block|{
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|note
expr_stmt|;
comment|/* The reg is only zero before one insn, the first that 		     uses it.  */
break|break;
block|}
comment|/* If this note refers to a multiple word hard 		 register, it may have been split into several smaller 		 hard register references.  We could split the notes, 		 but simply dropping them is good enough.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig_dest
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|orig_dest
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|HARD_REGNO_NREGS
argument_list|(
name|REGNO
argument_list|(
name|orig_dest
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|orig_dest
argument_list|)
argument_list|)
operator|>
literal|1
condition|)
break|break;
comment|/* It must be set somewhere, fail if we couldn't find where it 		 was set.  */
if|if
condition|(
name|insn
operator|==
name|last
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|REG_EQUAL
case|:
case|case
name|REG_EQUIV
case|:
comment|/* A REG_EQUIV or REG_EQUAL note on an insn with more than one 	     set is meaningless.  Just drop the note.  */
if|if
condition|(
operator|!
name|orig_dest
condition|)
break|break;
case|case
name|REG_NO_CONFLICT
case|:
comment|/* These notes apply to the dest of the original insn.  Find the last 	     new insn that now has the same dest, and move the note there.  */
if|if
condition|(
operator|!
name|orig_dest
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|last
init|;
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
operator|(
name|temp
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
operator|)
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_DEST
argument_list|(
name|temp
argument_list|)
argument_list|,
name|orig_dest
argument_list|)
condition|)
block|{
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|note
expr_stmt|;
comment|/* Only put this note on one of the new insns.  */
break|break;
block|}
comment|/* The original dest must still be set someplace.  Abort if we 		 couldn't find it.  */
if|if
condition|(
name|insn
operator|==
name|first
condition|)
block|{
comment|/* However, if this note refers to a multiple word hard 		     register, it may have been split into several smaller 		     hard register references.  We could split the notes, 		     but simply dropping them is good enough.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig_dest
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|orig_dest
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|HARD_REGNO_NREGS
argument_list|(
name|REGNO
argument_list|(
name|orig_dest
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|orig_dest
argument_list|)
argument_list|)
operator|>
literal|1
condition|)
break|break;
comment|/* Likewise for multi-word memory references.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig_dest
argument_list|)
operator|==
name|MEM
operator|&&
name|SIZE_FOR_MODE
argument_list|(
name|orig_dest
argument_list|)
operator|>
name|MOVE_MAX
condition|)
break|break;
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
break|break;
case|case
name|REG_LIBCALL
case|:
comment|/* Move a REG_LIBCALL note to the first insn created, and update 	     the corresponding REG_RETVAL note.  */
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
operator|=
name|REG_NOTES
argument_list|(
name|first
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|first
argument_list|)
operator|=
name|note
expr_stmt|;
name|insn
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
condition|)
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
operator|=
name|first
expr_stmt|;
break|break;
case|case
name|REG_EXEC_COUNT
case|:
comment|/* Move a REG_EXEC_COUNT note to the first insn created.  */
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
operator|=
name|REG_NOTES
argument_list|(
name|first
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|first
argument_list|)
operator|=
name|note
expr_stmt|;
break|break;
case|case
name|REG_RETVAL
case|:
comment|/* Move a REG_RETVAL note to the last insn created, and update 	     the corresponding REG_LIBCALL note.  */
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
operator|=
name|REG_NOTES
argument_list|(
name|last
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|last
argument_list|)
operator|=
name|note
expr_stmt|;
name|insn
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_LIBCALL
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
condition|)
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
operator|=
name|last
expr_stmt|;
break|break;
case|case
name|REG_NONNEG
case|:
case|case
name|REG_BR_PROB
case|:
comment|/* This should be moved to whichever instruction is a JUMP_INSN.  */
for|for
control|(
name|insn
operator|=
name|last
init|;
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|note
expr_stmt|;
comment|/* Only put this note on one of the new insns.  */
break|break;
block|}
comment|/* Fail if we couldn't find a JUMP_INSN.  */
if|if
condition|(
name|insn
operator|==
name|first
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|REG_INC
case|:
comment|/* reload sometimes leaves obsolete REG_INC notes around.  */
if|if
condition|(
name|reload_completed
condition|)
break|break;
comment|/* This should be moved to whichever instruction now has the 	     increment operation.  */
name|abort
argument_list|()
expr_stmt|;
case|case
name|REG_LABEL
case|:
comment|/* Should be moved to the new insn(s) which use the label.  */
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
operator|!=
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
name|reg_mentioned_p
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_LABEL
argument_list|,
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG_CC_SETTER
case|:
case|case
name|REG_CC_USER
case|:
comment|/* These two notes will never appear until after reorg, so we don't 	     have to handle them here.  */
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Each new insn created, except the last, has a new set.  If the destination      is a register, then this reg is now live across several insns, whereas      previously the dest reg was born and died within the same insn.  To      reflect this, we now need a REG_DEAD note on the insn where this      dest reg dies.       Similarly, the new insns may have clobbers that need REG_UNUSED notes.  */
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
operator|!=
name|last
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|rtx
name|pat
decl_stmt|;
name|int
name|i
decl_stmt|;
name|pat
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|CLOBBER
condition|)
name|new_insn_dead_notes
argument_list|(
name|pat
argument_list|,
name|insn
argument_list|,
name|last
argument_list|,
name|orig_insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
name|new_insn_dead_notes
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|,
name|last
argument_list|,
name|orig_insn
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If any insn, except the last, uses the register set by the last insn,      then we need a new REG_DEAD note on that insn.  In this case, there      would not have been a REG_DEAD note for this register in the original      insn because it was used and set within one insn.  */
name|set
operator|=
name|single_set
argument_list|(
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
condition|)
block|{
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SIGN_EXTRACT
condition|)
name|dest
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
comment|/* Global registers are always live, so the code below does not 	     apply to them.  */
operator|&&
operator|(
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
operator|!
name|global_regs
index|[
name|REGNO
argument_list|(
name|dest
argument_list|)
index|]
operator|)
condition|)
block|{
name|rtx
name|stop_insn
init|=
name|PREV_INSN
argument_list|(
name|first
argument_list|)
decl_stmt|;
comment|/* If the last insn uses the register that it is setting, then 	     we don't want to put a REG_DEAD note there.  Search backwards 	     to find the first insn that sets but does not use DEST.  */
name|insn
operator|=
name|last
expr_stmt|;
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|dest
argument_list|,
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
condition|)
block|{
for|for
control|(
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
init|;
name|insn
operator|!=
name|first
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
operator|)
operator|&&
name|reg_mentioned_p
argument_list|(
name|dest
argument_list|,
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|&&
operator|!
name|reg_overlap_mentioned_p
argument_list|(
name|dest
argument_list|,
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
condition|)
break|break;
block|}
block|}
comment|/* Now find the first insn that uses but does not set DEST.  */
for|for
control|(
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
init|;
name|insn
operator|!=
name|stop_insn
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
name|reg_mentioned_p
argument_list|(
name|dest
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|&&
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|insn_dest
init|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|insn_dest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|insn_dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|insn_dest
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|insn_dest
argument_list|)
operator|==
name|SIGN_EXTRACT
condition|)
name|insn_dest
operator|=
name|XEXP
argument_list|(
name|insn_dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn_dest
operator|!=
name|dest
condition|)
block|{
name|note
operator|=
name|rtx_alloc
argument_list|(
name|EXPR_LIST
argument_list|)
expr_stmt|;
name|PUT_REG_NOTE_KIND
argument_list|(
name|note
argument_list|,
name|REG_DEAD
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
operator|=
name|dest
expr_stmt|;
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|note
expr_stmt|;
comment|/* The reg only dies in one insn, the last one 			 that uses it.  */
break|break;
block|}
block|}
block|}
block|}
block|}
comment|/* If the original dest is modifying a multiple register target, and the      original instruction was split such that the original dest is now set      by two or more SUBREG sets, then the split insns no longer kill the      destination of the original insn.       In this case, if there exists an instruction in the same basic block,      before the split insn, which uses the original dest, and this use is      killed by the original insn, then we must remove the REG_DEAD note on      this insn, because it is now superfluous.       This does not apply when a hard register gets split, because the code      knows how to handle overlapping hard registers properly.  */
if|if
condition|(
name|orig_dest
operator|&&
name|GET_CODE
argument_list|(
name|orig_dest
argument_list|)
operator|==
name|REG
condition|)
block|{
name|int
name|found_orig_dest
init|=
literal|0
decl_stmt|;
name|int
name|found_split_dest
init|=
literal|0
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|first
init|;
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|i
init|=
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
condition|?
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
else|:
literal|0
decl_stmt|;
name|set
operator|=
name|pat
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|set
argument_list|)
operator|==
name|SET
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REGNO
argument_list|(
name|orig_dest
argument_list|)
condition|)
block|{
name|found_orig_dest
operator|=
literal|1
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|orig_dest
condition|)
block|{
name|found_split_dest
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|--
name|i
operator|<
literal|0
condition|)
break|break;
name|set
operator|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|insn
operator|==
name|last
condition|)
break|break;
block|}
if|if
condition|(
name|found_split_dest
condition|)
block|{
comment|/* Search backwards from FIRST, looking for the first insn that uses 	     the original dest.  Stop if we pass a CODE_LABEL or a JUMP_INSN. 	     If we find an insn, and it has a REG_DEAD note, then delete the 	     note.  */
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
break|break;
elseif|else
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
name|reg_mentioned_p
argument_list|(
name|orig_dest
argument_list|,
name|insn
argument_list|)
condition|)
block|{
name|note
operator|=
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
name|orig_dest
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
condition|)
name|remove_note
argument_list|(
name|insn
argument_list|,
name|note
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|found_orig_dest
condition|)
block|{
name|int
name|i
decl_stmt|,
name|regno
decl_stmt|;
comment|/* Should never reach here for a pseudo reg.  */
if|if
condition|(
name|REGNO
argument_list|(
name|orig_dest
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* This can happen for a hard register, if the splitter 	     does not bother to emit instructions which would be no-ops. 	     We try to verify that this is the case by checking to see if 	     the original instruction uses all of the registers that it 	     set.  This case is OK, because deleting a no-op can not affect 	     REG_DEAD notes on other insns.  If this is not the case, then 	     abort.  */
name|regno
operator|=
name|REGNO
argument_list|(
name|orig_dest
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|orig_dest
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
operator|!
name|refers_to_regno_p
argument_list|(
name|regno
operator|+
name|i
argument_list|,
name|regno
operator|+
name|i
operator|+
literal|1
argument_list|,
name|orig_insn
argument_list|,
name|NULL_PTR
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Update reg_n_sets.  This is necessary to prevent local alloc from      converting REG_EQUAL notes to REG_EQUIV when splitting has modified      a reg from set once to set multiple times.  */
block|{
name|rtx
name|x
init|=
name|PATTERN
argument_list|(
name|orig_insn
argument_list|)
decl_stmt|;
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|SET
operator|||
name|code
operator|==
name|CLOBBER
condition|)
name|update_n_sets
argument_list|(
name|x
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|code
operator|=
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|SET
operator|||
name|code
operator|==
name|CLOBBER
condition|)
name|update_n_sets
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|insn
operator|=
name|first
init|;
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|x
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|SET
operator|||
name|code
operator|==
name|CLOBBER
condition|)
name|update_n_sets
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|code
operator|=
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|SET
operator|||
name|code
operator|==
name|CLOBBER
condition|)
name|update_n_sets
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|insn
operator|==
name|last
condition|)
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* The one entry point in this file.  DUMP_FILE is the dump file for    this pass.  */
end_comment

begin_function
name|void
name|schedule_insns
parameter_list|(
name|dump_file
parameter_list|)
name|FILE
modifier|*
name|dump_file
decl_stmt|;
block|{
name|int
name|max_uid
init|=
name|MAX_INSNS_PER_SPLIT
operator|*
operator|(
name|get_max_uid
argument_list|()
operator|+
literal|1
operator|)
decl_stmt|;
name|int
name|b
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
comment|/* Taking care of this degenerate case makes the rest of      this code simpler.  */
if|if
condition|(
name|n_basic_blocks
operator|==
literal|0
condition|)
return|return;
comment|/* Create an insn here so that we can hang dependencies off of it later.  */
name|sched_before_next_call
operator|=
name|gen_rtx_INSN
argument_list|(
name|VOIDmode
argument_list|,
literal|0
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
comment|/* Initialize the unused_*_lists.  We can't use the ones left over from      the previous function, because gcc has freed that memory.  We can use      the ones left over from the first sched pass in the second pass however,      so only clear them on the first sched pass.  The first pass is before      reload if flag_schedule_insns is set, otherwise it is afterwards.  */
if|if
condition|(
name|reload_completed
operator|==
literal|0
operator|||
operator|!
name|flag_schedule_insns
condition|)
block|{
name|unused_insn_list
operator|=
literal|0
expr_stmt|;
name|unused_expr_list
operator|=
literal|0
expr_stmt|;
block|}
comment|/* We create no insns here, only reorder them, so we      remember how far we can cut back the stack on exit.  */
comment|/* Allocate data for this pass.  See comments, above,      for what these vectors do.       We use xmalloc instead of alloca, because max_uid can be very large      when there is a lot of function inlining.  If we used alloca, we could      exceed stack limits on some hosts for some inputs.  */
name|insn_luid
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|insn_priority
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|insn_tick
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|insn_costs
operator|=
operator|(
name|short
operator|*
operator|)
name|xmalloc
argument_list|(
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|insn_units
operator|=
operator|(
name|short
operator|*
operator|)
name|xmalloc
argument_list|(
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|insn_blockage
operator|=
operator|(
name|unsigned
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|max_uid
operator|*
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
argument_list|)
expr_stmt|;
name|insn_ref_count
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reload_completed
operator|==
literal|0
condition|)
block|{
name|sched_reg_n_calls_crossed
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|sched_reg_live_length
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bb_dead_regs
operator|=
name|ALLOCA_REG_SET
argument_list|()
expr_stmt|;
name|bb_live_regs
operator|=
name|ALLOCA_REG_SET
argument_list|()
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sched_reg_n_calls_crossed
argument_list|,
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sched_reg_live_length
argument_list|,
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sched_reg_n_calls_crossed
operator|=
literal|0
expr_stmt|;
name|sched_reg_live_length
operator|=
literal|0
expr_stmt|;
name|bb_dead_regs
operator|=
literal|0
expr_stmt|;
name|bb_live_regs
operator|=
literal|0
expr_stmt|;
block|}
name|init_alias_analysis
argument_list|()
expr_stmt|;
if|if
condition|(
name|write_symbols
operator|!=
name|NO_DEBUG
condition|)
block|{
name|rtx
name|line
decl_stmt|;
name|line_note
operator|=
operator|(
name|rtx
operator|*
operator|)
name|xmalloc
argument_list|(
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|line_note
argument_list|,
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|line_note_head
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|line_note_head
argument_list|,
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Determine the line-number at the start of each basic block. 	 This must be computed and saved now, because after a basic block's 	 predecessor has been scheduled, it is impossible to accurately 	 determine the correct line number for the first insn of the block.  */
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|n_basic_blocks
condition|;
name|b
operator|++
control|)
for|for
control|(
name|line
operator|=
name|BLOCK_HEAD
argument_list|(
name|b
argument_list|)
init|;
name|line
condition|;
name|line
operator|=
name|PREV_INSN
argument_list|(
name|line
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|line
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|line
argument_list|)
operator|>
literal|0
condition|)
block|{
name|line_note_head
index|[
name|b
index|]
operator|=
name|line
expr_stmt|;
break|break;
block|}
block|}
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|insn_luid
argument_list|,
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|insn_priority
argument_list|,
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|insn_tick
argument_list|,
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|insn_costs
argument_list|,
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|insn_units
argument_list|,
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|insn_blockage
argument_list|,
name|max_uid
operator|*
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|insn_ref_count
argument_list|,
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Schedule each basic block, block by block.  */
comment|/* ??? Add a NOTE after the last insn of the last basic block.  It is not      known why this is done.  */
comment|/* ??? Perhaps it's done to ensure NEXT_TAIL in schedule_block is a      valid insn.  */
name|insn
operator|=
name|BLOCK_END
argument_list|(
name|n_basic_blocks
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|==
literal|0
operator|||
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|CODE_LABEL
comment|/* Don't emit a NOTE if it would end up between an unconditional 	     jump and a BARRIER.  */
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|BARRIER
operator|)
operator|)
condition|)
name|emit_note_after
argument_list|(
name|NOTE_INSN_DELETED
argument_list|,
name|BLOCK_END
argument_list|(
name|n_basic_blocks
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|n_basic_blocks
condition|;
name|b
operator|++
control|)
block|{
name|note_list
operator|=
literal|0
expr_stmt|;
name|split_block_insns
argument_list|(
name|b
argument_list|,
name|reload_completed
operator|==
literal|0
operator|||
operator|!
name|flag_schedule_insns
argument_list|)
expr_stmt|;
name|schedule_block
argument_list|(
name|b
argument_list|,
name|dump_file
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_C_ALLOCA
name|alloca
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Reposition the prologue and epilogue notes in case we moved the      prologue/epilogue insns.  */
if|if
condition|(
name|reload_completed
condition|)
name|reposition_prologue_and_epilogue_notes
argument_list|(
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_symbols
operator|!=
name|NO_DEBUG
condition|)
block|{
name|rtx
name|line
init|=
literal|0
decl_stmt|;
name|rtx
name|insn
init|=
name|get_insns
argument_list|()
decl_stmt|;
name|int
name|active_insn
init|=
literal|0
decl_stmt|;
name|int
name|notes
init|=
literal|0
decl_stmt|;
comment|/* Walk the insns deleting redundant line-number notes.  Many of these 	 are already present.  The remainder tend to occur at basic 	 block boundaries.  */
for|for
control|(
name|insn
operator|=
name|get_last_insn
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* If there are no active insns following, INSN is redundant.  */
if|if
condition|(
name|active_insn
operator|==
literal|0
condition|)
block|{
name|notes
operator|++
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
block|}
comment|/* If the line number is unchanged, LINE is redundant.  */
elseif|else
if|if
condition|(
name|line
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|line
argument_list|)
operator|==
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|&&
name|NOTE_SOURCE_FILE
argument_list|(
name|line
argument_list|)
operator|==
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|notes
operator|++
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|line
argument_list|)
operator|=
literal|0
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|line
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|line
operator|=
name|insn
expr_stmt|;
block|}
else|else
name|line
operator|=
name|insn
expr_stmt|;
name|active_insn
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_DELETED
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
operator|)
operator|)
operator|)
condition|)
name|active_insn
operator|++
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
name|notes
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|";; deleted %d line-number notes\n"
argument_list|,
name|notes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reload_completed
operator|==
literal|0
condition|)
block|{
name|int
name|regno
decl_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|max_regno
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|sched_reg_live_length
index|[
name|regno
index|]
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
block|{
if|if
condition|(
name|REG_LIVE_LENGTH
argument_list|(
name|regno
argument_list|)
operator|>
name|sched_reg_live_length
index|[
name|regno
index|]
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|";; register %d life shortened from %d to %d\n"
argument_list|,
name|regno
argument_list|,
name|REG_LIVE_LENGTH
argument_list|(
name|regno
argument_list|)
argument_list|,
name|sched_reg_live_length
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
comment|/* Negative values are special; don't overwrite the current 		   reg_live_length value if it is negative.  */
elseif|else
if|if
condition|(
name|REG_LIVE_LENGTH
argument_list|(
name|regno
argument_list|)
operator|<
name|sched_reg_live_length
index|[
name|regno
index|]
operator|&&
name|REG_LIVE_LENGTH
argument_list|(
name|regno
argument_list|)
operator|>=
literal|0
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|";; register %d life extended from %d to %d\n"
argument_list|,
name|regno
argument_list|,
name|REG_LIVE_LENGTH
argument_list|(
name|regno
argument_list|)
argument_list|,
name|sched_reg_live_length
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|REG_N_CALLS_CROSSED
argument_list|(
name|regno
argument_list|)
operator|&&
name|sched_reg_n_calls_crossed
index|[
name|regno
index|]
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|";; register %d now crosses calls\n"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_N_CALLS_CROSSED
argument_list|(
name|regno
argument_list|)
operator|&&
operator|!
name|sched_reg_n_calls_crossed
index|[
name|regno
index|]
operator|&&
name|REG_BASIC_BLOCK
argument_list|(
name|regno
argument_list|)
operator|!=
name|REG_BLOCK_GLOBAL
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|";; register %d no longer crosses calls\n"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
comment|/* Negative values are special; don't overwrite the current 	       reg_live_length value if it is negative.  */
if|if
condition|(
name|REG_LIVE_LENGTH
argument_list|(
name|regno
argument_list|)
operator|>=
literal|0
condition|)
name|REG_LIVE_LENGTH
argument_list|(
name|regno
argument_list|)
operator|=
name|sched_reg_live_length
index|[
name|regno
index|]
expr_stmt|;
comment|/* We can't change the value of reg_n_calls_crossed to zero for 	       pseudos which are live in more than one block.  	       This is because combine might have made an optimization which 	       invalidated basic_block_live_at_start and reg_n_calls_crossed, 	       but it does not update them.  If we update reg_n_calls_crossed 	       here, the two variables are now inconsistent, and this might 	       confuse the caller-save code into saving a register that doesn't 	       need to be saved.  This is only a problem when we zero calls 	       crossed for a pseudo live in multiple basic blocks.  	       Alternatively, we could try to correctly update basic block live 	       at start here in sched, but that seems complicated.  */
if|if
condition|(
name|sched_reg_n_calls_crossed
index|[
name|regno
index|]
operator|||
name|REG_BASIC_BLOCK
argument_list|(
name|regno
argument_list|)
operator|!=
name|REG_BLOCK_GLOBAL
condition|)
name|REG_N_CALLS_CROSSED
argument_list|(
name|regno
argument_list|)
operator|=
name|sched_reg_n_calls_crossed
index|[
name|regno
index|]
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|insn_luid
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|insn_priority
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|insn_tick
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|insn_costs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|insn_units
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|insn_blockage
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|insn_ref_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_symbols
operator|!=
name|NO_DEBUG
condition|)
name|free
argument_list|(
name|line_note
argument_list|)
expr_stmt|;
if|if
condition|(
name|reload_completed
operator|==
literal|0
condition|)
block|{
name|FREE_REG_SET
argument_list|(
name|bb_dead_regs
argument_list|)
expr_stmt|;
name|FREE_REG_SET
argument_list|(
name|bb_live_regs
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INSN_SCHEDULING */
end_comment

end_unit

