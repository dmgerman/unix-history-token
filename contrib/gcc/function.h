begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Structure for saving state for a nested function.    Copyright (C) 1989, 92-97, 1998 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NULL_TREE
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|tree
argument_list|)
end_if

begin_typedef
typedef|typedef
name|union
name|union_node
modifier|*
name|_function_tree
typedef|;
end_typedef

begin_define
define|#
directive|define
name|tree
value|_function_tree
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NULL_RTX
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|rtx
argument_list|)
end_if

begin_typedef
typedef|typedef
name|struct
name|rtx_def
modifier|*
name|_function_rtx
typedef|;
end_typedef

begin_define
define|#
directive|define
name|rtx
value|_function_rtx
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|var_refs_queue
block|{
name|rtx
name|modified
decl_stmt|;
name|enum
name|machine_mode
name|promoted_mode
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|struct
name|var_refs_queue
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Stack of pending (incomplete) sequences saved by `start_sequence'.    Each element describes one pending sequence.    The main insn-chain is saved in the last element of the chain,    unless the chain is empty.  */
end_comment

begin_struct
struct|struct
name|sequence_stack
block|{
comment|/* First and last insns in the chain of the saved sequence.  */
name|rtx
name|first
decl_stmt|,
name|last
decl_stmt|;
name|tree
name|sequence_rtl_expr
decl_stmt|;
name|struct
name|sequence_stack
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|extern
name|struct
name|sequence_stack
modifier|*
name|sequence_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stack of single obstacks.  */
end_comment

begin_struct
struct|struct
name|simple_obstack_stack
block|{
name|struct
name|obstack
modifier|*
name|obstack
decl_stmt|;
name|struct
name|simple_obstack_stack
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_escape
end_escape

begin_comment
comment|/* This structure can save all the important global and static variables    describing the status of the current function.  */
end_comment

begin_struct
struct|struct
name|function
block|{
name|struct
name|function
modifier|*
name|next
decl_stmt|;
comment|/* For function.c.  */
name|char
modifier|*
name|name
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|int
name|pops_args
decl_stmt|;
name|int
name|returns_struct
decl_stmt|;
name|int
name|returns_pcc_struct
decl_stmt|;
name|int
name|returns_pointer
decl_stmt|;
name|int
name|needs_context
decl_stmt|;
name|int
name|calls_setjmp
decl_stmt|;
name|int
name|calls_longjmp
decl_stmt|;
name|int
name|calls_alloca
decl_stmt|;
name|int
name|has_nonlocal_label
decl_stmt|;
name|int
name|has_nonlocal_goto
decl_stmt|;
name|int
name|contains_functions
decl_stmt|;
name|int
name|has_computed_jump
decl_stmt|;
name|int
name|is_thunk
decl_stmt|;
name|rtx
name|nonlocal_goto_handler_slots
decl_stmt|;
name|rtx
name|nonlocal_goto_handler_labels
decl_stmt|;
name|rtx
name|nonlocal_goto_stack_level
decl_stmt|;
name|tree
name|nonlocal_labels
decl_stmt|;
name|int
name|args_size
decl_stmt|;
name|int
name|pretend_args_size
decl_stmt|;
name|rtx
name|arg_offset_rtx
decl_stmt|;
name|int
name|varargs
decl_stmt|;
name|int
name|stdarg
decl_stmt|;
name|int
name|max_parm_reg
decl_stmt|;
name|rtx
modifier|*
name|parm_reg_stack_loc
decl_stmt|;
name|int
name|outgoing_args_size
decl_stmt|;
name|rtx
name|return_rtx
decl_stmt|;
name|rtx
name|cleanup_label
decl_stmt|;
name|rtx
name|return_label
decl_stmt|;
name|rtx
name|save_expr_regs
decl_stmt|;
name|rtx
name|stack_slot_list
decl_stmt|;
name|rtx
name|parm_birth_insn
decl_stmt|;
name|HOST_WIDE_INT
name|frame_offset
decl_stmt|;
name|rtx
name|tail_recursion_label
decl_stmt|;
name|rtx
name|tail_recursion_reentry
decl_stmt|;
name|rtx
name|internal_arg_pointer
decl_stmt|;
name|char
modifier|*
name|cannot_inline
decl_stmt|;
name|rtx
name|arg_pointer_save_area
decl_stmt|;
name|tree
name|rtl_expr_chain
decl_stmt|;
name|rtx
name|last_parm_insn
decl_stmt|;
name|tree
name|context_display
decl_stmt|;
name|tree
name|trampoline_list
decl_stmt|;
name|int
name|function_call_count
decl_stmt|;
name|struct
name|temp_slot
modifier|*
name|temp_slots
decl_stmt|;
name|int
name|temp_slot_level
decl_stmt|;
name|int
name|target_temp_slot_level
decl_stmt|;
name|int
name|var_temp_slot_level
decl_stmt|;
name|int
name|instrument_entry_exit
decl_stmt|;
comment|/* This slot is initialized as 0 and is added to      during the nested function.  */
name|struct
name|var_refs_queue
modifier|*
name|fixup_var_refs_queue
decl_stmt|;
name|CUMULATIVE_ARGS
name|args_info
decl_stmt|;
comment|/* For stmt.c  */
name|struct
name|nesting
modifier|*
name|block_stack
decl_stmt|;
name|struct
name|nesting
modifier|*
name|stack_block_stack
decl_stmt|;
name|struct
name|nesting
modifier|*
name|cond_stack
decl_stmt|;
name|struct
name|nesting
modifier|*
name|loop_stack
decl_stmt|;
name|struct
name|nesting
modifier|*
name|case_stack
decl_stmt|;
name|struct
name|nesting
modifier|*
name|nesting_stack
decl_stmt|;
name|int
name|nesting_depth
decl_stmt|;
name|int
name|block_start_count
decl_stmt|;
name|tree
name|last_expr_type
decl_stmt|;
name|rtx
name|last_expr_value
decl_stmt|;
name|int
name|expr_stmts_for_value
decl_stmt|;
name|char
modifier|*
name|emit_filename
decl_stmt|;
name|int
name|emit_lineno
decl_stmt|;
name|struct
name|goto_fixup
modifier|*
name|goto_fixup_chain
decl_stmt|;
comment|/* For exception handling information.  */
name|struct
name|eh_stack
name|ehstack
decl_stmt|;
name|struct
name|eh_stack
name|catchstack
decl_stmt|;
name|struct
name|eh_queue
name|ehqueue
decl_stmt|;
name|rtx
name|catch_clauses
decl_stmt|;
name|struct
name|label_node
modifier|*
name|false_label_stack
decl_stmt|;
name|struct
name|label_node
modifier|*
name|caught_return_label_stack
decl_stmt|;
name|tree
name|protect_list
decl_stmt|;
name|rtx
name|ehc
decl_stmt|;
name|rtx
name|eh_return_stub_label
decl_stmt|;
comment|/* For expr.c.  */
name|rtx
name|pending_chain
decl_stmt|;
name|int
name|pending_stack_adjust
decl_stmt|;
name|int
name|inhibit_defer_pop
decl_stmt|;
name|rtx
name|saveregs_value
decl_stmt|;
name|rtx
name|apply_args_value
decl_stmt|;
name|rtx
name|forced_labels
decl_stmt|;
name|int
name|check_memory_usage
decl_stmt|;
comment|/* For emit-rtl.c.  */
name|int
name|reg_rtx_no
decl_stmt|;
name|int
name|first_label_num
decl_stmt|;
name|rtx
name|first_insn
decl_stmt|;
name|rtx
name|last_insn
decl_stmt|;
name|tree
name|sequence_rtl_expr
decl_stmt|;
name|struct
name|sequence_stack
modifier|*
name|sequence_stack
decl_stmt|;
name|int
name|cur_insn_uid
decl_stmt|;
name|int
name|last_linenum
decl_stmt|;
name|char
modifier|*
name|last_filename
decl_stmt|;
name|char
modifier|*
name|regno_pointer_flag
decl_stmt|;
name|char
modifier|*
name|regno_pointer_align
decl_stmt|;
name|int
name|regno_pointer_flag_length
decl_stmt|;
name|rtx
modifier|*
name|regno_reg_rtx
decl_stmt|;
comment|/* For stor-layout.c.  */
name|tree
name|permanent_type_chain
decl_stmt|;
name|tree
name|temporary_type_chain
decl_stmt|;
name|tree
name|permanent_type_end
decl_stmt|;
name|tree
name|temporary_type_end
decl_stmt|;
name|tree
name|pending_sizes
decl_stmt|;
name|int
name|immediate_size_expand
decl_stmt|;
comment|/* For tree.c.  */
name|int
name|all_types_permanent
decl_stmt|;
name|struct
name|momentary_level
modifier|*
name|momentary_stack
decl_stmt|;
name|char
modifier|*
name|maybepermanent_firstobj
decl_stmt|;
name|char
modifier|*
name|temporary_firstobj
decl_stmt|;
name|char
modifier|*
name|momentary_firstobj
decl_stmt|;
name|char
modifier|*
name|momentary_function_firstobj
decl_stmt|;
name|struct
name|obstack
modifier|*
name|current_obstack
decl_stmt|;
name|struct
name|obstack
modifier|*
name|function_obstack
decl_stmt|;
name|struct
name|obstack
modifier|*
name|function_maybepermanent_obstack
decl_stmt|;
name|struct
name|obstack
modifier|*
name|expression_obstack
decl_stmt|;
name|struct
name|obstack
modifier|*
name|saveable_obstack
decl_stmt|;
name|struct
name|obstack
modifier|*
name|rtl_obstack
decl_stmt|;
name|struct
name|simple_obstack_stack
modifier|*
name|inline_obstacks
decl_stmt|;
comment|/* For integrate.c.  */
name|int
name|uses_const_pool
decl_stmt|;
comment|/* For md files.  */
name|int
name|uses_pic_offset_table
decl_stmt|;
comment|/* tm.h can use this to store whatever it likes.  */
name|struct
name|machine_function
modifier|*
name|machine
decl_stmt|;
comment|/* For reorg.  */
name|rtx
name|epilogue_delay_list
decl_stmt|;
comment|/* For varasm.  */
name|struct
name|constant_descriptor
modifier|*
modifier|*
name|const_rtx_hash_table
decl_stmt|;
name|struct
name|pool_sym
modifier|*
modifier|*
name|const_rtx_sym_hash_table
decl_stmt|;
name|struct
name|pool_constant
modifier|*
name|first_pool
decl_stmt|,
modifier|*
name|last_pool
decl_stmt|;
name|int
name|pool_offset
decl_stmt|;
name|rtx
name|const_double_chain
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The FUNCTION_DECL for an inline function currently being expanded.  */
end_comment

begin_decl_stmt
specifier|extern
name|tree
name|inline_function_decl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Label that will go on parm cleanup code, if any.    Jumping to this label runs cleanup code for parameters, if    such code must be run.  Following this code is the logical return label.  */
end_comment

begin_decl_stmt
specifier|extern
name|rtx
name|cleanup_label
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Label that will go on function epilogue.    Jumping to this label serves as a "return" instruction    on machines which require execution of the epilogue on all returns.  */
end_comment

begin_decl_stmt
specifier|extern
name|rtx
name|return_label
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Offset to end of allocated area of stack frame.    If stack grows down, this is the address of the last stack slot allocated.    If stack grows up, this is the address for the next slot.  */
end_comment

begin_decl_stmt
specifier|extern
name|HOST_WIDE_INT
name|frame_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Label to jump back to for tail recursion, or 0 if we have    not yet needed one for this function.  */
end_comment

begin_decl_stmt
specifier|extern
name|rtx
name|tail_recursion_label
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Place after which to insert the tail_recursion_label if we need one.  */
end_comment

begin_decl_stmt
specifier|extern
name|rtx
name|tail_recursion_reentry
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Location at which to save the argument pointer if it will need to be    referenced.  There are two cases where this is done: if nonlocal gotos    exist, or if vars whose is an offset from the argument pointer will be    needed by inner routines.  */
end_comment

begin_decl_stmt
specifier|extern
name|rtx
name|arg_pointer_save_area
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain of all RTL_EXPRs that have insns in them.  */
end_comment

begin_decl_stmt
specifier|extern
name|tree
name|rtl_expr_chain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List (chain of EXPR_LISTs) of all stack slots in this function.    Made for the sake of unshare_all_rtl.  */
end_comment

begin_decl_stmt
specifier|extern
name|rtx
name|stack_slot_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Given a function decl for a containing function,    return the `struct function' for it.  */
end_comment

begin_decl_stmt
name|struct
name|function
modifier|*
name|find_function_data
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to chain of `struct function' for containing functions.  */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|function
modifier|*
name|outer_function_chain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Put all this function's BLOCK nodes into a vector and return it.    Also store in each NOTE for the beginning or end of a block    the index of that block in the vector.  */
end_comment

begin_decl_stmt
specifier|extern
name|tree
modifier|*
name|identify_blocks
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return size needed for stack frame based on slots so far allocated.    This size counts from zero.  It is not rounded to STACK_BOUNDARY;    the caller may have to do that.  */
end_comment

begin_decl_stmt
specifier|extern
name|HOST_WIDE_INT
name|get_frame_size
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These variables hold pointers to functions to    save and restore machine-specific data,    in push_function_context and pop_function_context.  */
end_comment

begin_extern
extern|extern void (*save_machine_status
end_extern

begin_expr_stmt
unit|)
name|PROTO
argument_list|(
operator|(
expr|struct
name|function
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_extern
extern|extern void (*restore_machine_status
end_extern

begin_expr_stmt
unit|)
name|PROTO
argument_list|(
operator|(
expr|struct
name|function
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Save and restore status information for a nested function.  */
end_comment

begin_decl_stmt
specifier|extern
name|void
name|save_tree_status
name|PROTO
argument_list|(
operator|(
expr|struct
name|function
operator|*
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|restore_tree_status
name|PROTO
argument_list|(
operator|(
expr|struct
name|function
operator|*
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|save_varasm_status
name|PROTO
argument_list|(
operator|(
expr|struct
name|function
operator|*
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|restore_varasm_status
name|PROTO
argument_list|(
operator|(
expr|struct
name|function
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|save_eh_status
name|PROTO
argument_list|(
operator|(
expr|struct
name|function
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|restore_eh_status
name|PROTO
argument_list|(
operator|(
expr|struct
name|function
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|save_stmt_status
name|PROTO
argument_list|(
operator|(
expr|struct
name|function
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|restore_stmt_status
name|PROTO
argument_list|(
operator|(
expr|struct
name|function
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|save_expr_status
name|PROTO
argument_list|(
operator|(
expr|struct
name|function
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|restore_expr_status
name|PROTO
argument_list|(
operator|(
expr|struct
name|function
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|save_emit_status
name|PROTO
argument_list|(
operator|(
expr|struct
name|function
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|restore_emit_status
name|PROTO
argument_list|(
operator|(
expr|struct
name|function
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|save_storage_status
name|PROTO
argument_list|(
operator|(
expr|struct
name|function
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|restore_storage_status
name|PROTO
argument_list|(
operator|(
expr|struct
name|function
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|rtx
name|get_first_block_beg
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|rtx
end_ifdef

begin_undef
undef|#
directive|undef
name|rtx
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|tree
end_ifdef

begin_undef
undef|#
directive|undef
name|tree
end_undef

begin_endif
endif|#
directive|endif
end_endif

end_unit

