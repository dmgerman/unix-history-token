begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Value Numbering routines for tree expressions.    Copyright (C) 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.    Contributed by Daniel Berlin<dan@dberlin.org>, Steven Bosscher<stevenb@suse.de> and Diego Novillo<dnovillo@redhat.com>  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"tree-dump.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_comment
comment|/* The value table that maps expressions to values.  */
end_comment

begin_decl_stmt
specifier|static
name|htab_t
name|value_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Map expressions to values.  These are simple pairs of expressions    and the values they represent.  To find the value represented by    an expression, we use a hash table where the elements are {e,v}    pairs, and the expression is the key.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|val_expr_pair_d
block|{
comment|/* Value handle.  */
name|tree
name|v
decl_stmt|;
comment|/* Associated expression.  */
name|tree
name|e
decl_stmt|;
comment|/* For comparing virtual uses in E.  */
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
name|vuses
expr_stmt|;
comment|/* E's hash value.  */
name|hashval_t
name|hashcode
decl_stmt|;
block|}
typedef|*
name|val_expr_pair_t
typedef|;
end_typedef

begin_function_decl
specifier|static
name|void
name|set_value_handle
parameter_list|(
name|tree
name|e
parameter_list|,
name|tree
name|v
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Create and return a new value handle node of type TYPE.  */
end_comment

begin_function
specifier|static
name|tree
name|make_value_handle
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
specifier|static
name|unsigned
name|int
name|id
init|=
literal|0
decl_stmt|;
name|tree
name|vh
decl_stmt|;
name|vh
operator|=
name|build0
argument_list|(
name|VALUE_HANDLE
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|VALUE_HANDLE_ID
argument_list|(
name|vh
argument_list|)
operator|=
name|id
operator|++
expr_stmt|;
return|return
name|vh
return|;
block|}
end_function

begin_comment
comment|/* Given an expression EXPR, compute a hash value number using the    code of the expression, its real operands and virtual operands (if    any).        VAL can be used to iterate by passing previous value numbers (it is    used by iterative_hash_expr).  */
end_comment

begin_function
name|hashval_t
name|vn_compute
parameter_list|(
name|tree
name|expr
parameter_list|,
name|hashval_t
name|val
parameter_list|)
block|{
comment|/* EXPR must not be a statement.  We are only interested in value      numbering expressions on the RHS of assignments.  */
name|gcc_assert
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|expr
operator|->
name|common
operator|.
name|ann
operator|||
name|expr
operator|->
name|common
operator|.
name|ann
operator|->
name|common
operator|.
name|type
operator|!=
name|STMT_ANN
argument_list|)
expr_stmt|;
name|val
operator|=
name|iterative_hash_expr
argument_list|(
name|expr
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Compare two expressions E1 and E2 and return true if they are    equal.  */
end_comment

begin_function
name|bool
name|expressions_equal_p
parameter_list|(
name|tree
name|e1
parameter_list|,
name|tree
name|e2
parameter_list|)
block|{
name|tree
name|te1
decl_stmt|,
name|te2
decl_stmt|;
if|if
condition|(
name|e1
operator|==
name|e2
condition|)
return|return
name|true
return|;
name|te1
operator|=
name|TREE_TYPE
argument_list|(
name|e1
argument_list|)
expr_stmt|;
name|te2
operator|=
name|TREE_TYPE
argument_list|(
name|e2
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|e1
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TREE_CODE
argument_list|(
name|e2
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|tree
name|lop1
init|=
name|e1
decl_stmt|;
name|tree
name|lop2
init|=
name|e2
decl_stmt|;
for|for
control|(
name|lop1
operator|=
name|e1
operator|,
name|lop2
operator|=
name|e2
init|;
name|lop1
operator|||
name|lop2
condition|;
name|lop1
operator|=
name|TREE_CHAIN
argument_list|(
name|lop1
argument_list|)
operator|,
name|lop2
operator|=
name|TREE_CHAIN
argument_list|(
name|lop2
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|lop1
operator|||
operator|!
name|lop2
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|expressions_equal_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|lop1
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|lop2
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|e1
argument_list|)
operator|==
name|TREE_CODE
argument_list|(
name|e2
argument_list|)
operator|&&
operator|(
name|te1
operator|==
name|te2
operator|||
name|lang_hooks
operator|.
name|types_compatible_p
argument_list|(
name|te1
argument_list|,
name|te2
argument_list|)
operator|)
operator|&&
name|operand_equal_p
argument_list|(
name|e1
argument_list|,
name|e2
argument_list|,
name|OEP_PURE_SAME
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Hash a {v,e} pair that is pointed to by P.    The hashcode is cached in the val_expr_pair, so we just return    that.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|val_expr_pair_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
specifier|const
name|val_expr_pair_t
name|ve
init|=
operator|(
name|val_expr_pair_t
operator|)
name|p
decl_stmt|;
return|return
name|ve
operator|->
name|hashcode
return|;
block|}
end_function

begin_comment
comment|/* Given two val_expr_pair_t's, return true if they represent the same    expression, false otherwise.    P1 and P2 should point to the val_expr_pair_t's to be compared.  */
end_comment

begin_function
specifier|static
name|int
name|val_expr_pair_expr_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|p1
parameter_list|,
specifier|const
name|void
modifier|*
name|p2
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|tree
name|vuse1
decl_stmt|;
specifier|const
name|val_expr_pair_t
name|ve1
init|=
operator|(
name|val_expr_pair_t
operator|)
name|p1
decl_stmt|;
specifier|const
name|val_expr_pair_t
name|ve2
init|=
operator|(
name|val_expr_pair_t
operator|)
name|p2
decl_stmt|;
if|if
condition|(
operator|!
name|expressions_equal_p
argument_list|(
name|ve1
operator|->
name|e
argument_list|,
name|ve2
operator|->
name|e
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|ve1
operator|->
name|vuses
operator|==
name|ve2
operator|->
name|vuses
condition|)
return|return
name|true
return|;
if|if
condition|(
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|ve1
operator|->
name|vuses
argument_list|)
operator|!=
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|ve2
operator|->
name|vuses
argument_list|)
condition|)
return|return
name|false
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
name|ve1
operator|->
name|vuses
argument_list|,
name|i
argument_list|,
name|vuse1
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|ve2
operator|->
name|vuses
argument_list|,
name|i
argument_list|)
operator|!=
name|vuse1
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Set the value handle for expression E to value V.  */
end_comment

begin_function
specifier|static
name|void
name|set_value_handle
parameter_list|(
name|tree
name|e
parameter_list|,
name|tree
name|v
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|e
argument_list|)
operator|==
name|SSA_NAME
condition|)
name|SSA_NAME_VALUE
argument_list|(
name|e
argument_list|)
operator|=
name|v
expr_stmt|;
elseif|else
if|if
condition|(
name|EXPR_P
argument_list|(
name|e
argument_list|)
operator|||
name|DECL_P
argument_list|(
name|e
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|e
argument_list|)
operator|==
name|TREE_LIST
operator|||
name|TREE_CODE
argument_list|(
name|e
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
name|get_tree_common_ann
argument_list|(
name|e
argument_list|)
operator|->
name|value_handle
operator|=
name|v
expr_stmt|;
else|else
comment|/* Do nothing.  Constants are their own value handles.  */
name|gcc_assert
argument_list|(
name|is_gimple_min_invariant
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy the virtual uses from STMT into a newly allocated VEC(tree),    and return the VEC(tree).  */
end_comment

begin_expr_stmt
specifier|static
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
name|copy_vuses_from_stmt
argument_list|(
argument|tree stmt
argument_list|)
block|{
name|ssa_op_iter
name|iter
block|;
name|tree
name|vuse
block|;
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
name|vuses
operator|=
name|NULL
block|;
if|if
condition|(
operator|!
name|stmt
condition|)
return|return
name|NULL
return|;
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|vuse
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_VUSE
argument_list|)
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|,
name|vuses
argument_list|,
name|vuse
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|vuses
return|;
end_return

begin_comment
unit|}
comment|/* Place for shared_vuses_from_stmt to shove vuses.  */
end_comment

begin_expr_stmt
unit|static
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
name|shared_lookup_vuses
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Copy the virtual uses from STMT into SHARED_LOOKUP_VUSES.    This function will overwrite the current SHARED_LOOKUP_VUSES    variable.  */
end_comment

begin_expr_stmt
specifier|static
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
name|shared_vuses_from_stmt
argument_list|(
argument|tree stmt
argument_list|)
block|{
name|ssa_op_iter
name|iter
block|;
name|tree
name|vuse
block|;
if|if
condition|(
operator|!
name|stmt
condition|)
return|return
name|NULL
return|;
name|VEC_truncate
argument_list|(
name|tree
argument_list|,
name|shared_lookup_vuses
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|vuse
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_VUSE
argument_list|)
end_macro

begin_expr_stmt
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|,
name|shared_lookup_vuses
argument_list|,
name|vuse
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|shared_lookup_vuses
argument_list|)
operator|>
literal|1
condition|)
name|sort_vuses
argument_list|(
name|shared_lookup_vuses
argument_list|)
expr_stmt|;
end_if

begin_return
return|return
name|shared_lookup_vuses
return|;
end_return

begin_comment
unit|}
comment|/* Insert EXPR into VALUE_TABLE with value VAL, and add expression    EXPR to the value set for value VAL.  */
end_comment

begin_macro
unit|void
name|vn_add
argument_list|(
argument|tree expr
argument_list|,
argument|tree val
argument_list|)
end_macro

begin_block
block|{
name|vn_add_with_vuses
argument_list|(
name|expr
argument_list|,
name|val
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Insert EXPR into VALUE_TABLE with value VAL, and add expression    EXPR to the value set for value VAL.  VUSES represents the virtual    use operands associated with EXPR.  It is used when computing a    hash value for EXPR.  */
end_comment

begin_decl_stmt
name|void
name|vn_add_with_vuses
argument_list|(
name|tree
name|expr
argument_list|,
name|tree
name|val
argument_list|,
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
name|vuses
argument_list|)
block|{
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
name|val_expr_pair_t
name|new_pair
decl_stmt|;
name|new_pair
operator|=
name|XNEW
argument_list|(
expr|struct
name|val_expr_pair_d
argument_list|)
expr_stmt|;
name|new_pair
operator|->
name|e
operator|=
name|expr
expr_stmt|;
name|new_pair
operator|->
name|v
operator|=
name|val
expr_stmt|;
name|new_pair
operator|->
name|vuses
operator|=
name|vuses
expr_stmt|;
name|new_pair
operator|->
name|hashcode
operator|=
name|vn_compute
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|slot
operator|=
name|htab_find_slot_with_hash
argument_list|(
name|value_table
argument_list|,
name|new_pair
argument_list|,
name|new_pair
operator|->
name|hashcode
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|slot
condition|)
name|free
argument_list|(
operator|*
name|slot
argument_list|)
expr_stmt|;
operator|*
name|slot
operator|=
operator|(
name|void
operator|*
operator|)
name|new_pair
expr_stmt|;
name|set_value_handle
argument_list|(
name|expr
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|VALUE_HANDLE
condition|)
name|add_to_value
argument_list|(
name|val
argument_list|,
name|expr
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Search in VALUE_TABLE for an existing instance of expression EXPR,    and return its value, or NULL if none has been set.  STMT    represents the stmt associated with EXPR.  It is used when computing the     hash value for EXPR.  */
end_comment

begin_function
name|tree
name|vn_lookup
parameter_list|(
name|tree
name|expr
parameter_list|,
name|tree
name|stmt
parameter_list|)
block|{
return|return
name|vn_lookup_with_vuses
argument_list|(
name|expr
argument_list|,
name|shared_vuses_from_stmt
argument_list|(
name|stmt
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Search in VALUE_TABLE for an existing instance of expression EXPR,    and return its value, or NULL if none has been set.  VUSES is the    list of virtual use operands associated with EXPR.  It is used when    computing the hash value for EXPR.  */
end_comment

begin_decl_stmt
name|tree
name|vn_lookup_with_vuses
argument_list|(
name|tree
name|expr
argument_list|,
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
name|vuses
argument_list|)
block|{
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
name|struct
name|val_expr_pair_d
name|vep
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
decl_stmt|;
comment|/* Constants are their own value.  */
if|if
condition|(
name|is_gimple_min_invariant
argument_list|(
name|expr
argument_list|)
condition|)
return|return
name|expr
return|;
name|vep
operator|.
name|e
operator|=
name|expr
expr_stmt|;
name|vep
operator|.
name|vuses
operator|=
name|vuses
expr_stmt|;
name|vep
operator|.
name|hashcode
operator|=
name|vn_compute
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|slot
operator|=
name|htab_find_slot_with_hash
argument_list|(
name|value_table
argument_list|,
operator|&
name|vep
argument_list|,
name|vep
operator|.
name|hashcode
argument_list|,
name|NO_INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|slot
condition|)
return|return
name|NULL_TREE
return|;
else|else
return|return
operator|(
operator|(
name|val_expr_pair_t
operator|)
operator|*
name|slot
operator|)
operator|->
name|v
return|;
block|}
end_decl_stmt

begin_comment
comment|/* A comparison function for use in qsort to compare vuses.  Simply    subtracts version numbers.  */
end_comment

begin_function
specifier|static
name|int
name|vuses_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|pa
parameter_list|,
specifier|const
name|void
modifier|*
name|pb
parameter_list|)
block|{
specifier|const
name|tree
name|vusea
init|=
operator|*
operator|(
operator|(
specifier|const
name|tree
operator|*
operator|)
name|pa
operator|)
decl_stmt|;
specifier|const
name|tree
name|vuseb
init|=
operator|*
operator|(
operator|(
specifier|const
name|tree
operator|*
operator|)
name|pb
operator|)
decl_stmt|;
name|int
name|sn
init|=
name|SSA_NAME_VERSION
argument_list|(
name|vusea
argument_list|)
operator|-
name|SSA_NAME_VERSION
argument_list|(
name|vuseb
argument_list|)
decl_stmt|;
return|return
name|sn
return|;
block|}
end_function

begin_comment
comment|/* Print out the "Created value<x> for<Y>" statement to the    dump_file.    This is factored because both versions of lookup use it, and it    obscures the real work going on in those functions.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|print_creation_to_file
argument_list|(
name|tree
name|v
argument_list|,
name|tree
name|expr
argument_list|,
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
name|vuses
argument_list|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Created value "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|v
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" for "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|expr
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|vuses
operator|&&
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|vuses
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|size_t
name|i
decl_stmt|;
name|tree
name|vuse
decl_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" vuses: ("
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
name|vuses
argument_list|,
name|i
argument_list|,
name|vuse
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|vuse
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|vuses
argument_list|)
operator|-
literal|1
operator|!=
name|i
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|","
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Like vn_lookup, but creates a new value for expression EXPR, if    EXPR doesn't already have a value.  Return the existing/created    value for EXPR.  STMT represents the stmt associated with EXPR.  It    is used when computing the VUSES for EXPR.  */
end_comment

begin_function
name|tree
name|vn_lookup_or_add
parameter_list|(
name|tree
name|expr
parameter_list|,
name|tree
name|stmt
parameter_list|)
block|{
name|tree
name|v
init|=
name|vn_lookup
argument_list|(
name|expr
argument_list|,
name|stmt
argument_list|)
decl_stmt|;
if|if
condition|(
name|v
operator|==
name|NULL_TREE
condition|)
block|{
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
name|vuses
expr_stmt|;
name|v
operator|=
name|make_value_handle
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|vuses
operator|=
name|copy_vuses_from_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|sort_vuses
argument_list|(
name|vuses
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|print_creation_to_file
argument_list|(
name|v
argument_list|,
name|expr
argument_list|,
name|vuses
argument_list|)
expr_stmt|;
name|VALUE_HANDLE_VUSES
argument_list|(
name|v
argument_list|)
operator|=
name|vuses
expr_stmt|;
name|vn_add_with_vuses
argument_list|(
name|expr
argument_list|,
name|v
argument_list|,
name|vuses
argument_list|)
expr_stmt|;
block|}
name|set_value_handle
argument_list|(
name|expr
argument_list|,
name|v
argument_list|)
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_comment
comment|/* Sort the VUSE array so that we can do equality comparisons    quicker on two vuse vecs.  */
end_comment

begin_decl_stmt
name|void
name|sort_vuses
argument_list|(
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
name|vuses
argument_list|)
block|{
if|if
condition|(
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|vuses
argument_list|)
operator|>
literal|1
condition|)
name|qsort
argument_list|(
name|VEC_address
argument_list|(
name|tree
argument_list|,
name|vuses
argument_list|)
argument_list|,
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|vuses
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|,
name|vuses_compare
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Like vn_lookup, but creates a new value for expression EXPR, if    EXPR doesn't already have a value.  Return the existing/created    value for EXPR.  STMT represents the stmt associated with EXPR.  It is used    when computing the hash value for EXPR.  */
end_comment

begin_decl_stmt
name|tree
name|vn_lookup_or_add_with_vuses
argument_list|(
name|tree
name|expr
argument_list|,
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
name|vuses
argument_list|)
block|{
name|tree
name|v
init|=
name|vn_lookup_with_vuses
argument_list|(
name|expr
argument_list|,
name|vuses
argument_list|)
decl_stmt|;
if|if
condition|(
name|v
operator|==
name|NULL_TREE
condition|)
block|{
name|v
operator|=
name|make_value_handle
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|sort_vuses
argument_list|(
name|vuses
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|print_creation_to_file
argument_list|(
name|v
argument_list|,
name|expr
argument_list|,
name|vuses
argument_list|)
expr_stmt|;
name|VALUE_HANDLE_VUSES
argument_list|(
name|v
argument_list|)
operator|=
name|vuses
expr_stmt|;
name|vn_add_with_vuses
argument_list|(
name|expr
argument_list|,
name|v
argument_list|,
name|vuses
argument_list|)
expr_stmt|;
block|}
name|set_value_handle
argument_list|(
name|expr
argument_list|,
name|v
argument_list|)
expr_stmt|;
return|return
name|v
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Get the value handle of EXPR.  This is the only correct way to get    the value handle for a "thing".  If EXPR does not have a value    handle associated, it returns NULL_TREE.      NB: If EXPR is min_invariant, this function is *required* to return EXPR.  */
end_comment

begin_function
name|tree
name|get_value_handle
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
if|if
condition|(
name|is_gimple_min_invariant
argument_list|(
name|expr
argument_list|)
condition|)
return|return
name|expr
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|SSA_NAME
condition|)
return|return
name|SSA_NAME_VALUE
argument_list|(
name|expr
argument_list|)
return|;
elseif|else
if|if
condition|(
name|EXPR_P
argument_list|(
name|expr
argument_list|)
operator|||
name|DECL_P
argument_list|(
name|expr
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|TREE_LIST
operator|||
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
block|{
name|tree_ann_common_t
name|ann
init|=
name|tree_common_ann
argument_list|(
name|expr
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|ann
operator|)
condition|?
name|ann
operator|->
name|value_handle
else|:
name|NULL_TREE
operator|)
return|;
block|}
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize data structures used in value numbering.  */
end_comment

begin_function
name|void
name|vn_init
parameter_list|(
name|void
parameter_list|)
block|{
name|value_table
operator|=
name|htab_create
argument_list|(
literal|511
argument_list|,
name|val_expr_pair_hash
argument_list|,
name|val_expr_pair_expr_eq
argument_list|,
name|free
argument_list|)
expr_stmt|;
name|shared_lookup_vuses
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Delete data used for value numbering.  */
end_comment

begin_function
name|void
name|vn_delete
parameter_list|(
name|void
parameter_list|)
block|{
name|htab_delete
argument_list|(
name|value_table
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|,
name|shared_lookup_vuses
argument_list|)
expr_stmt|;
name|value_table
operator|=
name|NULL
expr_stmt|;
block|}
end_function

end_unit

