begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Basic block reordering routines for the GNU compiler.    Copyright (C) 2000, 2002 Free Software Foundation, Inc.     This file is part of GCC.     GCC is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GCC is distributed in the hope that it will be useful, but WITHOUT    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public    License for more details.     You should have received a copy of the GNU General Public License    along with GCC; see the file COPYING.  If not, write to the Free    Software Foundation, 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_comment
comment|/* References:     "Profile Guided Code Positioning"    Pettis and Hanson; PLDI '90.     TODO:     (1) Consider:  		if (p) goto A;		// predict taken 		foo (); 	      A: 		if (q) goto B;		// predict taken 		bar (); 	      B: 		baz (); 		return;         We'll currently reorder this as  		if (!p) goto C; 	      A: 		if (!q) goto D; 	      B: 		baz (); 		return; 	      D: 		bar (); 		goto B; 	      C: 		foo (); 		goto A;         A better ordering is  		if (!p) goto C; 		if (!q) goto D; 	      B: 		baz (); 		return; 	      C: 		foo (); 		if (q) goto B; 	      D: 		bar (); 		goto B;         This requires that we be able to duplicate the jump at A, and        adjust the graph traversal such that greedy placement doesn't        fix D before C is considered.     (2) Coordinate with shorten_branches to minimize the number of        long branches.     (3) Invent a method by which sufficiently non-predicted code can        be moved to either the end of the section or another section        entirely.  Some sort of NOTE_INSN note would work fine.         This completely scroggs all debugging formats, so the user        would have to explicitly ask for it. */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"cfglayout.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_comment
comment|/* Local function prototypes.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|make_reorder_chain
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|basic_block
name|make_reorder_chain_1
name|PARAMS
argument_list|(
operator|(
name|basic_block
operator|,
name|basic_block
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|basic_block
name|maybe_duplicate_computed_goto_succ
name|PARAMS
argument_list|(
operator|(
name|basic_block
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Compute an ordering for a subgraph beginning with block BB.  Record the    ordering in RBI()->index and chained through RBI()->next.  */
end_comment

begin_function
specifier|static
name|void
name|make_reorder_chain
parameter_list|()
block|{
name|basic_block
name|prev
init|=
name|NULL
decl_stmt|;
name|basic_block
name|next
decl_stmt|,
name|bb
decl_stmt|;
comment|/* Loop until we've placed every block.  */
do|do
block|{
name|next
operator|=
name|NULL
expr_stmt|;
comment|/* Find the next unplaced block.  */
comment|/* ??? Get rid of this loop, and track which blocks are not yet 	 placed more directly, so as to avoid the O(N^2) worst case. 	 Perhaps keep a doubly-linked list of all to-be-placed blocks; 	 remove from the list as we place.  The head of that list is 	 what we're looking for here.  */
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
if|if
condition|(
operator|!
name|RBI
argument_list|(
name|bb
argument_list|)
operator|->
name|visited
condition|)
block|{
name|next
operator|=
name|bb
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|next
condition|)
name|prev
operator|=
name|make_reorder_chain_1
argument_list|(
name|next
argument_list|,
name|prev
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|next
condition|)
do|;
name|RBI
argument_list|(
name|prev
argument_list|)
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If the successor is our artificial computed_jump block, duplicate it.  */
end_comment

begin_function
specifier|static
specifier|inline
name|basic_block
name|maybe_duplicate_computed_goto_succ
parameter_list|(
name|bb
parameter_list|)
name|basic_block
name|bb
decl_stmt|;
block|{
name|edge
name|e
decl_stmt|;
name|basic_block
name|next
decl_stmt|;
comment|/* Note that we can't rely on computed_goto_common_label still being in      the instruction stream -- cfgloop.c likes to munge things about.  But      we can still use it's non-null-ness to avoid a fruitless search.  */
if|if
condition|(
operator|!
name|cfun
operator|->
name|computed_goto_common_label
condition|)
return|return
name|NULL
return|;
comment|/* Only want to duplicate when coming from a simple branch.  */
name|e
operator|=
name|bb
operator|->
name|succ
expr_stmt|;
if|if
condition|(
operator|!
name|e
operator|||
name|e
operator|->
name|succ_next
condition|)
return|return
name|NULL
return|;
comment|/* Only duplicate if we've already layed out this block once.  */
name|next
operator|=
name|e
operator|->
name|dest
expr_stmt|;
if|if
condition|(
operator|!
name|RBI
argument_list|(
name|next
argument_list|)
operator|->
name|visited
condition|)
return|return
name|NULL
return|;
comment|/* See if the block contains only a computed branch.  */
if|if
condition|(
operator|(
name|next
operator|->
name|head
operator|==
name|next
operator|->
name|end
operator|||
name|next_active_insn
argument_list|(
name|next
operator|->
name|head
argument_list|)
operator|==
name|next
operator|->
name|end
operator|)
operator|&&
name|computed_jump_p
argument_list|(
name|next
operator|->
name|end
argument_list|)
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Duplicating block %d after %d\n"
argument_list|,
name|next
operator|->
name|index
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
return|return
name|cfg_layout_duplicate_bb
argument_list|(
name|next
argument_list|,
name|e
argument_list|)
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* A helper function for make_reorder_chain.     We do not follow EH edges, or non-fallthru edges to noreturn blocks.    These are assumed to be the error condition and we wish to cluster    all of them at the very end of the function for the benefit of cache    locality for the rest of the function.     ??? We could do slightly better by noticing earlier that some subgraph    has all paths leading to noreturn functions, but for there to be more    than one block in such a subgraph is rare.  */
end_comment

begin_function
specifier|static
name|basic_block
name|make_reorder_chain_1
parameter_list|(
name|bb
parameter_list|,
name|prev
parameter_list|)
name|basic_block
name|bb
decl_stmt|;
name|basic_block
name|prev
decl_stmt|;
block|{
name|edge
name|e
decl_stmt|;
name|basic_block
name|next
decl_stmt|;
name|rtx
name|note
decl_stmt|;
comment|/* Mark this block visited.  */
if|if
condition|(
name|prev
condition|)
block|{
name|restart
label|:
name|RBI
argument_list|(
name|prev
argument_list|)
operator|->
name|next
operator|=
name|bb
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
operator|&&
name|prev
operator|->
name|next_bb
operator|!=
name|bb
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Reordering block %d after %d\n"
argument_list|,
name|bb
operator|->
name|index
argument_list|,
name|prev
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|bb
operator|->
name|prev_bb
operator|!=
name|ENTRY_BLOCK_PTR
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
name|RBI
argument_list|(
name|bb
argument_list|)
operator|->
name|visited
operator|=
literal|1
expr_stmt|;
name|prev
operator|=
name|bb
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|succ
operator|==
name|NULL
condition|)
return|return
name|prev
return|;
comment|/* Find the most probable block.  */
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|any_condjump_p
argument_list|(
name|bb
operator|->
name|end
argument_list|)
operator|&&
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|bb
operator|->
name|end
argument_list|,
name|REG_BR_PROB
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|taken
decl_stmt|,
name|probability
decl_stmt|;
name|edge
name|e_taken
decl_stmt|,
name|e_fall
decl_stmt|;
name|probability
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|taken
operator|=
name|probability
operator|>
name|REG_BR_PROB_BASE
operator|/
literal|2
expr_stmt|;
comment|/* Find the normal taken edge and the normal fallthru edge.  	 Note, conditional jumps with other side effects may not 	 be fully optimized.  In this case it is possible for 	 the conditional jump to branch to the same location as 	 the fallthru path.  	 We should probably work to improve optimization of that 	 case; however, it seems silly not to also deal with such 	 problems here if they happen to occur.  */
name|e_taken
operator|=
name|e_fall
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
block|{
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
name|e_fall
operator|=
name|e
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_EH
operator|)
condition|)
name|e_taken
operator|=
name|e
expr_stmt|;
block|}
name|next
operator|=
operator|(
operator|(
name|taken
operator|&&
name|e_taken
operator|)
condition|?
name|e_taken
else|:
name|e_fall
operator|)
operator|->
name|dest
expr_stmt|;
block|}
comment|/* If the successor is our artificial computed_jump block, duplicate it.  */
else|else
name|next
operator|=
name|maybe_duplicate_computed_goto_succ
argument_list|(
name|bb
argument_list|)
expr_stmt|;
comment|/* In the absence of a prediction, disturb things as little as possible      by selecting the old "next" block from the list of successors.  If      there had been a fallthru edge, that will be the one.  */
comment|/* Note that the fallthru block may not be next any time we eliminate      forwarder blocks.  */
if|if
condition|(
operator|!
name|next
condition|)
block|{
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
block|{
name|next
operator|=
name|e
operator|->
name|dest
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|e
operator|->
name|dest
operator|==
name|bb
operator|->
name|next_bb
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
operator|(
name|EDGE_ABNORMAL_CALL
operator||
name|EDGE_EH
operator|)
operator|)
condition|)
name|next
operator|=
name|e
operator|->
name|dest
expr_stmt|;
block|}
block|}
comment|/* Make sure we didn't select a silly next block.  */
if|if
condition|(
operator|!
name|next
operator|||
name|next
operator|==
name|EXIT_BLOCK_PTR
operator|||
name|RBI
argument_list|(
name|next
argument_list|)
operator|->
name|visited
condition|)
name|next
operator|=
name|NULL
expr_stmt|;
comment|/* Recurse on the successors.  Unroll the last call, as the normal      case is exactly one or two edges, and we can tail recurse.  */
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
if|if
condition|(
name|e
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
operator|&&
operator|!
name|RBI
argument_list|(
name|e
operator|->
name|dest
argument_list|)
operator|->
name|visited
operator|&&
name|e
operator|->
name|dest
operator|->
name|succ
operator|&&
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
operator|(
name|EDGE_ABNORMAL_CALL
operator||
name|EDGE_EH
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|next
condition|)
block|{
name|prev
operator|=
name|make_reorder_chain_1
argument_list|(
name|next
argument_list|,
name|prev
argument_list|)
expr_stmt|;
name|next
operator|=
name|RBI
argument_list|(
name|e
operator|->
name|dest
argument_list|)
operator|->
name|visited
condition|?
name|NULL
else|:
name|e
operator|->
name|dest
expr_stmt|;
block|}
else|else
name|next
operator|=
name|e
operator|->
name|dest
expr_stmt|;
block|}
if|if
condition|(
name|next
condition|)
block|{
name|bb
operator|=
name|next
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
return|return
name|prev
return|;
block|}
end_function

begin_comment
comment|/* Reorder basic blocks.  The main entry point to this file.  */
end_comment

begin_function
name|void
name|reorder_basic_blocks
parameter_list|()
block|{
if|if
condition|(
name|n_basic_blocks
operator|<=
literal|1
condition|)
return|return;
if|if
condition|(
call|(
modifier|*
name|targetm
operator|.
name|cannot_modify_jumps_p
call|)
argument_list|()
condition|)
return|return;
name|cfg_layout_initialize
argument_list|()
expr_stmt|;
name|make_reorder_chain
argument_list|()
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|dump_flow_info
argument_list|(
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|cfg_layout_finalize
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

