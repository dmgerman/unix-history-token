begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Basic block reordering routines for the GNU compiler.    Copyright (C) 2000, 2002, 2003 Free Software Foundation, Inc.     This file is part of GCC.     GCC is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GCC is distributed in the hope that it will be useful, but WITHOUT    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public    License for more details.     You should have received a copy of the GNU General Public License    along with GCC; see the file COPYING.  If not, write to the Free    Software Foundation, 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_comment
comment|/* This (greedy) algorithm constructs traces in several rounds.    The construction starts from "seeds".  The seed for the first round    is the entry point of function.  When there are more than one seed    that one is selected first that has the lowest key in the heap    (see function bb_to_key).  Then the algorithm repeatedly adds the most    probable successor to the end of a trace.  Finally it connects the traces.     There are two parameters: Branch Threshold and Exec Threshold.    If the edge to a successor of the actual basic block is lower than    Branch Threshold or the frequency of the successor is lower than    Exec Threshold the successor will be the seed in one of the next rounds.    Each round has these parameters lower than the previous one.    The last round has to have these parameters set to zero    so that the remaining blocks are picked up.     The algorithm selects the most probable successor from all unvisited    successors and successors that have been added to this trace.    The other successors (that has not been "sent" to the next round) will be    other seeds for this round and the secondary traces will start in them.    If the successor has not been visited in this trace it is added to the trace    (however, there is some heuristic for simple branches).    If the successor has been visited in this trace the loop has been found.    If the loop has many iterations the loop is rotated so that the    source block of the most probable edge going out from the loop    is the last block of the trace.    If the loop has few iterations and there is no edge from the last block of    the loop going out from loop the loop header is duplicated.    Finally, the construction of the trace is terminated.     When connecting traces it first checks whether there is an edge from the    last block of one trace to the first block of another trace.    When there are still some unconnected traces it checks whether there exists    a basic block BB such that BB is a successor of the last bb of one trace    and BB is a predecessor of the first block of another trace. In this case,    BB is duplicated and the traces are connected through this duplicate.    The rest of traces are simply connected so there will be a jump to the    beginning of the rest of trace.      References:     "Software Trace Cache"    A. Ramirez, J. Larriba-Pey, C. Navarro, J. Torrellas and M. Valero; 1999    http://citeseer.nj.nec.com/15361.html  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"cfglayout.h"
end_include

begin_include
include|#
directive|include
file|"fibheap.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_comment
comment|/* The number of rounds.  */
end_comment

begin_define
define|#
directive|define
name|N_ROUNDS
value|4
end_define

begin_comment
comment|/* Branch thresholds in thousandths (per mille) of the REG_BR_PROB_BASE.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|branch_threshold
index|[
name|N_ROUNDS
index|]
init|=
block|{
literal|400
block|,
literal|200
block|,
literal|100
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Exec thresholds in thousandths (per mille) of the frequency of bb 0.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|exec_threshold
index|[
name|N_ROUNDS
index|]
init|=
block|{
literal|500
block|,
literal|200
block|,
literal|50
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If edge frequency is lower than DUPLICATION_THRESHOLD per mille of entry    block the edge destination is not duplicated while connecting traces.  */
end_comment

begin_define
define|#
directive|define
name|DUPLICATION_THRESHOLD
value|100
end_define

begin_comment
comment|/* Length of unconditional jump instruction.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|uncond_jump_length
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Structure to hold needed information for each basic block.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|bbro_basic_block_data_def
block|{
comment|/* Which trace is the bb start of (-1 means it is not a start of a trace).  */
name|int
name|start_of_trace
decl_stmt|;
comment|/* Which trace is the bb end of (-1 means it is not an end of a trace).  */
name|int
name|end_of_trace
decl_stmt|;
comment|/* Which heap is BB in (if any)?  */
name|fibheap_t
name|heap
decl_stmt|;
comment|/* Which heap node is BB in (if any)?  */
name|fibnode_t
name|node
decl_stmt|;
block|}
name|bbro_basic_block_data
typedef|;
end_typedef

begin_comment
comment|/* The current size of the following dynamic array.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|array_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The array which holds needed information for basic blocks.  */
end_comment

begin_decl_stmt
specifier|static
name|bbro_basic_block_data
modifier|*
name|bbd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* To avoid frequent reallocation the size of arrays is greater than needed,    the number of elements is (not less than) 1.25 * size_wanted.  */
end_comment

begin_define
define|#
directive|define
name|GET_ARRAY_SIZE
parameter_list|(
name|X
parameter_list|)
value|((((X) / 4) + 1) * 5)
end_define

begin_comment
comment|/* Free the memory and set the pointer to NULL.  */
end_comment

begin_define
define|#
directive|define
name|FREE
parameter_list|(
name|P
parameter_list|)
define|\
value|do { if (P) { free (P); P = 0; } else { abort (); } } while (0)
end_define

begin_comment
comment|/* Structure for holding information about a trace.  */
end_comment

begin_struct
struct|struct
name|trace
block|{
comment|/* First and last basic block of the trace.  */
name|basic_block
name|first
decl_stmt|,
name|last
decl_stmt|;
comment|/* The round of the STC creation which this trace was found in.  */
name|int
name|round
decl_stmt|;
comment|/* The length (i.e. the number of basic blocks) of the trace.  */
name|int
name|length
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Maximum frequency and count of one of the entry blocks.  */
end_comment

begin_decl_stmt
name|int
name|max_entry_frequency
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|gcov_type
name|max_entry_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Local function prototypes.  */
end_comment

begin_function_decl
specifier|static
name|void
name|find_traces
parameter_list|(
name|int
modifier|*
parameter_list|,
name|struct
name|trace
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|basic_block
name|rotate_loop
parameter_list|(
name|edge
parameter_list|,
name|struct
name|trace
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mark_bb_visited
parameter_list|(
name|basic_block
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|find_traces_1_round
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|gcov_type
parameter_list|,
name|struct
name|trace
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
parameter_list|,
name|fibheap_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|basic_block
name|copy_bb
parameter_list|(
name|basic_block
parameter_list|,
name|edge
parameter_list|,
name|basic_block
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|fibheapkey_t
name|bb_to_key
parameter_list|(
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|better_edge_p
parameter_list|(
name|basic_block
parameter_list|,
name|edge
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|connect_traces
parameter_list|(
name|int
parameter_list|,
name|struct
name|trace
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|copy_bb_p
parameter_list|(
name|basic_block
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_uncond_jump_length
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Find the traces for Software Trace Cache.  Chain each trace through    RBI()->next.  Store the number of traces to N_TRACES and description of    traces to TRACES.  */
end_comment

begin_function
specifier|static
name|void
name|find_traces
parameter_list|(
name|int
modifier|*
name|n_traces
parameter_list|,
name|struct
name|trace
modifier|*
name|traces
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|fibheap_t
name|heap
decl_stmt|;
comment|/* Insert entry points of function into heap.  */
name|heap
operator|=
name|fibheap_new
argument_list|()
expr_stmt|;
name|max_entry_frequency
operator|=
literal|0
expr_stmt|;
name|max_entry_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|e
operator|=
name|ENTRY_BLOCK_PTR
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
block|{
name|bbd
index|[
name|e
operator|->
name|dest
operator|->
name|index
index|]
operator|.
name|heap
operator|=
name|heap
expr_stmt|;
name|bbd
index|[
name|e
operator|->
name|dest
operator|->
name|index
index|]
operator|.
name|node
operator|=
name|fibheap_insert
argument_list|(
name|heap
argument_list|,
name|bb_to_key
argument_list|(
name|e
operator|->
name|dest
argument_list|)
argument_list|,
name|e
operator|->
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|dest
operator|->
name|frequency
operator|>
name|max_entry_frequency
condition|)
name|max_entry_frequency
operator|=
name|e
operator|->
name|dest
operator|->
name|frequency
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|dest
operator|->
name|count
operator|>
name|max_entry_count
condition|)
name|max_entry_count
operator|=
name|e
operator|->
name|dest
operator|->
name|count
expr_stmt|;
block|}
comment|/* Find the traces.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_ROUNDS
condition|;
name|i
operator|++
control|)
block|{
name|gcov_type
name|count_threshold
decl_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"STC - round %d\n"
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_entry_count
operator|<
name|INT_MAX
operator|/
literal|1000
condition|)
name|count_threshold
operator|=
name|max_entry_count
operator|*
name|exec_threshold
index|[
name|i
index|]
operator|/
literal|1000
expr_stmt|;
else|else
name|count_threshold
operator|=
name|max_entry_count
operator|/
literal|1000
operator|*
name|exec_threshold
index|[
name|i
index|]
expr_stmt|;
name|find_traces_1_round
argument_list|(
name|REG_BR_PROB_BASE
operator|*
name|branch_threshold
index|[
name|i
index|]
operator|/
literal|1000
argument_list|,
name|max_entry_frequency
operator|*
name|exec_threshold
index|[
name|i
index|]
operator|/
literal|1000
argument_list|,
name|count_threshold
argument_list|,
name|traces
argument_list|,
name|n_traces
argument_list|,
name|i
argument_list|,
operator|&
name|heap
argument_list|)
expr_stmt|;
block|}
name|fibheap_delete
argument_list|(
name|heap
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|*
name|n_traces
condition|;
name|i
operator|++
control|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Trace %d (round %d):  "
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|traces
index|[
name|i
index|]
operator|.
name|round
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|bb
operator|=
name|traces
index|[
name|i
index|]
operator|.
name|first
init|;
name|bb
operator|!=
name|traces
index|[
name|i
index|]
operator|.
name|last
condition|;
name|bb
operator|=
name|bb
operator|->
name|rbi
operator|->
name|next
control|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"%d [%d] "
argument_list|,
name|bb
operator|->
name|index
argument_list|,
name|bb
operator|->
name|frequency
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"%d [%d]\n"
argument_list|,
name|bb
operator|->
name|index
argument_list|,
name|bb
operator|->
name|frequency
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|rtl_dump_file
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Rotate loop whose back edge is BACK_EDGE in the tail of trace TRACE    (with sequential number TRACE_N).  */
end_comment

begin_function
specifier|static
name|basic_block
name|rotate_loop
parameter_list|(
name|edge
name|back_edge
parameter_list|,
name|struct
name|trace
modifier|*
name|trace
parameter_list|,
name|int
name|trace_n
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
comment|/* Information about the best end (end after rotation) of the loop.  */
name|basic_block
name|best_bb
init|=
name|NULL
decl_stmt|;
name|edge
name|best_edge
init|=
name|NULL
decl_stmt|;
name|int
name|best_freq
init|=
operator|-
literal|1
decl_stmt|;
name|gcov_type
name|best_count
init|=
operator|-
literal|1
decl_stmt|;
comment|/* The best edge is preferred when its destination is not visited yet      or is a start block of some trace.  */
name|bool
name|is_preferred
init|=
name|false
decl_stmt|;
comment|/* Find the most frequent edge that goes out from current trace.  */
name|bb
operator|=
name|back_edge
operator|->
name|dest
expr_stmt|;
do|do
block|{
name|edge
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
if|if
condition|(
name|e
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
operator|&&
name|e
operator|->
name|dest
operator|->
name|rbi
operator|->
name|visited
operator|!=
name|trace_n
operator|&&
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_CAN_FALLTHRU
operator|)
operator|&&
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_COMPLEX
operator|)
condition|)
block|{
if|if
condition|(
name|is_preferred
condition|)
block|{
comment|/* The best edge is preferred.  */
if|if
condition|(
operator|!
name|e
operator|->
name|dest
operator|->
name|rbi
operator|->
name|visited
operator|||
name|bbd
index|[
name|e
operator|->
name|dest
operator|->
name|index
index|]
operator|.
name|start_of_trace
operator|>=
literal|0
condition|)
block|{
comment|/* The current edge E is also preferred.  */
name|int
name|freq
init|=
name|EDGE_FREQUENCY
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
name|freq
operator|>
name|best_freq
operator|||
name|e
operator|->
name|count
operator|>
name|best_count
condition|)
block|{
name|best_freq
operator|=
name|freq
expr_stmt|;
name|best_count
operator|=
name|e
operator|->
name|count
expr_stmt|;
name|best_edge
operator|=
name|e
expr_stmt|;
name|best_bb
operator|=
name|bb
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|e
operator|->
name|dest
operator|->
name|rbi
operator|->
name|visited
operator|||
name|bbd
index|[
name|e
operator|->
name|dest
operator|->
name|index
index|]
operator|.
name|start_of_trace
operator|>=
literal|0
condition|)
block|{
comment|/* The current edge E is preferred.  */
name|is_preferred
operator|=
name|true
expr_stmt|;
name|best_freq
operator|=
name|EDGE_FREQUENCY
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|best_count
operator|=
name|e
operator|->
name|count
expr_stmt|;
name|best_edge
operator|=
name|e
expr_stmt|;
name|best_bb
operator|=
name|bb
expr_stmt|;
block|}
else|else
block|{
name|int
name|freq
init|=
name|EDGE_FREQUENCY
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|best_edge
operator|||
name|freq
operator|>
name|best_freq
operator|||
name|e
operator|->
name|count
operator|>
name|best_count
condition|)
block|{
name|best_freq
operator|=
name|freq
expr_stmt|;
name|best_count
operator|=
name|e
operator|->
name|count
expr_stmt|;
name|best_edge
operator|=
name|e
expr_stmt|;
name|best_bb
operator|=
name|bb
expr_stmt|;
block|}
block|}
block|}
block|}
name|bb
operator|=
name|bb
operator|->
name|rbi
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|bb
operator|!=
name|back_edge
operator|->
name|dest
condition|)
do|;
if|if
condition|(
name|best_bb
condition|)
block|{
comment|/* Rotate the loop so that the BEST_EDGE goes out from the last block of 	 the trace.  */
if|if
condition|(
name|back_edge
operator|->
name|dest
operator|==
name|trace
operator|->
name|first
condition|)
block|{
name|trace
operator|->
name|first
operator|=
name|best_bb
operator|->
name|rbi
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|basic_block
name|prev_bb
decl_stmt|;
for|for
control|(
name|prev_bb
operator|=
name|trace
operator|->
name|first
init|;
name|prev_bb
operator|->
name|rbi
operator|->
name|next
operator|!=
name|back_edge
operator|->
name|dest
condition|;
name|prev_bb
operator|=
name|prev_bb
operator|->
name|rbi
operator|->
name|next
control|)
empty_stmt|;
name|prev_bb
operator|->
name|rbi
operator|->
name|next
operator|=
name|best_bb
operator|->
name|rbi
operator|->
name|next
expr_stmt|;
comment|/* Try to get rid of uncond jump to cond jump.  */
if|if
condition|(
name|prev_bb
operator|->
name|succ
operator|&&
operator|!
name|prev_bb
operator|->
name|succ
operator|->
name|succ_next
condition|)
block|{
name|basic_block
name|header
init|=
name|prev_bb
operator|->
name|succ
operator|->
name|dest
decl_stmt|;
comment|/* Duplicate HEADER if it is a small block containing cond jump 		 in the end.  */
if|if
condition|(
name|any_condjump_p
argument_list|(
name|BB_END
argument_list|(
name|header
argument_list|)
argument_list|)
operator|&&
name|copy_bb_p
argument_list|(
name|header
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|copy_bb
argument_list|(
name|header
argument_list|,
name|prev_bb
operator|->
name|succ
argument_list|,
name|prev_bb
argument_list|,
name|trace_n
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
comment|/* We have not found suitable loop tail so do no rotation.  */
name|best_bb
operator|=
name|back_edge
operator|->
name|src
expr_stmt|;
block|}
name|best_bb
operator|->
name|rbi
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
return|return
name|best_bb
return|;
block|}
end_function

begin_comment
comment|/* This function marks BB that it was visited in trace number TRACE.  */
end_comment

begin_function
specifier|static
name|void
name|mark_bb_visited
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|int
name|trace
parameter_list|)
block|{
name|bb
operator|->
name|rbi
operator|->
name|visited
operator|=
name|trace
expr_stmt|;
if|if
condition|(
name|bbd
index|[
name|bb
operator|->
name|index
index|]
operator|.
name|heap
condition|)
block|{
name|fibheap_delete_node
argument_list|(
name|bbd
index|[
name|bb
operator|->
name|index
index|]
operator|.
name|heap
argument_list|,
name|bbd
index|[
name|bb
operator|->
name|index
index|]
operator|.
name|node
argument_list|)
expr_stmt|;
name|bbd
index|[
name|bb
operator|->
name|index
index|]
operator|.
name|heap
operator|=
name|NULL
expr_stmt|;
name|bbd
index|[
name|bb
operator|->
name|index
index|]
operator|.
name|node
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* One round of finding traces. Find traces for BRANCH_TH and EXEC_TH i.e. do    not include basic blocks their probability is lower than BRANCH_TH or their    frequency is lower than EXEC_TH into traces (or count is lower than    COUNT_TH).  It stores the new traces into TRACES and modifies the number of    traces *N_TRACES. Sets the round (which the trace belongs to) to ROUND. It    expects that starting basic blocks are in *HEAP and at the end it deletes    *HEAP and stores starting points for the next round into new *HEAP.  */
end_comment

begin_function
specifier|static
name|void
name|find_traces_1_round
parameter_list|(
name|int
name|branch_th
parameter_list|,
name|int
name|exec_th
parameter_list|,
name|gcov_type
name|count_th
parameter_list|,
name|struct
name|trace
modifier|*
name|traces
parameter_list|,
name|int
modifier|*
name|n_traces
parameter_list|,
name|int
name|round
parameter_list|,
name|fibheap_t
modifier|*
name|heap
parameter_list|)
block|{
comment|/* Heap for discarded basic blocks which are possible starting points for      the next round.  */
name|fibheap_t
name|new_heap
init|=
name|fibheap_new
argument_list|()
decl_stmt|;
while|while
condition|(
operator|!
name|fibheap_empty
argument_list|(
operator|*
name|heap
argument_list|)
condition|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|struct
name|trace
modifier|*
name|trace
decl_stmt|;
name|edge
name|best_edge
decl_stmt|,
name|e
decl_stmt|;
name|fibheapkey_t
name|key
decl_stmt|;
name|bb
operator|=
name|fibheap_extract_min
argument_list|(
operator|*
name|heap
argument_list|)
expr_stmt|;
name|bbd
index|[
name|bb
operator|->
name|index
index|]
operator|.
name|heap
operator|=
name|NULL
expr_stmt|;
name|bbd
index|[
name|bb
operator|->
name|index
index|]
operator|.
name|node
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Getting bb %d\n"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
comment|/* If the BB's frequency is too low send BB to the next round.  */
if|if
condition|(
name|round
operator|<
name|N_ROUNDS
operator|-
literal|1
operator|&&
operator|(
name|bb
operator|->
name|frequency
operator|<
name|exec_th
operator|||
name|bb
operator|->
name|count
operator|<
name|count_th
operator|||
name|probably_never_executed_bb_p
argument_list|(
name|bb
argument_list|)
operator|)
condition|)
block|{
name|int
name|key
init|=
name|bb_to_key
argument_list|(
name|bb
argument_list|)
decl_stmt|;
name|bbd
index|[
name|bb
operator|->
name|index
index|]
operator|.
name|heap
operator|=
name|new_heap
expr_stmt|;
name|bbd
index|[
name|bb
operator|->
name|index
index|]
operator|.
name|node
operator|=
name|fibheap_insert
argument_list|(
name|new_heap
argument_list|,
name|key
argument_list|,
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"  Possible start point of next round: %d (key: %d)\n"
argument_list|,
name|bb
operator|->
name|index
argument_list|,
name|key
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|trace
operator|=
name|traces
operator|+
operator|*
name|n_traces
expr_stmt|;
name|trace
operator|->
name|first
operator|=
name|bb
expr_stmt|;
name|trace
operator|->
name|round
operator|=
name|round
expr_stmt|;
name|trace
operator|->
name|length
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|n_traces
operator|)
operator|++
expr_stmt|;
do|do
block|{
name|int
name|prob
decl_stmt|,
name|freq
decl_stmt|;
comment|/* The probability and frequency of the best edge.  */
name|int
name|best_prob
init|=
name|INT_MIN
operator|/
literal|2
decl_stmt|;
name|int
name|best_freq
init|=
name|INT_MIN
operator|/
literal|2
decl_stmt|;
name|best_edge
operator|=
name|NULL
expr_stmt|;
name|mark_bb_visited
argument_list|(
name|bb
argument_list|,
operator|*
name|n_traces
argument_list|)
expr_stmt|;
name|trace
operator|->
name|length
operator|++
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Basic block %d was visited in trace %d\n"
argument_list|,
name|bb
operator|->
name|index
argument_list|,
operator|*
name|n_traces
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Select the successor that will be placed after BB.  */
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
block|{
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FAKE
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|e
operator|->
name|dest
operator|==
name|EXIT_BLOCK_PTR
condition|)
continue|continue;
if|if
condition|(
name|e
operator|->
name|dest
operator|->
name|rbi
operator|->
name|visited
operator|&&
name|e
operator|->
name|dest
operator|->
name|rbi
operator|->
name|visited
operator|!=
operator|*
name|n_traces
condition|)
continue|continue;
name|prob
operator|=
name|e
operator|->
name|probability
expr_stmt|;
name|freq
operator|=
name|EDGE_FREQUENCY
argument_list|(
name|e
argument_list|)
expr_stmt|;
comment|/* Edge that cannot be fallthru or improbable or infrequent 		 successor (ie. it is unsuitable successor).  */
if|if
condition|(
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_CAN_FALLTHRU
operator|)
operator|||
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_COMPLEX
operator|)
operator|||
name|prob
operator|<
name|branch_th
operator|||
name|freq
operator|<
name|exec_th
operator|||
name|e
operator|->
name|count
operator|<
name|count_th
condition|)
continue|continue;
if|if
condition|(
name|better_edge_p
argument_list|(
name|bb
argument_list|,
name|e
argument_list|,
name|prob
argument_list|,
name|freq
argument_list|,
name|best_prob
argument_list|,
name|best_freq
argument_list|)
condition|)
block|{
name|best_edge
operator|=
name|e
expr_stmt|;
name|best_prob
operator|=
name|prob
expr_stmt|;
name|best_freq
operator|=
name|freq
expr_stmt|;
block|}
block|}
comment|/* If the best destination has multiple predecessors, and can be 	     duplicated cheaper than a jump, don't allow it to be added 	     to a trace.  We'll duplicate it when connecting traces.  */
if|if
condition|(
name|best_edge
operator|&&
name|best_edge
operator|->
name|dest
operator|->
name|pred
operator|->
name|pred_next
operator|&&
name|copy_bb_p
argument_list|(
name|best_edge
operator|->
name|dest
argument_list|,
literal|0
argument_list|)
condition|)
name|best_edge
operator|=
name|NULL
expr_stmt|;
comment|/* Add all non-selected successors to the heaps.  */
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
block|{
if|if
condition|(
name|e
operator|==
name|best_edge
operator|||
name|e
operator|->
name|dest
operator|==
name|EXIT_BLOCK_PTR
operator|||
name|e
operator|->
name|dest
operator|->
name|rbi
operator|->
name|visited
condition|)
continue|continue;
name|key
operator|=
name|bb_to_key
argument_list|(
name|e
operator|->
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|bbd
index|[
name|e
operator|->
name|dest
operator|->
name|index
index|]
operator|.
name|heap
condition|)
block|{
comment|/* E->DEST is already in some heap.  */
if|if
condition|(
name|key
operator|!=
name|bbd
index|[
name|e
operator|->
name|dest
operator|->
name|index
index|]
operator|.
name|node
operator|->
name|key
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Changing key for bb %d from %ld to %ld.\n"
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|,
operator|(
name|long
operator|)
name|bbd
index|[
name|e
operator|->
name|dest
operator|->
name|index
index|]
operator|.
name|node
operator|->
name|key
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
name|fibheap_replace_key
argument_list|(
name|bbd
index|[
name|e
operator|->
name|dest
operator|->
name|index
index|]
operator|.
name|heap
argument_list|,
name|bbd
index|[
name|e
operator|->
name|dest
operator|->
name|index
index|]
operator|.
name|node
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|fibheap_t
name|which_heap
init|=
operator|*
name|heap
decl_stmt|;
name|prob
operator|=
name|e
operator|->
name|probability
expr_stmt|;
name|freq
operator|=
name|EDGE_FREQUENCY
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_CAN_FALLTHRU
operator|)
operator|||
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_COMPLEX
operator|)
operator|||
name|prob
operator|<
name|branch_th
operator|||
name|freq
operator|<
name|exec_th
operator|||
name|e
operator|->
name|count
operator|<
name|count_th
condition|)
block|{
if|if
condition|(
name|round
operator|<
name|N_ROUNDS
operator|-
literal|1
condition|)
name|which_heap
operator|=
name|new_heap
expr_stmt|;
block|}
name|bbd
index|[
name|e
operator|->
name|dest
operator|->
name|index
index|]
operator|.
name|heap
operator|=
name|which_heap
expr_stmt|;
name|bbd
index|[
name|e
operator|->
name|dest
operator|->
name|index
index|]
operator|.
name|node
operator|=
name|fibheap_insert
argument_list|(
name|which_heap
argument_list|,
name|key
argument_list|,
name|e
operator|->
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"  Possible start of %s round: %d (key: %ld)\n"
argument_list|,
operator|(
name|which_heap
operator|==
name|new_heap
operator|)
condition|?
literal|"next"
else|:
literal|"this"
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|,
operator|(
name|long
operator|)
name|key
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|best_edge
condition|)
comment|/* Suitable successor was found.  */
block|{
if|if
condition|(
name|best_edge
operator|->
name|dest
operator|->
name|rbi
operator|->
name|visited
operator|==
operator|*
name|n_traces
condition|)
block|{
comment|/* We do nothing with one basic block loops.  */
if|if
condition|(
name|best_edge
operator|->
name|dest
operator|!=
name|bb
condition|)
block|{
if|if
condition|(
name|EDGE_FREQUENCY
argument_list|(
name|best_edge
argument_list|)
operator|>
literal|4
operator|*
name|best_edge
operator|->
name|dest
operator|->
name|frequency
operator|/
literal|5
condition|)
block|{
comment|/* The loop has at least 4 iterations.  If the loop 			     header is not the first block of the function 			     we can rotate the loop.  */
if|if
condition|(
name|best_edge
operator|->
name|dest
operator|!=
name|ENTRY_BLOCK_PTR
operator|->
name|next_bb
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Rotating loop %d - %d\n"
argument_list|,
name|best_edge
operator|->
name|dest
operator|->
name|index
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
name|bb
operator|->
name|rbi
operator|->
name|next
operator|=
name|best_edge
operator|->
name|dest
expr_stmt|;
name|bb
operator|=
name|rotate_loop
argument_list|(
name|best_edge
argument_list|,
name|trace
argument_list|,
operator|*
name|n_traces
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* The loop has less than 4 iterations.  */
comment|/* Check whether there is another edge from BB.  */
name|edge
name|another_edge
decl_stmt|;
for|for
control|(
name|another_edge
operator|=
name|bb
operator|->
name|succ
init|;
name|another_edge
condition|;
name|another_edge
operator|=
name|another_edge
operator|->
name|succ_next
control|)
if|if
condition|(
name|another_edge
operator|!=
name|best_edge
condition|)
break|break;
if|if
condition|(
operator|!
name|another_edge
operator|&&
name|copy_bb_p
argument_list|(
name|best_edge
operator|->
name|dest
argument_list|,
operator|!
name|optimize_size
argument_list|)
condition|)
block|{
name|bb
operator|=
name|copy_bb
argument_list|(
name|best_edge
operator|->
name|dest
argument_list|,
name|best_edge
argument_list|,
name|bb
argument_list|,
operator|*
name|n_traces
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Terminate the trace.  */
break|break;
block|}
else|else
block|{
comment|/* Check for a situation  		    A 		   /| 		  B | 		   \| 		    C  		  where 		  EDGE_FREQUENCY (AB) + EDGE_FREQUENCY (BC)>= EDGE_FREQUENCY (AC). 		  (i.e. 2 * B->frequency>= EDGE_FREQUENCY (AC) ) 		  Best ordering is then A B C.  		  This situation is created for example by:  		  if (A) B; 		  C;  		  */
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
if|if
condition|(
name|e
operator|!=
name|best_edge
operator|&&
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_CAN_FALLTHRU
operator|)
operator|&&
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_COMPLEX
operator|)
operator|&&
operator|!
name|e
operator|->
name|dest
operator|->
name|rbi
operator|->
name|visited
operator|&&
operator|!
name|e
operator|->
name|dest
operator|->
name|pred
operator|->
name|pred_next
operator|&&
name|e
operator|->
name|dest
operator|->
name|succ
operator|&&
operator|(
name|e
operator|->
name|dest
operator|->
name|succ
operator|->
name|flags
operator|&
name|EDGE_CAN_FALLTHRU
operator|)
operator|&&
operator|!
operator|(
name|e
operator|->
name|dest
operator|->
name|succ
operator|->
name|flags
operator|&
name|EDGE_COMPLEX
operator|)
operator|&&
operator|!
name|e
operator|->
name|dest
operator|->
name|succ
operator|->
name|succ_next
operator|&&
name|e
operator|->
name|dest
operator|->
name|succ
operator|->
name|dest
operator|==
name|best_edge
operator|->
name|dest
operator|&&
literal|2
operator|*
name|e
operator|->
name|dest
operator|->
name|frequency
operator|>=
name|EDGE_FREQUENCY
argument_list|(
name|best_edge
argument_list|)
condition|)
block|{
name|best_edge
operator|=
name|e
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Selecting BB %d\n"
argument_list|,
name|best_edge
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
break|break;
block|}
name|bb
operator|->
name|rbi
operator|->
name|next
operator|=
name|best_edge
operator|->
name|dest
expr_stmt|;
name|bb
operator|=
name|best_edge
operator|->
name|dest
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|best_edge
condition|)
do|;
name|trace
operator|->
name|last
operator|=
name|bb
expr_stmt|;
name|bbd
index|[
name|trace
operator|->
name|first
operator|->
name|index
index|]
operator|.
name|start_of_trace
operator|=
operator|*
name|n_traces
operator|-
literal|1
expr_stmt|;
name|bbd
index|[
name|trace
operator|->
name|last
operator|->
name|index
index|]
operator|.
name|end_of_trace
operator|=
operator|*
name|n_traces
operator|-
literal|1
expr_stmt|;
comment|/* The trace is terminated so we have to recount the keys in heap 	 (some block can have a lower key because now one of its predecessors 	 is an end of the trace).  */
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
block|{
if|if
condition|(
name|e
operator|->
name|dest
operator|==
name|EXIT_BLOCK_PTR
operator|||
name|e
operator|->
name|dest
operator|->
name|rbi
operator|->
name|visited
condition|)
continue|continue;
if|if
condition|(
name|bbd
index|[
name|e
operator|->
name|dest
operator|->
name|index
index|]
operator|.
name|heap
condition|)
block|{
name|key
operator|=
name|bb_to_key
argument_list|(
name|e
operator|->
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|!=
name|bbd
index|[
name|e
operator|->
name|dest
operator|->
name|index
index|]
operator|.
name|node
operator|->
name|key
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Changing key for bb %d from %ld to %ld.\n"
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|,
operator|(
name|long
operator|)
name|bbd
index|[
name|e
operator|->
name|dest
operator|->
name|index
index|]
operator|.
name|node
operator|->
name|key
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
name|fibheap_replace_key
argument_list|(
name|bbd
index|[
name|e
operator|->
name|dest
operator|->
name|index
index|]
operator|.
name|heap
argument_list|,
name|bbd
index|[
name|e
operator|->
name|dest
operator|->
name|index
index|]
operator|.
name|node
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|fibheap_delete
argument_list|(
operator|*
name|heap
argument_list|)
expr_stmt|;
comment|/* "Return" the new heap.  */
operator|*
name|heap
operator|=
name|new_heap
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create a duplicate of the basic block OLD_BB and redirect edge E to it, add    it to trace after BB, mark OLD_BB visited and update pass' data structures    (TRACE is a number of trace which OLD_BB is duplicated to).  */
end_comment

begin_function
specifier|static
name|basic_block
name|copy_bb
parameter_list|(
name|basic_block
name|old_bb
parameter_list|,
name|edge
name|e
parameter_list|,
name|basic_block
name|bb
parameter_list|,
name|int
name|trace
parameter_list|)
block|{
name|basic_block
name|new_bb
decl_stmt|;
name|new_bb
operator|=
name|cfg_layout_duplicate_bb
argument_list|(
name|old_bb
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|dest
operator|!=
name|new_bb
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|dest
operator|->
name|rbi
operator|->
name|visited
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Duplicated bb %d (created bb %d)\n"
argument_list|,
name|old_bb
operator|->
name|index
argument_list|,
name|new_bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|new_bb
operator|->
name|rbi
operator|->
name|visited
operator|=
name|trace
expr_stmt|;
name|new_bb
operator|->
name|rbi
operator|->
name|next
operator|=
name|bb
operator|->
name|rbi
operator|->
name|next
expr_stmt|;
name|bb
operator|->
name|rbi
operator|->
name|next
operator|=
name|new_bb
expr_stmt|;
if|if
condition|(
name|new_bb
operator|->
name|index
operator|>=
name|array_size
operator|||
name|last_basic_block
operator|>
name|array_size
condition|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|new_size
decl_stmt|;
name|new_size
operator|=
name|MAX
argument_list|(
name|last_basic_block
argument_list|,
name|new_bb
operator|->
name|index
operator|+
literal|1
argument_list|)
expr_stmt|;
name|new_size
operator|=
name|GET_ARRAY_SIZE
argument_list|(
name|new_size
argument_list|)
expr_stmt|;
name|bbd
operator|=
name|xrealloc
argument_list|(
name|bbd
argument_list|,
name|new_size
operator|*
sizeof|sizeof
argument_list|(
name|bbro_basic_block_data
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|array_size
init|;
name|i
operator|<
name|new_size
condition|;
name|i
operator|++
control|)
block|{
name|bbd
index|[
name|i
index|]
operator|.
name|start_of_trace
operator|=
operator|-
literal|1
expr_stmt|;
name|bbd
index|[
name|i
index|]
operator|.
name|end_of_trace
operator|=
operator|-
literal|1
expr_stmt|;
name|bbd
index|[
name|i
index|]
operator|.
name|heap
operator|=
name|NULL
expr_stmt|;
name|bbd
index|[
name|i
index|]
operator|.
name|node
operator|=
name|NULL
expr_stmt|;
block|}
name|array_size
operator|=
name|new_size
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Growing the dynamic array to %d elements.\n"
argument_list|,
name|array_size
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|new_bb
return|;
block|}
end_function

begin_comment
comment|/* Compute and return the key (for the heap) of the basic block BB.  */
end_comment

begin_function
specifier|static
name|fibheapkey_t
name|bb_to_key
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|edge
name|e
decl_stmt|;
name|int
name|priority
init|=
literal|0
decl_stmt|;
comment|/* Do not start in probably never executed blocks.  */
if|if
condition|(
name|probably_never_executed_bb_p
argument_list|(
name|bb
argument_list|)
condition|)
return|return
name|BB_FREQ_MAX
return|;
comment|/* Prefer blocks whose predecessor is an end of some trace      or whose predecessor edge is EDGE_DFS_BACK.  */
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
block|{
if|if
condition|(
operator|(
name|e
operator|->
name|src
operator|!=
name|ENTRY_BLOCK_PTR
operator|&&
name|bbd
index|[
name|e
operator|->
name|src
operator|->
name|index
index|]
operator|.
name|end_of_trace
operator|>=
literal|0
operator|)
operator|||
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_DFS_BACK
operator|)
condition|)
block|{
name|int
name|edge_freq
init|=
name|EDGE_FREQUENCY
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
name|edge_freq
operator|>
name|priority
condition|)
name|priority
operator|=
name|edge_freq
expr_stmt|;
block|}
block|}
if|if
condition|(
name|priority
condition|)
comment|/* The block with priority should have significantly lower key.  */
return|return
operator|-
operator|(
literal|100
operator|*
name|BB_FREQ_MAX
operator|+
literal|100
operator|*
name|priority
operator|+
name|bb
operator|->
name|frequency
operator|)
return|;
return|return
operator|-
name|bb
operator|->
name|frequency
return|;
block|}
end_function

begin_comment
comment|/* Return true when the edge E from basic block BB is better than the temporary    best edge (details are in function).  The probability of edge E is PROB. The    frequency of the successor is FREQ.  The current best probability is    BEST_PROB, the best frequency is BEST_FREQ.    The edge is considered to be equivalent when PROB does not differ much from    BEST_PROB; similarly for frequency.  */
end_comment

begin_function
specifier|static
name|bool
name|better_edge_p
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|edge
name|e
parameter_list|,
name|int
name|prob
parameter_list|,
name|int
name|freq
parameter_list|,
name|int
name|best_prob
parameter_list|,
name|int
name|best_freq
parameter_list|)
block|{
name|bool
name|is_better_edge
decl_stmt|;
comment|/* The BEST_* values do not have to be best, but can be a bit smaller than      maximum values.  */
name|int
name|diff_prob
init|=
name|best_prob
operator|/
literal|10
decl_stmt|;
name|int
name|diff_freq
init|=
name|best_freq
operator|/
literal|10
decl_stmt|;
if|if
condition|(
name|prob
operator|>
name|best_prob
operator|+
name|diff_prob
condition|)
comment|/* The edge has higher probability than the temporary best edge.  */
name|is_better_edge
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|prob
operator|<
name|best_prob
operator|-
name|diff_prob
condition|)
comment|/* The edge has lower probability than the temporary best edge.  */
name|is_better_edge
operator|=
name|false
expr_stmt|;
elseif|else
if|if
condition|(
name|freq
operator|<
name|best_freq
operator|-
name|diff_freq
condition|)
comment|/* The edge and the temporary best edge  have almost equivalent        probabilities.  The higher frequency of a successor now means        that there is another edge going into that successor.        This successor has lower frequency so it is better.  */
name|is_better_edge
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|freq
operator|>
name|best_freq
operator|+
name|diff_freq
condition|)
comment|/* This successor has higher frequency so it is worse.  */
name|is_better_edge
operator|=
name|false
expr_stmt|;
elseif|else
if|if
condition|(
name|e
operator|->
name|dest
operator|->
name|prev_bb
operator|==
name|bb
condition|)
comment|/* The edges have equivalent probabilities and the successors        have equivalent frequencies.  Select the previous successor.  */
name|is_better_edge
operator|=
name|true
expr_stmt|;
else|else
name|is_better_edge
operator|=
name|false
expr_stmt|;
return|return
name|is_better_edge
return|;
block|}
end_function

begin_comment
comment|/* Connect traces in array TRACES, N_TRACES is the count of traces.  */
end_comment

begin_function
specifier|static
name|void
name|connect_traces
parameter_list|(
name|int
name|n_traces
parameter_list|,
name|struct
name|trace
modifier|*
name|traces
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|bool
modifier|*
name|connected
decl_stmt|;
name|int
name|last_trace
decl_stmt|;
name|int
name|freq_threshold
decl_stmt|;
name|gcov_type
name|count_threshold
decl_stmt|;
name|freq_threshold
operator|=
name|max_entry_frequency
operator|*
name|DUPLICATION_THRESHOLD
operator|/
literal|1000
expr_stmt|;
if|if
condition|(
name|max_entry_count
operator|<
name|INT_MAX
operator|/
literal|1000
condition|)
name|count_threshold
operator|=
name|max_entry_count
operator|*
name|DUPLICATION_THRESHOLD
operator|/
literal|1000
expr_stmt|;
else|else
name|count_threshold
operator|=
name|max_entry_count
operator|/
literal|1000
operator|*
name|DUPLICATION_THRESHOLD
expr_stmt|;
name|connected
operator|=
name|xcalloc
argument_list|(
name|n_traces
argument_list|,
sizeof|sizeof
argument_list|(
name|bool
argument_list|)
argument_list|)
expr_stmt|;
name|last_trace
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_traces
condition|;
name|i
operator|++
control|)
block|{
name|int
name|t
init|=
name|i
decl_stmt|;
name|int
name|t2
decl_stmt|;
name|edge
name|e
decl_stmt|,
name|best
decl_stmt|;
name|int
name|best_len
decl_stmt|;
if|if
condition|(
name|connected
index|[
name|t
index|]
condition|)
continue|continue;
name|connected
index|[
name|t
index|]
operator|=
name|true
expr_stmt|;
comment|/* Find the predecessor traces.  */
for|for
control|(
name|t2
operator|=
name|t
init|;
name|t2
operator|>
literal|0
condition|;
control|)
block|{
name|best
operator|=
name|NULL
expr_stmt|;
name|best_len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|e
operator|=
name|traces
index|[
name|t2
index|]
operator|.
name|first
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
block|{
name|int
name|si
init|=
name|e
operator|->
name|src
operator|->
name|index
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|src
operator|!=
name|ENTRY_BLOCK_PTR
operator|&&
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_CAN_FALLTHRU
operator|)
operator|&&
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_COMPLEX
operator|)
operator|&&
name|bbd
index|[
name|si
index|]
operator|.
name|end_of_trace
operator|>=
literal|0
operator|&&
operator|!
name|connected
index|[
name|bbd
index|[
name|si
index|]
operator|.
name|end_of_trace
index|]
operator|&&
operator|(
operator|!
name|best
operator|||
name|e
operator|->
name|probability
operator|>
name|best
operator|->
name|probability
operator|||
operator|(
name|e
operator|->
name|probability
operator|==
name|best
operator|->
name|probability
operator|&&
name|traces
index|[
name|bbd
index|[
name|si
index|]
operator|.
name|end_of_trace
index|]
operator|.
name|length
operator|>
name|best_len
operator|)
operator|)
condition|)
block|{
name|best
operator|=
name|e
expr_stmt|;
name|best_len
operator|=
name|traces
index|[
name|bbd
index|[
name|si
index|]
operator|.
name|end_of_trace
index|]
operator|.
name|length
expr_stmt|;
block|}
block|}
if|if
condition|(
name|best
condition|)
block|{
name|best
operator|->
name|src
operator|->
name|rbi
operator|->
name|next
operator|=
name|best
operator|->
name|dest
expr_stmt|;
name|t2
operator|=
name|bbd
index|[
name|best
operator|->
name|src
operator|->
name|index
index|]
operator|.
name|end_of_trace
expr_stmt|;
name|connected
index|[
name|t2
index|]
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Connection: %d %d\n"
argument_list|,
name|best
operator|->
name|src
operator|->
name|index
argument_list|,
name|best
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
block|}
else|else
break|break;
block|}
if|if
condition|(
name|last_trace
operator|>=
literal|0
condition|)
name|traces
index|[
name|last_trace
index|]
operator|.
name|last
operator|->
name|rbi
operator|->
name|next
operator|=
name|traces
index|[
name|t2
index|]
operator|.
name|first
expr_stmt|;
name|last_trace
operator|=
name|t
expr_stmt|;
comment|/* Find the successor traces.  */
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Find the continuation of the chain.  */
name|best
operator|=
name|NULL
expr_stmt|;
name|best_len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|e
operator|=
name|traces
index|[
name|t
index|]
operator|.
name|last
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
block|{
name|int
name|di
init|=
name|e
operator|->
name|dest
operator|->
name|index
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
operator|&&
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_CAN_FALLTHRU
operator|)
operator|&&
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_COMPLEX
operator|)
operator|&&
name|bbd
index|[
name|di
index|]
operator|.
name|start_of_trace
operator|>=
literal|0
operator|&&
operator|!
name|connected
index|[
name|bbd
index|[
name|di
index|]
operator|.
name|start_of_trace
index|]
operator|&&
operator|(
operator|!
name|best
operator|||
name|e
operator|->
name|probability
operator|>
name|best
operator|->
name|probability
operator|||
operator|(
name|e
operator|->
name|probability
operator|==
name|best
operator|->
name|probability
operator|&&
name|traces
index|[
name|bbd
index|[
name|di
index|]
operator|.
name|start_of_trace
index|]
operator|.
name|length
operator|>
name|best_len
operator|)
operator|)
condition|)
block|{
name|best
operator|=
name|e
expr_stmt|;
name|best_len
operator|=
name|traces
index|[
name|bbd
index|[
name|di
index|]
operator|.
name|start_of_trace
index|]
operator|.
name|length
expr_stmt|;
block|}
block|}
if|if
condition|(
name|best
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Connection: %d %d\n"
argument_list|,
name|best
operator|->
name|src
operator|->
name|index
argument_list|,
name|best
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|bbd
index|[
name|best
operator|->
name|dest
operator|->
name|index
index|]
operator|.
name|start_of_trace
expr_stmt|;
name|traces
index|[
name|last_trace
index|]
operator|.
name|last
operator|->
name|rbi
operator|->
name|next
operator|=
name|traces
index|[
name|t
index|]
operator|.
name|first
expr_stmt|;
name|connected
index|[
name|t
index|]
operator|=
name|true
expr_stmt|;
name|last_trace
operator|=
name|t
expr_stmt|;
block|}
else|else
block|{
comment|/* Try to connect the traces by duplication of 1 block.  */
name|edge
name|e2
decl_stmt|;
name|basic_block
name|next_bb
init|=
name|NULL
decl_stmt|;
name|bool
name|try_copy
init|=
name|false
decl_stmt|;
for|for
control|(
name|e
operator|=
name|traces
index|[
name|t
index|]
operator|.
name|last
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
if|if
condition|(
name|e
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
operator|&&
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_CAN_FALLTHRU
operator|)
operator|&&
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_COMPLEX
operator|)
operator|&&
operator|(
operator|!
name|best
operator|||
name|e
operator|->
name|probability
operator|>
name|best
operator|->
name|probability
operator|)
condition|)
block|{
name|edge
name|best2
init|=
name|NULL
decl_stmt|;
name|int
name|best2_len
init|=
literal|0
decl_stmt|;
comment|/* If the destination is a start of a trace which is only 		       one block long, then no need to search the successor 		       blocks of the trace.  Accept it.  */
if|if
condition|(
name|bbd
index|[
name|e
operator|->
name|dest
operator|->
name|index
index|]
operator|.
name|start_of_trace
operator|>=
literal|0
operator|&&
name|traces
index|[
name|bbd
index|[
name|e
operator|->
name|dest
operator|->
name|index
index|]
operator|.
name|start_of_trace
index|]
operator|.
name|length
operator|==
literal|1
condition|)
block|{
name|best
operator|=
name|e
expr_stmt|;
name|try_copy
operator|=
name|true
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|e2
operator|=
name|e
operator|->
name|dest
operator|->
name|succ
init|;
name|e2
condition|;
name|e2
operator|=
name|e2
operator|->
name|succ_next
control|)
block|{
name|int
name|di
init|=
name|e2
operator|->
name|dest
operator|->
name|index
decl_stmt|;
if|if
condition|(
name|e2
operator|->
name|dest
operator|==
name|EXIT_BLOCK_PTR
operator|||
operator|(
operator|(
name|e2
operator|->
name|flags
operator|&
name|EDGE_CAN_FALLTHRU
operator|)
operator|&&
operator|!
operator|(
name|e2
operator|->
name|flags
operator|&
name|EDGE_COMPLEX
operator|)
operator|&&
name|bbd
index|[
name|di
index|]
operator|.
name|start_of_trace
operator|>=
literal|0
operator|&&
operator|!
name|connected
index|[
name|bbd
index|[
name|di
index|]
operator|.
name|start_of_trace
index|]
operator|&&
operator|(
name|EDGE_FREQUENCY
argument_list|(
name|e2
argument_list|)
operator|>=
name|freq_threshold
operator|)
operator|&&
operator|(
name|e2
operator|->
name|count
operator|>=
name|count_threshold
operator|)
operator|&&
operator|(
operator|!
name|best2
operator|||
name|e2
operator|->
name|probability
operator|>
name|best2
operator|->
name|probability
operator|||
operator|(
name|e2
operator|->
name|probability
operator|==
name|best2
operator|->
name|probability
operator|&&
name|traces
index|[
name|bbd
index|[
name|di
index|]
operator|.
name|start_of_trace
index|]
operator|.
name|length
operator|>
name|best2_len
operator|)
operator|)
operator|)
condition|)
block|{
name|best
operator|=
name|e
expr_stmt|;
name|best2
operator|=
name|e2
expr_stmt|;
if|if
condition|(
name|e2
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
condition|)
name|best2_len
operator|=
name|traces
index|[
name|bbd
index|[
name|di
index|]
operator|.
name|start_of_trace
index|]
operator|.
name|length
expr_stmt|;
else|else
name|best2_len
operator|=
name|INT_MAX
expr_stmt|;
name|next_bb
operator|=
name|e2
operator|->
name|dest
expr_stmt|;
name|try_copy
operator|=
name|true
expr_stmt|;
block|}
block|}
block|}
comment|/* Copy tiny blocks always; copy larger blocks only when the 		 edge is traversed frequently enough.  */
if|if
condition|(
name|try_copy
operator|&&
name|copy_bb_p
argument_list|(
name|best
operator|->
name|dest
argument_list|,
operator|!
name|optimize_size
operator|&&
name|EDGE_FREQUENCY
argument_list|(
name|best
argument_list|)
operator|>=
name|freq_threshold
operator|&&
name|best
operator|->
name|count
operator|>=
name|count_threshold
argument_list|)
condition|)
block|{
name|basic_block
name|new_bb
decl_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Connection: %d %d "
argument_list|,
name|traces
index|[
name|t
index|]
operator|.
name|last
operator|->
name|index
argument_list|,
name|best
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|next_bb
condition|)
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|rtl_dump_file
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|next_bb
operator|==
name|EXIT_BLOCK_PTR
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"exit\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"%d\n"
argument_list|,
name|next_bb
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
name|new_bb
operator|=
name|copy_bb
argument_list|(
name|best
operator|->
name|dest
argument_list|,
name|best
argument_list|,
name|traces
index|[
name|t
index|]
operator|.
name|last
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|traces
index|[
name|t
index|]
operator|.
name|last
operator|=
name|new_bb
expr_stmt|;
if|if
condition|(
name|next_bb
operator|&&
name|next_bb
operator|!=
name|EXIT_BLOCK_PTR
condition|)
block|{
name|t
operator|=
name|bbd
index|[
name|next_bb
operator|->
name|index
index|]
operator|.
name|start_of_trace
expr_stmt|;
name|traces
index|[
name|last_trace
index|]
operator|.
name|last
operator|->
name|rbi
operator|->
name|next
operator|=
name|traces
index|[
name|t
index|]
operator|.
name|first
expr_stmt|;
name|connected
index|[
name|t
index|]
operator|=
name|true
expr_stmt|;
name|last_trace
operator|=
name|t
expr_stmt|;
block|}
else|else
break|break;
comment|/* Stop finding the successor traces.  */
block|}
else|else
break|break;
comment|/* Stop finding the successor traces.  */
block|}
block|}
block|}
if|if
condition|(
name|rtl_dump_file
condition|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Final order:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|bb
operator|=
name|traces
index|[
literal|0
index|]
operator|.
name|first
init|;
name|bb
condition|;
name|bb
operator|=
name|bb
operator|->
name|rbi
operator|->
name|next
control|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"%d "
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|rtl_dump_file
argument_list|)
expr_stmt|;
block|}
name|FREE
argument_list|(
name|connected
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true when BB can and should be copied. CODE_MAY_GROW is true    when code size is allowed to grow by duplication.  */
end_comment

begin_function
specifier|static
name|bool
name|copy_bb_p
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|int
name|code_may_grow
parameter_list|)
block|{
name|int
name|size
init|=
literal|0
decl_stmt|;
name|int
name|max_size
init|=
name|uncond_jump_length
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|n_succ
decl_stmt|;
name|edge
name|e
decl_stmt|;
if|if
condition|(
operator|!
name|bb
operator|->
name|frequency
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|bb
operator|->
name|pred
operator|||
operator|!
name|bb
operator|->
name|pred
operator|->
name|pred_next
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|cfg_layout_can_duplicate_bb_p
argument_list|(
name|bb
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Avoid duplicating blocks which have many successors (PR/13430).  */
name|n_succ
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
block|{
name|n_succ
operator|++
expr_stmt|;
if|if
condition|(
name|n_succ
operator|>
literal|8
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|code_may_grow
operator|&&
name|maybe_hot_bb_p
argument_list|(
name|bb
argument_list|)
condition|)
name|max_size
operator|*=
literal|8
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
init|;
name|insn
operator|!=
name|NEXT_INSN
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|size
operator|+=
name|get_attr_length
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|<=
name|max_size
condition|)
return|return
name|true
return|;
if|if
condition|(
name|rtl_dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Block %d can't be copied because its size = %d.\n"
argument_list|,
name|bb
operator|->
name|index
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return the length of unconditional jump instruction.  */
end_comment

begin_function
specifier|static
name|int
name|get_uncond_jump_length
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|label
decl_stmt|,
name|jump
decl_stmt|;
name|int
name|length
decl_stmt|;
name|label
operator|=
name|emit_label_before
argument_list|(
name|gen_label_rtx
argument_list|()
argument_list|,
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
name|jump
operator|=
name|emit_jump_insn
argument_list|(
name|gen_jump
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|length
operator|=
name|get_attr_length
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|label
argument_list|)
expr_stmt|;
return|return
name|length
return|;
block|}
end_function

begin_comment
comment|/* Reorder basic blocks.  The main entry point to this file.  FLAGS is    the set of flags to pass to cfg_layout_initialize().  */
end_comment

begin_function
name|void
name|reorder_basic_blocks
parameter_list|(
name|unsigned
name|int
name|flags
parameter_list|)
block|{
name|int
name|n_traces
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|trace
modifier|*
name|traces
decl_stmt|;
if|if
condition|(
name|n_basic_blocks
operator|<=
literal|1
condition|)
return|return;
if|if
condition|(
call|(
modifier|*
name|targetm
operator|.
name|cannot_modify_jumps_p
call|)
argument_list|()
condition|)
return|return;
name|timevar_push
argument_list|(
name|TV_REORDER_BLOCKS
argument_list|)
expr_stmt|;
name|cfg_layout_initialize
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|set_edge_can_fallthru_flag
argument_list|()
expr_stmt|;
name|mark_dfs_back_edges
argument_list|()
expr_stmt|;
comment|/* We are estimating the length of uncond jump insn only once since the code      for getting the insn length always returns the minimal length now.  */
if|if
condition|(
name|uncond_jump_length
operator|==
literal|0
condition|)
name|uncond_jump_length
operator|=
name|get_uncond_jump_length
argument_list|()
expr_stmt|;
comment|/* We need to know some information for each basic block.  */
name|array_size
operator|=
name|GET_ARRAY_SIZE
argument_list|(
name|last_basic_block
argument_list|)
expr_stmt|;
name|bbd
operator|=
name|xmalloc
argument_list|(
name|array_size
operator|*
sizeof|sizeof
argument_list|(
name|bbro_basic_block_data
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|array_size
condition|;
name|i
operator|++
control|)
block|{
name|bbd
index|[
name|i
index|]
operator|.
name|start_of_trace
operator|=
operator|-
literal|1
expr_stmt|;
name|bbd
index|[
name|i
index|]
operator|.
name|end_of_trace
operator|=
operator|-
literal|1
expr_stmt|;
name|bbd
index|[
name|i
index|]
operator|.
name|heap
operator|=
name|NULL
expr_stmt|;
name|bbd
index|[
name|i
index|]
operator|.
name|node
operator|=
name|NULL
expr_stmt|;
block|}
name|traces
operator|=
name|xmalloc
argument_list|(
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|trace
argument_list|)
argument_list|)
expr_stmt|;
name|n_traces
operator|=
literal|0
expr_stmt|;
name|find_traces
argument_list|(
operator|&
name|n_traces
argument_list|,
name|traces
argument_list|)
expr_stmt|;
name|connect_traces
argument_list|(
name|n_traces
argument_list|,
name|traces
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|traces
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|bbd
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|dump_flow_info
argument_list|(
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|cfg_layout_finalize
argument_list|()
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_REORDER_BLOCKS
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

