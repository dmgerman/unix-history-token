begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Output Dwarf format symbol table information from the GNU C compiler.    Copyright (C) 1992, 1993, 1995 Free Software Foundation, Inc.     Written by Ron Guilmette (rfg@netcom.com) for    Network Computing Devices, August, September, October, November 1990.    Generously contributed by NCD to the Free Software Foundation.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DWARF_DEBUGGING_INFO
end_ifdef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"dwarf.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"defaults.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|DWARF_VERSION
end_ifndef

begin_define
define|#
directive|define
name|DWARF_VERSION
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* #define NDEBUG 1 */
end_comment

begin_include
include|#
directive|include
file|"assert.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DWARF_TIMESTAMPS
argument_list|)
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|POSIX
argument_list|)
end_if

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !defined(POSIX) */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
end_if

begin_function_decl
specifier|extern
name|time_t
name|time
parameter_list|(
name|time_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !defined(__STDC__) */
end_comment

begin_function_decl
specifier|extern
name|time_t
name|time
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined(__STDC__) */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined(POSIX) */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(DWARF_TIMESTAMPS) */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|getpwd
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|rindex
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* IMPORTANT NOTE: Please see the file README.DWARF for important details    regarding the GNU implementation of Dwarf.  */
end_comment

begin_comment
comment|/* NOTE: In the comments in this file, many references are made to    so called "Debugging Information Entries".  For the sake of brevity,    this term is abbreviated to `DIE' throughout the remainder of this    file.  */
end_comment

begin_comment
comment|/* Note that the implementation of C++ support herein is (as yet) unfinished.    If you want to try to complete it, more power to you.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
operator|(
name|NDEBUG
operator|==
literal|1
operator|)
end_if

begin_define
define|#
directive|define
name|inline
value|static inline
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|inline
value|static
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* How to start an assembler comment.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_COMMENT_START
end_ifndef

begin_define
define|#
directive|define
name|ASM_COMMENT_START
value|";#"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* How to print out a register name.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PRINT_REG
end_ifndef

begin_define
define|#
directive|define
name|PRINT_REG
parameter_list|(
name|RTX
parameter_list|,
name|CODE
parameter_list|,
name|FILE
parameter_list|)
define|\
value|fprintf ((FILE), "%s", reg_names[REGNO (RTX)])
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Define a macro which returns non-zero for any tagged type which is    used (directly or indirectly) in the specification of either some    function's return type or some formal parameter of some function.    We use this macro when we are operating in "terse" mode to help us    know what tagged types have to be represented in Dwarf (even in    terse mode) and which ones don't.     A flag bit with this meaning really should be a part of the normal    GCC ..._TYPE nodes, but at the moment, there is no such bit defined    for these nodes.  For now, we have to just fake it.  It it safe for    us to simply return zero for all complete tagged types (which will    get forced out anyway if they were used in the specification of some    formal or return type) and non-zero for all incomplete tagged types. */
end_comment

begin_define
define|#
directive|define
name|TYPE_USED_FOR_FUNCTION
parameter_list|(
name|tagged_type
parameter_list|)
value|(TYPE_SIZE (tagged_type) == 0)
end_define

begin_decl_stmt
specifier|extern
name|int
name|flag_traditional
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|version_string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|language_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maximum size (in bytes) of an artificially generated label.	*/
end_comment

begin_define
define|#
directive|define
name|MAX_ARTIFICIAL_LABEL_BYTES
value|30
end_define

begin_escape
end_escape

begin_comment
comment|/* Make sure we know the sizes of the various types dwarf can describe.    These are only defaults.  If the sizes are different for your target,    you should override these values by defining the appropriate symbols    in your tm.h file.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CHAR_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|CHAR_TYPE_SIZE
value|BITS_PER_UNIT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SHORT_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|SHORT_TYPE_SIZE
value|(BITS_PER_UNIT * 2)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|INT_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|INT_TYPE_SIZE
value|BITS_PER_WORD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LONG_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|LONG_TYPE_SIZE
value|BITS_PER_WORD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LONG_LONG_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|LONG_LONG_TYPE_SIZE
value|(BITS_PER_WORD * 2)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WCHAR_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|WCHAR_TYPE_SIZE
value|INT_TYPE_SIZE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WCHAR_UNSIGNED
end_ifndef

begin_define
define|#
directive|define
name|WCHAR_UNSIGNED
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|FLOAT_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|FLOAT_TYPE_SIZE
value|BITS_PER_WORD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DOUBLE_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|DOUBLE_TYPE_SIZE
value|(BITS_PER_WORD * 2)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LONG_DOUBLE_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|LONG_DOUBLE_TYPE_SIZE
value|(BITS_PER_WORD * 2)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Structure to keep track of source filenames.  */
end_comment

begin_struct
struct|struct
name|filename_entry
block|{
name|unsigned
name|number
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|filename_entry
name|filename_entry
typedef|;
end_typedef

begin_comment
comment|/* Pointer to an array of elements, each one having the structure above. */
end_comment

begin_decl_stmt
specifier|static
name|filename_entry
modifier|*
name|filename_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Total number of entries in the table (i.e. array) pointed to by    `filename_table'.  This is the *total* and includes both used and    unused slots.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|ft_entries_allocated
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of entries in the filename_table which are actually in use.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|ft_entries
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size (in elements) of increments by which we may expand the filename    table.  Actually, a single hunk of space of this size should be enough    for most typical programs.	 */
end_comment

begin_define
define|#
directive|define
name|FT_ENTRIES_INCREMENT
value|64
end_define

begin_comment
comment|/* Local pointer to the name of the main input file.  Initialized in    dwarfout_init.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|primary_filename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to the most recent filename for which we produced some line info.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|last_filename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For Dwarf output, we must assign lexical-blocks id numbers    in the order in which their beginnings are encountered.    We output Dwarf debugging info that refers to the beginnings    and ends of the ranges of code for each lexical block with    assembler labels ..Bn and ..Bn.e, where n is the block number.    The labels themselves are generated in final.c, which assigns    numbers to the blocks in the same way.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|next_block_number
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Counter to generate unique names for DIEs. */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|next_unused_dienum
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of the DIE which is currently being generated.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|current_dienum
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number to use for the special "pubname" label on the next DIE which    represents a function or data object defined in this compilation    unit which has "extern" linkage.  */
end_comment

begin_expr_stmt
specifier|static
name|next_pubname_number
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|NEXT_DIE_NUM
value|pending_sibling_stack[pending_siblings-1]
end_define

begin_comment
comment|/* Pointer to a dynamically allocated list of pre-reserved and still    pending sibling DIE numbers.	 Note that this list will grow as needed.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
modifier|*
name|pending_sibling_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Counter to keep track of the number of pre-reserved and still pending    sibling DIE numbers.	 */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|pending_siblings
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The currently allocated size of the above list (expressed in number of    list elements).  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|pending_siblings_allocated
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size (in elements) of increments by which we may expand the pending    sibling stack.  Actually, a single hunk of space of this size should    be enough for most typical programs.	 */
end_comment

begin_define
define|#
directive|define
name|PENDING_SIBLINGS_INCREMENT
value|64
end_define

begin_comment
comment|/* Non-zero if we are performing our file-scope finalization pass and if    we should force out Dwarf descriptions of any and all file-scope    tagged types which are still incomplete types.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|finalizing
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A pointer to the base of a list of pending types which we haven't    generated DIEs for yet, but which we will have to come back to    later on.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
modifier|*
name|pending_types_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements currently allocated for the pending_types_list.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|pending_types_allocated
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements of pending_types_list currently in use.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|pending_types
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size (in elements) of increments by which we may expand the pending    types list.  Actually, a single hunk of space of this size should    be enough for most typical programs.	 */
end_comment

begin_define
define|#
directive|define
name|PENDING_TYPES_INCREMENT
value|64
end_define

begin_comment
comment|/* Pointer to an artificial RECORD_TYPE which we create in dwarfout_init.    This is used in a hack to help us get the DIEs describing types of    formal parameters to come *after* all of the DIEs describing the formal    parameters themselves.  That's necessary in order to be compatible    with what the brain-damaged svr4 SDB debugger requires.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|fake_containing_scope
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of the current function definition that we are generating    debugging information for.  These numbers range from 1 up to the maximum    number of function definitions contained within the current compilation    unit.  These numbers are used to create unique labels for various things    contained within various function definitions.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|current_funcdef_number
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A pointer to the ..._DECL node which we have most recently been working    on.  We keep this around just in case something about it looks screwy    and we want to tell the user what the source coordinates for the actual    declaration are.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|dwarf_last_decl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declarations for functions defined in this file.  */
end_comment

begin_function_decl
specifier|static
name|void
name|output_type
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|type_attribute
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|output_decls_for_scope
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|output_decl
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|lookup_filename
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Definitions of defaults for assembler-dependent names of various    pseudo-ops and section names.     Theses may be overridden in your tm.h file (if necessary) for your    particular assembler.  The default values provided here correspond to    what is expected by "standard" AT&T System V.4 assemblers.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|FILE_ASM_OP
end_ifndef

begin_define
define|#
directive|define
name|FILE_ASM_OP
value|".file"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|VERSION_ASM_OP
end_ifndef

begin_define
define|#
directive|define
name|VERSION_ASM_OP
value|".version"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|UNALIGNED_SHORT_ASM_OP
end_ifndef

begin_define
define|#
directive|define
name|UNALIGNED_SHORT_ASM_OP
value|".2byte"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|UNALIGNED_INT_ASM_OP
end_ifndef

begin_define
define|#
directive|define
name|UNALIGNED_INT_ASM_OP
value|".4byte"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_BYTE_OP
end_ifndef

begin_define
define|#
directive|define
name|ASM_BYTE_OP
value|".byte"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SET_ASM_OP
end_ifndef

begin_define
define|#
directive|define
name|SET_ASM_OP
value|".set"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Pseudo-ops for pushing the current section onto the section stack (and    simultaneously changing to a new section) and for poping back to the    section we were in immediately before this one.  Note that most svr4    assemblers only maintain a one level stack... you can push all the    sections you want, but you can only pop out one level.  (The sparc    svr4 assembler is an exception to this general rule.)  That's    OK because we only use at most one level of the section stack herein.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PUSHSECTION_ASM_OP
end_ifndef

begin_define
define|#
directive|define
name|PUSHSECTION_ASM_OP
value|".section"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|POPSECTION_ASM_OP
end_ifndef

begin_define
define|#
directive|define
name|POPSECTION_ASM_OP
value|".previous"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The default format used by the ASM_OUTPUT_PUSH_SECTION macro (see below)    to print the PUSHSECTION_ASM_OP and the section name.  The default here    works for almost all svr4 assemblers, except for the sparc, where the    section name must be enclosed in double quotes.  (See sparcv4.h.)  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PUSHSECTION_FORMAT
end_ifndef

begin_define
define|#
directive|define
name|PUSHSECTION_FORMAT
value|"\t%s\t%s\n"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG_SECTION
end_ifndef

begin_define
define|#
directive|define
name|DEBUG_SECTION
value|".debug"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LINE_SECTION
end_ifndef

begin_define
define|#
directive|define
name|LINE_SECTION
value|".line"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SFNAMES_SECTION
end_ifndef

begin_define
define|#
directive|define
name|SFNAMES_SECTION
value|".debug_sfnames"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SRCINFO_SECTION
end_ifndef

begin_define
define|#
directive|define
name|SRCINFO_SECTION
value|".debug_srcinfo"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MACINFO_SECTION
end_ifndef

begin_define
define|#
directive|define
name|MACINFO_SECTION
value|".debug_macinfo"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PUBNAMES_SECTION
end_ifndef

begin_define
define|#
directive|define
name|PUBNAMES_SECTION
value|".debug_pubnames"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ARANGES_SECTION
end_ifndef

begin_define
define|#
directive|define
name|ARANGES_SECTION
value|".debug_aranges"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TEXT_SECTION
end_ifndef

begin_define
define|#
directive|define
name|TEXT_SECTION
value|".text"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DATA_SECTION
end_ifndef

begin_define
define|#
directive|define
name|DATA_SECTION
value|".data"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DATA1_SECTION
end_ifndef

begin_define
define|#
directive|define
name|DATA1_SECTION
value|".data1"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|RODATA_SECTION
end_ifndef

begin_define
define|#
directive|define
name|RODATA_SECTION
value|".rodata"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|RODATA1_SECTION
end_ifndef

begin_define
define|#
directive|define
name|RODATA1_SECTION
value|".rodata1"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|BSS_SECTION
end_ifndef

begin_define
define|#
directive|define
name|BSS_SECTION
value|".bss"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Definitions of defaults for formats and names of various special    (artificial) labels which may be generated within this file (when    the -g options is used and DWARF_DEBUGGING_INFO is in effect.     If necessary, these may be overridden from within your tm.h file,    but typically, you should never need to override these.     These labels have been hacked (temporarily) so that they all begin with    a `.L' sequence so as to appease the stock sparc/svr4 assembler and the    stock m88k/svr4 assembler, both of which need to see .L at the start of    a label in order to prevent that label from going into the linker symbol    table).  When I get time, I'll have to fix this the right way so that we    will use ASM_GENERATE_INTERNAL_LABEL and ASM_OUTPUT_INTERNAL_LABEL herein,    but that will require a rather massive set of changes.  For the moment,    the following definitions out to produce the right results for all svr4    and svr3 assemblers. -- rfg */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TEXT_BEGIN_LABEL
end_ifndef

begin_define
define|#
directive|define
name|TEXT_BEGIN_LABEL
value|".L_text_b"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TEXT_END_LABEL
end_ifndef

begin_define
define|#
directive|define
name|TEXT_END_LABEL
value|".L_text_e"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DATA_BEGIN_LABEL
end_ifndef

begin_define
define|#
directive|define
name|DATA_BEGIN_LABEL
value|".L_data_b"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DATA_END_LABEL
end_ifndef

begin_define
define|#
directive|define
name|DATA_END_LABEL
value|".L_data_e"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DATA1_BEGIN_LABEL
end_ifndef

begin_define
define|#
directive|define
name|DATA1_BEGIN_LABEL
value|".L_data1_b"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DATA1_END_LABEL
end_ifndef

begin_define
define|#
directive|define
name|DATA1_END_LABEL
value|".L_data1_e"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|RODATA_BEGIN_LABEL
end_ifndef

begin_define
define|#
directive|define
name|RODATA_BEGIN_LABEL
value|".L_rodata_b"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|RODATA_END_LABEL
end_ifndef

begin_define
define|#
directive|define
name|RODATA_END_LABEL
value|".L_rodata_e"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|RODATA1_BEGIN_LABEL
end_ifndef

begin_define
define|#
directive|define
name|RODATA1_BEGIN_LABEL
value|".L_rodata1_b"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|RODATA1_END_LABEL
end_ifndef

begin_define
define|#
directive|define
name|RODATA1_END_LABEL
value|".L_rodata1_e"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|BSS_BEGIN_LABEL
end_ifndef

begin_define
define|#
directive|define
name|BSS_BEGIN_LABEL
value|".L_bss_b"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|BSS_END_LABEL
end_ifndef

begin_define
define|#
directive|define
name|BSS_END_LABEL
value|".L_bss_e"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LINE_BEGIN_LABEL
end_ifndef

begin_define
define|#
directive|define
name|LINE_BEGIN_LABEL
value|".L_line_b"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LINE_LAST_ENTRY_LABEL
end_ifndef

begin_define
define|#
directive|define
name|LINE_LAST_ENTRY_LABEL
value|".L_line_last"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LINE_END_LABEL
end_ifndef

begin_define
define|#
directive|define
name|LINE_END_LABEL
value|".L_line_e"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG_BEGIN_LABEL
end_ifndef

begin_define
define|#
directive|define
name|DEBUG_BEGIN_LABEL
value|".L_debug_b"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SFNAMES_BEGIN_LABEL
end_ifndef

begin_define
define|#
directive|define
name|SFNAMES_BEGIN_LABEL
value|".L_sfnames_b"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SRCINFO_BEGIN_LABEL
end_ifndef

begin_define
define|#
directive|define
name|SRCINFO_BEGIN_LABEL
value|".L_srcinfo_b"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MACINFO_BEGIN_LABEL
end_ifndef

begin_define
define|#
directive|define
name|MACINFO_BEGIN_LABEL
value|".L_macinfo_b"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DIE_BEGIN_LABEL_FMT
end_ifndef

begin_define
define|#
directive|define
name|DIE_BEGIN_LABEL_FMT
value|".L_D%u"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DIE_END_LABEL_FMT
end_ifndef

begin_define
define|#
directive|define
name|DIE_END_LABEL_FMT
value|".L_D%u_e"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PUB_DIE_LABEL_FMT
end_ifndef

begin_define
define|#
directive|define
name|PUB_DIE_LABEL_FMT
value|".L_P%u"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|INSN_LABEL_FMT
end_ifndef

begin_define
define|#
directive|define
name|INSN_LABEL_FMT
value|".L_I%u_%u"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|BLOCK_BEGIN_LABEL_FMT
end_ifndef

begin_define
define|#
directive|define
name|BLOCK_BEGIN_LABEL_FMT
value|".L_B%u"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|BLOCK_END_LABEL_FMT
end_ifndef

begin_define
define|#
directive|define
name|BLOCK_END_LABEL_FMT
value|".L_B%u_e"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SS_BEGIN_LABEL_FMT
end_ifndef

begin_define
define|#
directive|define
name|SS_BEGIN_LABEL_FMT
value|".L_s%u"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SS_END_LABEL_FMT
end_ifndef

begin_define
define|#
directive|define
name|SS_END_LABEL_FMT
value|".L_s%u_e"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|EE_BEGIN_LABEL_FMT
end_ifndef

begin_define
define|#
directive|define
name|EE_BEGIN_LABEL_FMT
value|".L_e%u"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|EE_END_LABEL_FMT
end_ifndef

begin_define
define|#
directive|define
name|EE_END_LABEL_FMT
value|".L_e%u_e"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MT_BEGIN_LABEL_FMT
end_ifndef

begin_define
define|#
directive|define
name|MT_BEGIN_LABEL_FMT
value|".L_t%u"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MT_END_LABEL_FMT
end_ifndef

begin_define
define|#
directive|define
name|MT_END_LABEL_FMT
value|".L_t%u_e"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LOC_BEGIN_LABEL_FMT
end_ifndef

begin_define
define|#
directive|define
name|LOC_BEGIN_LABEL_FMT
value|".L_l%u"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LOC_END_LABEL_FMT
end_ifndef

begin_define
define|#
directive|define
name|LOC_END_LABEL_FMT
value|".L_l%u_e"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|BOUND_BEGIN_LABEL_FMT
end_ifndef

begin_define
define|#
directive|define
name|BOUND_BEGIN_LABEL_FMT
value|".L_b%u_%u_%c"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|BOUND_END_LABEL_FMT
end_ifndef

begin_define
define|#
directive|define
name|BOUND_END_LABEL_FMT
value|".L_b%u_%u_%c_e"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DERIV_BEGIN_LABEL_FMT
end_ifndef

begin_define
define|#
directive|define
name|DERIV_BEGIN_LABEL_FMT
value|".L_d%u"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DERIV_END_LABEL_FMT
end_ifndef

begin_define
define|#
directive|define
name|DERIV_END_LABEL_FMT
value|".L_d%u_e"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SL_BEGIN_LABEL_FMT
end_ifndef

begin_define
define|#
directive|define
name|SL_BEGIN_LABEL_FMT
value|".L_sl%u"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SL_END_LABEL_FMT
end_ifndef

begin_define
define|#
directive|define
name|SL_END_LABEL_FMT
value|".L_sl%u_e"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|BODY_BEGIN_LABEL_FMT
end_ifndef

begin_define
define|#
directive|define
name|BODY_BEGIN_LABEL_FMT
value|".L_b%u"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|BODY_END_LABEL_FMT
end_ifndef

begin_define
define|#
directive|define
name|BODY_END_LABEL_FMT
value|".L_b%u_e"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|FUNC_END_LABEL_FMT
end_ifndef

begin_define
define|#
directive|define
name|FUNC_END_LABEL_FMT
value|".L_f%u_e"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TYPE_NAME_FMT
end_ifndef

begin_define
define|#
directive|define
name|TYPE_NAME_FMT
value|".L_T%u"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DECL_NAME_FMT
end_ifndef

begin_define
define|#
directive|define
name|DECL_NAME_FMT
value|".L_E%u"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LINE_CODE_LABEL_FMT
end_ifndef

begin_define
define|#
directive|define
name|LINE_CODE_LABEL_FMT
value|".L_LC%u"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SFNAMES_ENTRY_LABEL_FMT
end_ifndef

begin_define
define|#
directive|define
name|SFNAMES_ENTRY_LABEL_FMT
value|".L_F%u"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LINE_ENTRY_LABEL_FMT
end_ifndef

begin_define
define|#
directive|define
name|LINE_ENTRY_LABEL_FMT
value|".L_LE%u"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Definitions of defaults for various types of primitive assembly language    output operations.     If necessary, these may be overridden from within your tm.h file,    but typically, you shouldn't need to override these.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_PUSH_SECTION
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_PUSH_SECTION
parameter_list|(
name|FILE
parameter_list|,
name|SECTION
parameter_list|)
define|\
value|fprintf ((FILE), PUSHSECTION_FORMAT, PUSHSECTION_ASM_OP, SECTION)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_POP_SECTION
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_POP_SECTION
parameter_list|(
name|FILE
parameter_list|)
define|\
value|fprintf ((FILE), "\t%s\n", POPSECTION_ASM_OP)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_SOURCE_FILENAME
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_SOURCE_FILENAME
parameter_list|(
name|FILE
parameter_list|,
name|NAME
parameter_list|)
define|\
value|do {	fprintf (FILE, "\t%s\t", FILE_ASM_OP);				\ 	output_quoted_string (FILE, NAME);				\ 	fputc ('\n', FILE);						\   } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_DWARF_DELTA2
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_DWARF_DELTA2
parameter_list|(
name|FILE
parameter_list|,
name|LABEL1
parameter_list|,
name|LABEL2
parameter_list|)
define|\
value|do {	fprintf ((FILE), "\t%s\t", UNALIGNED_SHORT_ASM_OP);		\ 	assemble_name (FILE, LABEL1);					\ 	fprintf (FILE, "-");						\ 	assemble_name (FILE, LABEL2);					\ 	fprintf (FILE, "\n");						\   } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_DWARF_DELTA4
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_DWARF_DELTA4
parameter_list|(
name|FILE
parameter_list|,
name|LABEL1
parameter_list|,
name|LABEL2
parameter_list|)
define|\
value|do {	fprintf ((FILE), "\t%s\t", UNALIGNED_INT_ASM_OP);		\ 	assemble_name (FILE, LABEL1);					\ 	fprintf (FILE, "-");						\ 	assemble_name (FILE, LABEL2);					\ 	fprintf (FILE, "\n");						\   } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_DWARF_TAG
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_DWARF_TAG
parameter_list|(
name|FILE
parameter_list|,
name|TAG
parameter_list|)
define|\
value|do {									\     fprintf ((FILE), "\t%s\t0x%x",					\ 		     UNALIGNED_SHORT_ASM_OP, (unsigned) TAG);		\     if (flag_verbose_asm)						\       fprintf ((FILE), "\t%s %s",					\ 		       ASM_COMMENT_START, dwarf_tag_name (TAG));	\     fputc ('\n', (FILE));						\   } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_DWARF_ATTRIBUTE
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_DWARF_ATTRIBUTE
parameter_list|(
name|FILE
parameter_list|,
name|ATTR
parameter_list|)
define|\
value|do {									\     fprintf ((FILE), "\t%s\t0x%x",					\ 		     UNALIGNED_SHORT_ASM_OP, (unsigned) ATTR);		\     if (flag_verbose_asm)						\       fprintf ((FILE), "\t%s %s",					\ 		       ASM_COMMENT_START, dwarf_attr_name (ATTR));	\     fputc ('\n', (FILE));						\   } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_DWARF_STACK_OP
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_DWARF_STACK_OP
parameter_list|(
name|FILE
parameter_list|,
name|OP
parameter_list|)
define|\
value|do {									\     fprintf ((FILE), "\t%s\t0x%x", ASM_BYTE_OP, (unsigned) OP);		\     if (flag_verbose_asm)						\       fprintf ((FILE), "\t%s %s",					\ 		       ASM_COMMENT_START, dwarf_stack_op_name (OP));	\     fputc ('\n', (FILE));						\   } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_DWARF_FUND_TYPE
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_DWARF_FUND_TYPE
parameter_list|(
name|FILE
parameter_list|,
name|FT
parameter_list|)
define|\
value|do {									\     fprintf ((FILE), "\t%s\t0x%x",					\ 		     UNALIGNED_SHORT_ASM_OP, (unsigned) FT);		\     if (flag_verbose_asm)						\       fprintf ((FILE), "\t%s %s",					\ 		       ASM_COMMENT_START, dwarf_fund_type_name (FT));	\     fputc ('\n', (FILE));						\   } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_DWARF_FMT_BYTE
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_DWARF_FMT_BYTE
parameter_list|(
name|FILE
parameter_list|,
name|FMT
parameter_list|)
define|\
value|do {									\     fprintf ((FILE), "\t%s\t0x%x", ASM_BYTE_OP, (unsigned) FMT);	\     if (flag_verbose_asm)						\       fprintf ((FILE), "\t%s %s",					\ 		       ASM_COMMENT_START, dwarf_fmt_byte_name (FMT));	\     fputc ('\n', (FILE));						\   } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_DWARF_TYPE_MODIFIER
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_DWARF_TYPE_MODIFIER
parameter_list|(
name|FILE
parameter_list|,
name|MOD
parameter_list|)
define|\
value|do {									\     fprintf ((FILE), "\t%s\t0x%x", ASM_BYTE_OP, (unsigned) MOD);	\     if (flag_verbose_asm)						\       fprintf ((FILE), "\t%s %s",					\ 		       ASM_COMMENT_START, dwarf_typemod_name (MOD));	\     fputc ('\n', (FILE));						\   } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_DWARF_ADDR
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_DWARF_ADDR
parameter_list|(
name|FILE
parameter_list|,
name|LABEL
parameter_list|)
define|\
value|do {	fprintf ((FILE), "\t%s\t", UNALIGNED_INT_ASM_OP);		\ 	assemble_name (FILE, LABEL);					\ 	fprintf (FILE, "\n");						\   } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_DWARF_ADDR_CONST
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_DWARF_ADDR_CONST
parameter_list|(
name|FILE
parameter_list|,
name|RTX
parameter_list|)
define|\
value|do {									\     fprintf ((FILE), "\t%s\t", UNALIGNED_INT_ASM_OP);			\     output_addr_const ((FILE), (RTX));					\     fputc ('\n', (FILE));						\   } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_DWARF_REF
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_DWARF_REF
parameter_list|(
name|FILE
parameter_list|,
name|LABEL
parameter_list|)
define|\
value|do {	fprintf ((FILE), "\t%s\t", UNALIGNED_INT_ASM_OP);		\ 	assemble_name (FILE, LABEL);					\ 	fprintf (FILE, "\n");						\   } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_DWARF_DATA1
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_DWARF_DATA1
parameter_list|(
name|FILE
parameter_list|,
name|VALUE
parameter_list|)
define|\
value|fprintf ((FILE), "\t%s\t0x%x\n", ASM_BYTE_OP, VALUE)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_DWARF_DATA2
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_DWARF_DATA2
parameter_list|(
name|FILE
parameter_list|,
name|VALUE
parameter_list|)
define|\
value|fprintf ((FILE), "\t%s\t0x%x\n", UNALIGNED_SHORT_ASM_OP, (unsigned) VALUE)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_DWARF_DATA4
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_DWARF_DATA4
parameter_list|(
name|FILE
parameter_list|,
name|VALUE
parameter_list|)
define|\
value|fprintf ((FILE), "\t%s\t0x%x\n", UNALIGNED_INT_ASM_OP, (unsigned) VALUE)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_DWARF_DATA8
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_DWARF_DATA8
parameter_list|(
name|FILE
parameter_list|,
name|HIGH_VALUE
parameter_list|,
name|LOW_VALUE
parameter_list|)
define|\
value|do {									\     if (WORDS_BIG_ENDIAN)						\       {									\ 	fprintf ((FILE), "\t%s\t0x%x\n", UNALIGNED_INT_ASM_OP, HIGH_VALUE); \ 	fprintf ((FILE), "\t%s\t0x%x\n", UNALIGNED_INT_ASM_OP, LOW_VALUE);\       }									\     else								\       {									\ 	fprintf ((FILE), "\t%s\t0x%x\n", UNALIGNED_INT_ASM_OP, LOW_VALUE);\ 	fprintf ((FILE), "\t%s\t0x%x\n", UNALIGNED_INT_ASM_OP, HIGH_VALUE); \       }									\   } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_DWARF_STRING
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_DWARF_STRING
parameter_list|(
name|FILE
parameter_list|,
name|P
parameter_list|)
define|\
value|ASM_OUTPUT_ASCII ((FILE), P, strlen (P)+1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/************************ general utility functions **************************/
end_comment

begin_function
specifier|inline
name|char
modifier|*
name|xstrdup
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|inline
name|int
name|is_pseudo_reg
parameter_list|(
name|rtl
parameter_list|)
specifier|register
name|rtx
name|rtl
decl_stmt|;
block|{
return|return
operator|(
operator|(
operator|(
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
operator|==
name|REG
operator|)
operator|&&
operator|(
name|REGNO
argument_list|(
name|rtl
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|)
operator|||
operator|(
operator|(
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
operator|==
name|SUBREG
operator|)
operator|&&
operator|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|inline
name|tree
name|type_main_variant
parameter_list|(
name|type
parameter_list|)
specifier|register
name|tree
name|type
decl_stmt|;
block|{
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* There really should be only one main variant among any group of variants      of a given type (and all of the MAIN_VARIANT values for all members of      the group should point to that one type) but sometimes the C front-end      messes this up for array types, so we work around that bug here.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
while|while
condition|(
name|type
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
condition|)
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if the given type node represents a tagged type.  */
end_comment

begin_function
specifier|inline
name|int
name|is_tagged_type
parameter_list|(
name|type
parameter_list|)
specifier|register
name|tree
name|type
decl_stmt|;
block|{
specifier|register
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
return|return
operator|(
name|code
operator|==
name|RECORD_TYPE
operator|||
name|code
operator|==
name|UNION_TYPE
operator|||
name|code
operator|==
name|QUAL_UNION_TYPE
operator|||
name|code
operator|==
name|ENUMERAL_TYPE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|dwarf_tag_name
parameter_list|(
name|tag
parameter_list|)
specifier|register
name|unsigned
name|tag
decl_stmt|;
block|{
switch|switch
condition|(
name|tag
condition|)
block|{
case|case
name|TAG_padding
case|:
return|return
literal|"TAG_padding"
return|;
case|case
name|TAG_array_type
case|:
return|return
literal|"TAG_array_type"
return|;
case|case
name|TAG_class_type
case|:
return|return
literal|"TAG_class_type"
return|;
case|case
name|TAG_entry_point
case|:
return|return
literal|"TAG_entry_point"
return|;
case|case
name|TAG_enumeration_type
case|:
return|return
literal|"TAG_enumeration_type"
return|;
case|case
name|TAG_formal_parameter
case|:
return|return
literal|"TAG_formal_parameter"
return|;
case|case
name|TAG_global_subroutine
case|:
return|return
literal|"TAG_global_subroutine"
return|;
case|case
name|TAG_global_variable
case|:
return|return
literal|"TAG_global_variable"
return|;
case|case
name|TAG_label
case|:
return|return
literal|"TAG_label"
return|;
case|case
name|TAG_lexical_block
case|:
return|return
literal|"TAG_lexical_block"
return|;
case|case
name|TAG_local_variable
case|:
return|return
literal|"TAG_local_variable"
return|;
case|case
name|TAG_member
case|:
return|return
literal|"TAG_member"
return|;
case|case
name|TAG_pointer_type
case|:
return|return
literal|"TAG_pointer_type"
return|;
case|case
name|TAG_reference_type
case|:
return|return
literal|"TAG_reference_type"
return|;
case|case
name|TAG_compile_unit
case|:
return|return
literal|"TAG_compile_unit"
return|;
case|case
name|TAG_string_type
case|:
return|return
literal|"TAG_string_type"
return|;
case|case
name|TAG_structure_type
case|:
return|return
literal|"TAG_structure_type"
return|;
case|case
name|TAG_subroutine
case|:
return|return
literal|"TAG_subroutine"
return|;
case|case
name|TAG_subroutine_type
case|:
return|return
literal|"TAG_subroutine_type"
return|;
case|case
name|TAG_typedef
case|:
return|return
literal|"TAG_typedef"
return|;
case|case
name|TAG_union_type
case|:
return|return
literal|"TAG_union_type"
return|;
case|case
name|TAG_unspecified_parameters
case|:
return|return
literal|"TAG_unspecified_parameters"
return|;
case|case
name|TAG_variant
case|:
return|return
literal|"TAG_variant"
return|;
case|case
name|TAG_common_block
case|:
return|return
literal|"TAG_common_block"
return|;
case|case
name|TAG_common_inclusion
case|:
return|return
literal|"TAG_common_inclusion"
return|;
case|case
name|TAG_inheritance
case|:
return|return
literal|"TAG_inheritance"
return|;
case|case
name|TAG_inlined_subroutine
case|:
return|return
literal|"TAG_inlined_subroutine"
return|;
case|case
name|TAG_module
case|:
return|return
literal|"TAG_module"
return|;
case|case
name|TAG_ptr_to_member_type
case|:
return|return
literal|"TAG_ptr_to_member_type"
return|;
case|case
name|TAG_set_type
case|:
return|return
literal|"TAG_set_type"
return|;
case|case
name|TAG_subrange_type
case|:
return|return
literal|"TAG_subrange_type"
return|;
case|case
name|TAG_with_stmt
case|:
return|return
literal|"TAG_with_stmt"
return|;
comment|/* GNU extensions.  */
case|case
name|TAG_format_label
case|:
return|return
literal|"TAG_format_label"
return|;
case|case
name|TAG_namelist
case|:
return|return
literal|"TAG_namelist"
return|;
case|case
name|TAG_function_template
case|:
return|return
literal|"TAG_function_template"
return|;
case|case
name|TAG_class_template
case|:
return|return
literal|"TAG_class_template"
return|;
default|default:
return|return
literal|"TAG_<unknown>"
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|dwarf_attr_name
parameter_list|(
name|attr
parameter_list|)
specifier|register
name|unsigned
name|attr
decl_stmt|;
block|{
switch|switch
condition|(
name|attr
condition|)
block|{
case|case
name|AT_sibling
case|:
return|return
literal|"AT_sibling"
return|;
case|case
name|AT_location
case|:
return|return
literal|"AT_location"
return|;
case|case
name|AT_name
case|:
return|return
literal|"AT_name"
return|;
case|case
name|AT_fund_type
case|:
return|return
literal|"AT_fund_type"
return|;
case|case
name|AT_mod_fund_type
case|:
return|return
literal|"AT_mod_fund_type"
return|;
case|case
name|AT_user_def_type
case|:
return|return
literal|"AT_user_def_type"
return|;
case|case
name|AT_mod_u_d_type
case|:
return|return
literal|"AT_mod_u_d_type"
return|;
case|case
name|AT_ordering
case|:
return|return
literal|"AT_ordering"
return|;
case|case
name|AT_subscr_data
case|:
return|return
literal|"AT_subscr_data"
return|;
case|case
name|AT_byte_size
case|:
return|return
literal|"AT_byte_size"
return|;
case|case
name|AT_bit_offset
case|:
return|return
literal|"AT_bit_offset"
return|;
case|case
name|AT_bit_size
case|:
return|return
literal|"AT_bit_size"
return|;
case|case
name|AT_element_list
case|:
return|return
literal|"AT_element_list"
return|;
case|case
name|AT_stmt_list
case|:
return|return
literal|"AT_stmt_list"
return|;
case|case
name|AT_low_pc
case|:
return|return
literal|"AT_low_pc"
return|;
case|case
name|AT_high_pc
case|:
return|return
literal|"AT_high_pc"
return|;
case|case
name|AT_language
case|:
return|return
literal|"AT_language"
return|;
case|case
name|AT_member
case|:
return|return
literal|"AT_member"
return|;
case|case
name|AT_discr
case|:
return|return
literal|"AT_discr"
return|;
case|case
name|AT_discr_value
case|:
return|return
literal|"AT_discr_value"
return|;
case|case
name|AT_string_length
case|:
return|return
literal|"AT_string_length"
return|;
case|case
name|AT_common_reference
case|:
return|return
literal|"AT_common_reference"
return|;
case|case
name|AT_comp_dir
case|:
return|return
literal|"AT_comp_dir"
return|;
case|case
name|AT_const_value_string
case|:
return|return
literal|"AT_const_value_string"
return|;
case|case
name|AT_const_value_data2
case|:
return|return
literal|"AT_const_value_data2"
return|;
case|case
name|AT_const_value_data4
case|:
return|return
literal|"AT_const_value_data4"
return|;
case|case
name|AT_const_value_data8
case|:
return|return
literal|"AT_const_value_data8"
return|;
case|case
name|AT_const_value_block2
case|:
return|return
literal|"AT_const_value_block2"
return|;
case|case
name|AT_const_value_block4
case|:
return|return
literal|"AT_const_value_block4"
return|;
case|case
name|AT_containing_type
case|:
return|return
literal|"AT_containing_type"
return|;
case|case
name|AT_default_value_addr
case|:
return|return
literal|"AT_default_value_addr"
return|;
case|case
name|AT_default_value_data2
case|:
return|return
literal|"AT_default_value_data2"
return|;
case|case
name|AT_default_value_data4
case|:
return|return
literal|"AT_default_value_data4"
return|;
case|case
name|AT_default_value_data8
case|:
return|return
literal|"AT_default_value_data8"
return|;
case|case
name|AT_default_value_string
case|:
return|return
literal|"AT_default_value_string"
return|;
case|case
name|AT_friends
case|:
return|return
literal|"AT_friends"
return|;
case|case
name|AT_inline
case|:
return|return
literal|"AT_inline"
return|;
case|case
name|AT_is_optional
case|:
return|return
literal|"AT_is_optional"
return|;
case|case
name|AT_lower_bound_ref
case|:
return|return
literal|"AT_lower_bound_ref"
return|;
case|case
name|AT_lower_bound_data2
case|:
return|return
literal|"AT_lower_bound_data2"
return|;
case|case
name|AT_lower_bound_data4
case|:
return|return
literal|"AT_lower_bound_data4"
return|;
case|case
name|AT_lower_bound_data8
case|:
return|return
literal|"AT_lower_bound_data8"
return|;
case|case
name|AT_private
case|:
return|return
literal|"AT_private"
return|;
case|case
name|AT_producer
case|:
return|return
literal|"AT_producer"
return|;
case|case
name|AT_program
case|:
return|return
literal|"AT_program"
return|;
case|case
name|AT_protected
case|:
return|return
literal|"AT_protected"
return|;
case|case
name|AT_prototyped
case|:
return|return
literal|"AT_prototyped"
return|;
case|case
name|AT_public
case|:
return|return
literal|"AT_public"
return|;
case|case
name|AT_pure_virtual
case|:
return|return
literal|"AT_pure_virtual"
return|;
case|case
name|AT_return_addr
case|:
return|return
literal|"AT_return_addr"
return|;
case|case
name|AT_abstract_origin
case|:
return|return
literal|"AT_abstract_origin"
return|;
case|case
name|AT_start_scope
case|:
return|return
literal|"AT_start_scope"
return|;
case|case
name|AT_stride_size
case|:
return|return
literal|"AT_stride_size"
return|;
case|case
name|AT_upper_bound_ref
case|:
return|return
literal|"AT_upper_bound_ref"
return|;
case|case
name|AT_upper_bound_data2
case|:
return|return
literal|"AT_upper_bound_data2"
return|;
case|case
name|AT_upper_bound_data4
case|:
return|return
literal|"AT_upper_bound_data4"
return|;
case|case
name|AT_upper_bound_data8
case|:
return|return
literal|"AT_upper_bound_data8"
return|;
case|case
name|AT_virtual
case|:
return|return
literal|"AT_virtual"
return|;
comment|/* GNU extensions */
case|case
name|AT_sf_names
case|:
return|return
literal|"AT_sf_names"
return|;
case|case
name|AT_src_info
case|:
return|return
literal|"AT_src_info"
return|;
case|case
name|AT_mac_info
case|:
return|return
literal|"AT_mac_info"
return|;
case|case
name|AT_src_coords
case|:
return|return
literal|"AT_src_coords"
return|;
case|case
name|AT_body_begin
case|:
return|return
literal|"AT_body_begin"
return|;
case|case
name|AT_body_end
case|:
return|return
literal|"AT_body_end"
return|;
default|default:
return|return
literal|"AT_<unknown>"
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|dwarf_stack_op_name
parameter_list|(
name|op
parameter_list|)
specifier|register
name|unsigned
name|op
decl_stmt|;
block|{
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|OP_REG
case|:
return|return
literal|"OP_REG"
return|;
case|case
name|OP_BASEREG
case|:
return|return
literal|"OP_BASEREG"
return|;
case|case
name|OP_ADDR
case|:
return|return
literal|"OP_ADDR"
return|;
case|case
name|OP_CONST
case|:
return|return
literal|"OP_CONST"
return|;
case|case
name|OP_DEREF2
case|:
return|return
literal|"OP_DEREF2"
return|;
case|case
name|OP_DEREF4
case|:
return|return
literal|"OP_DEREF4"
return|;
case|case
name|OP_ADD
case|:
return|return
literal|"OP_ADD"
return|;
default|default:
return|return
literal|"OP_<unknown>"
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|dwarf_typemod_name
parameter_list|(
name|mod
parameter_list|)
specifier|register
name|unsigned
name|mod
decl_stmt|;
block|{
switch|switch
condition|(
name|mod
condition|)
block|{
case|case
name|MOD_pointer_to
case|:
return|return
literal|"MOD_pointer_to"
return|;
case|case
name|MOD_reference_to
case|:
return|return
literal|"MOD_reference_to"
return|;
case|case
name|MOD_const
case|:
return|return
literal|"MOD_const"
return|;
case|case
name|MOD_volatile
case|:
return|return
literal|"MOD_volatile"
return|;
default|default:
return|return
literal|"MOD_<unknown>"
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|dwarf_fmt_byte_name
parameter_list|(
name|fmt
parameter_list|)
specifier|register
name|unsigned
name|fmt
decl_stmt|;
block|{
switch|switch
condition|(
name|fmt
condition|)
block|{
case|case
name|FMT_FT_C_C
case|:
return|return
literal|"FMT_FT_C_C"
return|;
case|case
name|FMT_FT_C_X
case|:
return|return
literal|"FMT_FT_C_X"
return|;
case|case
name|FMT_FT_X_C
case|:
return|return
literal|"FMT_FT_X_C"
return|;
case|case
name|FMT_FT_X_X
case|:
return|return
literal|"FMT_FT_X_X"
return|;
case|case
name|FMT_UT_C_C
case|:
return|return
literal|"FMT_UT_C_C"
return|;
case|case
name|FMT_UT_C_X
case|:
return|return
literal|"FMT_UT_C_X"
return|;
case|case
name|FMT_UT_X_C
case|:
return|return
literal|"FMT_UT_X_C"
return|;
case|case
name|FMT_UT_X_X
case|:
return|return
literal|"FMT_UT_X_X"
return|;
case|case
name|FMT_ET
case|:
return|return
literal|"FMT_ET"
return|;
default|default:
return|return
literal|"FMT_<unknown>"
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|dwarf_fund_type_name
parameter_list|(
name|ft
parameter_list|)
specifier|register
name|unsigned
name|ft
decl_stmt|;
block|{
switch|switch
condition|(
name|ft
condition|)
block|{
case|case
name|FT_char
case|:
return|return
literal|"FT_char"
return|;
case|case
name|FT_signed_char
case|:
return|return
literal|"FT_signed_char"
return|;
case|case
name|FT_unsigned_char
case|:
return|return
literal|"FT_unsigned_char"
return|;
case|case
name|FT_short
case|:
return|return
literal|"FT_short"
return|;
case|case
name|FT_signed_short
case|:
return|return
literal|"FT_signed_short"
return|;
case|case
name|FT_unsigned_short
case|:
return|return
literal|"FT_unsigned_short"
return|;
case|case
name|FT_integer
case|:
return|return
literal|"FT_integer"
return|;
case|case
name|FT_signed_integer
case|:
return|return
literal|"FT_signed_integer"
return|;
case|case
name|FT_unsigned_integer
case|:
return|return
literal|"FT_unsigned_integer"
return|;
case|case
name|FT_long
case|:
return|return
literal|"FT_long"
return|;
case|case
name|FT_signed_long
case|:
return|return
literal|"FT_signed_long"
return|;
case|case
name|FT_unsigned_long
case|:
return|return
literal|"FT_unsigned_long"
return|;
case|case
name|FT_pointer
case|:
return|return
literal|"FT_pointer"
return|;
case|case
name|FT_float
case|:
return|return
literal|"FT_float"
return|;
case|case
name|FT_dbl_prec_float
case|:
return|return
literal|"FT_dbl_prec_float"
return|;
case|case
name|FT_ext_prec_float
case|:
return|return
literal|"FT_ext_prec_float"
return|;
case|case
name|FT_complex
case|:
return|return
literal|"FT_complex"
return|;
case|case
name|FT_dbl_prec_complex
case|:
return|return
literal|"FT_dbl_prec_complex"
return|;
case|case
name|FT_void
case|:
return|return
literal|"FT_void"
return|;
case|case
name|FT_boolean
case|:
return|return
literal|"FT_boolean"
return|;
case|case
name|FT_ext_prec_complex
case|:
return|return
literal|"FT_ext_prec_complex"
return|;
case|case
name|FT_label
case|:
return|return
literal|"FT_label"
return|;
comment|/* GNU extensions.  */
case|case
name|FT_long_long
case|:
return|return
literal|"FT_long_long"
return|;
case|case
name|FT_signed_long_long
case|:
return|return
literal|"FT_signed_long_long"
return|;
case|case
name|FT_unsigned_long_long
case|:
return|return
literal|"FT_unsigned_long_long"
return|;
case|case
name|FT_int8
case|:
return|return
literal|"FT_int8"
return|;
case|case
name|FT_signed_int8
case|:
return|return
literal|"FT_signed_int8"
return|;
case|case
name|FT_unsigned_int8
case|:
return|return
literal|"FT_unsigned_int8"
return|;
case|case
name|FT_int16
case|:
return|return
literal|"FT_int16"
return|;
case|case
name|FT_signed_int16
case|:
return|return
literal|"FT_signed_int16"
return|;
case|case
name|FT_unsigned_int16
case|:
return|return
literal|"FT_unsigned_int16"
return|;
case|case
name|FT_int32
case|:
return|return
literal|"FT_int32"
return|;
case|case
name|FT_signed_int32
case|:
return|return
literal|"FT_signed_int32"
return|;
case|case
name|FT_unsigned_int32
case|:
return|return
literal|"FT_unsigned_int32"
return|;
case|case
name|FT_int64
case|:
return|return
literal|"FT_int64"
return|;
case|case
name|FT_signed_int64
case|:
return|return
literal|"FT_signed_int64"
return|;
case|case
name|FT_unsigned_int64
case|:
return|return
literal|"FT_signed_int64"
return|;
case|case
name|FT_real32
case|:
return|return
literal|"FT_real32"
return|;
case|case
name|FT_real64
case|:
return|return
literal|"FT_real64"
return|;
case|case
name|FT_real96
case|:
return|return
literal|"FT_real96"
return|;
case|case
name|FT_real128
case|:
return|return
literal|"FT_real128"
return|;
default|default:
return|return
literal|"FT_<unknown>"
return|;
block|}
block|}
end_function

begin_comment
comment|/* Determine the "ultimate origin" of a decl.  The decl may be an    inlined instance of an inlined instance of a decl which is local    to an inline function, so we have to trace all of the way back    through the origin chain to find out what sort of node actually    served as the original seed for the given block.  */
end_comment

begin_function
specifier|static
name|tree
name|decl_ultimate_origin
parameter_list|(
name|decl
parameter_list|)
specifier|register
name|tree
name|decl
decl_stmt|;
block|{
specifier|register
name|tree
name|immediate_origin
init|=
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|immediate_origin
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
else|else
block|{
specifier|register
name|tree
name|ret_val
decl_stmt|;
specifier|register
name|tree
name|lookahead
init|=
name|immediate_origin
decl_stmt|;
do|do
block|{
name|ret_val
operator|=
name|lookahead
expr_stmt|;
name|lookahead
operator|=
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|ret_val
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|lookahead
operator|!=
name|NULL
operator|&&
name|lookahead
operator|!=
name|ret_val
condition|)
do|;
return|return
name|ret_val
return|;
block|}
block|}
end_function

begin_comment
comment|/* Determine the "ultimate origin" of a block.  The block may be an    inlined instance of an inlined instance of a block which is local    to an inline function, so we have to trace all of the way back    through the origin chain to find out what sort of node actually    served as the original seed for the given block.  */
end_comment

begin_function
specifier|static
name|tree
name|block_ultimate_origin
parameter_list|(
name|block
parameter_list|)
specifier|register
name|tree
name|block
decl_stmt|;
block|{
specifier|register
name|tree
name|immediate_origin
init|=
name|BLOCK_ABSTRACT_ORIGIN
argument_list|(
name|block
argument_list|)
decl_stmt|;
if|if
condition|(
name|immediate_origin
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
else|else
block|{
specifier|register
name|tree
name|ret_val
decl_stmt|;
specifier|register
name|tree
name|lookahead
init|=
name|immediate_origin
decl_stmt|;
do|do
block|{
name|ret_val
operator|=
name|lookahead
expr_stmt|;
name|lookahead
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|ret_val
argument_list|)
operator|==
name|BLOCK
operator|)
condition|?
name|BLOCK_ABSTRACT_ORIGIN
argument_list|(
name|ret_val
argument_list|)
else|:
name|NULL
expr_stmt|;
block|}
do|while
condition|(
name|lookahead
operator|!=
name|NULL
operator|&&
name|lookahead
operator|!=
name|ret_val
condition|)
do|;
return|return
name|ret_val
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|output_unsigned_leb128
parameter_list|(
name|value
parameter_list|)
specifier|register
name|unsigned
name|long
name|value
decl_stmt|;
block|{
specifier|register
name|unsigned
name|long
name|orig_value
init|=
name|value
decl_stmt|;
do|do
block|{
specifier|register
name|unsigned
name|byte
init|=
operator|(
name|value
operator|&
literal|0x7f
operator|)
decl_stmt|;
name|value
operator|>>=
literal|7
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
comment|/* more bytes to follow */
name|byte
operator||=
literal|0x80
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s\t0x%x"
argument_list|,
name|ASM_BYTE_OP
argument_list|,
operator|(
name|unsigned
operator|)
name|byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_verbose_asm
operator|&&
name|value
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s ULEB128 number - value = %u"
argument_list|,
name|ASM_COMMENT_START
argument_list|,
name|orig_value
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|value
operator|!=
literal|0
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_signed_leb128
parameter_list|(
name|value
parameter_list|)
specifier|register
name|long
name|value
decl_stmt|;
block|{
specifier|register
name|long
name|orig_value
init|=
name|value
decl_stmt|;
specifier|register
name|int
name|negative
init|=
operator|(
name|value
operator|<
literal|0
operator|)
decl_stmt|;
specifier|register
name|int
name|more
decl_stmt|;
do|do
block|{
specifier|register
name|unsigned
name|byte
init|=
operator|(
name|value
operator|&
literal|0x7f
operator|)
decl_stmt|;
name|value
operator|>>=
literal|7
expr_stmt|;
if|if
condition|(
name|negative
condition|)
name|value
operator||=
literal|0xfe000000
expr_stmt|;
comment|/* manually sign extend */
if|if
condition|(
operator|(
operator|(
name|value
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|byte
operator|&
literal|0x40
operator|)
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
operator|(
name|value
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
operator|(
name|byte
operator|&
literal|0x40
operator|)
operator|==
literal|1
operator|)
operator|)
condition|)
name|more
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|byte
operator||=
literal|0x80
expr_stmt|;
name|more
operator|=
literal|1
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s\t0x%x"
argument_list|,
name|ASM_BYTE_OP
argument_list|,
operator|(
name|unsigned
operator|)
name|byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_verbose_asm
operator|&&
name|more
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s SLEB128 number - value = %d"
argument_list|,
name|ASM_COMMENT_START
argument_list|,
name|orig_value
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|more
condition|)
do|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/**************** utility functions for attribute functions ******************/
end_comment

begin_comment
comment|/* Given a pointer to a BLOCK node return non-zero if (and only if) the    node in question represents the outermost pair of curly braces (i.e.    the "body block") of a function or method.     For any BLOCK node representing a "body block" of a function or method,    the BLOCK_SUPERCONTEXT of the node will point to another BLOCK node    which represents the outermost (function) scope for the function or    method (i.e. the one which includes the formal parameters).  The    BLOCK_SUPERCONTEXT of *that* node in turn will point to the relevant    FUNCTION_DECL node. */
end_comment

begin_function
specifier|inline
name|int
name|is_body_block
parameter_list|(
name|stmt
parameter_list|)
specifier|register
name|tree
name|stmt
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|BLOCK
condition|)
block|{
specifier|register
name|tree
name|parent
init|=
name|BLOCK_SUPERCONTEXT
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parent
argument_list|)
operator|==
name|BLOCK
condition|)
block|{
specifier|register
name|tree
name|grandparent
init|=
name|BLOCK_SUPERCONTEXT
argument_list|(
name|parent
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|grandparent
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Given a pointer to a tree node for some type, return a Dwarf fundamental    type code for the given type.     This routine must only be called for GCC type nodes that correspond to    Dwarf fundamental types.     The current Dwarf draft specification calls for Dwarf fundamental types    to accurately reflect the fact that a given type was either a "plain"    integral type or an explicitly "signed" integral type.  Unfortunately,    we can't always do this, because GCC may already have thrown away the    information about the precise way in which the type was originally    specified, as in:  	typedef signed int my_type;  	struct s { my_type f; };     Since we may be stuck here without enought information to do exactly    what is called for in the Dwarf draft specification, we do the best    that we can under the circumstances and always use the "plain" integral    fundamental type codes for int, short, and long types.  That's probably    good enough.  The additional accuracy called for in the current DWARF    draft specification is probably never even useful in practice.  */
end_comment

begin_function
specifier|static
name|int
name|fundamental_type_code
parameter_list|(
name|type
parameter_list|)
specifier|register
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|ERROR_MARK
case|:
return|return
name|FT_void
return|;
case|case
name|VOID_TYPE
case|:
return|return
name|FT_void
return|;
case|case
name|INTEGER_TYPE
case|:
comment|/* Carefully distinguish all the standard types of C, 	   without messing up if the language is not C. 	   Note that we check only for the names that contain spaces; 	   other names might occur by coincidence in other languages.  */
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
name|char
modifier|*
name|name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"unsigned char"
argument_list|)
condition|)
return|return
name|FT_unsigned_char
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"signed char"
argument_list|)
condition|)
return|return
name|FT_signed_char
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"unsigned int"
argument_list|)
condition|)
return|return
name|FT_unsigned_integer
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"short int"
argument_list|)
condition|)
return|return
name|FT_short
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"short unsigned int"
argument_list|)
condition|)
return|return
name|FT_unsigned_short
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"long int"
argument_list|)
condition|)
return|return
name|FT_long
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"long unsigned int"
argument_list|)
condition|)
return|return
name|FT_unsigned_long
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"long long int"
argument_list|)
condition|)
return|return
name|FT_long_long
return|;
comment|/* Not grok'ed by svr4 SDB */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"long long unsigned int"
argument_list|)
condition|)
return|return
name|FT_unsigned_long_long
return|;
comment|/* Not grok'ed by svr4 SDB */
block|}
comment|/* Most integer types will be sorted out above, however, for the 	   sake of special `array index' integer types, the following code 	   is also provided.  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|INT_TYPE_SIZE
condition|)
return|return
operator|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|?
name|FT_unsigned_integer
else|:
name|FT_integer
operator|)
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|LONG_TYPE_SIZE
condition|)
return|return
operator|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|?
name|FT_unsigned_long
else|:
name|FT_long
operator|)
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|LONG_LONG_TYPE_SIZE
condition|)
return|return
operator|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|?
name|FT_unsigned_long_long
else|:
name|FT_long_long
operator|)
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|SHORT_TYPE_SIZE
condition|)
return|return
operator|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|?
name|FT_unsigned_short
else|:
name|FT_short
operator|)
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|CHAR_TYPE_SIZE
condition|)
return|return
operator|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|?
name|FT_unsigned_char
else|:
name|FT_char
operator|)
return|;
name|abort
argument_list|()
expr_stmt|;
case|case
name|REAL_TYPE
case|:
comment|/* Carefully distinguish all the standard types of C, 	   without messing up if the language is not C.  */
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
name|char
modifier|*
name|name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Note that here we can run afowl of a serious bug in "classic" 	       svr4 SDB debuggers.  They don't seem to understand the 	       FT_ext_prec_float type (even though they should).  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"long double"
argument_list|)
condition|)
return|return
name|FT_ext_prec_float
return|;
block|}
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|DOUBLE_TYPE_SIZE
condition|)
return|return
name|FT_dbl_prec_float
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|FLOAT_TYPE_SIZE
condition|)
return|return
name|FT_float
return|;
comment|/* Note that here we can run afowl of a serious bug in "classic" 	   svr4 SDB debuggers.  They don't seem to understand the 	   FT_ext_prec_float type (even though they should).  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|LONG_DOUBLE_TYPE_SIZE
condition|)
return|return
name|FT_ext_prec_float
return|;
name|abort
argument_list|()
expr_stmt|;
case|case
name|COMPLEX_TYPE
case|:
return|return
name|FT_complex
return|;
comment|/* GNU FORTRAN COMPLEX type.  */
case|case
name|CHAR_TYPE
case|:
return|return
name|FT_char
return|;
comment|/* GNU Pascal CHAR type.  Not used in C.  */
case|case
name|BOOLEAN_TYPE
case|:
return|return
name|FT_boolean
return|;
comment|/* GNU FORTRAN BOOLEAN type.  */
default|default:
name|abort
argument_list|()
expr_stmt|;
comment|/* No other TREE_CODEs are Dwarf fundamental types.  */
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a pointer to an arbitrary ..._TYPE tree node, return a pointer to    the Dwarf "root" type for the given input type.  The Dwarf "root" type    of a given type is generally the same as the given type, except that if    the	given type is a pointer or reference type, then the root type of    the given type is the root type of the "basis" type for the pointer or    reference type.  (This definition of the "root" type is recursive.)    Also, the root type of a `const' qualified type or a `volatile'    qualified type is the root type of the given type without the    qualifiers.  */
end_comment

begin_function
specifier|static
name|tree
name|root_type
parameter_list|(
name|type
parameter_list|)
specifier|register
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|ERROR_MARK
case|:
return|return
name|error_mark_node
return|;
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
return|return
name|type_main_variant
argument_list|(
name|root_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
return|;
default|default:
return|return
name|type_main_variant
argument_list|(
name|type
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Given a pointer to an arbitrary ..._TYPE tree node, write out a sequence    of zero or more Dwarf "type-modifier" bytes applicable to the type.	*/
end_comment

begin_function
specifier|static
name|void
name|write_modifier_bytes
parameter_list|(
name|type
parameter_list|,
name|decl_const
parameter_list|,
name|decl_volatile
parameter_list|)
specifier|register
name|tree
name|type
decl_stmt|;
specifier|register
name|int
name|decl_const
decl_stmt|;
specifier|register
name|int
name|decl_volatile
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return;
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|type
argument_list|)
operator|||
name|decl_const
condition|)
name|ASM_OUTPUT_DWARF_TYPE_MODIFIER
argument_list|(
name|asm_out_file
argument_list|,
name|MOD_const
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_VOLATILE
argument_list|(
name|type
argument_list|)
operator|||
name|decl_volatile
condition|)
name|ASM_OUTPUT_DWARF_TYPE_MODIFIER
argument_list|(
name|asm_out_file
argument_list|,
name|MOD_volatile
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|POINTER_TYPE
case|:
name|ASM_OUTPUT_DWARF_TYPE_MODIFIER
argument_list|(
name|asm_out_file
argument_list|,
name|MOD_pointer_to
argument_list|)
expr_stmt|;
name|write_modifier_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|REFERENCE_TYPE
case|:
name|ASM_OUTPUT_DWARF_TYPE_MODIFIER
argument_list|(
name|asm_out_file
argument_list|,
name|MOD_reference_to
argument_list|)
expr_stmt|;
name|write_modifier_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|ERROR_MARK
case|:
default|default:
return|return;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a pointer to an arbitrary ..._TYPE tree node, return non-zero if the    given input type is a Dwarf "fundamental" type.  Otherwise return zero.  */
end_comment

begin_function
specifier|inline
name|int
name|type_is_fundamental
parameter_list|(
name|type
parameter_list|)
specifier|register
name|tree
name|type
decl_stmt|;
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|ERROR_MARK
case|:
case|case
name|VOID_TYPE
case|:
case|case
name|INTEGER_TYPE
case|:
case|case
name|REAL_TYPE
case|:
case|case
name|COMPLEX_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
case|case
name|CHAR_TYPE
case|:
return|return
literal|1
return|;
case|case
name|SET_TYPE
case|:
case|case
name|ARRAY_TYPE
case|:
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|QUAL_UNION_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|FUNCTION_TYPE
case|:
case|case
name|METHOD_TYPE
case|:
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
case|case
name|FILE_TYPE
case|:
case|case
name|OFFSET_TYPE
case|:
case|case
name|LANG_TYPE
case|:
return|return
literal|0
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Given a pointer to some ..._DECL tree node, generate an assembly language    equate directive which will associate a symbolic name with the current DIE.     The name used is an artificial label generated from the DECL_UID number    associated with the given decl node.  The name it gets equated to is the    symbolic label that we (previously) output at the start of the DIE that    we are currently generating.     Calling this function while generating some "decl related" form of DIE    makes it possible to later refer to the DIE which represents the given    decl simply by re-generating the symbolic name from the ..._DECL node's    UID number.	*/
end_comment

begin_function
specifier|static
name|void
name|equate_decl_number_to_die_number
parameter_list|(
name|decl
parameter_list|)
specifier|register
name|tree
name|decl
decl_stmt|;
block|{
comment|/* In the case where we are generating a DIE for some ..._DECL node      which represents either some inline function declaration or some      entity declared within an inline function declaration/definition,      setup a symbolic name for the current DIE so that we have a name      for this DIE that we can easily refer to later on within      AT_abstract_origin attributes.  */
name|char
name|decl_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|char
name|die_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|decl_label
argument_list|,
name|DECL_NAME_FMT
argument_list|,
name|DECL_UID
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|die_label
argument_list|,
name|DIE_BEGIN_LABEL_FMT
argument_list|,
name|current_dienum
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DEF
argument_list|(
name|asm_out_file
argument_list|,
name|decl_label
argument_list|,
name|die_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a pointer to some ..._TYPE tree node, generate an assembly language    equate directive which will associate a symbolic name with the current DIE.     The name used is an artificial label generated from the TYPE_UID number    associated with the given type node.  The name it gets equated to is the    symbolic label that we (previously) output at the start of the DIE that    we are currently generating.     Calling this function while generating some "type related" form of DIE    makes it easy to later refer to the DIE which represents the given type    simply by re-generating the alternative name from the ..._TYPE node's    UID number.	*/
end_comment

begin_function
specifier|inline
name|void
name|equate_type_number_to_die_number
parameter_list|(
name|type
parameter_list|)
specifier|register
name|tree
name|type
decl_stmt|;
block|{
name|char
name|type_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|char
name|die_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
comment|/* We are generating a DIE to represent the main variant of this type      (i.e the type without any const or volatile qualifiers) so in order      to get the equate to come out right, we need to get the main variant      itself here.  */
name|type
operator|=
name|type_main_variant
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|type_label
argument_list|,
name|TYPE_NAME_FMT
argument_list|,
name|TYPE_UID
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|die_label
argument_list|,
name|DIE_BEGIN_LABEL_FMT
argument_list|,
name|current_dienum
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DEF
argument_list|(
name|asm_out_file
argument_list|,
name|type_label
argument_list|,
name|die_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_reg_number
parameter_list|(
name|rtl
parameter_list|)
specifier|register
name|rtx
name|rtl
decl_stmt|;
block|{
specifier|register
name|unsigned
name|regno
init|=
name|REGNO
argument_list|(
name|rtl
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|warning_with_decl
argument_list|(
name|dwarf_last_decl
argument_list|,
literal|"internal regno botch: regno = %d\n"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|regno
operator|=
literal|0
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s\t0x%x"
argument_list|,
name|UNALIGNED_INT_ASM_OP
argument_list|,
name|DBX_REGISTER_NUMBER
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_verbose_asm
condition|)
block|{
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s "
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|PRINT_REG
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The following routine is a nice and simple transducer.  It converts the    RTL for a variable or parameter (resident in memory) into an equivalent    Dwarf representation of a mechanism for getting the address of that same    variable onto the top of a hypothetical "address evaluation" stack.     When creating memory location descriptors, we are effectively trans-    forming the RTL for a memory-resident object into its Dwarf postfix    expression equivalent.  This routine just recursively descends an    RTL tree, turning it into Dwarf postfix code as it goes.  */
end_comment

begin_function
specifier|static
name|void
name|output_mem_loc_descriptor
parameter_list|(
name|rtl
parameter_list|)
specifier|register
name|rtx
name|rtl
decl_stmt|;
block|{
comment|/* Note that for a dynamically sized array, the location we will      generate a description of here will be the lowest numbered location      which is actually within the array.  That's *not* necessarily the      same as the zeroth element of the array.  */
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
condition|)
block|{
case|case
name|SUBREG
case|:
comment|/* The case of a subreg may arise when we have a local (register) 	   variable or a formal (register) parameter which doesn't quite 	   fill up an entire register.	For now, just assume that it is 	   legitimate to make the Dwarf info refer to the whole register 	   which contains the given subreg.  */
name|rtl
operator|=
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Drop thru.  */
case|case
name|REG
case|:
comment|/* Whenever a register number forms a part of the description of 	   the method for calculating the (dynamic) address of a memory 	   resident object, DWARF rules require the register number to 	   be referred to as a "base register".  This distinction is not 	   based in any way upon what category of register the hardware 	   believes the given register belongs to.  This is strictly 	   DWARF terminology we're dealing with here.  	   Note that in cases where the location of a memory-resident data 	   object could be expressed as:  		    OP_ADD (OP_BASEREG (basereg), OP_CONST (0))  	   the actual DWARF location descriptor that we generate may just 	   be OP_BASEREG (basereg).  This may look deceptively like the 	   object in question was allocated to a register (rather than 	   in memory) so DWARF consumers need to be aware of the subtle 	   distinction between OP_REG and OP_BASEREG.  */
name|ASM_OUTPUT_DWARF_STACK_OP
argument_list|(
name|asm_out_file
argument_list|,
name|OP_BASEREG
argument_list|)
expr_stmt|;
name|output_reg_number
argument_list|(
name|rtl
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEM
case|:
name|output_mem_loc_descriptor
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_STACK_OP
argument_list|(
name|asm_out_file
argument_list|,
name|OP_DEREF4
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST
case|:
case|case
name|SYMBOL_REF
case|:
name|ASM_OUTPUT_DWARF_STACK_OP
argument_list|(
name|asm_out_file
argument_list|,
name|OP_ADDR
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_ADDR_CONST
argument_list|(
name|asm_out_file
argument_list|,
name|rtl
argument_list|)
expr_stmt|;
break|break;
case|case
name|PLUS
case|:
name|output_mem_loc_descriptor
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|output_mem_loc_descriptor
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_STACK_OP
argument_list|(
name|asm_out_file
argument_list|,
name|OP_ADD
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_INT
case|:
name|ASM_OUTPUT_DWARF_STACK_OP
argument_list|(
name|asm_out_file
argument_list|,
name|OP_CONST
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DATA4
argument_list|(
name|asm_out_file
argument_list|,
name|INTVAL
argument_list|(
name|rtl
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output a proper Dwarf location descriptor for a variable or parameter    which is either allocated in a register or in a memory location.  For    a register, we just generate an OP_REG and the register number.  For a    memory location we provide a Dwarf postfix expression describing how to    generate the (dynamic) address of the object onto the address stack.  */
end_comment

begin_function
specifier|static
name|void
name|output_loc_descriptor
parameter_list|(
name|rtl
parameter_list|)
specifier|register
name|rtx
name|rtl
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
condition|)
block|{
case|case
name|SUBREG
case|:
comment|/* The case of a subreg may arise when we have a local (register) 	   variable or a formal (register) parameter which doesn't quite 	   fill up an entire register.	For now, just assume that it is 	   legitimate to make the Dwarf info refer to the whole register 	   which contains the given subreg.  */
name|rtl
operator|=
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Drop thru.  */
case|case
name|REG
case|:
name|ASM_OUTPUT_DWARF_STACK_OP
argument_list|(
name|asm_out_file
argument_list|,
name|OP_REG
argument_list|)
expr_stmt|;
name|output_reg_number
argument_list|(
name|rtl
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEM
case|:
name|output_mem_loc_descriptor
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
comment|/* Should never happen */
block|}
block|}
end_function

begin_comment
comment|/* Given a tree node describing an array bound (either lower or upper)    output a representation for that bound.  */
end_comment

begin_function
specifier|static
name|void
name|output_bound_representation
parameter_list|(
name|bound
parameter_list|,
name|dim_num
parameter_list|,
name|u_or_l
parameter_list|)
specifier|register
name|tree
name|bound
decl_stmt|;
specifier|register
name|unsigned
name|dim_num
decl_stmt|;
comment|/* For multi-dimensional arrays.  */
specifier|register
name|char
name|u_or_l
decl_stmt|;
comment|/* Designates upper or lower bound.  */
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|bound
argument_list|)
condition|)
block|{
case|case
name|ERROR_MARK
case|:
return|return;
comment|/* All fixed-bounds are represented by INTEGER_CST nodes.	 */
case|case
name|INTEGER_CST
case|:
name|ASM_OUTPUT_DWARF_DATA4
argument_list|(
name|asm_out_file
argument_list|,
operator|(
name|unsigned
operator|)
name|TREE_INT_CST_LOW
argument_list|(
name|bound
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|/* Dynamic bounds may be represented by NOP_EXPR nodes containing 	 SAVE_EXPR nodes.  */
case|case
name|NOP_EXPR
case|:
name|bound
operator|=
name|TREE_OPERAND
argument_list|(
name|bound
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* ... fall thru... */
case|case
name|SAVE_EXPR
case|:
block|{
name|char
name|begin_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|char
name|end_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|begin_label
argument_list|,
name|BOUND_BEGIN_LABEL_FMT
argument_list|,
name|current_dienum
argument_list|,
name|dim_num
argument_list|,
name|u_or_l
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|end_label
argument_list|,
name|BOUND_END_LABEL_FMT
argument_list|,
name|current_dienum
argument_list|,
name|dim_num
argument_list|,
name|u_or_l
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DELTA2
argument_list|(
name|asm_out_file
argument_list|,
name|end_label
argument_list|,
name|begin_label
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|begin_label
argument_list|)
expr_stmt|;
comment|/* If we are working on a bound for a dynamic dimension in C, 	     the dynamic dimension in question had better have a static 	     (zero) lower bound and a dynamic *upper* bound.  */
if|if
condition|(
name|u_or_l
operator|!=
literal|'u'
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If optimization is turned on, the SAVE_EXPRs that describe 	     how to access the upper bound values are essentially bogus. 	     They only describe (at best) how to get at these values at 	     the points in the generated code right after they have just 	     been computed.  Worse yet, in the typical case, the upper 	     bound values will not even *be* computed in the optimized 	     code, so these SAVE_EXPRs are entirely bogus.  	     In order to compensate for this fact, we check here to see 	     if optimization is enabled, and if so, we effectively create 	     an empty location description for the (unknown and unknowable) 	     upper bound.  	     This should not cause too much trouble for existing (stupid?) 	     debuggers because they have to deal with empty upper bounds 	     location descriptions anyway in order to be able to deal with 	     incomplete array types.  	     Of course an intelligent debugger (GDB?) should be able to 	     comprehend that a missing upper bound specification in a 	     array type used for a storage class `auto' local array variable 	     indicates that the upper bound is both unknown (at compile- 	     time) and unknowable (at run-time) due to optimization. 	  */
if|if
condition|(
operator|!
name|optimize
condition|)
name|output_loc_descriptor
argument_list|(
name|eliminate_regs
argument_list|(
name|SAVE_EXPR_RTL
argument_list|(
name|bound
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|end_label
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Recursive function to output a sequence of value/name pairs for    enumeration constants in reversed order.  This is called from    enumeration_type_die.  */
end_comment

begin_function
specifier|static
name|void
name|output_enumeral_list
parameter_list|(
name|link
parameter_list|)
specifier|register
name|tree
name|link
decl_stmt|;
block|{
if|if
condition|(
name|link
condition|)
block|{
name|output_enumeral_list
argument_list|(
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DATA4
argument_list|(
name|asm_out_file
argument_list|,
operator|(
name|unsigned
operator|)
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_STRING
argument_list|(
name|asm_out_file
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Given an unsigned value, round it up to the lowest multiple of `boundary'    which is not less than the value itself.  */
end_comment

begin_function
specifier|inline
name|unsigned
name|ceiling
parameter_list|(
name|value
parameter_list|,
name|boundary
parameter_list|)
specifier|register
name|unsigned
name|value
decl_stmt|;
specifier|register
name|unsigned
name|boundary
decl_stmt|;
block|{
return|return
operator|(
operator|(
operator|(
name|value
operator|+
name|boundary
operator|-
literal|1
operator|)
operator|/
name|boundary
operator|)
operator|*
name|boundary
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Given a pointer to what is assumed to be a FIELD_DECL node, return a    pointer to the declared type for the relevant field variable, or return    `integer_type_node' if the given node turns out to be an ERROR_MARK node.  */
end_comment

begin_function
specifier|inline
name|tree
name|field_type
parameter_list|(
name|decl
parameter_list|)
specifier|register
name|tree
name|decl
decl_stmt|;
block|{
specifier|register
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|integer_type_node
return|;
name|type
operator|=
name|DECL_BIT_FIELD_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Given a pointer to a tree node, assumed to be some kind of a ..._TYPE    node, return the alignment in bits for the type, or else return    BITS_PER_WORD if the node actually turns out to be an ERROR_MARK node.  */
end_comment

begin_function
specifier|inline
name|unsigned
name|simple_type_align_in_bits
parameter_list|(
name|type
parameter_list|)
specifier|register
name|tree
name|type
decl_stmt|;
block|{
return|return
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|ERROR_MARK
operator|)
condition|?
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
else|:
name|BITS_PER_WORD
return|;
block|}
end_function

begin_comment
comment|/* Given a pointer to a tree node, assumed to be some kind of a ..._TYPE    node, return the size in bits for the type if it is a constant, or    else return the alignment for the type if the type's size is not    constant, or else return BITS_PER_WORD if the type actually turns out    to be an ERROR_MARK node.  */
end_comment

begin_function
specifier|inline
name|unsigned
name|simple_type_size_in_bits
parameter_list|(
name|type
parameter_list|)
specifier|register
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|BITS_PER_WORD
return|;
else|else
block|{
specifier|register
name|tree
name|type_size_tree
init|=
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type_size_tree
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
return|;
return|return
operator|(
name|unsigned
operator|)
name|TREE_INT_CST_LOW
argument_list|(
name|type_size_tree
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Given a pointer to what is assumed to be a FIELD_DECL node, compute and    return the byte offset of the lowest addressed byte of the "containing    object" for the given FIELD_DECL, or return 0 if we are unable to deter-    mine what that offset is, either because the argument turns out to be a    pointer to an ERROR_MARK node, or because the offset is actually variable.    (We can't handle the latter case just yet.)  */
end_comment

begin_function
specifier|static
name|unsigned
name|field_byte_offset
parameter_list|(
name|decl
parameter_list|)
specifier|register
name|tree
name|decl
decl_stmt|;
block|{
specifier|register
name|unsigned
name|type_align_in_bytes
decl_stmt|;
specifier|register
name|unsigned
name|type_align_in_bits
decl_stmt|;
specifier|register
name|unsigned
name|type_size_in_bits
decl_stmt|;
specifier|register
name|unsigned
name|object_offset_in_align_units
decl_stmt|;
specifier|register
name|unsigned
name|object_offset_in_bits
decl_stmt|;
specifier|register
name|unsigned
name|object_offset_in_bytes
decl_stmt|;
specifier|register
name|tree
name|type
decl_stmt|;
specifier|register
name|tree
name|bitpos_tree
decl_stmt|;
specifier|register
name|tree
name|field_size_tree
decl_stmt|;
specifier|register
name|unsigned
name|bitpos_int
decl_stmt|;
specifier|register
name|unsigned
name|deepest_bitpos
decl_stmt|;
specifier|register
name|unsigned
name|field_size_in_bits
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|type
operator|=
name|field_type
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|bitpos_tree
operator|=
name|DECL_FIELD_BITPOS
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|field_size_tree
operator|=
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* We cannot yet cope with fields whose positions or sizes are variable,      so for now, when we see such things, we simply return 0.  Someday,      we may be able to handle such cases, but it will be damn difficult.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|bitpos_tree
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
literal|0
return|;
name|bitpos_int
operator|=
operator|(
name|unsigned
operator|)
name|TREE_INT_CST_LOW
argument_list|(
name|bitpos_tree
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field_size_tree
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
literal|0
return|;
name|field_size_in_bits
operator|=
operator|(
name|unsigned
operator|)
name|TREE_INT_CST_LOW
argument_list|(
name|field_size_tree
argument_list|)
expr_stmt|;
name|type_size_in_bits
operator|=
name|simple_type_size_in_bits
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|type_align_in_bits
operator|=
name|simple_type_align_in_bits
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|type_align_in_bytes
operator|=
name|type_align_in_bits
operator|/
name|BITS_PER_UNIT
expr_stmt|;
comment|/* Note that the GCC front-end doesn't make any attempt to keep track      of the starting bit offset (relative to the start of the containing      structure type) of the hypothetical "containing object" for a bit-      field.  Thus, when computing the byte offset value for the start of      the "containing object" of a bit-field, we must deduce this infor-      mation on our own.       This can be rather tricky to do in some cases.  For example, handling      the following structure type definition when compiling for an i386/i486      target (which only aligns long long's to 32-bit boundaries) can be very      tricky:  		struct S { 			int		field1; 			long long	field2:31; 		};       Fortunately, there is a simple rule-of-thumb which can be used in such      cases.  When compiling for an i386/i486, GCC will allocate 8 bytes for      the structure shown above.  It decides to do this based upon one simple      rule for bit-field allocation.  Quite simply, GCC allocates each "con-      taining object" for each bit-field at the first (i.e. lowest addressed)      legitimate alignment boundary (based upon the required minimum alignment      for the declared type of the field) which it can possibly use, subject      to the condition that there is still enough available space remaining      in the containing object (when allocated at the selected point) to      fully accommodate all of the bits of the bit-field itself.       This simple rule makes it obvious why GCC allocates 8 bytes for each      object of the structure type shown above.  When looking for a place to      allocate the "containing object" for `field2', the compiler simply tries      to allocate a 64-bit "containing object" at each successive 32-bit      boundary (starting at zero) until it finds a place to allocate that 64-      bit field such that at least 31 contiguous (and previously unallocated)      bits remain within that selected 64 bit field.  (As it turns out, for      the example above, the compiler finds that it is OK to allocate the      "containing object" 64-bit field at bit-offset zero within the      structure type.)       Here we attempt to work backwards from the limited set of facts we're      given, and we try to deduce from those facts, where GCC must have      believed that the containing object started (within the structure type).       The value we deduce is then used (by the callers of this routine) to      generate AT_location and AT_bit_offset attributes for fields (both      bit-fields and, in the case of AT_location, regular fields as well).   */
comment|/* Figure out the bit-distance from the start of the structure to the      "deepest" bit of the bit-field.  */
name|deepest_bitpos
operator|=
name|bitpos_int
operator|+
name|field_size_in_bits
expr_stmt|;
comment|/* This is the tricky part.  Use some fancy footwork to deduce where the      lowest addressed bit of the containing object must be.  */
name|object_offset_in_bits
operator|=
name|ceiling
argument_list|(
name|deepest_bitpos
argument_list|,
name|type_align_in_bits
argument_list|)
operator|-
name|type_size_in_bits
expr_stmt|;
comment|/* Compute the offset of the containing object in "alignment units".  */
name|object_offset_in_align_units
operator|=
name|object_offset_in_bits
operator|/
name|type_align_in_bits
expr_stmt|;
comment|/* Compute the offset of the containing object in bytes.  */
name|object_offset_in_bytes
operator|=
name|object_offset_in_align_units
operator|*
name|type_align_in_bytes
expr_stmt|;
return|return
name|object_offset_in_bytes
return|;
block|}
end_function

begin_comment
comment|/****************************** attributes *********************************/
end_comment

begin_comment
comment|/* The following routines are responsible for writing out the various types    of Dwarf attributes (and any following data bytes associated with them).    These routines are listed in order based on the numerical codes of their    associated attributes.  */
end_comment

begin_comment
comment|/* Generate an AT_sibling attribute.  */
end_comment

begin_function
specifier|inline
name|void
name|sibling_attribute
parameter_list|()
block|{
name|char
name|label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|ASM_OUTPUT_DWARF_ATTRIBUTE
argument_list|(
name|asm_out_file
argument_list|,
name|AT_sibling
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|label
argument_list|,
name|DIE_BEGIN_LABEL_FMT
argument_list|,
name|NEXT_DIE_NUM
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_REF
argument_list|(
name|asm_out_file
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output the form of location attributes suitable for whole variables and    whole parameters.  Note that the location attributes for struct fields    are generated by the routine `data_member_location_attribute' below.  */
end_comment

begin_function
specifier|static
name|void
name|location_attribute
parameter_list|(
name|rtl
parameter_list|)
specifier|register
name|rtx
name|rtl
decl_stmt|;
block|{
name|char
name|begin_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|char
name|end_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|ASM_OUTPUT_DWARF_ATTRIBUTE
argument_list|(
name|asm_out_file
argument_list|,
name|AT_location
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|begin_label
argument_list|,
name|LOC_BEGIN_LABEL_FMT
argument_list|,
name|current_dienum
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|end_label
argument_list|,
name|LOC_END_LABEL_FMT
argument_list|,
name|current_dienum
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DELTA2
argument_list|(
name|asm_out_file
argument_list|,
name|end_label
argument_list|,
name|begin_label
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|begin_label
argument_list|)
expr_stmt|;
comment|/* Handle a special case.  If we are about to output a location descriptor      for a variable or parameter which has been optimized out of existence,      don't do that.  Instead we output a zero-length location descriptor      value as part of the location attribute.       A variable which has been optimized out of existence will have a      DECL_RTL value which denotes a pseudo-reg.       Currently, in some rare cases, variables can have DECL_RTL values      which look like (MEM (REG pseudo-reg#)).  These cases are due to      bugs elsewhere in the compiler.  We treat such cases      as if the variable(s) in question had been optimized out of existence.       Note that in all cases where we wish to express the fact that a      variable has been optimized out of existence, we do not simply      suppress the generation of the entire location attribute because      the absence of a location attribute in certain kinds of DIEs is      used to indicate something else entirely... i.e. that the DIE      represents an object declaration, but not a definition.  So saith      the PLSIG.   */
if|if
condition|(
operator|!
name|is_pseudo_reg
argument_list|(
name|rtl
argument_list|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
operator|!=
name|MEM
operator|||
operator|!
name|is_pseudo_reg
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
name|output_loc_descriptor
argument_list|(
name|eliminate_regs
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|end_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output the specialized form of location attribute used for data members    of struct and union types.     In the special case of a FIELD_DECL node which represents a bit-field,    the "offset" part of this special location descriptor must indicate the    distance in bytes from the lowest-addressed byte of the containing    struct or union type to the lowest-addressed byte of the "containing    object" for the bit-field.  (See the `field_byte_offset' function above.)     For any given bit-field, the "containing object" is a hypothetical    object (of some integral or enum type) within which the given bit-field    lives.  The type of this hypothetical "containing object" is always the    same as the declared type of the individual bit-field itself (for GCC    anyway... the DWARF spec doesn't actually mandate this).     Note that it is the size (in bytes) of the hypothetical "containing    object" which will be given in the AT_byte_size attribute for this    bit-field.  (See the `byte_size_attribute' function below.)  It is    also used when calculating the value of the AT_bit_offset attribute.    (See the `bit_offset_attribute' function below.) */
end_comment

begin_function
specifier|static
name|void
name|data_member_location_attribute
parameter_list|(
name|decl
parameter_list|)
specifier|register
name|tree
name|decl
decl_stmt|;
block|{
specifier|register
name|unsigned
name|object_offset_in_bytes
init|=
name|field_byte_offset
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|char
name|begin_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|char
name|end_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|ASM_OUTPUT_DWARF_ATTRIBUTE
argument_list|(
name|asm_out_file
argument_list|,
name|AT_location
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|begin_label
argument_list|,
name|LOC_BEGIN_LABEL_FMT
argument_list|,
name|current_dienum
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|end_label
argument_list|,
name|LOC_END_LABEL_FMT
argument_list|,
name|current_dienum
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DELTA2
argument_list|(
name|asm_out_file
argument_list|,
name|end_label
argument_list|,
name|begin_label
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|begin_label
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_STACK_OP
argument_list|(
name|asm_out_file
argument_list|,
name|OP_CONST
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DATA4
argument_list|(
name|asm_out_file
argument_list|,
name|object_offset_in_bytes
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_STACK_OP
argument_list|(
name|asm_out_file
argument_list|,
name|OP_ADD
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|end_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output an AT_const_value attribute for a variable or a parameter which    does not have a "location" either in memory or in a register.  These    things can arise in GNU C when a constant is passed as an actual    parameter to an inlined function.  They can also arise in C++ where    declared constants do not necessarily get memory "homes".  */
end_comment

begin_function
specifier|static
name|void
name|const_value_attribute
parameter_list|(
name|rtl
parameter_list|)
specifier|register
name|rtx
name|rtl
decl_stmt|;
block|{
name|char
name|begin_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|char
name|end_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|ASM_OUTPUT_DWARF_ATTRIBUTE
argument_list|(
name|asm_out_file
argument_list|,
name|AT_const_value_block4
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|begin_label
argument_list|,
name|LOC_BEGIN_LABEL_FMT
argument_list|,
name|current_dienum
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|end_label
argument_list|,
name|LOC_END_LABEL_FMT
argument_list|,
name|current_dienum
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DELTA4
argument_list|(
name|asm_out_file
argument_list|,
name|end_label
argument_list|,
name|begin_label
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|begin_label
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
condition|)
block|{
case|case
name|CONST_INT
case|:
comment|/* Note that a CONST_INT rtx could represent either an integer or 	   a floating-point constant.  A CONST_INT is used whenever the 	   constant will fit into a single word.  In all such cases, the 	   original mode of the constant value is wiped out, and the 	   CONST_INT rtx is assigned VOIDmode.  Since we no longer have 	   precise mode information for these constants, we always just 	   output them using 4 bytes.  */
name|ASM_OUTPUT_DWARF_DATA4
argument_list|(
name|asm_out_file
argument_list|,
operator|(
name|unsigned
operator|)
name|INTVAL
argument_list|(
name|rtl
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_DOUBLE
case|:
comment|/* Note that a CONST_DOUBLE rtx could represent either an integer 	   or a floating-point constant.  A CONST_DOUBLE is used whenever 	   the constant requires more than one word in order to be adequately 	   represented.  In all such cases, the original mode of the constant 	   value is preserved as the mode of the CONST_DOUBLE rtx, but for 	   simplicity we always just output CONST_DOUBLEs using 8 bytes.  */
name|ASM_OUTPUT_DWARF_DATA8
argument_list|(
name|asm_out_file
argument_list|,
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|CONST_DOUBLE_HIGH
argument_list|(
name|rtl
argument_list|)
argument_list|,
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|CONST_DOUBLE_LOW
argument_list|(
name|rtl
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_STRING
case|:
name|ASM_OUTPUT_DWARF_STRING
argument_list|(
name|asm_out_file
argument_list|,
name|XSTR
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|CONST
case|:
name|ASM_OUTPUT_DWARF_ADDR_CONST
argument_list|(
name|asm_out_file
argument_list|,
name|rtl
argument_list|)
expr_stmt|;
break|break;
case|case
name|PLUS
case|:
comment|/* In cases where an inlined instance of an inline function is passed 	   the address of an `auto' variable (which is local to the caller) 	   we can get a situation where the DECL_RTL of the artificial 	   local variable (for the inlining) which acts as a stand-in for 	   the corresponding formal parameter (of the inline function) 	   will look like (plus:SI (reg:SI FRAME_PTR) (const_int ...)). 	   This is not exactly a compile-time constant expression, but it 	   isn't the address of the (artificial) local variable either. 	   Rather, it represents the *value* which the artificial local 	   variable always has during its lifetime.  We currently have no 	   way to represent such quasi-constant values in Dwarf, so for now 	   we just punt and generate an AT_const_value attribute with form 	   FORM_BLOCK4 and a length of zero.  */
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
comment|/* No other kinds of rtx should be possible here.  */
block|}
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|end_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate *either* an AT_location attribute or else an AT_const_value    data attribute for a variable or a parameter.  We generate the    AT_const_value attribute only in those cases where the given    variable or parameter does not have a true "location" either in    memory or in a register.  This can happen (for example) when a    constant is passed as an actual argument in a call to an inline    function.  (It's possible that these things can crop up in other    ways also.)  Note that one type of constant value which can be    passed into an inlined function is a constant pointer.  This can    happen for example if an actual argument in an inlined function    call evaluates to a compile-time constant address.  */
end_comment

begin_function
specifier|static
name|void
name|location_or_const_value_attribute
parameter_list|(
name|decl
parameter_list|)
specifier|register
name|tree
name|decl
decl_stmt|;
block|{
specifier|register
name|rtx
name|rtl
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|VAR_DECL
operator|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|PARM_DECL
operator|)
condition|)
block|{
comment|/* Should never happen.  */
name|abort
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Here we have to decide where we are going to say the parameter "lives"      (as far as the debugger is concerned).  We only have a couple of choices.      GCC provides us with DECL_RTL and with DECL_INCOMING_RTL.  DECL_RTL      normally indicates where the parameter lives during most of the activa-      tion of the function.  If optimization is enabled however, this could      be either NULL or else a pseudo-reg.  Both of those cases indicate that      the parameter doesn't really live anywhere (as far as the code generation      parts of GCC are concerned) during most of the function's activation.      That will happen (for example) if the parameter is never referenced      within the function.       We could just generate a location descriptor here for all non-NULL      non-pseudo values of DECL_RTL and ignore all of the rest, but we can      be a little nicer than that if we also consider DECL_INCOMING_RTL in      cases where DECL_RTL is NULL or is a pseudo-reg.       Note however that we can only get away with using DECL_INCOMING_RTL as      a backup substitute for DECL_RTL in certain limited cases.  In cases      where DECL_ARG_TYPE(decl) indicates the same type as TREE_TYPE(decl)      we can be sure that the parameter was passed using the same type as it      is declared to have within the function, and that its DECL_INCOMING_RTL      points us to a place where a value of that type is passed.  In cases      where DECL_ARG_TYPE(decl) and TREE_TYPE(decl) are different types      however, we cannot (in general) use DECL_INCOMING_RTL as a backup      substitute for DECL_RTL because in these cases, DECL_INCOMING_RTL      points us to a value of some type which is *different* from the type      of the parameter itself.  Thus, if we tried to use DECL_INCOMING_RTL      to generate a location attribute in such cases, the debugger would      end up (for example) trying to fetch a `float' from a place which      actually contains the first part of a `double'.  That would lead to      really incorrect and confusing output at debug-time, and we don't      want that now do we?       So in general, we DO NOT use DECL_INCOMING_RTL as a backup for DECL_RTL      in cases where DECL_ARG_TYPE(decl) != TREE_TYPE(decl).  There are a      couple of cute exceptions however.  On little-endian machines we can      get away with using DECL_INCOMING_RTL even when DECL_ARG_TYPE(decl) is      not the same as TREE_TYPE(decl) but only when DECL_ARG_TYPE(decl) is      an integral type which is smaller than TREE_TYPE(decl).  These cases      arise when (on a little-endian machine) a non-prototyped function has      a parameter declared to be of type `short' or `char'.  In such cases,      TREE_TYPE(decl) will be `short' or `char', DECL_ARG_TYPE(decl) will be      `int', and DECL_INCOMING_RTL will point to the lowest-order byte of the      passed `int' value.  If the debugger then uses that address to fetch a      `short' or a `char' (on a little-endian machine) the result will be the      correct data, so we allow for such exceptional cases below.       Note that our goal here is to describe the place where the given formal      parameter lives during most of the function's activation (i.e. between      the end of the prologue and the start of the epilogue).  We'll do that      as best as we can.  Note however that if the given formal parameter is      modified sometime during the execution of the function, then a stack      backtrace (at debug-time) will show the function as having been called      with the *new* value rather than the value which was originally passed      in.  This happens rarely enough that it is not a major problem, but it      *is* a problem, and I'd like to fix it.  A future version of dwarfout.c      may generate two additional attributes for any given TAG_formal_parameter      DIE which will describe the "passed type" and the "passed location" for      the given formal parameter in addition to the attributes we now generate      to indicate the "declared type" and the "active location" for each      parameter.  This additional set of attributes could be used by debuggers      for stack backtraces.       Separately, note that sometimes DECL_RTL can be NULL and DECL_INCOMING_RTL      can be NULL also.  This happens (for example) for inlined-instances of      inline function formal parameters which are never referenced.  This really      shouldn't be happening.  All PARM_DECL nodes should get valid non-NULL      DECL_INCOMING_RTL values, but integrate.c doesn't currently generate      these values for inlined instances of inline function parameters, so      when we see such cases, we are just SOL (shit-out-of-luck) for the time      being (until integrate.c gets fixed).   */
comment|/* Use DECL_RTL as the "location" unless we find something better.  */
name|rtl
operator|=
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
condition|)
if|if
condition|(
name|rtl
operator|==
name|NULL_RTX
operator|||
name|is_pseudo_reg
argument_list|(
name|rtl
argument_list|)
condition|)
block|{
comment|/* This decl represents a formal parameter which was optimized out.  */
specifier|register
name|tree
name|declared_type
init|=
name|type_main_variant
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|passed_type
init|=
name|type_main_variant
argument_list|(
name|DECL_ARG_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Note that DECL_INCOMING_RTL may be NULL in here, but we handle 	   *all* cases where (rtl == NULL_RTX) just below.  */
if|if
condition|(
name|declared_type
operator|==
name|passed_type
condition|)
name|rtl
operator|=
name|DECL_INCOMING_RTL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|BYTES_BIG_ENDIAN
condition|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|declared_type
argument_list|)
operator|==
name|INTEGER_TYPE
condition|)
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|declared_type
argument_list|)
operator|<=
name|TYPE_SIZE
argument_list|(
name|passed_type
argument_list|)
condition|)
name|rtl
operator|=
name|DECL_INCOMING_RTL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rtl
operator|==
name|NULL_RTX
condition|)
return|return;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
condition|)
block|{
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_STRING
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|CONST
case|:
case|case
name|PLUS
case|:
comment|/* DECL_RTL could be (plus (reg ...) (const_int ...)) */
name|const_value_attribute
argument_list|(
name|rtl
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEM
case|:
case|case
name|REG
case|:
case|case
name|SUBREG
case|:
name|location_attribute
argument_list|(
name|rtl
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
comment|/* Should never happen.  */
block|}
block|}
end_function

begin_comment
comment|/* Generate an AT_name attribute given some string value to be included as    the value of the attribute.	*/
end_comment

begin_function
specifier|inline
name|void
name|name_attribute
parameter_list|(
name|name_string
parameter_list|)
specifier|register
name|char
modifier|*
name|name_string
decl_stmt|;
block|{
if|if
condition|(
name|name_string
operator|&&
operator|*
name|name_string
condition|)
block|{
name|ASM_OUTPUT_DWARF_ATTRIBUTE
argument_list|(
name|asm_out_file
argument_list|,
name|AT_name
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_STRING
argument_list|(
name|asm_out_file
argument_list|,
name|name_string
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|inline
name|void
name|fund_type_attribute
parameter_list|(
name|ft_code
parameter_list|)
specifier|register
name|unsigned
name|ft_code
decl_stmt|;
block|{
name|ASM_OUTPUT_DWARF_ATTRIBUTE
argument_list|(
name|asm_out_file
argument_list|,
name|AT_fund_type
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_FUND_TYPE
argument_list|(
name|asm_out_file
argument_list|,
name|ft_code
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mod_fund_type_attribute
parameter_list|(
name|type
parameter_list|,
name|decl_const
parameter_list|,
name|decl_volatile
parameter_list|)
specifier|register
name|tree
name|type
decl_stmt|;
specifier|register
name|int
name|decl_const
decl_stmt|;
specifier|register
name|int
name|decl_volatile
decl_stmt|;
block|{
name|char
name|begin_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|char
name|end_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|ASM_OUTPUT_DWARF_ATTRIBUTE
argument_list|(
name|asm_out_file
argument_list|,
name|AT_mod_fund_type
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|begin_label
argument_list|,
name|MT_BEGIN_LABEL_FMT
argument_list|,
name|current_dienum
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|end_label
argument_list|,
name|MT_END_LABEL_FMT
argument_list|,
name|current_dienum
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DELTA2
argument_list|(
name|asm_out_file
argument_list|,
name|end_label
argument_list|,
name|begin_label
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|begin_label
argument_list|)
expr_stmt|;
name|write_modifier_bytes
argument_list|(
name|type
argument_list|,
name|decl_const
argument_list|,
name|decl_volatile
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_FUND_TYPE
argument_list|(
name|asm_out_file
argument_list|,
name|fundamental_type_code
argument_list|(
name|root_type
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|end_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|inline
name|void
name|user_def_type_attribute
parameter_list|(
name|type
parameter_list|)
specifier|register
name|tree
name|type
decl_stmt|;
block|{
name|char
name|ud_type_name
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|ASM_OUTPUT_DWARF_ATTRIBUTE
argument_list|(
name|asm_out_file
argument_list|,
name|AT_user_def_type
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ud_type_name
argument_list|,
name|TYPE_NAME_FMT
argument_list|,
name|TYPE_UID
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_REF
argument_list|(
name|asm_out_file
argument_list|,
name|ud_type_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mod_u_d_type_attribute
parameter_list|(
name|type
parameter_list|,
name|decl_const
parameter_list|,
name|decl_volatile
parameter_list|)
specifier|register
name|tree
name|type
decl_stmt|;
specifier|register
name|int
name|decl_const
decl_stmt|;
specifier|register
name|int
name|decl_volatile
decl_stmt|;
block|{
name|char
name|begin_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|char
name|end_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|char
name|ud_type_name
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|ASM_OUTPUT_DWARF_ATTRIBUTE
argument_list|(
name|asm_out_file
argument_list|,
name|AT_mod_u_d_type
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|begin_label
argument_list|,
name|MT_BEGIN_LABEL_FMT
argument_list|,
name|current_dienum
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|end_label
argument_list|,
name|MT_END_LABEL_FMT
argument_list|,
name|current_dienum
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DELTA2
argument_list|(
name|asm_out_file
argument_list|,
name|end_label
argument_list|,
name|begin_label
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|begin_label
argument_list|)
expr_stmt|;
name|write_modifier_bytes
argument_list|(
name|type
argument_list|,
name|decl_const
argument_list|,
name|decl_volatile
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ud_type_name
argument_list|,
name|TYPE_NAME_FMT
argument_list|,
name|TYPE_UID
argument_list|(
name|root_type
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_REF
argument_list|(
name|asm_out_file
argument_list|,
name|ud_type_name
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|end_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USE_ORDERING_ATTRIBUTE
end_ifdef

begin_function
specifier|inline
name|void
name|ordering_attribute
parameter_list|(
name|ordering
parameter_list|)
specifier|register
name|unsigned
name|ordering
decl_stmt|;
block|{
name|ASM_OUTPUT_DWARF_ATTRIBUTE
argument_list|(
name|asm_out_file
argument_list|,
name|AT_ordering
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DATA2
argument_list|(
name|asm_out_file
argument_list|,
name|ordering
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(USE_ORDERING_ATTRIBUTE) */
end_comment

begin_comment
comment|/* Note that the block of subscript information for an array type also    includes information about the element type of type given array type.  */
end_comment

begin_function
specifier|static
name|void
name|subscript_data_attribute
parameter_list|(
name|type
parameter_list|)
specifier|register
name|tree
name|type
decl_stmt|;
block|{
specifier|register
name|unsigned
name|dimension_number
decl_stmt|;
name|char
name|begin_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|char
name|end_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|ASM_OUTPUT_DWARF_ATTRIBUTE
argument_list|(
name|asm_out_file
argument_list|,
name|AT_subscr_data
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|begin_label
argument_list|,
name|SS_BEGIN_LABEL_FMT
argument_list|,
name|current_dienum
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|end_label
argument_list|,
name|SS_END_LABEL_FMT
argument_list|,
name|current_dienum
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DELTA2
argument_list|(
name|asm_out_file
argument_list|,
name|end_label
argument_list|,
name|begin_label
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|begin_label
argument_list|)
expr_stmt|;
comment|/* The GNU compilers represent multidimensional array types as sequences      of one dimensional array types whose element types are themselves array      types.  Here we squish that down, so that each multidimensional array      type gets only one array_type DIE in the Dwarf debugging info.  The      draft Dwarf specification say that we are allowed to do this kind      of compression in C (because there is no difference between an      array or arrays and a multidimensional array in C) but for other      source languages (e.g. Ada) we probably shouldn't do this.  */
for|for
control|(
name|dimension_number
operator|=
literal|0
init|;
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
operator|,
name|dimension_number
operator|++
control|)
block|{
specifier|register
name|tree
name|domain
init|=
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* Arrays come in three flavors.	Unspecified bounds, fixed 	 bounds, and (in GNU C only) variable bounds.  Handle all 	 three forms here.  */
if|if
condition|(
name|domain
condition|)
block|{
comment|/* We have an array type with specified bounds.  */
specifier|register
name|tree
name|lower
init|=
name|TYPE_MIN_VALUE
argument_list|(
name|domain
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|upper
init|=
name|TYPE_MAX_VALUE
argument_list|(
name|domain
argument_list|)
decl_stmt|;
comment|/* Handle only fundamental types as index types for now.  */
if|if
condition|(
operator|!
name|type_is_fundamental
argument_list|(
name|domain
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Output the representation format byte for this dimension. */
name|ASM_OUTPUT_DWARF_FMT_BYTE
argument_list|(
name|asm_out_file
argument_list|,
name|FMT_CODE
argument_list|(
literal|1
argument_list|,
name|TREE_CODE
argument_list|(
name|lower
argument_list|)
operator|==
name|INTEGER_CST
argument_list|,
name|TREE_CODE
argument_list|(
name|upper
argument_list|)
operator|==
name|INTEGER_CST
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Output the index type for this dimension.	*/
name|ASM_OUTPUT_DWARF_FUND_TYPE
argument_list|(
name|asm_out_file
argument_list|,
name|fundamental_type_code
argument_list|(
name|domain
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Output the representation for the lower bound.  */
name|output_bound_representation
argument_list|(
name|lower
argument_list|,
name|dimension_number
argument_list|,
literal|'l'
argument_list|)
expr_stmt|;
comment|/* Output the representation for the upper bound.  */
name|output_bound_representation
argument_list|(
name|upper
argument_list|,
name|dimension_number
argument_list|,
literal|'u'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We have an array type with an unspecified length.	For C and 	     C++ we can assume that this really means that (a) the index 	     type is an integral type, and (b) the lower bound is zero. 	     Note that Dwarf defines the representation of an unspecified 	     (upper) bound as being a zero-length location description.	 */
comment|/* Output the array-bounds format byte.  */
name|ASM_OUTPUT_DWARF_FMT_BYTE
argument_list|(
name|asm_out_file
argument_list|,
name|FMT_FT_C_X
argument_list|)
expr_stmt|;
comment|/* Output the (assumed) index type.  */
name|ASM_OUTPUT_DWARF_FUND_TYPE
argument_list|(
name|asm_out_file
argument_list|,
name|FT_integer
argument_list|)
expr_stmt|;
comment|/* Output the (assumed) lower bound (constant) value.	 */
name|ASM_OUTPUT_DWARF_DATA4
argument_list|(
name|asm_out_file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Output the (empty) location description for the upper bound.  */
name|ASM_OUTPUT_DWARF_DATA2
argument_list|(
name|asm_out_file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Output the prefix byte that says that the element type is coming up.  */
name|ASM_OUTPUT_DWARF_FMT_BYTE
argument_list|(
name|asm_out_file
argument_list|,
name|FMT_ET
argument_list|)
expr_stmt|;
comment|/* Output a representation of the type of the elements of this array type.  */
name|type_attribute
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|end_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|byte_size_attribute
parameter_list|(
name|tree_node
parameter_list|)
specifier|register
name|tree
name|tree_node
decl_stmt|;
block|{
specifier|register
name|unsigned
name|size
decl_stmt|;
name|ASM_OUTPUT_DWARF_ATTRIBUTE
argument_list|(
name|asm_out_file
argument_list|,
name|AT_byte_size
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|tree_node
argument_list|)
condition|)
block|{
case|case
name|ERROR_MARK
case|:
name|size
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|QUAL_UNION_TYPE
case|:
name|size
operator|=
name|int_size_in_bytes
argument_list|(
name|tree_node
argument_list|)
expr_stmt|;
break|break;
case|case
name|FIELD_DECL
case|:
comment|/* For a data member of a struct or union, the AT_byte_size is 	   generally given as the number of bytes normally allocated for 	   an object of the *declared* type of the member itself.  This 	   is true even for bit-fields.  */
name|size
operator|=
name|simple_type_size_in_bits
argument_list|(
name|field_type
argument_list|(
name|tree_node
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Note that `size' might be -1 when we get to this point.  If it      is, that indicates that the byte size of the entity in question      is variable.  We have no good way of expressing this fact in Dwarf      at the present time, so just let the -1 pass on through.  */
name|ASM_OUTPUT_DWARF_DATA4
argument_list|(
name|asm_out_file
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* For a FIELD_DECL node which represents a bit-field, output an attribute    which specifies the distance in bits from the highest order bit of the    "containing object" for the bit-field to the highest order bit of the    bit-field itself.     For any given bit-field, the "containing object" is a hypothetical    object (of some integral or enum type) within which the given bit-field    lives.  The type of this hypothetical "containing object" is always the    same as the declared type of the individual bit-field itself.     The determination of the exact location of the "containing object" for    a bit-field is rather complicated.  It's handled by the `field_byte_offset'    function (above).     Note that it is the size (in bytes) of the hypothetical "containing    object" which will be given in the AT_byte_size attribute for this    bit-field.  (See `byte_size_attribute' above.) */
end_comment

begin_function
specifier|inline
name|void
name|bit_offset_attribute
parameter_list|(
name|decl
parameter_list|)
specifier|register
name|tree
name|decl
decl_stmt|;
block|{
specifier|register
name|unsigned
name|object_offset_in_bytes
init|=
name|field_byte_offset
argument_list|(
name|decl
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|type
init|=
name|DECL_BIT_FIELD_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|bitpos_tree
init|=
name|DECL_FIELD_BITPOS
argument_list|(
name|decl
argument_list|)
decl_stmt|;
specifier|register
name|unsigned
name|bitpos_int
decl_stmt|;
specifier|register
name|unsigned
name|highest_order_object_bit_offset
decl_stmt|;
specifier|register
name|unsigned
name|highest_order_field_bit_offset
decl_stmt|;
specifier|register
name|unsigned
name|bit_offset
decl_stmt|;
name|assert
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FIELD_DECL
argument_list|)
expr_stmt|;
comment|/* Must be a field.  */
name|assert
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Must be a bit field.	 */
comment|/* We can't yet handle bit-fields whose offsets are variable, so if we      encounter such things, just return without generating any attribute      whatsoever.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|bitpos_tree
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return;
name|bitpos_int
operator|=
operator|(
name|unsigned
operator|)
name|TREE_INT_CST_LOW
argument_list|(
name|bitpos_tree
argument_list|)
expr_stmt|;
comment|/* Note that the bit offset is always the distance (in bits) from the      highest-order bit of the "containing object" to the highest-order      bit of the bit-field itself.  Since the "high-order end" of any      object or field is different on big-endian and little-endian machines,      the computation below must take account of these differences.  */
name|highest_order_object_bit_offset
operator|=
name|object_offset_in_bytes
operator|*
name|BITS_PER_UNIT
expr_stmt|;
name|highest_order_field_bit_offset
operator|=
name|bitpos_int
expr_stmt|;
if|if
condition|(
operator|!
name|BYTES_BIG_ENDIAN
condition|)
block|{
name|highest_order_field_bit_offset
operator|+=
operator|(
name|unsigned
operator|)
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|highest_order_object_bit_offset
operator|+=
name|simple_type_size_in_bits
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
name|bit_offset
operator|=
operator|(
operator|!
name|BYTES_BIG_ENDIAN
condition|?
name|highest_order_object_bit_offset
operator|-
name|highest_order_field_bit_offset
else|:
name|highest_order_field_bit_offset
operator|-
name|highest_order_object_bit_offset
operator|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_ATTRIBUTE
argument_list|(
name|asm_out_file
argument_list|,
name|AT_bit_offset
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DATA2
argument_list|(
name|asm_out_file
argument_list|,
name|bit_offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* For a FIELD_DECL node which represents a bit field, output an attribute    which specifies the length in bits of the given field.  */
end_comment

begin_function
specifier|inline
name|void
name|bit_size_attribute
parameter_list|(
name|decl
parameter_list|)
specifier|register
name|tree
name|decl
decl_stmt|;
block|{
name|assert
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FIELD_DECL
argument_list|)
expr_stmt|;
comment|/* Must be a field.  */
name|assert
argument_list|(
name|DECL_BIT_FIELD_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Must be a bit field.	 */
name|ASM_OUTPUT_DWARF_ATTRIBUTE
argument_list|(
name|asm_out_file
argument_list|,
name|AT_bit_size
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DATA4
argument_list|(
name|asm_out_file
argument_list|,
operator|(
name|unsigned
operator|)
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The following routine outputs the `element_list' attribute for enumeration    type DIEs.  The element_lits attribute includes the names and values of    all of the enumeration constants associated with the given enumeration    type.  */
end_comment

begin_function
specifier|inline
name|void
name|element_list_attribute
parameter_list|(
name|element
parameter_list|)
specifier|register
name|tree
name|element
decl_stmt|;
block|{
name|char
name|begin_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|char
name|end_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|ASM_OUTPUT_DWARF_ATTRIBUTE
argument_list|(
name|asm_out_file
argument_list|,
name|AT_element_list
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|begin_label
argument_list|,
name|EE_BEGIN_LABEL_FMT
argument_list|,
name|current_dienum
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|end_label
argument_list|,
name|EE_END_LABEL_FMT
argument_list|,
name|current_dienum
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DELTA4
argument_list|(
name|asm_out_file
argument_list|,
name|end_label
argument_list|,
name|begin_label
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|begin_label
argument_list|)
expr_stmt|;
comment|/* Here we output a list of value/name pairs for each enumeration constant      defined for this enumeration type (as required), but we do it in REVERSE      order.  The order is the one required by the draft #5 Dwarf specification      published by the UI/PLSIG.  */
name|output_enumeral_list
argument_list|(
name|element
argument_list|)
expr_stmt|;
comment|/* Recursively output the whole list.  */
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|end_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate an AT_stmt_list attribute.	These are normally present only in    DIEs with a TAG_compile_unit tag.  */
end_comment

begin_function
specifier|inline
name|void
name|stmt_list_attribute
parameter_list|(
name|label
parameter_list|)
specifier|register
name|char
modifier|*
name|label
decl_stmt|;
block|{
name|ASM_OUTPUT_DWARF_ATTRIBUTE
argument_list|(
name|asm_out_file
argument_list|,
name|AT_stmt_list
argument_list|)
expr_stmt|;
comment|/* Don't use ASM_OUTPUT_DWARF_DATA4 here.  */
name|ASM_OUTPUT_DWARF_ADDR
argument_list|(
name|asm_out_file
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate an AT_low_pc attribute for a label DIE, a lexical_block DIE or    for a subroutine DIE.  */
end_comment

begin_function
specifier|inline
name|void
name|low_pc_attribute
parameter_list|(
name|asm_low_label
parameter_list|)
specifier|register
name|char
modifier|*
name|asm_low_label
decl_stmt|;
block|{
name|ASM_OUTPUT_DWARF_ATTRIBUTE
argument_list|(
name|asm_out_file
argument_list|,
name|AT_low_pc
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_ADDR
argument_list|(
name|asm_out_file
argument_list|,
name|asm_low_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate an AT_high_pc attribute for a lexical_block DIE or for a    subroutine DIE.  */
end_comment

begin_function
specifier|inline
name|void
name|high_pc_attribute
parameter_list|(
name|asm_high_label
parameter_list|)
specifier|register
name|char
modifier|*
name|asm_high_label
decl_stmt|;
block|{
name|ASM_OUTPUT_DWARF_ATTRIBUTE
argument_list|(
name|asm_out_file
argument_list|,
name|AT_high_pc
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_ADDR
argument_list|(
name|asm_out_file
argument_list|,
name|asm_high_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate an AT_body_begin attribute for a subroutine DIE.  */
end_comment

begin_function
specifier|inline
name|void
name|body_begin_attribute
parameter_list|(
name|asm_begin_label
parameter_list|)
specifier|register
name|char
modifier|*
name|asm_begin_label
decl_stmt|;
block|{
name|ASM_OUTPUT_DWARF_ATTRIBUTE
argument_list|(
name|asm_out_file
argument_list|,
name|AT_body_begin
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_ADDR
argument_list|(
name|asm_out_file
argument_list|,
name|asm_begin_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate an AT_body_end attribute for a subroutine DIE.  */
end_comment

begin_function
specifier|inline
name|void
name|body_end_attribute
parameter_list|(
name|asm_end_label
parameter_list|)
specifier|register
name|char
modifier|*
name|asm_end_label
decl_stmt|;
block|{
name|ASM_OUTPUT_DWARF_ATTRIBUTE
argument_list|(
name|asm_out_file
argument_list|,
name|AT_body_end
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_ADDR
argument_list|(
name|asm_out_file
argument_list|,
name|asm_end_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate an AT_language attribute given a LANG value.  These attributes    are used only within TAG_compile_unit DIEs.  */
end_comment

begin_function
specifier|inline
name|void
name|language_attribute
parameter_list|(
name|language_code
parameter_list|)
specifier|register
name|unsigned
name|language_code
decl_stmt|;
block|{
name|ASM_OUTPUT_DWARF_ATTRIBUTE
argument_list|(
name|asm_out_file
argument_list|,
name|AT_language
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DATA4
argument_list|(
name|asm_out_file
argument_list|,
name|language_code
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|inline
name|void
name|member_attribute
parameter_list|(
name|context
parameter_list|)
specifier|register
name|tree
name|context
decl_stmt|;
block|{
name|char
name|label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
comment|/* Generate this attribute only for members in C++.  */
if|if
condition|(
name|context
operator|!=
name|NULL
operator|&&
name|is_tagged_type
argument_list|(
name|context
argument_list|)
condition|)
block|{
name|ASM_OUTPUT_DWARF_ATTRIBUTE
argument_list|(
name|asm_out_file
argument_list|,
name|AT_member
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|label
argument_list|,
name|TYPE_NAME_FMT
argument_list|,
name|TYPE_UID
argument_list|(
name|context
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_REF
argument_list|(
name|asm_out_file
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|inline
name|void
name|string_length_attribute
parameter_list|(
name|upper_bound
parameter_list|)
specifier|register
name|tree
name|upper_bound
decl_stmt|;
block|{
name|char
name|begin_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|char
name|end_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|ASM_OUTPUT_DWARF_ATTRIBUTE
argument_list|(
name|asm_out_file
argument_list|,
name|AT_string_length
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|begin_label
argument_list|,
name|SL_BEGIN_LABEL_FMT
argument_list|,
name|current_dienum
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|end_label
argument_list|,
name|SL_END_LABEL_FMT
argument_list|,
name|current_dienum
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DELTA2
argument_list|(
name|asm_out_file
argument_list|,
name|end_label
argument_list|,
name|begin_label
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|begin_label
argument_list|)
expr_stmt|;
name|output_bound_representation
argument_list|(
name|upper_bound
argument_list|,
literal|0
argument_list|,
literal|'u'
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|end_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|inline
name|void
name|comp_dir_attribute
parameter_list|(
name|dirname
parameter_list|)
specifier|register
name|char
modifier|*
name|dirname
decl_stmt|;
block|{
name|ASM_OUTPUT_DWARF_ATTRIBUTE
argument_list|(
name|asm_out_file
argument_list|,
name|AT_comp_dir
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_STRING
argument_list|(
name|asm_out_file
argument_list|,
name|dirname
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|inline
name|void
name|sf_names_attribute
parameter_list|(
name|sf_names_start_label
parameter_list|)
specifier|register
name|char
modifier|*
name|sf_names_start_label
decl_stmt|;
block|{
name|ASM_OUTPUT_DWARF_ATTRIBUTE
argument_list|(
name|asm_out_file
argument_list|,
name|AT_sf_names
argument_list|)
expr_stmt|;
comment|/* Don't use ASM_OUTPUT_DWARF_DATA4 here.  */
name|ASM_OUTPUT_DWARF_ADDR
argument_list|(
name|asm_out_file
argument_list|,
name|sf_names_start_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|inline
name|void
name|src_info_attribute
parameter_list|(
name|src_info_start_label
parameter_list|)
specifier|register
name|char
modifier|*
name|src_info_start_label
decl_stmt|;
block|{
name|ASM_OUTPUT_DWARF_ATTRIBUTE
argument_list|(
name|asm_out_file
argument_list|,
name|AT_src_info
argument_list|)
expr_stmt|;
comment|/* Don't use ASM_OUTPUT_DWARF_DATA4 here.  */
name|ASM_OUTPUT_DWARF_ADDR
argument_list|(
name|asm_out_file
argument_list|,
name|src_info_start_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|inline
name|void
name|mac_info_attribute
parameter_list|(
name|mac_info_start_label
parameter_list|)
specifier|register
name|char
modifier|*
name|mac_info_start_label
decl_stmt|;
block|{
name|ASM_OUTPUT_DWARF_ATTRIBUTE
argument_list|(
name|asm_out_file
argument_list|,
name|AT_mac_info
argument_list|)
expr_stmt|;
comment|/* Don't use ASM_OUTPUT_DWARF_DATA4 here.  */
name|ASM_OUTPUT_DWARF_ADDR
argument_list|(
name|asm_out_file
argument_list|,
name|mac_info_start_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|inline
name|void
name|prototyped_attribute
parameter_list|(
name|func_type
parameter_list|)
specifier|register
name|tree
name|func_type
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|language_string
argument_list|,
literal|"GNU C"
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|TYPE_ARG_TYPES
argument_list|(
name|func_type
argument_list|)
operator|!=
name|NULL
operator|)
condition|)
block|{
name|ASM_OUTPUT_DWARF_ATTRIBUTE
argument_list|(
name|asm_out_file
argument_list|,
name|AT_prototyped
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_STRING
argument_list|(
name|asm_out_file
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|inline
name|void
name|producer_attribute
parameter_list|(
name|producer
parameter_list|)
specifier|register
name|char
modifier|*
name|producer
decl_stmt|;
block|{
name|ASM_OUTPUT_DWARF_ATTRIBUTE
argument_list|(
name|asm_out_file
argument_list|,
name|AT_producer
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_STRING
argument_list|(
name|asm_out_file
argument_list|,
name|producer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|inline
name|void
name|inline_attribute
parameter_list|(
name|decl
parameter_list|)
specifier|register
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
name|DECL_INLINE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|ASM_OUTPUT_DWARF_ATTRIBUTE
argument_list|(
name|asm_out_file
argument_list|,
name|AT_inline
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_STRING
argument_list|(
name|asm_out_file
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|inline
name|void
name|containing_type_attribute
parameter_list|(
name|containing_type
parameter_list|)
specifier|register
name|tree
name|containing_type
decl_stmt|;
block|{
name|char
name|label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|ASM_OUTPUT_DWARF_ATTRIBUTE
argument_list|(
name|asm_out_file
argument_list|,
name|AT_containing_type
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|label
argument_list|,
name|TYPE_NAME_FMT
argument_list|,
name|TYPE_UID
argument_list|(
name|containing_type
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_REF
argument_list|(
name|asm_out_file
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|inline
name|void
name|abstract_origin_attribute
parameter_list|(
name|origin
parameter_list|)
specifier|register
name|tree
name|origin
decl_stmt|;
block|{
name|char
name|label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|ASM_OUTPUT_DWARF_ATTRIBUTE
argument_list|(
name|asm_out_file
argument_list|,
name|AT_abstract_origin
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|origin
argument_list|)
argument_list|)
condition|)
block|{
case|case
literal|'d'
case|:
name|sprintf
argument_list|(
name|label
argument_list|,
name|DECL_NAME_FMT
argument_list|,
name|DECL_UID
argument_list|(
name|origin
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|sprintf
argument_list|(
name|label
argument_list|,
name|TYPE_NAME_FMT
argument_list|,
name|TYPE_UID
argument_list|(
name|origin
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
comment|/* Should never happen.  */
block|}
name|ASM_OUTPUT_DWARF_REF
argument_list|(
name|asm_out_file
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DWARF_DECL_COORDINATES
end_ifdef

begin_function
specifier|inline
name|void
name|src_coords_attribute
parameter_list|(
name|src_fileno
parameter_list|,
name|src_lineno
parameter_list|)
specifier|register
name|unsigned
name|src_fileno
decl_stmt|;
specifier|register
name|unsigned
name|src_lineno
decl_stmt|;
block|{
name|ASM_OUTPUT_DWARF_ATTRIBUTE
argument_list|(
name|asm_out_file
argument_list|,
name|AT_src_coords
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DATA2
argument_list|(
name|asm_out_file
argument_list|,
name|src_fileno
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DATA2
argument_list|(
name|asm_out_file
argument_list|,
name|src_lineno
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(DWARF_DECL_COORDINATES) */
end_comment

begin_function
specifier|inline
name|void
name|pure_or_virtual_attribute
parameter_list|(
name|func_decl
parameter_list|)
specifier|register
name|tree
name|func_decl
decl_stmt|;
block|{
if|if
condition|(
name|DECL_VIRTUAL_P
argument_list|(
name|func_decl
argument_list|)
condition|)
block|{
if|#
directive|if
literal|0
comment|/* DECL_ABSTRACT_VIRTUAL_P is C++-specific.  */
block|if (DECL_ABSTRACT_VIRTUAL_P (func_decl))         ASM_OUTPUT_DWARF_ATTRIBUTE (asm_out_file, AT_pure_virtual);       else
endif|#
directive|endif
name|ASM_OUTPUT_DWARF_ATTRIBUTE
argument_list|(
name|asm_out_file
argument_list|,
name|AT_virtual
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_STRING
argument_list|(
name|asm_out_file
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/************************* end of attributes *****************************/
end_comment

begin_comment
comment|/********************* utility routines for DIEs *************************/
end_comment

begin_comment
comment|/* Output an AT_name attribute and an AT_src_coords attribute for the    given decl, but only if it actually has a name.  */
end_comment

begin_function
specifier|static
name|void
name|name_and_src_coords_attributes
parameter_list|(
name|decl
parameter_list|)
specifier|register
name|tree
name|decl
decl_stmt|;
block|{
specifier|register
name|tree
name|decl_name
init|=
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|decl_name
operator|&&
name|IDENTIFIER_POINTER
argument_list|(
name|decl_name
argument_list|)
condition|)
block|{
name|name_attribute
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|decl_name
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DWARF_DECL_COORDINATES
block|{
specifier|register
name|unsigned
name|file_index
decl_stmt|;
comment|/* This is annoying, but we have to pop out of the .debug section 	   for a moment while we call `lookup_filename' because calling it 	   may cause a temporary switch into the .debug_sfnames section and 	   most svr4 assemblers are not smart enough be be able to nest 	   section switches to any depth greater than one.  Note that we 	   also can't skirt this issue by delaying all output to the 	   .debug_sfnames section unit the end of compilation because that 	   would cause us to have inter-section forward references and 	   Fred Fish sez that m68k/svr4 assemblers botch those.  */
name|ASM_OUTPUT_POP_SECTION
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
name|file_index
operator|=
name|lookup_filename
argument_list|(
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_PUSH_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|DEBUG_SECTION
argument_list|)
expr_stmt|;
name|src_coords_attribute
argument_list|(
name|file_index
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* defined(DWARF_DECL_COORDINATES) */
block|}
block|}
end_function

begin_comment
comment|/* Many forms of DIEs contain a "type description" part.  The following    routine writes out these "type descriptor" parts.  */
end_comment

begin_function
specifier|static
name|void
name|type_attribute
parameter_list|(
name|type
parameter_list|,
name|decl_const
parameter_list|,
name|decl_volatile
parameter_list|)
specifier|register
name|tree
name|type
decl_stmt|;
specifier|register
name|int
name|decl_const
decl_stmt|;
specifier|register
name|int
name|decl_volatile
decl_stmt|;
block|{
specifier|register
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|int
name|root_type_modified
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return;
comment|/* Handle a special case.  For functions whose return type is void,      we generate *no* type attribute.  (Note that no object may have      type `void', so this only applies to function return types.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VOID_TYPE
condition|)
return|return;
name|root_type_modified
operator|=
operator|(
name|code
operator|==
name|POINTER_TYPE
operator|||
name|code
operator|==
name|REFERENCE_TYPE
operator|||
name|decl_const
operator|||
name|decl_volatile
operator|||
name|TYPE_READONLY
argument_list|(
name|type
argument_list|)
operator|||
name|TYPE_VOLATILE
argument_list|(
name|type
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|type_is_fundamental
argument_list|(
name|root_type
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
if|if
condition|(
name|root_type_modified
condition|)
name|mod_fund_type_attribute
argument_list|(
name|type
argument_list|,
name|decl_const
argument_list|,
name|decl_volatile
argument_list|)
expr_stmt|;
else|else
name|fund_type_attribute
argument_list|(
name|fundamental_type_code
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|root_type_modified
condition|)
name|mod_u_d_type_attribute
argument_list|(
name|type
argument_list|,
name|decl_const
argument_list|,
name|decl_volatile
argument_list|)
expr_stmt|;
else|else
comment|/* We have to get the type_main_variant here (and pass that to the 	   `user_def_type_attribute' routine) because the ..._TYPE node we 	   have might simply be a *copy* of some original type node (where 	   the copy was created to help us keep track of typedef names) 	   and that copy might have a different TYPE_UID from the original 	   ..._TYPE node.  (Note that when `equate_type_number_to_die_number' 	   is labeling a given type DIE for future reference, it always and 	   only creates labels for DIEs representing *main variants*, and it 	   never even knows about non-main-variants.)  */
name|user_def_type_attribute
argument_list|(
name|type_main_variant
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a tree pointer to a struct, class, union, or enum type node, return    a pointer to the (string) tag name for the given type, or zero if the    type was declared without a tag.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|type_tag
parameter_list|(
name|type
parameter_list|)
specifier|register
name|tree
name|type
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|name
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
condition|)
block|{
specifier|register
name|tree
name|t
init|=
literal|0
decl_stmt|;
comment|/* Find the IDENTIFIER_NODE for the type name.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|t
operator|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* The g++ front end makes the TYPE_NAME of *each* tagged type point 	 to a TYPE_DECL node, regardless of whether or not a `typedef' was 	 involved.  This is distinctly different from what the gcc front-end 	 does.  It always makes the TYPE_NAME for each tagged type be either 	 NULL (signifying an anonymous tagged type) or else a pointer to an 	 IDENTIFIER_NODE.  Obviously, we would like to generate correct Dwarf 	 for both C and C++, but given this inconsistency in the TREE 	 representation of tagged types for C and C++ in the GNU front-ends, 	 we cannot support both languages correctly unless we introduce some 	 front-end specific code here, and rms objects to that, so we can 	 only generate correct Dwarf for one of these two languages.  C is 	 more important, so for now we'll do the right thing for C and let 	 g++ go fish.  */
block|else 	if (TREE_CODE (TYPE_NAME (type)) == TYPE_DECL) 	  t = DECL_NAME (TYPE_NAME (type));
endif|#
directive|endif
comment|/* Now get the name as a string, or invent one.  */
if|if
condition|(
name|t
operator|!=
literal|0
condition|)
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|name
operator|==
literal|0
operator|||
operator|*
name|name
operator|==
literal|'\0'
operator|)
condition|?
literal|0
else|:
name|name
return|;
block|}
end_function

begin_function
specifier|inline
name|void
name|dienum_push
parameter_list|()
block|{
comment|/* Start by checking if the pending_sibling_stack needs to be expanded.      If necessary, expand it.  */
if|if
condition|(
name|pending_siblings
operator|==
name|pending_siblings_allocated
condition|)
block|{
name|pending_siblings_allocated
operator|+=
name|PENDING_SIBLINGS_INCREMENT
expr_stmt|;
name|pending_sibling_stack
operator|=
operator|(
name|unsigned
operator|*
operator|)
name|xrealloc
argument_list|(
name|pending_sibling_stack
argument_list|,
name|pending_siblings_allocated
operator|*
sizeof|sizeof
argument_list|(
name|unsigned
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|pending_siblings
operator|++
expr_stmt|;
name|NEXT_DIE_NUM
operator|=
name|next_unused_dienum
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pop the sibling stack so that the most recently pushed DIEnum becomes the    NEXT_DIE_NUM.  */
end_comment

begin_function
specifier|inline
name|void
name|dienum_pop
parameter_list|()
block|{
name|pending_siblings
operator|--
expr_stmt|;
block|}
end_function

begin_function
specifier|inline
name|tree
name|member_declared_type
parameter_list|(
name|member
parameter_list|)
specifier|register
name|tree
name|member
decl_stmt|;
block|{
return|return
operator|(
name|DECL_BIT_FIELD_TYPE
argument_list|(
name|member
argument_list|)
operator|)
condition|?
name|DECL_BIT_FIELD_TYPE
argument_list|(
name|member
argument_list|)
else|:
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Get the function's label, as described by its RTL.    This may be different from the DECL_NAME name used    in the source file.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|function_start_label
parameter_list|(
name|decl
parameter_list|)
specifier|register
name|tree
name|decl
decl_stmt|;
block|{
name|rtx
name|x
decl_stmt|;
name|char
modifier|*
name|fnname
decl_stmt|;
name|x
operator|=
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fnname
operator|=
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|fnname
return|;
block|}
end_function

begin_comment
comment|/******************************* DIEs ************************************/
end_comment

begin_comment
comment|/* Output routines for individual types of DIEs.  */
end_comment

begin_comment
comment|/* Note that every type of DIE (except a null DIE) gets a sibling.  */
end_comment

begin_function
specifier|static
name|void
name|output_array_type_die
parameter_list|(
name|arg
parameter_list|)
specifier|register
name|void
modifier|*
name|arg
decl_stmt|;
block|{
specifier|register
name|tree
name|type
init|=
name|arg
decl_stmt|;
name|ASM_OUTPUT_DWARF_TAG
argument_list|(
name|asm_out_file
argument_list|,
name|TAG_array_type
argument_list|)
expr_stmt|;
name|sibling_attribute
argument_list|()
expr_stmt|;
name|equate_type_number_to_die_number
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|member_attribute
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* I believe that we can default the array ordering.  SDB will probably      do the right things even if AT_ordering is not present.  It's not      even an issue until we start to get into multidimensional arrays      anyway.  If SDB is ever caught doing the Wrong Thing for multi-      dimensional arrays, then we'll have to put the AT_ordering attribute      back in.  (But if and when we find out that we need to put these in,      we will only do so for multidimensional arrays.  After all, we don't      want to waste space in the .debug section now do we?)  */
ifdef|#
directive|ifdef
name|USE_ORDERING_ATTRIBUTE
name|ordering_attribute
argument_list|(
name|ORD_row_major
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(USE_ORDERING_ATTRIBUTE) */
name|subscript_data_attribute
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_set_type_die
parameter_list|(
name|arg
parameter_list|)
specifier|register
name|void
modifier|*
name|arg
decl_stmt|;
block|{
specifier|register
name|tree
name|type
init|=
name|arg
decl_stmt|;
name|ASM_OUTPUT_DWARF_TAG
argument_list|(
name|asm_out_file
argument_list|,
name|TAG_set_type
argument_list|)
expr_stmt|;
name|sibling_attribute
argument_list|()
expr_stmt|;
name|equate_type_number_to_die_number
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|member_attribute
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|type_attribute
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Implement this when there is a GNU FORTRAN or GNU Ada front end.  */
end_comment

begin_endif
unit|static void output_entry_point_die (arg)      register void *arg; {   register tree decl = arg;   register tree origin = decl_ultimate_origin (decl);    ASM_OUTPUT_DWARF_TAG (asm_out_file, TAG_entry_point);   sibling_attribute ();   dienum_push ();   if (origin != NULL)     abstract_origin_attribute (origin);   else     {       name_and_src_coords_attributes (decl);       member_attribute (DECL_CONTEXT (decl));       type_attribute (TREE_TYPE (TREE_TYPE (decl)), 0, 0);     }   if (DECL_ABSTRACT (decl))     equate_decl_number_to_die_number (decl);   else     low_pc_attribute (function_start_label (decl)); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Output a DIE to represent an inlined instance of an enumeration type.  */
end_comment

begin_function
specifier|static
name|void
name|output_inlined_enumeration_type_die
parameter_list|(
name|arg
parameter_list|)
specifier|register
name|void
modifier|*
name|arg
decl_stmt|;
block|{
specifier|register
name|tree
name|type
init|=
name|arg
decl_stmt|;
name|ASM_OUTPUT_DWARF_TAG
argument_list|(
name|asm_out_file
argument_list|,
name|TAG_enumeration_type
argument_list|)
expr_stmt|;
name|sibling_attribute
argument_list|()
expr_stmt|;
name|assert
argument_list|(
name|TREE_ASM_WRITTEN
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|abstract_origin_attribute
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output a DIE to represent an inlined instance of a structure type.  */
end_comment

begin_function
specifier|static
name|void
name|output_inlined_structure_type_die
parameter_list|(
name|arg
parameter_list|)
specifier|register
name|void
modifier|*
name|arg
decl_stmt|;
block|{
specifier|register
name|tree
name|type
init|=
name|arg
decl_stmt|;
name|ASM_OUTPUT_DWARF_TAG
argument_list|(
name|asm_out_file
argument_list|,
name|TAG_structure_type
argument_list|)
expr_stmt|;
name|sibling_attribute
argument_list|()
expr_stmt|;
name|assert
argument_list|(
name|TREE_ASM_WRITTEN
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|abstract_origin_attribute
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output a DIE to represent an inlined instance of a union type.  */
end_comment

begin_function
specifier|static
name|void
name|output_inlined_union_type_die
parameter_list|(
name|arg
parameter_list|)
specifier|register
name|void
modifier|*
name|arg
decl_stmt|;
block|{
specifier|register
name|tree
name|type
init|=
name|arg
decl_stmt|;
name|ASM_OUTPUT_DWARF_TAG
argument_list|(
name|asm_out_file
argument_list|,
name|TAG_union_type
argument_list|)
expr_stmt|;
name|sibling_attribute
argument_list|()
expr_stmt|;
name|assert
argument_list|(
name|TREE_ASM_WRITTEN
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|abstract_origin_attribute
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output a DIE to represent an enumeration type.  Note that these DIEs    include all of the information about the enumeration values also.    This information is encoded into the element_list attribute.	 */
end_comment

begin_function
specifier|static
name|void
name|output_enumeration_type_die
parameter_list|(
name|arg
parameter_list|)
specifier|register
name|void
modifier|*
name|arg
decl_stmt|;
block|{
specifier|register
name|tree
name|type
init|=
name|arg
decl_stmt|;
name|ASM_OUTPUT_DWARF_TAG
argument_list|(
name|asm_out_file
argument_list|,
name|TAG_enumeration_type
argument_list|)
expr_stmt|;
name|sibling_attribute
argument_list|()
expr_stmt|;
name|equate_type_number_to_die_number
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|name_attribute
argument_list|(
name|type_tag
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|member_attribute
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Handle a GNU C/C++ extension, i.e. incomplete enum types.  If the      given enum type is incomplete, do not generate the AT_byte_size      attribute or the AT_element_list attribute.  */
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|byte_size_attribute
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|element_list_attribute
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output a DIE to represent either a real live formal parameter decl or    to represent just the type of some formal parameter position in some    function type.     Note that this routine is a bit unusual because its argument may be    a ..._DECL node (i.e. either a PARM_DECL or perhaps a VAR_DECL which    represents an inlining of some PARM_DECL) or else some sort of a    ..._TYPE node.  If it's the former then this function is being called    to output a DIE to represent a formal parameter object (or some inlining    thereof).  If it's the latter, then this function is only being called    to output a TAG_formal_parameter DIE to stand as a placeholder for some    formal argument type of some subprogram type.  */
end_comment

begin_function
specifier|static
name|void
name|output_formal_parameter_die
parameter_list|(
name|arg
parameter_list|)
specifier|register
name|void
modifier|*
name|arg
decl_stmt|;
block|{
specifier|register
name|tree
name|node
init|=
name|arg
decl_stmt|;
name|ASM_OUTPUT_DWARF_TAG
argument_list|(
name|asm_out_file
argument_list|,
name|TAG_formal_parameter
argument_list|)
expr_stmt|;
name|sibling_attribute
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
argument_list|)
condition|)
block|{
case|case
literal|'d'
case|:
comment|/* We were called with some kind of a ..._DECL node.  */
block|{
specifier|register
name|tree
name|origin
init|=
name|decl_ultimate_origin
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|origin
operator|!=
name|NULL
condition|)
name|abstract_origin_attribute
argument_list|(
name|origin
argument_list|)
expr_stmt|;
else|else
block|{
name|name_and_src_coords_attributes
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|type_attribute
argument_list|(
name|TREE_TYPE
argument_list|(
name|node
argument_list|)
argument_list|,
name|TREE_READONLY
argument_list|(
name|node
argument_list|)
argument_list|,
name|TREE_THIS_VOLATILE
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_ABSTRACT
argument_list|(
name|node
argument_list|)
condition|)
name|equate_decl_number_to_die_number
argument_list|(
name|node
argument_list|)
expr_stmt|;
else|else
name|location_or_const_value_attribute
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'t'
case|:
comment|/* We were called with some kind of a ..._TYPE node.  */
name|type_attribute
argument_list|(
name|node
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
comment|/* Should never happen.  */
block|}
block|}
end_function

begin_comment
comment|/* Output a DIE to represent a declared function (either file-scope    or block-local) which has "external linkage" (according to ANSI-C).  */
end_comment

begin_function
specifier|static
name|void
name|output_global_subroutine_die
parameter_list|(
name|arg
parameter_list|)
specifier|register
name|void
modifier|*
name|arg
decl_stmt|;
block|{
specifier|register
name|tree
name|decl
init|=
name|arg
decl_stmt|;
specifier|register
name|tree
name|origin
init|=
name|decl_ultimate_origin
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|ASM_OUTPUT_DWARF_TAG
argument_list|(
name|asm_out_file
argument_list|,
name|TAG_global_subroutine
argument_list|)
expr_stmt|;
name|sibling_attribute
argument_list|()
expr_stmt|;
name|dienum_push
argument_list|()
expr_stmt|;
if|if
condition|(
name|origin
operator|!=
name|NULL
condition|)
name|abstract_origin_attribute
argument_list|(
name|origin
argument_list|)
expr_stmt|;
else|else
block|{
specifier|register
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|name_and_src_coords_attributes
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|inline_attribute
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|prototyped_attribute
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|member_attribute
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|type_attribute
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pure_or_virtual_attribute
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_ABSTRACT
argument_list|(
name|decl
argument_list|)
condition|)
name|equate_decl_number_to_die_number
argument_list|(
name|decl
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|char
name|label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|low_pc_attribute
argument_list|(
name|function_start_label
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|label
argument_list|,
name|FUNC_END_LABEL_FMT
argument_list|,
name|current_funcdef_number
argument_list|)
expr_stmt|;
name|high_pc_attribute
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|label
argument_list|,
name|BODY_BEGIN_LABEL_FMT
argument_list|,
name|current_funcdef_number
argument_list|)
expr_stmt|;
name|body_begin_attribute
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|label
argument_list|,
name|BODY_END_LABEL_FMT
argument_list|,
name|current_funcdef_number
argument_list|)
expr_stmt|;
name|body_end_attribute
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Output a DIE to represent a declared data object (either file-scope    or block-local) which has "external linkage" (according to ANSI-C).  */
end_comment

begin_function
specifier|static
name|void
name|output_global_variable_die
parameter_list|(
name|arg
parameter_list|)
specifier|register
name|void
modifier|*
name|arg
decl_stmt|;
block|{
specifier|register
name|tree
name|decl
init|=
name|arg
decl_stmt|;
specifier|register
name|tree
name|origin
init|=
name|decl_ultimate_origin
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|ASM_OUTPUT_DWARF_TAG
argument_list|(
name|asm_out_file
argument_list|,
name|TAG_global_variable
argument_list|)
expr_stmt|;
name|sibling_attribute
argument_list|()
expr_stmt|;
if|if
condition|(
name|origin
operator|!=
name|NULL
condition|)
name|abstract_origin_attribute
argument_list|(
name|origin
argument_list|)
expr_stmt|;
else|else
block|{
name|name_and_src_coords_attributes
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|member_attribute
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|type_attribute
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_ABSTRACT
argument_list|(
name|decl
argument_list|)
condition|)
name|equate_decl_number_to_die_number
argument_list|(
name|decl
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
name|location_or_const_value_attribute
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|output_label_die
parameter_list|(
name|arg
parameter_list|)
specifier|register
name|void
modifier|*
name|arg
decl_stmt|;
block|{
specifier|register
name|tree
name|decl
init|=
name|arg
decl_stmt|;
specifier|register
name|tree
name|origin
init|=
name|decl_ultimate_origin
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|ASM_OUTPUT_DWARF_TAG
argument_list|(
name|asm_out_file
argument_list|,
name|TAG_label
argument_list|)
expr_stmt|;
name|sibling_attribute
argument_list|()
expr_stmt|;
if|if
condition|(
name|origin
operator|!=
name|NULL
condition|)
name|abstract_origin_attribute
argument_list|(
name|origin
argument_list|)
expr_stmt|;
else|else
name|name_and_src_coords_attributes
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_ABSTRACT
argument_list|(
name|decl
argument_list|)
condition|)
name|equate_decl_number_to_die_number
argument_list|(
name|decl
argument_list|)
expr_stmt|;
else|else
block|{
specifier|register
name|rtx
name|insn
init|=
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
block|{
name|char
name|label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
comment|/* When optimization is enabled (via -O) some parts of the compiler 	     (e.g. jump.c and cse.c) may try to delete CODE_LABEL insns which 	     represent source-level labels which were explicitly declared by 	     the user.  This really shouldn't be happening though, so catch 	     it if it ever does happen.  */
if|if
condition|(
name|INSN_DELETED_P
argument_list|(
name|insn
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Should never happen.  */
name|sprintf
argument_list|(
name|label
argument_list|,
name|INSN_LABEL_FMT
argument_list|,
name|current_funcdef_number
argument_list|,
operator|(
name|unsigned
operator|)
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|low_pc_attribute
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|output_lexical_block_die
parameter_list|(
name|arg
parameter_list|)
specifier|register
name|void
modifier|*
name|arg
decl_stmt|;
block|{
specifier|register
name|tree
name|stmt
init|=
name|arg
decl_stmt|;
name|ASM_OUTPUT_DWARF_TAG
argument_list|(
name|asm_out_file
argument_list|,
name|TAG_lexical_block
argument_list|)
expr_stmt|;
name|sibling_attribute
argument_list|()
expr_stmt|;
name|dienum_push
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|BLOCK_ABSTRACT
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
name|char
name|begin_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|char
name|end_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|begin_label
argument_list|,
name|BLOCK_BEGIN_LABEL_FMT
argument_list|,
name|next_block_number
argument_list|)
expr_stmt|;
name|low_pc_attribute
argument_list|(
name|begin_label
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|end_label
argument_list|,
name|BLOCK_END_LABEL_FMT
argument_list|,
name|next_block_number
argument_list|)
expr_stmt|;
name|high_pc_attribute
argument_list|(
name|end_label
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|output_inlined_subroutine_die
parameter_list|(
name|arg
parameter_list|)
specifier|register
name|void
modifier|*
name|arg
decl_stmt|;
block|{
specifier|register
name|tree
name|stmt
init|=
name|arg
decl_stmt|;
name|ASM_OUTPUT_DWARF_TAG
argument_list|(
name|asm_out_file
argument_list|,
name|TAG_inlined_subroutine
argument_list|)
expr_stmt|;
name|sibling_attribute
argument_list|()
expr_stmt|;
name|dienum_push
argument_list|()
expr_stmt|;
name|abstract_origin_attribute
argument_list|(
name|block_ultimate_origin
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|BLOCK_ABSTRACT
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
name|char
name|begin_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|char
name|end_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|begin_label
argument_list|,
name|BLOCK_BEGIN_LABEL_FMT
argument_list|,
name|next_block_number
argument_list|)
expr_stmt|;
name|low_pc_attribute
argument_list|(
name|begin_label
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|end_label
argument_list|,
name|BLOCK_END_LABEL_FMT
argument_list|,
name|next_block_number
argument_list|)
expr_stmt|;
name|high_pc_attribute
argument_list|(
name|end_label
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output a DIE to represent a declared data object (either file-scope    or block-local) which has "internal linkage" (according to ANSI-C).  */
end_comment

begin_function
specifier|static
name|void
name|output_local_variable_die
parameter_list|(
name|arg
parameter_list|)
specifier|register
name|void
modifier|*
name|arg
decl_stmt|;
block|{
specifier|register
name|tree
name|decl
init|=
name|arg
decl_stmt|;
specifier|register
name|tree
name|origin
init|=
name|decl_ultimate_origin
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|ASM_OUTPUT_DWARF_TAG
argument_list|(
name|asm_out_file
argument_list|,
name|TAG_local_variable
argument_list|)
expr_stmt|;
name|sibling_attribute
argument_list|()
expr_stmt|;
if|if
condition|(
name|origin
operator|!=
name|NULL
condition|)
name|abstract_origin_attribute
argument_list|(
name|origin
argument_list|)
expr_stmt|;
else|else
block|{
name|name_and_src_coords_attributes
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|member_attribute
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|type_attribute
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_ABSTRACT
argument_list|(
name|decl
argument_list|)
condition|)
name|equate_decl_number_to_die_number
argument_list|(
name|decl
argument_list|)
expr_stmt|;
else|else
name|location_or_const_value_attribute
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_member_die
parameter_list|(
name|arg
parameter_list|)
specifier|register
name|void
modifier|*
name|arg
decl_stmt|;
block|{
specifier|register
name|tree
name|decl
init|=
name|arg
decl_stmt|;
name|ASM_OUTPUT_DWARF_TAG
argument_list|(
name|asm_out_file
argument_list|,
name|TAG_member
argument_list|)
expr_stmt|;
name|sibling_attribute
argument_list|()
expr_stmt|;
name|name_and_src_coords_attributes
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|member_attribute
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|type_attribute
argument_list|(
name|member_declared_type
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_BIT_FIELD_TYPE
argument_list|(
name|decl
argument_list|)
condition|)
comment|/* If this is a bit field... */
block|{
name|byte_size_attribute
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|bit_size_attribute
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|bit_offset_attribute
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
name|data_member_location_attribute
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Don't generate either pointer_type DIEs or reference_type DIEs.  Use    modified types instead.     We keep this code here just in case these types of DIEs may be needed    to represent certain things in other languages (e.g. Pascal) someday. */
end_comment

begin_endif
unit|static void output_pointer_type_die (arg)      register void *arg; {   register tree type = arg;    ASM_OUTPUT_DWARF_TAG (asm_out_file, TAG_pointer_type);   sibling_attribute ();   equate_type_number_to_die_number (type);   member_attribute (TYPE_CONTEXT (type));   type_attribute (TREE_TYPE (type), 0, 0); }  static void output_reference_type_die (arg)      register void *arg; {   register tree type = arg;    ASM_OUTPUT_DWARF_TAG (asm_out_file, TAG_reference_type);   sibling_attribute ();   equate_type_number_to_die_number (type);   member_attribute (TYPE_CONTEXT (type));   type_attribute (TREE_TYPE (type), 0, 0); }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|output_ptr_to_mbr_type_die
parameter_list|(
name|arg
parameter_list|)
specifier|register
name|void
modifier|*
name|arg
decl_stmt|;
block|{
specifier|register
name|tree
name|type
init|=
name|arg
decl_stmt|;
name|ASM_OUTPUT_DWARF_TAG
argument_list|(
name|asm_out_file
argument_list|,
name|TAG_ptr_to_member_type
argument_list|)
expr_stmt|;
name|sibling_attribute
argument_list|()
expr_stmt|;
name|equate_type_number_to_die_number
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|member_attribute
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|containing_type_attribute
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|type_attribute
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_compile_unit_die
parameter_list|(
name|arg
parameter_list|)
specifier|register
name|void
modifier|*
name|arg
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|main_input_filename
init|=
name|arg
decl_stmt|;
name|ASM_OUTPUT_DWARF_TAG
argument_list|(
name|asm_out_file
argument_list|,
name|TAG_compile_unit
argument_list|)
expr_stmt|;
name|sibling_attribute
argument_list|()
expr_stmt|;
name|dienum_push
argument_list|()
expr_stmt|;
name|name_attribute
argument_list|(
name|main_input_filename
argument_list|)
expr_stmt|;
block|{
name|char
name|producer
index|[
literal|250
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|producer
argument_list|,
literal|"%s %s"
argument_list|,
name|language_string
argument_list|,
name|version_string
argument_list|)
expr_stmt|;
name|producer_attribute
argument_list|(
name|producer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|language_string
argument_list|,
literal|"GNU C++"
argument_list|)
operator|==
literal|0
condition|)
name|language_attribute
argument_list|(
name|LANG_C_PLUS_PLUS
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|language_string
argument_list|,
literal|"GNU Ada"
argument_list|)
operator|==
literal|0
condition|)
name|language_attribute
argument_list|(
name|LANG_ADA83
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|language_string
argument_list|,
literal|"GNU F77"
argument_list|)
operator|==
literal|0
condition|)
name|language_attribute
argument_list|(
name|LANG_FORTRAN77
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flag_traditional
condition|)
name|language_attribute
argument_list|(
name|LANG_C
argument_list|)
expr_stmt|;
else|else
name|language_attribute
argument_list|(
name|LANG_C89
argument_list|)
expr_stmt|;
name|low_pc_attribute
argument_list|(
name|TEXT_BEGIN_LABEL
argument_list|)
expr_stmt|;
name|high_pc_attribute
argument_list|(
name|TEXT_END_LABEL
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_info_level
operator|>=
name|DINFO_LEVEL_NORMAL
condition|)
name|stmt_list_attribute
argument_list|(
name|LINE_BEGIN_LABEL
argument_list|)
expr_stmt|;
name|last_filename
operator|=
name|xstrdup
argument_list|(
name|main_input_filename
argument_list|)
expr_stmt|;
block|{
name|char
modifier|*
name|wd
init|=
name|getpwd
argument_list|()
decl_stmt|;
if|if
condition|(
name|wd
condition|)
name|comp_dir_attribute
argument_list|(
name|wd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|debug_info_level
operator|>=
name|DINFO_LEVEL_NORMAL
condition|)
block|{
name|sf_names_attribute
argument_list|(
name|SFNAMES_BEGIN_LABEL
argument_list|)
expr_stmt|;
name|src_info_attribute
argument_list|(
name|SRCINFO_BEGIN_LABEL
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_info_level
operator|>=
name|DINFO_LEVEL_VERBOSE
condition|)
name|mac_info_attribute
argument_list|(
name|MACINFO_BEGIN_LABEL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|output_string_type_die
parameter_list|(
name|arg
parameter_list|)
specifier|register
name|void
modifier|*
name|arg
decl_stmt|;
block|{
specifier|register
name|tree
name|type
init|=
name|arg
decl_stmt|;
name|ASM_OUTPUT_DWARF_TAG
argument_list|(
name|asm_out_file
argument_list|,
name|TAG_string_type
argument_list|)
expr_stmt|;
name|sibling_attribute
argument_list|()
expr_stmt|;
name|member_attribute
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fudge the string length attribute for now.  */
name|string_length_attribute
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_structure_type_die
parameter_list|(
name|arg
parameter_list|)
specifier|register
name|void
modifier|*
name|arg
decl_stmt|;
block|{
specifier|register
name|tree
name|type
init|=
name|arg
decl_stmt|;
name|ASM_OUTPUT_DWARF_TAG
argument_list|(
name|asm_out_file
argument_list|,
name|TAG_structure_type
argument_list|)
expr_stmt|;
name|sibling_attribute
argument_list|()
expr_stmt|;
name|equate_type_number_to_die_number
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|name_attribute
argument_list|(
name|type_tag
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|member_attribute
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this type has been completed, then give it a byte_size attribute      and prepare to give a list of members.  Otherwise, don't do either of      these things.  In the latter case, we will not be generating a list      of members (since we don't have any idea what they might be for an      incomplete type).	*/
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|dienum_push
argument_list|()
expr_stmt|;
name|byte_size_attribute
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output a DIE to represent a declared function (either file-scope    or block-local) which has "internal linkage" (according to ANSI-C).  */
end_comment

begin_function
specifier|static
name|void
name|output_local_subroutine_die
parameter_list|(
name|arg
parameter_list|)
specifier|register
name|void
modifier|*
name|arg
decl_stmt|;
block|{
specifier|register
name|tree
name|decl
init|=
name|arg
decl_stmt|;
specifier|register
name|tree
name|origin
init|=
name|decl_ultimate_origin
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|ASM_OUTPUT_DWARF_TAG
argument_list|(
name|asm_out_file
argument_list|,
name|TAG_subroutine
argument_list|)
expr_stmt|;
name|sibling_attribute
argument_list|()
expr_stmt|;
name|dienum_push
argument_list|()
expr_stmt|;
if|if
condition|(
name|origin
operator|!=
name|NULL
condition|)
name|abstract_origin_attribute
argument_list|(
name|origin
argument_list|)
expr_stmt|;
else|else
block|{
specifier|register
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|name_and_src_coords_attributes
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|inline_attribute
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|prototyped_attribute
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|member_attribute
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|type_attribute
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pure_or_virtual_attribute
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_ABSTRACT
argument_list|(
name|decl
argument_list|)
condition|)
name|equate_decl_number_to_die_number
argument_list|(
name|decl
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Avoid getting screwed up in cases where a function was declared 	 static but where no definition was ever given for it.  */
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|char
name|label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|low_pc_attribute
argument_list|(
name|function_start_label
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|label
argument_list|,
name|FUNC_END_LABEL_FMT
argument_list|,
name|current_funcdef_number
argument_list|)
expr_stmt|;
name|high_pc_attribute
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|label
argument_list|,
name|BODY_BEGIN_LABEL_FMT
argument_list|,
name|current_funcdef_number
argument_list|)
expr_stmt|;
name|body_begin_attribute
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|label
argument_list|,
name|BODY_END_LABEL_FMT
argument_list|,
name|current_funcdef_number
argument_list|)
expr_stmt|;
name|body_end_attribute
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|output_subroutine_type_die
parameter_list|(
name|arg
parameter_list|)
specifier|register
name|void
modifier|*
name|arg
decl_stmt|;
block|{
specifier|register
name|tree
name|type
init|=
name|arg
decl_stmt|;
specifier|register
name|tree
name|return_type
init|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|ASM_OUTPUT_DWARF_TAG
argument_list|(
name|asm_out_file
argument_list|,
name|TAG_subroutine_type
argument_list|)
expr_stmt|;
name|sibling_attribute
argument_list|()
expr_stmt|;
name|dienum_push
argument_list|()
expr_stmt|;
name|equate_type_number_to_die_number
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|prototyped_attribute
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|member_attribute
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|type_attribute
argument_list|(
name|return_type
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_typedef_die
parameter_list|(
name|arg
parameter_list|)
specifier|register
name|void
modifier|*
name|arg
decl_stmt|;
block|{
specifier|register
name|tree
name|decl
init|=
name|arg
decl_stmt|;
specifier|register
name|tree
name|origin
init|=
name|decl_ultimate_origin
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|ASM_OUTPUT_DWARF_TAG
argument_list|(
name|asm_out_file
argument_list|,
name|TAG_typedef
argument_list|)
expr_stmt|;
name|sibling_attribute
argument_list|()
expr_stmt|;
if|if
condition|(
name|origin
operator|!=
name|NULL
condition|)
name|abstract_origin_attribute
argument_list|(
name|origin
argument_list|)
expr_stmt|;
else|else
block|{
name|name_and_src_coords_attributes
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|member_attribute
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|type_attribute
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_ABSTRACT
argument_list|(
name|decl
argument_list|)
condition|)
name|equate_decl_number_to_die_number
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_union_type_die
parameter_list|(
name|arg
parameter_list|)
specifier|register
name|void
modifier|*
name|arg
decl_stmt|;
block|{
specifier|register
name|tree
name|type
init|=
name|arg
decl_stmt|;
name|ASM_OUTPUT_DWARF_TAG
argument_list|(
name|asm_out_file
argument_list|,
name|TAG_union_type
argument_list|)
expr_stmt|;
name|sibling_attribute
argument_list|()
expr_stmt|;
name|equate_type_number_to_die_number
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|name_attribute
argument_list|(
name|type_tag
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|member_attribute
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this type has been completed, then give it a byte_size attribute      and prepare to give a list of members.  Otherwise, don't do either of      these things.  In the latter case, we will not be generating a list      of members (since we don't have any idea what they might be for an      incomplete type).	*/
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|dienum_push
argument_list|()
expr_stmt|;
name|byte_size_attribute
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate a special type of DIE used as a stand-in for a trailing ellipsis    at the end of an (ANSI prototyped) formal parameters list.  */
end_comment

begin_function
specifier|static
name|void
name|output_unspecified_parameters_die
parameter_list|(
name|arg
parameter_list|)
specifier|register
name|void
modifier|*
name|arg
decl_stmt|;
block|{
specifier|register
name|tree
name|decl_or_type
init|=
name|arg
decl_stmt|;
name|ASM_OUTPUT_DWARF_TAG
argument_list|(
name|asm_out_file
argument_list|,
name|TAG_unspecified_parameters
argument_list|)
expr_stmt|;
name|sibling_attribute
argument_list|()
expr_stmt|;
comment|/* This kludge is here only for the sake of being compatible with what      the USL CI5 C compiler does.  The specification of Dwarf Version 1      doesn't say that TAG_unspecified_parameters DIEs should contain any      attributes other than the AT_sibling attribute, but they are certainly      allowed to contain additional attributes, and the CI5 compiler      generates AT_name, AT_fund_type, and AT_location attributes within      TAG_unspecified_parameters DIEs which appear in the child lists for      DIEs representing function definitions, so we do likewise here.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl_or_type
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl_or_type
argument_list|)
condition|)
block|{
name|name_attribute
argument_list|(
literal|"..."
argument_list|)
expr_stmt|;
name|fund_type_attribute
argument_list|(
name|FT_pointer
argument_list|)
expr_stmt|;
comment|/* location_attribute (?); */
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|output_padded_null_die
parameter_list|(
name|arg
parameter_list|)
specifier|register
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* 2**2 == 4 */
block|}
end_function

begin_comment
comment|/*************************** end of DIEs *********************************/
end_comment

begin_comment
comment|/* Generate some type of DIE.  This routine generates the generic outer    wrapper stuff which goes around all types of DIE's (regardless of their    TAGs.  All forms of DIEs start with a DIE-specific label, followed by a    DIE-length word, followed by the guts of the DIE itself.  After the guts    of the DIE, there must always be a terminator label for the DIE.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|output_die
argument_list|(
name|die_specific_output_function
argument_list|,
name|param
argument_list|)
decl|register
name|void
argument_list|(
operator|*
name|die_specific_output_function
argument_list|)
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|void
modifier|*
name|param
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|begin_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|char
name|end_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|current_dienum
operator|=
name|NEXT_DIE_NUM
expr_stmt|;
name|NEXT_DIE_NUM
operator|=
name|next_unused_dienum
expr_stmt|;
name|sprintf
argument_list|(
name|begin_label
argument_list|,
name|DIE_BEGIN_LABEL_FMT
argument_list|,
name|current_dienum
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|end_label
argument_list|,
name|DIE_END_LABEL_FMT
argument_list|,
name|current_dienum
argument_list|)
expr_stmt|;
comment|/* Write a label which will act as the name for the start of this DIE.  */
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|begin_label
argument_list|)
expr_stmt|;
comment|/* Write the DIE-length word.	 */
name|ASM_OUTPUT_DWARF_DELTA4
argument_list|(
name|asm_out_file
argument_list|,
name|end_label
argument_list|,
name|begin_label
argument_list|)
expr_stmt|;
comment|/* Fill in the guts of the DIE.  */
name|next_unused_dienum
operator|++
expr_stmt|;
name|die_specific_output_function
argument_list|(
name|param
argument_list|)
expr_stmt|;
comment|/* Write a label which will act as the name for the end of this DIE.	*/
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|end_label
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|end_sibling_chain
parameter_list|()
block|{
name|char
name|begin_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|current_dienum
operator|=
name|NEXT_DIE_NUM
expr_stmt|;
name|NEXT_DIE_NUM
operator|=
name|next_unused_dienum
expr_stmt|;
name|sprintf
argument_list|(
name|begin_label
argument_list|,
name|DIE_BEGIN_LABEL_FMT
argument_list|,
name|current_dienum
argument_list|)
expr_stmt|;
comment|/* Write a label which will act as the name for the start of this DIE.  */
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|begin_label
argument_list|)
expr_stmt|;
comment|/* Write the DIE-length word.	 */
name|ASM_OUTPUT_DWARF_DATA4
argument_list|(
name|asm_out_file
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|dienum_pop
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate a list of nameless TAG_formal_parameter DIEs (and perhaps a    TAG_unspecified_parameters DIE) to represent the types of the formal    parameters as specified in some function type specification (except    for those which appear as part of a function *definition*).     Note that we must be careful here to output all of the parameter DIEs    *before* we output any DIEs needed to represent the types of the formal    parameters.  This keeps svr4 SDB happy because it (incorrectly) thinks    that the first non-parameter DIE it sees ends the formal parameter list. */
end_comment

begin_function
specifier|static
name|void
name|output_formal_types
parameter_list|(
name|function_or_method_type
parameter_list|)
specifier|register
name|tree
name|function_or_method_type
decl_stmt|;
block|{
specifier|register
name|tree
name|link
decl_stmt|;
specifier|register
name|tree
name|formal_type
init|=
name|NULL
decl_stmt|;
specifier|register
name|tree
name|first_parm_type
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|function_or_method_type
argument_list|)
decl_stmt|;
comment|/* In the case where we are generating a formal types list for a C++      non-static member function type, skip over the first thing on the      TYPE_ARG_TYPES list because it only represents the type of the      hidden `this pointer'.  The debugger should be able to figure      out (without being explicitly told) that this non-static member      function type takes a `this pointer' and should be able to figure      what the type of that hidden parameter is from the AT_member      attribute of the parent TAG_subroutine_type DIE.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function_or_method_type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|first_parm_type
operator|=
name|TREE_CHAIN
argument_list|(
name|first_parm_type
argument_list|)
expr_stmt|;
comment|/* Make our first pass over the list of formal parameter types and output      a TAG_formal_parameter DIE for each one.  */
for|for
control|(
name|link
operator|=
name|first_parm_type
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
name|formal_type
operator|=
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|formal_type
operator|==
name|void_type_node
condition|)
break|break;
comment|/* Output a (nameless) DIE to represent the formal parameter itself.  */
name|output_die
argument_list|(
name|output_formal_parameter_die
argument_list|,
name|formal_type
argument_list|)
expr_stmt|;
block|}
comment|/* If this function type has an ellipsis, add a TAG_unspecified_parameters      DIE to the end of the parameter list.  */
if|if
condition|(
name|formal_type
operator|!=
name|void_type_node
condition|)
name|output_die
argument_list|(
name|output_unspecified_parameters_die
argument_list|,
name|function_or_method_type
argument_list|)
expr_stmt|;
comment|/* Make our second (and final) pass over the list of formal parameter types      and output DIEs to represent those types (as necessary).  */
for|for
control|(
name|link
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|function_or_method_type
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
name|formal_type
operator|=
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|formal_type
operator|==
name|void_type_node
condition|)
break|break;
name|output_type
argument_list|(
name|formal_type
argument_list|,
name|function_or_method_type
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Remember a type in the pending_types_list.  */
end_comment

begin_function
specifier|static
name|void
name|pend_type
parameter_list|(
name|type
parameter_list|)
specifier|register
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|pending_types
operator|==
name|pending_types_allocated
condition|)
block|{
name|pending_types_allocated
operator|+=
name|PENDING_TYPES_INCREMENT
expr_stmt|;
name|pending_types_list
operator|=
operator|(
name|tree
operator|*
operator|)
name|xrealloc
argument_list|(
name|pending_types_list
argument_list|,
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
operator|*
name|pending_types_allocated
argument_list|)
expr_stmt|;
block|}
name|pending_types_list
index|[
name|pending_types
operator|++
index|]
operator|=
name|type
expr_stmt|;
comment|/* Mark the pending type as having been output already (even though      it hasn't been).  This prevents the type from being added to the      pending_types_list more than once.  */
name|TREE_ASM_WRITTEN
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return non-zero if it is legitimate to output DIEs to represent a    given type while we are generating the list of child DIEs for some    DIE (e.g. a function or lexical block DIE) associated with a given scope.     See the comments within the function for a description of when it is    considered legitimate to output DIEs for various kinds of types.     Note that TYPE_CONTEXT(type) may be NULL (to indicate global scope)    or it may point to a BLOCK node (for types local to a block), or to a    FUNCTION_DECL node (for types local to the heading of some function    definition), or to a FUNCTION_TYPE node (for types local to the    prototyped parameter list of a function type specification), or to a    RECORD_TYPE, UNION_TYPE, or QUAL_UNION_TYPE node    (in the case of C++ nested types).     The `scope' parameter should likewise be NULL or should point to a    BLOCK node, a FUNCTION_DECL node, a FUNCTION_TYPE node, a RECORD_TYPE    node, a UNION_TYPE node, or a QUAL_UNION_TYPE node.     This function is used only for deciding when to "pend" and when to    "un-pend" types to/from the pending_types_list.     Note that we sometimes make use of this "type pending" feature in a    rather twisted way to temporarily delay the production of DIEs for the    types of formal parameters.  (We do this just to make svr4 SDB happy.)    It order to delay the production of DIEs representing types of formal    parameters, callers of this function supply `fake_containing_scope' as    the `scope' parameter to this function.  Given that fake_containing_scope    is a tagged type which is *not* the containing scope for *any* other type,    the desired effect is achieved, i.e. output of DIEs representing types    is temporarily suspended, and any type DIEs which would have otherwise    been output are instead placed onto the pending_types_list.  Later on,    we force these (temporarily pended) types to be output simply by calling    `output_pending_types_for_scope' with an actual argument equal to the    true scope of the types we temporarily pended. */
end_comment

begin_function
specifier|inline
name|int
name|type_ok_for_scope
parameter_list|(
name|type
parameter_list|,
name|scope
parameter_list|)
specifier|register
name|tree
name|type
decl_stmt|;
specifier|register
name|tree
name|scope
decl_stmt|;
block|{
comment|/* Tagged types (i.e. struct, union, and enum types) must always be      output only in the scopes where they actually belong (or else the      scoping of their own tag names and the scoping of their member      names will be incorrect).  Non-tagged-types on the other hand can      generally be output anywhere, except that svr4 SDB really doesn't      want to see them nested within struct or union types, so here we      say it is always OK to immediately output any such a (non-tagged)      type, so long as we are not within such a context.  Note that the      only kinds of non-tagged types which we will be dealing with here      (for C and C++ anyway) will be array types and function types.  */
return|return
name|is_tagged_type
argument_list|(
name|type
argument_list|)
condition|?
operator|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
operator|==
name|scope
operator|)
else|:
operator|(
name|scope
operator|==
name|NULL_TREE
operator|||
operator|!
name|is_tagged_type
argument_list|(
name|scope
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Output any pending types (from the pending_types list) which we can output    now (taking into account the scope that we are working on now).     For each type output, remove the given type from the pending_types_list    *before* we try to output it.     Note that we have to process the list in beginning-to-end order,    because the call made here to output_type may cause yet more types    to be added to the end of the list, and we may have to output some    of them too. */
end_comment

begin_function
specifier|static
name|void
name|output_pending_types_for_scope
parameter_list|(
name|containing_scope
parameter_list|)
specifier|register
name|tree
name|containing_scope
decl_stmt|;
block|{
specifier|register
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pending_types
condition|;
control|)
block|{
specifier|register
name|tree
name|type
init|=
name|pending_types_list
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|type_ok_for_scope
argument_list|(
name|type
argument_list|,
name|containing_scope
argument_list|)
condition|)
block|{
specifier|register
name|tree
modifier|*
name|mover
decl_stmt|;
specifier|register
name|tree
modifier|*
name|limit
decl_stmt|;
name|pending_types
operator|--
expr_stmt|;
name|limit
operator|=
operator|&
name|pending_types_list
index|[
name|pending_types
index|]
expr_stmt|;
for|for
control|(
name|mover
operator|=
operator|&
name|pending_types_list
index|[
name|i
index|]
init|;
name|mover
operator|<
name|limit
condition|;
name|mover
operator|++
control|)
operator|*
name|mover
operator|=
operator|*
operator|(
name|mover
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* Un-mark the type as having been output already (because it 	     hasn't been, really).  Then call output_type to generate a 	     Dwarf representation of it.  */
name|TREE_ASM_WRITTEN
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
name|output_type
argument_list|(
name|type
argument_list|,
name|containing_scope
argument_list|)
expr_stmt|;
comment|/* Don't increment the loop counter in this case because we 	     have shifted all of the subsequent pending types down one 	     element in the pending_types_list array.  */
block|}
else|else
name|i
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|output_type
parameter_list|(
name|type
parameter_list|,
name|containing_scope
parameter_list|)
specifier|register
name|tree
name|type
decl_stmt|;
specifier|register
name|tree
name|containing_scope
decl_stmt|;
block|{
if|if
condition|(
name|type
operator|==
literal|0
operator|||
name|type
operator|==
name|error_mark_node
condition|)
return|return;
comment|/* We are going to output a DIE to represent the unqualified version of      of this type (i.e. without any const or volatile qualifiers) so get      the main variant (i.e. the unqualified version) of this type now.  */
name|type
operator|=
name|type_main_variant
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|type
argument_list|)
condition|)
return|return;
comment|/* Don't generate any DIEs for this type now unless it is OK to do so      (based upon what `type_ok_for_scope' tells us).  */
if|if
condition|(
operator|!
name|type_ok_for_scope
argument_list|(
name|type
argument_list|,
name|containing_scope
argument_list|)
condition|)
block|{
name|pend_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|ERROR_MARK
case|:
break|break;
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
comment|/* For these types, all that is required is that we output a DIE 	   (or a set of DIEs) to represent the "basis" type.  */
name|output_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|containing_scope
argument_list|)
expr_stmt|;
break|break;
case|case
name|OFFSET_TYPE
case|:
comment|/* This code is used for C++ pointer-to-data-member types.  */
comment|/* Output a description of the relevant class type.  */
name|output_type
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|containing_scope
argument_list|)
expr_stmt|;
comment|/* Output a description of the type of the object pointed to.  */
name|output_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|containing_scope
argument_list|)
expr_stmt|;
comment|/* Now output a DIE to represent this pointer-to-data-member type 	   itself.  */
name|output_die
argument_list|(
name|output_ptr_to_mbr_type_die
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|SET_TYPE
case|:
name|output_type
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|,
name|containing_scope
argument_list|)
expr_stmt|;
name|output_die
argument_list|(
name|output_set_type_die
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|FILE_TYPE
case|:
name|output_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|containing_scope
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
comment|/* No way to represent these in Dwarf yet!  */
break|break;
case|case
name|FUNCTION_TYPE
case|:
comment|/* Force out return type (in case it wasn't forced out already).  */
name|output_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|containing_scope
argument_list|)
expr_stmt|;
name|output_die
argument_list|(
name|output_subroutine_type_die
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|output_formal_types
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|end_sibling_chain
argument_list|()
expr_stmt|;
break|break;
case|case
name|METHOD_TYPE
case|:
comment|/* Force out return type (in case it wasn't forced out already).  */
name|output_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|containing_scope
argument_list|)
expr_stmt|;
name|output_die
argument_list|(
name|output_subroutine_type_die
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|output_formal_types
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|end_sibling_chain
argument_list|()
expr_stmt|;
break|break;
case|case
name|ARRAY_TYPE
case|:
if|if
condition|(
name|TYPE_STRING_FLAG
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|CHAR_TYPE
condition|)
block|{
name|output_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|containing_scope
argument_list|)
expr_stmt|;
name|output_die
argument_list|(
name|output_string_type_die
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|tree
name|element_type
decl_stmt|;
name|element_type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|element_type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|element_type
operator|=
name|TREE_TYPE
argument_list|(
name|element_type
argument_list|)
expr_stmt|;
name|output_type
argument_list|(
name|element_type
argument_list|,
name|containing_scope
argument_list|)
expr_stmt|;
name|output_die
argument_list|(
name|output_array_type_die
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|QUAL_UNION_TYPE
case|:
comment|/* For a non-file-scope tagged type, we can always go ahead and 	   output a Dwarf description of this type right now, even if 	   the type in question is still incomplete, because if this 	   local type *was* ever completed anywhere within its scope, 	   that complete definition would already have been attached to 	   this RECORD_TYPE, UNION_TYPE, QUAL_UNION_TYPE or ENUMERAL_TYPE 	   node by the time we reach this point.  That's true because of the 	   way the front-end does its processing of file-scope declarations (of 	   functions and class types) within which other types might be 	   nested.  The C and C++ front-ends always gobble up such "local 	   scope" things en-mass before they try to output *any* debugging 	   information for any of the stuff contained inside them and thus, 	   we get the benefit here of what is (in effect) a pre-resolution 	   of forward references to tagged types in local scopes.  	   Note however that for file-scope tagged types we cannot assume 	   that such pre-resolution of forward references has taken place. 	   A given file-scope tagged type may appear to be incomplete when 	   we reach this point, but it may yet be given a full definition 	   (at file-scope) later on during compilation.  In order to avoid 	   generating a premature (and possibly incorrect) set of Dwarf 	   DIEs for such (as yet incomplete) file-scope tagged types, we 	   generate nothing at all for as-yet incomplete file-scope tagged 	   types here unless we are making our special "finalization" pass 	   for file-scope things at the very end of compilation.  At that 	   time, we will certainly know as much about each file-scope tagged 	   type as we are ever going to know, so at that point in time, we 	   can safely generate correct Dwarf descriptions for these file- 	   scope tagged types. 	*/
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|==
literal|0
operator|&&
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
operator|==
name|NULL
operator|&&
operator|!
name|finalizing
condition|)
return|return;
comment|/* EARLY EXIT!  Avoid setting TREE_ASM_WRITTEN.  */
comment|/* Prevent infinite recursion in cases where the type of some 	   member of this type is expressed in terms of this type itself.  */
name|TREE_ASM_WRITTEN
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Output a DIE to represent the tagged type itself.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|ENUMERAL_TYPE
case|:
name|output_die
argument_list|(
name|output_enumeration_type_die
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return;
comment|/* a special case -- nothing left to do so just return */
case|case
name|RECORD_TYPE
case|:
name|output_die
argument_list|(
name|output_structure_type_die
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNION_TYPE
case|:
case|case
name|QUAL_UNION_TYPE
case|:
name|output_die
argument_list|(
name|output_union_type_die
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
comment|/* Should never happen.  */
block|}
comment|/* If this is not an incomplete type, output descriptions of 	   each of its members.  	   Note that as we output the DIEs necessary to represent the 	   members of this record or union type, we will also be trying 	   to output DIEs to represent the *types* of those members. 	   However the `output_type' function (above) will specifically 	   avoid generating type DIEs for member types *within* the list 	   of member DIEs for this (containing) type execpt for those 	   types (of members) which are explicitly marked as also being 	   members of this (containing) type themselves.  The g++ front- 	   end can force any given type to be treated as a member of some 	   other (containing) type by setting the TYPE_CONTEXT of the 	   given (member) type to point to the TREE node representing the 	   appropriate (containing) type. 	*/
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
condition|)
block|{
block|{
specifier|register
name|tree
name|normal_member
decl_stmt|;
comment|/* First output info about the data members and type members.  */
for|for
control|(
name|normal_member
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|normal_member
condition|;
name|normal_member
operator|=
name|TREE_CHAIN
argument_list|(
name|normal_member
argument_list|)
control|)
name|output_decl
argument_list|(
name|normal_member
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|{
specifier|register
name|tree
name|vec_base
decl_stmt|;
comment|/* Now output info about the function members (if any).  */
name|vec_base
operator|=
name|TYPE_METHODS
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|vec_base
condition|)
block|{
specifier|register
name|tree
name|first_func_member
init|=
name|TREE_VEC_ELT
argument_list|(
name|vec_base
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|func_member
decl_stmt|;
comment|/* This isn't documented, but the first element of the 		     vector of member functions can be NULL in cases where 		     the class type in question didn't have either a 		     constructor or a destructor declared for it.  We have 		     to make allowances for that here.  */
if|if
condition|(
name|first_func_member
operator|==
name|NULL
condition|)
name|first_func_member
operator|=
name|TREE_VEC_ELT
argument_list|(
name|vec_base
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|func_member
operator|=
name|first_func_member
init|;
name|func_member
condition|;
name|func_member
operator|=
name|TREE_CHAIN
argument_list|(
name|func_member
argument_list|)
control|)
name|output_decl
argument_list|(
name|func_member
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* RECORD_TYPEs, UNION_TYPEs, and QUAL_UNION_TYPEs are themselves 	       scopes (at least in C++) so we must now output any nested 	       pending types which are local just to this type.  */
name|output_pending_types_for_scope
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|end_sibling_chain
argument_list|()
expr_stmt|;
comment|/* Terminate member chain.  */
block|}
break|break;
case|case
name|VOID_TYPE
case|:
case|case
name|INTEGER_TYPE
case|:
case|case
name|REAL_TYPE
case|:
case|case
name|COMPLEX_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
case|case
name|CHAR_TYPE
case|:
break|break;
comment|/* No DIEs needed for fundamental types.  */
case|case
name|LANG_TYPE
case|:
comment|/* No Dwarf representation currently defined.  */
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|TREE_ASM_WRITTEN
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_tagged_type_instantiation
parameter_list|(
name|type
parameter_list|)
specifier|register
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|type
operator|==
literal|0
operator|||
name|type
operator|==
name|error_mark_node
condition|)
return|return;
comment|/* We are going to output a DIE to represent the unqualified version of      of this type (i.e. without any const or volatile qualifiers) so make      sure that we have the main variant (i.e. the unqualified version) of      this type now.  */
name|assert
argument_list|(
name|type
operator|==
name|type_main_variant
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|TREE_ASM_WRITTEN
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|ERROR_MARK
case|:
break|break;
case|case
name|ENUMERAL_TYPE
case|:
name|output_die
argument_list|(
name|output_inlined_enumeration_type_die
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|RECORD_TYPE
case|:
name|output_die
argument_list|(
name|output_inlined_structure_type_die
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNION_TYPE
case|:
case|case
name|QUAL_UNION_TYPE
case|:
name|output_die
argument_list|(
name|output_inlined_union_type_die
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
comment|/* Should never happen.  */
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output a TAG_lexical_block DIE followed by DIEs to represent all of    the things which are local to the given block.  */
end_comment

begin_function
specifier|static
name|void
name|output_block
parameter_list|(
name|stmt
parameter_list|)
specifier|register
name|tree
name|stmt
decl_stmt|;
block|{
specifier|register
name|int
name|must_output_die
init|=
literal|0
decl_stmt|;
specifier|register
name|tree
name|origin
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|origin_code
decl_stmt|;
comment|/* Ignore blocks never really used to make RTL.  */
if|if
condition|(
operator|!
name|stmt
operator|||
operator|!
name|TREE_USED
argument_list|(
name|stmt
argument_list|)
condition|)
return|return;
comment|/* Determine the "ultimate origin" of this block.  This block may be an      inlined instance of an inlined instance of inline function, so we      have to trace all of the way back through the origin chain to find      out what sort of node actually served as the original seed for the      creation of the current block.  */
name|origin
operator|=
name|block_ultimate_origin
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|origin_code
operator|=
operator|(
name|origin
operator|!=
name|NULL
operator|)
condition|?
name|TREE_CODE
argument_list|(
name|origin
argument_list|)
else|:
name|ERROR_MARK
expr_stmt|;
comment|/* Determine if we need to output any Dwarf DIEs at all to represent this      block.  */
if|if
condition|(
name|origin_code
operator|==
name|FUNCTION_DECL
condition|)
comment|/* The outer scopes for inlinings *must* always be represented.  We        generate TAG_inlined_subroutine DIEs for them.  (See below.)  */
name|must_output_die
operator|=
literal|1
expr_stmt|;
else|else
block|{
comment|/* In the case where the current block represents an inlining of the 	 "body block" of an inline function, we must *NOT* output any DIE 	 for this block because we have already output a DIE to represent 	 the whole inlined function scope and the "body block" of any 	 function doesn't really represent a different scope according to 	 ANSI C rules.  So we check here to make sure that this block does 	 not represent a "body block inlining" before trying to set the 	 `must_output_die' flag.  */
if|if
condition|(
name|origin
operator|==
name|NULL
operator|||
operator|!
name|is_body_block
argument_list|(
name|origin
argument_list|)
condition|)
block|{
comment|/* Determine if this block directly contains any "significant" 	     local declarations which we will need to output DIEs for.  */
if|if
condition|(
name|debug_info_level
operator|>
name|DINFO_LEVEL_TERSE
condition|)
comment|/* We are not in terse mode so *any* local declaration counts 	       as being a "significant" one.  */
name|must_output_die
operator|=
operator|(
name|BLOCK_VARS
argument_list|(
name|stmt
argument_list|)
operator|!=
name|NULL
operator|)
expr_stmt|;
else|else
block|{
specifier|register
name|tree
name|decl
decl_stmt|;
comment|/* We are in terse mode, so only local (nested) function 	         definitions count as "significant" local declarations.  */
for|for
control|(
name|decl
operator|=
name|BLOCK_VARS
argument_list|(
name|stmt
argument_list|)
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|must_output_die
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
comment|/* It would be a waste of space to generate a Dwarf TAG_lexical_block      DIE for any block which contains no significant local declarations      at all.  Rather, in such cases we just call `output_decls_for_scope'      so that any needed Dwarf info for any sub-blocks will get properly      generated.  Note that in terse mode, our definition of what constitutes      a "significant" local declaration gets restricted to include only      inlined function instances and local (nested) function definitions.  */
if|if
condition|(
name|must_output_die
condition|)
block|{
name|output_die
argument_list|(
operator|(
name|origin_code
operator|==
name|FUNCTION_DECL
operator|)
condition|?
name|output_inlined_subroutine_die
else|:
name|output_lexical_block_die
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|output_decls_for_scope
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|end_sibling_chain
argument_list|()
expr_stmt|;
block|}
else|else
name|output_decls_for_scope
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output all of the decls declared within a given scope (also called    a `binding contour') and (recursively) all of it's sub-blocks.  */
end_comment

begin_function
specifier|static
name|void
name|output_decls_for_scope
parameter_list|(
name|stmt
parameter_list|)
specifier|register
name|tree
name|stmt
decl_stmt|;
block|{
comment|/* Ignore blocks never really used to make RTL.  */
if|if
condition|(
operator|!
name|stmt
operator|||
operator|!
name|TREE_USED
argument_list|(
name|stmt
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|BLOCK_ABSTRACT
argument_list|(
name|stmt
argument_list|)
condition|)
name|next_block_number
operator|++
expr_stmt|;
comment|/* Output the DIEs to represent all of the data objects, functions,      typedefs, and tagged types declared directly within this block      but not within any nested sub-blocks.  */
block|{
specifier|register
name|tree
name|decl
decl_stmt|;
for|for
control|(
name|decl
operator|=
name|BLOCK_VARS
argument_list|(
name|stmt
argument_list|)
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
name|output_decl
argument_list|(
name|decl
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
block|}
name|output_pending_types_for_scope
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
comment|/* Output the DIEs to represent all sub-blocks (and the items declared      therein) of this block.	 */
block|{
specifier|register
name|tree
name|subblocks
decl_stmt|;
for|for
control|(
name|subblocks
operator|=
name|BLOCK_SUBBLOCKS
argument_list|(
name|stmt
argument_list|)
init|;
name|subblocks
condition|;
name|subblocks
operator|=
name|BLOCK_CHAIN
argument_list|(
name|subblocks
argument_list|)
control|)
name|output_block
argument_list|(
name|subblocks
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output Dwarf .debug information for a decl described by DECL.  */
end_comment

begin_function
specifier|static
name|void
name|output_decl
parameter_list|(
name|decl
parameter_list|,
name|containing_scope
parameter_list|)
specifier|register
name|tree
name|decl
decl_stmt|;
specifier|register
name|tree
name|containing_scope
decl_stmt|;
block|{
comment|/* Make a note of the decl node we are going to be working on.  We may      need to give the user the source coordinates of where it appeared in      case we notice (later on) that something about it looks screwy.  */
name|dwarf_last_decl
operator|=
name|decl
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return;
comment|/* If a structure is declared within an initialization, e.g. as the      operand of a sizeof, then it will not have a name.  We don't want      to output a DIE for it, as the tree nodes are in the temporary obstack */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
operator|)
operator|&&
operator|(
operator|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|&&
name|TYPE_NAME
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
operator|==
name|ERROR_MARK
operator|)
operator|)
operator|)
condition|)
return|return;
comment|/* If this ..._DECL node is marked to be ignored, then ignore it.      But don't ignore a function definition, since that would screw      up our count of blocks, and that it turn will completely screw up the      the labels we will reference in subsequent AT_low_pc and AT_high_pc      attributes (for subsequent blocks).  */
if|if
condition|(
name|DECL_IGNORED_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
return|return;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
case|case
name|CONST_DECL
case|:
comment|/* The individual enumerators of an enum type get output when we 	 output the Dwarf representation of the relevant enum type itself.  */
break|break;
case|case
name|FUNCTION_DECL
case|:
comment|/* If we are in terse mode, don't output any DIEs to represent 	 mere function declarations.  Also, if we are conforming 	 to the DWARF version 1 specification, don't output DIEs for 	 mere function declarations.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
condition|)
if|#
directive|if
operator|(
name|DWARF_VERSION
operator|>
literal|1
operator|)
if|if
condition|(
name|debug_info_level
operator|<=
name|DINFO_LEVEL_TERSE
condition|)
endif|#
directive|endif
break|break;
comment|/* Before we describe the FUNCTION_DECL itself, make sure that we 	 have described its return type.  */
name|output_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|containing_scope
argument_list|)
expr_stmt|;
comment|/* If the following DIE will represent a function definition for a 	 function with "extern" linkage, output a special "pubnames" DIE 	 label just ahead of the actual DIE.  A reference to this label 	 was already generated in the .debug_pubnames section sub-entry 	 for this function definition.  */
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|char
name|label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|label
argument_list|,
name|PUB_DIE_LABEL_FMT
argument_list|,
name|next_pubname_number
operator|++
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
comment|/* Now output a DIE to represent the function itself.  */
name|output_die
argument_list|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|?
name|output_global_subroutine_die
else|:
name|output_local_subroutine_die
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* Now output descriptions of the arguments for this function. 	 This gets (unnecessarily?) complex because of the fact that 	 the DECL_ARGUMENT list for a FUNCTION_DECL doesn't indicate 	 cases where there was a trailing `...' at the end of the formal 	 parameter list.  In order to find out if there was a trailing 	 ellipsis or not, we must instead look at the type associated 	 with the FUNCTION_DECL.  This will be a node of type FUNCTION_TYPE. 	 If the chain of type nodes hanging off of this FUNCTION_TYPE node 	 ends with a void_type_node then there should *not* be an ellipsis 	 at the end.  */
comment|/* In the case where we are describing a mere function declaration, all 	 we need to do here (and all we *can* do here) is to describe 	 the *types* of its formal parameters.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|output_formal_types
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Generate DIEs to represent all known formal parameters */
specifier|register
name|tree
name|arg_decls
init|=
name|DECL_ARGUMENTS
argument_list|(
name|decl
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|parm
decl_stmt|;
comment|/* WARNING!  Kludge zone ahead!  Here we have a special 	     hack for svr4 SDB compatibility.  Instead of passing the 	     current FUNCTION_DECL node as the second parameter (i.e. 	     the `containing_scope' parameter) to `output_decl' (as 	     we ought to) we instead pass a pointer to our own private 	     fake_containing_scope node.  That node is a RECORD_TYPE 	     node which NO OTHER TYPE may ever actually be a member of.  	     This pointer will ultimately get passed into `output_type' 	     as its `containing_scope' parameter.  `Output_type' will 	     then perform its part in the hack... i.e. it will pend 	     the type of the formal parameter onto the pending_types 	     list.  Later on, when we are done generating the whole 	     sequence of formal parameter DIEs for this function 	     definition, we will un-pend all previously pended types 	     of formal parameters for this function definition.  	     This whole kludge prevents any type DIEs from being 	     mixed in with the formal parameter DIEs.  That's good 	     because svr4 SDB believes that the list of formal 	     parameter DIEs for a function ends wherever the first 	     non-formal-parameter DIE appears.  Thus, we have to 	     keep the formal parameter DIEs segregated.  They must 	     all appear (consecutively) at the start of the list of 	     children for the DIE representing the function definition. 	     Then (and only then) may we output any additional DIEs 	     needed to represent the types of these formal parameters. 	  */
comment|/* 	     When generating DIEs, generate the unspecified_parameters 	     DIE instead if we come across the arg "__builtin_va_alist" 	  */
for|for
control|(
name|parm
operator|=
name|arg_decls
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|PARM_DECL
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|parm
argument_list|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|parm
argument_list|)
argument_list|)
argument_list|,
literal|"__builtin_va_alist"
argument_list|)
condition|)
name|output_die
argument_list|(
name|output_unspecified_parameters_die
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
name|output_decl
argument_list|(
name|parm
argument_list|,
name|fake_containing_scope
argument_list|)
expr_stmt|;
block|}
comment|/* 	     Now that we have finished generating all of the DIEs to 	     represent the formal parameters themselves, force out 	     any DIEs needed to represent their types.  We do this 	     simply by un-pending all previously pended types which 	     can legitimately go into the chain of children DIEs for 	     the current FUNCTION_DECL. 	  */
name|output_pending_types_for_scope
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* 	    Decide whether we need a unspecified_parameters DIE at the end. 	    There are 2 more cases to do this for: 	    1) the ansi ... declaration - this is detectable when the end 		of the arg list is not a void_type_node 	    2) an unprototyped function declaration (not a definition).  This 		just means that we have no info about the parameters at all. 	  */
block|{
specifier|register
name|tree
name|fn_arg_types
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|fn_arg_types
condition|)
block|{
comment|/* this is the prototyped case, check for ... */
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|tree_last
argument_list|(
name|fn_arg_types
argument_list|)
argument_list|)
operator|!=
name|void_type_node
condition|)
name|output_die
argument_list|(
name|output_unspecified_parameters_die
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* this is unprototyped, check for undefined (just declaration) */
if|if
condition|(
operator|!
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
condition|)
name|output_die
argument_list|(
name|output_unspecified_parameters_die
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Output Dwarf info for all of the stuff within the body of the 	 function (if it has one - it may be just a declaration).  */
block|{
specifier|register
name|tree
name|outer_scope
init|=
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|outer_scope
operator|&&
name|TREE_CODE
argument_list|(
name|outer_scope
argument_list|)
operator|!=
name|ERROR_MARK
condition|)
block|{
comment|/* Note that here, `outer_scope' is a pointer to the outermost 	       BLOCK node created to represent a function. 	       This outermost BLOCK actually represents the outermost 	       binding contour for the function, i.e. the contour in which 	       the function's formal parameters and labels get declared.  	       Curiously, it appears that the front end doesn't actually 	       put the PARM_DECL nodes for the current function onto the 	       BLOCK_VARS list for this outer scope.  (They are strung 	       off of the DECL_ARGUMENTS list for the function instead.) 	       The BLOCK_VARS list for the `outer_scope' does provide us 	       with a list of the LABEL_DECL nodes for the function however, 	       and we output DWARF info for those here.  	       Just within the `outer_scope' there will be another BLOCK 	       node representing the function's outermost pair of curly 	       braces.  We mustn't generate a lexical_block DIE for this 	       outermost pair of curly braces because that is not really an 	       independent scope according to ANSI C rules.  Rather, it is 	       the same scope in which the parameters were declared.  */
block|{
specifier|register
name|tree
name|label
decl_stmt|;
for|for
control|(
name|label
operator|=
name|BLOCK_VARS
argument_list|(
name|outer_scope
argument_list|)
init|;
name|label
condition|;
name|label
operator|=
name|TREE_CHAIN
argument_list|(
name|label
argument_list|)
control|)
name|output_decl
argument_list|(
name|label
argument_list|,
name|outer_scope
argument_list|)
expr_stmt|;
block|}
comment|/* Note here that `BLOCK_SUBBLOCKS (outer_scope)' points to a 	       list of BLOCK nodes which is always only one element long. 	       That one element represents the outermost pair of curley 	       braces for the function body.  */
name|output_decls_for_scope
argument_list|(
name|BLOCK_SUBBLOCKS
argument_list|(
name|outer_scope
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Finally, force out any pending types which are local to the 	       outermost block of this function definition.  These will 	       all have a TYPE_CONTEXT which points to the FUNCTION_DECL 	       node itself.  */
name|output_pending_types_for_scope
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Generate a terminator for the list of stuff `owned' by this 	 function.  */
name|end_sibling_chain
argument_list|()
expr_stmt|;
break|break;
case|case
name|TYPE_DECL
case|:
comment|/* If we are in terse mode, don't generate any DIEs to represent 	 any actual typedefs.  Note that even when we are in terse mode, 	 we must still output DIEs to represent those tagged types which 	 are used (directly or indirectly) in the specification of either 	 a return type or a formal parameter type of some function.  */
if|if
condition|(
name|debug_info_level
operator|<=
name|DINFO_LEVEL_TERSE
condition|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL
operator|||
operator|!
name|TYPE_USED_FOR_FUNCTION
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
return|return;
comment|/* In the special case of a null-named TYPE_DECL node (representing 	 the declaration of some type tag), if the given TYPE_DECL is 	 marked as having been instantiated from some other (original) 	 TYPE_DECL node (e.g. one which was generated within the original 	 definition of an inline function) we have to generate a special 	 (abbreviated) TAG_structure_type, TAG_union_type, or 	 TAG_enumeration-type DIE here.  */
if|if
condition|(
operator|!
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|output_tagged_type_instantiation
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|output_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|containing_scope
argument_list|)
expr_stmt|;
comment|/* Note that unlike the gcc front end (which generates a NULL named 	 TYPE_DECL node for each complete tagged type, each array type, 	 and each function type node created) the g++ front end generates 	 a *named* TYPE_DECL node for each tagged type node created. 	 Unfortunately, these g++ TYPE_DECL nodes cause us to output many 	 superfluous and unnecessary TAG_typedef DIEs here.  When g++ is 	 fixed to stop generating these superfluous named TYPE_DECL nodes, 	 the superfluous TAG_typedef DIEs will likewise cease.  */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
condition|)
comment|/* Output a DIE to represent the typedef itself.  */
name|output_die
argument_list|(
name|output_typedef_die
argument_list|,
name|decl
argument_list|)
expr_stmt|;
break|break;
case|case
name|LABEL_DECL
case|:
if|if
condition|(
name|debug_info_level
operator|>=
name|DINFO_LEVEL_NORMAL
condition|)
name|output_die
argument_list|(
name|output_label_die
argument_list|,
name|decl
argument_list|)
expr_stmt|;
break|break;
case|case
name|VAR_DECL
case|:
comment|/* If we are conforming to the DWARF version 1 specification, don't 	 generated any DIEs to represent mere external object declarations.  */
if|#
directive|if
operator|(
name|DWARF_VERSION
operator|<=
literal|1
operator|)
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
break|break;
endif|#
directive|endif
comment|/* If we are in terse mode, don't generate any DIEs to represent 	 any variable declarations or definitions.  */
if|if
condition|(
name|debug_info_level
operator|<=
name|DINFO_LEVEL_TERSE
condition|)
break|break;
comment|/* Output any DIEs that are needed to specify the type of this data 	 object.  */
name|output_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|containing_scope
argument_list|)
expr_stmt|;
comment|/* If the following DIE will represent a data object definition for a 	 data object with "extern" linkage, output a special "pubnames" DIE 	 label just ahead of the actual DIE.  A reference to this label 	 was already generated in the .debug_pubnames section sub-entry 	 for this data object definition.  */
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_ABSTRACT
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|char
name|label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|label
argument_list|,
name|PUB_DIE_LABEL_FMT
argument_list|,
name|next_pubname_number
operator|++
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
comment|/* Now output the DIE to represent the data object itself.  This gets 	 complicated because of the possibility that the VAR_DECL really 	 represents an inlined instance of a formal parameter for an inline 	 function.  */
block|{
specifier|register
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|()
function_decl|;
specifier|register
name|tree
name|origin
init|=
name|decl_ultimate_origin
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|origin
operator|!=
name|NULL
operator|&&
name|TREE_CODE
argument_list|(
name|origin
argument_list|)
operator|==
name|PARM_DECL
condition|)
name|func
operator|=
name|output_formal_parameter_die
expr_stmt|;
else|else
block|{
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
name|func
operator|=
name|output_global_variable_die
expr_stmt|;
else|else
name|func
operator|=
name|output_local_variable_die
expr_stmt|;
block|}
name|output_die
argument_list|(
name|func
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|FIELD_DECL
case|:
comment|/* Ignore the nameless fields that are used to skip bits.  */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|output_type
argument_list|(
name|member_declared_type
argument_list|(
name|decl
argument_list|)
argument_list|,
name|containing_scope
argument_list|)
expr_stmt|;
name|output_die
argument_list|(
name|output_member_die
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PARM_DECL
case|:
comment|/* Force out the type of this formal, if it was not forced out yet. 	Note that here we can run afowl of a bug in "classic" svr4 SDB. 	It should be able to grok the presence of type DIEs within a list 	of TAG_formal_parameter DIEs, but it doesn't.  */
name|output_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|containing_scope
argument_list|)
expr_stmt|;
name|output_die
argument_list|(
name|output_formal_parameter_die
argument_list|,
name|decl
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|dwarfout_file_scope_decl
parameter_list|(
name|decl
parameter_list|,
name|set_finalizing
parameter_list|)
specifier|register
name|tree
name|decl
decl_stmt|;
specifier|register
name|int
name|set_finalizing
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return;
comment|/* If this ..._DECL node is marked to be ignored, then ignore it.  We      gotta hope that the node in question doesn't represent a function      definition.  If it does, then totally ignoring it is bound to screw      up our count of blocks, and that it turn will completely screw up the      the labels we will reference in subsequent AT_low_pc and AT_high_pc      attributes (for subsequent blocks).  (It's too bad that BLOCK nodes      don't carry their own sequence numbers with them!)  */
if|if
condition|(
name|DECL_IGNORED_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
case|case
name|FUNCTION_DECL
case|:
comment|/* Ignore this FUNCTION_DECL if it refers to a builtin declaration of 	 a builtin function.  Explicit programmer-supplied declarations of 	 these same functions should NOT be ignored however.  */
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_FUNCTION_CODE
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
comment|/* What we would really like to do here is to filter out all mere 	 file-scope declarations of file-scope functions which are never 	 referenced later within this translation unit (and keep all of 	 ones that *are* referenced later on) but we aren't clairvoyant, 	 so we have no idea which functions will be referenced in the 	 future (i.e. later on within the current translation unit). 	 So here we just ignore all file-scope function declarations 	 which are not also definitions.  If and when the debugger needs 	 to know something about these functions, it wil have to hunt 	 around and find the DWARF information associated with the 	 *definition* of the function.  	 Note that we can't just check `DECL_EXTERNAL' to find out which 	 FUNCTION_DECL nodes represent definitions and which ones represent 	 mere declarations.  We have to check `DECL_INITIAL' instead.  That's 	 because the C front-end supports some weird semantics for "extern 	 inline" function definitions.  These can get inlined within the 	 current translation unit (an thus, we need to generate DWARF info 	 for their abstract instances so that the DWARF info for the 	 concrete inlined instances can have something to refer to) but 	 the compiler never generates any out-of-lines instances of such 	 things (despite the fact that they *are* definitions).  The 	 important point is that the C front-end marks these "extern inline" 	 functions as DECL_EXTERNAL, but we need to generate DWARf for them 	 anyway.  	 Note that the C++ front-end also plays some similar games for inline 	 function definitions appearing within include files which also 	 contain `#pragma interface' pragmas.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return;
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_ABSTRACT
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|char
name|label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
comment|/* Output a .debug_pubnames entry for a public function 	     defined in this compilation unit.  */
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_PUSH_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|PUBNAMES_SECTION
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|label
argument_list|,
name|PUB_DIE_LABEL_FMT
argument_list|,
name|next_pubname_number
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_ADDR
argument_list|(
name|asm_out_file
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_STRING
argument_list|(
name|asm_out_file
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_POP_SECTION
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|VAR_DECL
case|:
comment|/* Ignore this VAR_DECL if it refers to a file-scope extern data 	 object declaration and if the declaration was never even 	 referenced from within this entire compilation unit.  We 	 suppress these DIEs in order to save space in the .debug section 	 (by eliminating entries which are probably useless).  Note that 	 we must not suppress block-local extern declarations (whether 	 used or not) because that would screw-up the debugger's name 	 lookup mechanism and cause it to miss things which really ought 	 to be in scope at a given point.  */
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_USED
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|DECL_ABSTRACT
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|char
name|label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
if|if
condition|(
name|debug_info_level
operator|>=
name|DINFO_LEVEL_NORMAL
condition|)
block|{
comment|/* Output a .debug_pubnames entry for a public variable 	         defined in this compilation unit.  */
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_PUSH_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|PUBNAMES_SECTION
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|label
argument_list|,
name|PUB_DIE_LABEL_FMT
argument_list|,
name|next_pubname_number
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_ADDR
argument_list|(
name|asm_out_file
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_STRING
argument_list|(
name|asm_out_file
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_POP_SECTION
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* Output a .debug_aranges entry for a public variable 		 which is tentatively defined in this compilation unit.  */
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_PUSH_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|ARANGES_SECTION
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_ADDR
argument_list|(
name|asm_out_file
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DATA4
argument_list|(
name|asm_out_file
argument_list|,
operator|(
name|unsigned
operator|)
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_POP_SECTION
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If we are in terse mode, don't generate any DIEs to represent 	 any variable declarations or definitions.  */
if|if
condition|(
name|debug_info_level
operator|<=
name|DINFO_LEVEL_TERSE
condition|)
return|return;
break|break;
case|case
name|TYPE_DECL
case|:
comment|/* Don't bother trying to generate any DIEs to represent any of the 	 normal built-in types for the language we are compiling, except 	 in cases where the types in question are *not* DWARF fundamental 	 types.  We make an exception in the case of non-fundamental types 	 for the sake of objective C (and perhaps C++) because the GNU 	 front-ends for these languages may in fact create certain "built-in" 	 types which are (for example) RECORD_TYPEs.  In such cases, we 	 really need to output these (non-fundamental) types because other 	 DIEs may contain references to them.  */
if|if
condition|(
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|&&
name|type_is_fundamental
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
return|return;
comment|/* If we are in terse mode, don't generate any DIEs to represent 	 any actual typedefs.  Note that even when we are in terse mode, 	 we must still output DIEs to represent those tagged types which 	 are used (directly or indirectly) in the specification of either 	 a return type or a formal parameter type of some function.  */
if|if
condition|(
name|debug_info_level
operator|<=
name|DINFO_LEVEL_TERSE
condition|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL
operator|||
operator|!
name|TYPE_USED_FOR_FUNCTION
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
return|return;
break|break;
default|default:
return|return;
block|}
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_PUSH_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|DEBUG_SECTION
argument_list|)
expr_stmt|;
name|finalizing
operator|=
name|set_finalizing
expr_stmt|;
name|output_decl
argument_list|(
name|decl
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* NOTE:  The call above to `output_decl' may have caused one or more      file-scope named types (i.e. tagged types) to be placed onto the      pending_types_list.  We have to get those types off of that list      at some point, and this is the perfect time to do it.  If we didn't      take them off now, they might still be on the list when cc1 finally      exits.  That might be OK if it weren't for the fact that when we put      types onto the pending_types_list, we set the TREE_ASM_WRITTEN flag      for these types, and that causes them never to be output unless      `output_pending_types_for_scope' takes them off of the list and un-sets      their TREE_ASM_WRITTEN flags.  */
name|output_pending_types_for_scope
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* The above call should have totally emptied the pending_types_list.  */
name|assert
argument_list|(
name|pending_types
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_POP_SECTION
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL
condition|)
name|current_funcdef_number
operator|++
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output a marker (i.e. a label) for the beginning of the generated code    for a lexical block.	 */
end_comment

begin_function
name|void
name|dwarfout_begin_block
parameter_list|(
name|blocknum
parameter_list|)
specifier|register
name|unsigned
name|blocknum
decl_stmt|;
block|{
name|char
name|label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|function_section
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|label
argument_list|,
name|BLOCK_BEGIN_LABEL_FMT
argument_list|,
name|blocknum
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output a marker (i.e. a label) for the end of the generated code    for a lexical block.	 */
end_comment

begin_function
name|void
name|dwarfout_end_block
parameter_list|(
name|blocknum
parameter_list|)
specifier|register
name|unsigned
name|blocknum
decl_stmt|;
block|{
name|char
name|label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|function_section
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|label
argument_list|,
name|BLOCK_END_LABEL_FMT
argument_list|,
name|blocknum
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output a marker (i.e. a label) at a point in the assembly code which    corresponds to a given source level label.  */
end_comment

begin_function
name|void
name|dwarfout_label
parameter_list|(
name|insn
parameter_list|)
specifier|register
name|rtx
name|insn
decl_stmt|;
block|{
if|if
condition|(
name|debug_info_level
operator|>=
name|DINFO_LEVEL_NORMAL
condition|)
block|{
name|char
name|label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|function_section
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|label
argument_list|,
name|INSN_LABEL_FMT
argument_list|,
name|current_funcdef_number
argument_list|,
operator|(
name|unsigned
operator|)
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output a marker (i.e. a label) for the point in the generated code where    the real body of the function begins (after parameters have been moved    to their home locations).  */
end_comment

begin_function
name|void
name|dwarfout_begin_function
parameter_list|()
block|{
name|char
name|label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|function_section
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|label
argument_list|,
name|BODY_BEGIN_LABEL_FMT
argument_list|,
name|current_funcdef_number
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output a marker (i.e. a label) for the point in the generated code where    the real body of the function ends (just before the epilogue code).  */
end_comment

begin_function
name|void
name|dwarfout_end_function
parameter_list|()
block|{
name|char
name|label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|function_section
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|label
argument_list|,
name|BODY_END_LABEL_FMT
argument_list|,
name|current_funcdef_number
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output a marker (i.e. a label) for the absolute end of the generated code    for a function definition.  This gets called *after* the epilogue code    has been generated.	*/
end_comment

begin_function
name|void
name|dwarfout_end_epilogue
parameter_list|()
block|{
name|char
name|label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
comment|/* Output a label to mark the endpoint of the code generated for this      function.	*/
name|sprintf
argument_list|(
name|label
argument_list|,
name|FUNC_END_LABEL_FMT
argument_list|,
name|current_funcdef_number
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|shuffle_filename_entry
parameter_list|(
name|new_zeroth
parameter_list|)
specifier|register
name|filename_entry
modifier|*
name|new_zeroth
decl_stmt|;
block|{
name|filename_entry
name|temp_entry
decl_stmt|;
specifier|register
name|filename_entry
modifier|*
name|limit_p
decl_stmt|;
specifier|register
name|filename_entry
modifier|*
name|move_p
decl_stmt|;
if|if
condition|(
name|new_zeroth
operator|==
operator|&
name|filename_table
index|[
literal|0
index|]
condition|)
return|return;
name|temp_entry
operator|=
operator|*
name|new_zeroth
expr_stmt|;
comment|/* Shift entries up in the table to make room at [0].  */
name|limit_p
operator|=
operator|&
name|filename_table
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|move_p
operator|=
name|new_zeroth
init|;
name|move_p
operator|>
name|limit_p
condition|;
name|move_p
operator|--
control|)
operator|*
name|move_p
operator|=
operator|*
operator|(
name|move_p
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* Install the found entry at [0].  */
name|filename_table
index|[
literal|0
index|]
operator|=
name|temp_entry
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create a new (string) entry for the .debug_sfnames section.  */
end_comment

begin_function
specifier|static
name|void
name|generate_new_sfname_entry
parameter_list|()
block|{
name|char
name|label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_PUSH_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|SFNAMES_SECTION
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|label
argument_list|,
name|SFNAMES_ENTRY_LABEL_FMT
argument_list|,
name|filename_table
index|[
literal|0
index|]
operator|.
name|number
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_STRING
argument_list|(
name|asm_out_file
argument_list|,
name|filename_table
index|[
literal|0
index|]
operator|.
name|name
condition|?
name|filename_table
index|[
literal|0
index|]
operator|.
name|name
else|:
literal|""
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_POP_SECTION
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Lookup a filename (in the list of filenames that we know about here in    dwarfout.c) and return its "index".  The index of each (known) filename    is just a unique number which is associated with only that one filename.    We need such numbers for the sake of generating labels (in the    .debug_sfnames section) and references to those unique labels (in the    .debug_srcinfo and .debug_macinfo sections).     If the filename given as an argument is not found in our current list,    add it to the list and assign it the next available unique index number.     Whatever we do (i.e. whether we find a pre-existing filename or add a new    one), we shuffle the filename found (or added) up to the zeroth entry of    our list of filenames (which is always searched linearly).  We do this so    as to optimize the most common case for these filename lookups within    dwarfout.c.  The most common case by far is the case where we call    lookup_filename to lookup the very same filename that we did a lookup    on the last time we called lookup_filename.  We make sure that this    common case is fast because such cases will constitute 99.9% of the    lookups we ever do (in practice).     If we add a new filename entry to our table, we go ahead and generate    the corresponding entry in the .debug_sfnames section right away.    Doing so allows us to avoid tickling an assembler bug (present in some    m68k assemblers) which yields assembly-time errors in cases where the    difference of two label addresses is taken and where the two labels    are in a section *other* than the one where the difference is being    calculated, and where at least one of the two symbol references is a    forward reference.  (This bug could be tickled by our .debug_srcinfo    entries if we don't output their corresponding .debug_sfnames entries    before them.) */
end_comment

begin_function
specifier|static
name|unsigned
name|lookup_filename
parameter_list|(
name|file_name
parameter_list|)
name|char
modifier|*
name|file_name
decl_stmt|;
block|{
specifier|register
name|filename_entry
modifier|*
name|search_p
decl_stmt|;
specifier|register
name|filename_entry
modifier|*
name|limit_p
init|=
operator|&
name|filename_table
index|[
name|ft_entries
index|]
decl_stmt|;
for|for
control|(
name|search_p
operator|=
name|filename_table
init|;
name|search_p
operator|<
name|limit_p
condition|;
name|search_p
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|file_name
argument_list|,
name|search_p
operator|->
name|name
argument_list|)
condition|)
block|{
comment|/* When we get here, we have found the filename that we were 	   looking for in the filename_table.  Now we want to make sure 	   that it gets moved to the zero'th entry in the table (if it 	   is not already there) so that subsequent attempts to find the 	   same filename will find it as quickly as possible.  */
name|shuffle_filename_entry
argument_list|(
name|search_p
argument_list|)
expr_stmt|;
return|return
name|filename_table
index|[
literal|0
index|]
operator|.
name|number
return|;
block|}
comment|/* We come here whenever we have a new filename which is not registered      in the current table.  Here we add it to the table.  */
comment|/* Prepare to add a new table entry by making sure there is enough space      in the table to do so.  If not, expand the current table.  */
if|if
condition|(
name|ft_entries
operator|==
name|ft_entries_allocated
condition|)
block|{
name|ft_entries_allocated
operator|+=
name|FT_ENTRIES_INCREMENT
expr_stmt|;
name|filename_table
operator|=
operator|(
name|filename_entry
operator|*
operator|)
name|xrealloc
argument_list|(
name|filename_table
argument_list|,
name|ft_entries_allocated
operator|*
sizeof|sizeof
argument_list|(
name|filename_entry
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Initially, add the new entry at the end of the filename table.  */
name|filename_table
index|[
name|ft_entries
index|]
operator|.
name|number
operator|=
name|ft_entries
expr_stmt|;
name|filename_table
index|[
name|ft_entries
index|]
operator|.
name|name
operator|=
name|xstrdup
argument_list|(
name|file_name
argument_list|)
expr_stmt|;
comment|/* Shuffle the new entry into filename_table[0].  */
name|shuffle_filename_entry
argument_list|(
operator|&
name|filename_table
index|[
name|ft_entries
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_info_level
operator|>=
name|DINFO_LEVEL_NORMAL
condition|)
name|generate_new_sfname_entry
argument_list|()
expr_stmt|;
name|ft_entries
operator|++
expr_stmt|;
return|return
name|filename_table
index|[
literal|0
index|]
operator|.
name|number
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|generate_srcinfo_entry
parameter_list|(
name|line_entry_num
parameter_list|,
name|files_entry_num
parameter_list|)
name|unsigned
name|line_entry_num
decl_stmt|;
name|unsigned
name|files_entry_num
decl_stmt|;
block|{
name|char
name|label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_PUSH_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|SRCINFO_SECTION
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|label
argument_list|,
name|LINE_ENTRY_LABEL_FMT
argument_list|,
name|line_entry_num
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DELTA4
argument_list|(
name|asm_out_file
argument_list|,
name|label
argument_list|,
name|LINE_BEGIN_LABEL
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|label
argument_list|,
name|SFNAMES_ENTRY_LABEL_FMT
argument_list|,
name|files_entry_num
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DELTA4
argument_list|(
name|asm_out_file
argument_list|,
name|label
argument_list|,
name|SFNAMES_BEGIN_LABEL
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_POP_SECTION
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dwarfout_line
parameter_list|(
name|filename
parameter_list|,
name|line
parameter_list|)
specifier|register
name|char
modifier|*
name|filename
decl_stmt|;
specifier|register
name|unsigned
name|line
decl_stmt|;
block|{
if|if
condition|(
name|debug_info_level
operator|>=
name|DINFO_LEVEL_NORMAL
condition|)
block|{
name|char
name|label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
specifier|static
name|unsigned
name|last_line_entry_num
init|=
literal|0
decl_stmt|;
specifier|static
name|unsigned
name|prev_file_entry_num
init|=
operator|(
name|unsigned
operator|)
operator|-
literal|1
decl_stmt|;
specifier|register
name|unsigned
name|this_file_entry_num
init|=
name|lookup_filename
argument_list|(
name|filename
argument_list|)
decl_stmt|;
name|function_section
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|label
argument_list|,
name|LINE_CODE_LABEL_FMT
argument_list|,
operator|++
name|last_line_entry_num
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_PUSH_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|LINE_SECTION
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_file_entry_num
operator|!=
name|prev_file_entry_num
condition|)
block|{
name|char
name|line_entry_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|line_entry_label
argument_list|,
name|LINE_ENTRY_LABEL_FMT
argument_list|,
name|last_line_entry_num
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|line_entry_label
argument_list|)
expr_stmt|;
block|}
block|{
specifier|register
name|char
modifier|*
name|tail
init|=
name|rindex
argument_list|(
name|filename
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
if|if
condition|(
name|tail
operator|!=
name|NULL
condition|)
name|filename
operator|=
name|tail
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s\t%u\t%s %s:%u\n"
argument_list|,
name|UNALIGNED_INT_ASM_OP
argument_list|,
name|line
argument_list|,
name|ASM_COMMENT_START
argument_list|,
name|filename
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DATA2
argument_list|(
name|asm_out_file
argument_list|,
literal|0xffff
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DELTA4
argument_list|(
name|asm_out_file
argument_list|,
name|label
argument_list|,
name|TEXT_BEGIN_LABEL
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_POP_SECTION
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_file_entry_num
operator|!=
name|prev_file_entry_num
condition|)
name|generate_srcinfo_entry
argument_list|(
name|last_line_entry_num
argument_list|,
name|this_file_entry_num
argument_list|)
expr_stmt|;
name|prev_file_entry_num
operator|=
name|this_file_entry_num
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate an entry in the .debug_macinfo section.  */
end_comment

begin_function
specifier|static
name|void
name|generate_macinfo_entry
parameter_list|(
name|type_and_offset
parameter_list|,
name|string
parameter_list|)
specifier|register
name|char
modifier|*
name|type_and_offset
decl_stmt|;
specifier|register
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_PUSH_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|MACINFO_SECTION
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s\t%s\n"
argument_list|,
name|UNALIGNED_INT_ASM_OP
argument_list|,
name|type_and_offset
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_STRING
argument_list|(
name|asm_out_file
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_POP_SECTION
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dwarfout_start_new_source_file
parameter_list|(
name|filename
parameter_list|)
specifier|register
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|char
name|label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|char
name|type_and_offset
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
operator|*
literal|3
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|label
argument_list|,
name|SFNAMES_ENTRY_LABEL_FMT
argument_list|,
name|lookup_filename
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|type_and_offset
argument_list|,
literal|"0x%08x+%s-%s"
argument_list|,
operator|(
operator|(
name|unsigned
operator|)
name|MACINFO_start
operator|<<
literal|24
operator|)
argument_list|,
name|label
argument_list|,
name|SFNAMES_BEGIN_LABEL
argument_list|)
expr_stmt|;
name|generate_macinfo_entry
argument_list|(
name|type_and_offset
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dwarfout_resume_previous_source_file
parameter_list|(
name|lineno
parameter_list|)
specifier|register
name|unsigned
name|lineno
decl_stmt|;
block|{
name|char
name|type_and_offset
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
operator|*
literal|2
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|type_and_offset
argument_list|,
literal|"0x%08x+%u"
argument_list|,
operator|(
operator|(
name|unsigned
operator|)
name|MACINFO_resume
operator|<<
literal|24
operator|)
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|generate_macinfo_entry
argument_list|(
name|type_and_offset
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called from check_newline in c-parse.y.  The `buffer' parameter    contains the tail part of the directive line, i.e. the part which    is past the initial whitespace, #, whitespace, directive-name,    whitespace part.  */
end_comment

begin_function
name|void
name|dwarfout_define
parameter_list|(
name|lineno
parameter_list|,
name|buffer
parameter_list|)
specifier|register
name|unsigned
name|lineno
decl_stmt|;
specifier|register
name|char
modifier|*
name|buffer
decl_stmt|;
block|{
specifier|static
name|int
name|initialized
init|=
literal|0
decl_stmt|;
name|char
name|type_and_offset
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
operator|*
literal|2
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|dwarfout_start_new_source_file
argument_list|(
name|primary_filename
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|1
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|type_and_offset
argument_list|,
literal|"0x%08x+%u"
argument_list|,
operator|(
operator|(
name|unsigned
operator|)
name|MACINFO_define
operator|<<
literal|24
operator|)
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|generate_macinfo_entry
argument_list|(
name|type_and_offset
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called from check_newline in c-parse.y.  The `buffer' parameter    contains the tail part of the directive line, i.e. the part which    is past the initial whitespace, #, whitespace, directive-name,    whitespace part.  */
end_comment

begin_function
name|void
name|dwarfout_undef
parameter_list|(
name|lineno
parameter_list|,
name|buffer
parameter_list|)
specifier|register
name|unsigned
name|lineno
decl_stmt|;
specifier|register
name|char
modifier|*
name|buffer
decl_stmt|;
block|{
name|char
name|type_and_offset
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
operator|*
literal|2
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|type_and_offset
argument_list|,
literal|"0x%08x+%u"
argument_list|,
operator|(
operator|(
name|unsigned
operator|)
name|MACINFO_undef
operator|<<
literal|24
operator|)
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|generate_macinfo_entry
argument_list|(
name|type_and_offset
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set up for Dwarf output at the start of compilation.	 */
end_comment

begin_function
name|void
name|dwarfout_init
parameter_list|(
name|asm_out_file
parameter_list|,
name|main_input_filename
parameter_list|)
specifier|register
name|FILE
modifier|*
name|asm_out_file
decl_stmt|;
specifier|register
name|char
modifier|*
name|main_input_filename
decl_stmt|;
block|{
comment|/* Remember the name of the primary input file.  */
name|primary_filename
operator|=
name|main_input_filename
expr_stmt|;
comment|/* Allocate the initial hunk of the pending_sibling_stack.  */
name|pending_sibling_stack
operator|=
operator|(
name|unsigned
operator|*
operator|)
name|xmalloc
argument_list|(
name|PENDING_SIBLINGS_INCREMENT
operator|*
sizeof|sizeof
argument_list|(
name|unsigned
argument_list|)
argument_list|)
expr_stmt|;
name|pending_siblings_allocated
operator|=
name|PENDING_SIBLINGS_INCREMENT
expr_stmt|;
name|pending_siblings
operator|=
literal|1
expr_stmt|;
comment|/* Allocate the initial hunk of the filename_table.  */
name|filename_table
operator|=
operator|(
name|filename_entry
operator|*
operator|)
name|xmalloc
argument_list|(
name|FT_ENTRIES_INCREMENT
operator|*
sizeof|sizeof
argument_list|(
name|filename_entry
argument_list|)
argument_list|)
expr_stmt|;
name|ft_entries_allocated
operator|=
name|FT_ENTRIES_INCREMENT
expr_stmt|;
name|ft_entries
operator|=
literal|0
expr_stmt|;
comment|/* Allocate the initial hunk of the pending_types_list.  */
name|pending_types_list
operator|=
operator|(
name|tree
operator|*
operator|)
name|xmalloc
argument_list|(
name|PENDING_TYPES_INCREMENT
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
name|pending_types_allocated
operator|=
name|PENDING_TYPES_INCREMENT
expr_stmt|;
name|pending_types
operator|=
literal|0
expr_stmt|;
comment|/* Create an artificial RECORD_TYPE node which we can use in our hack      to get the DIEs representing types of formal parameters to come out      only *after* the DIEs for the formal parameters themselves.  */
name|fake_containing_scope
operator|=
name|make_node
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
comment|/* Output a starting label for the .text section.  */
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_PUSH_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|TEXT_SECTION
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|TEXT_BEGIN_LABEL
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_POP_SECTION
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
comment|/* Output a starting label for the .data section.  */
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_PUSH_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|DATA_SECTION
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|DATA_BEGIN_LABEL
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_POP_SECTION
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* GNU C doesn't currently use .data1.  */
comment|/* Output a starting label for the .data1 section.  */
block|fputc ('\n', asm_out_file);   ASM_OUTPUT_PUSH_SECTION (asm_out_file, DATA1_SECTION);   ASM_OUTPUT_LABEL (asm_out_file, DATA1_BEGIN_LABEL);   ASM_OUTPUT_POP_SECTION (asm_out_file);
endif|#
directive|endif
comment|/* Output a starting label for the .rodata section.  */
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_PUSH_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|RODATA_SECTION
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|RODATA_BEGIN_LABEL
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_POP_SECTION
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* GNU C doesn't currently use .rodata1.  */
comment|/* Output a starting label for the .rodata1 section.  */
block|fputc ('\n', asm_out_file);   ASM_OUTPUT_PUSH_SECTION (asm_out_file, RODATA1_SECTION);   ASM_OUTPUT_LABEL (asm_out_file, RODATA1_BEGIN_LABEL);   ASM_OUTPUT_POP_SECTION (asm_out_file);
endif|#
directive|endif
comment|/* Output a starting label for the .bss section.  */
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_PUSH_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|BSS_SECTION
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|BSS_BEGIN_LABEL
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_POP_SECTION
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_info_level
operator|>=
name|DINFO_LEVEL_NORMAL
condition|)
block|{
comment|/* Output a starting label and an initial (compilation directory) 	 entry for the .debug_sfnames section.  The starting label will be 	 referenced by the initial entry in the .debug_srcinfo section.  */
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_PUSH_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|SFNAMES_SECTION
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|SFNAMES_BEGIN_LABEL
argument_list|)
expr_stmt|;
block|{
specifier|register
name|char
modifier|*
name|pwd
decl_stmt|;
specifier|register
name|unsigned
name|len
decl_stmt|;
specifier|register
name|char
modifier|*
name|dirname
decl_stmt|;
name|pwd
operator|=
name|getpwd
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|pwd
condition|)
name|pfatal_with_name
argument_list|(
literal|"getpwd"
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|pwd
argument_list|)
expr_stmt|;
name|dirname
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|dirname
argument_list|,
name|pwd
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|dirname
operator|+
name|len
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_STRING
argument_list|(
name|asm_out_file
argument_list|,
name|dirname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dirname
argument_list|)
expr_stmt|;
block|}
name|ASM_OUTPUT_POP_SECTION
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_info_level
operator|>=
name|DINFO_LEVEL_VERBOSE
condition|)
block|{
comment|/* Output a starting label for the .debug_macinfo section.  This 	     label will be referenced by the AT_mac_info attribute in the 	     TAG_compile_unit DIE.  */
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_PUSH_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|MACINFO_SECTION
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|MACINFO_BEGIN_LABEL
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_POP_SECTION
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
comment|/* Generate the initial entry for the .line section.  */
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_PUSH_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|LINE_SECTION
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|LINE_BEGIN_LABEL
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DELTA4
argument_list|(
name|asm_out_file
argument_list|,
name|LINE_END_LABEL
argument_list|,
name|LINE_BEGIN_LABEL
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_ADDR
argument_list|(
name|asm_out_file
argument_list|,
name|TEXT_BEGIN_LABEL
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_POP_SECTION
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
comment|/* Generate the initial entry for the .debug_srcinfo section.  */
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_PUSH_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|SRCINFO_SECTION
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|SRCINFO_BEGIN_LABEL
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_ADDR
argument_list|(
name|asm_out_file
argument_list|,
name|LINE_BEGIN_LABEL
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_ADDR
argument_list|(
name|asm_out_file
argument_list|,
name|SFNAMES_BEGIN_LABEL
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_ADDR
argument_list|(
name|asm_out_file
argument_list|,
name|TEXT_BEGIN_LABEL
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_ADDR
argument_list|(
name|asm_out_file
argument_list|,
name|TEXT_END_LABEL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DWARF_TIMESTAMPS
name|ASM_OUTPUT_DWARF_DATA4
argument_list|(
name|asm_out_file
argument_list|,
name|time
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|ASM_OUTPUT_DWARF_DATA4
argument_list|(
name|asm_out_file
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ASM_OUTPUT_POP_SECTION
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
comment|/* Generate the initial entry for the .debug_pubnames section.  */
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_PUSH_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|PUBNAMES_SECTION
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_ADDR
argument_list|(
name|asm_out_file
argument_list|,
name|DEBUG_BEGIN_LABEL
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_POP_SECTION
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
comment|/* Generate the initial entry for the .debug_aranges section.  */
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_PUSH_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|ARANGES_SECTION
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_ADDR
argument_list|(
name|asm_out_file
argument_list|,
name|DEBUG_BEGIN_LABEL
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_POP_SECTION
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
comment|/* Setup first DIE number == 1.  */
name|NEXT_DIE_NUM
operator|=
name|next_unused_dienum
operator|++
expr_stmt|;
comment|/* Generate the initial DIE for the .debug section.  Note that the      (string) value given in the AT_name attribute of the TAG_compile_unit      DIE will (typically) be a relative pathname and that this pathname      should be taken as being relative to the directory from which the      compiler was invoked when the given (base) source file was compiled.  */
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_PUSH_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|DEBUG_SECTION
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|DEBUG_BEGIN_LABEL
argument_list|)
expr_stmt|;
name|output_die
argument_list|(
name|output_compile_unit_die
argument_list|,
name|main_input_filename
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_POP_SECTION
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output stuff that dwarf requires at the end of every file.  */
end_comment

begin_function
name|void
name|dwarfout_finish
parameter_list|()
block|{
name|char
name|label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_PUSH_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|DEBUG_SECTION
argument_list|)
expr_stmt|;
comment|/* Mark the end of the chain of siblings which represent all file-scope      declarations in this compilation unit.  */
comment|/* The (null) DIE which represents the terminator for the (sibling linked)      list of file-scope items is *special*.  Normally, we would just call      end_sibling_chain at this point in order to output a word with the      value `4' and that word would act as the terminator for the list of      DIEs describing file-scope items.  Unfortunately, if we were to simply      do that, the label that would follow this DIE in the .debug section      (i.e. `..D2') would *not* be properly aligned (as it must be on some      machines) to a 4 byte boundary.       In order to force the label `..D2' to get aligned to a 4 byte boundary,      the trick used is to insert extra (otherwise useless) padding bytes      into the (null) DIE that we know must precede the ..D2 label in the      .debug section.  The amount of padding required can be anywhere between      0 and 3 bytes.  The length word at the start of this DIE (i.e. the one      with the padding) would normally contain the value 4, but now it will      also have to include the padding bytes, so it will instead have some      value in the range 4..7.       Fortunately, the rules of Dwarf say that any DIE whose length word      contains *any* value less than 8 should be treated as a null DIE, so      this trick works out nicely.  Clever, eh?  Don't give me any credit      (or blame).  I didn't think of this scheme.  I just conformed to it.   */
name|output_die
argument_list|(
name|output_padded_null_die
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|dienum_pop
argument_list|()
expr_stmt|;
name|sprintf
argument_list|(
name|label
argument_list|,
name|DIE_BEGIN_LABEL_FMT
argument_list|,
name|NEXT_DIE_NUM
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|label
argument_list|)
expr_stmt|;
comment|/* should be ..D2 */
name|ASM_OUTPUT_POP_SECTION
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
comment|/* Output a terminator label for the .text section.  */
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_PUSH_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|TEXT_SECTION
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|TEXT_END_LABEL
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_POP_SECTION
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
comment|/* Output a terminator label for the .data section.  */
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_PUSH_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|DATA_SECTION
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|DATA_END_LABEL
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_POP_SECTION
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* GNU C doesn't currently use .data1.  */
comment|/* Output a terminator label for the .data1 section.  */
block|fputc ('\n', asm_out_file);   ASM_OUTPUT_PUSH_SECTION (asm_out_file, DATA1_SECTION);   ASM_OUTPUT_LABEL (asm_out_file, DATA1_END_LABEL);   ASM_OUTPUT_POP_SECTION (asm_out_file);
endif|#
directive|endif
comment|/* Output a terminator label for the .rodata section.  */
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_PUSH_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|RODATA_SECTION
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|RODATA_END_LABEL
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_POP_SECTION
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* GNU C doesn't currently use .rodata1.  */
comment|/* Output a terminator label for the .rodata1 section.  */
block|fputc ('\n', asm_out_file);   ASM_OUTPUT_PUSH_SECTION (asm_out_file, RODATA1_SECTION);   ASM_OUTPUT_LABEL (asm_out_file, RODATA1_END_LABEL);   ASM_OUTPUT_POP_SECTION (asm_out_file);
endif|#
directive|endif
comment|/* Output a terminator label for the .bss section.  */
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_PUSH_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|BSS_SECTION
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|BSS_END_LABEL
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_POP_SECTION
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_info_level
operator|>=
name|DINFO_LEVEL_NORMAL
condition|)
block|{
comment|/* Output a terminating entry for the .line section.  */
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_PUSH_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|LINE_SECTION
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|LINE_LAST_ENTRY_LABEL
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DATA4
argument_list|(
name|asm_out_file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DATA2
argument_list|(
name|asm_out_file
argument_list|,
literal|0xffff
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DELTA4
argument_list|(
name|asm_out_file
argument_list|,
name|TEXT_END_LABEL
argument_list|,
name|TEXT_BEGIN_LABEL
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|LINE_END_LABEL
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_POP_SECTION
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
comment|/* Output a terminating entry for the .debug_srcinfo section.  */
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_PUSH_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|SRCINFO_SECTION
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DELTA4
argument_list|(
name|asm_out_file
argument_list|,
name|LINE_LAST_ENTRY_LABEL
argument_list|,
name|LINE_BEGIN_LABEL
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DATA4
argument_list|(
name|asm_out_file
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_POP_SECTION
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_info_level
operator|>=
name|DINFO_LEVEL_VERBOSE
condition|)
block|{
comment|/* Output terminating entries for the .debug_macinfo section.  */
name|dwarfout_resume_previous_source_file
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_PUSH_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|MACINFO_SECTION
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DATA4
argument_list|(
name|asm_out_file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_STRING
argument_list|(
name|asm_out_file
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_POP_SECTION
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
comment|/* Generate the terminating entry for the .debug_pubnames section.  */
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_PUSH_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|PUBNAMES_SECTION
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DATA4
argument_list|(
name|asm_out_file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_STRING
argument_list|(
name|asm_out_file
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_POP_SECTION
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
comment|/* Generate the terminating entries for the .debug_aranges section.  	 Note that we want to do this only *after* we have output the end 	 labels (for the various program sections) which we are going to 	 refer to here.  This allows us to work around a bug in the m68k 	 svr4 assembler.  That assembler gives bogus assembly-time errors 	 if (within any given section) you try to take the difference of 	 two relocatable symbols, both of which are located within some 	 other section, and if one (or both?) of the symbols involved is 	 being forward-referenced.  By generating the .debug_aranges 	 entries at this late point in the assembly output, we skirt the 	 issue simply by avoiding forward-references.       */
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_PUSH_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|ARANGES_SECTION
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_ADDR
argument_list|(
name|asm_out_file
argument_list|,
name|TEXT_BEGIN_LABEL
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DELTA4
argument_list|(
name|asm_out_file
argument_list|,
name|TEXT_END_LABEL
argument_list|,
name|TEXT_BEGIN_LABEL
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_ADDR
argument_list|(
name|asm_out_file
argument_list|,
name|DATA_BEGIN_LABEL
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DELTA4
argument_list|(
name|asm_out_file
argument_list|,
name|DATA_END_LABEL
argument_list|,
name|DATA_BEGIN_LABEL
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* GNU C doesn't currently use .data1.  */
block|ASM_OUTPUT_DWARF_ADDR (asm_out_file, DATA1_BEGIN_LABEL);       ASM_OUTPUT_DWARF_DELTA4 (asm_out_file, DATA1_END_LABEL, 					     DATA1_BEGIN_LABEL);
endif|#
directive|endif
name|ASM_OUTPUT_DWARF_ADDR
argument_list|(
name|asm_out_file
argument_list|,
name|RODATA_BEGIN_LABEL
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DELTA4
argument_list|(
name|asm_out_file
argument_list|,
name|RODATA_END_LABEL
argument_list|,
name|RODATA_BEGIN_LABEL
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* GNU C doesn't currently use .rodata1.  */
block|ASM_OUTPUT_DWARF_ADDR (asm_out_file, RODATA1_BEGIN_LABEL);       ASM_OUTPUT_DWARF_DELTA4 (asm_out_file, RODATA1_END_LABEL, 					     RODATA1_BEGIN_LABEL);
endif|#
directive|endif
name|ASM_OUTPUT_DWARF_ADDR
argument_list|(
name|asm_out_file
argument_list|,
name|BSS_BEGIN_LABEL
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DELTA4
argument_list|(
name|asm_out_file
argument_list|,
name|BSS_END_LABEL
argument_list|,
name|BSS_BEGIN_LABEL
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DATA4
argument_list|(
name|asm_out_file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DATA4
argument_list|(
name|asm_out_file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_POP_SECTION
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DWARF_DEBUGGING_INFO */
end_comment

end_unit

