begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Output Dwarf format symbol table information from the GNU C compiler.    Copyright (C) 1992, 1993, 1995, 1996, 1997, 1998, 2002,    1999, 2000, 2001, 2002 Free Software Foundation, Inc.    Contributed by Ron Guilmette (rfg@monkeys.com) of Network Computing Devices.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/*   Notes on the GNU Implementation of DWARF Debugging Information  --------------------------------------------------------------  Last Major Update: Sun Jul 17 08:17:42 PDT 1994 by rfg@segfault.us.com  ------------------------------------------------------------   This file describes special and unique aspects of the GNU implementation of  the DWARF Version 1 debugging information language, as provided in the GNU  version 2.x compiler(s).   For general information about the DWARF debugging information language,  you should obtain the DWARF version 1.1 specification document (and perhaps  also the DWARF version 2 draft specification document) developed by the  (now defunct) UNIX International Programming Languages Special Interest Group.   To obtain a copy of the DWARF Version 1 and/or DWARF Version 2  specification, visit the web page for the DWARF Version 2 committee, at     http://www.eagercon.com/dwarf/dwarf2std.htm   The generation of DWARF debugging information by the GNU version 2.x C  compiler has now been tested rather extensively for m88k, i386, i860, and  SPARC targets.  The DWARF output of the GNU C compiler appears to inter-  operate well with the standard SVR4 SDB debugger on these kinds of target  systems (but of course, there are no guarantees).   DWARF 1 generation for the GNU g++ compiler is implemented, but limited.  C++ users should definitely use DWARF 2 instead.   Future plans for the dwarfout.c module of the GNU compiler(s) includes the  addition of full support for GNU FORTRAN.  (This should, in theory, be a  lot simpler to add than adding support for g++... but we'll see.)   Many features of the DWARF version 2 specification have been adapted to  (and used in) the GNU implementation of DWARF (version 1).  In most of  these cases, a DWARF version 2 approach is used in place of (or in addition  to) DWARF version 1 stuff simply because it is apparent that DWARF version  1 is not sufficiently expressive to provide the kinds of information which  may be necessary to support really robust debugging.  In all of these cases  however, the use of DWARF version 2 features should not interfere in any  way with the interoperability (of GNU compilers) with generally available  "classic" (pre version 1) DWARF consumer tools (e.g. SVR4 SDB).   The DWARF generation enhancement for the GNU compiler(s) was initially  donated to the Free Software Foundation by Network Computing Devices.  (Thanks NCD!) Additional development and maintenance of dwarfout.c has  been largely supported (i.e. funded) by Intel Corporation.  (Thanks Intel!)   If you have questions or comments about the DWARF generation feature, please  send mail to me<rfg@netcom.com>.  I will be happy to investigate any bugs  reported and I may even provide fixes (but of course, I can make no promises).   The DWARF debugging information produced by GCC may deviate in a few minor  (but perhaps significant) respects from the DWARF debugging information  currently produced by other C compilers.  A serious attempt has been made  however to conform to the published specifications, to existing practice,  and to generally accepted norms in the GNU implementation of DWARF.       ** IMPORTANT NOTE **    ** IMPORTANT NOTE **    ** IMPORTANT NOTE **   Under normal circumstances, the DWARF information generated by the GNU  compilers (in an assembly language file) is essentially impossible for  a human being to read.  This fact can make it very difficult to debug  certain DWARF-related problems.  In order to overcome this difficulty,  a feature has been added to dwarfout.c (enabled by the -dA  option) which causes additional comments to be placed into the assembly  language output file, out to the right-hand side of most bits of DWARF  material.  The comments indicate (far more clearly that the obscure  DWARF hex codes do) what is actually being encoded in DWARF.  Thus, the  -dA option can be highly useful for those who must study the  DWARF output from the GNU compilers in detail.   ---------   (Footnote: Within this file, the term `Debugging Information Entry' will  be abbreviated as `DIE'.)    Release Notes  (aka known bugs)  -------------------------------   In one very obscure case involving dynamically sized arrays, the DWARF  "location information" for such an array may make it appear that the  array has been totally optimized out of existence, when in fact it  *must* actually exist.  (This only happens when you are using *both* -g  *and* -O.)  This is due to aggressive dead store elimination in the  compiler, and to the fact that the DECL_RTL expressions associated with  variables are not always updated to correctly reflect the effects of  GCC's aggressive dead store elimination.   -------------------------------   When attempting to set a breakpoint at the "start" of a function compiled  with -g1, the debugger currently has no way of knowing exactly where the  end of the prologue code for the function is.  Thus, for most targets,  all the debugger can do is to set the breakpoint at the AT_low_pc address  for the function.  But if you stop there and then try to look at one or  more of the formal parameter values, they may not have been "homed" yet,  so you may get inaccurate answers (or perhaps even addressing errors).   Some people may consider this simply a non-feature, but I consider it a  bug, and I hope to provide some GNU-specific attributes (on function  DIEs) which will specify the address of the end of the prologue and the  address of the beginning of the epilogue in a future release.   -------------------------------   It is believed at this time that old bugs relating to the AT_bit_offset  values for bit-fields have been fixed.   There may still be some very obscure bugs relating to the DWARF description  of type `long long' bit-fields for target machines (e.g. 80x86 machines)  where the alignment of type `long long' data objects is different from  (and less than) the size of a type `long long' data object.   Please report any problems with the DWARF description of bit-fields as you  would any other GCC bug.  (Procedures for bug reporting are given in the  GNU C compiler manual.)   --------------------------------   At this time, GCC does not know how to handle the GNU C "nested functions"  extension.  (See the GCC manual for more info on this extension to ANSI C.)   --------------------------------   The GNU compilers now represent inline functions (and inlined instances  thereof) in exactly the manner described by the current DWARF version 2  (draft) specification.  The version 1 specification for handling inline  functions (and inlined instances) was known to be brain-damaged (by the  PLSIG) when the version 1 spec was finalized, but it was simply too late  in the cycle to get it removed before the version 1 spec was formally  released to the public (by UI).   --------------------------------   At this time, GCC does not generate the kind of really precise information  about the exact declared types of entities with signed integral types which  is required by the current DWARF draft specification.   Specifically, the current DWARF draft specification seems to require that  the type of a non-unsigned integral bit-field member of a struct or union  type be represented as either a "signed" type or as a "plain" type,  depending upon the exact set of keywords that were used in the  type specification for the given bit-field member.  It was felt (by the  UI/PLSIG) that this distinction between "plain" and "signed" integral types  could have some significance (in the case of bit-fields) because ANSI C  does not constrain the signedness of a plain bit-field, whereas it does  constrain the signedness of an explicitly "signed" bit-field.  For this  reason, the current DWARF specification calls for compilers to produce  type information (for *all* integral typed entities... not just bit-fields)  which explicitly indicates the signedness of the relevant type to be  "signed" or "plain" or "unsigned".   Unfortunately, the GNU DWARF implementation is currently incapable of making  such distinctions.   --------------------------------    Known Interoperability Problems  -------------------------------   Although the GNU implementation of DWARF conforms (for the most part) with  the current UI/PLSIG DWARF version 1 specification (with many compatible  version 2 features added in as "vendor specific extensions" just for good  measure) there are a few known cases where GCC's DWARF output can cause  some confusion for "classic" (pre version 1) DWARF consumers such as the  System V Release 4 SDB debugger.  These cases are described in this section.   --------------------------------   The DWARF version 1 specification includes the fundamental type codes  FT_ext_prec_float, FT_complex, FT_dbl_prec_complex, and FT_ext_prec_complex.  Since GNU C is only a C compiler (and since C doesn't provide any "complex"  data types) the only one of these fundamental type codes which GCC ever  generates is FT_ext_prec_float.  This fundamental type code is generated  by GCC for the `long double' data type.  Unfortunately, due to an apparent  bug in the SVR4 SDB debugger, SDB can become very confused wherever any  attempt is made to print a variable, parameter, or field whose type was  given in terms of FT_ext_prec_float.   (Actually, SVR4 SDB fails to understand *any* of the four fundamental type  codes mentioned here.  This will fact will cause additional problems when  there is a GNU FORTRAN front-end.)   --------------------------------   In general, it appears that SVR4 SDB is not able to effectively ignore  fundamental type codes in the "implementation defined" range.  This can  cause problems when a program being debugged uses the `long long' data  type (or the signed or unsigned varieties thereof) because these types  are not defined by ANSI C, and thus, GCC must use its own private fundamental  type codes (from the implementation-defined range) to represent these types.   --------------------------------    General GNU DWARF extensions  ----------------------------   In the current DWARF version 1 specification, no mechanism is specified by  which accurate information about executable code from include files can be  properly (and fully) described.  (The DWARF version 2 specification *does*  specify such a mechanism, but it is about 10 times more complicated than  it needs to be so I'm not terribly anxious to try to implement it right  away.)   In the GNU implementation of DWARF version 1, a fully downward-compatible  extension has been implemented which permits the GNU compilers to specify  which executable lines come from which files.  This extension places  additional information (about source file names) in GNU-specific sections  (which should be totally ignored by all non-GNU DWARF consumers) so that  this extended information can be provided (to GNU DWARF consumers) in a way  which is totally transparent (and invisible) to non-GNU DWARF consumers  (e.g. the SVR4 SDB debugger).  The additional information is placed *only*  in specialized GNU-specific sections, where it should never even be seen  by non-GNU DWARF consumers.   To understand this GNU DWARF extension, imagine that the sequence of entries  in the .lines section is broken up into several subsections.  Each contiguous  sequence of .line entries which relates to a sequence of lines (or statements)  from one particular file (either a `base' file or an `include' file) could  be called a `line entries chunk' (LEC).   For each LEC there is one entry in the .debug_srcinfo section.   Each normal entry in the .debug_srcinfo section consists of two 4-byte  words of data as follows:  	 (1)	The starting address (relative to the entire .line section) 		 of the first .line entry in the relevant LEC.  	 (2)	The starting address (relative to the entire .debug_sfnames 		 section) of a NUL terminated string representing the 		 relevant filename.  (This filename name be either a 		 relative or an absolute filename, depending upon how the 		 given source file was located during compilation.)   Obviously, each .debug_srcinfo entry allows you to find the relevant filename,  and it also points you to the first .line entry that was generated as a result  of having compiled a given source line from the given source file.   Each subsequent .line entry should also be assumed to have been produced  as a result of compiling yet more lines from the same file.  The end of  any given LEC is easily found by looking at the first 4-byte pointer in  the *next* .debug_srcinfo entry.  That next .debug_srcinfo entry points  to a new and different LEC, so the preceding LEC (implicitly) must have  ended with the last .line section entry which occurs at the 2 1/2 words  just before the address given in the first pointer of the new .debug_srcinfo  entry.   The following picture may help to clarify this feature.  Let's assume that  `LE' stands for `.line entry'.  Also, assume that `* 'stands for a pointer.   	 .line section	   .debug_srcinfo section     .debug_sfnames section 	 ----------------------------------------------------------------  	 LE<---------------------- * 	 LE			    * -----------------> "foobar.c"<--- 	 LE								| 	 LE								| 	 LE<---------------------- *					| 	 LE			    * -----------------> "foobar.h"<|	| 	 LE							     |	| 	 LE							     |	| 	 LE<---------------------- *				     |	| 	 LE			    * ----------------->  "inner.h"  |	| 	 LE							     |	| 	 LE<---------------------- *				     |	| 	 LE			    * -------------------------------	| 	 LE								| 	 LE								| 	 LE								| 	 LE								| 	 LE<---------------------- *					| 	 LE			    * ----------------------------------- 	 LE 	 LE 	 LE   In effect, each entry in the .debug_srcinfo section points to *both* a  filename (in the .debug_sfnames section) and to the start of a block of  consecutive LEs (in the .line section).   Note that just like in the .line section, there are specialized first and  last entries in the .debug_srcinfo section for each object file.  These  special first and last entries for the .debug_srcinfo section are very  different from the normal .debug_srcinfo section entries.  They provide  additional information which may be helpful to a debugger when it is  interpreting the data in the .debug_srcinfo, .debug_sfnames, and .line  sections.   The first entry in the .debug_srcinfo section for each compilation unit  consists of five 4-byte words of data.  The contents of these five words  should be interpreted (by debuggers) as follows:  	 (1)	The starting address (relative to the entire .line section) 		 of the .line section for this compilation unit.  	 (2)	The starting address (relative to the entire .debug_sfnames 		 section) of the .debug_sfnames section for this compilation 		 unit.  	 (3)	The starting address (in the execution virtual address space) 		 of the .text section for this compilation unit.  	 (4)	The ending address plus one (in the execution virtual address 		 space) of the .text section for this compilation unit.  	 (5)	The date/time (in seconds since midnight 1/1/70) at which the 		 compilation of this compilation unit occurred.  This value 		 should be interpreted as an unsigned quantity because gcc 		 might be configured to generate a default value of 0xffffffff 		 in this field (in cases where it is desired to have object 		 files created at different times from identical source files 		 be byte-for-byte identical).  By default, these timestamps 		 are *not* generated by dwarfout.c (so that object files 		 compiled at different times will be byte-for-byte identical). 		 If you wish to enable this "timestamp" feature however, you 		 can simply place a #define for the symbol `DWARF_TIMESTAMPS' 		 in your target configuration file and then rebuild the GNU 		 compiler(s).   Note that the first string placed into the .debug_sfnames section for each  compilation unit is the name of the directory in which compilation occurred.  This string ends with a `/' (to help indicate that it is the pathname of a  directory).  Thus, the second word of each specialized initial .debug_srcinfo  entry for each compilation unit may be used as a pointer to the (string)  name of the compilation directory, and that string may in turn be used to  "absolutize" any relative pathnames which may appear later on in the  .debug_sfnames section entries for the same compilation unit.   The fifth and last word of each specialized starting entry for a compilation  unit in the .debug_srcinfo section may (depending upon your configuration)  indicate the date/time of compilation, and this may be used (by a debugger)  to determine if any of the source files which contributed code to this  compilation unit are newer than the object code for the compilation unit  itself.  If so, the debugger may wish to print an "out-of-date" warning  about the compilation unit.   The .debug_srcinfo section associated with each compilation will also have  a specialized terminating entry.  This terminating .debug_srcinfo section  entry will consist of the following two 4-byte words of data:  	 (1)	The offset, measured from the start of the .line section to 		 the beginning of the terminating entry for the .line section.  	 (2)	A word containing the value 0xffffffff.   --------------------------------   In the current DWARF version 1 specification, no mechanism is specified by  which information about macro definitions and un-definitions may be provided  to the DWARF consumer.   The DWARF version 2 (draft) specification does specify such a mechanism.  That specification was based on the GNU ("vendor specific extension")  which provided some support for macro definitions and un-definitions,  but the "official" DWARF version 2 (draft) specification mechanism for  handling macros and the GNU implementation have diverged somewhat.  I  plan to update the GNU implementation to conform to the "official"  DWARF version 2 (draft) specification as soon as I get time to do that.   Note that in the GNU implementation, additional information about macro  definitions and un-definitions is *only* provided when the -g3 level of  debug-info production is selected.  (The default level is -g2 and the  plain old -g option is considered to be identical to -g2.)   GCC records information about macro definitions and undefinitions primarily  in a section called the .debug_macinfo section.  Normal entries in the  .debug_macinfo section consist of the following three parts:  	 (1)	A special "type" byte.  	 (2)	A 3-byte line-number/filename-offset field.  	 (3)	A NUL terminated string.   The interpretation of the second and third parts is dependent upon the  value of the leading (type) byte.   The type byte may have one of four values depending upon the type of the  .debug_macinfo entry which follows.  The 1-byte MACINFO type codes presently  used, and their meanings are as follows:  	 MACINFO_start		A base file or an include file starts here. 	 MACINFO_resume		The current base or include file ends here. 	 MACINFO_define          A #define directive occurs here. 	 MACINFO_undef           A #undef directive occur here.   (Note that the MACINFO_... codes mentioned here are simply symbolic names  for constants which are defined in the GNU dwarf.h file.)   For MACINFO_define and MACINFO_undef entries, the second (3-byte) field  contains the number of the source line (relative to the start of the current  base source file or the current include files) when the #define or #undef  directive appears.  For a MACINFO_define entry, the following string field  contains the name of the macro which is defined, followed by its definition.  Note that the definition is always separated from the name of the macro  by at least one whitespace character.  For a MACINFO_undef entry, the  string which follows the 3-byte line number field contains just the name  of the macro which is being undef'ed.   For a MACINFO_start entry, the 3-byte field following the type byte contains  the offset, relative to the start of the .debug_sfnames section for the  current compilation unit, of a string which names the new source file which  is beginning its inclusion at this point.  Following that 3-byte field,  each MACINFO_start entry always contains a zero length NUL terminated  string.   For a MACINFO_resume entry, the 3-byte field following the type byte contains  the line number WITHIN THE INCLUDING FILE at which the inclusion of the  current file (whose inclusion ends here) was initiated.  Following that  3-byte field, each MACINFO_resume entry always contains a zero length NUL  terminated string.   Each set of .debug_macinfo entries for each compilation unit is terminated  by a special .debug_macinfo entry consisting of a 4-byte zero value followed  by a single NUL byte.   --------------------------------   In the current DWARF draft specification, no provision is made for providing  a separate level of (limited) debugging information necessary to support  tracebacks (only) through fully-debugged code (e.g. code in system libraries).   A proposal to define such a level was submitted (by me) to the UI/PLSIG.  This proposal was rejected by the UI/PLSIG for inclusion into the DWARF  version 1 specification for two reasons.  First, it was felt (by the PLSIG)  that the issues involved in supporting a "traceback only" subset of DWARF  were not well understood.  Second, and perhaps more importantly, the PLSIG  is already having enough trouble agreeing on what it means to be "conforming"  to the DWARF specification, and it was felt that trying to specify multiple  different *levels* of conformance would only complicate our discussions of  this already divisive issue.  Nonetheless, the GNU implementation of DWARF  provides an abbreviated "traceback only" level of debug-info production for  use with fully-debugged "system library" code.  This level should only be  used for fully debugged system library code, and even then, it should only  be used where there is a very strong need to conserve disk space.  This  abbreviated level of debug-info production can be used by specifying the  -g1 option on the compilation command line.   --------------------------------   As mentioned above, the GNU implementation of DWARF currently uses the DWARF  version 2 (draft) approach for inline functions (and inlined instances  thereof).  This is used in preference to the version 1 approach because  (quite simply) the version 1 approach is highly brain-damaged and probably  unworkable.   --------------------------------    GNU DWARF Representation of GNU C Extensions to ANSI C  ------------------------------------------------------   The file dwarfout.c has been designed and implemented so as to provide  some reasonable DWARF representation for each and every declarative  construct which is accepted by the GNU C compiler.  Since the GNU C  compiler accepts a superset of ANSI C, this means that there are some  cases in which the DWARF information produced by GCC must take some  liberties in improvising DWARF representations for declarations which  are only valid in (extended) GNU C.   In particular, GNU C provides at least three significant extensions to  ANSI C when it comes to declarations.  These are (1) inline functions,  and (2) dynamic arrays, and (3) incomplete enum types.  (See the GCC  manual for more information on these GNU extensions to ANSI C.)  When  used, these GNU C extensions are represented (in the generated DWARF  output of GCC) in the most natural and intuitively obvious ways.   In the case of inline functions, the DWARF representation is exactly as  called for in the DWARF version 2 (draft) specification for an identical  function written in C++; i.e. we "reuse" the representation of inline  functions which has been defined for C++ to support this GNU C extension.   In the case of dynamic arrays, we use the most obvious representational  mechanism available; i.e. an array type in which the upper bound of  some dimension (usually the first and only dimension) is a variable  rather than a constant.  (See the DWARF version 1 specification for more  details.)   In the case of incomplete enum types, such types are represented simply  as TAG_enumeration_type DIEs which DO NOT contain either AT_byte_size  attributes or AT_element_list attributes.   --------------------------------    Future Directions  -----------------   The codes, formats, and other paraphernalia necessary to provide proper  support for symbolic debugging for the C++ language are still being worked  on by the UI/PLSIG.  The vast majority of the additions to DWARF which will  be needed to completely support C++ have already been hashed out and agreed  upon, but a few small issues (e.g. anonymous unions, access declarations)  are still being discussed.  Also, we in the PLSIG are still discussing  whether or not we need to do anything special for C++ templates.  (At this  time it is not yet clear whether we even need to do anything special for  these.)   With regard to FORTRAN, the UI/PLSIG has defined what is believed to be a  complete and sufficient set of codes and rules for adequately representing  all of FORTRAN 77, and most of Fortran 90 in DWARF.  While some support for  this has been implemented in dwarfout.c, further implementation and testing  is needed.   GNU DWARF support for other languages (i.e. Pascal and Modula) is a moot  issue until there are GNU front-ends for these other languages.   As currently defined, DWARF only describes a (binary) language which can  be used to communicate symbolic debugging information from a compiler  through an assembler and a linker, to a debugger.  There is no clear  specification of what processing should be (or must be) done by the  assembler and/or the linker.  Fortunately, the role of the assembler  is easily inferred (by anyone knowledgeable about assemblers) just by  looking  at examples of assembly-level DWARF code.  Sadly though, the  allowable (or required) processing steps performed by a linker are  harder to infer and (perhaps) even harder to agree upon.  There are  several forms of very useful `post-processing' steps which intelligent  linkers *could* (in theory) perform on object files containing DWARF,  but any and all such link-time transformations are currently both disallowed  and unspecified.   In particular, possible link-time transformations of DWARF code which could  provide significant benefits include (but are not limited to):  	 Commonization of duplicate DIEs obtained from multiple input 	 (object) files.  	 Cross-compilation type checking based upon DWARF type information 	 for objects and functions.  	 Other possible `compacting' transformations designed to save disk 	 space and to reduce linker& debugger I/O activity.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DWARF_DEBUGGING_INFO
end_ifdef

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"dwarf.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"dwarf2asm.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_comment
comment|/* NOTE: In the comments in this file, many references are made to    so called "Debugging Information Entries".  For the sake of brevity,    this term is abbreviated to `DIE' throughout the remainder of this    file.  */
end_comment

begin_comment
comment|/* Note that the implementation of C++ support herein is (as yet) unfinished.    If you want to try to complete it, more power to you.  */
end_comment

begin_comment
comment|/* How to start an assembler comment.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_COMMENT_START
end_ifndef

begin_define
define|#
directive|define
name|ASM_COMMENT_START
value|";#"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* How to print out a register name.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PRINT_REG
end_ifndef

begin_define
define|#
directive|define
name|PRINT_REG
parameter_list|(
name|RTX
parameter_list|,
name|CODE
parameter_list|,
name|FILE
parameter_list|)
define|\
value|fprintf ((FILE), "%s", reg_names[REGNO (RTX)])
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Define a macro which returns nonzero for any tagged type which is    used (directly or indirectly) in the specification of either some    function's return type or some formal parameter of some function.    We use this macro when we are operating in "terse" mode to help us    know what tagged types have to be represented in Dwarf (even in    terse mode) and which ones don't.     A flag bit with this meaning really should be a part of the normal    GCC ..._TYPE nodes, but at the moment, there is no such bit defined    for these nodes.  For now, we have to just fake it.  It it safe for    us to simply return zero for all complete tagged types (which will    get forced out anyway if they were used in the specification of some    formal or return type) and nonzero for all incomplete tagged types. */
end_comment

begin_define
define|#
directive|define
name|TYPE_USED_FOR_FUNCTION
parameter_list|(
name|tagged_type
parameter_list|)
value|(TYPE_SIZE (tagged_type) == 0)
end_define

begin_comment
comment|/* Define a macro which returns nonzero for a TYPE_DECL which was    implicitly generated for a tagged type.     Note that unlike the gcc front end (which generates a NULL named    TYPE_DECL node for each complete tagged type, each array type, and    each function type node created) the g++ front end generates a    _named_ TYPE_DECL node for each tagged type node created.    These TYPE_DECLs have DECL_ARTIFICIAL set, so we know not to    generate a DW_TAG_typedef DIE for them.  */
end_comment

begin_define
define|#
directive|define
name|TYPE_DECL_IS_STUB
parameter_list|(
name|decl
parameter_list|)
define|\
value|(DECL_NAME (decl) == NULL				\    || (DECL_ARTIFICIAL (decl)				\&& is_tagged_type (TREE_TYPE (decl))		\&& decl == TYPE_STUB_DECL (TREE_TYPE (decl))))
end_define

begin_comment
comment|/* Maximum size (in bytes) of an artificially generated label.	*/
end_comment

begin_define
define|#
directive|define
name|MAX_ARTIFICIAL_LABEL_BYTES
value|30
end_define

begin_escape
end_escape

begin_comment
comment|/* Structure to keep track of source filenames.  */
end_comment

begin_struct
struct|struct
name|filename_entry
block|{
name|unsigned
name|number
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|filename_entry
name|filename_entry
typedef|;
end_typedef

begin_comment
comment|/* Pointer to an array of elements, each one having the structure above.  */
end_comment

begin_decl_stmt
specifier|static
name|filename_entry
modifier|*
name|filename_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Total number of entries in the table (i.e. array) pointed to by    `filename_table'.  This is the *total* and includes both used and    unused slots.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|ft_entries_allocated
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of entries in the filename_table which are actually in use.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|ft_entries
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size (in elements) of increments by which we may expand the filename    table.  Actually, a single hunk of space of this size should be enough    for most typical programs.	 */
end_comment

begin_define
define|#
directive|define
name|FT_ENTRIES_INCREMENT
value|64
end_define

begin_comment
comment|/* Local pointer to the name of the main input file.  Initialized in    dwarfout_init.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|primary_filename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Counter to generate unique names for DIEs.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|next_unused_dienum
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of the DIE which is currently being generated.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|current_dienum
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number to use for the special "pubname" label on the next DIE which    represents a function or data object defined in this compilation    unit which has "extern" linkage.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|next_pubname_number
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NEXT_DIE_NUM
value|pending_sibling_stack[pending_siblings-1]
end_define

begin_comment
comment|/* Pointer to a dynamically allocated list of pre-reserved and still    pending sibling DIE numbers.	 Note that this list will grow as needed.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
modifier|*
name|pending_sibling_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Counter to keep track of the number of pre-reserved and still pending    sibling DIE numbers.	 */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|pending_siblings
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The currently allocated size of the above list (expressed in number of    list elements).  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|pending_siblings_allocated
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size (in elements) of increments by which we may expand the pending    sibling stack.  Actually, a single hunk of space of this size should    be enough for most typical programs.	 */
end_comment

begin_define
define|#
directive|define
name|PENDING_SIBLINGS_INCREMENT
value|64
end_define

begin_comment
comment|/* Nonzero if we are performing our file-scope finalization pass and if    we should force out Dwarf descriptions of any and all file-scope    tagged types which are still incomplete types.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|finalizing
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A pointer to the base of a list of pending types which we haven't    generated DIEs for yet, but which we will have to come back to    later on.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
modifier|*
name|pending_types_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements currently allocated for the pending_types_list.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|pending_types_allocated
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements of pending_types_list currently in use.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|pending_types
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size (in elements) of increments by which we may expand the pending    types list.  Actually, a single hunk of space of this size should    be enough for most typical programs.	 */
end_comment

begin_define
define|#
directive|define
name|PENDING_TYPES_INCREMENT
value|64
end_define

begin_comment
comment|/* A pointer to the base of a list of incomplete types which might be    completed at some later time.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
modifier|*
name|incomplete_types_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements currently allocated for the incomplete_types_list.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|incomplete_types_allocated
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements of incomplete_types_list currently in use.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|incomplete_types
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size (in elements) of increments by which we may expand the incomplete    types list.  Actually, a single hunk of space of this size should    be enough for most typical programs.	 */
end_comment

begin_define
define|#
directive|define
name|INCOMPLETE_TYPES_INCREMENT
value|64
end_define

begin_comment
comment|/* Pointer to an artificial RECORD_TYPE which we create in dwarfout_init.    This is used in a hack to help us get the DIEs describing types of    formal parameters to come *after* all of the DIEs describing the formal    parameters themselves.  That's necessary in order to be compatible    with what the brain-damaged svr4 SDB debugger requires.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|fake_containing_scope
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A pointer to the ..._DECL node which we have most recently been working    on.  We keep this around just in case something about it looks screwy    and we want to tell the user what the source coordinates for the actual    declaration are.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|dwarf_last_decl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A flag indicating that we are emitting the member declarations of a    class, so member functions and variables should not be entirely emitted.    This is a kludge to avoid passing a second argument to output_*_die.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|in_class
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declarations for functions defined in this file.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|dwarfout_init
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dwarfout_finish
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dwarfout_define
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dwarfout_undef
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dwarfout_start_source_file
name|PARAMS
argument_list|(
operator|(
name|unsigned
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dwarfout_start_source_file_check
name|PARAMS
argument_list|(
operator|(
name|unsigned
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dwarfout_end_source_file
name|PARAMS
argument_list|(
operator|(
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dwarfout_end_source_file_check
name|PARAMS
argument_list|(
operator|(
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dwarfout_begin_block
name|PARAMS
argument_list|(
operator|(
name|unsigned
operator|,
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dwarfout_end_block
name|PARAMS
argument_list|(
operator|(
name|unsigned
operator|,
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dwarfout_end_epilogue
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dwarfout_source_line
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dwarfout_end_prologue
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dwarfout_end_function
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dwarfout_function_decl
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dwarfout_global_decl
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dwarfout_deferred_inline_function
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dwarfout_file_scope_decl
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|dwarf_tag_name
name|PARAMS
argument_list|(
operator|(
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|dwarf_attr_name
name|PARAMS
argument_list|(
operator|(
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|dwarf_stack_op_name
name|PARAMS
argument_list|(
operator|(
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|dwarf_typemod_name
name|PARAMS
argument_list|(
operator|(
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|dwarf_fmt_byte_name
name|PARAMS
argument_list|(
operator|(
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|dwarf_fund_type_name
name|PARAMS
argument_list|(
operator|(
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|decl_ultimate_origin
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|block_ultimate_origin
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|decl_class_context
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void output_unsigned_leb128	PARAMS ((unsigned long)); static void output_signed_leb128	PARAMS ((long));
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|fundamental_type_code
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|root_type_1
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|root_type
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_modifier_bytes_1
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_modifier_bytes
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|int
name|type_is_fundamental
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|equate_decl_number_to_die_number
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|void
name|equate_type_number_to_die_number
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_reg_number
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_mem_loc_descriptor
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_loc_descriptor
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_bound_representation
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|unsigned
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_enumeral_list
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|HOST_WIDE_INT
name|ceiling
name|PARAMS
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|tree
name|field_type
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|unsigned
name|int
name|simple_type_align_in_bits
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|unsigned
name|HOST_WIDE_INT
name|simple_type_size_in_bits
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|HOST_WIDE_INT
name|field_byte_offset
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|void
name|sibling_attribute
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|location_attribute
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|data_member_location_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|const_value_attribute
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|location_or_const_value_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|void
name|name_attribute
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|void
name|fund_type_attribute
name|PARAMS
argument_list|(
operator|(
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mod_fund_type_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|void
name|user_def_type_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mod_u_d_type_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|USE_ORDERING_ATTRIBUTE
end_ifdef

begin_decl_stmt
specifier|static
specifier|inline
name|void
name|ordering_attribute
name|PARAMS
argument_list|(
operator|(
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(USE_ORDERING_ATTRIBUTE) */
end_comment

begin_decl_stmt
specifier|static
name|void
name|subscript_data_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|byte_size_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|void
name|bit_offset_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|void
name|bit_size_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|void
name|element_list_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|void
name|stmt_list_attribute
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|void
name|low_pc_attribute
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|void
name|high_pc_attribute
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|void
name|body_begin_attribute
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|void
name|body_end_attribute
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|void
name|language_attribute
name|PARAMS
argument_list|(
operator|(
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|void
name|member_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static inline void string_length_attribute PARAMS ((tree));
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|inline
name|void
name|comp_dir_attribute
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|void
name|sf_names_attribute
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|void
name|src_info_attribute
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|void
name|mac_info_attribute
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|void
name|prototyped_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|void
name|producer_attribute
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|void
name|inline_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|void
name|containing_type_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|void
name|abstract_origin_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DWARF_DECL_COORDINATES
end_ifdef

begin_decl_stmt
specifier|static
specifier|inline
name|void
name|src_coords_attribute
name|PARAMS
argument_list|(
operator|(
name|unsigned
operator|,
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(DWARF_DECL_COORDINATES) */
end_comment

begin_decl_stmt
specifier|static
specifier|inline
name|void
name|pure_or_virtual_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|name_and_src_coords_attributes
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|type_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|type_tag
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|void
name|dienum_push
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|void
name|dienum_pop
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|tree
name|member_declared_type
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|function_start_label
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_array_type_die
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_set_type_die
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void output_entry_point_die	PARAMS ((void *));
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|output_inlined_enumeration_type_die
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_inlined_structure_type_die
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_inlined_union_type_die
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_enumeration_type_die
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_formal_parameter_die
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_global_subroutine_die
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_global_variable_die
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_label_die
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_lexical_block_die
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_inlined_subroutine_die
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_local_variable_die
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_member_die
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void output_pointer_type_die	PARAMS ((void *)); static void output_reference_type_die	PARAMS ((void *));
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|output_ptr_to_mbr_type_die
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_compile_unit_die
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_string_type_die
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_inheritance_die
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_structure_type_die
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_local_subroutine_die
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_subroutine_type_die
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_typedef_die
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_union_type_die
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_unspecified_parameters_die
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_padded_null_die
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_die
name|PARAMS
argument_list|(
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|end_sibling_chain
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_formal_types
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pend_type
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|type_ok_for_scope
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_pending_types_for_scope
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_type
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_tagged_type_instantiation
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_block
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_decls_for_scope
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_decl
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|shuffle_filename_entry
name|PARAMS
argument_list|(
operator|(
name|filename_entry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|generate_new_sfname_entry
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|lookup_filename
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|generate_srcinfo_entry
name|PARAMS
argument_list|(
operator|(
name|unsigned
operator|,
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|generate_macinfo_entry
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|,
name|rtx
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_pseudo_reg
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|type_main_variant
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_tagged_type
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_redundant_typedef
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_incomplete_type
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|retry_incomplete_types
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Definitions of defaults for assembler-dependent names of various    pseudo-ops and section names.     Theses may be overridden in your tm.h file (if necessary) for your    particular assembler.  The default values provided here correspond to    what is expected by "standard" AT&T System V.4 assemblers.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|FILE_ASM_OP
end_ifndef

begin_define
define|#
directive|define
name|FILE_ASM_OP
value|"\t.file\t"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SET_ASM_OP
end_ifndef

begin_define
define|#
directive|define
name|SET_ASM_OP
value|"\t.set\t"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Pseudo-ops for pushing the current section onto the section stack (and    simultaneously changing to a new section) and for poping back to the    section we were in immediately before this one.  Note that most svr4    assemblers only maintain a one level stack... you can push all the    sections you want, but you can only pop out one level.  (The sparc    svr4 assembler is an exception to this general rule.)  That's    OK because we only use at most one level of the section stack herein.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PUSHSECTION_ASM_OP
end_ifndef

begin_define
define|#
directive|define
name|PUSHSECTION_ASM_OP
value|"\t.section\t"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|POPSECTION_ASM_OP
end_ifndef

begin_define
define|#
directive|define
name|POPSECTION_ASM_OP
value|"\t.previous"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The default format used by the ASM_OUTPUT_PUSH_SECTION macro (see below)    to print the PUSHSECTION_ASM_OP and the section name.  The default here    works for almost all svr4 assemblers, except for the sparc, where the    section name must be enclosed in double quotes.  (See sparcv4.h.)  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PUSHSECTION_FORMAT
end_ifndef

begin_define
define|#
directive|define
name|PUSHSECTION_FORMAT
value|"%s%s\n"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG_SECTION
end_ifndef

begin_define
define|#
directive|define
name|DEBUG_SECTION
value|".debug"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LINE_SECTION
end_ifndef

begin_define
define|#
directive|define
name|LINE_SECTION
value|".line"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG_SFNAMES_SECTION
end_ifndef

begin_define
define|#
directive|define
name|DEBUG_SFNAMES_SECTION
value|".debug_sfnames"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG_SRCINFO_SECTION
end_ifndef

begin_define
define|#
directive|define
name|DEBUG_SRCINFO_SECTION
value|".debug_srcinfo"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG_MACINFO_SECTION
end_ifndef

begin_define
define|#
directive|define
name|DEBUG_MACINFO_SECTION
value|".debug_macinfo"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG_PUBNAMES_SECTION
end_ifndef

begin_define
define|#
directive|define
name|DEBUG_PUBNAMES_SECTION
value|".debug_pubnames"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG_ARANGES_SECTION
end_ifndef

begin_define
define|#
directive|define
name|DEBUG_ARANGES_SECTION
value|".debug_aranges"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TEXT_SECTION_NAME
end_ifndef

begin_define
define|#
directive|define
name|TEXT_SECTION_NAME
value|".text"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DATA_SECTION_NAME
end_ifndef

begin_define
define|#
directive|define
name|DATA_SECTION_NAME
value|".data"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DATA1_SECTION_NAME
end_ifndef

begin_define
define|#
directive|define
name|DATA1_SECTION_NAME
value|".data1"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|RODATA_SECTION_NAME
end_ifndef

begin_define
define|#
directive|define
name|RODATA_SECTION_NAME
value|".rodata"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|RODATA1_SECTION_NAME
end_ifndef

begin_define
define|#
directive|define
name|RODATA1_SECTION_NAME
value|".rodata1"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|BSS_SECTION_NAME
end_ifndef

begin_define
define|#
directive|define
name|BSS_SECTION_NAME
value|".bss"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Definitions of defaults for formats and names of various special    (artificial) labels which may be generated within this file (when    the -g options is used and DWARF_DEBUGGING_INFO is in effect.     If necessary, these may be overridden from within your tm.h file,    but typically, you should never need to override these.     These labels have been hacked (temporarily) so that they all begin with    a `.L' sequence so as to appease the stock sparc/svr4 assembler and the    stock m88k/svr4 assembler, both of which need to see .L at the start of    a label in order to prevent that label from going into the linker symbol    table).  When I get time, I'll have to fix this the right way so that we    will use ASM_GENERATE_INTERNAL_LABEL and ASM_OUTPUT_INTERNAL_LABEL herein,    but that will require a rather massive set of changes.  For the moment,    the following definitions out to produce the right results for all svr4    and svr3 assemblers. -- rfg */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TEXT_BEGIN_LABEL
end_ifndef

begin_define
define|#
directive|define
name|TEXT_BEGIN_LABEL
value|"*.L_text_b"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TEXT_END_LABEL
end_ifndef

begin_define
define|#
directive|define
name|TEXT_END_LABEL
value|"*.L_text_e"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DATA_BEGIN_LABEL
end_ifndef

begin_define
define|#
directive|define
name|DATA_BEGIN_LABEL
value|"*.L_data_b"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DATA_END_LABEL
end_ifndef

begin_define
define|#
directive|define
name|DATA_END_LABEL
value|"*.L_data_e"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DATA1_BEGIN_LABEL
end_ifndef

begin_define
define|#
directive|define
name|DATA1_BEGIN_LABEL
value|"*.L_data1_b"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DATA1_END_LABEL
end_ifndef

begin_define
define|#
directive|define
name|DATA1_END_LABEL
value|"*.L_data1_e"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|RODATA_BEGIN_LABEL
end_ifndef

begin_define
define|#
directive|define
name|RODATA_BEGIN_LABEL
value|"*.L_rodata_b"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|RODATA_END_LABEL
end_ifndef

begin_define
define|#
directive|define
name|RODATA_END_LABEL
value|"*.L_rodata_e"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|RODATA1_BEGIN_LABEL
end_ifndef

begin_define
define|#
directive|define
name|RODATA1_BEGIN_LABEL
value|"*.L_rodata1_b"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|RODATA1_END_LABEL
end_ifndef

begin_define
define|#
directive|define
name|RODATA1_END_LABEL
value|"*.L_rodata1_e"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|BSS_BEGIN_LABEL
end_ifndef

begin_define
define|#
directive|define
name|BSS_BEGIN_LABEL
value|"*.L_bss_b"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|BSS_END_LABEL
end_ifndef

begin_define
define|#
directive|define
name|BSS_END_LABEL
value|"*.L_bss_e"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LINE_BEGIN_LABEL
end_ifndef

begin_define
define|#
directive|define
name|LINE_BEGIN_LABEL
value|"*.L_line_b"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LINE_LAST_ENTRY_LABEL
end_ifndef

begin_define
define|#
directive|define
name|LINE_LAST_ENTRY_LABEL
value|"*.L_line_last"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LINE_END_LABEL
end_ifndef

begin_define
define|#
directive|define
name|LINE_END_LABEL
value|"*.L_line_e"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG_BEGIN_LABEL
end_ifndef

begin_define
define|#
directive|define
name|DEBUG_BEGIN_LABEL
value|"*.L_debug_b"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SFNAMES_BEGIN_LABEL
end_ifndef

begin_define
define|#
directive|define
name|SFNAMES_BEGIN_LABEL
value|"*.L_sfnames_b"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SRCINFO_BEGIN_LABEL
end_ifndef

begin_define
define|#
directive|define
name|SRCINFO_BEGIN_LABEL
value|"*.L_srcinfo_b"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MACINFO_BEGIN_LABEL
end_ifndef

begin_define
define|#
directive|define
name|MACINFO_BEGIN_LABEL
value|"*.L_macinfo_b"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG_ARANGES_BEGIN_LABEL
end_ifndef

begin_define
define|#
directive|define
name|DEBUG_ARANGES_BEGIN_LABEL
value|"*.L_debug_aranges_begin"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG_ARANGES_END_LABEL
end_ifndef

begin_define
define|#
directive|define
name|DEBUG_ARANGES_END_LABEL
value|"*.L_debug_aranges_end"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DIE_BEGIN_LABEL_FMT
end_ifndef

begin_define
define|#
directive|define
name|DIE_BEGIN_LABEL_FMT
value|"*.L_D%u"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DIE_END_LABEL_FMT
end_ifndef

begin_define
define|#
directive|define
name|DIE_END_LABEL_FMT
value|"*.L_D%u_e"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PUB_DIE_LABEL_FMT
end_ifndef

begin_define
define|#
directive|define
name|PUB_DIE_LABEL_FMT
value|"*.L_P%u"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|BLOCK_BEGIN_LABEL_FMT
end_ifndef

begin_define
define|#
directive|define
name|BLOCK_BEGIN_LABEL_FMT
value|"*.L_B%u"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|BLOCK_END_LABEL_FMT
end_ifndef

begin_define
define|#
directive|define
name|BLOCK_END_LABEL_FMT
value|"*.L_B%u_e"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SS_BEGIN_LABEL_FMT
end_ifndef

begin_define
define|#
directive|define
name|SS_BEGIN_LABEL_FMT
value|"*.L_s%u"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SS_END_LABEL_FMT
end_ifndef

begin_define
define|#
directive|define
name|SS_END_LABEL_FMT
value|"*.L_s%u_e"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|EE_BEGIN_LABEL_FMT
end_ifndef

begin_define
define|#
directive|define
name|EE_BEGIN_LABEL_FMT
value|"*.L_e%u"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|EE_END_LABEL_FMT
end_ifndef

begin_define
define|#
directive|define
name|EE_END_LABEL_FMT
value|"*.L_e%u_e"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MT_BEGIN_LABEL_FMT
end_ifndef

begin_define
define|#
directive|define
name|MT_BEGIN_LABEL_FMT
value|"*.L_t%u"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MT_END_LABEL_FMT
end_ifndef

begin_define
define|#
directive|define
name|MT_END_LABEL_FMT
value|"*.L_t%u_e"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LOC_BEGIN_LABEL_FMT
end_ifndef

begin_define
define|#
directive|define
name|LOC_BEGIN_LABEL_FMT
value|"*.L_l%u"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LOC_END_LABEL_FMT
end_ifndef

begin_define
define|#
directive|define
name|LOC_END_LABEL_FMT
value|"*.L_l%u_e"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|BOUND_BEGIN_LABEL_FMT
end_ifndef

begin_define
define|#
directive|define
name|BOUND_BEGIN_LABEL_FMT
value|"*.L_b%u_%u_%c"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|BOUND_END_LABEL_FMT
end_ifndef

begin_define
define|#
directive|define
name|BOUND_END_LABEL_FMT
value|"*.L_b%u_%u_%c_e"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|BODY_BEGIN_LABEL_FMT
end_ifndef

begin_define
define|#
directive|define
name|BODY_BEGIN_LABEL_FMT
value|"*.L_b%u"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|BODY_END_LABEL_FMT
end_ifndef

begin_define
define|#
directive|define
name|BODY_END_LABEL_FMT
value|"*.L_b%u_e"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|FUNC_END_LABEL_FMT
end_ifndef

begin_define
define|#
directive|define
name|FUNC_END_LABEL_FMT
value|"*.L_f%u_e"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TYPE_NAME_FMT
end_ifndef

begin_define
define|#
directive|define
name|TYPE_NAME_FMT
value|"*.L_T%u"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DECL_NAME_FMT
end_ifndef

begin_define
define|#
directive|define
name|DECL_NAME_FMT
value|"*.L_E%u"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LINE_CODE_LABEL_FMT
end_ifndef

begin_define
define|#
directive|define
name|LINE_CODE_LABEL_FMT
value|"*.L_LC%u"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SFNAMES_ENTRY_LABEL_FMT
end_ifndef

begin_define
define|#
directive|define
name|SFNAMES_ENTRY_LABEL_FMT
value|"*.L_F%u"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LINE_ENTRY_LABEL_FMT
end_ifndef

begin_define
define|#
directive|define
name|LINE_ENTRY_LABEL_FMT
value|"*.L_LE%u"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Definitions of defaults for various types of primitive assembly language    output operations.     If necessary, these may be overridden from within your tm.h file,    but typically, you shouldn't need to override these.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_PUSH_SECTION
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_PUSH_SECTION
parameter_list|(
name|FILE
parameter_list|,
name|SECTION
parameter_list|)
define|\
value|fprintf ((FILE), PUSHSECTION_FORMAT, PUSHSECTION_ASM_OP, SECTION)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_POP_SECTION
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_POP_SECTION
parameter_list|(
name|FILE
parameter_list|)
define|\
value|fprintf ((FILE), "%s\n", POPSECTION_ASM_OP)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_DWARF_DELTA2
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_DWARF_DELTA2
parameter_list|(
name|FILE
parameter_list|,
name|LABEL1
parameter_list|,
name|LABEL2
parameter_list|)
define|\
value|dw2_asm_output_delta (2, LABEL1, LABEL2, NULL)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_DWARF_DELTA4
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_DWARF_DELTA4
parameter_list|(
name|FILE
parameter_list|,
name|LABEL1
parameter_list|,
name|LABEL2
parameter_list|)
define|\
value|dw2_asm_output_delta (4, LABEL1, LABEL2, NULL)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_DWARF_TAG
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_DWARF_TAG
parameter_list|(
name|FILE
parameter_list|,
name|TAG
parameter_list|)
define|\
value|dw2_asm_output_data (2, TAG, "%s", dwarf_tag_name (TAG));
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_DWARF_ATTRIBUTE
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_DWARF_ATTRIBUTE
parameter_list|(
name|FILE
parameter_list|,
name|ATTR
parameter_list|)
define|\
value|dw2_asm_output_data (2, ATTR, "%s", dwarf_attr_name (ATTR))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_DWARF_STACK_OP
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_DWARF_STACK_OP
parameter_list|(
name|FILE
parameter_list|,
name|OP
parameter_list|)
define|\
value|dw2_asm_output_data (1, OP, "%s", dwarf_stack_op_name (OP))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_DWARF_FUND_TYPE
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_DWARF_FUND_TYPE
parameter_list|(
name|FILE
parameter_list|,
name|FT
parameter_list|)
define|\
value|dw2_asm_output_data (2, FT, "%s", dwarf_fund_type_name (FT))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_DWARF_FMT_BYTE
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_DWARF_FMT_BYTE
parameter_list|(
name|FILE
parameter_list|,
name|FMT
parameter_list|)
define|\
value|dw2_asm_output_data (1, FMT, "%s", dwarf_fmt_byte_name (FMT));
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_DWARF_TYPE_MODIFIER
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_DWARF_TYPE_MODIFIER
parameter_list|(
name|FILE
parameter_list|,
name|MOD
parameter_list|)
define|\
value|dw2_asm_output_data (1, MOD, "%s", dwarf_typemod_name (MOD));
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_DWARF_ADDR
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_DWARF_ADDR
parameter_list|(
name|FILE
parameter_list|,
name|LABEL
parameter_list|)
define|\
value|dw2_asm_output_addr (4, LABEL, NULL)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_DWARF_ADDR_CONST
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_DWARF_ADDR_CONST
parameter_list|(
name|FILE
parameter_list|,
name|RTX
parameter_list|)
define|\
value|dw2_asm_output_addr_rtx (4, RTX, NULL)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_DWARF_REF
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_DWARF_REF
parameter_list|(
name|FILE
parameter_list|,
name|LABEL
parameter_list|)
define|\
value|dw2_asm_output_addr (4, LABEL, NULL)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_DWARF_DATA1
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_DWARF_DATA1
parameter_list|(
name|FILE
parameter_list|,
name|VALUE
parameter_list|)
define|\
value|dw2_asm_output_data (1, VALUE, NULL)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_DWARF_DATA2
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_DWARF_DATA2
parameter_list|(
name|FILE
parameter_list|,
name|VALUE
parameter_list|)
define|\
value|dw2_asm_output_data (2, VALUE, NULL)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_DWARF_DATA4
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_DWARF_DATA4
parameter_list|(
name|FILE
parameter_list|,
name|VALUE
parameter_list|)
define|\
value|dw2_asm_output_data (4, VALUE, NULL)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_DWARF_DATA8
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_DWARF_DATA8
parameter_list|(
name|FILE
parameter_list|,
name|HIGH_VALUE
parameter_list|,
name|LOW_VALUE
parameter_list|)
define|\
value|dw2_asm_output_data (8, VALUE, NULL)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ASM_OUTPUT_DWARF_STRING is defined to output an ascii string, but to    NOT issue a trailing newline. We define ASM_OUTPUT_DWARF_STRING_NEWLINE    based on whether ASM_OUTPUT_DWARF_STRING is defined or not. If it is    defined, we call it, then issue the line feed. If not, we supply a    default definition of calling ASM_OUTPUT_ASCII */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_DWARF_STRING
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_DWARF_STRING_NEWLINE
parameter_list|(
name|FILE
parameter_list|,
name|P
parameter_list|)
define|\
value|ASM_OUTPUT_ASCII ((FILE), P, strlen (P)+1)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ASM_OUTPUT_DWARF_STRING_NEWLINE
parameter_list|(
name|FILE
parameter_list|,
name|P
parameter_list|)
define|\
value|ASM_OUTPUT_DWARF_STRING (FILE,P), ASM_OUTPUT_DWARF_STRING (FILE,"\n")
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* The debug hooks structure.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|gcc_debug_hooks
name|dwarf_debug_hooks
init|=
block|{
name|dwarfout_init
block|,
name|dwarfout_finish
block|,
name|dwarfout_define
block|,
name|dwarfout_undef
block|,
name|dwarfout_start_source_file_check
block|,
name|dwarfout_end_source_file_check
block|,
name|dwarfout_begin_block
block|,
name|dwarfout_end_block
block|,
name|debug_true_tree
block|,
comment|/* ignore_block */
name|dwarfout_source_line
block|,
comment|/* source_line */
name|dwarfout_source_line
block|,
comment|/* begin_prologue */
name|dwarfout_end_prologue
block|,
name|dwarfout_end_epilogue
block|,
name|debug_nothing_tree
block|,
comment|/* begin_function */
name|dwarfout_end_function
block|,
name|dwarfout_function_decl
block|,
name|dwarfout_global_decl
block|,
name|dwarfout_deferred_inline_function
block|,
name|debug_nothing_tree
block|,
comment|/* outlining_inline_function */
name|debug_nothing_rtx
comment|/* label */
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/************************ general utility functions **************************/
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|is_pseudo_reg
parameter_list|(
name|rtl
parameter_list|)
name|rtx
name|rtl
decl_stmt|;
block|{
return|return
operator|(
operator|(
operator|(
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
operator|==
name|REG
operator|)
operator|&&
operator|(
name|REGNO
argument_list|(
name|rtl
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|)
operator|||
operator|(
operator|(
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
operator|==
name|SUBREG
operator|)
operator|&&
operator|(
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|rtl
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|tree
name|type_main_variant
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* There really should be only one main variant among any group of variants      of a given type (and all of the MAIN_VARIANT values for all members of      the group should point to that one type) but sometimes the C front-end      messes this up for array types, so we work around that bug here.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
while|while
condition|(
name|type
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
condition|)
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if the given type node represents a tagged type.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|is_tagged_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
return|return
operator|(
name|code
operator|==
name|RECORD_TYPE
operator|||
name|code
operator|==
name|UNION_TYPE
operator|||
name|code
operator|==
name|QUAL_UNION_TYPE
operator|||
name|code
operator|==
name|ENUMERAL_TYPE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|dwarf_tag_name
parameter_list|(
name|tag
parameter_list|)
name|unsigned
name|tag
decl_stmt|;
block|{
switch|switch
condition|(
name|tag
condition|)
block|{
case|case
name|TAG_padding
case|:
return|return
literal|"TAG_padding"
return|;
case|case
name|TAG_array_type
case|:
return|return
literal|"TAG_array_type"
return|;
case|case
name|TAG_class_type
case|:
return|return
literal|"TAG_class_type"
return|;
case|case
name|TAG_entry_point
case|:
return|return
literal|"TAG_entry_point"
return|;
case|case
name|TAG_enumeration_type
case|:
return|return
literal|"TAG_enumeration_type"
return|;
case|case
name|TAG_formal_parameter
case|:
return|return
literal|"TAG_formal_parameter"
return|;
case|case
name|TAG_global_subroutine
case|:
return|return
literal|"TAG_global_subroutine"
return|;
case|case
name|TAG_global_variable
case|:
return|return
literal|"TAG_global_variable"
return|;
case|case
name|TAG_label
case|:
return|return
literal|"TAG_label"
return|;
case|case
name|TAG_lexical_block
case|:
return|return
literal|"TAG_lexical_block"
return|;
case|case
name|TAG_local_variable
case|:
return|return
literal|"TAG_local_variable"
return|;
case|case
name|TAG_member
case|:
return|return
literal|"TAG_member"
return|;
case|case
name|TAG_pointer_type
case|:
return|return
literal|"TAG_pointer_type"
return|;
case|case
name|TAG_reference_type
case|:
return|return
literal|"TAG_reference_type"
return|;
case|case
name|TAG_compile_unit
case|:
return|return
literal|"TAG_compile_unit"
return|;
case|case
name|TAG_string_type
case|:
return|return
literal|"TAG_string_type"
return|;
case|case
name|TAG_structure_type
case|:
return|return
literal|"TAG_structure_type"
return|;
case|case
name|TAG_subroutine
case|:
return|return
literal|"TAG_subroutine"
return|;
case|case
name|TAG_subroutine_type
case|:
return|return
literal|"TAG_subroutine_type"
return|;
case|case
name|TAG_typedef
case|:
return|return
literal|"TAG_typedef"
return|;
case|case
name|TAG_union_type
case|:
return|return
literal|"TAG_union_type"
return|;
case|case
name|TAG_unspecified_parameters
case|:
return|return
literal|"TAG_unspecified_parameters"
return|;
case|case
name|TAG_variant
case|:
return|return
literal|"TAG_variant"
return|;
case|case
name|TAG_common_block
case|:
return|return
literal|"TAG_common_block"
return|;
case|case
name|TAG_common_inclusion
case|:
return|return
literal|"TAG_common_inclusion"
return|;
case|case
name|TAG_inheritance
case|:
return|return
literal|"TAG_inheritance"
return|;
case|case
name|TAG_inlined_subroutine
case|:
return|return
literal|"TAG_inlined_subroutine"
return|;
case|case
name|TAG_module
case|:
return|return
literal|"TAG_module"
return|;
case|case
name|TAG_ptr_to_member_type
case|:
return|return
literal|"TAG_ptr_to_member_type"
return|;
case|case
name|TAG_set_type
case|:
return|return
literal|"TAG_set_type"
return|;
case|case
name|TAG_subrange_type
case|:
return|return
literal|"TAG_subrange_type"
return|;
case|case
name|TAG_with_stmt
case|:
return|return
literal|"TAG_with_stmt"
return|;
comment|/* GNU extensions.  */
case|case
name|TAG_format_label
case|:
return|return
literal|"TAG_format_label"
return|;
case|case
name|TAG_namelist
case|:
return|return
literal|"TAG_namelist"
return|;
case|case
name|TAG_function_template
case|:
return|return
literal|"TAG_function_template"
return|;
case|case
name|TAG_class_template
case|:
return|return
literal|"TAG_class_template"
return|;
default|default:
return|return
literal|"TAG_<unknown>"
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|dwarf_attr_name
parameter_list|(
name|attr
parameter_list|)
name|unsigned
name|attr
decl_stmt|;
block|{
switch|switch
condition|(
name|attr
condition|)
block|{
case|case
name|AT_sibling
case|:
return|return
literal|"AT_sibling"
return|;
case|case
name|AT_location
case|:
return|return
literal|"AT_location"
return|;
case|case
name|AT_name
case|:
return|return
literal|"AT_name"
return|;
case|case
name|AT_fund_type
case|:
return|return
literal|"AT_fund_type"
return|;
case|case
name|AT_mod_fund_type
case|:
return|return
literal|"AT_mod_fund_type"
return|;
case|case
name|AT_user_def_type
case|:
return|return
literal|"AT_user_def_type"
return|;
case|case
name|AT_mod_u_d_type
case|:
return|return
literal|"AT_mod_u_d_type"
return|;
case|case
name|AT_ordering
case|:
return|return
literal|"AT_ordering"
return|;
case|case
name|AT_subscr_data
case|:
return|return
literal|"AT_subscr_data"
return|;
case|case
name|AT_byte_size
case|:
return|return
literal|"AT_byte_size"
return|;
case|case
name|AT_bit_offset
case|:
return|return
literal|"AT_bit_offset"
return|;
case|case
name|AT_bit_size
case|:
return|return
literal|"AT_bit_size"
return|;
case|case
name|AT_element_list
case|:
return|return
literal|"AT_element_list"
return|;
case|case
name|AT_stmt_list
case|:
return|return
literal|"AT_stmt_list"
return|;
case|case
name|AT_low_pc
case|:
return|return
literal|"AT_low_pc"
return|;
case|case
name|AT_high_pc
case|:
return|return
literal|"AT_high_pc"
return|;
case|case
name|AT_language
case|:
return|return
literal|"AT_language"
return|;
case|case
name|AT_member
case|:
return|return
literal|"AT_member"
return|;
case|case
name|AT_discr
case|:
return|return
literal|"AT_discr"
return|;
case|case
name|AT_discr_value
case|:
return|return
literal|"AT_discr_value"
return|;
case|case
name|AT_string_length
case|:
return|return
literal|"AT_string_length"
return|;
case|case
name|AT_common_reference
case|:
return|return
literal|"AT_common_reference"
return|;
case|case
name|AT_comp_dir
case|:
return|return
literal|"AT_comp_dir"
return|;
case|case
name|AT_const_value_string
case|:
return|return
literal|"AT_const_value_string"
return|;
case|case
name|AT_const_value_data2
case|:
return|return
literal|"AT_const_value_data2"
return|;
case|case
name|AT_const_value_data4
case|:
return|return
literal|"AT_const_value_data4"
return|;
case|case
name|AT_const_value_data8
case|:
return|return
literal|"AT_const_value_data8"
return|;
case|case
name|AT_const_value_block2
case|:
return|return
literal|"AT_const_value_block2"
return|;
case|case
name|AT_const_value_block4
case|:
return|return
literal|"AT_const_value_block4"
return|;
case|case
name|AT_containing_type
case|:
return|return
literal|"AT_containing_type"
return|;
case|case
name|AT_default_value_addr
case|:
return|return
literal|"AT_default_value_addr"
return|;
case|case
name|AT_default_value_data2
case|:
return|return
literal|"AT_default_value_data2"
return|;
case|case
name|AT_default_value_data4
case|:
return|return
literal|"AT_default_value_data4"
return|;
case|case
name|AT_default_value_data8
case|:
return|return
literal|"AT_default_value_data8"
return|;
case|case
name|AT_default_value_string
case|:
return|return
literal|"AT_default_value_string"
return|;
case|case
name|AT_friends
case|:
return|return
literal|"AT_friends"
return|;
case|case
name|AT_inline
case|:
return|return
literal|"AT_inline"
return|;
case|case
name|AT_is_optional
case|:
return|return
literal|"AT_is_optional"
return|;
case|case
name|AT_lower_bound_ref
case|:
return|return
literal|"AT_lower_bound_ref"
return|;
case|case
name|AT_lower_bound_data2
case|:
return|return
literal|"AT_lower_bound_data2"
return|;
case|case
name|AT_lower_bound_data4
case|:
return|return
literal|"AT_lower_bound_data4"
return|;
case|case
name|AT_lower_bound_data8
case|:
return|return
literal|"AT_lower_bound_data8"
return|;
case|case
name|AT_private
case|:
return|return
literal|"AT_private"
return|;
case|case
name|AT_producer
case|:
return|return
literal|"AT_producer"
return|;
case|case
name|AT_program
case|:
return|return
literal|"AT_program"
return|;
case|case
name|AT_protected
case|:
return|return
literal|"AT_protected"
return|;
case|case
name|AT_prototyped
case|:
return|return
literal|"AT_prototyped"
return|;
case|case
name|AT_public
case|:
return|return
literal|"AT_public"
return|;
case|case
name|AT_pure_virtual
case|:
return|return
literal|"AT_pure_virtual"
return|;
case|case
name|AT_return_addr
case|:
return|return
literal|"AT_return_addr"
return|;
case|case
name|AT_abstract_origin
case|:
return|return
literal|"AT_abstract_origin"
return|;
case|case
name|AT_start_scope
case|:
return|return
literal|"AT_start_scope"
return|;
case|case
name|AT_stride_size
case|:
return|return
literal|"AT_stride_size"
return|;
case|case
name|AT_upper_bound_ref
case|:
return|return
literal|"AT_upper_bound_ref"
return|;
case|case
name|AT_upper_bound_data2
case|:
return|return
literal|"AT_upper_bound_data2"
return|;
case|case
name|AT_upper_bound_data4
case|:
return|return
literal|"AT_upper_bound_data4"
return|;
case|case
name|AT_upper_bound_data8
case|:
return|return
literal|"AT_upper_bound_data8"
return|;
case|case
name|AT_virtual
case|:
return|return
literal|"AT_virtual"
return|;
comment|/* GNU extensions */
case|case
name|AT_sf_names
case|:
return|return
literal|"AT_sf_names"
return|;
case|case
name|AT_src_info
case|:
return|return
literal|"AT_src_info"
return|;
case|case
name|AT_mac_info
case|:
return|return
literal|"AT_mac_info"
return|;
case|case
name|AT_src_coords
case|:
return|return
literal|"AT_src_coords"
return|;
case|case
name|AT_body_begin
case|:
return|return
literal|"AT_body_begin"
return|;
case|case
name|AT_body_end
case|:
return|return
literal|"AT_body_end"
return|;
default|default:
return|return
literal|"AT_<unknown>"
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|dwarf_stack_op_name
parameter_list|(
name|op
parameter_list|)
name|unsigned
name|op
decl_stmt|;
block|{
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|OP_REG
case|:
return|return
literal|"OP_REG"
return|;
case|case
name|OP_BASEREG
case|:
return|return
literal|"OP_BASEREG"
return|;
case|case
name|OP_ADDR
case|:
return|return
literal|"OP_ADDR"
return|;
case|case
name|OP_CONST
case|:
return|return
literal|"OP_CONST"
return|;
case|case
name|OP_DEREF2
case|:
return|return
literal|"OP_DEREF2"
return|;
case|case
name|OP_DEREF4
case|:
return|return
literal|"OP_DEREF4"
return|;
case|case
name|OP_ADD
case|:
return|return
literal|"OP_ADD"
return|;
default|default:
return|return
literal|"OP_<unknown>"
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|dwarf_typemod_name
parameter_list|(
name|mod
parameter_list|)
name|unsigned
name|mod
decl_stmt|;
block|{
switch|switch
condition|(
name|mod
condition|)
block|{
case|case
name|MOD_pointer_to
case|:
return|return
literal|"MOD_pointer_to"
return|;
case|case
name|MOD_reference_to
case|:
return|return
literal|"MOD_reference_to"
return|;
case|case
name|MOD_const
case|:
return|return
literal|"MOD_const"
return|;
case|case
name|MOD_volatile
case|:
return|return
literal|"MOD_volatile"
return|;
default|default:
return|return
literal|"MOD_<unknown>"
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|dwarf_fmt_byte_name
parameter_list|(
name|fmt
parameter_list|)
name|unsigned
name|fmt
decl_stmt|;
block|{
switch|switch
condition|(
name|fmt
condition|)
block|{
case|case
name|FMT_FT_C_C
case|:
return|return
literal|"FMT_FT_C_C"
return|;
case|case
name|FMT_FT_C_X
case|:
return|return
literal|"FMT_FT_C_X"
return|;
case|case
name|FMT_FT_X_C
case|:
return|return
literal|"FMT_FT_X_C"
return|;
case|case
name|FMT_FT_X_X
case|:
return|return
literal|"FMT_FT_X_X"
return|;
case|case
name|FMT_UT_C_C
case|:
return|return
literal|"FMT_UT_C_C"
return|;
case|case
name|FMT_UT_C_X
case|:
return|return
literal|"FMT_UT_C_X"
return|;
case|case
name|FMT_UT_X_C
case|:
return|return
literal|"FMT_UT_X_C"
return|;
case|case
name|FMT_UT_X_X
case|:
return|return
literal|"FMT_UT_X_X"
return|;
case|case
name|FMT_ET
case|:
return|return
literal|"FMT_ET"
return|;
default|default:
return|return
literal|"FMT_<unknown>"
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|dwarf_fund_type_name
parameter_list|(
name|ft
parameter_list|)
name|unsigned
name|ft
decl_stmt|;
block|{
switch|switch
condition|(
name|ft
condition|)
block|{
case|case
name|FT_char
case|:
return|return
literal|"FT_char"
return|;
case|case
name|FT_signed_char
case|:
return|return
literal|"FT_signed_char"
return|;
case|case
name|FT_unsigned_char
case|:
return|return
literal|"FT_unsigned_char"
return|;
case|case
name|FT_short
case|:
return|return
literal|"FT_short"
return|;
case|case
name|FT_signed_short
case|:
return|return
literal|"FT_signed_short"
return|;
case|case
name|FT_unsigned_short
case|:
return|return
literal|"FT_unsigned_short"
return|;
case|case
name|FT_integer
case|:
return|return
literal|"FT_integer"
return|;
case|case
name|FT_signed_integer
case|:
return|return
literal|"FT_signed_integer"
return|;
case|case
name|FT_unsigned_integer
case|:
return|return
literal|"FT_unsigned_integer"
return|;
case|case
name|FT_long
case|:
return|return
literal|"FT_long"
return|;
case|case
name|FT_signed_long
case|:
return|return
literal|"FT_signed_long"
return|;
case|case
name|FT_unsigned_long
case|:
return|return
literal|"FT_unsigned_long"
return|;
case|case
name|FT_pointer
case|:
return|return
literal|"FT_pointer"
return|;
case|case
name|FT_float
case|:
return|return
literal|"FT_float"
return|;
case|case
name|FT_dbl_prec_float
case|:
return|return
literal|"FT_dbl_prec_float"
return|;
case|case
name|FT_ext_prec_float
case|:
return|return
literal|"FT_ext_prec_float"
return|;
case|case
name|FT_complex
case|:
return|return
literal|"FT_complex"
return|;
case|case
name|FT_dbl_prec_complex
case|:
return|return
literal|"FT_dbl_prec_complex"
return|;
case|case
name|FT_void
case|:
return|return
literal|"FT_void"
return|;
case|case
name|FT_boolean
case|:
return|return
literal|"FT_boolean"
return|;
case|case
name|FT_ext_prec_complex
case|:
return|return
literal|"FT_ext_prec_complex"
return|;
case|case
name|FT_label
case|:
return|return
literal|"FT_label"
return|;
comment|/* GNU extensions.  */
case|case
name|FT_long_long
case|:
return|return
literal|"FT_long_long"
return|;
case|case
name|FT_signed_long_long
case|:
return|return
literal|"FT_signed_long_long"
return|;
case|case
name|FT_unsigned_long_long
case|:
return|return
literal|"FT_unsigned_long_long"
return|;
case|case
name|FT_int8
case|:
return|return
literal|"FT_int8"
return|;
case|case
name|FT_signed_int8
case|:
return|return
literal|"FT_signed_int8"
return|;
case|case
name|FT_unsigned_int8
case|:
return|return
literal|"FT_unsigned_int8"
return|;
case|case
name|FT_int16
case|:
return|return
literal|"FT_int16"
return|;
case|case
name|FT_signed_int16
case|:
return|return
literal|"FT_signed_int16"
return|;
case|case
name|FT_unsigned_int16
case|:
return|return
literal|"FT_unsigned_int16"
return|;
case|case
name|FT_int32
case|:
return|return
literal|"FT_int32"
return|;
case|case
name|FT_signed_int32
case|:
return|return
literal|"FT_signed_int32"
return|;
case|case
name|FT_unsigned_int32
case|:
return|return
literal|"FT_unsigned_int32"
return|;
case|case
name|FT_int64
case|:
return|return
literal|"FT_int64"
return|;
case|case
name|FT_signed_int64
case|:
return|return
literal|"FT_signed_int64"
return|;
case|case
name|FT_unsigned_int64
case|:
return|return
literal|"FT_unsigned_int64"
return|;
case|case
name|FT_int128
case|:
return|return
literal|"FT_int128"
return|;
case|case
name|FT_signed_int128
case|:
return|return
literal|"FT_signed_int128"
return|;
case|case
name|FT_unsigned_int128
case|:
return|return
literal|"FT_unsigned_int128"
return|;
case|case
name|FT_real32
case|:
return|return
literal|"FT_real32"
return|;
case|case
name|FT_real64
case|:
return|return
literal|"FT_real64"
return|;
case|case
name|FT_real96
case|:
return|return
literal|"FT_real96"
return|;
case|case
name|FT_real128
case|:
return|return
literal|"FT_real128"
return|;
default|default:
return|return
literal|"FT_<unknown>"
return|;
block|}
block|}
end_function

begin_comment
comment|/* Determine the "ultimate origin" of a decl.  The decl may be an    inlined instance of an inlined instance of a decl which is local    to an inline function, so we have to trace all of the way back    through the origin chain to find out what sort of node actually    served as the original seed for the given block.  */
end_comment

begin_function
specifier|static
name|tree
name|decl_ultimate_origin
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
if|if
condition|(
name|DECL_FROM_INLINE
argument_list|(
name|DECL_ORIGIN
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
comment|/* Since the DECL_ABSTRACT_ORIGIN for a DECL is supposed to be the        most distant ancestor, this should never happen.  */
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|decl
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Determine the "ultimate origin" of a block.  The block may be an    inlined instance of an inlined instance of a block which is local    to an inline function, so we have to trace all of the way back    through the origin chain to find out what sort of node actually    served as the original seed for the given block.  */
end_comment

begin_function
specifier|static
name|tree
name|block_ultimate_origin
parameter_list|(
name|block
parameter_list|)
name|tree
name|block
decl_stmt|;
block|{
name|tree
name|immediate_origin
init|=
name|BLOCK_ABSTRACT_ORIGIN
argument_list|(
name|block
argument_list|)
decl_stmt|;
if|if
condition|(
name|immediate_origin
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
else|else
block|{
name|tree
name|ret_val
decl_stmt|;
name|tree
name|lookahead
init|=
name|immediate_origin
decl_stmt|;
do|do
block|{
name|ret_val
operator|=
name|lookahead
expr_stmt|;
name|lookahead
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|ret_val
argument_list|)
operator|==
name|BLOCK
operator|)
condition|?
name|BLOCK_ABSTRACT_ORIGIN
argument_list|(
name|ret_val
argument_list|)
else|:
name|NULL
expr_stmt|;
block|}
do|while
condition|(
name|lookahead
operator|!=
name|NULL
operator|&&
name|lookahead
operator|!=
name|ret_val
condition|)
do|;
return|return
name|ret_val
return|;
block|}
block|}
end_function

begin_comment
comment|/* Get the class to which DECL belongs, if any.  In g++, the DECL_CONTEXT    of a virtual function may refer to a base class, so we check the 'this'    parameter.  */
end_comment

begin_function
specifier|static
name|tree
name|decl_class_context
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|context
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|||
operator|!
name|DECL_VINDEX
argument_list|(
name|decl
argument_list|)
condition|)
name|context
operator|=
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
else|else
name|context
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|&&
operator|!
name|TYPE_P
argument_list|(
name|context
argument_list|)
condition|)
name|context
operator|=
name|NULL_TREE
expr_stmt|;
return|return
name|context
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static void output_unsigned_leb128 (value)      unsigned long value; {   unsigned long orig_value = value;    do     {       unsigned byte = (value& 0x7f);        value>>= 7;       if (value != 0)
comment|/* more bytes to follow */
end_comment

begin_comment
unit|byte |= 0x80;       dw2_asm_output_data (1, byte, "\t%s ULEB128 number - value = %lu", 			   orig_value);     }   while (value != 0); }  static void output_signed_leb128 (value)      long value; {   long orig_value = value;   int negative = (value< 0);   int more;    do     {       unsigned byte = (value& 0x7f);        value>>= 7;       if (negative) 	value |= 0xfe000000;
comment|/* manually sign extend */
end_comment

begin_endif
unit|if (((value == 0)&& ((byte& 0x40) == 0)) 	  || ((value == -1)&& ((byte& 0x40) == 1))) 	more = 0;       else 	{ 	  byte |= 0x80; 	  more = 1; 	}       dw2_asm_output_data (1, byte, "\t%s SLEB128 number - value = %ld", 			   orig_value);     }   while (more); }
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/**************** utility functions for attribute functions ******************/
end_comment

begin_comment
comment|/* Given a pointer to a tree node for some type, return a Dwarf fundamental    type code for the given type.     This routine must only be called for GCC type nodes that correspond to    Dwarf fundamental types.     The current Dwarf draft specification calls for Dwarf fundamental types    to accurately reflect the fact that a given type was either a "plain"    integral type or an explicitly "signed" integral type.  Unfortunately,    we can't always do this, because GCC may already have thrown away the    information about the precise way in which the type was originally    specified, as in:  	typedef signed int my_type;  	struct s { my_type f; };     Since we may be stuck here without enough information to do exactly    what is called for in the Dwarf draft specification, we do the best    that we can under the circumstances and always use the "plain" integral    fundamental type codes for int, short, and long types.  That's probably    good enough.  The additional accuracy called for in the current DWARF    draft specification is probably never even useful in practice.  */
end_comment

begin_function
specifier|static
name|int
name|fundamental_type_code
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|ERROR_MARK
case|:
return|return
name|FT_void
return|;
case|case
name|VOID_TYPE
case|:
return|return
name|FT_void
return|;
case|case
name|INTEGER_TYPE
case|:
comment|/* Carefully distinguish all the standard types of C, 	   without messing up if the language is not C. 	   Note that we check only for the names that contain spaces; 	   other names might occur by coincidence in other languages.  */
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
specifier|const
name|char
modifier|*
specifier|const
name|name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"unsigned char"
argument_list|)
condition|)
return|return
name|FT_unsigned_char
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"signed char"
argument_list|)
condition|)
return|return
name|FT_signed_char
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"unsigned int"
argument_list|)
condition|)
return|return
name|FT_unsigned_integer
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"short int"
argument_list|)
condition|)
return|return
name|FT_short
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"short unsigned int"
argument_list|)
condition|)
return|return
name|FT_unsigned_short
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"long int"
argument_list|)
condition|)
return|return
name|FT_long
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"long unsigned int"
argument_list|)
condition|)
return|return
name|FT_unsigned_long
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"long long int"
argument_list|)
condition|)
return|return
name|FT_long_long
return|;
comment|/* Not grok'ed by svr4 SDB */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"long long unsigned int"
argument_list|)
condition|)
return|return
name|FT_unsigned_long_long
return|;
comment|/* Not grok'ed by svr4 SDB */
block|}
comment|/* Most integer types will be sorted out above, however, for the 	   sake of special `array index' integer types, the following code 	   is also provided.  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|INT_TYPE_SIZE
condition|)
return|return
operator|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|?
name|FT_unsigned_integer
else|:
name|FT_integer
operator|)
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|LONG_TYPE_SIZE
condition|)
return|return
operator|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|?
name|FT_unsigned_long
else|:
name|FT_long
operator|)
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|LONG_LONG_TYPE_SIZE
condition|)
return|return
operator|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|?
name|FT_unsigned_long_long
else|:
name|FT_long_long
operator|)
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|SHORT_TYPE_SIZE
condition|)
return|return
operator|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|?
name|FT_unsigned_short
else|:
name|FT_short
operator|)
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|CHAR_TYPE_SIZE
condition|)
return|return
operator|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|?
name|FT_unsigned_char
else|:
name|FT_char
operator|)
return|;
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|TImode
condition|)
return|return
operator|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|?
name|FT_unsigned_int128
else|:
name|FT_int128
operator|)
return|;
comment|/* In C++, __java_boolean is an INTEGER_TYPE with precision == 1 */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
literal|1
condition|)
return|return
name|FT_boolean
return|;
name|abort
argument_list|()
expr_stmt|;
case|case
name|REAL_TYPE
case|:
comment|/* Carefully distinguish all the standard types of C, 	   without messing up if the language is not C.  */
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
specifier|const
name|char
modifier|*
specifier|const
name|name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Note that here we can run afoul of a serious bug in "classic" 	       svr4 SDB debuggers.  They don't seem to understand the 	       FT_ext_prec_float type (even though they should).  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"long double"
argument_list|)
condition|)
return|return
name|FT_ext_prec_float
return|;
block|}
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|DOUBLE_TYPE_SIZE
condition|)
block|{
comment|/* On the SH, when compiling with -m3e or -m4-single-only, both 	       float and double are 32 bits.  But since the debugger doesn't 	       know about the subtarget, it always thinks double is 64 bits. 	       So we have to tell the debugger that the type is float to 	       make the output of the 'print' command etc. readable.  */
if|if
condition|(
name|DOUBLE_TYPE_SIZE
operator|==
name|FLOAT_TYPE_SIZE
operator|&&
name|FLOAT_TYPE_SIZE
operator|==
literal|32
condition|)
return|return
name|FT_float
return|;
return|return
name|FT_dbl_prec_float
return|;
block|}
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|FLOAT_TYPE_SIZE
condition|)
return|return
name|FT_float
return|;
comment|/* Note that here we can run afoul of a serious bug in "classic" 	   svr4 SDB debuggers.  They don't seem to understand the 	   FT_ext_prec_float type (even though they should).  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|LONG_DOUBLE_TYPE_SIZE
condition|)
return|return
name|FT_ext_prec_float
return|;
name|abort
argument_list|()
expr_stmt|;
case|case
name|COMPLEX_TYPE
case|:
return|return
name|FT_complex
return|;
comment|/* GNU FORTRAN COMPLEX type.  */
case|case
name|CHAR_TYPE
case|:
return|return
name|FT_char
return|;
comment|/* GNU Pascal CHAR type.  Not used in C.  */
case|case
name|BOOLEAN_TYPE
case|:
return|return
name|FT_boolean
return|;
comment|/* GNU FORTRAN BOOLEAN type.  */
default|default:
name|abort
argument_list|()
expr_stmt|;
comment|/* No other TREE_CODEs are Dwarf fundamental types.  */
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a pointer to an arbitrary ..._TYPE tree node, return a pointer to    the Dwarf "root" type for the given input type.  The Dwarf "root" type    of a given type is generally the same as the given type, except that if    the	given type is a pointer or reference type, then the root type of    the given type is the root type of the "basis" type for the pointer or    reference type.  (This definition of the "root" type is recursive.)    Also, the root type of a `const' qualified type or a `volatile'    qualified type is the root type of the given type without the    qualifiers.  */
end_comment

begin_function
specifier|static
name|tree
name|root_type_1
parameter_list|(
name|type
parameter_list|,
name|count
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
comment|/* Give up after searching 1000 levels, in case this is a recursive      pointer type.  Such types are possible in Ada, but it is not possible      to represent them in DWARF1 debug info.  */
if|if
condition|(
name|count
operator|>
literal|1000
condition|)
return|return
name|error_mark_node
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|ERROR_MARK
case|:
return|return
name|error_mark_node
return|;
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
return|return
name|root_type_1
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|count
operator|+
literal|1
argument_list|)
return|;
default|default:
return|return
name|type
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|tree
name|root_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|type
operator|=
name|root_type_1
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|error_mark_node
condition|)
name|type
operator|=
name|type_main_variant
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Given a pointer to an arbitrary ..._TYPE tree node, write out a sequence    of zero or more Dwarf "type-modifier" bytes applicable to the type.	*/
end_comment

begin_function
specifier|static
name|void
name|write_modifier_bytes_1
parameter_list|(
name|type
parameter_list|,
name|decl_const
parameter_list|,
name|decl_volatile
parameter_list|,
name|count
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|decl_const
decl_stmt|;
name|int
name|decl_volatile
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return;
comment|/* Give up after searching 1000 levels, in case this is a recursive      pointer type.  Such types are possible in Ada, but it is not possible      to represent them in DWARF1 debug info.  */
if|if
condition|(
name|count
operator|>
literal|1000
condition|)
return|return;
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|type
argument_list|)
operator|||
name|decl_const
condition|)
name|ASM_OUTPUT_DWARF_TYPE_MODIFIER
argument_list|(
name|asm_out_file
argument_list|,
name|MOD_const
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_VOLATILE
argument_list|(
name|type
argument_list|)
operator|||
name|decl_volatile
condition|)
name|ASM_OUTPUT_DWARF_TYPE_MODIFIER
argument_list|(
name|asm_out_file
argument_list|,
name|MOD_volatile
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|POINTER_TYPE
case|:
name|ASM_OUTPUT_DWARF_TYPE_MODIFIER
argument_list|(
name|asm_out_file
argument_list|,
name|MOD_pointer_to
argument_list|)
expr_stmt|;
name|write_modifier_bytes_1
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|count
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
case|case
name|REFERENCE_TYPE
case|:
name|ASM_OUTPUT_DWARF_TYPE_MODIFIER
argument_list|(
name|asm_out_file
argument_list|,
name|MOD_reference_to
argument_list|)
expr_stmt|;
name|write_modifier_bytes_1
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|count
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
case|case
name|ERROR_MARK
case|:
default|default:
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|write_modifier_bytes
parameter_list|(
name|type
parameter_list|,
name|decl_const
parameter_list|,
name|decl_volatile
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|decl_const
decl_stmt|;
name|int
name|decl_volatile
decl_stmt|;
block|{
name|write_modifier_bytes_1
argument_list|(
name|type
argument_list|,
name|decl_const
argument_list|,
name|decl_volatile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a pointer to an arbitrary ..._TYPE tree node, return nonzero if the    given input type is a Dwarf "fundamental" type.  Otherwise return zero.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|type_is_fundamental
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|ERROR_MARK
case|:
case|case
name|VOID_TYPE
case|:
case|case
name|INTEGER_TYPE
case|:
case|case
name|REAL_TYPE
case|:
case|case
name|COMPLEX_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
case|case
name|CHAR_TYPE
case|:
return|return
literal|1
return|;
case|case
name|SET_TYPE
case|:
case|case
name|ARRAY_TYPE
case|:
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|QUAL_UNION_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|FUNCTION_TYPE
case|:
case|case
name|METHOD_TYPE
case|:
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
case|case
name|FILE_TYPE
case|:
case|case
name|OFFSET_TYPE
case|:
case|case
name|LANG_TYPE
case|:
case|case
name|VECTOR_TYPE
case|:
return|return
literal|0
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Given a pointer to some ..._DECL tree node, generate an assembly language    equate directive which will associate a symbolic name with the current DIE.     The name used is an artificial label generated from the DECL_UID number    associated with the given decl node.  The name it gets equated to is the    symbolic label that we (previously) output at the start of the DIE that    we are currently generating.     Calling this function while generating some "decl related" form of DIE    makes it possible to later refer to the DIE which represents the given    decl simply by re-generating the symbolic name from the ..._DECL node's    UID number.	*/
end_comment

begin_function
specifier|static
name|void
name|equate_decl_number_to_die_number
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
comment|/* In the case where we are generating a DIE for some ..._DECL node      which represents either some inline function declaration or some      entity declared within an inline function declaration/definition,      setup a symbolic name for the current DIE so that we have a name      for this DIE that we can easily refer to later on within      AT_abstract_origin attributes.  */
name|char
name|decl_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|char
name|die_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|decl_label
argument_list|,
name|DECL_NAME_FMT
argument_list|,
name|DECL_UID
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|die_label
argument_list|,
name|DIE_BEGIN_LABEL_FMT
argument_list|,
name|current_dienum
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DEF
argument_list|(
name|asm_out_file
argument_list|,
name|decl_label
argument_list|,
name|die_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a pointer to some ..._TYPE tree node, generate an assembly language    equate directive which will associate a symbolic name with the current DIE.     The name used is an artificial label generated from the TYPE_UID number    associated with the given type node.  The name it gets equated to is the    symbolic label that we (previously) output at the start of the DIE that    we are currently generating.     Calling this function while generating some "type related" form of DIE    makes it easy to later refer to the DIE which represents the given type    simply by re-generating the alternative name from the ..._TYPE node's    UID number.	*/
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|equate_type_number_to_die_number
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|char
name|type_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|char
name|die_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
comment|/* We are generating a DIE to represent the main variant of this type      (i.e the type without any const or volatile qualifiers) so in order      to get the equate to come out right, we need to get the main variant      itself here.  */
name|type
operator|=
name|type_main_variant
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|type_label
argument_list|,
name|TYPE_NAME_FMT
argument_list|,
name|TYPE_UID
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|die_label
argument_list|,
name|DIE_BEGIN_LABEL_FMT
argument_list|,
name|current_dienum
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DEF
argument_list|(
name|asm_out_file
argument_list|,
name|type_label
argument_list|,
name|die_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_reg_number
parameter_list|(
name|rtl
parameter_list|)
name|rtx
name|rtl
decl_stmt|;
block|{
name|unsigned
name|regno
init|=
name|REGNO
argument_list|(
name|rtl
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno
operator|>=
name|DWARF_FRAME_REGISTERS
condition|)
block|{
name|warning_with_decl
argument_list|(
name|dwarf_last_decl
argument_list|,
literal|"internal regno botch: `%s' has regno = %d\n"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|regno
operator|=
literal|0
expr_stmt|;
block|}
name|dw2_assemble_integer
argument_list|(
literal|4
argument_list|,
name|GEN_INT
argument_list|(
name|DBX_REGISTER_NUMBER
argument_list|(
name|regno
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
block|{
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s "
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|PRINT_REG
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The following routine is a nice and simple transducer.  It converts the    RTL for a variable or parameter (resident in memory) into an equivalent    Dwarf representation of a mechanism for getting the address of that same    variable onto the top of a hypothetical "address evaluation" stack.     When creating memory location descriptors, we are effectively trans-    forming the RTL for a memory-resident object into its Dwarf postfix    expression equivalent.  This routine just recursively descends an    RTL tree, turning it into Dwarf postfix code as it goes.  */
end_comment

begin_function
specifier|static
name|void
name|output_mem_loc_descriptor
parameter_list|(
name|rtl
parameter_list|)
name|rtx
name|rtl
decl_stmt|;
block|{
comment|/* Note that for a dynamically sized array, the location we will      generate a description of here will be the lowest numbered location      which is actually within the array.  That's *not* necessarily the      same as the zeroth element of the array.  */
ifdef|#
directive|ifdef
name|ASM_SIMPLIFY_DWARF_ADDR
name|rtl
operator|=
name|ASM_SIMPLIFY_DWARF_ADDR
argument_list|(
name|rtl
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
condition|)
block|{
case|case
name|SUBREG
case|:
comment|/* The case of a subreg may arise when we have a local (register) 	   variable or a formal (register) parameter which doesn't quite 	   fill up an entire register.	For now, just assume that it is 	   legitimate to make the Dwarf info refer to the whole register 	   which contains the given subreg.  */
name|rtl
operator|=
name|SUBREG_REG
argument_list|(
name|rtl
argument_list|)
expr_stmt|;
comment|/* Drop thru.  */
case|case
name|REG
case|:
comment|/* Whenever a register number forms a part of the description of 	   the method for calculating the (dynamic) address of a memory 	   resident object, DWARF rules require the register number to 	   be referred to as a "base register".  This distinction is not 	   based in any way upon what category of register the hardware 	   believes the given register belongs to.  This is strictly 	   DWARF terminology we're dealing with here.  	   Note that in cases where the location of a memory-resident data 	   object could be expressed as:  		    OP_ADD (OP_BASEREG (basereg), OP_CONST (0))  	   the actual DWARF location descriptor that we generate may just 	   be OP_BASEREG (basereg).  This may look deceptively like the 	   object in question was allocated to a register (rather than 	   in memory) so DWARF consumers need to be aware of the subtle 	   distinction between OP_REG and OP_BASEREG.  */
name|ASM_OUTPUT_DWARF_STACK_OP
argument_list|(
name|asm_out_file
argument_list|,
name|OP_BASEREG
argument_list|)
expr_stmt|;
name|output_reg_number
argument_list|(
name|rtl
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEM
case|:
name|output_mem_loc_descriptor
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_STACK_OP
argument_list|(
name|asm_out_file
argument_list|,
name|OP_DEREF4
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST
case|:
case|case
name|SYMBOL_REF
case|:
name|ASM_OUTPUT_DWARF_STACK_OP
argument_list|(
name|asm_out_file
argument_list|,
name|OP_ADDR
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_ADDR_CONST
argument_list|(
name|asm_out_file
argument_list|,
name|rtl
argument_list|)
expr_stmt|;
break|break;
case|case
name|PLUS
case|:
name|output_mem_loc_descriptor
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|output_mem_loc_descriptor
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_STACK_OP
argument_list|(
name|asm_out_file
argument_list|,
name|OP_ADD
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_INT
case|:
name|ASM_OUTPUT_DWARF_STACK_OP
argument_list|(
name|asm_out_file
argument_list|,
name|OP_CONST
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DATA4
argument_list|(
name|asm_out_file
argument_list|,
name|INTVAL
argument_list|(
name|rtl
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MULT
case|:
comment|/* If a pseudo-reg is optimized away, it is possible for it to 	   be replaced with a MEM containing a multiply.  Use a GNU extension 	   to describe it.  */
name|output_mem_loc_descriptor
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|output_mem_loc_descriptor
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_STACK_OP
argument_list|(
name|asm_out_file
argument_list|,
name|OP_MULT
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output a proper Dwarf location descriptor for a variable or parameter    which is either allocated in a register or in a memory location.  For    a register, we just generate an OP_REG and the register number.  For a    memory location we provide a Dwarf postfix expression describing how to    generate the (dynamic) address of the object onto the address stack.  */
end_comment

begin_function
specifier|static
name|void
name|output_loc_descriptor
parameter_list|(
name|rtl
parameter_list|)
name|rtx
name|rtl
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
condition|)
block|{
case|case
name|SUBREG
case|:
comment|/* The case of a subreg may arise when we have a local (register) 	   variable or a formal (register) parameter which doesn't quite 	   fill up an entire register.	For now, just assume that it is 	   legitimate to make the Dwarf info refer to the whole register 	   which contains the given subreg.  */
name|rtl
operator|=
name|SUBREG_REG
argument_list|(
name|rtl
argument_list|)
expr_stmt|;
comment|/* Drop thru.  */
case|case
name|REG
case|:
name|ASM_OUTPUT_DWARF_STACK_OP
argument_list|(
name|asm_out_file
argument_list|,
name|OP_REG
argument_list|)
expr_stmt|;
name|output_reg_number
argument_list|(
name|rtl
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEM
case|:
name|output_mem_loc_descriptor
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
comment|/* Should never happen */
block|}
block|}
end_function

begin_comment
comment|/* Given a tree node describing an array bound (either lower or upper)    output a representation for that bound.  */
end_comment

begin_function
specifier|static
name|void
name|output_bound_representation
parameter_list|(
name|bound
parameter_list|,
name|dim_num
parameter_list|,
name|u_or_l
parameter_list|)
name|tree
name|bound
decl_stmt|;
name|unsigned
name|dim_num
decl_stmt|;
comment|/* For multi-dimensional arrays.  */
name|char
name|u_or_l
decl_stmt|;
comment|/* Designates upper or lower bound.  */
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|bound
argument_list|)
condition|)
block|{
case|case
name|ERROR_MARK
case|:
return|return;
comment|/* All fixed-bounds are represented by INTEGER_CST nodes.	 */
case|case
name|INTEGER_CST
case|:
if|if
condition|(
name|host_integerp
argument_list|(
name|bound
argument_list|,
literal|0
argument_list|)
condition|)
name|ASM_OUTPUT_DWARF_DATA4
argument_list|(
name|asm_out_file
argument_list|,
name|tree_low_cst
argument_list|(
name|bound
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Dynamic bounds may be represented by NOP_EXPR nodes containing 	 SAVE_EXPR nodes, in which case we can do something, or as 	 an expression, which we cannot represent.  */
block|{
name|char
name|begin_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|char
name|end_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|begin_label
argument_list|,
name|BOUND_BEGIN_LABEL_FMT
argument_list|,
name|current_dienum
argument_list|,
name|dim_num
argument_list|,
name|u_or_l
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|end_label
argument_list|,
name|BOUND_END_LABEL_FMT
argument_list|,
name|current_dienum
argument_list|,
name|dim_num
argument_list|,
name|u_or_l
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DELTA2
argument_list|(
name|asm_out_file
argument_list|,
name|end_label
argument_list|,
name|begin_label
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|begin_label
argument_list|)
expr_stmt|;
comment|/* If optimization is turned on, the SAVE_EXPRs that describe 	   how to access the upper bound values are essentially bogus. 	   They only describe (at best) how to get at these values at 	   the points in the generated code right after they have just 	   been computed.  Worse yet, in the typical case, the upper 	   bound values will not even *be* computed in the optimized 	   code, so these SAVE_EXPRs are entirely bogus.  	   In order to compensate for this fact, we check here to see 	   if optimization is enabled, and if so, we effectively create 	   an empty location description for the (unknown and unknowable) 	   upper bound.  	   This should not cause too much trouble for existing (stupid?) 	   debuggers because they have to deal with empty upper bounds 	   location descriptions anyway in order to be able to deal with 	   incomplete array types.  	   Of course an intelligent debugger (GDB?) should be able to 	   comprehend that a missing upper bound specification in a 	   array type used for a storage class `auto' local array variable 	   indicates that the upper bound is both unknown (at compile- 	   time) and unknowable (at run-time) due to optimization.  */
if|if
condition|(
operator|!
name|optimize
condition|)
block|{
while|while
condition|(
name|TREE_CODE
argument_list|(
name|bound
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|bound
argument_list|)
operator|==
name|CONVERT_EXPR
condition|)
name|bound
operator|=
name|TREE_OPERAND
argument_list|(
name|bound
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|bound
argument_list|)
operator|==
name|SAVE_EXPR
operator|&&
name|SAVE_EXPR_RTL
argument_list|(
name|bound
argument_list|)
condition|)
name|output_loc_descriptor
argument_list|(
name|eliminate_regs
argument_list|(
name|SAVE_EXPR_RTL
argument_list|(
name|bound
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|end_label
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Recursive function to output a sequence of value/name pairs for    enumeration constants in reversed order.  This is called from    enumeration_type_die.  */
end_comment

begin_function
specifier|static
name|void
name|output_enumeral_list
parameter_list|(
name|link
parameter_list|)
name|tree
name|link
decl_stmt|;
block|{
if|if
condition|(
name|link
condition|)
block|{
name|output_enumeral_list
argument_list|(
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|host_integerp
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
name|ASM_OUTPUT_DWARF_DATA4
argument_list|(
name|asm_out_file
argument_list|,
name|tree_low_cst
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_STRING_NEWLINE
argument_list|(
name|asm_out_file
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Given an unsigned value, round it up to the lowest multiple of `boundary'    which is not less than the value itself.  */
end_comment

begin_function
specifier|static
specifier|inline
name|HOST_WIDE_INT
name|ceiling
parameter_list|(
name|value
parameter_list|,
name|boundary
parameter_list|)
name|HOST_WIDE_INT
name|value
decl_stmt|;
name|unsigned
name|int
name|boundary
decl_stmt|;
block|{
return|return
operator|(
operator|(
operator|(
name|value
operator|+
name|boundary
operator|-
literal|1
operator|)
operator|/
name|boundary
operator|)
operator|*
name|boundary
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Given a pointer to what is assumed to be a FIELD_DECL node, return a    pointer to the declared type for the relevant field variable, or return    `integer_type_node' if the given node turns out to be an ERROR_MARK node.  */
end_comment

begin_function
specifier|static
specifier|inline
name|tree
name|field_type
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|integer_type_node
return|;
name|type
operator|=
name|DECL_BIT_FIELD_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Given a pointer to a tree node, assumed to be some kind of a ..._TYPE    node, return the alignment in bits for the type, or else return    BITS_PER_WORD if the node actually turns out to be an ERROR_MARK node.  */
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|int
name|simple_type_align_in_bits
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
return|return
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|ERROR_MARK
operator|)
condition|?
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
else|:
name|BITS_PER_WORD
return|;
block|}
end_function

begin_comment
comment|/* Given a pointer to a tree node, assumed to be some kind of a ..._TYPE    node, return the size in bits for the type if it is a constant, or    else return the alignment for the type if the type's size is not    constant, or else return BITS_PER_WORD if the type actually turns out    to be an ERROR_MARK node.  */
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|HOST_WIDE_INT
name|simple_type_size_in_bits
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|type_size_tree
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|BITS_PER_WORD
return|;
name|type_size_tree
operator|=
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type_size_tree
operator|==
name|NULL_TREE
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|type_size_tree
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
return|;
return|return
name|tree_low_cst
argument_list|(
name|type_size_tree
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given a pointer to what is assumed to be a FIELD_DECL node, compute and    return the byte offset of the lowest addressed byte of the "containing    object" for the given FIELD_DECL, or return 0 if we are unable to deter-    mine what that offset is, either because the argument turns out to be a    pointer to an ERROR_MARK node, or because the offset is actually variable.    (We can't handle the latter case just yet.)  */
end_comment

begin_function
specifier|static
name|HOST_WIDE_INT
name|field_byte_offset
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|unsigned
name|int
name|type_align_in_bytes
decl_stmt|;
name|unsigned
name|int
name|type_align_in_bits
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|type_size_in_bits
decl_stmt|;
name|HOST_WIDE_INT
name|object_offset_in_align_units
decl_stmt|;
name|HOST_WIDE_INT
name|object_offset_in_bits
decl_stmt|;
name|HOST_WIDE_INT
name|object_offset_in_bytes
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|tree
name|field_size_tree
decl_stmt|;
name|HOST_WIDE_INT
name|bitpos_int
decl_stmt|;
name|HOST_WIDE_INT
name|deepest_bitpos
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|field_size_in_bits
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|type
operator|=
name|field_type
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|field_size_tree
operator|=
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* The size could be unspecified if there was an error, or for      a flexible array member.  */
if|if
condition|(
operator|!
name|field_size_tree
condition|)
name|field_size_tree
operator|=
name|bitsize_zero_node
expr_stmt|;
comment|/* We cannot yet cope with fields whose positions or sizes are variable,      so for now, when we see such things, we simply return 0.  Someday,      we may be able to handle such cases, but it will be damn difficult.  */
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|bit_position
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|host_integerp
argument_list|(
name|field_size_tree
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|0
return|;
name|bitpos_int
operator|=
name|int_bit_position
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|field_size_in_bits
operator|=
name|tree_low_cst
argument_list|(
name|field_size_tree
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|type_size_in_bits
operator|=
name|simple_type_size_in_bits
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|type_align_in_bits
operator|=
name|simple_type_align_in_bits
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|type_align_in_bytes
operator|=
name|type_align_in_bits
operator|/
name|BITS_PER_UNIT
expr_stmt|;
comment|/* Note that the GCC front-end doesn't make any attempt to keep track      of the starting bit offset (relative to the start of the containing      structure type) of the hypothetical "containing object" for a bit-      field.  Thus, when computing the byte offset value for the start of      the "containing object" of a bit-field, we must deduce this infor-      mation on our own.       This can be rather tricky to do in some cases.  For example, handling      the following structure type definition when compiling for an i386/i486      target (which only aligns long long's to 32-bit boundaries) can be very      tricky:  		struct S { 			int		field1; 			long long	field2:31; 		};       Fortunately, there is a simple rule-of-thumb which can be used in such      cases.  When compiling for an i386/i486, GCC will allocate 8 bytes for      the structure shown above.  It decides to do this based upon one simple      rule for bit-field allocation.  Quite simply, GCC allocates each "con-      taining object" for each bit-field at the first (i.e. lowest addressed)      legitimate alignment boundary (based upon the required minimum alignment      for the declared type of the field) which it can possibly use, subject      to the condition that there is still enough available space remaining      in the containing object (when allocated at the selected point) to      fully accommodate all of the bits of the bit-field itself.       This simple rule makes it obvious why GCC allocates 8 bytes for each      object of the structure type shown above.  When looking for a place to      allocate the "containing object" for `field2', the compiler simply tries      to allocate a 64-bit "containing object" at each successive 32-bit      boundary (starting at zero) until it finds a place to allocate that 64-      bit field such that at least 31 contiguous (and previously unallocated)      bits remain within that selected 64 bit field.  (As it turns out, for      the example above, the compiler finds that it is OK to allocate the      "containing object" 64-bit field at bit-offset zero within the      structure type.)       Here we attempt to work backwards from the limited set of facts we're      given, and we try to deduce from those facts, where GCC must have      believed that the containing object started (within the structure type).       The value we deduce is then used (by the callers of this routine) to      generate AT_location and AT_bit_offset attributes for fields (both      bit-fields and, in the case of AT_location, regular fields as well).  */
comment|/* Figure out the bit-distance from the start of the structure to the      "deepest" bit of the bit-field.  */
name|deepest_bitpos
operator|=
name|bitpos_int
operator|+
name|field_size_in_bits
expr_stmt|;
comment|/* This is the tricky part.  Use some fancy footwork to deduce where the      lowest addressed bit of the containing object must be.  */
name|object_offset_in_bits
operator|=
name|ceiling
argument_list|(
name|deepest_bitpos
argument_list|,
name|type_align_in_bits
argument_list|)
operator|-
name|type_size_in_bits
expr_stmt|;
comment|/* Compute the offset of the containing object in "alignment units".  */
name|object_offset_in_align_units
operator|=
name|object_offset_in_bits
operator|/
name|type_align_in_bits
expr_stmt|;
comment|/* Compute the offset of the containing object in bytes.  */
name|object_offset_in_bytes
operator|=
name|object_offset_in_align_units
operator|*
name|type_align_in_bytes
expr_stmt|;
comment|/* The above code assumes that the field does not cross an alignment      boundary.  This can happen if PCC_BITFIELD_TYPE_MATTERS is not defined,      or if the structure is packed.  If this happens, then we get an object      which starts after the bitfield, which means that the bit offset is      negative.  Gdb fails when given negative bit offsets.  We avoid this      by recomputing using the first bit of the bitfield.  This will give      us an object which does not completely contain the bitfield, but it      will be aligned, and it will contain the first bit of the bitfield.       However, only do this for a BYTES_BIG_ENDIAN target.  For a      ! BYTES_BIG_ENDIAN target, bitpos_int + field_size_in_bits is the first      first bit of the bitfield.  If we recompute using bitpos_int + 1 below,      then we end up computing the object byte offset for the wrong word of the      desired bitfield, which in turn causes the field offset to be negative      in bit_offset_attribute.  */
if|if
condition|(
name|BYTES_BIG_ENDIAN
operator|&&
name|object_offset_in_bits
operator|>
name|bitpos_int
condition|)
block|{
name|deepest_bitpos
operator|=
name|bitpos_int
operator|+
literal|1
expr_stmt|;
name|object_offset_in_bits
operator|=
name|ceiling
argument_list|(
name|deepest_bitpos
argument_list|,
name|type_align_in_bits
argument_list|)
operator|-
name|type_size_in_bits
expr_stmt|;
name|object_offset_in_align_units
operator|=
operator|(
name|object_offset_in_bits
operator|/
name|type_align_in_bits
operator|)
expr_stmt|;
name|object_offset_in_bytes
operator|=
operator|(
name|object_offset_in_align_units
operator|*
name|type_align_in_bytes
operator|)
expr_stmt|;
block|}
return|return
name|object_offset_in_bytes
return|;
block|}
end_function

begin_comment
comment|/****************************** attributes *********************************/
end_comment

begin_comment
comment|/* The following routines are responsible for writing out the various types    of Dwarf attributes (and any following data bytes associated with them).    These routines are listed in order based on the numerical codes of their    associated attributes.  */
end_comment

begin_comment
comment|/* Generate an AT_sibling attribute.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|sibling_attribute
parameter_list|()
block|{
name|char
name|label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|ASM_OUTPUT_DWARF_ATTRIBUTE
argument_list|(
name|asm_out_file
argument_list|,
name|AT_sibling
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|label
argument_list|,
name|DIE_BEGIN_LABEL_FMT
argument_list|,
name|NEXT_DIE_NUM
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_REF
argument_list|(
name|asm_out_file
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output the form of location attributes suitable for whole variables and    whole parameters.  Note that the location attributes for struct fields    are generated by the routine `data_member_location_attribute' below.  */
end_comment

begin_function
specifier|static
name|void
name|location_attribute
parameter_list|(
name|rtl
parameter_list|)
name|rtx
name|rtl
decl_stmt|;
block|{
name|char
name|begin_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|char
name|end_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|ASM_OUTPUT_DWARF_ATTRIBUTE
argument_list|(
name|asm_out_file
argument_list|,
name|AT_location
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|begin_label
argument_list|,
name|LOC_BEGIN_LABEL_FMT
argument_list|,
name|current_dienum
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|end_label
argument_list|,
name|LOC_END_LABEL_FMT
argument_list|,
name|current_dienum
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DELTA2
argument_list|(
name|asm_out_file
argument_list|,
name|end_label
argument_list|,
name|begin_label
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|begin_label
argument_list|)
expr_stmt|;
comment|/* Handle a special case.  If we are about to output a location descriptor      for a variable or parameter which has been optimized out of existence,      don't do that.  Instead we output a zero-length location descriptor      value as part of the location attribute.       A variable which has been optimized out of existence will have a      DECL_RTL value which denotes a pseudo-reg.       Currently, in some rare cases, variables can have DECL_RTL values      which look like (MEM (REG pseudo-reg#)).  These cases are due to      bugs elsewhere in the compiler.  We treat such cases      as if the variable(s) in question had been optimized out of existence.       Note that in all cases where we wish to express the fact that a      variable has been optimized out of existence, we do not simply      suppress the generation of the entire location attribute because      the absence of a location attribute in certain kinds of DIEs is      used to indicate something else entirely... i.e. that the DIE      represents an object declaration, but not a definition.  So saith      the PLSIG.   */
if|if
condition|(
operator|!
name|is_pseudo_reg
argument_list|(
name|rtl
argument_list|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
operator|!=
name|MEM
operator|||
operator|!
name|is_pseudo_reg
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
name|output_loc_descriptor
argument_list|(
name|rtl
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|end_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output the specialized form of location attribute used for data members    of struct and union types.     In the special case of a FIELD_DECL node which represents a bit-field,    the "offset" part of this special location descriptor must indicate the    distance in bytes from the lowest-addressed byte of the containing    struct or union type to the lowest-addressed byte of the "containing    object" for the bit-field.  (See the `field_byte_offset' function above.)     For any given bit-field, the "containing object" is a hypothetical    object (of some integral or enum type) within which the given bit-field    lives.  The type of this hypothetical "containing object" is always the    same as the declared type of the individual bit-field itself (for GCC    anyway... the DWARF spec doesn't actually mandate this).     Note that it is the size (in bytes) of the hypothetical "containing    object" which will be given in the AT_byte_size attribute for this    bit-field.  (See the `byte_size_attribute' function below.)  It is    also used when calculating the value of the AT_bit_offset attribute.    (See the `bit_offset_attribute' function below.)  */
end_comment

begin_function
specifier|static
name|void
name|data_member_location_attribute
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|unsigned
name|object_offset_in_bytes
decl_stmt|;
name|char
name|begin_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|char
name|end_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TREE_VEC
condition|)
name|object_offset_in_bytes
operator|=
name|tree_low_cst
argument_list|(
name|BINFO_OFFSET
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|object_offset_in_bytes
operator|=
name|field_byte_offset
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_ATTRIBUTE
argument_list|(
name|asm_out_file
argument_list|,
name|AT_location
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|begin_label
argument_list|,
name|LOC_BEGIN_LABEL_FMT
argument_list|,
name|current_dienum
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|end_label
argument_list|,
name|LOC_END_LABEL_FMT
argument_list|,
name|current_dienum
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DELTA2
argument_list|(
name|asm_out_file
argument_list|,
name|end_label
argument_list|,
name|begin_label
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|begin_label
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_STACK_OP
argument_list|(
name|asm_out_file
argument_list|,
name|OP_CONST
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DATA4
argument_list|(
name|asm_out_file
argument_list|,
name|object_offset_in_bytes
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_STACK_OP
argument_list|(
name|asm_out_file
argument_list|,
name|OP_ADD
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|end_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output an AT_const_value attribute for a variable or a parameter which    does not have a "location" either in memory or in a register.  These    things can arise in GNU C when a constant is passed as an actual    parameter to an inlined function.  They can also arise in C++ where    declared constants do not necessarily get memory "homes".  */
end_comment

begin_function
specifier|static
name|void
name|const_value_attribute
parameter_list|(
name|rtl
parameter_list|)
name|rtx
name|rtl
decl_stmt|;
block|{
name|char
name|begin_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|char
name|end_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|ASM_OUTPUT_DWARF_ATTRIBUTE
argument_list|(
name|asm_out_file
argument_list|,
name|AT_const_value_block4
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|begin_label
argument_list|,
name|LOC_BEGIN_LABEL_FMT
argument_list|,
name|current_dienum
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|end_label
argument_list|,
name|LOC_END_LABEL_FMT
argument_list|,
name|current_dienum
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DELTA4
argument_list|(
name|asm_out_file
argument_list|,
name|end_label
argument_list|,
name|begin_label
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|begin_label
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
condition|)
block|{
case|case
name|CONST_INT
case|:
comment|/* Note that a CONST_INT rtx could represent either an integer or 	   a floating-point constant.  A CONST_INT is used whenever the 	   constant will fit into a single word.  In all such cases, the 	   original mode of the constant value is wiped out, and the 	   CONST_INT rtx is assigned VOIDmode.  Since we no longer have 	   precise mode information for these constants, we always just 	   output them using 4 bytes.  */
name|ASM_OUTPUT_DWARF_DATA4
argument_list|(
name|asm_out_file
argument_list|,
operator|(
name|unsigned
operator|)
name|INTVAL
argument_list|(
name|rtl
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_DOUBLE
case|:
comment|/* Note that a CONST_DOUBLE rtx could represent either an integer 	   or a floating-point constant.  A CONST_DOUBLE is used whenever 	   the constant requires more than one word in order to be adequately 	   represented.  In all such cases, the original mode of the constant 	   value is preserved as the mode of the CONST_DOUBLE rtx, but for 	   simplicity we always just output CONST_DOUBLEs using 8 bytes.  */
name|ASM_OUTPUT_DWARF_DATA8
argument_list|(
name|asm_out_file
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|CONST_DOUBLE_HIGH
argument_list|(
name|rtl
argument_list|)
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|CONST_DOUBLE_LOW
argument_list|(
name|rtl
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_STRING
case|:
name|ASM_OUTPUT_DWARF_STRING_NEWLINE
argument_list|(
name|asm_out_file
argument_list|,
name|XSTR
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|CONST
case|:
name|ASM_OUTPUT_DWARF_ADDR_CONST
argument_list|(
name|asm_out_file
argument_list|,
name|rtl
argument_list|)
expr_stmt|;
break|break;
case|case
name|PLUS
case|:
comment|/* In cases where an inlined instance of an inline function is passed 	   the address of an `auto' variable (which is local to the caller) 	   we can get a situation where the DECL_RTL of the artificial 	   local variable (for the inlining) which acts as a stand-in for 	   the corresponding formal parameter (of the inline function) 	   will look like (plus:SI (reg:SI FRAME_PTR) (const_int ...)). 	   This is not exactly a compile-time constant expression, but it 	   isn't the address of the (artificial) local variable either. 	   Rather, it represents the *value* which the artificial local 	   variable always has during its lifetime.  We currently have no 	   way to represent such quasi-constant values in Dwarf, so for now 	   we just punt and generate an AT_const_value attribute with form 	   FORM_BLOCK4 and a length of zero.  */
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
comment|/* No other kinds of rtx should be possible here.  */
block|}
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|end_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate *either* an AT_location attribute or else an AT_const_value    data attribute for a variable or a parameter.  We generate the    AT_const_value attribute only in those cases where the given    variable or parameter does not have a true "location" either in    memory or in a register.  This can happen (for example) when a    constant is passed as an actual argument in a call to an inline    function.  (It's possible that these things can crop up in other    ways also.)  Note that one type of constant value which can be    passed into an inlined function is a constant pointer.  This can    happen for example if an actual argument in an inlined function    call evaluates to a compile-time constant address.  */
end_comment

begin_function
specifier|static
name|void
name|location_or_const_value_attribute
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|rtx
name|rtl
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|VAR_DECL
operator|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|PARM_DECL
operator|)
condition|)
block|{
comment|/* Should never happen.  */
name|abort
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Here we have to decide where we are going to say the parameter "lives"      (as far as the debugger is concerned).  We only have a couple of choices.      GCC provides us with DECL_RTL and with DECL_INCOMING_RTL.  DECL_RTL      normally indicates where the parameter lives during most of the activa-      tion of the function.  If optimization is enabled however, this could      be either NULL or else a pseudo-reg.  Both of those cases indicate that      the parameter doesn't really live anywhere (as far as the code generation      parts of GCC are concerned) during most of the function's activation.      That will happen (for example) if the parameter is never referenced      within the function.       We could just generate a location descriptor here for all non-NULL      non-pseudo values of DECL_RTL and ignore all of the rest, but we can      be a little nicer than that if we also consider DECL_INCOMING_RTL in      cases where DECL_RTL is NULL or is a pseudo-reg.       Note however that we can only get away with using DECL_INCOMING_RTL as      a backup substitute for DECL_RTL in certain limited cases.  In cases      where DECL_ARG_TYPE(decl) indicates the same type as TREE_TYPE(decl)      we can be sure that the parameter was passed using the same type as it      is declared to have within the function, and that its DECL_INCOMING_RTL      points us to a place where a value of that type is passed.  In cases      where DECL_ARG_TYPE(decl) and TREE_TYPE(decl) are different types      however, we cannot (in general) use DECL_INCOMING_RTL as a backup      substitute for DECL_RTL because in these cases, DECL_INCOMING_RTL      points us to a value of some type which is *different* from the type      of the parameter itself.  Thus, if we tried to use DECL_INCOMING_RTL      to generate a location attribute in such cases, the debugger would      end up (for example) trying to fetch a `float' from a place which      actually contains the first part of a `double'.  That would lead to      really incorrect and confusing output at debug-time, and we don't      want that now do we?       So in general, we DO NOT use DECL_INCOMING_RTL as a backup for DECL_RTL      in cases where DECL_ARG_TYPE(decl) != TREE_TYPE(decl).  There are a      couple of cute exceptions however.  On little-endian machines we can      get away with using DECL_INCOMING_RTL even when DECL_ARG_TYPE(decl) is      not the same as TREE_TYPE(decl) but only when DECL_ARG_TYPE(decl) is      an integral type which is smaller than TREE_TYPE(decl).  These cases      arise when (on a little-endian machine) a non-prototyped function has      a parameter declared to be of type `short' or `char'.  In such cases,      TREE_TYPE(decl) will be `short' or `char', DECL_ARG_TYPE(decl) will be      `int', and DECL_INCOMING_RTL will point to the lowest-order byte of the      passed `int' value.  If the debugger then uses that address to fetch a      `short' or a `char' (on a little-endian machine) the result will be the      correct data, so we allow for such exceptional cases below.       Note that our goal here is to describe the place where the given formal      parameter lives during most of the function's activation (i.e. between      the end of the prologue and the start of the epilogue).  We'll do that      as best as we can.  Note however that if the given formal parameter is      modified sometime during the execution of the function, then a stack      backtrace (at debug-time) will show the function as having been called      with the *new* value rather than the value which was originally passed      in.  This happens rarely enough that it is not a major problem, but it      *is* a problem, and I'd like to fix it.  A future version of dwarfout.c      may generate two additional attributes for any given TAG_formal_parameter      DIE which will describe the "passed type" and the "passed location" for      the given formal parameter in addition to the attributes we now generate      to indicate the "declared type" and the "active location" for each      parameter.  This additional set of attributes could be used by debuggers      for stack backtraces.       Separately, note that sometimes DECL_RTL can be NULL and DECL_INCOMING_RTL      can be NULL also.  This happens (for example) for inlined-instances of      inline function formal parameters which are never referenced.  This really      shouldn't be happening.  All PARM_DECL nodes should get valid non-NULL      DECL_INCOMING_RTL values, but integrate.c doesn't currently generate      these values for inlined instances of inline function parameters, so      when we see such cases, we are just out-of-luck for the time      being (until integrate.c gets fixed).   */
comment|/* Use DECL_RTL as the "location" unless we find something better.  */
name|rtl
operator|=
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
condition|)
if|if
condition|(
name|rtl
operator|==
name|NULL_RTX
operator|||
name|is_pseudo_reg
argument_list|(
name|rtl
argument_list|)
condition|)
block|{
comment|/* This decl represents a formal parameter which was optimized out.  */
name|tree
name|declared_type
init|=
name|type_main_variant
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|passed_type
init|=
name|type_main_variant
argument_list|(
name|DECL_ARG_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Note that DECL_INCOMING_RTL may be NULL in here, but we handle 	   *all* cases where (rtl == NULL_RTX) just below.  */
if|if
condition|(
name|declared_type
operator|==
name|passed_type
condition|)
name|rtl
operator|=
name|DECL_INCOMING_RTL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|BYTES_BIG_ENDIAN
condition|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|declared_type
argument_list|)
operator|==
name|INTEGER_TYPE
condition|)
comment|/* NMS WTF? */
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|declared_type
argument_list|)
operator|<=
name|TYPE_SIZE
argument_list|(
name|passed_type
argument_list|)
condition|)
name|rtl
operator|=
name|DECL_INCOMING_RTL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rtl
operator|==
name|NULL_RTX
condition|)
return|return;
name|rtl
operator|=
name|eliminate_regs
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LEAF_REG_REMAP
if|if
condition|(
name|current_function_uses_only_leaf_regs
condition|)
name|leaf_renumber_regs_insn
argument_list|(
name|rtl
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
condition|)
block|{
case|case
name|ADDRESSOF
case|:
comment|/* The address of a variable that was optimized away; don't emit 	 anything.  */
break|break;
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_STRING
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|CONST
case|:
case|case
name|PLUS
case|:
comment|/* DECL_RTL could be (plus (reg ...) (const_int ...)) */
name|const_value_attribute
argument_list|(
name|rtl
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEM
case|:
case|case
name|REG
case|:
case|case
name|SUBREG
case|:
name|location_attribute
argument_list|(
name|rtl
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONCAT
case|:
comment|/* ??? CONCAT is used for complex variables, which may have the real 	 part stored in one place and the imag part stored somewhere else. 	 DWARF1 has no way to describe a variable that lives in two different 	 places, so we just describe where the first part lives, and hope that 	 the second part is stored after it.  */
name|location_attribute
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
comment|/* Should never happen.  */
block|}
block|}
end_function

begin_comment
comment|/* Generate an AT_name attribute given some string value to be included as    the value of the attribute.	*/
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|name_attribute
parameter_list|(
name|name_string
parameter_list|)
specifier|const
name|char
modifier|*
name|name_string
decl_stmt|;
block|{
if|if
condition|(
name|name_string
operator|&&
operator|*
name|name_string
condition|)
block|{
name|ASM_OUTPUT_DWARF_ATTRIBUTE
argument_list|(
name|asm_out_file
argument_list|,
name|AT_name
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_STRING_NEWLINE
argument_list|(
name|asm_out_file
argument_list|,
name|name_string
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|fund_type_attribute
parameter_list|(
name|ft_code
parameter_list|)
name|unsigned
name|ft_code
decl_stmt|;
block|{
name|ASM_OUTPUT_DWARF_ATTRIBUTE
argument_list|(
name|asm_out_file
argument_list|,
name|AT_fund_type
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_FUND_TYPE
argument_list|(
name|asm_out_file
argument_list|,
name|ft_code
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mod_fund_type_attribute
parameter_list|(
name|type
parameter_list|,
name|decl_const
parameter_list|,
name|decl_volatile
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|decl_const
decl_stmt|;
name|int
name|decl_volatile
decl_stmt|;
block|{
name|char
name|begin_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|char
name|end_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|ASM_OUTPUT_DWARF_ATTRIBUTE
argument_list|(
name|asm_out_file
argument_list|,
name|AT_mod_fund_type
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|begin_label
argument_list|,
name|MT_BEGIN_LABEL_FMT
argument_list|,
name|current_dienum
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|end_label
argument_list|,
name|MT_END_LABEL_FMT
argument_list|,
name|current_dienum
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DELTA2
argument_list|(
name|asm_out_file
argument_list|,
name|end_label
argument_list|,
name|begin_label
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|begin_label
argument_list|)
expr_stmt|;
name|write_modifier_bytes
argument_list|(
name|type
argument_list|,
name|decl_const
argument_list|,
name|decl_volatile
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_FUND_TYPE
argument_list|(
name|asm_out_file
argument_list|,
name|fundamental_type_code
argument_list|(
name|root_type
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|end_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|user_def_type_attribute
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|char
name|ud_type_name
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|ASM_OUTPUT_DWARF_ATTRIBUTE
argument_list|(
name|asm_out_file
argument_list|,
name|AT_user_def_type
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ud_type_name
argument_list|,
name|TYPE_NAME_FMT
argument_list|,
name|TYPE_UID
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_REF
argument_list|(
name|asm_out_file
argument_list|,
name|ud_type_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mod_u_d_type_attribute
parameter_list|(
name|type
parameter_list|,
name|decl_const
parameter_list|,
name|decl_volatile
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|decl_const
decl_stmt|;
name|int
name|decl_volatile
decl_stmt|;
block|{
name|char
name|begin_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|char
name|end_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|char
name|ud_type_name
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|ASM_OUTPUT_DWARF_ATTRIBUTE
argument_list|(
name|asm_out_file
argument_list|,
name|AT_mod_u_d_type
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|begin_label
argument_list|,
name|MT_BEGIN_LABEL_FMT
argument_list|,
name|current_dienum
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|end_label
argument_list|,
name|MT_END_LABEL_FMT
argument_list|,
name|current_dienum
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DELTA2
argument_list|(
name|asm_out_file
argument_list|,
name|end_label
argument_list|,
name|begin_label
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|begin_label
argument_list|)
expr_stmt|;
name|write_modifier_bytes
argument_list|(
name|type
argument_list|,
name|decl_const
argument_list|,
name|decl_volatile
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ud_type_name
argument_list|,
name|TYPE_NAME_FMT
argument_list|,
name|TYPE_UID
argument_list|(
name|root_type
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_REF
argument_list|(
name|asm_out_file
argument_list|,
name|ud_type_name
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|end_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USE_ORDERING_ATTRIBUTE
end_ifdef

begin_function
specifier|static
specifier|inline
name|void
name|ordering_attribute
parameter_list|(
name|ordering
parameter_list|)
name|unsigned
name|ordering
decl_stmt|;
block|{
name|ASM_OUTPUT_DWARF_ATTRIBUTE
argument_list|(
name|asm_out_file
argument_list|,
name|AT_ordering
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DATA2
argument_list|(
name|asm_out_file
argument_list|,
name|ordering
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(USE_ORDERING_ATTRIBUTE) */
end_comment

begin_comment
comment|/* Note that the block of subscript information for an array type also    includes information about the element type of type given array type.  */
end_comment

begin_function
specifier|static
name|void
name|subscript_data_attribute
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|unsigned
name|dimension_number
decl_stmt|;
name|char
name|begin_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|char
name|end_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|ASM_OUTPUT_DWARF_ATTRIBUTE
argument_list|(
name|asm_out_file
argument_list|,
name|AT_subscr_data
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|begin_label
argument_list|,
name|SS_BEGIN_LABEL_FMT
argument_list|,
name|current_dienum
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|end_label
argument_list|,
name|SS_END_LABEL_FMT
argument_list|,
name|current_dienum
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DELTA2
argument_list|(
name|asm_out_file
argument_list|,
name|end_label
argument_list|,
name|begin_label
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|begin_label
argument_list|)
expr_stmt|;
comment|/* The GNU compilers represent multidimensional array types as sequences      of one dimensional array types whose element types are themselves array      types.  Here we squish that down, so that each multidimensional array      type gets only one array_type DIE in the Dwarf debugging info.  The      draft Dwarf specification say that we are allowed to do this kind      of compression in C (because there is no difference between an      array or arrays and a multidimensional array in C) but for other      source languages (e.g. Ada) we probably shouldn't do this.  */
for|for
control|(
name|dimension_number
operator|=
literal|0
init|;
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
operator|,
name|dimension_number
operator|++
control|)
block|{
name|tree
name|domain
init|=
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* Arrays come in three flavors.	Unspecified bounds, fixed 	 bounds, and (in GNU C only) variable bounds.  Handle all 	 three forms here.  */
if|if
condition|(
name|domain
condition|)
block|{
comment|/* We have an array type with specified bounds.  */
name|tree
name|lower
init|=
name|TYPE_MIN_VALUE
argument_list|(
name|domain
argument_list|)
decl_stmt|;
name|tree
name|upper
init|=
name|TYPE_MAX_VALUE
argument_list|(
name|domain
argument_list|)
decl_stmt|;
comment|/* Handle only fundamental types as index types for now.  */
if|if
condition|(
operator|!
name|type_is_fundamental
argument_list|(
name|domain
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Output the representation format byte for this dimension.  */
name|ASM_OUTPUT_DWARF_FMT_BYTE
argument_list|(
name|asm_out_file
argument_list|,
name|FMT_CODE
argument_list|(
literal|1
argument_list|,
name|TREE_CODE
argument_list|(
name|lower
argument_list|)
operator|==
name|INTEGER_CST
argument_list|,
name|upper
operator|&&
name|TREE_CODE
argument_list|(
name|upper
argument_list|)
operator|==
name|INTEGER_CST
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Output the index type for this dimension.	*/
name|ASM_OUTPUT_DWARF_FUND_TYPE
argument_list|(
name|asm_out_file
argument_list|,
name|fundamental_type_code
argument_list|(
name|domain
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Output the representation for the lower bound.  */
name|output_bound_representation
argument_list|(
name|lower
argument_list|,
name|dimension_number
argument_list|,
literal|'l'
argument_list|)
expr_stmt|;
comment|/* Output the representation for the upper bound.  */
if|if
condition|(
name|upper
condition|)
name|output_bound_representation
argument_list|(
name|upper
argument_list|,
name|dimension_number
argument_list|,
literal|'u'
argument_list|)
expr_stmt|;
else|else
name|ASM_OUTPUT_DWARF_DATA2
argument_list|(
name|asm_out_file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We have an array type with an unspecified length.	For C and 	     C++ we can assume that this really means that (a) the index 	     type is an integral type, and (b) the lower bound is zero. 	     Note that Dwarf defines the representation of an unspecified 	     (upper) bound as being a zero-length location description.	 */
comment|/* Output the array-bounds format byte.  */
name|ASM_OUTPUT_DWARF_FMT_BYTE
argument_list|(
name|asm_out_file
argument_list|,
name|FMT_FT_C_X
argument_list|)
expr_stmt|;
comment|/* Output the (assumed) index type.  */
name|ASM_OUTPUT_DWARF_FUND_TYPE
argument_list|(
name|asm_out_file
argument_list|,
name|FT_integer
argument_list|)
expr_stmt|;
comment|/* Output the (assumed) lower bound (constant) value.	 */
name|ASM_OUTPUT_DWARF_DATA4
argument_list|(
name|asm_out_file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Output the (empty) location description for the upper bound.  */
name|ASM_OUTPUT_DWARF_DATA2
argument_list|(
name|asm_out_file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Output the prefix byte that says that the element type is coming up.  */
name|ASM_OUTPUT_DWARF_FMT_BYTE
argument_list|(
name|asm_out_file
argument_list|,
name|FMT_ET
argument_list|)
expr_stmt|;
comment|/* Output a representation of the type of the elements of this array type.  */
name|type_attribute
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|end_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|byte_size_attribute
parameter_list|(
name|tree_node
parameter_list|)
name|tree
name|tree_node
decl_stmt|;
block|{
name|unsigned
name|size
decl_stmt|;
name|ASM_OUTPUT_DWARF_ATTRIBUTE
argument_list|(
name|asm_out_file
argument_list|,
name|AT_byte_size
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|tree_node
argument_list|)
condition|)
block|{
case|case
name|ERROR_MARK
case|:
name|size
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|QUAL_UNION_TYPE
case|:
case|case
name|ARRAY_TYPE
case|:
name|size
operator|=
name|int_size_in_bytes
argument_list|(
name|tree_node
argument_list|)
expr_stmt|;
break|break;
case|case
name|FIELD_DECL
case|:
comment|/* For a data member of a struct or union, the AT_byte_size is 	   generally given as the number of bytes normally allocated for 	   an object of the *declared* type of the member itself.  This 	   is true even for bit-fields.  */
name|size
operator|=
name|simple_type_size_in_bits
argument_list|(
name|field_type
argument_list|(
name|tree_node
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Note that `size' might be -1 when we get to this point.  If it      is, that indicates that the byte size of the entity in question      is variable.  We have no good way of expressing this fact in Dwarf      at the present time, so just let the -1 pass on through.  */
name|ASM_OUTPUT_DWARF_DATA4
argument_list|(
name|asm_out_file
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* For a FIELD_DECL node which represents a bit-field, output an attribute    which specifies the distance in bits from the highest order bit of the    "containing object" for the bit-field to the highest order bit of the    bit-field itself.     For any given bit-field, the "containing object" is a hypothetical    object (of some integral or enum type) within which the given bit-field    lives.  The type of this hypothetical "containing object" is always the    same as the declared type of the individual bit-field itself.     The determination of the exact location of the "containing object" for    a bit-field is rather complicated.  It's handled by the `field_byte_offset'    function (above).     Note that it is the size (in bytes) of the hypothetical "containing    object" which will be given in the AT_byte_size attribute for this    bit-field.  (See `byte_size_attribute' above.) */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|bit_offset_attribute
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|HOST_WIDE_INT
name|object_offset_in_bytes
init|=
name|field_byte_offset
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|tree
name|type
init|=
name|DECL_BIT_FIELD_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|bitpos_int
decl_stmt|;
name|HOST_WIDE_INT
name|highest_order_object_bit_offset
decl_stmt|;
name|HOST_WIDE_INT
name|highest_order_field_bit_offset
decl_stmt|;
name|HOST_WIDE_INT
name|bit_offset
decl_stmt|;
comment|/* Must be a bit field.  */
if|if
condition|(
operator|!
name|type
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* We can't yet handle bit-fields whose offsets or sizes are variable, so      if we encounter such things, just return without generating any      attribute whatsoever.  */
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|bit_position
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|host_integerp
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
return|return;
name|bitpos_int
operator|=
name|int_bit_position
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Note that the bit offset is always the distance (in bits) from the      highest-order bit of the "containing object" to the highest-order      bit of the bit-field itself.  Since the "high-order end" of any      object or field is different on big-endian and little-endian machines,      the computation below must take account of these differences.  */
name|highest_order_object_bit_offset
operator|=
name|object_offset_in_bytes
operator|*
name|BITS_PER_UNIT
expr_stmt|;
name|highest_order_field_bit_offset
operator|=
name|bitpos_int
expr_stmt|;
if|if
condition|(
operator|!
name|BYTES_BIG_ENDIAN
condition|)
block|{
name|highest_order_field_bit_offset
operator|+=
name|tree_low_cst
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|highest_order_object_bit_offset
operator|+=
name|simple_type_size_in_bits
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
name|bit_offset
operator|=
operator|(
operator|!
name|BYTES_BIG_ENDIAN
condition|?
name|highest_order_object_bit_offset
operator|-
name|highest_order_field_bit_offset
else|:
name|highest_order_field_bit_offset
operator|-
name|highest_order_object_bit_offset
operator|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_ATTRIBUTE
argument_list|(
name|asm_out_file
argument_list|,
name|AT_bit_offset
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DATA2
argument_list|(
name|asm_out_file
argument_list|,
name|bit_offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* For a FIELD_DECL node which represents a bit field, output an attribute    which specifies the length in bits of the given field.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|bit_size_attribute
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
comment|/* Must be a field and a bit field.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FIELD_DECL
operator|||
operator|!
name|DECL_BIT_FIELD_TYPE
argument_list|(
name|decl
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|host_integerp
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|ASM_OUTPUT_DWARF_ATTRIBUTE
argument_list|(
name|asm_out_file
argument_list|,
name|AT_bit_size
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DATA4
argument_list|(
name|asm_out_file
argument_list|,
name|tree_low_cst
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The following routine outputs the `element_list' attribute for enumeration    type DIEs.  The element_lits attribute includes the names and values of    all of the enumeration constants associated with the given enumeration    type.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|element_list_attribute
parameter_list|(
name|element
parameter_list|)
name|tree
name|element
decl_stmt|;
block|{
name|char
name|begin_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|char
name|end_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|ASM_OUTPUT_DWARF_ATTRIBUTE
argument_list|(
name|asm_out_file
argument_list|,
name|AT_element_list
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|begin_label
argument_list|,
name|EE_BEGIN_LABEL_FMT
argument_list|,
name|current_dienum
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|end_label
argument_list|,
name|EE_END_LABEL_FMT
argument_list|,
name|current_dienum
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DELTA4
argument_list|(
name|asm_out_file
argument_list|,
name|end_label
argument_list|,
name|begin_label
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|begin_label
argument_list|)
expr_stmt|;
comment|/* Here we output a list of value/name pairs for each enumeration constant      defined for this enumeration type (as required), but we do it in REVERSE      order.  The order is the one required by the draft #5 Dwarf specification      published by the UI/PLSIG.  */
name|output_enumeral_list
argument_list|(
name|element
argument_list|)
expr_stmt|;
comment|/* Recursively output the whole list.  */
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|end_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate an AT_stmt_list attribute.	These are normally present only in    DIEs with a TAG_compile_unit tag.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|stmt_list_attribute
parameter_list|(
name|label
parameter_list|)
specifier|const
name|char
modifier|*
name|label
decl_stmt|;
block|{
name|ASM_OUTPUT_DWARF_ATTRIBUTE
argument_list|(
name|asm_out_file
argument_list|,
name|AT_stmt_list
argument_list|)
expr_stmt|;
comment|/* Don't use ASM_OUTPUT_DWARF_DATA4 here.  */
name|ASM_OUTPUT_DWARF_ADDR
argument_list|(
name|asm_out_file
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate an AT_low_pc attribute for a label DIE, a lexical_block DIE or    for a subroutine DIE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|low_pc_attribute
parameter_list|(
name|asm_low_label
parameter_list|)
specifier|const
name|char
modifier|*
name|asm_low_label
decl_stmt|;
block|{
name|ASM_OUTPUT_DWARF_ATTRIBUTE
argument_list|(
name|asm_out_file
argument_list|,
name|AT_low_pc
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_ADDR
argument_list|(
name|asm_out_file
argument_list|,
name|asm_low_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate an AT_high_pc attribute for a lexical_block DIE or for a    subroutine DIE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|high_pc_attribute
parameter_list|(
name|asm_high_label
parameter_list|)
specifier|const
name|char
modifier|*
name|asm_high_label
decl_stmt|;
block|{
name|ASM_OUTPUT_DWARF_ATTRIBUTE
argument_list|(
name|asm_out_file
argument_list|,
name|AT_high_pc
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_ADDR
argument_list|(
name|asm_out_file
argument_list|,
name|asm_high_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate an AT_body_begin attribute for a subroutine DIE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|body_begin_attribute
parameter_list|(
name|asm_begin_label
parameter_list|)
specifier|const
name|char
modifier|*
name|asm_begin_label
decl_stmt|;
block|{
name|ASM_OUTPUT_DWARF_ATTRIBUTE
argument_list|(
name|asm_out_file
argument_list|,
name|AT_body_begin
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_ADDR
argument_list|(
name|asm_out_file
argument_list|,
name|asm_begin_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate an AT_body_end attribute for a subroutine DIE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|body_end_attribute
parameter_list|(
name|asm_end_label
parameter_list|)
specifier|const
name|char
modifier|*
name|asm_end_label
decl_stmt|;
block|{
name|ASM_OUTPUT_DWARF_ATTRIBUTE
argument_list|(
name|asm_out_file
argument_list|,
name|AT_body_end
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_ADDR
argument_list|(
name|asm_out_file
argument_list|,
name|asm_end_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate an AT_language attribute given a LANG value.  These attributes    are used only within TAG_compile_unit DIEs.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|language_attribute
parameter_list|(
name|language_code
parameter_list|)
name|unsigned
name|language_code
decl_stmt|;
block|{
name|ASM_OUTPUT_DWARF_ATTRIBUTE
argument_list|(
name|asm_out_file
argument_list|,
name|AT_language
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DATA4
argument_list|(
name|asm_out_file
argument_list|,
name|language_code
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|member_attribute
parameter_list|(
name|context
parameter_list|)
name|tree
name|context
decl_stmt|;
block|{
name|char
name|label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
comment|/* Generate this attribute only for members in C++.  */
if|if
condition|(
name|context
operator|!=
name|NULL
operator|&&
name|is_tagged_type
argument_list|(
name|context
argument_list|)
condition|)
block|{
name|ASM_OUTPUT_DWARF_ATTRIBUTE
argument_list|(
name|asm_out_file
argument_list|,
name|AT_member
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|label
argument_list|,
name|TYPE_NAME_FMT
argument_list|,
name|TYPE_UID
argument_list|(
name|context
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_REF
argument_list|(
name|asm_out_file
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|SL_BEGIN_LABEL_FMT
end_ifndef

begin_define
define|#
directive|define
name|SL_BEGIN_LABEL_FMT
value|"*.L_sl%u"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SL_END_LABEL_FMT
end_ifndef

begin_define
define|#
directive|define
name|SL_END_LABEL_FMT
value|"*.L_sl%u_e"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
unit|static inline void string_length_attribute (upper_bound)      tree upper_bound; {   char begin_label[MAX_ARTIFICIAL_LABEL_BYTES];   char end_label[MAX_ARTIFICIAL_LABEL_BYTES];    ASM_OUTPUT_DWARF_ATTRIBUTE (asm_out_file, AT_string_length);   sprintf (begin_label, SL_BEGIN_LABEL_FMT, current_dienum);   sprintf (end_label, SL_END_LABEL_FMT, current_dienum);   ASM_OUTPUT_DWARF_DELTA2 (asm_out_file, end_label, begin_label);   ASM_OUTPUT_LABEL (asm_out_file, begin_label);   output_bound_representation (upper_bound, 0, 'u');   ASM_OUTPUT_LABEL (asm_out_file, end_label); }
endif|#
directive|endif
end_endif

begin_function
specifier|static
specifier|inline
name|void
name|comp_dir_attribute
parameter_list|(
name|dirname
parameter_list|)
specifier|const
name|char
modifier|*
name|dirname
decl_stmt|;
block|{
name|ASM_OUTPUT_DWARF_ATTRIBUTE
argument_list|(
name|asm_out_file
argument_list|,
name|AT_comp_dir
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_STRING_NEWLINE
argument_list|(
name|asm_out_file
argument_list|,
name|dirname
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|sf_names_attribute
parameter_list|(
name|sf_names_start_label
parameter_list|)
specifier|const
name|char
modifier|*
name|sf_names_start_label
decl_stmt|;
block|{
name|ASM_OUTPUT_DWARF_ATTRIBUTE
argument_list|(
name|asm_out_file
argument_list|,
name|AT_sf_names
argument_list|)
expr_stmt|;
comment|/* Don't use ASM_OUTPUT_DWARF_DATA4 here.  */
name|ASM_OUTPUT_DWARF_ADDR
argument_list|(
name|asm_out_file
argument_list|,
name|sf_names_start_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|src_info_attribute
parameter_list|(
name|src_info_start_label
parameter_list|)
specifier|const
name|char
modifier|*
name|src_info_start_label
decl_stmt|;
block|{
name|ASM_OUTPUT_DWARF_ATTRIBUTE
argument_list|(
name|asm_out_file
argument_list|,
name|AT_src_info
argument_list|)
expr_stmt|;
comment|/* Don't use ASM_OUTPUT_DWARF_DATA4 here.  */
name|ASM_OUTPUT_DWARF_ADDR
argument_list|(
name|asm_out_file
argument_list|,
name|src_info_start_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|mac_info_attribute
parameter_list|(
name|mac_info_start_label
parameter_list|)
specifier|const
name|char
modifier|*
name|mac_info_start_label
decl_stmt|;
block|{
name|ASM_OUTPUT_DWARF_ATTRIBUTE
argument_list|(
name|asm_out_file
argument_list|,
name|AT_mac_info
argument_list|)
expr_stmt|;
comment|/* Don't use ASM_OUTPUT_DWARF_DATA4 here.  */
name|ASM_OUTPUT_DWARF_ADDR
argument_list|(
name|asm_out_file
argument_list|,
name|mac_info_start_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|prototyped_attribute
parameter_list|(
name|func_type
parameter_list|)
name|tree
name|func_type
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|lang_hooks
operator|.
name|name
argument_list|,
literal|"GNU C"
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|TYPE_ARG_TYPES
argument_list|(
name|func_type
argument_list|)
operator|!=
name|NULL
operator|)
condition|)
block|{
name|ASM_OUTPUT_DWARF_ATTRIBUTE
argument_list|(
name|asm_out_file
argument_list|,
name|AT_prototyped
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_STRING_NEWLINE
argument_list|(
name|asm_out_file
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|producer_attribute
parameter_list|(
name|producer
parameter_list|)
specifier|const
name|char
modifier|*
name|producer
decl_stmt|;
block|{
name|ASM_OUTPUT_DWARF_ATTRIBUTE
argument_list|(
name|asm_out_file
argument_list|,
name|AT_producer
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_STRING_NEWLINE
argument_list|(
name|asm_out_file
argument_list|,
name|producer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|inline_attribute
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
name|DECL_INLINE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|ASM_OUTPUT_DWARF_ATTRIBUTE
argument_list|(
name|asm_out_file
argument_list|,
name|AT_inline
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_STRING_NEWLINE
argument_list|(
name|asm_out_file
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|containing_type_attribute
parameter_list|(
name|containing_type
parameter_list|)
name|tree
name|containing_type
decl_stmt|;
block|{
name|char
name|label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|ASM_OUTPUT_DWARF_ATTRIBUTE
argument_list|(
name|asm_out_file
argument_list|,
name|AT_containing_type
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|label
argument_list|,
name|TYPE_NAME_FMT
argument_list|,
name|TYPE_UID
argument_list|(
name|containing_type
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_REF
argument_list|(
name|asm_out_file
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|abstract_origin_attribute
parameter_list|(
name|origin
parameter_list|)
name|tree
name|origin
decl_stmt|;
block|{
name|char
name|label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|ASM_OUTPUT_DWARF_ATTRIBUTE
argument_list|(
name|asm_out_file
argument_list|,
name|AT_abstract_origin
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|origin
argument_list|)
argument_list|)
condition|)
block|{
case|case
literal|'d'
case|:
name|sprintf
argument_list|(
name|label
argument_list|,
name|DECL_NAME_FMT
argument_list|,
name|DECL_UID
argument_list|(
name|origin
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|sprintf
argument_list|(
name|label
argument_list|,
name|TYPE_NAME_FMT
argument_list|,
name|TYPE_UID
argument_list|(
name|origin
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
comment|/* Should never happen.  */
block|}
name|ASM_OUTPUT_DWARF_REF
argument_list|(
name|asm_out_file
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DWARF_DECL_COORDINATES
end_ifdef

begin_function
specifier|static
specifier|inline
name|void
name|src_coords_attribute
parameter_list|(
name|src_fileno
parameter_list|,
name|src_lineno
parameter_list|)
name|unsigned
name|src_fileno
decl_stmt|;
name|unsigned
name|src_lineno
decl_stmt|;
block|{
name|ASM_OUTPUT_DWARF_ATTRIBUTE
argument_list|(
name|asm_out_file
argument_list|,
name|AT_src_coords
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DATA2
argument_list|(
name|asm_out_file
argument_list|,
name|src_fileno
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DATA2
argument_list|(
name|asm_out_file
argument_list|,
name|src_lineno
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(DWARF_DECL_COORDINATES) */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|pure_or_virtual_attribute
parameter_list|(
name|func_decl
parameter_list|)
name|tree
name|func_decl
decl_stmt|;
block|{
if|if
condition|(
name|DECL_VIRTUAL_P
argument_list|(
name|func_decl
argument_list|)
condition|)
block|{
if|#
directive|if
literal|0
comment|/* DECL_ABSTRACT_VIRTUAL_P is C++-specific.  */
block|if (DECL_ABSTRACT_VIRTUAL_P (func_decl)) 	ASM_OUTPUT_DWARF_ATTRIBUTE (asm_out_file, AT_pure_virtual);       else
endif|#
directive|endif
name|ASM_OUTPUT_DWARF_ATTRIBUTE
argument_list|(
name|asm_out_file
argument_list|,
name|AT_virtual
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_STRING_NEWLINE
argument_list|(
name|asm_out_file
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/************************* end of attributes *****************************/
end_comment

begin_comment
comment|/********************* utility routines for DIEs *************************/
end_comment

begin_comment
comment|/* Output an AT_name attribute and an AT_src_coords attribute for the    given decl, but only if it actually has a name.  */
end_comment

begin_function
specifier|static
name|void
name|name_and_src_coords_attributes
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|decl_name
init|=
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|decl_name
operator|&&
name|IDENTIFIER_POINTER
argument_list|(
name|decl_name
argument_list|)
condition|)
block|{
name|name_attribute
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|decl_name
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DWARF_DECL_COORDINATES
block|{
specifier|register
name|unsigned
name|file_index
decl_stmt|;
comment|/* This is annoying, but we have to pop out of the .debug section 	   for a moment while we call `lookup_filename' because calling it 	   may cause a temporary switch into the .debug_sfnames section and 	   most svr4 assemblers are not smart enough to be able to nest 	   section switches to any depth greater than one.  Note that we 	   also can't skirt this issue by delaying all output to the 	   .debug_sfnames section unit the end of compilation because that 	   would cause us to have inter-section forward references and 	   Fred Fish sez that m68k/svr4 assemblers botch those.  */
name|ASM_OUTPUT_POP_SECTION
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
name|file_index
operator|=
name|lookup_filename
argument_list|(
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_PUSH_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|DEBUG_SECTION
argument_list|)
expr_stmt|;
name|src_coords_attribute
argument_list|(
name|file_index
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* defined(DWARF_DECL_COORDINATES) */
block|}
block|}
end_function

begin_comment
comment|/* Many forms of DIEs contain a "type description" part.  The following    routine writes out these "type descriptor" parts.  */
end_comment

begin_function
specifier|static
name|void
name|type_attribute
parameter_list|(
name|type
parameter_list|,
name|decl_const
parameter_list|,
name|decl_volatile
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|decl_const
decl_stmt|;
name|int
name|decl_volatile
decl_stmt|;
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|root_type_modified
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|ERROR_MARK
condition|)
return|return;
comment|/* Handle a special case.  For functions whose return type is void,      we generate *no* type attribute.  (Note that no object may have      type `void', so this only applies to function return types.  */
if|if
condition|(
name|code
operator|==
name|VOID_TYPE
condition|)
return|return;
comment|/* If this is a subtype, find the underlying type.  Eventually,      this should write out the appropriate subtype info.  */
while|while
condition|(
operator|(
name|code
operator|==
name|INTEGER_TYPE
operator|||
name|code
operator|==
name|REAL_TYPE
operator|)
operator|&&
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
operator|,
name|code
operator|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|root_type_modified
operator|=
operator|(
name|code
operator|==
name|POINTER_TYPE
operator|||
name|code
operator|==
name|REFERENCE_TYPE
operator|||
name|decl_const
operator|||
name|decl_volatile
operator|||
name|TYPE_READONLY
argument_list|(
name|type
argument_list|)
operator|||
name|TYPE_VOLATILE
argument_list|(
name|type
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|type_is_fundamental
argument_list|(
name|root_type
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|root_type_modified
condition|)
name|mod_fund_type_attribute
argument_list|(
name|type
argument_list|,
name|decl_const
argument_list|,
name|decl_volatile
argument_list|)
expr_stmt|;
else|else
name|fund_type_attribute
argument_list|(
name|fundamental_type_code
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|root_type_modified
condition|)
name|mod_u_d_type_attribute
argument_list|(
name|type
argument_list|,
name|decl_const
argument_list|,
name|decl_volatile
argument_list|)
expr_stmt|;
else|else
comment|/* We have to get the type_main_variant here (and pass that to the 	   `user_def_type_attribute' routine) because the ..._TYPE node we 	   have might simply be a *copy* of some original type node (where 	   the copy was created to help us keep track of typedef names) 	   and that copy might have a different TYPE_UID from the original 	   ..._TYPE node.  (Note that when `equate_type_number_to_die_number' 	   is labeling a given type DIE for future reference, it always and 	   only creates labels for DIEs representing *main variants*, and it 	   never even knows about non-main-variants.)  */
name|user_def_type_attribute
argument_list|(
name|type_main_variant
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Given a tree pointer to a struct, class, union, or enum type node, return    a pointer to the (string) tag name for the given type, or zero if the    type was declared without a tag.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|type_tag
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|name
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|tree
name|t
init|=
literal|0
decl_stmt|;
comment|/* Find the IDENTIFIER_NODE for the type name.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|t
operator|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* The g++ front end makes the TYPE_NAME of *each* tagged type point to          a TYPE_DECL node, regardless of whether or not a `typedef' was          involved.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
operator|!
name|DECL_IGNORED_P
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|t
operator|=
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now get the name as a string, or invent one.  */
if|if
condition|(
name|t
operator|!=
literal|0
condition|)
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|name
operator|==
literal|0
operator|||
operator|*
name|name
operator|==
literal|'\0'
operator|)
condition|?
literal|0
else|:
name|name
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|dienum_push
parameter_list|()
block|{
comment|/* Start by checking if the pending_sibling_stack needs to be expanded.      If necessary, expand it.  */
if|if
condition|(
name|pending_siblings
operator|==
name|pending_siblings_allocated
condition|)
block|{
name|pending_siblings_allocated
operator|+=
name|PENDING_SIBLINGS_INCREMENT
expr_stmt|;
name|pending_sibling_stack
operator|=
operator|(
name|unsigned
operator|*
operator|)
name|xrealloc
argument_list|(
name|pending_sibling_stack
argument_list|,
name|pending_siblings_allocated
operator|*
sizeof|sizeof
argument_list|(
name|unsigned
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|pending_siblings
operator|++
expr_stmt|;
name|NEXT_DIE_NUM
operator|=
name|next_unused_dienum
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pop the sibling stack so that the most recently pushed DIEnum becomes the    NEXT_DIE_NUM.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|dienum_pop
parameter_list|()
block|{
name|pending_siblings
operator|--
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|tree
name|member_declared_type
parameter_list|(
name|member
parameter_list|)
name|tree
name|member
decl_stmt|;
block|{
return|return
operator|(
name|DECL_BIT_FIELD_TYPE
argument_list|(
name|member
argument_list|)
operator|)
condition|?
name|DECL_BIT_FIELD_TYPE
argument_list|(
name|member
argument_list|)
else|:
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Get the function's label, as described by its RTL.    This may be different from the DECL_NAME name used    in the source file.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|function_start_label
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|rtx
name|x
decl_stmt|;
specifier|const
name|char
modifier|*
name|fnname
decl_stmt|;
name|x
operator|=
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fnname
operator|=
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|fnname
return|;
block|}
end_function

begin_comment
comment|/******************************* DIEs ************************************/
end_comment

begin_comment
comment|/* Output routines for individual types of DIEs.  */
end_comment

begin_comment
comment|/* Note that every type of DIE (except a null DIE) gets a sibling.  */
end_comment

begin_function
specifier|static
name|void
name|output_array_type_die
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|tree
name|type
init|=
name|arg
decl_stmt|;
name|ASM_OUTPUT_DWARF_TAG
argument_list|(
name|asm_out_file
argument_list|,
name|TAG_array_type
argument_list|)
expr_stmt|;
name|sibling_attribute
argument_list|()
expr_stmt|;
name|equate_type_number_to_die_number
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|member_attribute
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* I believe that we can default the array ordering.  SDB will probably      do the right things even if AT_ordering is not present.  It's not      even an issue until we start to get into multidimensional arrays      anyway.  If SDB is ever caught doing the Wrong Thing for multi-      dimensional arrays, then we'll have to put the AT_ordering attribute      back in.  (But if and when we find out that we need to put these in,      we will only do so for multidimensional arrays.  After all, we don't      want to waste space in the .debug section now do we?)  */
ifdef|#
directive|ifdef
name|USE_ORDERING_ATTRIBUTE
name|ordering_attribute
argument_list|(
name|ORD_row_major
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(USE_ORDERING_ATTRIBUTE) */
name|subscript_data_attribute
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_set_type_die
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|tree
name|type
init|=
name|arg
decl_stmt|;
name|ASM_OUTPUT_DWARF_TAG
argument_list|(
name|asm_out_file
argument_list|,
name|TAG_set_type
argument_list|)
expr_stmt|;
name|sibling_attribute
argument_list|()
expr_stmt|;
name|equate_type_number_to_die_number
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|member_attribute
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|type_attribute
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Implement this when there is a GNU FORTRAN or GNU Ada front end.  */
end_comment

begin_endif
unit|static void output_entry_point_die (arg)      void *arg; {   tree decl = arg;   tree origin = decl_ultimate_origin (decl);    ASM_OUTPUT_DWARF_TAG (asm_out_file, TAG_entry_point);   sibling_attribute ();   dienum_push ();   if (origin != NULL)     abstract_origin_attribute (origin);   else     {       name_and_src_coords_attributes (decl);       member_attribute (DECL_CONTEXT (decl));       type_attribute (TREE_TYPE (TREE_TYPE (decl)), 0, 0);     }   if (DECL_ABSTRACT (decl))     equate_decl_number_to_die_number (decl);   else     low_pc_attribute (function_start_label (decl)); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Output a DIE to represent an inlined instance of an enumeration type.  */
end_comment

begin_function
specifier|static
name|void
name|output_inlined_enumeration_type_die
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|tree
name|type
init|=
name|arg
decl_stmt|;
name|ASM_OUTPUT_DWARF_TAG
argument_list|(
name|asm_out_file
argument_list|,
name|TAG_enumeration_type
argument_list|)
expr_stmt|;
name|sibling_attribute
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|type
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|abstract_origin_attribute
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output a DIE to represent an inlined instance of a structure type.  */
end_comment

begin_function
specifier|static
name|void
name|output_inlined_structure_type_die
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|tree
name|type
init|=
name|arg
decl_stmt|;
name|ASM_OUTPUT_DWARF_TAG
argument_list|(
name|asm_out_file
argument_list|,
name|TAG_structure_type
argument_list|)
expr_stmt|;
name|sibling_attribute
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|type
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|abstract_origin_attribute
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output a DIE to represent an inlined instance of a union type.  */
end_comment

begin_function
specifier|static
name|void
name|output_inlined_union_type_die
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|tree
name|type
init|=
name|arg
decl_stmt|;
name|ASM_OUTPUT_DWARF_TAG
argument_list|(
name|asm_out_file
argument_list|,
name|TAG_union_type
argument_list|)
expr_stmt|;
name|sibling_attribute
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|type
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|abstract_origin_attribute
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output a DIE to represent an enumeration type.  Note that these DIEs    include all of the information about the enumeration values also.    This information is encoded into the element_list attribute.	 */
end_comment

begin_function
specifier|static
name|void
name|output_enumeration_type_die
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|tree
name|type
init|=
name|arg
decl_stmt|;
name|ASM_OUTPUT_DWARF_TAG
argument_list|(
name|asm_out_file
argument_list|,
name|TAG_enumeration_type
argument_list|)
expr_stmt|;
name|sibling_attribute
argument_list|()
expr_stmt|;
name|equate_type_number_to_die_number
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|name_attribute
argument_list|(
name|type_tag
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|member_attribute
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Handle a GNU C/C++ extension, i.e. incomplete enum types.  If the      given enum type is incomplete, do not generate the AT_byte_size      attribute or the AT_element_list attribute.  */
if|if
condition|(
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|byte_size_attribute
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|element_list_attribute
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output a DIE to represent either a real live formal parameter decl or    to represent just the type of some formal parameter position in some    function type.     Note that this routine is a bit unusual because its argument may be    a ..._DECL node (i.e. either a PARM_DECL or perhaps a VAR_DECL which    represents an inlining of some PARM_DECL) or else some sort of a    ..._TYPE node.  If it's the former then this function is being called    to output a DIE to represent a formal parameter object (or some inlining    thereof).  If it's the latter, then this function is only being called    to output a TAG_formal_parameter DIE to stand as a placeholder for some    formal argument type of some subprogram type.  */
end_comment

begin_function
specifier|static
name|void
name|output_formal_parameter_die
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|tree
name|node
init|=
name|arg
decl_stmt|;
name|ASM_OUTPUT_DWARF_TAG
argument_list|(
name|asm_out_file
argument_list|,
name|TAG_formal_parameter
argument_list|)
expr_stmt|;
name|sibling_attribute
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
argument_list|)
condition|)
block|{
case|case
literal|'d'
case|:
comment|/* We were called with some kind of a ..._DECL node.  */
block|{
specifier|register
name|tree
name|origin
init|=
name|decl_ultimate_origin
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|origin
operator|!=
name|NULL
condition|)
name|abstract_origin_attribute
argument_list|(
name|origin
argument_list|)
expr_stmt|;
else|else
block|{
name|name_and_src_coords_attributes
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|type_attribute
argument_list|(
name|TREE_TYPE
argument_list|(
name|node
argument_list|)
argument_list|,
name|TREE_READONLY
argument_list|(
name|node
argument_list|)
argument_list|,
name|TREE_THIS_VOLATILE
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_ABSTRACT
argument_list|(
name|node
argument_list|)
condition|)
name|equate_decl_number_to_die_number
argument_list|(
name|node
argument_list|)
expr_stmt|;
else|else
name|location_or_const_value_attribute
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'t'
case|:
comment|/* We were called with some kind of a ..._TYPE node.  */
name|type_attribute
argument_list|(
name|node
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
comment|/* Should never happen.  */
block|}
block|}
end_function

begin_comment
comment|/* Output a DIE to represent a declared function (either file-scope    or block-local) which has "external linkage" (according to ANSI-C).  */
end_comment

begin_function
specifier|static
name|void
name|output_global_subroutine_die
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|tree
name|decl
init|=
name|arg
decl_stmt|;
name|tree
name|origin
init|=
name|decl_ultimate_origin
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|ASM_OUTPUT_DWARF_TAG
argument_list|(
name|asm_out_file
argument_list|,
name|TAG_global_subroutine
argument_list|)
expr_stmt|;
name|sibling_attribute
argument_list|()
expr_stmt|;
name|dienum_push
argument_list|()
expr_stmt|;
if|if
condition|(
name|origin
operator|!=
name|NULL
condition|)
name|abstract_origin_attribute
argument_list|(
name|origin
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|name_and_src_coords_attributes
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|inline_attribute
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|prototyped_attribute
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|member_attribute
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|type_attribute
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pure_or_virtual_attribute
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_ABSTRACT
argument_list|(
name|decl
argument_list|)
condition|)
name|equate_decl_number_to_die_number
argument_list|(
name|decl
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|in_class
operator|&&
name|decl
operator|==
name|current_function_decl
condition|)
block|{
name|char
name|label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|low_pc_attribute
argument_list|(
name|function_start_label
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|label
argument_list|,
name|FUNC_END_LABEL_FMT
argument_list|,
name|current_function_funcdef_no
argument_list|)
expr_stmt|;
name|high_pc_attribute
argument_list|(
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_gnu_debug_info_extensions
condition|)
block|{
name|sprintf
argument_list|(
name|label
argument_list|,
name|BODY_BEGIN_LABEL_FMT
argument_list|,
name|current_function_funcdef_no
argument_list|)
expr_stmt|;
name|body_begin_attribute
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|label
argument_list|,
name|BODY_END_LABEL_FMT
argument_list|,
name|current_function_funcdef_no
argument_list|)
expr_stmt|;
name|body_end_attribute
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Output a DIE to represent a declared data object (either file-scope    or block-local) which has "external linkage" (according to ANSI-C).  */
end_comment

begin_function
specifier|static
name|void
name|output_global_variable_die
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|tree
name|decl
init|=
name|arg
decl_stmt|;
name|tree
name|origin
init|=
name|decl_ultimate_origin
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|ASM_OUTPUT_DWARF_TAG
argument_list|(
name|asm_out_file
argument_list|,
name|TAG_global_variable
argument_list|)
expr_stmt|;
name|sibling_attribute
argument_list|()
expr_stmt|;
if|if
condition|(
name|origin
operator|!=
name|NULL
condition|)
name|abstract_origin_attribute
argument_list|(
name|origin
argument_list|)
expr_stmt|;
else|else
block|{
name|name_and_src_coords_attributes
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|member_attribute
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|type_attribute
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_ABSTRACT
argument_list|(
name|decl
argument_list|)
condition|)
name|equate_decl_number_to_die_number
argument_list|(
name|decl
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|in_class
operator|&&
name|current_function_decl
operator|==
name|decl_function_context
argument_list|(
name|decl
argument_list|)
condition|)
name|location_or_const_value_attribute
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|output_label_die
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|tree
name|decl
init|=
name|arg
decl_stmt|;
name|tree
name|origin
init|=
name|decl_ultimate_origin
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|ASM_OUTPUT_DWARF_TAG
argument_list|(
name|asm_out_file
argument_list|,
name|TAG_label
argument_list|)
expr_stmt|;
name|sibling_attribute
argument_list|()
expr_stmt|;
if|if
condition|(
name|origin
operator|!=
name|NULL
condition|)
name|abstract_origin_attribute
argument_list|(
name|origin
argument_list|)
expr_stmt|;
else|else
name|name_and_src_coords_attributes
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_ABSTRACT
argument_list|(
name|decl
argument_list|)
condition|)
name|equate_decl_number_to_die_number
argument_list|(
name|decl
argument_list|)
expr_stmt|;
else|else
block|{
name|rtx
name|insn
init|=
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
decl_stmt|;
comment|/* Deleted labels are programmer specified labels which have been 	 eliminated because of various optimisations.  We still emit them 	 here so that it is possible to put breakpoints on them.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
operator|||
operator|(
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_DELETED_LABEL
operator|)
operator|)
condition|)
block|{
name|char
name|label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
comment|/* When optimization is enabled (via -O) some parts of the compiler 	     (e.g. jump.c and cse.c) may try to delete CODE_LABEL insns which 	     represent source-level labels which were explicitly declared by 	     the user.  This really shouldn't be happening though, so catch 	     it if it ever does happen.  */
if|if
condition|(
name|INSN_DELETED_P
argument_list|(
name|insn
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Should never happen.  */
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|low_pc_attribute
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|output_lexical_block_die
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|tree
name|stmt
init|=
name|arg
decl_stmt|;
name|ASM_OUTPUT_DWARF_TAG
argument_list|(
name|asm_out_file
argument_list|,
name|TAG_lexical_block
argument_list|)
expr_stmt|;
name|sibling_attribute
argument_list|()
expr_stmt|;
name|dienum_push
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|BLOCK_ABSTRACT
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
name|char
name|begin_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|char
name|end_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|begin_label
argument_list|,
name|BLOCK_BEGIN_LABEL_FMT
argument_list|,
name|BLOCK_NUMBER
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|low_pc_attribute
argument_list|(
name|begin_label
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|end_label
argument_list|,
name|BLOCK_END_LABEL_FMT
argument_list|,
name|BLOCK_NUMBER
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|high_pc_attribute
argument_list|(
name|end_label
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|output_inlined_subroutine_die
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|tree
name|stmt
init|=
name|arg
decl_stmt|;
name|ASM_OUTPUT_DWARF_TAG
argument_list|(
name|asm_out_file
argument_list|,
name|TAG_inlined_subroutine
argument_list|)
expr_stmt|;
name|sibling_attribute
argument_list|()
expr_stmt|;
name|dienum_push
argument_list|()
expr_stmt|;
name|abstract_origin_attribute
argument_list|(
name|block_ultimate_origin
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|BLOCK_ABSTRACT
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
name|char
name|begin_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|char
name|end_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|begin_label
argument_list|,
name|BLOCK_BEGIN_LABEL_FMT
argument_list|,
name|BLOCK_NUMBER
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|low_pc_attribute
argument_list|(
name|begin_label
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|end_label
argument_list|,
name|BLOCK_END_LABEL_FMT
argument_list|,
name|BLOCK_NUMBER
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|high_pc_attribute
argument_list|(
name|end_label
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output a DIE to represent a declared data object (either file-scope    or block-local) which has "internal linkage" (according to ANSI-C).  */
end_comment

begin_function
specifier|static
name|void
name|output_local_variable_die
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|tree
name|decl
init|=
name|arg
decl_stmt|;
name|tree
name|origin
init|=
name|decl_ultimate_origin
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|ASM_OUTPUT_DWARF_TAG
argument_list|(
name|asm_out_file
argument_list|,
name|TAG_local_variable
argument_list|)
expr_stmt|;
name|sibling_attribute
argument_list|()
expr_stmt|;
if|if
condition|(
name|origin
operator|!=
name|NULL
condition|)
name|abstract_origin_attribute
argument_list|(
name|origin
argument_list|)
expr_stmt|;
else|else
block|{
name|name_and_src_coords_attributes
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|member_attribute
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|type_attribute
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_ABSTRACT
argument_list|(
name|decl
argument_list|)
condition|)
name|equate_decl_number_to_die_number
argument_list|(
name|decl
argument_list|)
expr_stmt|;
else|else
name|location_or_const_value_attribute
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_member_die
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|tree
name|decl
init|=
name|arg
decl_stmt|;
name|ASM_OUTPUT_DWARF_TAG
argument_list|(
name|asm_out_file
argument_list|,
name|TAG_member
argument_list|)
expr_stmt|;
name|sibling_attribute
argument_list|()
expr_stmt|;
name|name_and_src_coords_attributes
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|member_attribute
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|type_attribute
argument_list|(
name|member_declared_type
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_BIT_FIELD_TYPE
argument_list|(
name|decl
argument_list|)
condition|)
comment|/* If this is a bit field...  */
block|{
name|byte_size_attribute
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|bit_size_attribute
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|bit_offset_attribute
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
name|data_member_location_attribute
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Don't generate either pointer_type DIEs or reference_type DIEs.  Use    modified types instead.     We keep this code here just in case these types of DIEs may be    needed to represent certain things in other languages (e.g. Pascal)    someday.  */
end_comment

begin_endif
unit|static void output_pointer_type_die (arg)      void *arg; {   tree type = arg;    ASM_OUTPUT_DWARF_TAG (asm_out_file, TAG_pointer_type);   sibling_attribute ();   equate_type_number_to_die_number (type);   member_attribute (TYPE_CONTEXT (type));   type_attribute (TREE_TYPE (type), 0, 0); }  static void output_reference_type_die (arg)      void *arg; {   tree type = arg;    ASM_OUTPUT_DWARF_TAG (asm_out_file, TAG_reference_type);   sibling_attribute ();   equate_type_number_to_die_number (type);   member_attribute (TYPE_CONTEXT (type));   type_attribute (TREE_TYPE (type), 0, 0); }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|output_ptr_to_mbr_type_die
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|tree
name|type
init|=
name|arg
decl_stmt|;
name|ASM_OUTPUT_DWARF_TAG
argument_list|(
name|asm_out_file
argument_list|,
name|TAG_ptr_to_member_type
argument_list|)
expr_stmt|;
name|sibling_attribute
argument_list|()
expr_stmt|;
name|equate_type_number_to_die_number
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|member_attribute
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|containing_type_attribute
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|type_attribute
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_compile_unit_die
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|main_input_filename
init|=
name|arg
decl_stmt|;
specifier|const
name|char
modifier|*
name|language_string
init|=
name|lang_hooks
operator|.
name|name
decl_stmt|;
name|ASM_OUTPUT_DWARF_TAG
argument_list|(
name|asm_out_file
argument_list|,
name|TAG_compile_unit
argument_list|)
expr_stmt|;
name|sibling_attribute
argument_list|()
expr_stmt|;
name|dienum_push
argument_list|()
expr_stmt|;
name|name_attribute
argument_list|(
name|main_input_filename
argument_list|)
expr_stmt|;
block|{
name|char
name|producer
index|[
literal|250
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|producer
argument_list|,
literal|"%s %s"
argument_list|,
name|language_string
argument_list|,
name|version_string
argument_list|)
expr_stmt|;
name|producer_attribute
argument_list|(
name|producer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|language_string
argument_list|,
literal|"GNU C++"
argument_list|)
operator|==
literal|0
condition|)
name|language_attribute
argument_list|(
name|LANG_C_PLUS_PLUS
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|language_string
argument_list|,
literal|"GNU Ada"
argument_list|)
operator|==
literal|0
condition|)
name|language_attribute
argument_list|(
name|LANG_ADA83
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|language_string
argument_list|,
literal|"GNU F77"
argument_list|)
operator|==
literal|0
condition|)
name|language_attribute
argument_list|(
name|LANG_FORTRAN77
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|language_string
argument_list|,
literal|"GNU Pascal"
argument_list|)
operator|==
literal|0
condition|)
name|language_attribute
argument_list|(
name|LANG_PASCAL83
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|language_string
argument_list|,
literal|"GNU Java"
argument_list|)
operator|==
literal|0
condition|)
name|language_attribute
argument_list|(
name|LANG_JAVA
argument_list|)
expr_stmt|;
else|else
name|language_attribute
argument_list|(
name|LANG_C89
argument_list|)
expr_stmt|;
name|low_pc_attribute
argument_list|(
name|TEXT_BEGIN_LABEL
argument_list|)
expr_stmt|;
name|high_pc_attribute
argument_list|(
name|TEXT_END_LABEL
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_info_level
operator|>=
name|DINFO_LEVEL_NORMAL
condition|)
name|stmt_list_attribute
argument_list|(
name|LINE_BEGIN_LABEL
argument_list|)
expr_stmt|;
block|{
specifier|const
name|char
modifier|*
name|wd
init|=
name|getpwd
argument_list|()
decl_stmt|;
if|if
condition|(
name|wd
condition|)
name|comp_dir_attribute
argument_list|(
name|wd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|debug_info_level
operator|>=
name|DINFO_LEVEL_NORMAL
operator|&&
name|use_gnu_debug_info_extensions
condition|)
block|{
name|sf_names_attribute
argument_list|(
name|SFNAMES_BEGIN_LABEL
argument_list|)
expr_stmt|;
name|src_info_attribute
argument_list|(
name|SRCINFO_BEGIN_LABEL
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_info_level
operator|>=
name|DINFO_LEVEL_VERBOSE
condition|)
name|mac_info_attribute
argument_list|(
name|MACINFO_BEGIN_LABEL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|output_string_type_die
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|tree
name|type
init|=
name|arg
decl_stmt|;
name|ASM_OUTPUT_DWARF_TAG
argument_list|(
name|asm_out_file
argument_list|,
name|TAG_string_type
argument_list|)
expr_stmt|;
name|sibling_attribute
argument_list|()
expr_stmt|;
name|equate_type_number_to_die_number
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|member_attribute
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* this is a fixed length string */
name|byte_size_attribute
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_inheritance_die
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|tree
name|binfo
init|=
name|arg
decl_stmt|;
name|ASM_OUTPUT_DWARF_TAG
argument_list|(
name|asm_out_file
argument_list|,
name|TAG_inheritance
argument_list|)
expr_stmt|;
name|sibling_attribute
argument_list|()
expr_stmt|;
name|type_attribute
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|data_member_location_attribute
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
name|ASM_OUTPUT_DWARF_ATTRIBUTE
argument_list|(
name|asm_out_file
argument_list|,
name|AT_virtual
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_STRING_NEWLINE
argument_list|(
name|asm_out_file
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_VIA_PUBLIC
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
name|ASM_OUTPUT_DWARF_ATTRIBUTE
argument_list|(
name|asm_out_file
argument_list|,
name|AT_public
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_STRING_NEWLINE
argument_list|(
name|asm_out_file
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_VIA_PROTECTED
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
name|ASM_OUTPUT_DWARF_ATTRIBUTE
argument_list|(
name|asm_out_file
argument_list|,
name|AT_protected
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_STRING_NEWLINE
argument_list|(
name|asm_out_file
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|output_structure_type_die
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|tree
name|type
init|=
name|arg
decl_stmt|;
name|ASM_OUTPUT_DWARF_TAG
argument_list|(
name|asm_out_file
argument_list|,
name|TAG_structure_type
argument_list|)
expr_stmt|;
name|sibling_attribute
argument_list|()
expr_stmt|;
name|equate_type_number_to_die_number
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|name_attribute
argument_list|(
name|type_tag
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|member_attribute
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this type has been completed, then give it a byte_size attribute      and prepare to give a list of members.  Otherwise, don't do either of      these things.  In the latter case, we will not be generating a list      of members (since we don't have any idea what they might be for an      incomplete type).	*/
if|if
condition|(
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|dienum_push
argument_list|()
expr_stmt|;
name|byte_size_attribute
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output a DIE to represent a declared function (either file-scope    or block-local) which has "internal linkage" (according to ANSI-C).  */
end_comment

begin_function
specifier|static
name|void
name|output_local_subroutine_die
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|tree
name|decl
init|=
name|arg
decl_stmt|;
name|tree
name|origin
init|=
name|decl_ultimate_origin
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|ASM_OUTPUT_DWARF_TAG
argument_list|(
name|asm_out_file
argument_list|,
name|TAG_subroutine
argument_list|)
expr_stmt|;
name|sibling_attribute
argument_list|()
expr_stmt|;
name|dienum_push
argument_list|()
expr_stmt|;
if|if
condition|(
name|origin
operator|!=
name|NULL
condition|)
name|abstract_origin_attribute
argument_list|(
name|origin
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|name_and_src_coords_attributes
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|inline_attribute
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|prototyped_attribute
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|member_attribute
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|type_attribute
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pure_or_virtual_attribute
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_ABSTRACT
argument_list|(
name|decl
argument_list|)
condition|)
name|equate_decl_number_to_die_number
argument_list|(
name|decl
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Avoid getting screwed up in cases where a function was declared 	 static but where no definition was ever given for it.  */
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|char
name|label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|low_pc_attribute
argument_list|(
name|function_start_label
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|label
argument_list|,
name|FUNC_END_LABEL_FMT
argument_list|,
name|current_function_funcdef_no
argument_list|)
expr_stmt|;
name|high_pc_attribute
argument_list|(
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_gnu_debug_info_extensions
condition|)
block|{
name|sprintf
argument_list|(
name|label
argument_list|,
name|BODY_BEGIN_LABEL_FMT
argument_list|,
name|current_function_funcdef_no
argument_list|)
expr_stmt|;
name|body_begin_attribute
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|label
argument_list|,
name|BODY_END_LABEL_FMT
argument_list|,
name|current_function_funcdef_no
argument_list|)
expr_stmt|;
name|body_end_attribute
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|output_subroutine_type_die
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|tree
name|type
init|=
name|arg
decl_stmt|;
name|tree
name|return_type
init|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|ASM_OUTPUT_DWARF_TAG
argument_list|(
name|asm_out_file
argument_list|,
name|TAG_subroutine_type
argument_list|)
expr_stmt|;
name|sibling_attribute
argument_list|()
expr_stmt|;
name|dienum_push
argument_list|()
expr_stmt|;
name|equate_type_number_to_die_number
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|prototyped_attribute
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|member_attribute
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|type_attribute
argument_list|(
name|return_type
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_typedef_die
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|tree
name|decl
init|=
name|arg
decl_stmt|;
name|tree
name|origin
init|=
name|decl_ultimate_origin
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|ASM_OUTPUT_DWARF_TAG
argument_list|(
name|asm_out_file
argument_list|,
name|TAG_typedef
argument_list|)
expr_stmt|;
name|sibling_attribute
argument_list|()
expr_stmt|;
if|if
condition|(
name|origin
operator|!=
name|NULL
condition|)
name|abstract_origin_attribute
argument_list|(
name|origin
argument_list|)
expr_stmt|;
else|else
block|{
name|name_and_src_coords_attributes
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|member_attribute
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|type_attribute
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_ABSTRACT
argument_list|(
name|decl
argument_list|)
condition|)
name|equate_decl_number_to_die_number
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_union_type_die
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|tree
name|type
init|=
name|arg
decl_stmt|;
name|ASM_OUTPUT_DWARF_TAG
argument_list|(
name|asm_out_file
argument_list|,
name|TAG_union_type
argument_list|)
expr_stmt|;
name|sibling_attribute
argument_list|()
expr_stmt|;
name|equate_type_number_to_die_number
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|name_attribute
argument_list|(
name|type_tag
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|member_attribute
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this type has been completed, then give it a byte_size attribute      and prepare to give a list of members.  Otherwise, don't do either of      these things.  In the latter case, we will not be generating a list      of members (since we don't have any idea what they might be for an      incomplete type).	*/
if|if
condition|(
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|dienum_push
argument_list|()
expr_stmt|;
name|byte_size_attribute
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate a special type of DIE used as a stand-in for a trailing ellipsis    at the end of an (ANSI prototyped) formal parameters list.  */
end_comment

begin_function
specifier|static
name|void
name|output_unspecified_parameters_die
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|tree
name|decl_or_type
init|=
name|arg
decl_stmt|;
name|ASM_OUTPUT_DWARF_TAG
argument_list|(
name|asm_out_file
argument_list|,
name|TAG_unspecified_parameters
argument_list|)
expr_stmt|;
name|sibling_attribute
argument_list|()
expr_stmt|;
comment|/* This kludge is here only for the sake of being compatible with what      the USL CI5 C compiler does.  The specification of Dwarf Version 1      doesn't say that TAG_unspecified_parameters DIEs should contain any      attributes other than the AT_sibling attribute, but they are certainly      allowed to contain additional attributes, and the CI5 compiler      generates AT_name, AT_fund_type, and AT_location attributes within      TAG_unspecified_parameters DIEs which appear in the child lists for      DIEs representing function definitions, so we do likewise here.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl_or_type
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl_or_type
argument_list|)
condition|)
block|{
name|name_attribute
argument_list|(
literal|"..."
argument_list|)
expr_stmt|;
name|fund_type_attribute
argument_list|(
name|FT_pointer
argument_list|)
expr_stmt|;
comment|/* location_attribute (?); */
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|output_padded_null_die
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* 2**2 == 4 */
block|}
end_function

begin_comment
comment|/*************************** end of DIEs *********************************/
end_comment

begin_comment
comment|/* Generate some type of DIE.  This routine generates the generic outer    wrapper stuff which goes around all types of DIE's (regardless of their    TAGs.  All forms of DIEs start with a DIE-specific label, followed by a    DIE-length word, followed by the guts of the DIE itself.  After the guts    of the DIE, there must always be a terminator label for the DIE.  */
end_comment

begin_function_decl
specifier|static
name|void
name|output_die
parameter_list|(
name|die_specific_output_function
parameter_list|,
name|param
parameter_list|)
function_decl|void
parameter_list|(
function_decl|*die_specific_output_function
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|void
modifier|*
name|param
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|begin_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|char
name|end_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|current_dienum
operator|=
name|NEXT_DIE_NUM
expr_stmt|;
name|NEXT_DIE_NUM
operator|=
name|next_unused_dienum
expr_stmt|;
name|sprintf
argument_list|(
name|begin_label
argument_list|,
name|DIE_BEGIN_LABEL_FMT
argument_list|,
name|current_dienum
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|end_label
argument_list|,
name|DIE_END_LABEL_FMT
argument_list|,
name|current_dienum
argument_list|)
expr_stmt|;
comment|/* Write a label which will act as the name for the start of this DIE.  */
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|begin_label
argument_list|)
expr_stmt|;
comment|/* Write the DIE-length word.	 */
name|ASM_OUTPUT_DWARF_DELTA4
argument_list|(
name|asm_out_file
argument_list|,
name|end_label
argument_list|,
name|begin_label
argument_list|)
expr_stmt|;
comment|/* Fill in the guts of the DIE.  */
name|next_unused_dienum
operator|++
expr_stmt|;
name|die_specific_output_function
argument_list|(
name|param
argument_list|)
expr_stmt|;
comment|/* Write a label which will act as the name for the end of this DIE.	*/
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|end_label
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|end_sibling_chain
parameter_list|()
block|{
name|char
name|begin_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|current_dienum
operator|=
name|NEXT_DIE_NUM
expr_stmt|;
name|NEXT_DIE_NUM
operator|=
name|next_unused_dienum
expr_stmt|;
name|sprintf
argument_list|(
name|begin_label
argument_list|,
name|DIE_BEGIN_LABEL_FMT
argument_list|,
name|current_dienum
argument_list|)
expr_stmt|;
comment|/* Write a label which will act as the name for the start of this DIE.  */
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|begin_label
argument_list|)
expr_stmt|;
comment|/* Write the DIE-length word.	 */
name|ASM_OUTPUT_DWARF_DATA4
argument_list|(
name|asm_out_file
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|dienum_pop
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate a list of nameless TAG_formal_parameter DIEs (and perhaps a    TAG_unspecified_parameters DIE) to represent the types of the formal    parameters as specified in some function type specification (except    for those which appear as part of a function *definition*).     Note that we must be careful here to output all of the parameter    DIEs *before* we output any DIEs needed to represent the types of    the formal parameters.  This keeps svr4 SDB happy because it    (incorrectly) thinks that the first non-parameter DIE it sees ends    the formal parameter list.  */
end_comment

begin_function
specifier|static
name|void
name|output_formal_types
parameter_list|(
name|function_or_method_type
parameter_list|)
name|tree
name|function_or_method_type
decl_stmt|;
block|{
name|tree
name|link
decl_stmt|;
name|tree
name|formal_type
init|=
name|NULL
decl_stmt|;
name|tree
name|first_parm_type
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|function_or_method_type
argument_list|)
decl_stmt|;
comment|/* Set TREE_ASM_WRITTEN while processing the parameters, lest we      get bogus recursion when outputting tagged types local to a      function declaration.  */
name|int
name|save_asm_written
init|=
name|TREE_ASM_WRITTEN
argument_list|(
name|function_or_method_type
argument_list|)
decl_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|function_or_method_type
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* In the case where we are generating a formal types list for a C++      non-static member function type, skip over the first thing on the      TYPE_ARG_TYPES list because it only represents the type of the      hidden `this pointer'.  The debugger should be able to figure      out (without being explicitly told) that this non-static member      function type takes a `this pointer' and should be able to figure      what the type of that hidden parameter is from the AT_member      attribute of the parent TAG_subroutine_type DIE.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function_or_method_type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|first_parm_type
operator|=
name|TREE_CHAIN
argument_list|(
name|first_parm_type
argument_list|)
expr_stmt|;
comment|/* Make our first pass over the list of formal parameter types and output      a TAG_formal_parameter DIE for each one.  */
for|for
control|(
name|link
operator|=
name|first_parm_type
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
name|formal_type
operator|=
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|formal_type
operator|==
name|void_type_node
condition|)
break|break;
comment|/* Output a (nameless) DIE to represent the formal parameter itself.  */
name|output_die
argument_list|(
name|output_formal_parameter_die
argument_list|,
name|formal_type
argument_list|)
expr_stmt|;
block|}
comment|/* If this function type has an ellipsis, add a TAG_unspecified_parameters      DIE to the end of the parameter list.  */
if|if
condition|(
name|formal_type
operator|!=
name|void_type_node
condition|)
name|output_die
argument_list|(
name|output_unspecified_parameters_die
argument_list|,
name|function_or_method_type
argument_list|)
expr_stmt|;
comment|/* Make our second (and final) pass over the list of formal parameter types      and output DIEs to represent those types (as necessary).  */
for|for
control|(
name|link
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|function_or_method_type
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
name|formal_type
operator|=
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|formal_type
operator|==
name|void_type_node
condition|)
break|break;
name|output_type
argument_list|(
name|formal_type
argument_list|,
name|function_or_method_type
argument_list|)
expr_stmt|;
block|}
name|TREE_ASM_WRITTEN
argument_list|(
name|function_or_method_type
argument_list|)
operator|=
name|save_asm_written
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Remember a type in the pending_types_list.  */
end_comment

begin_function
specifier|static
name|void
name|pend_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|pending_types
operator|==
name|pending_types_allocated
condition|)
block|{
name|pending_types_allocated
operator|+=
name|PENDING_TYPES_INCREMENT
expr_stmt|;
name|pending_types_list
operator|=
operator|(
name|tree
operator|*
operator|)
name|xrealloc
argument_list|(
name|pending_types_list
argument_list|,
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
operator|*
name|pending_types_allocated
argument_list|)
expr_stmt|;
block|}
name|pending_types_list
index|[
name|pending_types
operator|++
index|]
operator|=
name|type
expr_stmt|;
comment|/* Mark the pending type as having been output already (even though      it hasn't been).  This prevents the type from being added to the      pending_types_list more than once.  */
name|TREE_ASM_WRITTEN
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return nonzero if it is legitimate to output DIEs to represent a    given type while we are generating the list of child DIEs for some    DIE (e.g. a function or lexical block DIE) associated with a given scope.     See the comments within the function for a description of when it is    considered legitimate to output DIEs for various kinds of types.     Note that TYPE_CONTEXT(type) may be NULL (to indicate global scope)    or it may point to a BLOCK node (for types local to a block), or to a    FUNCTION_DECL node (for types local to the heading of some function    definition), or to a FUNCTION_TYPE node (for types local to the    prototyped parameter list of a function type specification), or to a    RECORD_TYPE, UNION_TYPE, or QUAL_UNION_TYPE node    (in the case of C++ nested types).     The `scope' parameter should likewise be NULL or should point to a    BLOCK node, a FUNCTION_DECL node, a FUNCTION_TYPE node, a RECORD_TYPE    node, a UNION_TYPE node, or a QUAL_UNION_TYPE node.     This function is used only for deciding when to "pend" and when to    "un-pend" types to/from the pending_types_list.     Note that we sometimes make use of this "type pending" feature in a    rather twisted way to temporarily delay the production of DIEs for the    types of formal parameters.  (We do this just to make svr4 SDB happy.)    It order to delay the production of DIEs representing types of formal    parameters, callers of this function supply `fake_containing_scope' as    the `scope' parameter to this function.  Given that fake_containing_scope    is a tagged type which is *not* the containing scope for *any* other type,    the desired effect is achieved, i.e. output of DIEs representing types    is temporarily suspended, and any type DIEs which would have otherwise    been output are instead placed onto the pending_types_list.  Later on,    we force these (temporarily pended) types to be output simply by calling    `output_pending_types_for_scope' with an actual argument equal to the    true scope of the types we temporarily pended.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|type_ok_for_scope
parameter_list|(
name|type
parameter_list|,
name|scope
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|scope
decl_stmt|;
block|{
comment|/* Tagged types (i.e. struct, union, and enum types) must always be      output only in the scopes where they actually belong (or else the      scoping of their own tag names and the scoping of their member      names will be incorrect).  Non-tagged-types on the other hand can      generally be output anywhere, except that svr4 SDB really doesn't      want to see them nested within struct or union types, so here we      say it is always OK to immediately output any such a (non-tagged)      type, so long as we are not within such a context.  Note that the      only kinds of non-tagged types which we will be dealing with here      (for C and C++ anyway) will be array types and function types.  */
return|return
name|is_tagged_type
argument_list|(
name|type
argument_list|)
condition|?
operator|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
operator|==
name|scope
comment|/* Ignore namespaces for the moment.  */
operator|||
operator|(
name|scope
operator|==
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|NAMESPACE_DECL
operator|)
operator|||
operator|(
name|scope
operator|==
name|NULL_TREE
operator|&&
name|is_tagged_type
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
name|TREE_ASM_WRITTEN
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
operator|)
else|:
operator|(
name|scope
operator|==
name|NULL_TREE
operator|||
operator|!
name|is_tagged_type
argument_list|(
name|scope
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Output any pending types (from the pending_types list) which we can output    now (taking into account the scope that we are working on now).     For each type output, remove the given type from the pending_types_list    *before* we try to output it.     Note that we have to process the list in beginning-to-end order,    because the call made here to output_type may cause yet more types    to be added to the end of the list, and we may have to output some    of them too.  */
end_comment

begin_function
specifier|static
name|void
name|output_pending_types_for_scope
parameter_list|(
name|containing_scope
parameter_list|)
name|tree
name|containing_scope
decl_stmt|;
block|{
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pending_types
condition|;
control|)
block|{
name|tree
name|type
init|=
name|pending_types_list
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|type_ok_for_scope
argument_list|(
name|type
argument_list|,
name|containing_scope
argument_list|)
condition|)
block|{
name|tree
modifier|*
name|mover
decl_stmt|;
name|tree
modifier|*
name|limit
decl_stmt|;
name|pending_types
operator|--
expr_stmt|;
name|limit
operator|=
operator|&
name|pending_types_list
index|[
name|pending_types
index|]
expr_stmt|;
for|for
control|(
name|mover
operator|=
operator|&
name|pending_types_list
index|[
name|i
index|]
init|;
name|mover
operator|<
name|limit
condition|;
name|mover
operator|++
control|)
operator|*
name|mover
operator|=
operator|*
operator|(
name|mover
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* Un-mark the type as having been output already (because it 	     hasn't been, really).  Then call output_type to generate a 	     Dwarf representation of it.  */
name|TREE_ASM_WRITTEN
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
name|output_type
argument_list|(
name|type
argument_list|,
name|containing_scope
argument_list|)
expr_stmt|;
comment|/* Don't increment the loop counter in this case because we 	     have shifted all of the subsequent pending types down one 	     element in the pending_types_list array.  */
block|}
else|else
name|i
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Remember a type in the incomplete_types_list.  */
end_comment

begin_function
specifier|static
name|void
name|add_incomplete_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|incomplete_types
operator|==
name|incomplete_types_allocated
condition|)
block|{
name|incomplete_types_allocated
operator|+=
name|INCOMPLETE_TYPES_INCREMENT
expr_stmt|;
name|incomplete_types_list
operator|=
operator|(
name|tree
operator|*
operator|)
name|xrealloc
argument_list|(
name|incomplete_types_list
argument_list|,
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
operator|*
name|incomplete_types_allocated
argument_list|)
expr_stmt|;
block|}
name|incomplete_types_list
index|[
name|incomplete_types
operator|++
index|]
operator|=
name|type
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Walk through the list of incomplete types again, trying once more to    emit full debugging info for them.  */
end_comment

begin_function
specifier|static
name|void
name|retry_incomplete_types
parameter_list|()
block|{
name|tree
name|type
decl_stmt|;
name|finalizing
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|incomplete_types
condition|)
block|{
operator|--
name|incomplete_types
expr_stmt|;
name|type
operator|=
name|incomplete_types_list
index|[
name|incomplete_types
index|]
expr_stmt|;
name|output_type
argument_list|(
name|type
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|output_type
parameter_list|(
name|type
parameter_list|,
name|containing_scope
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|containing_scope
decl_stmt|;
block|{
if|if
condition|(
name|type
operator|==
literal|0
operator|||
name|type
operator|==
name|error_mark_node
condition|)
return|return;
comment|/* We are going to output a DIE to represent the unqualified version of      this type (i.e. without any const or volatile qualifiers) so get      the main variant (i.e. the unqualified version) of this type now.  */
name|type
operator|=
name|type_main_variant
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|finalizing
operator|&&
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|member
decl_stmt|;
comment|/* Some of our nested types might not have been defined when we 	     were written out before; force them out now.  */
for|for
control|(
name|member
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|member
condition|;
name|member
operator|=
name|TREE_CHAIN
argument_list|(
name|member
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|member
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
argument_list|)
condition|)
name|output_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
argument_list|,
name|containing_scope
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* If this is a nested type whose containing class hasn't been      written out yet, writing it out will cover this one, too.  */
if|if
condition|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_P
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
name|output_type
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
argument_list|,
name|containing_scope
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Don't generate any DIEs for this type now unless it is OK to do so      (based upon what `type_ok_for_scope' tells us).  */
if|if
condition|(
operator|!
name|type_ok_for_scope
argument_list|(
name|type
argument_list|,
name|containing_scope
argument_list|)
condition|)
block|{
name|pend_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|ERROR_MARK
case|:
break|break;
case|case
name|VECTOR_TYPE
case|:
name|output_type
argument_list|(
name|TYPE_DEBUG_REPRESENTATION_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|containing_scope
argument_list|)
expr_stmt|;
break|break;
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
comment|/* Prevent infinite recursion in cases where this is a recursive 	   type.  Recursive types are possible in Ada.  */
name|TREE_ASM_WRITTEN
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* For these types, all that is required is that we output a DIE 	   (or a set of DIEs) to represent the "basis" type.  */
name|output_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|containing_scope
argument_list|)
expr_stmt|;
break|break;
case|case
name|OFFSET_TYPE
case|:
comment|/* This code is used for C++ pointer-to-data-member types.  */
comment|/* Output a description of the relevant class type.  */
name|output_type
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|containing_scope
argument_list|)
expr_stmt|;
comment|/* Output a description of the type of the object pointed to.  */
name|output_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|containing_scope
argument_list|)
expr_stmt|;
comment|/* Now output a DIE to represent this pointer-to-data-member type 	   itself.  */
name|output_die
argument_list|(
name|output_ptr_to_mbr_type_die
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|SET_TYPE
case|:
name|output_type
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|,
name|containing_scope
argument_list|)
expr_stmt|;
name|output_die
argument_list|(
name|output_set_type_die
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|FILE_TYPE
case|:
name|output_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|containing_scope
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
comment|/* No way to represent these in Dwarf yet!  */
break|break;
case|case
name|FUNCTION_TYPE
case|:
comment|/* Force out return type (in case it wasn't forced out already).  */
name|output_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|containing_scope
argument_list|)
expr_stmt|;
name|output_die
argument_list|(
name|output_subroutine_type_die
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|output_formal_types
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|end_sibling_chain
argument_list|()
expr_stmt|;
break|break;
case|case
name|METHOD_TYPE
case|:
comment|/* Force out return type (in case it wasn't forced out already).  */
name|output_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|containing_scope
argument_list|)
expr_stmt|;
name|output_die
argument_list|(
name|output_subroutine_type_die
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|output_formal_types
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|end_sibling_chain
argument_list|()
expr_stmt|;
break|break;
case|case
name|ARRAY_TYPE
case|:
if|if
condition|(
name|TYPE_STRING_FLAG
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|CHAR_TYPE
condition|)
block|{
name|output_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|containing_scope
argument_list|)
expr_stmt|;
name|output_die
argument_list|(
name|output_string_type_die
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|element_type
decl_stmt|;
name|element_type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|element_type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|element_type
operator|=
name|TREE_TYPE
argument_list|(
name|element_type
argument_list|)
expr_stmt|;
name|output_type
argument_list|(
name|element_type
argument_list|,
name|containing_scope
argument_list|)
expr_stmt|;
name|output_die
argument_list|(
name|output_array_type_die
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|QUAL_UNION_TYPE
case|:
comment|/* For a non-file-scope tagged type, we can always go ahead and 	   output a Dwarf description of this type right now, even if 	   the type in question is still incomplete, because if this 	   local type *was* ever completed anywhere within its scope, 	   that complete definition would already have been attached to 	   this RECORD_TYPE, UNION_TYPE, QUAL_UNION_TYPE or ENUMERAL_TYPE 	   node by the time we reach this point.  That's true because of the 	   way the front-end does its processing of file-scope declarations (of 	   functions and class types) within which other types might be 	   nested.  The C and C++ front-ends always gobble up such "local 	   scope" things en-mass before they try to output *any* debugging 	   information for any of the stuff contained inside them and thus, 	   we get the benefit here of what is (in effect) a pre-resolution 	   of forward references to tagged types in local scopes.  	   Note however that for file-scope tagged types we cannot assume 	   that such pre-resolution of forward references has taken place. 	   A given file-scope tagged type may appear to be incomplete when 	   we reach this point, but it may yet be given a full definition 	   (at file-scope) later on during compilation.  In order to avoid 	   generating a premature (and possibly incorrect) set of Dwarf 	   DIEs for such (as yet incomplete) file-scope tagged types, we 	   generate nothing at all for as-yet incomplete file-scope tagged 	   types here unless we are making our special "finalization" pass 	   for file-scope things at the very end of compilation.  At that 	   time, we will certainly know as much about each file-scope tagged 	   type as we are ever going to know, so at that point in time, we 	   can safely generate correct Dwarf descriptions for these file- 	   scope tagged types.  */
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
operator|==
name|NULL
operator|||
name|AGGREGATE_TYPE_P
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|NAMESPACE_DECL
operator|)
operator|&&
operator|!
name|finalizing
condition|)
block|{
comment|/* We don't need to do this for function-local types.  */
if|if
condition|(
operator|!
name|decl_function_context
argument_list|(
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|add_incomplete_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return;
comment|/* EARLY EXIT!  Avoid setting TREE_ASM_WRITTEN.  */
block|}
comment|/* Prevent infinite recursion in cases where the type of some 	   member of this type is expressed in terms of this type itself.  */
name|TREE_ASM_WRITTEN
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Output a DIE to represent the tagged type itself.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|ENUMERAL_TYPE
case|:
name|output_die
argument_list|(
name|output_enumeration_type_die
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return;
comment|/* a special case -- nothing left to do so just return */
case|case
name|RECORD_TYPE
case|:
name|output_die
argument_list|(
name|output_structure_type_die
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNION_TYPE
case|:
case|case
name|QUAL_UNION_TYPE
case|:
name|output_die
argument_list|(
name|output_union_type_die
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
comment|/* Should never happen.  */
block|}
comment|/* If this is not an incomplete type, output descriptions of 	   each of its members.  	   Note that as we output the DIEs necessary to represent the 	   members of this record or union type, we will also be trying 	   to output DIEs to represent the *types* of those members. 	   However the `output_type' function (above) will specifically 	   avoid generating type DIEs for member types *within* the list 	   of member DIEs for this (containing) type except for those 	   types (of members) which are explicitly marked as also being 	   members of this (containing) type themselves.  The g++ front- 	   end can force any given type to be treated as a member of some 	   other (containing) type by setting the TYPE_CONTEXT of the 	   given (member) type to point to the TREE node representing the 	   appropriate (containing) type. 	*/
if|if
condition|(
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* First output info about the base classes.  */
if|if
condition|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_BINFO_BASETYPES
argument_list|(
name|type
argument_list|)
condition|)
block|{
specifier|register
name|tree
name|bases
init|=
name|TYPE_BINFO_BASETYPES
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|int
name|n_bases
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|bases
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_bases
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|bases
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|output_type
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|containing_scope
argument_list|)
expr_stmt|;
name|output_die
argument_list|(
name|output_inheritance_die
argument_list|,
name|binfo
argument_list|)
expr_stmt|;
block|}
block|}
operator|++
name|in_class
expr_stmt|;
block|{
name|tree
name|normal_member
decl_stmt|;
comment|/* Now output info about the data members and type members.  */
for|for
control|(
name|normal_member
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|normal_member
condition|;
name|normal_member
operator|=
name|TREE_CHAIN
argument_list|(
name|normal_member
argument_list|)
control|)
name|output_decl
argument_list|(
name|normal_member
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|{
name|tree
name|func_member
decl_stmt|;
comment|/* Now output info about the function members (if any).  */
for|for
control|(
name|func_member
operator|=
name|TYPE_METHODS
argument_list|(
name|type
argument_list|)
init|;
name|func_member
condition|;
name|func_member
operator|=
name|TREE_CHAIN
argument_list|(
name|func_member
argument_list|)
control|)
block|{
comment|/* Don't include clones in the member list.  */
if|if
condition|(
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|func_member
argument_list|)
condition|)
continue|continue;
name|output_decl
argument_list|(
name|func_member
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
operator|--
name|in_class
expr_stmt|;
comment|/* RECORD_TYPEs, UNION_TYPEs, and QUAL_UNION_TYPEs are themselves 	       scopes (at least in C++) so we must now output any nested 	       pending types which are local just to this type.  */
name|output_pending_types_for_scope
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|end_sibling_chain
argument_list|()
expr_stmt|;
comment|/* Terminate member chain.  */
block|}
break|break;
case|case
name|VOID_TYPE
case|:
case|case
name|INTEGER_TYPE
case|:
case|case
name|REAL_TYPE
case|:
case|case
name|COMPLEX_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
case|case
name|CHAR_TYPE
case|:
break|break;
comment|/* No DIEs needed for fundamental types.  */
case|case
name|LANG_TYPE
case|:
comment|/* No Dwarf representation currently defined.  */
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|TREE_ASM_WRITTEN
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_tagged_type_instantiation
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|type
operator|==
literal|0
operator|||
name|type
operator|==
name|error_mark_node
condition|)
return|return;
comment|/* We are going to output a DIE to represent the unqualified version of      this type (i.e. without any const or volatile qualifiers) so make      sure that we have the main variant (i.e. the unqualified version) of      this type now.  */
if|if
condition|(
name|type
operator|!=
name|type_main_variant
argument_list|(
name|type
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|type
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|ERROR_MARK
case|:
break|break;
case|case
name|ENUMERAL_TYPE
case|:
name|output_die
argument_list|(
name|output_inlined_enumeration_type_die
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|RECORD_TYPE
case|:
name|output_die
argument_list|(
name|output_inlined_structure_type_die
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNION_TYPE
case|:
case|case
name|QUAL_UNION_TYPE
case|:
name|output_die
argument_list|(
name|output_inlined_union_type_die
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
comment|/* Should never happen.  */
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output a TAG_lexical_block DIE followed by DIEs to represent all of    the things which are local to the given block.  */
end_comment

begin_function
specifier|static
name|void
name|output_block
parameter_list|(
name|stmt
parameter_list|,
name|depth
parameter_list|)
name|tree
name|stmt
decl_stmt|;
name|int
name|depth
decl_stmt|;
block|{
name|int
name|must_output_die
init|=
literal|0
decl_stmt|;
name|tree
name|origin
decl_stmt|;
name|enum
name|tree_code
name|origin_code
decl_stmt|;
comment|/* Ignore blocks never really used to make RTL.  */
if|if
condition|(
operator|!
name|stmt
operator|||
operator|!
name|TREE_USED
argument_list|(
name|stmt
argument_list|)
operator|||
operator|(
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|stmt
argument_list|)
operator|&&
operator|!
name|BLOCK_ABSTRACT
argument_list|(
name|stmt
argument_list|)
operator|)
condition|)
return|return;
comment|/* Determine the "ultimate origin" of this block.  This block may be an      inlined instance of an inlined instance of inline function, so we      have to trace all of the way back through the origin chain to find      out what sort of node actually served as the original seed for the      creation of the current block.  */
name|origin
operator|=
name|block_ultimate_origin
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|origin_code
operator|=
operator|(
name|origin
operator|!=
name|NULL
operator|)
condition|?
name|TREE_CODE
argument_list|(
name|origin
argument_list|)
else|:
name|ERROR_MARK
expr_stmt|;
comment|/* Determine if we need to output any Dwarf DIEs at all to represent this      block.  */
if|if
condition|(
name|origin_code
operator|==
name|FUNCTION_DECL
condition|)
comment|/* The outer scopes for inlinings *must* always be represented.  We        generate TAG_inlined_subroutine DIEs for them.  (See below.)  */
name|must_output_die
operator|=
literal|1
expr_stmt|;
else|else
block|{
comment|/* In the case where the current block represents an inlining of the 	 "body block" of an inline function, we must *NOT* output any DIE 	 for this block because we have already output a DIE to represent 	 the whole inlined function scope and the "body block" of any 	 function doesn't really represent a different scope according to 	 ANSI C rules.  So we check here to make sure that this block does 	 not represent a "body block inlining" before trying to set the 	 `must_output_die' flag.  */
if|if
condition|(
operator|!
name|is_body_block
argument_list|(
name|origin
condition|?
name|origin
else|:
name|stmt
argument_list|)
condition|)
block|{
comment|/* Determine if this block directly contains any "significant" 	     local declarations which we will need to output DIEs for.  */
if|if
condition|(
name|debug_info_level
operator|>
name|DINFO_LEVEL_TERSE
condition|)
comment|/* We are not in terse mode so *any* local declaration counts 	       as being a "significant" one.  */
name|must_output_die
operator|=
operator|(
name|BLOCK_VARS
argument_list|(
name|stmt
argument_list|)
operator|!=
name|NULL
operator|)
expr_stmt|;
else|else
block|{
name|tree
name|decl
decl_stmt|;
comment|/* We are in terse mode, so only local (nested) function 	         definitions count as "significant" local declarations.  */
for|for
control|(
name|decl
operator|=
name|BLOCK_VARS
argument_list|(
name|stmt
argument_list|)
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|must_output_die
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
comment|/* It would be a waste of space to generate a Dwarf TAG_lexical_block      DIE for any block which contains no significant local declarations      at all.  Rather, in such cases we just call `output_decls_for_scope'      so that any needed Dwarf info for any sub-blocks will get properly      generated.  Note that in terse mode, our definition of what constitutes      a "significant" local declaration gets restricted to include only      inlined function instances and local (nested) function definitions.  */
if|if
condition|(
name|origin_code
operator|==
name|FUNCTION_DECL
operator|&&
name|BLOCK_ABSTRACT
argument_list|(
name|stmt
argument_list|)
condition|)
comment|/* We don't care about an abstract inlined subroutine.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|must_output_die
condition|)
block|{
name|output_die
argument_list|(
operator|(
name|origin_code
operator|==
name|FUNCTION_DECL
operator|)
condition|?
name|output_inlined_subroutine_die
else|:
name|output_lexical_block_die
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|output_decls_for_scope
argument_list|(
name|stmt
argument_list|,
name|depth
argument_list|)
expr_stmt|;
name|end_sibling_chain
argument_list|()
expr_stmt|;
block|}
else|else
name|output_decls_for_scope
argument_list|(
name|stmt
argument_list|,
name|depth
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output all of the decls declared within a given scope (also called    a `binding contour') and (recursively) all of it's sub-blocks.  */
end_comment

begin_function
specifier|static
name|void
name|output_decls_for_scope
parameter_list|(
name|stmt
parameter_list|,
name|depth
parameter_list|)
name|tree
name|stmt
decl_stmt|;
name|int
name|depth
decl_stmt|;
block|{
comment|/* Ignore blocks never really used to make RTL.  */
if|if
condition|(
operator|!
name|stmt
operator|||
operator|!
name|TREE_USED
argument_list|(
name|stmt
argument_list|)
condition|)
return|return;
comment|/* Output the DIEs to represent all of the data objects, functions,      typedefs, and tagged types declared directly within this block      but not within any nested sub-blocks.  */
block|{
name|tree
name|decl
decl_stmt|;
for|for
control|(
name|decl
operator|=
name|BLOCK_VARS
argument_list|(
name|stmt
argument_list|)
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
name|output_decl
argument_list|(
name|decl
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
block|}
name|output_pending_types_for_scope
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
comment|/* Output the DIEs to represent all sub-blocks (and the items declared      therein) of this block.	 */
block|{
name|tree
name|subblocks
decl_stmt|;
for|for
control|(
name|subblocks
operator|=
name|BLOCK_SUBBLOCKS
argument_list|(
name|stmt
argument_list|)
init|;
name|subblocks
condition|;
name|subblocks
operator|=
name|BLOCK_CHAIN
argument_list|(
name|subblocks
argument_list|)
control|)
name|output_block
argument_list|(
name|subblocks
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Is this a typedef we can avoid emitting?  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|is_redundant_typedef
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
name|TYPE_DECL_IS_STUB
argument_list|(
name|decl
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|&&
name|is_tagged_type
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
condition|)
comment|/* Also ignore the artificial member typedef for the class name.  */
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Output Dwarf .debug information for a decl described by DECL.  */
end_comment

begin_function
specifier|static
name|void
name|output_decl
parameter_list|(
name|decl
parameter_list|,
name|containing_scope
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|tree
name|containing_scope
decl_stmt|;
block|{
comment|/* Make a note of the decl node we are going to be working on.  We may      need to give the user the source coordinates of where it appeared in      case we notice (later on) that something about it looks screwy.  */
name|dwarf_last_decl
operator|=
name|decl
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return;
comment|/* If a structure is declared within an initialization, e.g. as the      operand of a sizeof, then it will not have a name.  We don't want      to output a DIE for it, as the tree nodes are in the temporary obstack */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
operator|)
operator|&&
operator|(
operator|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|&&
name|TYPE_NAME
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
operator|==
name|ERROR_MARK
operator|)
operator|)
operator|)
condition|)
return|return;
comment|/* If this ..._DECL node is marked to be ignored, then ignore it.  */
if|if
condition|(
name|DECL_IGNORED_P
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
case|case
name|CONST_DECL
case|:
comment|/* The individual enumerators of an enum type get output when we 	 output the Dwarf representation of the relevant enum type itself.  */
break|break;
case|case
name|FUNCTION_DECL
case|:
comment|/* If we are in terse mode, don't output any DIEs to represent 	 mere function declarations.  Also, if we are conforming 	 to the DWARF version 1 specification, don't output DIEs for 	 mere function declarations.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
condition|)
if|#
directive|if
operator|(
name|DWARF_VERSION
operator|>
literal|1
operator|)
if|if
condition|(
name|debug_info_level
operator|<=
name|DINFO_LEVEL_TERSE
condition|)
endif|#
directive|endif
break|break;
comment|/* Before we describe the FUNCTION_DECL itself, make sure that we 	 have described its return type.  */
name|output_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|containing_scope
argument_list|)
expr_stmt|;
block|{
comment|/* And its containing type.  */
specifier|register
name|tree
name|origin
init|=
name|decl_class_context
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|origin
condition|)
name|output_type
argument_list|(
name|origin
argument_list|,
name|containing_scope
argument_list|)
expr_stmt|;
block|}
comment|/* If we're emitting an out-of-line copy of an inline function, 	 set up to refer to the abstract instance emitted from 	 dwarfout_deferred_inline_function.  */
if|if
condition|(
name|DECL_INLINE
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_ABSTRACT
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
operator|(
name|containing_scope
operator|&&
name|TYPE_P
argument_list|(
name|containing_scope
argument_list|)
operator|)
condition|)
name|set_decl_origin_self
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* If the following DIE will represent a function definition for a 	 function with "extern" linkage, output a special "pubnames" DIE 	 label just ahead of the actual DIE.  A reference to this label 	 was already generated in the .debug_pubnames section sub-entry 	 for this function definition.  */
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|char
name|label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|label
argument_list|,
name|PUB_DIE_LABEL_FMT
argument_list|,
name|next_pubname_number
operator|++
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
comment|/* Now output a DIE to represent the function itself.  */
name|output_die
argument_list|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|?
name|output_global_subroutine_die
else|:
name|output_local_subroutine_die
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* Now output descriptions of the arguments for this function. 	 This gets (unnecessarily?) complex because of the fact that 	 the DECL_ARGUMENT list for a FUNCTION_DECL doesn't indicate 	 cases where there was a trailing `...' at the end of the formal 	 parameter list.  In order to find out if there was a trailing 	 ellipsis or not, we must instead look at the type associated 	 with the FUNCTION_DECL.  This will be a node of type FUNCTION_TYPE. 	 If the chain of type nodes hanging off of this FUNCTION_TYPE node 	 ends with a void_type_node then there should *not* be an ellipsis 	 at the end.  */
comment|/* In the case where we are describing a mere function declaration, all 	 we need to do here (and all we *can* do here) is to describe 	 the *types* of its formal parameters.  */
if|if
condition|(
name|decl
operator|!=
name|current_function_decl
operator|||
name|in_class
condition|)
name|output_formal_types
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Generate DIEs to represent all known formal parameters */
name|tree
name|arg_decls
init|=
name|DECL_ARGUMENTS
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|tree
name|parm
decl_stmt|;
comment|/* WARNING!  Kludge zone ahead!  Here we have a special 	     hack for svr4 SDB compatibility.  Instead of passing the 	     current FUNCTION_DECL node as the second parameter (i.e. 	     the `containing_scope' parameter) to `output_decl' (as 	     we ought to) we instead pass a pointer to our own private 	     fake_containing_scope node.  That node is a RECORD_TYPE 	     node which NO OTHER TYPE may ever actually be a member of.  	     This pointer will ultimately get passed into `output_type' 	     as its `containing_scope' parameter.  `Output_type' will 	     then perform its part in the hack... i.e. it will pend 	     the type of the formal parameter onto the pending_types 	     list.  Later on, when we are done generating the whole 	     sequence of formal parameter DIEs for this function 	     definition, we will un-pend all previously pended types 	     of formal parameters for this function definition.  	     This whole kludge prevents any type DIEs from being 	     mixed in with the formal parameter DIEs.  That's good 	     because svr4 SDB believes that the list of formal 	     parameter DIEs for a function ends wherever the first 	     non-formal-parameter DIE appears.  Thus, we have to 	     keep the formal parameter DIEs segregated.  They must 	     all appear (consecutively) at the start of the list of 	     children for the DIE representing the function definition. 	     Then (and only then) may we output any additional DIEs 	     needed to represent the types of these formal parameters. 	  */
comment|/* 	     When generating DIEs, generate the unspecified_parameters 	     DIE instead if we come across the arg "__builtin_va_alist" 	  */
for|for
control|(
name|parm
operator|=
name|arg_decls
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|PARM_DECL
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|parm
argument_list|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|parm
argument_list|)
argument_list|)
argument_list|,
literal|"__builtin_va_alist"
argument_list|)
condition|)
name|output_die
argument_list|(
name|output_unspecified_parameters_die
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
name|output_decl
argument_list|(
name|parm
argument_list|,
name|fake_containing_scope
argument_list|)
expr_stmt|;
block|}
comment|/* 	     Now that we have finished generating all of the DIEs to 	     represent the formal parameters themselves, force out 	     any DIEs needed to represent their types.  We do this 	     simply by un-pending all previously pended types which 	     can legitimately go into the chain of children DIEs for 	     the current FUNCTION_DECL. 	  */
name|output_pending_types_for_scope
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* 	    Decide whether we need an unspecified_parameters DIE at the end. 	    There are 2 more cases to do this for: 	    1) the ansi ... declaration - this is detectable when the end 		of the arg list is not a void_type_node 	    2) an unprototyped function declaration (not a definition).  This 		just means that we have no info about the parameters at all. 	  */
block|{
name|tree
name|fn_arg_types
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|fn_arg_types
condition|)
block|{
comment|/* this is the prototyped case, check for ...  */
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|tree_last
argument_list|(
name|fn_arg_types
argument_list|)
argument_list|)
operator|!=
name|void_type_node
condition|)
name|output_die
argument_list|(
name|output_unspecified_parameters_die
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* this is unprototyped, check for undefined (just declaration) */
if|if
condition|(
operator|!
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
condition|)
name|output_die
argument_list|(
name|output_unspecified_parameters_die
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Output Dwarf info for all of the stuff within the body of the 	     function (if it has one - it may be just a declaration).  */
block|{
name|tree
name|outer_scope
init|=
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|outer_scope
operator|&&
name|TREE_CODE
argument_list|(
name|outer_scope
argument_list|)
operator|!=
name|ERROR_MARK
condition|)
block|{
comment|/* Note that here, `outer_scope' is a pointer to the outermost 		   BLOCK node created to represent a function. 		   This outermost BLOCK actually represents the outermost 		   binding contour for the function, i.e. the contour in which 		   the function's formal parameters and labels get declared.  		   Curiously, it appears that the front end doesn't actually 		   put the PARM_DECL nodes for the current function onto the 		   BLOCK_VARS list for this outer scope.  (They are strung 		   off of the DECL_ARGUMENTS list for the function instead.) 		   The BLOCK_VARS list for the `outer_scope' does provide us 		   with a list of the LABEL_DECL nodes for the function however, 		   and we output DWARF info for those here.  		   Just within the `outer_scope' there will be a BLOCK node 		   representing the function's outermost pair of curly braces, 		   and any blocks used for the base and member initializers of 		   a C++ constructor function.  */
name|output_decls_for_scope
argument_list|(
name|outer_scope
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Finally, force out any pending types which are local to the 		   outermost block of this function definition.  These will 		   all have a TYPE_CONTEXT which points to the FUNCTION_DECL 		   node itself.  */
name|output_pending_types_for_scope
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Generate a terminator for the list of stuff `owned' by this 	 function.  */
name|end_sibling_chain
argument_list|()
expr_stmt|;
break|break;
case|case
name|TYPE_DECL
case|:
comment|/* If we are in terse mode, don't generate any DIEs to represent 	 any actual typedefs.  Note that even when we are in terse mode, 	 we must still output DIEs to represent those tagged types which 	 are used (directly or indirectly) in the specification of either 	 a return type or a formal parameter type of some function.  */
if|if
condition|(
name|debug_info_level
operator|<=
name|DINFO_LEVEL_TERSE
condition|)
if|if
condition|(
operator|!
name|TYPE_DECL_IS_STUB
argument_list|(
name|decl
argument_list|)
operator|||
operator|(
operator|!
name|TYPE_USED_FOR_FUNCTION
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|&&
operator|!
name|in_class
operator|)
condition|)
return|return;
comment|/* In the special case of a TYPE_DECL node representing 	 the declaration of some type tag, if the given TYPE_DECL is 	 marked as having been instantiated from some other (original) 	 TYPE_DECL node (e.g. one which was generated within the original 	 definition of an inline function) we have to generate a special 	 (abbreviated) TAG_structure_type, TAG_union_type, or 	 TAG_enumeration-type DIE here.  */
if|if
condition|(
name|TYPE_DECL_IS_STUB
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|output_tagged_type_instantiation
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|output_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|containing_scope
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_redundant_typedef
argument_list|(
name|decl
argument_list|)
condition|)
comment|/* Output a DIE to represent the typedef itself.  */
name|output_die
argument_list|(
name|output_typedef_die
argument_list|,
name|decl
argument_list|)
expr_stmt|;
break|break;
case|case
name|LABEL_DECL
case|:
if|if
condition|(
name|debug_info_level
operator|>=
name|DINFO_LEVEL_NORMAL
condition|)
name|output_die
argument_list|(
name|output_label_die
argument_list|,
name|decl
argument_list|)
expr_stmt|;
break|break;
case|case
name|VAR_DECL
case|:
comment|/* If we are conforming to the DWARF version 1 specification, don't 	 generated any DIEs to represent mere external object declarations.  */
if|#
directive|if
operator|(
name|DWARF_VERSION
operator|<=
literal|1
operator|)
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
break|break;
endif|#
directive|endif
comment|/* If we are in terse mode, don't generate any DIEs to represent 	 any variable declarations or definitions.  */
if|if
condition|(
name|debug_info_level
operator|<=
name|DINFO_LEVEL_TERSE
condition|)
break|break;
comment|/* Output any DIEs that are needed to specify the type of this data 	 object.  */
name|output_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|containing_scope
argument_list|)
expr_stmt|;
block|{
comment|/* And its containing type.  */
specifier|register
name|tree
name|origin
init|=
name|decl_class_context
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|origin
condition|)
name|output_type
argument_list|(
name|origin
argument_list|,
name|containing_scope
argument_list|)
expr_stmt|;
block|}
comment|/* If the following DIE will represent a data object definition for a 	 data object with "extern" linkage, output a special "pubnames" DIE 	 label just ahead of the actual DIE.  A reference to this label 	 was already generated in the .debug_pubnames section sub-entry 	 for this data object definition.  */
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_ABSTRACT
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|char
name|label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|label
argument_list|,
name|PUB_DIE_LABEL_FMT
argument_list|,
name|next_pubname_number
operator|++
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
comment|/* Now output the DIE to represent the data object itself.  This gets 	 complicated because of the possibility that the VAR_DECL really 	 represents an inlined instance of a formal parameter for an inline 	 function.  */
block|{
name|void
argument_list|(
argument|*func
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
expr_stmt|;
specifier|register
name|tree
name|origin
init|=
name|decl_ultimate_origin
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|origin
operator|!=
name|NULL
operator|&&
name|TREE_CODE
argument_list|(
name|origin
argument_list|)
operator|==
name|PARM_DECL
condition|)
name|func
operator|=
name|output_formal_parameter_die
expr_stmt|;
else|else
block|{
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
name|func
operator|=
name|output_global_variable_die
expr_stmt|;
else|else
name|func
operator|=
name|output_local_variable_die
expr_stmt|;
block|}
name|output_die
argument_list|(
name|func
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|FIELD_DECL
case|:
comment|/* Ignore the nameless fields that are used to skip bits.  */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|output_type
argument_list|(
name|member_declared_type
argument_list|(
name|decl
argument_list|)
argument_list|,
name|containing_scope
argument_list|)
expr_stmt|;
name|output_die
argument_list|(
name|output_member_die
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PARM_DECL
case|:
comment|/* Force out the type of this formal, if it was not forced out yet. 	Note that here we can run afoul of a bug in "classic" svr4 SDB. 	It should be able to grok the presence of type DIEs within a list 	of TAG_formal_parameter DIEs, but it doesn't.  */
name|output_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|containing_scope
argument_list|)
expr_stmt|;
name|output_die
argument_list|(
name|output_formal_parameter_die
argument_list|,
name|decl
argument_list|)
expr_stmt|;
break|break;
case|case
name|NAMESPACE_DECL
case|:
comment|/* Ignore for now.  */
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output debug information for a function.  */
end_comment

begin_function
specifier|static
name|void
name|dwarfout_function_decl
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|dwarfout_file_scope_decl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Debug information for a global DECL.  Called from toplev.c after    compilation proper has finished.  */
end_comment

begin_function
specifier|static
name|void
name|dwarfout_global_decl
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
comment|/* Output DWARF information for file-scope tentative data object      declarations, file-scope (extern) function declarations (which      had no corresponding body) and file-scope tagged type      declarations and definitions which have not yet been forced out.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|||
operator|!
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
condition|)
name|dwarfout_file_scope_decl
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* DECL is an inline function, whose body is present, but which is not    being output at this point.  (We're putting that off until we need    to do it.)  */
end_comment

begin_function
specifier|static
name|void
name|dwarfout_deferred_inline_function
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
comment|/* Generate the DWARF info for the "abstract" instance of a function      which we may later generate inlined and/or out-of-line instances      of.  */
if|if
condition|(
operator|(
name|DECL_INLINE
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_ABSTRACT
argument_list|(
name|decl
argument_list|)
operator|)
operator|&&
operator|!
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* The front-end may not have set CURRENT_FUNCTION_DECL, but the 	 DWARF code expects it to be set in this case.  Intuitively, 	 DECL is the function we just finished defining, so setting 	 CURRENT_FUNCTION_DECL is sensible.  */
name|tree
name|saved_cfd
init|=
name|current_function_decl
decl_stmt|;
name|int
name|was_abstract
init|=
name|DECL_ABSTRACT
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|current_function_decl
operator|=
name|decl
expr_stmt|;
comment|/* Let the DWARF code do its work.  */
name|set_decl_abstract_flags
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dwarfout_file_scope_decl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|was_abstract
condition|)
name|set_decl_abstract_flags
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Reset CURRENT_FUNCTION_DECL.  */
name|current_function_decl
operator|=
name|saved_cfd
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dwarfout_file_scope_decl
parameter_list|(
name|decl
parameter_list|,
name|set_finalizing
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|int
name|set_finalizing
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return;
comment|/* If this ..._DECL node is marked to be ignored, then ignore it.  */
if|if
condition|(
name|DECL_IGNORED_P
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
case|case
name|FUNCTION_DECL
case|:
comment|/* Ignore this FUNCTION_DECL if it refers to a builtin declaration of 	 a builtin function.  Explicit programmer-supplied declarations of 	 these same functions should NOT be ignored however.  */
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_FUNCTION_CODE
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
comment|/* What we would really like to do here is to filter out all mere 	 file-scope declarations of file-scope functions which are never 	 referenced later within this translation unit (and keep all of 	 ones that *are* referenced later on) but we aren't clairvoyant, 	 so we have no idea which functions will be referenced in the 	 future (i.e. later on within the current translation unit). 	 So here we just ignore all file-scope function declarations 	 which are not also definitions.  If and when the debugger needs 	 to know something about these functions, it will have to hunt 	 around and find the DWARF information associated with the 	 *definition* of the function.  	 Note that we can't just check `DECL_EXTERNAL' to find out which 	 FUNCTION_DECL nodes represent definitions and which ones represent 	 mere declarations.  We have to check `DECL_INITIAL' instead.  That's 	 because the C front-end supports some weird semantics for "extern 	 inline" function definitions.  These can get inlined within the 	 current translation unit (an thus, we need to generate DWARF info 	 for their abstract instances so that the DWARF info for the 	 concrete inlined instances can have something to refer to) but 	 the compiler never generates any out-of-lines instances of such 	 things (despite the fact that they *are* definitions).  The 	 important point is that the C front-end marks these "extern inline" 	 functions as DECL_EXTERNAL, but we need to generate DWARF for them 	 anyway.  	 Note that the C++ front-end also plays some similar games for inline 	 function definitions appearing within include files which also 	 contain `#pragma interface' pragmas.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return;
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_ABSTRACT
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|char
name|label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
comment|/* Output a .debug_pubnames entry for a public function 	     defined in this compilation unit.  */
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_PUSH_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|DEBUG_PUBNAMES_SECTION
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|label
argument_list|,
name|PUB_DIE_LABEL_FMT
argument_list|,
name|next_pubname_number
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_ADDR
argument_list|(
name|asm_out_file
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_STRING_NEWLINE
argument_list|(
name|asm_out_file
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_POP_SECTION
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|VAR_DECL
case|:
comment|/* Ignore this VAR_DECL if it refers to a file-scope extern data 	 object declaration and if the declaration was never even 	 referenced from within this entire compilation unit.  We 	 suppress these DIEs in order to save space in the .debug section 	 (by eliminating entries which are probably useless).  Note that 	 we must not suppress block-local extern declarations (whether 	 used or not) because that would screw-up the debugger's name 	 lookup mechanism and cause it to miss things which really ought 	 to be in scope at a given point.  */
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_USED
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|DECL_ABSTRACT
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|char
name|label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
if|if
condition|(
name|debug_info_level
operator|>=
name|DINFO_LEVEL_NORMAL
condition|)
block|{
comment|/* Output a .debug_pubnames entry for a public variable 	         defined in this compilation unit.  */
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_PUSH_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|DEBUG_PUBNAMES_SECTION
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|label
argument_list|,
name|PUB_DIE_LABEL_FMT
argument_list|,
name|next_pubname_number
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_ADDR
argument_list|(
name|asm_out_file
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_STRING_NEWLINE
argument_list|(
name|asm_out_file
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_POP_SECTION
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* Output a .debug_aranges entry for a public variable 		 which is tentatively defined in this compilation unit.  */
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_PUSH_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|DEBUG_ARANGES_SECTION
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_ADDR
argument_list|(
name|asm_out_file
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DATA4
argument_list|(
name|asm_out_file
argument_list|,
operator|(
name|unsigned
operator|)
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_POP_SECTION
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If we are in terse mode, don't generate any DIEs to represent 	 any variable declarations or definitions.  */
if|if
condition|(
name|debug_info_level
operator|<=
name|DINFO_LEVEL_TERSE
condition|)
return|return;
break|break;
case|case
name|TYPE_DECL
case|:
comment|/* Don't bother trying to generate any DIEs to represent any of the 	 normal built-in types for the language we are compiling, except 	 in cases where the types in question are *not* DWARF fundamental 	 types.  We make an exception in the case of non-fundamental types 	 for the sake of objective C (and perhaps C++) because the GNU 	 front-ends for these languages may in fact create certain "built-in" 	 types which are (for example) RECORD_TYPEs.  In such cases, we 	 really need to output these (non-fundamental) types because other 	 DIEs may contain references to them.  */
comment|/* Also ignore language dependent types here, because they are probably 	 also built-in types.  If we didn't ignore them, then we would get 	 references to undefined labels because output_type doesn't support 	 them.   So, for now, we need to ignore them to avoid assembler 	 errors.  */
comment|/* ??? This code is different than the equivalent code in dwarf2out.c. 	 The dwarf2out.c code is probably more correct.  */
if|if
condition|(
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|type_is_fundamental
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|LANG_TYPE
operator|)
condition|)
return|return;
comment|/* If we are in terse mode, don't generate any DIEs to represent 	 any actual typedefs.  Note that even when we are in terse mode, 	 we must still output DIEs to represent those tagged types which 	 are used (directly or indirectly) in the specification of either 	 a return type or a formal parameter type of some function.  */
if|if
condition|(
name|debug_info_level
operator|<=
name|DINFO_LEVEL_TERSE
condition|)
if|if
condition|(
operator|!
name|TYPE_DECL_IS_STUB
argument_list|(
name|decl
argument_list|)
operator|||
operator|!
name|TYPE_USED_FOR_FUNCTION
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
return|return;
break|break;
default|default:
return|return;
block|}
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_PUSH_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|DEBUG_SECTION
argument_list|)
expr_stmt|;
name|finalizing
operator|=
name|set_finalizing
expr_stmt|;
name|output_decl
argument_list|(
name|decl
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* NOTE:  The call above to `output_decl' may have caused one or more      file-scope named types (i.e. tagged types) to be placed onto the      pending_types_list.  We have to get those types off of that list      at some point, and this is the perfect time to do it.  If we didn't      take them off now, they might still be on the list when cc1 finally      exits.  That might be OK if it weren't for the fact that when we put      types onto the pending_types_list, we set the TREE_ASM_WRITTEN flag      for these types, and that causes them never to be output unless      `output_pending_types_for_scope' takes them off of the list and un-sets      their TREE_ASM_WRITTEN flags.  */
name|output_pending_types_for_scope
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* The above call should have totally emptied the pending_types_list      if this is not a nested function or class.  If this is a nested type,      then the remaining pending_types will be emitted when the containing type      is handled.  */
if|if
condition|(
operator|!
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|pending_types
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
name|ASM_OUTPUT_POP_SECTION
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output a marker (i.e. a label) for the beginning of the generated code    for a lexical block.	 */
end_comment

begin_function
specifier|static
name|void
name|dwarfout_begin_block
parameter_list|(
name|line
parameter_list|,
name|blocknum
parameter_list|)
name|unsigned
name|int
name|line
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|unsigned
name|int
name|blocknum
decl_stmt|;
block|{
name|char
name|label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|function_section
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|label
argument_list|,
name|BLOCK_BEGIN_LABEL_FMT
argument_list|,
name|blocknum
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output a marker (i.e. a label) for the end of the generated code    for a lexical block.	 */
end_comment

begin_function
specifier|static
name|void
name|dwarfout_end_block
parameter_list|(
name|line
parameter_list|,
name|blocknum
parameter_list|)
name|unsigned
name|int
name|line
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|unsigned
name|int
name|blocknum
decl_stmt|;
block|{
name|char
name|label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|function_section
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|label
argument_list|,
name|BLOCK_END_LABEL_FMT
argument_list|,
name|blocknum
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output a marker (i.e. a label) for the point in the generated code where    the real body of the function begins (after parameters have been moved    to their home locations).  */
end_comment

begin_function
specifier|static
name|void
name|dwarfout_end_prologue
parameter_list|(
name|line
parameter_list|,
name|file
parameter_list|)
name|unsigned
name|int
name|line
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
name|label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|use_gnu_debug_info_extensions
condition|)
return|return;
name|function_section
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|label
argument_list|,
name|BODY_BEGIN_LABEL_FMT
argument_list|,
name|current_function_funcdef_no
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output a marker (i.e. a label) for the point in the generated code where    the real body of the function ends (just before the epilogue code).  */
end_comment

begin_function
specifier|static
name|void
name|dwarfout_end_function
parameter_list|(
name|line
parameter_list|)
name|unsigned
name|int
name|line
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
name|label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|use_gnu_debug_info_extensions
condition|)
return|return;
name|function_section
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|label
argument_list|,
name|BODY_END_LABEL_FMT
argument_list|,
name|current_function_funcdef_no
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output a marker (i.e. a label) for the absolute end of the generated code    for a function definition.  This gets called *after* the epilogue code    has been generated.	*/
end_comment

begin_function
specifier|static
name|void
name|dwarfout_end_epilogue
parameter_list|(
name|line
parameter_list|,
name|file
parameter_list|)
name|unsigned
name|int
name|line
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
name|label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
comment|/* Output a label to mark the endpoint of the code generated for this      function.	*/
name|sprintf
argument_list|(
name|label
argument_list|,
name|FUNC_END_LABEL_FMT
argument_list|,
name|current_function_funcdef_no
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|shuffle_filename_entry
parameter_list|(
name|new_zeroth
parameter_list|)
name|filename_entry
modifier|*
name|new_zeroth
decl_stmt|;
block|{
name|filename_entry
name|temp_entry
decl_stmt|;
name|filename_entry
modifier|*
name|limit_p
decl_stmt|;
name|filename_entry
modifier|*
name|move_p
decl_stmt|;
if|if
condition|(
name|new_zeroth
operator|==
operator|&
name|filename_table
index|[
literal|0
index|]
condition|)
return|return;
name|temp_entry
operator|=
operator|*
name|new_zeroth
expr_stmt|;
comment|/* Shift entries up in the table to make room at [0].  */
name|limit_p
operator|=
operator|&
name|filename_table
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|move_p
operator|=
name|new_zeroth
init|;
name|move_p
operator|>
name|limit_p
condition|;
name|move_p
operator|--
control|)
operator|*
name|move_p
operator|=
operator|*
operator|(
name|move_p
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* Install the found entry at [0].  */
name|filename_table
index|[
literal|0
index|]
operator|=
name|temp_entry
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create a new (string) entry for the .debug_sfnames section.  */
end_comment

begin_function
specifier|static
name|void
name|generate_new_sfname_entry
parameter_list|()
block|{
name|char
name|label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_PUSH_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|DEBUG_SFNAMES_SECTION
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|label
argument_list|,
name|SFNAMES_ENTRY_LABEL_FMT
argument_list|,
name|filename_table
index|[
literal|0
index|]
operator|.
name|number
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_STRING_NEWLINE
argument_list|(
name|asm_out_file
argument_list|,
name|filename_table
index|[
literal|0
index|]
operator|.
name|name
condition|?
name|filename_table
index|[
literal|0
index|]
operator|.
name|name
else|:
literal|""
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_POP_SECTION
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Lookup a filename (in the list of filenames that we know about here in    dwarfout.c) and return its "index".  The index of each (known) filename    is just a unique number which is associated with only that one filename.    We need such numbers for the sake of generating labels (in the    .debug_sfnames section) and references to those unique labels (in the    .debug_srcinfo and .debug_macinfo sections).     If the filename given as an argument is not found in our current list,    add it to the list and assign it the next available unique index number.     Whatever we do (i.e. whether we find a pre-existing filename or add a new    one), we shuffle the filename found (or added) up to the zeroth entry of    our list of filenames (which is always searched linearly).  We do this so    as to optimize the most common case for these filename lookups within    dwarfout.c.  The most common case by far is the case where we call    lookup_filename to lookup the very same filename that we did a lookup    on the last time we called lookup_filename.  We make sure that this    common case is fast because such cases will constitute 99.9% of the    lookups we ever do (in practice).     If we add a new filename entry to our table, we go ahead and generate    the corresponding entry in the .debug_sfnames section right away.    Doing so allows us to avoid tickling an assembler bug (present in some    m68k assemblers) which yields assembly-time errors in cases where the    difference of two label addresses is taken and where the two labels    are in a section *other* than the one where the difference is being    calculated, and where at least one of the two symbol references is a    forward reference.  (This bug could be tickled by our .debug_srcinfo    entries if we don't output their corresponding .debug_sfnames entries    before them.) */
end_comment

begin_function
specifier|static
name|unsigned
name|lookup_filename
parameter_list|(
name|file_name
parameter_list|)
specifier|const
name|char
modifier|*
name|file_name
decl_stmt|;
block|{
name|filename_entry
modifier|*
name|search_p
decl_stmt|;
name|filename_entry
modifier|*
name|limit_p
init|=
operator|&
name|filename_table
index|[
name|ft_entries
index|]
decl_stmt|;
for|for
control|(
name|search_p
operator|=
name|filename_table
init|;
name|search_p
operator|<
name|limit_p
condition|;
name|search_p
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|file_name
argument_list|,
name|search_p
operator|->
name|name
argument_list|)
condition|)
block|{
comment|/* When we get here, we have found the filename that we were 	   looking for in the filename_table.  Now we want to make sure 	   that it gets moved to the zero'th entry in the table (if it 	   is not already there) so that subsequent attempts to find the 	   same filename will find it as quickly as possible.  */
name|shuffle_filename_entry
argument_list|(
name|search_p
argument_list|)
expr_stmt|;
return|return
name|filename_table
index|[
literal|0
index|]
operator|.
name|number
return|;
block|}
comment|/* We come here whenever we have a new filename which is not registered      in the current table.  Here we add it to the table.  */
comment|/* Prepare to add a new table entry by making sure there is enough space      in the table to do so.  If not, expand the current table.  */
if|if
condition|(
name|ft_entries
operator|==
name|ft_entries_allocated
condition|)
block|{
name|ft_entries_allocated
operator|+=
name|FT_ENTRIES_INCREMENT
expr_stmt|;
name|filename_table
operator|=
operator|(
name|filename_entry
operator|*
operator|)
name|xrealloc
argument_list|(
name|filename_table
argument_list|,
name|ft_entries_allocated
operator|*
sizeof|sizeof
argument_list|(
name|filename_entry
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Initially, add the new entry at the end of the filename table.  */
name|filename_table
index|[
name|ft_entries
index|]
operator|.
name|number
operator|=
name|ft_entries
expr_stmt|;
name|filename_table
index|[
name|ft_entries
index|]
operator|.
name|name
operator|=
name|xstrdup
argument_list|(
name|file_name
argument_list|)
expr_stmt|;
comment|/* Shuffle the new entry into filename_table[0].  */
name|shuffle_filename_entry
argument_list|(
operator|&
name|filename_table
index|[
name|ft_entries
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_info_level
operator|>=
name|DINFO_LEVEL_NORMAL
condition|)
name|generate_new_sfname_entry
argument_list|()
expr_stmt|;
name|ft_entries
operator|++
expr_stmt|;
return|return
name|filename_table
index|[
literal|0
index|]
operator|.
name|number
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|generate_srcinfo_entry
parameter_list|(
name|line_entry_num
parameter_list|,
name|files_entry_num
parameter_list|)
name|unsigned
name|line_entry_num
decl_stmt|;
name|unsigned
name|files_entry_num
decl_stmt|;
block|{
name|char
name|label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_PUSH_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|DEBUG_SRCINFO_SECTION
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|label
argument_list|,
name|LINE_ENTRY_LABEL_FMT
argument_list|,
name|line_entry_num
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DELTA4
argument_list|(
name|asm_out_file
argument_list|,
name|label
argument_list|,
name|LINE_BEGIN_LABEL
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|label
argument_list|,
name|SFNAMES_ENTRY_LABEL_FMT
argument_list|,
name|files_entry_num
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DELTA4
argument_list|(
name|asm_out_file
argument_list|,
name|label
argument_list|,
name|SFNAMES_BEGIN_LABEL
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_POP_SECTION
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dwarfout_source_line
parameter_list|(
name|line
parameter_list|,
name|filename
parameter_list|)
name|unsigned
name|int
name|line
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
block|{
if|if
condition|(
name|debug_info_level
operator|>=
name|DINFO_LEVEL_NORMAL
comment|/* We can't emit line number info for functions in separate sections, 	 because the assembler can't subtract labels in different sections.  */
operator|&&
name|DECL_SECTION_NAME
argument_list|(
name|current_function_decl
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|char
name|label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
specifier|static
name|unsigned
name|last_line_entry_num
init|=
literal|0
decl_stmt|;
specifier|static
name|unsigned
name|prev_file_entry_num
init|=
operator|(
name|unsigned
operator|)
operator|-
literal|1
decl_stmt|;
name|unsigned
name|this_file_entry_num
decl_stmt|;
name|function_section
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|label
argument_list|,
name|LINE_CODE_LABEL_FMT
argument_list|,
operator|++
name|last_line_entry_num
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_gnu_debug_info_extensions
condition|)
name|this_file_entry_num
operator|=
name|lookup_filename
argument_list|(
name|filename
argument_list|)
expr_stmt|;
else|else
name|this_file_entry_num
operator|=
operator|(
name|unsigned
operator|)
operator|-
literal|1
expr_stmt|;
name|ASM_OUTPUT_PUSH_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|LINE_SECTION
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_file_entry_num
operator|!=
name|prev_file_entry_num
condition|)
block|{
name|char
name|line_entry_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|line_entry_label
argument_list|,
name|LINE_ENTRY_LABEL_FMT
argument_list|,
name|last_line_entry_num
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|line_entry_label
argument_list|)
expr_stmt|;
block|}
block|{
specifier|const
name|char
modifier|*
name|tail
init|=
name|strrchr
argument_list|(
name|filename
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
if|if
condition|(
name|tail
operator|!=
name|NULL
condition|)
name|filename
operator|=
name|tail
expr_stmt|;
block|}
name|dw2_asm_output_data
argument_list|(
literal|4
argument_list|,
name|line
argument_list|,
literal|"%s:%u"
argument_list|,
name|filename
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DATA2
argument_list|(
name|asm_out_file
argument_list|,
literal|0xffff
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DELTA4
argument_list|(
name|asm_out_file
argument_list|,
name|label
argument_list|,
name|TEXT_BEGIN_LABEL
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_POP_SECTION
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_file_entry_num
operator|!=
name|prev_file_entry_num
condition|)
name|generate_srcinfo_entry
argument_list|(
name|last_line_entry_num
argument_list|,
name|this_file_entry_num
argument_list|)
expr_stmt|;
name|prev_file_entry_num
operator|=
name|this_file_entry_num
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate an entry in the .debug_macinfo section.  */
end_comment

begin_function
specifier|static
name|void
name|generate_macinfo_entry
parameter_list|(
name|type
parameter_list|,
name|offset
parameter_list|,
name|string
parameter_list|)
name|unsigned
name|int
name|type
decl_stmt|;
name|rtx
name|offset
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|use_gnu_debug_info_extensions
condition|)
return|return;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_PUSH_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|DEBUG_MACINFO_SECTION
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|gen_rtx_PLUS
argument_list|(
name|SImode
argument_list|,
name|GEN_INT
argument_list|(
name|type
operator|<<
literal|24
argument_list|)
argument_list|,
name|offset
argument_list|)
argument_list|,
literal|4
argument_list|,
name|BITS_PER_UNIT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_STRING_NEWLINE
argument_list|(
name|asm_out_file
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_POP_SECTION
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Wrapper for toplev.c callback to check debug info level.  */
end_comment

begin_function
specifier|static
name|void
name|dwarfout_start_source_file_check
parameter_list|(
name|line
parameter_list|,
name|filename
parameter_list|)
name|unsigned
name|int
name|line
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
block|{
if|if
condition|(
name|debug_info_level
operator|==
name|DINFO_LEVEL_VERBOSE
condition|)
name|dwarfout_start_source_file
argument_list|(
name|line
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dwarfout_start_source_file
parameter_list|(
name|line
parameter_list|,
name|filename
parameter_list|)
name|unsigned
name|int
name|line
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|char
name|label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|label1
decl_stmt|,
modifier|*
name|label2
decl_stmt|;
name|sprintf
argument_list|(
name|label
argument_list|,
name|SFNAMES_ENTRY_LABEL_FMT
argument_list|,
name|lookup_filename
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
name|label1
operator|=
operator|(
operator|*
name|label
operator|==
literal|'*'
operator|)
operator|+
name|label
expr_stmt|;
name|label2
operator|=
operator|(
operator|*
name|SFNAMES_BEGIN_LABEL
operator|==
literal|'*'
operator|)
operator|+
name|SFNAMES_BEGIN_LABEL
expr_stmt|;
name|generate_macinfo_entry
argument_list|(
name|MACINFO_start
argument_list|,
name|gen_rtx_MINUS
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|label1
argument_list|)
argument_list|,
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|label2
argument_list|)
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Wrapper for toplev.c callback to check debug info level.  */
end_comment

begin_function
specifier|static
name|void
name|dwarfout_end_source_file_check
parameter_list|(
name|lineno
parameter_list|)
name|unsigned
name|lineno
decl_stmt|;
block|{
if|if
condition|(
name|debug_info_level
operator|==
name|DINFO_LEVEL_VERBOSE
condition|)
name|dwarfout_end_source_file
argument_list|(
name|lineno
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dwarfout_end_source_file
parameter_list|(
name|lineno
parameter_list|)
name|unsigned
name|lineno
decl_stmt|;
block|{
name|generate_macinfo_entry
argument_list|(
name|MACINFO_resume
argument_list|,
name|GEN_INT
argument_list|(
name|lineno
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called from check_newline in c-parse.y.  The `buffer' parameter    contains the tail part of the directive line, i.e. the part which    is past the initial whitespace, #, whitespace, directive-name,    whitespace part.  */
end_comment

begin_function
specifier|static
name|void
name|dwarfout_define
parameter_list|(
name|lineno
parameter_list|,
name|buffer
parameter_list|)
name|unsigned
name|lineno
decl_stmt|;
specifier|const
name|char
modifier|*
name|buffer
decl_stmt|;
block|{
specifier|static
name|int
name|initialized
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|dwarfout_start_source_file
argument_list|(
literal|0
argument_list|,
name|primary_filename
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|1
expr_stmt|;
block|}
name|generate_macinfo_entry
argument_list|(
name|MACINFO_define
argument_list|,
name|GEN_INT
argument_list|(
name|lineno
argument_list|)
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called from check_newline in c-parse.y.  The `buffer' parameter    contains the tail part of the directive line, i.e. the part which    is past the initial whitespace, #, whitespace, directive-name,    whitespace part.  */
end_comment

begin_function
specifier|static
name|void
name|dwarfout_undef
parameter_list|(
name|lineno
parameter_list|,
name|buffer
parameter_list|)
name|unsigned
name|lineno
decl_stmt|;
specifier|const
name|char
modifier|*
name|buffer
decl_stmt|;
block|{
name|generate_macinfo_entry
argument_list|(
name|MACINFO_undef
argument_list|,
name|GEN_INT
argument_list|(
name|lineno
argument_list|)
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set up for Dwarf output at the start of compilation.	 */
end_comment

begin_function
specifier|static
name|void
name|dwarfout_init
parameter_list|(
name|main_input_filename
parameter_list|)
specifier|const
name|char
modifier|*
name|main_input_filename
decl_stmt|;
block|{
name|warning
argument_list|(
literal|"support for the DWARF1 debugging format is deprecated"
argument_list|)
expr_stmt|;
comment|/* Remember the name of the primary input file.  */
name|primary_filename
operator|=
name|main_input_filename
expr_stmt|;
comment|/* Allocate the initial hunk of the pending_sibling_stack.  */
name|pending_sibling_stack
operator|=
operator|(
name|unsigned
operator|*
operator|)
name|xmalloc
argument_list|(
name|PENDING_SIBLINGS_INCREMENT
operator|*
sizeof|sizeof
argument_list|(
name|unsigned
argument_list|)
argument_list|)
expr_stmt|;
name|pending_siblings_allocated
operator|=
name|PENDING_SIBLINGS_INCREMENT
expr_stmt|;
name|pending_siblings
operator|=
literal|1
expr_stmt|;
comment|/* Allocate the initial hunk of the filename_table.  */
name|filename_table
operator|=
operator|(
name|filename_entry
operator|*
operator|)
name|xmalloc
argument_list|(
name|FT_ENTRIES_INCREMENT
operator|*
sizeof|sizeof
argument_list|(
name|filename_entry
argument_list|)
argument_list|)
expr_stmt|;
name|ft_entries_allocated
operator|=
name|FT_ENTRIES_INCREMENT
expr_stmt|;
name|ft_entries
operator|=
literal|0
expr_stmt|;
comment|/* Allocate the initial hunk of the pending_types_list.  */
name|pending_types_list
operator|=
operator|(
name|tree
operator|*
operator|)
name|xmalloc
argument_list|(
name|PENDING_TYPES_INCREMENT
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
name|pending_types_allocated
operator|=
name|PENDING_TYPES_INCREMENT
expr_stmt|;
name|pending_types
operator|=
literal|0
expr_stmt|;
comment|/* Create an artificial RECORD_TYPE node which we can use in our hack      to get the DIEs representing types of formal parameters to come out      only *after* the DIEs for the formal parameters themselves.  */
name|fake_containing_scope
operator|=
name|make_node
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
comment|/* Output a starting label for the .text section.  */
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_PUSH_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|TEXT_SECTION_NAME
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|TEXT_BEGIN_LABEL
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_POP_SECTION
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
comment|/* Output a starting label for the .data section.  */
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_PUSH_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|DATA_SECTION_NAME
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|DATA_BEGIN_LABEL
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_POP_SECTION
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* GNU C doesn't currently use .data1.  */
comment|/* Output a starting label for the .data1 section.  */
block|fputc ('\n', asm_out_file);   ASM_OUTPUT_PUSH_SECTION (asm_out_file, DATA1_SECTION_NAME);   ASM_OUTPUT_LABEL (asm_out_file, DATA1_BEGIN_LABEL);   ASM_OUTPUT_POP_SECTION (asm_out_file);
endif|#
directive|endif
comment|/* Output a starting label for the .rodata section.  */
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_PUSH_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|RODATA_SECTION_NAME
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|RODATA_BEGIN_LABEL
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_POP_SECTION
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* GNU C doesn't currently use .rodata1.  */
comment|/* Output a starting label for the .rodata1 section.  */
block|fputc ('\n', asm_out_file);   ASM_OUTPUT_PUSH_SECTION (asm_out_file, RODATA1_SECTION_NAME);   ASM_OUTPUT_LABEL (asm_out_file, RODATA1_BEGIN_LABEL);   ASM_OUTPUT_POP_SECTION (asm_out_file);
endif|#
directive|endif
comment|/* Output a starting label for the .bss section.  */
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_PUSH_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|BSS_SECTION_NAME
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|BSS_BEGIN_LABEL
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_POP_SECTION
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_info_level
operator|>=
name|DINFO_LEVEL_NORMAL
condition|)
block|{
if|if
condition|(
name|use_gnu_debug_info_extensions
condition|)
block|{
comment|/* Output a starting label and an initial (compilation directory) 	     entry for the .debug_sfnames section.  The starting label will be 	     referenced by the initial entry in the .debug_srcinfo section.  */
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_PUSH_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|DEBUG_SFNAMES_SECTION
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|SFNAMES_BEGIN_LABEL
argument_list|)
expr_stmt|;
block|{
specifier|const
name|char
modifier|*
name|pwd
init|=
name|getpwd
argument_list|()
decl_stmt|;
name|char
modifier|*
name|dirname
decl_stmt|;
if|if
condition|(
operator|!
name|pwd
condition|)
name|fatal_io_error
argument_list|(
literal|"can't get current directory"
argument_list|)
expr_stmt|;
name|dirname
operator|=
name|concat
argument_list|(
name|pwd
argument_list|,
literal|"/"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_STRING_NEWLINE
argument_list|(
name|asm_out_file
argument_list|,
name|dirname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dirname
argument_list|)
expr_stmt|;
block|}
name|ASM_OUTPUT_POP_SECTION
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|debug_info_level
operator|>=
name|DINFO_LEVEL_VERBOSE
operator|&&
name|use_gnu_debug_info_extensions
condition|)
block|{
comment|/* Output a starting label for the .debug_macinfo section.  This 	     label will be referenced by the AT_mac_info attribute in the 	     TAG_compile_unit DIE.  */
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_PUSH_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|DEBUG_MACINFO_SECTION
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|MACINFO_BEGIN_LABEL
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_POP_SECTION
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
comment|/* Generate the initial entry for the .line section.  */
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_PUSH_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|LINE_SECTION
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|LINE_BEGIN_LABEL
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DELTA4
argument_list|(
name|asm_out_file
argument_list|,
name|LINE_END_LABEL
argument_list|,
name|LINE_BEGIN_LABEL
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_ADDR
argument_list|(
name|asm_out_file
argument_list|,
name|TEXT_BEGIN_LABEL
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_POP_SECTION
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_gnu_debug_info_extensions
condition|)
block|{
comment|/* Generate the initial entry for the .debug_srcinfo section.  */
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_PUSH_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|DEBUG_SRCINFO_SECTION
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|SRCINFO_BEGIN_LABEL
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_ADDR
argument_list|(
name|asm_out_file
argument_list|,
name|LINE_BEGIN_LABEL
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_ADDR
argument_list|(
name|asm_out_file
argument_list|,
name|SFNAMES_BEGIN_LABEL
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_ADDR
argument_list|(
name|asm_out_file
argument_list|,
name|TEXT_BEGIN_LABEL
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_ADDR
argument_list|(
name|asm_out_file
argument_list|,
name|TEXT_END_LABEL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DWARF_TIMESTAMPS
name|ASM_OUTPUT_DWARF_DATA4
argument_list|(
name|asm_out_file
argument_list|,
name|time
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|ASM_OUTPUT_DWARF_DATA4
argument_list|(
name|asm_out_file
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ASM_OUTPUT_POP_SECTION
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
comment|/* Generate the initial entry for the .debug_pubnames section.  */
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_PUSH_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|DEBUG_PUBNAMES_SECTION
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_ADDR
argument_list|(
name|asm_out_file
argument_list|,
name|DEBUG_BEGIN_LABEL
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_POP_SECTION
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
comment|/* Generate the initial entry for the .debug_aranges section.  */
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_PUSH_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|DEBUG_ARANGES_SECTION
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DELTA4
argument_list|(
name|asm_out_file
argument_list|,
name|DEBUG_ARANGES_END_LABEL
argument_list|,
name|DEBUG_ARANGES_BEGIN_LABEL
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|DEBUG_ARANGES_BEGIN_LABEL
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DATA1
argument_list|(
name|asm_out_file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_ADDR
argument_list|(
name|asm_out_file
argument_list|,
name|DEBUG_BEGIN_LABEL
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_POP_SECTION
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
comment|/* Setup first DIE number == 1.  */
name|NEXT_DIE_NUM
operator|=
name|next_unused_dienum
operator|++
expr_stmt|;
comment|/* Generate the initial DIE for the .debug section.  Note that the      (string) value given in the AT_name attribute of the TAG_compile_unit      DIE will (typically) be a relative pathname and that this pathname      should be taken as being relative to the directory from which the      compiler was invoked when the given (base) source file was compiled.  */
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_PUSH_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|DEBUG_SECTION
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|DEBUG_BEGIN_LABEL
argument_list|)
expr_stmt|;
name|output_die
argument_list|(
name|output_compile_unit_die
argument_list|,
operator|(
name|PTR
operator|)
name|main_input_filename
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_POP_SECTION
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output stuff that dwarf requires at the end of every file.  */
end_comment

begin_function
specifier|static
name|void
name|dwarfout_finish
parameter_list|(
name|main_input_filename
parameter_list|)
specifier|const
name|char
modifier|*
name|main_input_filename
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
name|label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_PUSH_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|DEBUG_SECTION
argument_list|)
expr_stmt|;
name|retry_incomplete_types
argument_list|()
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
comment|/* Mark the end of the chain of siblings which represent all file-scope      declarations in this compilation unit.  */
comment|/* The (null) DIE which represents the terminator for the (sibling linked)      list of file-scope items is *special*.  Normally, we would just call      end_sibling_chain at this point in order to output a word with the      value `4' and that word would act as the terminator for the list of      DIEs describing file-scope items.  Unfortunately, if we were to simply      do that, the label that would follow this DIE in the .debug section      (i.e. `..D2') would *not* be properly aligned (as it must be on some      machines) to a 4 byte boundary.       In order to force the label `..D2' to get aligned to a 4 byte boundary,      the trick used is to insert extra (otherwise useless) padding bytes      into the (null) DIE that we know must precede the ..D2 label in the      .debug section.  The amount of padding required can be anywhere between      0 and 3 bytes.  The length word at the start of this DIE (i.e. the one      with the padding) would normally contain the value 4, but now it will      also have to include the padding bytes, so it will instead have some      value in the range 4..7.       Fortunately, the rules of Dwarf say that any DIE whose length word      contains *any* value less than 8 should be treated as a null DIE, so      this trick works out nicely.  Clever, eh?  Don't give me any credit      (or blame).  I didn't think of this scheme.  I just conformed to it.   */
name|output_die
argument_list|(
name|output_padded_null_die
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|dienum_pop
argument_list|()
expr_stmt|;
name|sprintf
argument_list|(
name|label
argument_list|,
name|DIE_BEGIN_LABEL_FMT
argument_list|,
name|NEXT_DIE_NUM
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|label
argument_list|)
expr_stmt|;
comment|/* should be ..D2 */
name|ASM_OUTPUT_POP_SECTION
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
comment|/* Output a terminator label for the .text section.  */
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_PUSH_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|TEXT_SECTION_NAME
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|TEXT_END_LABEL
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_POP_SECTION
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
comment|/* Output a terminator label for the .data section.  */
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_PUSH_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|DATA_SECTION_NAME
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|DATA_END_LABEL
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_POP_SECTION
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* GNU C doesn't currently use .data1.  */
comment|/* Output a terminator label for the .data1 section.  */
block|fputc ('\n', asm_out_file);   ASM_OUTPUT_PUSH_SECTION (asm_out_file, DATA1_SECTION_NAME);   ASM_OUTPUT_LABEL (asm_out_file, DATA1_END_LABEL);   ASM_OUTPUT_POP_SECTION (asm_out_file);
endif|#
directive|endif
comment|/* Output a terminator label for the .rodata section.  */
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_PUSH_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|RODATA_SECTION_NAME
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|RODATA_END_LABEL
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_POP_SECTION
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* GNU C doesn't currently use .rodata1.  */
comment|/* Output a terminator label for the .rodata1 section.  */
block|fputc ('\n', asm_out_file);   ASM_OUTPUT_PUSH_SECTION (asm_out_file, RODATA1_SECTION_NAME);   ASM_OUTPUT_LABEL (asm_out_file, RODATA1_END_LABEL);   ASM_OUTPUT_POP_SECTION (asm_out_file);
endif|#
directive|endif
comment|/* Output a terminator label for the .bss section.  */
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_PUSH_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|BSS_SECTION_NAME
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|BSS_END_LABEL
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_POP_SECTION
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_info_level
operator|>=
name|DINFO_LEVEL_NORMAL
condition|)
block|{
comment|/* Output a terminating entry for the .line section.  */
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_PUSH_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|LINE_SECTION
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|LINE_LAST_ENTRY_LABEL
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DATA4
argument_list|(
name|asm_out_file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DATA2
argument_list|(
name|asm_out_file
argument_list|,
literal|0xffff
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DELTA4
argument_list|(
name|asm_out_file
argument_list|,
name|TEXT_END_LABEL
argument_list|,
name|TEXT_BEGIN_LABEL
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|LINE_END_LABEL
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_POP_SECTION
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_gnu_debug_info_extensions
condition|)
block|{
comment|/* Output a terminating entry for the .debug_srcinfo section.  */
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_PUSH_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|DEBUG_SRCINFO_SECTION
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DELTA4
argument_list|(
name|asm_out_file
argument_list|,
name|LINE_LAST_ENTRY_LABEL
argument_list|,
name|LINE_BEGIN_LABEL
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DATA4
argument_list|(
name|asm_out_file
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_POP_SECTION
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|debug_info_level
operator|>=
name|DINFO_LEVEL_VERBOSE
condition|)
block|{
comment|/* Output terminating entries for the .debug_macinfo section.  */
name|dwarfout_end_source_file
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_PUSH_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|DEBUG_MACINFO_SECTION
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DATA4
argument_list|(
name|asm_out_file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_STRING_NEWLINE
argument_list|(
name|asm_out_file
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_POP_SECTION
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
comment|/* Generate the terminating entry for the .debug_pubnames section.  */
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_PUSH_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|DEBUG_PUBNAMES_SECTION
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DATA4
argument_list|(
name|asm_out_file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_STRING_NEWLINE
argument_list|(
name|asm_out_file
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_POP_SECTION
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
comment|/* Generate the terminating entries for the .debug_aranges section.  	 Note that we want to do this only *after* we have output the end 	 labels (for the various program sections) which we are going to 	 refer to here.  This allows us to work around a bug in the m68k 	 svr4 assembler.  That assembler gives bogus assembly-time errors 	 if (within any given section) you try to take the difference of 	 two relocatable symbols, both of which are located within some 	 other section, and if one (or both?) of the symbols involved is 	 being forward-referenced.  By generating the .debug_aranges 	 entries at this late point in the assembly output, we skirt the 	 issue simply by avoiding forward-references.       */
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_PUSH_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|DEBUG_ARANGES_SECTION
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_ADDR
argument_list|(
name|asm_out_file
argument_list|,
name|TEXT_BEGIN_LABEL
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DELTA4
argument_list|(
name|asm_out_file
argument_list|,
name|TEXT_END_LABEL
argument_list|,
name|TEXT_BEGIN_LABEL
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_ADDR
argument_list|(
name|asm_out_file
argument_list|,
name|DATA_BEGIN_LABEL
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DELTA4
argument_list|(
name|asm_out_file
argument_list|,
name|DATA_END_LABEL
argument_list|,
name|DATA_BEGIN_LABEL
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* GNU C doesn't currently use .data1.  */
block|ASM_OUTPUT_DWARF_ADDR (asm_out_file, DATA1_BEGIN_LABEL);       ASM_OUTPUT_DWARF_DELTA4 (asm_out_file, DATA1_END_LABEL, 					     DATA1_BEGIN_LABEL);
endif|#
directive|endif
name|ASM_OUTPUT_DWARF_ADDR
argument_list|(
name|asm_out_file
argument_list|,
name|RODATA_BEGIN_LABEL
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DELTA4
argument_list|(
name|asm_out_file
argument_list|,
name|RODATA_END_LABEL
argument_list|,
name|RODATA_BEGIN_LABEL
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* GNU C doesn't currently use .rodata1.  */
block|ASM_OUTPUT_DWARF_ADDR (asm_out_file, RODATA1_BEGIN_LABEL);       ASM_OUTPUT_DWARF_DELTA4 (asm_out_file, RODATA1_END_LABEL, 					     RODATA1_BEGIN_LABEL);
endif|#
directive|endif
name|ASM_OUTPUT_DWARF_ADDR
argument_list|(
name|asm_out_file
argument_list|,
name|BSS_BEGIN_LABEL
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DELTA4
argument_list|(
name|asm_out_file
argument_list|,
name|BSS_END_LABEL
argument_list|,
name|BSS_BEGIN_LABEL
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DATA4
argument_list|(
name|asm_out_file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DATA4
argument_list|(
name|asm_out_file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|DEBUG_ARANGES_END_LABEL
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_POP_SECTION
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
comment|/* There should not be any pending types left at the end.  We need      this now because it may not have been checked on the last call to      dwarfout_file_scope_decl.  */
if|if
condition|(
name|pending_types
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DWARF_DEBUGGING_INFO */
end_comment

end_unit

