begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Natural loop discovery code for GNU compiler.    Copyright (C) 2000, 2001 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_decl_stmt
specifier|static
name|void
name|flow_loops_cfg_dump
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|loops
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|flow_loop_nested_p
name|PARAMS
argument_list|(
operator|(
expr|struct
name|loop
operator|*
operator|,
expr|struct
name|loop
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|flow_loop_entry_edges_find
name|PARAMS
argument_list|(
operator|(
name|basic_block
operator|,
specifier|const
name|sbitmap
operator|,
name|edge
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|flow_loop_exit_edges_find
name|PARAMS
argument_list|(
operator|(
specifier|const
name|sbitmap
operator|,
name|edge
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|flow_loop_nodes_find
name|PARAMS
argument_list|(
operator|(
name|basic_block
operator|,
name|basic_block
operator|,
name|sbitmap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|flow_loop_pre_header_scan
name|PARAMS
argument_list|(
operator|(
expr|struct
name|loop
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|basic_block
name|flow_loop_pre_header_find
name|PARAMS
argument_list|(
operator|(
name|basic_block
operator|,
specifier|const
name|sbitmap
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|flow_loop_tree_node_add
name|PARAMS
argument_list|(
operator|(
expr|struct
name|loop
operator|*
operator|,
expr|struct
name|loop
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|flow_loops_tree_build
name|PARAMS
argument_list|(
operator|(
expr|struct
name|loops
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|flow_loop_level_compute
name|PARAMS
argument_list|(
operator|(
expr|struct
name|loop
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|flow_loops_level_compute
name|PARAMS
argument_list|(
operator|(
expr|struct
name|loops
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Dump loop related CFG information.  */
end_comment

begin_function
specifier|static
name|void
name|flow_loops_cfg_dump
parameter_list|(
name|loops
parameter_list|,
name|file
parameter_list|)
specifier|const
name|struct
name|loops
modifier|*
name|loops
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|loops
operator|->
name|num
operator|||
operator|!
name|file
operator|||
operator|!
name|loops
operator|->
name|cfg
operator|.
name|dom
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
block|{
name|edge
name|succ
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";; %d succs { "
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|succ
operator|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
operator|->
name|succ
init|;
name|succ
condition|;
name|succ
operator|=
name|succ
operator|->
name|succ_next
control|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d "
argument_list|,
name|succ
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
name|flow_nodes_print
argument_list|(
literal|"} dom"
argument_list|,
name|loops
operator|->
name|cfg
operator|.
name|dom
index|[
name|i
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
comment|/* Dump the DFS node order.  */
if|if
condition|(
name|loops
operator|->
name|cfg
operator|.
name|dfs_order
condition|)
block|{
name|fputs
argument_list|(
literal|";; DFS order: "
argument_list|,
name|file
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d "
argument_list|,
name|loops
operator|->
name|cfg
operator|.
name|dfs_order
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
comment|/* Dump the reverse completion node order.  */
if|if
condition|(
name|loops
operator|->
name|cfg
operator|.
name|rc_order
condition|)
block|{
name|fputs
argument_list|(
literal|";; RC order: "
argument_list|,
name|file
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d "
argument_list|,
name|loops
operator|->
name|cfg
operator|.
name|rc_order
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return non-zero if the nodes of LOOP are a subset of OUTER.  */
end_comment

begin_function
specifier|static
name|int
name|flow_loop_nested_p
parameter_list|(
name|outer
parameter_list|,
name|loop
parameter_list|)
name|struct
name|loop
modifier|*
name|outer
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
block|{
return|return
name|sbitmap_a_subset_b_p
argument_list|(
name|loop
operator|->
name|nodes
argument_list|,
name|outer
operator|->
name|nodes
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Dump the loop information specified by LOOP to the stream FILE    using auxiliary dump callback function LOOP_DUMP_AUX if non null.  */
end_comment

begin_function_decl
name|void
name|flow_loop_dump
parameter_list|(
name|loop
parameter_list|,
name|file
parameter_list|,
name|loop_dump_aux
parameter_list|,
name|verbose
parameter_list|)
specifier|const
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
function_decl|void
parameter_list|(
function_decl|*loop_dump_aux
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|loop
operator|*
operator|,
name|FILE
operator|*
operator|,
name|int
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|verbose
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|loop
operator|||
operator|!
name|loop
operator|->
name|header
condition|)
return|return;
if|if
condition|(
name|loop
operator|->
name|first
operator|->
name|head
operator|&&
name|loop
operator|->
name|last
operator|->
name|end
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";;\n;; Loop %d (%d to %d):%s%s\n"
argument_list|,
name|loop
operator|->
name|num
argument_list|,
name|INSN_UID
argument_list|(
name|loop
operator|->
name|first
operator|->
name|head
argument_list|)
argument_list|,
name|INSN_UID
argument_list|(
name|loop
operator|->
name|last
operator|->
name|end
argument_list|)
argument_list|,
name|loop
operator|->
name|shared
condition|?
literal|" shared"
else|:
literal|""
argument_list|,
name|loop
operator|->
name|invalid
condition|?
literal|" invalid"
else|:
literal|""
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";;\n;; Loop %d:%s%s\n"
argument_list|,
name|loop
operator|->
name|num
argument_list|,
name|loop
operator|->
name|shared
condition|?
literal|" shared"
else|:
literal|""
argument_list|,
name|loop
operator|->
name|invalid
condition|?
literal|" invalid"
else|:
literal|""
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";;  header %d, latch %d, pre-header %d, first %d, last %d\n"
argument_list|,
name|loop
operator|->
name|header
operator|->
name|index
argument_list|,
name|loop
operator|->
name|latch
operator|->
name|index
argument_list|,
name|loop
operator|->
name|pre_header
condition|?
name|loop
operator|->
name|pre_header
operator|->
name|index
else|:
operator|-
literal|1
argument_list|,
name|loop
operator|->
name|first
operator|->
name|index
argument_list|,
name|loop
operator|->
name|last
operator|->
name|index
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";;  depth %d, level %d, outer %ld\n"
argument_list|,
name|loop
operator|->
name|depth
argument_list|,
name|loop
operator|->
name|level
argument_list|,
call|(
name|long
call|)
argument_list|(
name|loop
operator|->
name|outer
condition|?
name|loop
operator|->
name|outer
operator|->
name|num
else|:
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop
operator|->
name|pre_header_edges
condition|)
name|flow_edge_list_print
argument_list|(
literal|";;  pre-header edges"
argument_list|,
name|loop
operator|->
name|pre_header_edges
argument_list|,
name|loop
operator|->
name|num_pre_header_edges
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|flow_edge_list_print
argument_list|(
literal|";;  entry edges"
argument_list|,
name|loop
operator|->
name|entry_edges
argument_list|,
name|loop
operator|->
name|num_entries
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";;  %d"
argument_list|,
name|loop
operator|->
name|num_nodes
argument_list|)
expr_stmt|;
name|flow_nodes_print
argument_list|(
literal|" nodes"
argument_list|,
name|loop
operator|->
name|nodes
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|flow_edge_list_print
argument_list|(
literal|";;  exit edges"
argument_list|,
name|loop
operator|->
name|exit_edges
argument_list|,
name|loop
operator|->
name|num_exits
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop
operator|->
name|exits_doms
condition|)
name|flow_nodes_print
argument_list|(
literal|";;  exit doms"
argument_list|,
name|loop
operator|->
name|exits_doms
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop_dump_aux
condition|)
name|loop_dump_aux
argument_list|(
name|loop
argument_list|,
name|file
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Dump the loop information specified by LOOPS to the stream FILE,    using auxiliary dump callback function LOOP_DUMP_AUX if non null.  */
end_comment

begin_function_decl
name|void
name|flow_loops_dump
parameter_list|(
name|loops
parameter_list|,
name|file
parameter_list|,
name|loop_dump_aux
parameter_list|,
name|verbose
parameter_list|)
specifier|const
name|struct
name|loops
modifier|*
name|loops
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
function_decl|void
parameter_list|(
function_decl|*loop_dump_aux
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|loop
operator|*
operator|,
name|FILE
operator|*
operator|,
name|int
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|verbose
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|num_loops
decl_stmt|;
name|num_loops
operator|=
name|loops
operator|->
name|num
expr_stmt|;
if|if
condition|(
operator|!
name|num_loops
operator|||
operator|!
name|file
condition|)
return|return;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";; %d loops found, %d levels\n"
argument_list|,
name|num_loops
argument_list|,
name|loops
operator|->
name|levels
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_loops
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|loop
modifier|*
name|loop
init|=
operator|&
name|loops
operator|->
name|array
index|[
name|i
index|]
decl_stmt|;
name|flow_loop_dump
argument_list|(
name|loop
argument_list|,
name|file
argument_list|,
name|loop_dump_aux
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop
operator|->
name|shared
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
name|struct
name|loop
modifier|*
name|oloop
init|=
operator|&
name|loops
operator|->
name|array
index|[
name|j
index|]
decl_stmt|;
if|if
condition|(
name|loop
operator|->
name|header
operator|==
name|oloop
operator|->
name|header
condition|)
block|{
name|int
name|disjoint
decl_stmt|;
name|int
name|smaller
decl_stmt|;
name|smaller
operator|=
name|loop
operator|->
name|num_nodes
operator|<
name|oloop
operator|->
name|num_nodes
expr_stmt|;
comment|/* If the union of LOOP and OLOOP is different than 		   the larger of LOOP and OLOOP then LOOP and OLOOP 		   must be disjoint.  */
name|disjoint
operator|=
operator|!
name|flow_loop_nested_p
argument_list|(
name|smaller
condition|?
name|loop
else|:
name|oloop
argument_list|,
name|smaller
condition|?
name|oloop
else|:
name|loop
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";; loop header %d shared by loops %d, %d %s\n"
argument_list|,
name|loop
operator|->
name|header
operator|->
name|index
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|disjoint
condition|?
literal|"disjoint"
else|:
literal|"nested"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|verbose
condition|)
name|flow_loops_cfg_dump
argument_list|(
name|loops
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Free all the memory allocated for LOOPS.  */
end_comment

begin_function
name|void
name|flow_loops_free
parameter_list|(
name|loops
parameter_list|)
name|struct
name|loops
modifier|*
name|loops
decl_stmt|;
block|{
if|if
condition|(
name|loops
operator|->
name|array
condition|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|loops
operator|->
name|num
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Free the loop descriptors.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loops
operator|->
name|num
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|loop
modifier|*
name|loop
init|=
operator|&
name|loops
operator|->
name|array
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|loop
operator|->
name|pre_header_edges
condition|)
name|free
argument_list|(
name|loop
operator|->
name|pre_header_edges
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop
operator|->
name|nodes
condition|)
name|sbitmap_free
argument_list|(
name|loop
operator|->
name|nodes
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop
operator|->
name|entry_edges
condition|)
name|free
argument_list|(
name|loop
operator|->
name|entry_edges
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop
operator|->
name|exit_edges
condition|)
name|free
argument_list|(
name|loop
operator|->
name|exit_edges
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop
operator|->
name|exits_doms
condition|)
name|sbitmap_free
argument_list|(
name|loop
operator|->
name|exits_doms
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|loops
operator|->
name|array
argument_list|)
expr_stmt|;
name|loops
operator|->
name|array
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|loops
operator|->
name|cfg
operator|.
name|dom
condition|)
name|sbitmap_vector_free
argument_list|(
name|loops
operator|->
name|cfg
operator|.
name|dom
argument_list|)
expr_stmt|;
if|if
condition|(
name|loops
operator|->
name|cfg
operator|.
name|dfs_order
condition|)
name|free
argument_list|(
name|loops
operator|->
name|cfg
operator|.
name|dfs_order
argument_list|)
expr_stmt|;
if|if
condition|(
name|loops
operator|->
name|shared_headers
condition|)
name|sbitmap_free
argument_list|(
name|loops
operator|->
name|shared_headers
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Find the entry edges into the loop with header HEADER and nodes    NODES and store in ENTRY_EDGES array.  Return the number of entry    edges from the loop.  */
end_comment

begin_function
specifier|static
name|int
name|flow_loop_entry_edges_find
parameter_list|(
name|header
parameter_list|,
name|nodes
parameter_list|,
name|entry_edges
parameter_list|)
name|basic_block
name|header
decl_stmt|;
specifier|const
name|sbitmap
name|nodes
decl_stmt|;
name|edge
modifier|*
modifier|*
name|entry_edges
decl_stmt|;
block|{
name|edge
name|e
decl_stmt|;
name|int
name|num_entries
decl_stmt|;
operator|*
name|entry_edges
operator|=
name|NULL
expr_stmt|;
name|num_entries
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|e
operator|=
name|header
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
block|{
name|basic_block
name|src
init|=
name|e
operator|->
name|src
decl_stmt|;
if|if
condition|(
name|src
operator|==
name|ENTRY_BLOCK_PTR
operator|||
operator|!
name|TEST_BIT
argument_list|(
name|nodes
argument_list|,
name|src
operator|->
name|index
argument_list|)
condition|)
name|num_entries
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|num_entries
condition|)
name|abort
argument_list|()
expr_stmt|;
operator|*
name|entry_edges
operator|=
operator|(
name|edge
operator|*
operator|)
name|xmalloc
argument_list|(
name|num_entries
operator|*
sizeof|sizeof
argument_list|(
name|edge
argument_list|)
argument_list|)
expr_stmt|;
name|num_entries
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|e
operator|=
name|header
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
block|{
name|basic_block
name|src
init|=
name|e
operator|->
name|src
decl_stmt|;
if|if
condition|(
name|src
operator|==
name|ENTRY_BLOCK_PTR
operator|||
operator|!
name|TEST_BIT
argument_list|(
name|nodes
argument_list|,
name|src
operator|->
name|index
argument_list|)
condition|)
operator|(
operator|*
name|entry_edges
operator|)
index|[
name|num_entries
operator|++
index|]
operator|=
name|e
expr_stmt|;
block|}
return|return
name|num_entries
return|;
block|}
end_function

begin_comment
comment|/* Find the exit edges from the loop using the bitmap of loop nodes    NODES and store in EXIT_EDGES array.  Return the number of    exit edges from the loop.  */
end_comment

begin_function
specifier|static
name|int
name|flow_loop_exit_edges_find
parameter_list|(
name|nodes
parameter_list|,
name|exit_edges
parameter_list|)
specifier|const
name|sbitmap
name|nodes
decl_stmt|;
name|edge
modifier|*
modifier|*
name|exit_edges
decl_stmt|;
block|{
name|edge
name|e
decl_stmt|;
name|int
name|node
decl_stmt|;
name|int
name|num_exits
decl_stmt|;
operator|*
name|exit_edges
operator|=
name|NULL
expr_stmt|;
comment|/* Check all nodes within the loop to see if there are any      successors not in the loop.  Note that a node may have multiple      exiting edges ?????  A node can have one jumping edge and one fallthru      edge so only one of these can exit the loop.  */
name|num_exits
operator|=
literal|0
expr_stmt|;
name|EXECUTE_IF_SET_IN_SBITMAP
argument_list|(
argument|nodes
argument_list|,
literal|0
argument_list|,
argument|node
argument_list|,
argument|{     for (e = BASIC_BLOCK (node)->succ; e; e = e->succ_next)       { 	basic_block dest = e->dest;  	if (dest == EXIT_BLOCK_PTR || ! TEST_BIT (nodes, dest->index)) 	    num_exits++;       }   }
argument_list|)
empty_stmt|;
if|if
condition|(
operator|!
name|num_exits
condition|)
return|return
literal|0
return|;
operator|*
name|exit_edges
operator|=
operator|(
name|edge
operator|*
operator|)
name|xmalloc
argument_list|(
name|num_exits
operator|*
sizeof|sizeof
argument_list|(
name|edge
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Store all exiting edges into an array.  */
name|num_exits
operator|=
literal|0
expr_stmt|;
name|EXECUTE_IF_SET_IN_SBITMAP
argument_list|(
argument|nodes
argument_list|,
literal|0
argument_list|,
argument|node
argument_list|,
argument|{     for (e = BASIC_BLOCK (node)->succ; e; e = e->succ_next)       { 	basic_block dest = e->dest;  	if (dest == EXIT_BLOCK_PTR || ! TEST_BIT (nodes, dest->index)) 	  (*exit_edges)[num_exits++] = e;       }   }
argument_list|)
empty_stmt|;
return|return
name|num_exits
return|;
block|}
end_function

begin_comment
comment|/* Find the nodes contained within the loop with header HEADER and    latch LATCH and store in NODES.  Return the number of nodes within    the loop.  */
end_comment

begin_function
specifier|static
name|int
name|flow_loop_nodes_find
parameter_list|(
name|header
parameter_list|,
name|latch
parameter_list|,
name|nodes
parameter_list|)
name|basic_block
name|header
decl_stmt|;
name|basic_block
name|latch
decl_stmt|;
name|sbitmap
name|nodes
decl_stmt|;
block|{
name|basic_block
modifier|*
name|stack
decl_stmt|;
name|int
name|sp
decl_stmt|;
name|int
name|num_nodes
init|=
literal|0
decl_stmt|;
name|stack
operator|=
operator|(
name|basic_block
operator|*
operator|)
name|xmalloc
argument_list|(
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|basic_block
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|=
literal|0
expr_stmt|;
comment|/* Start with only the loop header in the set of loop nodes.  */
name|sbitmap_zero
argument_list|(
name|nodes
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|nodes
argument_list|,
name|header
operator|->
name|index
argument_list|)
expr_stmt|;
name|num_nodes
operator|++
expr_stmt|;
name|header
operator|->
name|loop_depth
operator|++
expr_stmt|;
comment|/* Push the loop latch on to the stack.  */
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|nodes
argument_list|,
name|latch
operator|->
name|index
argument_list|)
condition|)
block|{
name|SET_BIT
argument_list|(
name|nodes
argument_list|,
name|latch
operator|->
name|index
argument_list|)
expr_stmt|;
name|latch
operator|->
name|loop_depth
operator|++
expr_stmt|;
name|num_nodes
operator|++
expr_stmt|;
name|stack
index|[
name|sp
operator|++
index|]
operator|=
name|latch
expr_stmt|;
block|}
while|while
condition|(
name|sp
condition|)
block|{
name|basic_block
name|node
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|node
operator|=
name|stack
index|[
operator|--
name|sp
index|]
expr_stmt|;
for|for
control|(
name|e
operator|=
name|node
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
block|{
name|basic_block
name|ancestor
init|=
name|e
operator|->
name|src
decl_stmt|;
comment|/* If each ancestor not marked as part of loop, add to set of 	     loop nodes and push on to stack.  */
if|if
condition|(
name|ancestor
operator|!=
name|ENTRY_BLOCK_PTR
operator|&&
operator|!
name|TEST_BIT
argument_list|(
name|nodes
argument_list|,
name|ancestor
operator|->
name|index
argument_list|)
condition|)
block|{
name|SET_BIT
argument_list|(
name|nodes
argument_list|,
name|ancestor
operator|->
name|index
argument_list|)
expr_stmt|;
name|ancestor
operator|->
name|loop_depth
operator|++
expr_stmt|;
name|num_nodes
operator|++
expr_stmt|;
name|stack
index|[
name|sp
operator|++
index|]
operator|=
name|ancestor
expr_stmt|;
block|}
block|}
block|}
name|free
argument_list|(
name|stack
argument_list|)
expr_stmt|;
return|return
name|num_nodes
return|;
block|}
end_function

begin_comment
comment|/* Find the root node of the loop pre-header extended basic block and    the edges along the trace from the root node to the loop header.  */
end_comment

begin_function
specifier|static
name|void
name|flow_loop_pre_header_scan
parameter_list|(
name|loop
parameter_list|)
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
block|{
name|int
name|num
decl_stmt|;
name|basic_block
name|ebb
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|loop
operator|->
name|num_pre_header_edges
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|loop
operator|->
name|num_entries
operator|!=
literal|1
condition|)
return|return;
name|ebb
operator|=
name|loop
operator|->
name|entry_edges
index|[
literal|0
index|]
operator|->
name|src
expr_stmt|;
if|if
condition|(
name|ebb
operator|==
name|ENTRY_BLOCK_PTR
condition|)
return|return;
comment|/* Count number of edges along trace from loop header to      root of pre-header extended basic block.  Usually this is      only one or two edges.  */
for|for
control|(
name|num
operator|=
literal|1
init|;
name|ebb
operator|->
name|pred
operator|->
name|src
operator|!=
name|ENTRY_BLOCK_PTR
operator|&&
operator|!
name|ebb
operator|->
name|pred
operator|->
name|pred_next
condition|;
name|num
operator|++
control|)
name|ebb
operator|=
name|ebb
operator|->
name|pred
operator|->
name|src
expr_stmt|;
name|loop
operator|->
name|pre_header_edges
operator|=
operator|(
name|edge
operator|*
operator|)
name|xmalloc
argument_list|(
name|num
operator|*
sizeof|sizeof
argument_list|(
name|edge
argument_list|)
argument_list|)
expr_stmt|;
name|loop
operator|->
name|num_pre_header_edges
operator|=
name|num
expr_stmt|;
comment|/* Store edges in order that they are followed.  The source of the first edge      is the root node of the pre-header extended basic block and the      destination of the last last edge is the loop header.  */
for|for
control|(
name|e
operator|=
name|loop
operator|->
name|entry_edges
index|[
literal|0
index|]
init|;
name|num
condition|;
name|e
operator|=
name|e
operator|->
name|src
operator|->
name|pred
control|)
name|loop
operator|->
name|pre_header_edges
index|[
operator|--
name|num
index|]
operator|=
name|e
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the block for the pre-header of the loop with header    HEADER where DOM specifies the dominator information.  Return NULL if    there is no pre-header.  */
end_comment

begin_function
specifier|static
name|basic_block
name|flow_loop_pre_header_find
parameter_list|(
name|header
parameter_list|,
name|dom
parameter_list|)
name|basic_block
name|header
decl_stmt|;
specifier|const
name|sbitmap
modifier|*
name|dom
decl_stmt|;
block|{
name|basic_block
name|pre_header
decl_stmt|;
name|edge
name|e
decl_stmt|;
comment|/* If block p is a predecessor of the header and is the only block      that the header does not dominate, then it is the pre-header.  */
name|pre_header
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|e
operator|=
name|header
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
block|{
name|basic_block
name|node
init|=
name|e
operator|->
name|src
decl_stmt|;
if|if
condition|(
name|node
operator|!=
name|ENTRY_BLOCK_PTR
operator|&&
operator|!
name|TEST_BIT
argument_list|(
name|dom
index|[
name|node
operator|->
name|index
index|]
argument_list|,
name|header
operator|->
name|index
argument_list|)
condition|)
block|{
if|if
condition|(
name|pre_header
operator|==
name|NULL
condition|)
name|pre_header
operator|=
name|node
expr_stmt|;
else|else
block|{
comment|/* There are multiple edges into the header from outside 		 the loop so there is no pre-header block.  */
name|pre_header
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
name|pre_header
return|;
block|}
end_function

begin_comment
comment|/* Add LOOP to the loop hierarchy tree where PREVLOOP was the loop    previously added.  The insertion algorithm assumes that the loops    are added in the order found by a depth first search of the CFG.  */
end_comment

begin_function
specifier|static
name|void
name|flow_loop_tree_node_add
parameter_list|(
name|prevloop
parameter_list|,
name|loop
parameter_list|)
name|struct
name|loop
modifier|*
name|prevloop
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
block|{
if|if
condition|(
name|flow_loop_nested_p
argument_list|(
name|prevloop
argument_list|,
name|loop
argument_list|)
condition|)
block|{
name|prevloop
operator|->
name|inner
operator|=
name|loop
expr_stmt|;
name|loop
operator|->
name|outer
operator|=
name|prevloop
expr_stmt|;
return|return;
block|}
for|for
control|(
init|;
name|prevloop
operator|->
name|outer
condition|;
name|prevloop
operator|=
name|prevloop
operator|->
name|outer
control|)
if|if
condition|(
name|flow_loop_nested_p
argument_list|(
name|prevloop
operator|->
name|outer
argument_list|,
name|loop
argument_list|)
condition|)
block|{
name|prevloop
operator|->
name|next
operator|=
name|loop
expr_stmt|;
name|loop
operator|->
name|outer
operator|=
name|prevloop
operator|->
name|outer
expr_stmt|;
return|return;
block|}
name|prevloop
operator|->
name|next
operator|=
name|loop
expr_stmt|;
name|loop
operator|->
name|outer
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Build the loop hierarchy tree for LOOPS.  */
end_comment

begin_function
specifier|static
name|void
name|flow_loops_tree_build
parameter_list|(
name|loops
parameter_list|)
name|struct
name|loops
modifier|*
name|loops
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|num_loops
decl_stmt|;
name|num_loops
operator|=
name|loops
operator|->
name|num
expr_stmt|;
if|if
condition|(
operator|!
name|num_loops
condition|)
return|return;
comment|/* Root the loop hierarchy tree with the first loop found.      Since we used a depth first search this should be the      outermost loop.  */
name|loops
operator|->
name|tree_root
operator|=
operator|&
name|loops
operator|->
name|array
index|[
literal|0
index|]
expr_stmt|;
name|loops
operator|->
name|tree_root
operator|->
name|outer
operator|=
name|loops
operator|->
name|tree_root
operator|->
name|inner
operator|=
name|loops
operator|->
name|tree_root
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
comment|/* Add the remaining loops to the tree.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|num_loops
condition|;
name|i
operator|++
control|)
name|flow_loop_tree_node_add
argument_list|(
operator|&
name|loops
operator|->
name|array
index|[
name|i
operator|-
literal|1
index|]
argument_list|,
operator|&
name|loops
operator|->
name|array
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Helper function to compute loop nesting depth and enclosed loop level    for the natural loop specified by LOOP at the loop depth DEPTH.    Returns the loop level.  */
end_comment

begin_function
specifier|static
name|int
name|flow_loop_level_compute
parameter_list|(
name|loop
parameter_list|,
name|depth
parameter_list|)
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|int
name|depth
decl_stmt|;
block|{
name|struct
name|loop
modifier|*
name|inner
decl_stmt|;
name|int
name|level
init|=
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|loop
condition|)
return|return
literal|0
return|;
comment|/* Traverse loop tree assigning depth and computing level as the      maximum level of all the inner loops of this loop.  The loop      level is equivalent to the height of the loop in the loop tree      and corresponds to the number of enclosed loop levels (including      itself).  */
for|for
control|(
name|inner
operator|=
name|loop
operator|->
name|inner
init|;
name|inner
condition|;
name|inner
operator|=
name|inner
operator|->
name|next
control|)
block|{
name|int
name|ilevel
init|=
name|flow_loop_level_compute
argument_list|(
name|inner
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
operator|+
literal|1
decl_stmt|;
name|level
operator|=
name|MAX
argument_list|(
name|ilevel
argument_list|,
name|level
argument_list|)
expr_stmt|;
block|}
name|loop
operator|->
name|level
operator|=
name|level
expr_stmt|;
name|loop
operator|->
name|depth
operator|=
name|depth
expr_stmt|;
return|return
name|level
return|;
block|}
end_function

begin_comment
comment|/* Compute the loop nesting depth and enclosed loop level for the loop    hierarchy tree specified by LOOPS.  Return the maximum enclosed loop    level.  */
end_comment

begin_function
specifier|static
name|int
name|flow_loops_level_compute
parameter_list|(
name|loops
parameter_list|)
name|struct
name|loops
modifier|*
name|loops
decl_stmt|;
block|{
name|int
name|levels
init|=
literal|0
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|int
name|level
decl_stmt|;
comment|/* Traverse all the outer level loops.  */
for|for
control|(
name|loop
operator|=
name|loops
operator|->
name|tree_root
init|;
name|loop
condition|;
name|loop
operator|=
name|loop
operator|->
name|next
control|)
block|{
name|level
operator|=
name|flow_loop_level_compute
argument_list|(
name|loop
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|levels
operator|=
name|MAX
argument_list|(
name|levels
argument_list|,
name|level
argument_list|)
expr_stmt|;
block|}
return|return
name|levels
return|;
block|}
end_function

begin_comment
comment|/* Scan a single natural loop specified by LOOP collecting information    about it specified by FLAGS.  */
end_comment

begin_function
name|int
name|flow_loop_scan
parameter_list|(
name|loops
parameter_list|,
name|loop
parameter_list|,
name|flags
parameter_list|)
name|struct
name|loops
modifier|*
name|loops
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
comment|/* Determine prerequisites.  */
if|if
condition|(
operator|(
name|flags
operator|&
name|LOOP_EXITS_DOMS
operator|)
operator|&&
operator|!
name|loop
operator|->
name|exit_edges
condition|)
name|flags
operator||=
name|LOOP_EXIT_EDGES
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|LOOP_ENTRY_EDGES
condition|)
comment|/* Find edges which enter the loop header.  Note that the entry edges        should only enter the header of a natural loop.  */
name|loop
operator|->
name|num_entries
operator|=
name|flow_loop_entry_edges_find
argument_list|(
name|loop
operator|->
name|header
argument_list|,
name|loop
operator|->
name|nodes
argument_list|,
operator|&
name|loop
operator|->
name|entry_edges
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|LOOP_EXIT_EDGES
condition|)
comment|/* Find edges which exit the loop.  */
name|loop
operator|->
name|num_exits
operator|=
name|flow_loop_exit_edges_find
argument_list|(
name|loop
operator|->
name|nodes
argument_list|,
operator|&
name|loop
operator|->
name|exit_edges
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|LOOP_EXITS_DOMS
condition|)
block|{
name|int
name|j
decl_stmt|;
comment|/* Determine which loop nodes dominate all the exits 	 of the loop.  */
name|loop
operator|->
name|exits_doms
operator|=
name|sbitmap_alloc
argument_list|(
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|sbitmap_copy
argument_list|(
name|loop
operator|->
name|exits_doms
argument_list|,
name|loop
operator|->
name|nodes
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|loop
operator|->
name|num_exits
condition|;
name|j
operator|++
control|)
name|sbitmap_a_and_b
argument_list|(
name|loop
operator|->
name|exits_doms
argument_list|,
name|loop
operator|->
name|exits_doms
argument_list|,
name|loops
operator|->
name|cfg
operator|.
name|dom
index|[
name|loop
operator|->
name|exit_edges
index|[
name|j
index|]
operator|->
name|src
operator|->
name|index
index|]
argument_list|)
expr_stmt|;
comment|/* The header of a natural loop must dominate 	 all exits.  */
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|loop
operator|->
name|exits_doms
argument_list|,
name|loop
operator|->
name|header
operator|->
name|index
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|LOOP_PRE_HEADER
condition|)
block|{
comment|/* Look to see if the loop has a pre-header node.  */
name|loop
operator|->
name|pre_header
operator|=
name|flow_loop_pre_header_find
argument_list|(
name|loop
operator|->
name|header
argument_list|,
name|loops
operator|->
name|cfg
operator|.
name|dom
argument_list|)
expr_stmt|;
comment|/* Find the blocks within the extended basic block of 	 the loop pre-header.  */
name|flow_loop_pre_header_scan
argument_list|(
name|loop
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Find all the natural loops in the function and save in LOOPS structure and    recalculate loop_depth information in basic block structures.  FLAGS    controls which loop information is collected.  Return the number of natural    loops found.  */
end_comment

begin_function
name|int
name|flow_loops_find
parameter_list|(
name|loops
parameter_list|,
name|flags
parameter_list|)
name|struct
name|loops
modifier|*
name|loops
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|b
decl_stmt|;
name|int
name|num_loops
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|sbitmap
name|headers
decl_stmt|;
name|sbitmap
modifier|*
name|dom
decl_stmt|;
name|int
modifier|*
name|dfs_order
decl_stmt|;
name|int
modifier|*
name|rc_order
decl_stmt|;
comment|/* This function cannot be repeatedly called with different      flags to build up the loop information.  The loop tree      must always be built if this function is called.  */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|LOOP_TREE
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|memset
argument_list|(
name|loops
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|loops
argument_list|)
expr_stmt|;
comment|/* Taking care of this degenerate case makes the rest of      this code simpler.  */
if|if
condition|(
name|n_basic_blocks
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|dfs_order
operator|=
name|NULL
expr_stmt|;
name|rc_order
operator|=
name|NULL
expr_stmt|;
comment|/* Compute the dominators.  */
name|dom
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_basic_blocks
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|calculate_dominance_info
argument_list|(
name|NULL
argument_list|,
name|dom
argument_list|,
name|CDI_DOMINATORS
argument_list|)
expr_stmt|;
comment|/* Count the number of loop edges (back edges).  This should be the      same as the number of natural loops.  */
name|num_loops
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|n_basic_blocks
condition|;
name|b
operator|++
control|)
block|{
name|basic_block
name|header
decl_stmt|;
name|header
operator|=
name|BASIC_BLOCK
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|header
operator|->
name|loop_depth
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|e
operator|=
name|header
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
block|{
name|basic_block
name|latch
init|=
name|e
operator|->
name|src
decl_stmt|;
comment|/* Look for back edges where a predecessor is dominated 	     by this block.  A natural loop has a single entry 	     node (header) that dominates all the nodes in the 	     loop.  It also has single back edge to the header 	     from a latch node.  Note that multiple natural loops 	     may share the same header.  */
if|if
condition|(
name|b
operator|!=
name|header
operator|->
name|index
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|latch
operator|!=
name|ENTRY_BLOCK_PTR
operator|&&
name|TEST_BIT
argument_list|(
name|dom
index|[
name|latch
operator|->
name|index
index|]
argument_list|,
name|b
argument_list|)
condition|)
name|num_loops
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|num_loops
condition|)
block|{
comment|/* Compute depth first search order of the CFG so that outer 	 natural loops will be found before inner natural loops.  */
name|dfs_order
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|rc_order
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|flow_depth_first_order_compute
argument_list|(
name|dfs_order
argument_list|,
name|rc_order
argument_list|)
expr_stmt|;
comment|/* Save CFG derived information to avoid recomputing it.  */
name|loops
operator|->
name|cfg
operator|.
name|dom
operator|=
name|dom
expr_stmt|;
name|loops
operator|->
name|cfg
operator|.
name|dfs_order
operator|=
name|dfs_order
expr_stmt|;
name|loops
operator|->
name|cfg
operator|.
name|rc_order
operator|=
name|rc_order
expr_stmt|;
comment|/* Allocate loop structures.  */
name|loops
operator|->
name|array
operator|=
operator|(
expr|struct
name|loop
operator|*
operator|)
name|xcalloc
argument_list|(
name|num_loops
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|loop
argument_list|)
argument_list|)
expr_stmt|;
name|headers
operator|=
name|sbitmap_alloc
argument_list|(
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|headers
argument_list|)
expr_stmt|;
name|loops
operator|->
name|shared_headers
operator|=
name|sbitmap_alloc
argument_list|(
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|loops
operator|->
name|shared_headers
argument_list|)
expr_stmt|;
comment|/* Find and record information about all the natural loops 	 in the CFG.  */
name|num_loops
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|b
operator|=
name|n_basic_blocks
operator|-
literal|1
init|;
name|b
operator|>=
literal|0
condition|;
name|b
operator|--
control|)
block|{
name|basic_block
name|latch
decl_stmt|;
comment|/* Search the nodes of the CFG in reverse completion order 	     so that we can find outer loops first.  */
name|latch
operator|=
name|BASIC_BLOCK
argument_list|(
name|rc_order
index|[
name|b
index|]
argument_list|)
expr_stmt|;
comment|/* Look for all the possible headers for this latch block.  */
for|for
control|(
name|e
operator|=
name|latch
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
block|{
name|basic_block
name|header
init|=
name|e
operator|->
name|dest
decl_stmt|;
comment|/* Look for forward edges where this block is dominated by 		 a successor of this block.  A natural loop has a single 		 entry node (header) that dominates all the nodes in the 		 loop.  It also has single back edge to the header from a 		 latch node.  Note that multiple natural loops may share 		 the same header.  */
if|if
condition|(
name|header
operator|!=
name|EXIT_BLOCK_PTR
operator|&&
name|TEST_BIT
argument_list|(
name|dom
index|[
name|latch
operator|->
name|index
index|]
argument_list|,
name|header
operator|->
name|index
argument_list|)
condition|)
block|{
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|loop
operator|=
name|loops
operator|->
name|array
operator|+
name|num_loops
expr_stmt|;
name|loop
operator|->
name|header
operator|=
name|header
expr_stmt|;
name|loop
operator|->
name|latch
operator|=
name|latch
expr_stmt|;
name|loop
operator|->
name|num
operator|=
name|num_loops
expr_stmt|;
name|num_loops
operator|++
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_loops
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|loop
modifier|*
name|loop
init|=
operator|&
name|loops
operator|->
name|array
index|[
name|i
index|]
decl_stmt|;
comment|/* Keep track of blocks that are loop headers so 	     that we can tell which loops should be merged.  */
if|if
condition|(
name|TEST_BIT
argument_list|(
name|headers
argument_list|,
name|loop
operator|->
name|header
operator|->
name|index
argument_list|)
condition|)
name|SET_BIT
argument_list|(
name|loops
operator|->
name|shared_headers
argument_list|,
name|loop
operator|->
name|header
operator|->
name|index
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|headers
argument_list|,
name|loop
operator|->
name|header
operator|->
name|index
argument_list|)
expr_stmt|;
comment|/* Find nodes contained within the loop.  */
name|loop
operator|->
name|nodes
operator|=
name|sbitmap_alloc
argument_list|(
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|loop
operator|->
name|num_nodes
operator|=
name|flow_loop_nodes_find
argument_list|(
name|loop
operator|->
name|header
argument_list|,
name|loop
operator|->
name|latch
argument_list|,
name|loop
operator|->
name|nodes
argument_list|)
expr_stmt|;
comment|/* Compute first and last blocks within the loop. 	     These are often the same as the loop header and 	     loop latch respectively, but this is not always 	     the case.  */
name|loop
operator|->
name|first
operator|=
name|BASIC_BLOCK
argument_list|(
name|sbitmap_first_set_bit
argument_list|(
name|loop
operator|->
name|nodes
argument_list|)
argument_list|)
expr_stmt|;
name|loop
operator|->
name|last
operator|=
name|BASIC_BLOCK
argument_list|(
name|sbitmap_last_set_bit
argument_list|(
name|loop
operator|->
name|nodes
argument_list|)
argument_list|)
expr_stmt|;
name|flow_loop_scan
argument_list|(
name|loops
argument_list|,
name|loop
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
comment|/* Natural loops with shared headers may either be disjoint or 	 nested.  Disjoint loops with shared headers cannot be inner 	 loops and should be merged.  For now just mark loops that share 	 headers.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_loops
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_BIT
argument_list|(
name|loops
operator|->
name|shared_headers
argument_list|,
name|loops
operator|->
name|array
index|[
name|i
index|]
operator|.
name|header
operator|->
name|index
argument_list|)
condition|)
name|loops
operator|->
name|array
index|[
name|i
index|]
operator|.
name|shared
operator|=
literal|1
expr_stmt|;
name|sbitmap_free
argument_list|(
name|headers
argument_list|)
expr_stmt|;
block|}
else|else
name|sbitmap_vector_free
argument_list|(
name|dom
argument_list|)
expr_stmt|;
name|loops
operator|->
name|num
operator|=
name|num_loops
expr_stmt|;
comment|/* Build the loop hierarchy tree.  */
name|flow_loops_tree_build
argument_list|(
name|loops
argument_list|)
expr_stmt|;
comment|/* Assign the loop nesting depth and enclosed loop level for each      loop.  */
name|loops
operator|->
name|levels
operator|=
name|flow_loops_level_compute
argument_list|(
name|loops
argument_list|)
expr_stmt|;
return|return
name|num_loops
return|;
block|}
end_function

begin_comment
comment|/* Update the information regarding the loops in the CFG    specified by LOOPS.  */
end_comment

begin_function
name|int
name|flow_loops_update
parameter_list|(
name|loops
parameter_list|,
name|flags
parameter_list|)
name|struct
name|loops
modifier|*
name|loops
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
comment|/* One day we may want to update the current loop data.  For now      throw away the old stuff and rebuild what we need.  */
if|if
condition|(
name|loops
operator|->
name|array
condition|)
name|flow_loops_free
argument_list|(
name|loops
argument_list|)
expr_stmt|;
return|return
name|flow_loops_find
argument_list|(
name|loops
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if edge E enters header of LOOP from outside of LOOP.  */
end_comment

begin_function
name|int
name|flow_loop_outside_edge_p
parameter_list|(
name|loop
parameter_list|,
name|e
parameter_list|)
specifier|const
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|edge
name|e
decl_stmt|;
block|{
if|if
condition|(
name|e
operator|->
name|dest
operator|!=
name|loop
operator|->
name|header
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
operator|(
name|e
operator|->
name|src
operator|==
name|ENTRY_BLOCK_PTR
operator|)
operator|||
operator|!
name|TEST_BIT
argument_list|(
name|loop
operator|->
name|nodes
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|)
return|;
block|}
end_function

end_unit

