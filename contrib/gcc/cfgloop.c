begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Natural loop discovery code for GNU compiler.    Copyright (C) 2000, 2001, 2003, 2004 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"cfgloop.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_comment
comment|/* Ratio of frequencies of edges so that one of more latch edges is    considered to belong to inner loop with same header.  */
end_comment

begin_define
define|#
directive|define
name|HEAVY_EDGE_RATIO
value|8
end_define

begin_function_decl
specifier|static
name|void
name|flow_loops_cfg_dump
parameter_list|(
specifier|const
name|struct
name|loops
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|flow_loop_entry_edges_find
parameter_list|(
name|struct
name|loop
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|flow_loop_exit_edges_find
parameter_list|(
name|struct
name|loop
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|flow_loop_nodes_find
parameter_list|(
name|basic_block
parameter_list|,
name|struct
name|loop
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|flow_loop_pre_header_scan
parameter_list|(
name|struct
name|loop
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|basic_block
name|flow_loop_pre_header_find
parameter_list|(
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|flow_loop_level_compute
parameter_list|(
name|struct
name|loop
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|flow_loops_level_compute
parameter_list|(
name|struct
name|loops
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|establish_preds
parameter_list|(
name|struct
name|loop
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|basic_block
name|make_forwarder_block
parameter_list|(
name|basic_block
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|edge
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|canonicalize_loop_headers
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|glb_enum_p
parameter_list|(
name|basic_block
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|redirect_edge_with_latch_update
parameter_list|(
name|edge
parameter_list|,
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Dump loop related CFG information.  */
end_comment

begin_function
specifier|static
name|void
name|flow_loops_cfg_dump
parameter_list|(
specifier|const
name|struct
name|loops
modifier|*
name|loops
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
if|if
condition|(
operator|!
name|loops
operator|->
name|num
operator|||
operator|!
name|file
condition|)
return|return;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|edge
name|succ
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";; %d succs { "
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
for|for
control|(
name|succ
operator|=
name|bb
operator|->
name|succ
init|;
name|succ
condition|;
name|succ
operator|=
name|succ
operator|->
name|succ_next
control|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d "
argument_list|,
name|succ
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Dump the DFS node order.  */
if|if
condition|(
name|loops
operator|->
name|cfg
operator|.
name|dfs_order
condition|)
block|{
name|fputs
argument_list|(
literal|";; DFS order: "
argument_list|,
name|file
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d "
argument_list|,
name|loops
operator|->
name|cfg
operator|.
name|dfs_order
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
comment|/* Dump the reverse completion node order.  */
if|if
condition|(
name|loops
operator|->
name|cfg
operator|.
name|rc_order
condition|)
block|{
name|fputs
argument_list|(
literal|";; RC order: "
argument_list|,
name|file
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d "
argument_list|,
name|loops
operator|->
name|cfg
operator|.
name|rc_order
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return nonzero if the nodes of LOOP are a subset of OUTER.  */
end_comment

begin_function
name|bool
name|flow_loop_nested_p
parameter_list|(
specifier|const
name|struct
name|loop
modifier|*
name|outer
parameter_list|,
specifier|const
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
return|return
name|loop
operator|->
name|depth
operator|>
name|outer
operator|->
name|depth
operator|&&
name|loop
operator|->
name|pred
index|[
name|outer
operator|->
name|depth
index|]
operator|==
name|outer
return|;
block|}
end_function

begin_comment
comment|/* Dump the loop information specified by LOOP to the stream FILE    using auxiliary dump callback function LOOP_DUMP_AUX if non null.  */
end_comment

begin_function
name|void
name|flow_loop_dump
parameter_list|(
specifier|const
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|,
name|void
function_decl|(
modifier|*
name|loop_dump_aux
function_decl|)
parameter_list|(
specifier|const
name|struct
name|loop
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|)
parameter_list|,
name|int
name|verbose
parameter_list|)
block|{
name|basic_block
modifier|*
name|bbs
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|loop
operator|||
operator|!
name|loop
operator|->
name|header
condition|)
return|return;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";;\n;; Loop %d:%s\n"
argument_list|,
name|loop
operator|->
name|num
argument_list|,
name|loop
operator|->
name|invalid
condition|?
literal|" invalid"
else|:
literal|""
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";;  header %d, latch %d, pre-header %d\n"
argument_list|,
name|loop
operator|->
name|header
operator|->
name|index
argument_list|,
name|loop
operator|->
name|latch
operator|->
name|index
argument_list|,
name|loop
operator|->
name|pre_header
condition|?
name|loop
operator|->
name|pre_header
operator|->
name|index
else|:
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";;  depth %d, level %d, outer %ld\n"
argument_list|,
name|loop
operator|->
name|depth
argument_list|,
name|loop
operator|->
name|level
argument_list|,
call|(
name|long
call|)
argument_list|(
name|loop
operator|->
name|outer
condition|?
name|loop
operator|->
name|outer
operator|->
name|num
else|:
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop
operator|->
name|pre_header_edges
condition|)
name|flow_edge_list_print
argument_list|(
literal|";;  pre-header edges"
argument_list|,
name|loop
operator|->
name|pre_header_edges
argument_list|,
name|loop
operator|->
name|num_pre_header_edges
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|flow_edge_list_print
argument_list|(
literal|";;  entry edges"
argument_list|,
name|loop
operator|->
name|entry_edges
argument_list|,
name|loop
operator|->
name|num_entries
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";;  nodes:"
argument_list|)
expr_stmt|;
name|bbs
operator|=
name|get_loop_body
argument_list|(
name|loop
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loop
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %d"
argument_list|,
name|bbs
index|[
name|i
index|]
operator|->
name|index
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bbs
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|flow_edge_list_print
argument_list|(
literal|";;  exit edges"
argument_list|,
name|loop
operator|->
name|exit_edges
argument_list|,
name|loop
operator|->
name|num_exits
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop_dump_aux
condition|)
name|loop_dump_aux
argument_list|(
name|loop
argument_list|,
name|file
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump the loop information specified by LOOPS to the stream FILE,    using auxiliary dump callback function LOOP_DUMP_AUX if non null.  */
end_comment

begin_function
name|void
name|flow_loops_dump
parameter_list|(
specifier|const
name|struct
name|loops
modifier|*
name|loops
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|,
name|void
function_decl|(
modifier|*
name|loop_dump_aux
function_decl|)
parameter_list|(
specifier|const
name|struct
name|loop
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|)
parameter_list|,
name|int
name|verbose
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|num_loops
decl_stmt|;
name|num_loops
operator|=
name|loops
operator|->
name|num
expr_stmt|;
if|if
condition|(
operator|!
name|num_loops
operator|||
operator|!
name|file
condition|)
return|return;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";; %d loops found, %d levels\n"
argument_list|,
name|num_loops
argument_list|,
name|loops
operator|->
name|levels
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_loops
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|loop
modifier|*
name|loop
init|=
name|loops
operator|->
name|parray
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|loop
condition|)
continue|continue;
name|flow_loop_dump
argument_list|(
name|loop
argument_list|,
name|file
argument_list|,
name|loop_dump_aux
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|verbose
condition|)
name|flow_loops_cfg_dump
argument_list|(
name|loops
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free data allocated for LOOP.  */
end_comment

begin_function
name|void
name|flow_loop_free
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
if|if
condition|(
name|loop
operator|->
name|pre_header_edges
condition|)
name|free
argument_list|(
name|loop
operator|->
name|pre_header_edges
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop
operator|->
name|entry_edges
condition|)
name|free
argument_list|(
name|loop
operator|->
name|entry_edges
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop
operator|->
name|exit_edges
condition|)
name|free
argument_list|(
name|loop
operator|->
name|exit_edges
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop
operator|->
name|pred
condition|)
name|free
argument_list|(
name|loop
operator|->
name|pred
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|loop
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free all the memory allocated for LOOPS.  */
end_comment

begin_function
name|void
name|flow_loops_free
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|)
block|{
if|if
condition|(
name|loops
operator|->
name|parray
condition|)
block|{
name|unsigned
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|loops
operator|->
name|num
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Free the loop descriptors.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loops
operator|->
name|num
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|loop
modifier|*
name|loop
init|=
name|loops
operator|->
name|parray
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|loop
condition|)
continue|continue;
name|flow_loop_free
argument_list|(
name|loop
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|loops
operator|->
name|parray
argument_list|)
expr_stmt|;
name|loops
operator|->
name|parray
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|loops
operator|->
name|cfg
operator|.
name|dfs_order
condition|)
name|free
argument_list|(
name|loops
operator|->
name|cfg
operator|.
name|dfs_order
argument_list|)
expr_stmt|;
if|if
condition|(
name|loops
operator|->
name|cfg
operator|.
name|rc_order
condition|)
name|free
argument_list|(
name|loops
operator|->
name|cfg
operator|.
name|rc_order
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Find the entry edges into the LOOP.  */
end_comment

begin_function
specifier|static
name|void
name|flow_loop_entry_edges_find
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|edge
name|e
decl_stmt|;
name|int
name|num_entries
decl_stmt|;
name|num_entries
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|e
operator|=
name|loop
operator|->
name|header
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
block|{
if|if
condition|(
name|flow_loop_outside_edge_p
argument_list|(
name|loop
argument_list|,
name|e
argument_list|)
condition|)
name|num_entries
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|num_entries
condition|)
name|abort
argument_list|()
expr_stmt|;
name|loop
operator|->
name|entry_edges
operator|=
name|xmalloc
argument_list|(
name|num_entries
operator|*
sizeof|sizeof
argument_list|(
name|edge
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|num_entries
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|e
operator|=
name|loop
operator|->
name|header
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
block|{
if|if
condition|(
name|flow_loop_outside_edge_p
argument_list|(
name|loop
argument_list|,
name|e
argument_list|)
condition|)
name|loop
operator|->
name|entry_edges
index|[
name|num_entries
operator|++
index|]
operator|=
name|e
expr_stmt|;
block|}
name|loop
operator|->
name|num_entries
operator|=
name|num_entries
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find the exit edges from the LOOP.  */
end_comment

begin_function
specifier|static
name|void
name|flow_loop_exit_edges_find
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|edge
name|e
decl_stmt|;
name|basic_block
name|node
decl_stmt|,
modifier|*
name|bbs
decl_stmt|;
name|unsigned
name|num_exits
decl_stmt|,
name|i
decl_stmt|;
name|loop
operator|->
name|exit_edges
operator|=
name|NULL
expr_stmt|;
name|loop
operator|->
name|num_exits
operator|=
literal|0
expr_stmt|;
comment|/* Check all nodes within the loop to see if there are any      successors not in the loop.  Note that a node may have multiple      exiting edges.  */
name|num_exits
operator|=
literal|0
expr_stmt|;
name|bbs
operator|=
name|get_loop_body
argument_list|(
name|loop
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loop
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
block|{
name|node
operator|=
name|bbs
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|e
operator|=
name|node
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
block|{
name|basic_block
name|dest
init|=
name|e
operator|->
name|dest
decl_stmt|;
if|if
condition|(
operator|!
name|flow_bb_inside_loop_p
argument_list|(
name|loop
argument_list|,
name|dest
argument_list|)
condition|)
name|num_exits
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|num_exits
condition|)
block|{
name|free
argument_list|(
name|bbs
argument_list|)
expr_stmt|;
return|return;
block|}
name|loop
operator|->
name|exit_edges
operator|=
name|xmalloc
argument_list|(
name|num_exits
operator|*
sizeof|sizeof
argument_list|(
name|edge
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Store all exiting edges into an array.  */
name|num_exits
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loop
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
block|{
name|node
operator|=
name|bbs
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|e
operator|=
name|node
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
block|{
name|basic_block
name|dest
init|=
name|e
operator|->
name|dest
decl_stmt|;
if|if
condition|(
operator|!
name|flow_bb_inside_loop_p
argument_list|(
name|loop
argument_list|,
name|dest
argument_list|)
condition|)
name|loop
operator|->
name|exit_edges
index|[
name|num_exits
operator|++
index|]
operator|=
name|e
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|bbs
argument_list|)
expr_stmt|;
name|loop
operator|->
name|num_exits
operator|=
name|num_exits
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find the nodes contained within the LOOP with header HEADER.    Return the number of nodes within the loop.  */
end_comment

begin_function
specifier|static
name|int
name|flow_loop_nodes_find
parameter_list|(
name|basic_block
name|header
parameter_list|,
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|basic_block
modifier|*
name|stack
decl_stmt|;
name|int
name|sp
decl_stmt|;
name|int
name|num_nodes
init|=
literal|1
decl_stmt|;
name|header
operator|->
name|loop_father
operator|=
name|loop
expr_stmt|;
name|header
operator|->
name|loop_depth
operator|=
name|loop
operator|->
name|depth
expr_stmt|;
if|if
condition|(
name|loop
operator|->
name|latch
operator|->
name|loop_father
operator|!=
name|loop
condition|)
block|{
name|stack
operator|=
name|xmalloc
argument_list|(
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|basic_block
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|=
literal|0
expr_stmt|;
name|num_nodes
operator|++
expr_stmt|;
name|stack
index|[
name|sp
operator|++
index|]
operator|=
name|loop
operator|->
name|latch
expr_stmt|;
name|loop
operator|->
name|latch
operator|->
name|loop_father
operator|=
name|loop
expr_stmt|;
name|loop
operator|->
name|latch
operator|->
name|loop_depth
operator|=
name|loop
operator|->
name|depth
expr_stmt|;
while|while
condition|(
name|sp
condition|)
block|{
name|basic_block
name|node
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|node
operator|=
name|stack
index|[
operator|--
name|sp
index|]
expr_stmt|;
for|for
control|(
name|e
operator|=
name|node
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
block|{
name|basic_block
name|ancestor
init|=
name|e
operator|->
name|src
decl_stmt|;
if|if
condition|(
name|ancestor
operator|!=
name|ENTRY_BLOCK_PTR
operator|&&
name|ancestor
operator|->
name|loop_father
operator|!=
name|loop
condition|)
block|{
name|ancestor
operator|->
name|loop_father
operator|=
name|loop
expr_stmt|;
name|ancestor
operator|->
name|loop_depth
operator|=
name|loop
operator|->
name|depth
expr_stmt|;
name|num_nodes
operator|++
expr_stmt|;
name|stack
index|[
name|sp
operator|++
index|]
operator|=
name|ancestor
expr_stmt|;
block|}
block|}
block|}
name|free
argument_list|(
name|stack
argument_list|)
expr_stmt|;
block|}
return|return
name|num_nodes
return|;
block|}
end_function

begin_comment
comment|/* Find the root node of the loop pre-header extended basic block and    the edges along the trace from the root node to the loop header.  */
end_comment

begin_function
specifier|static
name|void
name|flow_loop_pre_header_scan
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|int
name|num
decl_stmt|;
name|basic_block
name|ebb
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|loop
operator|->
name|num_pre_header_edges
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|loop
operator|->
name|num_entries
operator|!=
literal|1
condition|)
return|return;
name|ebb
operator|=
name|loop
operator|->
name|entry_edges
index|[
literal|0
index|]
operator|->
name|src
expr_stmt|;
if|if
condition|(
name|ebb
operator|==
name|ENTRY_BLOCK_PTR
condition|)
return|return;
comment|/* Count number of edges along trace from loop header to      root of pre-header extended basic block.  Usually this is      only one or two edges.  */
for|for
control|(
name|num
operator|=
literal|1
init|;
name|ebb
operator|->
name|pred
operator|->
name|src
operator|!=
name|ENTRY_BLOCK_PTR
operator|&&
operator|!
name|ebb
operator|->
name|pred
operator|->
name|pred_next
condition|;
name|num
operator|++
control|)
name|ebb
operator|=
name|ebb
operator|->
name|pred
operator|->
name|src
expr_stmt|;
name|loop
operator|->
name|pre_header_edges
operator|=
name|xmalloc
argument_list|(
name|num
operator|*
sizeof|sizeof
argument_list|(
name|edge
argument_list|)
argument_list|)
expr_stmt|;
name|loop
operator|->
name|num_pre_header_edges
operator|=
name|num
expr_stmt|;
comment|/* Store edges in order that they are followed.  The source of the first edge      is the root node of the pre-header extended basic block and the      destination of the last last edge is the loop header.  */
for|for
control|(
name|e
operator|=
name|loop
operator|->
name|entry_edges
index|[
literal|0
index|]
init|;
name|num
condition|;
name|e
operator|=
name|e
operator|->
name|src
operator|->
name|pred
control|)
name|loop
operator|->
name|pre_header_edges
index|[
operator|--
name|num
index|]
operator|=
name|e
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the block for the pre-header of the loop with header    HEADER.  Return NULL if there is no pre-header.  */
end_comment

begin_function
specifier|static
name|basic_block
name|flow_loop_pre_header_find
parameter_list|(
name|basic_block
name|header
parameter_list|)
block|{
name|basic_block
name|pre_header
decl_stmt|;
name|edge
name|e
decl_stmt|;
comment|/* If block p is a predecessor of the header and is the only block      that the header does not dominate, then it is the pre-header.  */
name|pre_header
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|e
operator|=
name|header
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
block|{
name|basic_block
name|node
init|=
name|e
operator|->
name|src
decl_stmt|;
if|if
condition|(
name|node
operator|!=
name|ENTRY_BLOCK_PTR
operator|&&
operator|!
name|dominated_by_p
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|node
argument_list|,
name|header
argument_list|)
condition|)
block|{
if|if
condition|(
name|pre_header
operator|==
name|NULL
condition|)
name|pre_header
operator|=
name|node
expr_stmt|;
else|else
block|{
comment|/* There are multiple edges into the header from outside 		 the loop so there is no pre-header block.  */
name|pre_header
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
name|pre_header
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|establish_preds
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|struct
name|loop
modifier|*
name|ploop
decl_stmt|,
modifier|*
name|father
init|=
name|loop
operator|->
name|outer
decl_stmt|;
name|loop
operator|->
name|depth
operator|=
name|father
operator|->
name|depth
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|loop
operator|->
name|pred
condition|)
name|free
argument_list|(
name|loop
operator|->
name|pred
argument_list|)
expr_stmt|;
name|loop
operator|->
name|pred
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|loop
operator|*
argument_list|)
operator|*
name|loop
operator|->
name|depth
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|loop
operator|->
name|pred
argument_list|,
name|father
operator|->
name|pred
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|loop
operator|*
argument_list|)
operator|*
name|father
operator|->
name|depth
argument_list|)
expr_stmt|;
name|loop
operator|->
name|pred
index|[
name|father
operator|->
name|depth
index|]
operator|=
name|father
expr_stmt|;
for|for
control|(
name|ploop
operator|=
name|loop
operator|->
name|inner
init|;
name|ploop
condition|;
name|ploop
operator|=
name|ploop
operator|->
name|next
control|)
name|establish_preds
argument_list|(
name|ploop
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add LOOP to the loop hierarchy tree where FATHER is father of the    added loop.  If LOOP has some children, take care of that their    pred field will be initialized correctly.  */
end_comment

begin_function
name|void
name|flow_loop_tree_node_add
parameter_list|(
name|struct
name|loop
modifier|*
name|father
parameter_list|,
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|loop
operator|->
name|next
operator|=
name|father
operator|->
name|inner
expr_stmt|;
name|father
operator|->
name|inner
operator|=
name|loop
expr_stmt|;
name|loop
operator|->
name|outer
operator|=
name|father
expr_stmt|;
name|establish_preds
argument_list|(
name|loop
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove LOOP from the loop hierarchy tree.  */
end_comment

begin_function
name|void
name|flow_loop_tree_node_remove
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|struct
name|loop
modifier|*
name|prev
decl_stmt|,
modifier|*
name|father
decl_stmt|;
name|father
operator|=
name|loop
operator|->
name|outer
expr_stmt|;
name|loop
operator|->
name|outer
operator|=
name|NULL
expr_stmt|;
comment|/* Remove loop from the list of sons.  */
if|if
condition|(
name|father
operator|->
name|inner
operator|==
name|loop
condition|)
name|father
operator|->
name|inner
operator|=
name|loop
operator|->
name|next
expr_stmt|;
else|else
block|{
for|for
control|(
name|prev
operator|=
name|father
operator|->
name|inner
init|;
name|prev
operator|->
name|next
operator|!=
name|loop
condition|;
name|prev
operator|=
name|prev
operator|->
name|next
control|)
empty_stmt|;
name|prev
operator|->
name|next
operator|=
name|loop
operator|->
name|next
expr_stmt|;
block|}
name|loop
operator|->
name|depth
operator|=
operator|-
literal|1
expr_stmt|;
name|free
argument_list|(
name|loop
operator|->
name|pred
argument_list|)
expr_stmt|;
name|loop
operator|->
name|pred
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Helper function to compute loop nesting depth and enclosed loop level    for the natural loop specified by LOOP.  Returns the loop level.  */
end_comment

begin_function
specifier|static
name|int
name|flow_loop_level_compute
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|struct
name|loop
modifier|*
name|inner
decl_stmt|;
name|int
name|level
init|=
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|loop
condition|)
return|return
literal|0
return|;
comment|/* Traverse loop tree assigning depth and computing level as the      maximum level of all the inner loops of this loop.  The loop      level is equivalent to the height of the loop in the loop tree      and corresponds to the number of enclosed loop levels (including      itself).  */
for|for
control|(
name|inner
operator|=
name|loop
operator|->
name|inner
init|;
name|inner
condition|;
name|inner
operator|=
name|inner
operator|->
name|next
control|)
block|{
name|int
name|ilevel
init|=
name|flow_loop_level_compute
argument_list|(
name|inner
argument_list|)
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|ilevel
operator|>
name|level
condition|)
name|level
operator|=
name|ilevel
expr_stmt|;
block|}
name|loop
operator|->
name|level
operator|=
name|level
expr_stmt|;
return|return
name|level
return|;
block|}
end_function

begin_comment
comment|/* Compute the loop nesting depth and enclosed loop level for the loop    hierarchy tree specified by LOOPS.  Return the maximum enclosed loop    level.  */
end_comment

begin_function
specifier|static
name|int
name|flow_loops_level_compute
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|)
block|{
return|return
name|flow_loop_level_compute
argument_list|(
name|loops
operator|->
name|tree_root
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Scan a single natural loop specified by LOOP collecting information    about it specified by FLAGS.  */
end_comment

begin_function
name|int
name|flow_loop_scan
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
if|if
condition|(
name|flags
operator|&
name|LOOP_ENTRY_EDGES
condition|)
block|{
comment|/* Find edges which enter the loop header. 	 Note that the entry edges should only 	 enter the header of a natural loop.  */
name|flow_loop_entry_edges_find
argument_list|(
name|loop
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|LOOP_EXIT_EDGES
condition|)
block|{
comment|/* Find edges which exit the loop.  */
name|flow_loop_exit_edges_find
argument_list|(
name|loop
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|LOOP_PRE_HEADER
condition|)
block|{
comment|/* Look to see if the loop has a pre-header node.  */
name|loop
operator|->
name|pre_header
operator|=
name|flow_loop_pre_header_find
argument_list|(
name|loop
operator|->
name|header
argument_list|)
expr_stmt|;
comment|/* Find the blocks within the extended basic block of 	 the loop pre-header.  */
name|flow_loop_pre_header_scan
argument_list|(
name|loop
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_define
define|#
directive|define
name|HEADER_BLOCK
parameter_list|(
name|B
parameter_list|)
value|(* (int *) (B)->aux)
end_define

begin_define
define|#
directive|define
name|LATCH_EDGE
parameter_list|(
name|E
parameter_list|)
value|(*(int *) (E)->aux)
end_define

begin_comment
comment|/* Redirect edge and update latch and header info.  */
end_comment

begin_function
specifier|static
name|void
name|redirect_edge_with_latch_update
parameter_list|(
name|edge
name|e
parameter_list|,
name|basic_block
name|to
parameter_list|)
block|{
name|basic_block
name|jump
decl_stmt|;
name|jump
operator|=
name|redirect_edge_and_branch_force
argument_list|(
name|e
argument_list|,
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|jump
condition|)
block|{
name|alloc_aux_for_block
argument_list|(
name|jump
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|HEADER_BLOCK
argument_list|(
name|jump
argument_list|)
operator|=
literal|0
expr_stmt|;
name|alloc_aux_for_edge
argument_list|(
name|jump
operator|->
name|pred
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|LATCH_EDGE
argument_list|(
name|jump
operator|->
name|succ
argument_list|)
operator|=
name|LATCH_EDGE
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|LATCH_EDGE
argument_list|(
name|jump
operator|->
name|pred
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Split BB into entry part and rest; if REDIRECT_LATCH, redirect edges    marked as latch into entry part, analogically for REDIRECT_NONLATCH.    In both of these cases, ignore edge EXCEPT.  If CONN_LATCH, set edge    between created entry part and BB as latch one.  Return created entry    part.  */
end_comment

begin_function
specifier|static
name|basic_block
name|make_forwarder_block
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|int
name|redirect_latch
parameter_list|,
name|int
name|redirect_nonlatch
parameter_list|,
name|edge
name|except
parameter_list|,
name|int
name|conn_latch
parameter_list|)
block|{
name|edge
name|e
decl_stmt|,
name|next_e
decl_stmt|,
name|fallthru
decl_stmt|;
name|basic_block
name|dummy
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|first_insn_after_basic_block_note
argument_list|(
name|bb
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For empty block split_block will return NULL.  */
if|if
condition|(
name|BB_END
argument_list|(
name|bb
argument_list|)
operator|==
name|insn
condition|)
name|emit_note_after
argument_list|(
name|NOTE_INSN_DELETED
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|fallthru
operator|=
name|split_block
argument_list|(
name|bb
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|dummy
operator|=
name|fallthru
operator|->
name|src
expr_stmt|;
name|bb
operator|=
name|fallthru
operator|->
name|dest
expr_stmt|;
name|bb
operator|->
name|aux
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|HEADER_BLOCK
argument_list|(
name|dummy
argument_list|)
operator|=
literal|0
expr_stmt|;
name|HEADER_BLOCK
argument_list|(
name|bb
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Redirect back edges we want to keep.  */
for|for
control|(
name|e
operator|=
name|dummy
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|next_e
control|)
block|{
name|next_e
operator|=
name|e
operator|->
name|pred_next
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|except
operator|||
operator|!
operator|(
operator|(
name|redirect_latch
operator|&&
name|LATCH_EDGE
argument_list|(
name|e
argument_list|)
operator|)
operator|||
operator|(
name|redirect_nonlatch
operator|&&
operator|!
name|LATCH_EDGE
argument_list|(
name|e
argument_list|)
operator|)
operator|)
condition|)
block|{
name|dummy
operator|->
name|frequency
operator|-=
name|EDGE_FREQUENCY
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|dummy
operator|->
name|count
operator|-=
name|e
operator|->
name|count
expr_stmt|;
if|if
condition|(
name|dummy
operator|->
name|frequency
operator|<
literal|0
condition|)
name|dummy
operator|->
name|frequency
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dummy
operator|->
name|count
operator|<
literal|0
condition|)
name|dummy
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|redirect_edge_with_latch_update
argument_list|(
name|e
argument_list|,
name|bb
argument_list|)
expr_stmt|;
block|}
block|}
name|alloc_aux_for_edge
argument_list|(
name|fallthru
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|LATCH_EDGE
argument_list|(
name|fallthru
argument_list|)
operator|=
name|conn_latch
expr_stmt|;
return|return
name|dummy
return|;
block|}
end_function

begin_comment
comment|/* Takes care of merging natural loops with shared headers.  */
end_comment

begin_function
specifier|static
name|void
name|canonicalize_loop_headers
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|header
decl_stmt|;
name|edge
name|e
decl_stmt|;
comment|/* Compute the dominators.  */
name|calculate_dominance_info
argument_list|(
name|CDI_DOMINATORS
argument_list|)
expr_stmt|;
name|alloc_aux_for_blocks
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|alloc_aux_for_edges
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Split blocks so that each loop has only single latch.  */
name|FOR_EACH_BB
argument_list|(
argument|header
argument_list|)
block|{
name|int
name|num_latches
init|=
literal|0
decl_stmt|;
name|int
name|have_abnormal_edge
init|=
literal|0
decl_stmt|;
for|for
control|(
name|e
operator|=
name|header
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
block|{
name|basic_block
name|latch
init|=
name|e
operator|->
name|src
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
condition|)
name|have_abnormal_edge
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|latch
operator|!=
name|ENTRY_BLOCK_PTR
operator|&&
name|dominated_by_p
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|latch
argument_list|,
name|header
argument_list|)
condition|)
block|{
name|num_latches
operator|++
expr_stmt|;
name|LATCH_EDGE
argument_list|(
name|e
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|have_abnormal_edge
condition|)
name|HEADER_BLOCK
argument_list|(
name|header
argument_list|)
operator|=
literal|0
expr_stmt|;
else|else
name|HEADER_BLOCK
argument_list|(
name|header
argument_list|)
operator|=
name|num_latches
expr_stmt|;
block|}
name|free_dominance_info
argument_list|(
name|CDI_DOMINATORS
argument_list|)
expr_stmt|;
if|if
condition|(
name|HEADER_BLOCK
argument_list|(
name|ENTRY_BLOCK_PTR
operator|->
name|succ
operator|->
name|dest
argument_list|)
condition|)
block|{
name|basic_block
name|bb
decl_stmt|;
comment|/* We could not redirect edges freely here. On the other hand, 	 we can simply split the edge from entry block.  */
name|bb
operator|=
name|split_edge
argument_list|(
name|ENTRY_BLOCK_PTR
operator|->
name|succ
argument_list|)
expr_stmt|;
name|alloc_aux_for_edge
argument_list|(
name|bb
operator|->
name|succ
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|LATCH_EDGE
argument_list|(
name|bb
operator|->
name|succ
argument_list|)
operator|=
literal|0
expr_stmt|;
name|alloc_aux_for_block
argument_list|(
name|bb
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|HEADER_BLOCK
argument_list|(
name|bb
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|FOR_EACH_BB
argument_list|(
argument|header
argument_list|)
block|{
name|int
name|num_latch
decl_stmt|;
name|int
name|want_join_latch
decl_stmt|;
name|int
name|max_freq
decl_stmt|,
name|is_heavy
decl_stmt|;
name|edge
name|heavy
decl_stmt|;
if|if
condition|(
operator|!
name|HEADER_BLOCK
argument_list|(
name|header
argument_list|)
condition|)
continue|continue;
name|num_latch
operator|=
name|HEADER_BLOCK
argument_list|(
name|header
argument_list|)
expr_stmt|;
name|want_join_latch
operator|=
operator|(
name|num_latch
operator|>
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|want_join_latch
condition|)
continue|continue;
comment|/* Find a heavy edge.  */
name|is_heavy
operator|=
literal|1
expr_stmt|;
name|heavy
operator|=
name|NULL
expr_stmt|;
name|max_freq
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|e
operator|=
name|header
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
if|if
condition|(
name|LATCH_EDGE
argument_list|(
name|e
argument_list|)
operator|&&
name|EDGE_FREQUENCY
argument_list|(
name|e
argument_list|)
operator|>
name|max_freq
condition|)
name|max_freq
operator|=
name|EDGE_FREQUENCY
argument_list|(
name|e
argument_list|)
expr_stmt|;
for|for
control|(
name|e
operator|=
name|header
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
if|if
condition|(
name|LATCH_EDGE
argument_list|(
name|e
argument_list|)
operator|&&
name|EDGE_FREQUENCY
argument_list|(
name|e
argument_list|)
operator|>=
name|max_freq
operator|/
name|HEAVY_EDGE_RATIO
condition|)
block|{
if|if
condition|(
name|heavy
condition|)
block|{
name|is_heavy
operator|=
literal|0
expr_stmt|;
break|break;
block|}
else|else
name|heavy
operator|=
name|e
expr_stmt|;
block|}
if|if
condition|(
name|is_heavy
condition|)
block|{
name|basic_block
name|new_header
init|=
name|make_forwarder_block
argument_list|(
name|header
argument_list|,
name|true
argument_list|,
name|true
argument_list|,
name|heavy
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|num_latch
operator|>
literal|2
condition|)
name|make_forwarder_block
argument_list|(
name|new_header
argument_list|,
name|true
argument_list|,
name|false
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|make_forwarder_block
argument_list|(
name|header
argument_list|,
name|true
argument_list|,
name|false
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|free_aux_for_blocks
argument_list|()
expr_stmt|;
name|free_aux_for_edges
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find all the natural loops in the function and save in LOOPS structure and    recalculate loop_depth information in basic block structures.  FLAGS    controls which loop information is collected.  Return the number of natural    loops found.  */
end_comment

begin_function
name|int
name|flow_loops_find
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|b
decl_stmt|;
name|int
name|num_loops
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|sbitmap
name|headers
decl_stmt|;
name|int
modifier|*
name|dfs_order
decl_stmt|;
name|int
modifier|*
name|rc_order
decl_stmt|;
name|basic_block
name|header
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
comment|/* This function cannot be repeatedly called with different      flags to build up the loop information.  The loop tree      must always be built if this function is called.  */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|LOOP_TREE
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|memset
argument_list|(
name|loops
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|loops
argument_list|)
expr_stmt|;
comment|/* Taking care of this degenerate case makes the rest of      this code simpler.  */
if|if
condition|(
name|n_basic_blocks
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|dfs_order
operator|=
name|NULL
expr_stmt|;
name|rc_order
operator|=
name|NULL
expr_stmt|;
comment|/* Join loops with shared headers.  */
name|canonicalize_loop_headers
argument_list|()
expr_stmt|;
comment|/* Compute the dominators.  */
name|calculate_dominance_info
argument_list|(
name|CDI_DOMINATORS
argument_list|)
expr_stmt|;
comment|/* Count the number of loop headers.  This should be the      same as the number of natural loops.  */
name|headers
operator|=
name|sbitmap_alloc
argument_list|(
name|last_basic_block
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|headers
argument_list|)
expr_stmt|;
name|num_loops
operator|=
literal|0
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|header
argument_list|)
block|{
name|int
name|more_latches
init|=
literal|0
decl_stmt|;
name|header
operator|->
name|loop_depth
operator|=
literal|0
expr_stmt|;
comment|/* If we have an abnormal predecessor, do not consider the 	 loop (not worth the problems).  */
for|for
control|(
name|e
operator|=
name|header
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
condition|)
break|break;
if|if
condition|(
name|e
condition|)
continue|continue;
for|for
control|(
name|e
operator|=
name|header
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
block|{
name|basic_block
name|latch
init|=
name|e
operator|->
name|src
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Look for back edges where a predecessor is dominated 	     by this block.  A natural loop has a single entry 	     node (header) that dominates all the nodes in the 	     loop.  It also has single back edge to the header 	     from a latch node.  */
if|if
condition|(
name|latch
operator|!=
name|ENTRY_BLOCK_PTR
operator|&&
name|dominated_by_p
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|latch
argument_list|,
name|header
argument_list|)
condition|)
block|{
comment|/* Shared headers should be eliminated by now.  */
if|if
condition|(
name|more_latches
condition|)
name|abort
argument_list|()
expr_stmt|;
name|more_latches
operator|=
literal|1
expr_stmt|;
name|SET_BIT
argument_list|(
name|headers
argument_list|,
name|header
operator|->
name|index
argument_list|)
expr_stmt|;
name|num_loops
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* Allocate loop structures.  */
name|loops
operator|->
name|parray
operator|=
name|xcalloc
argument_list|(
name|num_loops
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|loop
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Dummy loop containing whole function.  */
name|loops
operator|->
name|parray
index|[
literal|0
index|]
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|loop
argument_list|)
argument_list|)
expr_stmt|;
name|loops
operator|->
name|parray
index|[
literal|0
index|]
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|loops
operator|->
name|parray
index|[
literal|0
index|]
operator|->
name|inner
operator|=
name|NULL
expr_stmt|;
name|loops
operator|->
name|parray
index|[
literal|0
index|]
operator|->
name|outer
operator|=
name|NULL
expr_stmt|;
name|loops
operator|->
name|parray
index|[
literal|0
index|]
operator|->
name|depth
operator|=
literal|0
expr_stmt|;
name|loops
operator|->
name|parray
index|[
literal|0
index|]
operator|->
name|pred
operator|=
name|NULL
expr_stmt|;
name|loops
operator|->
name|parray
index|[
literal|0
index|]
operator|->
name|num_nodes
operator|=
name|n_basic_blocks
operator|+
literal|2
expr_stmt|;
name|loops
operator|->
name|parray
index|[
literal|0
index|]
operator|->
name|latch
operator|=
name|EXIT_BLOCK_PTR
expr_stmt|;
name|loops
operator|->
name|parray
index|[
literal|0
index|]
operator|->
name|header
operator|=
name|ENTRY_BLOCK_PTR
expr_stmt|;
name|ENTRY_BLOCK_PTR
operator|->
name|loop_father
operator|=
name|loops
operator|->
name|parray
index|[
literal|0
index|]
expr_stmt|;
name|EXIT_BLOCK_PTR
operator|->
name|loop_father
operator|=
name|loops
operator|->
name|parray
index|[
literal|0
index|]
expr_stmt|;
name|loops
operator|->
name|tree_root
operator|=
name|loops
operator|->
name|parray
index|[
literal|0
index|]
expr_stmt|;
comment|/* Find and record information about all the natural loops      in the CFG.  */
name|loops
operator|->
name|num
operator|=
literal|1
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
name|bb
operator|->
name|loop_father
operator|=
name|loops
operator|->
name|tree_root
expr_stmt|;
if|if
condition|(
name|num_loops
condition|)
block|{
comment|/* Compute depth first search order of the CFG so that outer 	 natural loops will be found before inner natural loops.  */
name|dfs_order
operator|=
name|xmalloc
argument_list|(
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|rc_order
operator|=
name|xmalloc
argument_list|(
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|flow_depth_first_order_compute
argument_list|(
name|dfs_order
argument_list|,
name|rc_order
argument_list|)
expr_stmt|;
comment|/* Save CFG derived information to avoid recomputing it.  */
name|loops
operator|->
name|cfg
operator|.
name|dfs_order
operator|=
name|dfs_order
expr_stmt|;
name|loops
operator|->
name|cfg
operator|.
name|rc_order
operator|=
name|rc_order
expr_stmt|;
name|num_loops
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|n_basic_blocks
condition|;
name|b
operator|++
control|)
block|{
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
comment|/* Search the nodes of the CFG in reverse completion order 	     so that we can find outer loops first.  */
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|headers
argument_list|,
name|rc_order
index|[
name|b
index|]
argument_list|)
condition|)
continue|continue;
name|header
operator|=
name|BASIC_BLOCK
argument_list|(
name|rc_order
index|[
name|b
index|]
argument_list|)
expr_stmt|;
name|loop
operator|=
name|loops
operator|->
name|parray
index|[
name|num_loops
index|]
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|loop
argument_list|)
argument_list|)
expr_stmt|;
name|loop
operator|->
name|header
operator|=
name|header
expr_stmt|;
name|loop
operator|->
name|num
operator|=
name|num_loops
expr_stmt|;
name|num_loops
operator|++
expr_stmt|;
comment|/* Look for the latch for this header block.  */
for|for
control|(
name|e
operator|=
name|header
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
block|{
name|basic_block
name|latch
init|=
name|e
operator|->
name|src
decl_stmt|;
if|if
condition|(
name|latch
operator|!=
name|ENTRY_BLOCK_PTR
operator|&&
name|dominated_by_p
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|latch
argument_list|,
name|header
argument_list|)
condition|)
block|{
name|loop
operator|->
name|latch
operator|=
name|latch
expr_stmt|;
break|break;
block|}
block|}
name|flow_loop_tree_node_add
argument_list|(
name|header
operator|->
name|loop_father
argument_list|,
name|loop
argument_list|)
expr_stmt|;
name|loop
operator|->
name|num_nodes
operator|=
name|flow_loop_nodes_find
argument_list|(
name|loop
operator|->
name|header
argument_list|,
name|loop
argument_list|)
expr_stmt|;
block|}
comment|/* Assign the loop nesting depth and enclosed loop level for each 	 loop.  */
name|loops
operator|->
name|levels
operator|=
name|flow_loops_level_compute
argument_list|(
name|loops
argument_list|)
expr_stmt|;
comment|/* Scan the loops.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|num_loops
condition|;
name|i
operator|++
control|)
name|flow_loop_scan
argument_list|(
name|loops
operator|->
name|parray
index|[
name|i
index|]
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|loops
operator|->
name|num
operator|=
name|num_loops
expr_stmt|;
block|}
else|else
block|{
name|free_dominance_info
argument_list|(
name|CDI_DOMINATORS
argument_list|)
expr_stmt|;
block|}
name|sbitmap_free
argument_list|(
name|headers
argument_list|)
expr_stmt|;
name|loops
operator|->
name|state
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|verify_flow_info
argument_list|()
expr_stmt|;
name|verify_loop_structure
argument_list|(
name|loops
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|loops
operator|->
name|num
return|;
block|}
end_function

begin_comment
comment|/* Update the information regarding the loops in the CFG    specified by LOOPS.  */
end_comment

begin_function
name|int
name|flow_loops_update
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
comment|/* One day we may want to update the current loop data.  For now      throw away the old stuff and rebuild what we need.  */
if|if
condition|(
name|loops
operator|->
name|parray
condition|)
name|flow_loops_free
argument_list|(
name|loops
argument_list|)
expr_stmt|;
return|return
name|flow_loops_find
argument_list|(
name|loops
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if basic block BB belongs to LOOP.  */
end_comment

begin_function
name|bool
name|flow_bb_inside_loop_p
parameter_list|(
specifier|const
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
specifier|const
name|basic_block
name|bb
parameter_list|)
block|{
name|struct
name|loop
modifier|*
name|source_loop
decl_stmt|;
if|if
condition|(
name|bb
operator|==
name|ENTRY_BLOCK_PTR
operator|||
name|bb
operator|==
name|EXIT_BLOCK_PTR
condition|)
return|return
literal|0
return|;
name|source_loop
operator|=
name|bb
operator|->
name|loop_father
expr_stmt|;
return|return
name|loop
operator|==
name|source_loop
operator|||
name|flow_loop_nested_p
argument_list|(
name|loop
argument_list|,
name|source_loop
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if edge E enters header of LOOP from outside of LOOP.  */
end_comment

begin_function
name|bool
name|flow_loop_outside_edge_p
parameter_list|(
specifier|const
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|edge
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|->
name|dest
operator|!=
name|loop
operator|->
name|header
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
operator|!
name|flow_bb_inside_loop_p
argument_list|(
name|loop
argument_list|,
name|e
operator|->
name|src
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Enumeration predicate for get_loop_body.  */
end_comment

begin_function
specifier|static
name|bool
name|glb_enum_p
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|void
modifier|*
name|glb_header
parameter_list|)
block|{
return|return
name|bb
operator|!=
operator|(
name|basic_block
operator|)
name|glb_header
return|;
block|}
end_function

begin_comment
comment|/* Gets basic blocks of a LOOP.  Header is the 0-th block, rest is in dfs    order against direction of edges from latch.  Specially, if    header != latch, latch is the 1-st block.  */
end_comment

begin_function
name|basic_block
modifier|*
name|get_loop_body
parameter_list|(
specifier|const
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|basic_block
modifier|*
name|tovisit
decl_stmt|,
name|bb
decl_stmt|;
name|unsigned
name|tv
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|loop
operator|->
name|num_nodes
condition|)
name|abort
argument_list|()
expr_stmt|;
name|tovisit
operator|=
name|xcalloc
argument_list|(
name|loop
operator|->
name|num_nodes
argument_list|,
sizeof|sizeof
argument_list|(
name|basic_block
argument_list|)
argument_list|)
expr_stmt|;
name|tovisit
index|[
name|tv
operator|++
index|]
operator|=
name|loop
operator|->
name|header
expr_stmt|;
if|if
condition|(
name|loop
operator|->
name|latch
operator|==
name|EXIT_BLOCK_PTR
condition|)
block|{
comment|/* There may be blocks unreachable from EXIT_BLOCK.  */
if|if
condition|(
name|loop
operator|->
name|num_nodes
operator|!=
operator|(
name|unsigned
operator|)
name|n_basic_blocks
operator|+
literal|2
condition|)
name|abort
argument_list|()
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
name|tovisit
index|[
name|tv
operator|++
index|]
operator|=
name|bb
expr_stmt|;
name|tovisit
index|[
name|tv
operator|++
index|]
operator|=
name|EXIT_BLOCK_PTR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|loop
operator|->
name|latch
operator|!=
name|loop
operator|->
name|header
condition|)
block|{
name|tv
operator|=
name|dfs_enumerate_from
argument_list|(
name|loop
operator|->
name|latch
argument_list|,
literal|1
argument_list|,
name|glb_enum_p
argument_list|,
name|tovisit
operator|+
literal|1
argument_list|,
name|loop
operator|->
name|num_nodes
operator|-
literal|1
argument_list|,
name|loop
operator|->
name|header
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|tv
operator|!=
name|loop
operator|->
name|num_nodes
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|tovisit
return|;
block|}
end_function

begin_comment
comment|/* Gets exit edges of a LOOP, returning their number in N_EDGES.  */
end_comment

begin_function
name|edge
modifier|*
name|get_loop_exit_edges
parameter_list|(
specifier|const
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|unsigned
name|int
modifier|*
name|n_edges
parameter_list|)
block|{
name|edge
modifier|*
name|edges
decl_stmt|,
name|e
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|n
decl_stmt|;
name|basic_block
modifier|*
name|body
decl_stmt|;
if|if
condition|(
name|loop
operator|->
name|latch
operator|==
name|EXIT_BLOCK_PTR
condition|)
name|abort
argument_list|()
expr_stmt|;
name|body
operator|=
name|get_loop_body
argument_list|(
name|loop
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loop
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
for|for
control|(
name|e
operator|=
name|body
index|[
name|i
index|]
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
if|if
condition|(
operator|!
name|flow_bb_inside_loop_p
argument_list|(
name|loop
argument_list|,
name|e
operator|->
name|dest
argument_list|)
condition|)
name|n
operator|++
expr_stmt|;
name|edges
operator|=
name|xmalloc
argument_list|(
name|n
operator|*
sizeof|sizeof
argument_list|(
name|edge
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|n_edges
operator|=
name|n
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loop
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
for|for
control|(
name|e
operator|=
name|body
index|[
name|i
index|]
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
if|if
condition|(
operator|!
name|flow_bb_inside_loop_p
argument_list|(
name|loop
argument_list|,
name|e
operator|->
name|dest
argument_list|)
condition|)
name|edges
index|[
name|n
operator|++
index|]
operator|=
name|e
expr_stmt|;
name|free
argument_list|(
name|body
argument_list|)
expr_stmt|;
return|return
name|edges
return|;
block|}
end_function

begin_comment
comment|/* Adds basic block BB to LOOP.  */
end_comment

begin_function
name|void
name|add_bb_to_loop
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|bb
operator|->
name|loop_father
operator|=
name|loop
expr_stmt|;
name|bb
operator|->
name|loop_depth
operator|=
name|loop
operator|->
name|depth
expr_stmt|;
name|loop
operator|->
name|num_nodes
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loop
operator|->
name|depth
condition|;
name|i
operator|++
control|)
name|loop
operator|->
name|pred
index|[
name|i
index|]
operator|->
name|num_nodes
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove basic block BB from loops.  */
end_comment

begin_function
name|void
name|remove_bb_from_loops
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop
init|=
name|bb
operator|->
name|loop_father
decl_stmt|;
name|loop
operator|->
name|num_nodes
operator|--
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loop
operator|->
name|depth
condition|;
name|i
operator|++
control|)
name|loop
operator|->
name|pred
index|[
name|i
index|]
operator|->
name|num_nodes
operator|--
expr_stmt|;
name|bb
operator|->
name|loop_father
operator|=
name|NULL
expr_stmt|;
name|bb
operator|->
name|loop_depth
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finds nearest common ancestor in loop tree for given loops.  */
end_comment

begin_function
name|struct
name|loop
modifier|*
name|find_common_loop
parameter_list|(
name|struct
name|loop
modifier|*
name|loop_s
parameter_list|,
name|struct
name|loop
modifier|*
name|loop_d
parameter_list|)
block|{
if|if
condition|(
operator|!
name|loop_s
condition|)
return|return
name|loop_d
return|;
if|if
condition|(
operator|!
name|loop_d
condition|)
return|return
name|loop_s
return|;
if|if
condition|(
name|loop_s
operator|->
name|depth
operator|<
name|loop_d
operator|->
name|depth
condition|)
name|loop_d
operator|=
name|loop_d
operator|->
name|pred
index|[
name|loop_s
operator|->
name|depth
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|loop_s
operator|->
name|depth
operator|>
name|loop_d
operator|->
name|depth
condition|)
name|loop_s
operator|=
name|loop_s
operator|->
name|pred
index|[
name|loop_d
operator|->
name|depth
index|]
expr_stmt|;
while|while
condition|(
name|loop_s
operator|!=
name|loop_d
condition|)
block|{
name|loop_s
operator|=
name|loop_s
operator|->
name|outer
expr_stmt|;
name|loop_d
operator|=
name|loop_d
operator|->
name|outer
expr_stmt|;
block|}
return|return
name|loop_s
return|;
block|}
end_function

begin_comment
comment|/* Cancels the LOOP; it must be innermost one.  */
end_comment

begin_function
name|void
name|cancel_loop
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|,
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|basic_block
modifier|*
name|bbs
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
if|if
condition|(
name|loop
operator|->
name|inner
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Move blocks up one level (they should be removed as soon as possible).  */
name|bbs
operator|=
name|get_loop_body
argument_list|(
name|loop
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loop
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
name|bbs
index|[
name|i
index|]
operator|->
name|loop_father
operator|=
name|loop
operator|->
name|outer
expr_stmt|;
comment|/* Remove the loop from structure.  */
name|flow_loop_tree_node_remove
argument_list|(
name|loop
argument_list|)
expr_stmt|;
comment|/* Remove loop from loops array.  */
name|loops
operator|->
name|parray
index|[
name|loop
operator|->
name|num
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* Free loop data.  */
name|flow_loop_free
argument_list|(
name|loop
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Cancels LOOP and all its subloops.  */
end_comment

begin_function
name|void
name|cancel_loop_tree
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|,
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
while|while
condition|(
name|loop
operator|->
name|inner
condition|)
name|cancel_loop_tree
argument_list|(
name|loops
argument_list|,
name|loop
operator|->
name|inner
argument_list|)
expr_stmt|;
name|cancel_loop
argument_list|(
name|loops
argument_list|,
name|loop
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Checks that LOOPS are all right:      -- sizes of loops are all right      -- results of get_loop_body really belong to the loop      -- loop header have just single entry edge and single latch edge      -- loop latches have only single successor that is header of their loop      -- irreducible loops are correctly marked   */
end_comment

begin_function
name|void
name|verify_loop_structure
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|)
block|{
name|unsigned
modifier|*
name|sizes
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|sbitmap
name|irreds
decl_stmt|;
name|basic_block
modifier|*
name|bbs
decl_stmt|,
name|bb
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|edge
name|e
decl_stmt|;
comment|/* Check sizes.  */
name|sizes
operator|=
name|xcalloc
argument_list|(
name|loops
operator|->
name|num
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|sizes
index|[
literal|0
index|]
operator|=
literal|2
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
for|for
control|(
name|loop
operator|=
name|bb
operator|->
name|loop_father
init|;
name|loop
condition|;
name|loop
operator|=
name|loop
operator|->
name|outer
control|)
name|sizes
index|[
name|loop
operator|->
name|num
index|]
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loops
operator|->
name|num
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|loops
operator|->
name|parray
index|[
name|i
index|]
condition|)
continue|continue;
if|if
condition|(
name|loops
operator|->
name|parray
index|[
name|i
index|]
operator|->
name|num_nodes
operator|!=
name|sizes
index|[
name|i
index|]
condition|)
block|{
name|error
argument_list|(
literal|"Size of loop %d should be %d, not %d."
argument_list|,
name|i
argument_list|,
name|sizes
index|[
name|i
index|]
argument_list|,
name|loops
operator|->
name|parray
index|[
name|i
index|]
operator|->
name|num_nodes
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|sizes
argument_list|)
expr_stmt|;
comment|/* Check get_loop_body.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|loops
operator|->
name|num
condition|;
name|i
operator|++
control|)
block|{
name|loop
operator|=
name|loops
operator|->
name|parray
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|loop
condition|)
continue|continue;
name|bbs
operator|=
name|get_loop_body
argument_list|(
name|loop
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|loop
operator|->
name|num_nodes
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|flow_bb_inside_loop_p
argument_list|(
name|loop
argument_list|,
name|bbs
index|[
name|j
index|]
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"Bb %d do not belong to loop %d."
argument_list|,
name|bbs
index|[
name|j
index|]
operator|->
name|index
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
name|free
argument_list|(
name|bbs
argument_list|)
expr_stmt|;
block|}
comment|/* Check headers and latches.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|loops
operator|->
name|num
condition|;
name|i
operator|++
control|)
block|{
name|loop
operator|=
name|loops
operator|->
name|parray
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|loop
condition|)
continue|continue;
if|if
condition|(
operator|(
name|loops
operator|->
name|state
operator|&
name|LOOPS_HAVE_PREHEADERS
operator|)
operator|&&
operator|(
operator|!
name|loop
operator|->
name|header
operator|->
name|pred
operator|->
name|pred_next
operator|||
name|loop
operator|->
name|header
operator|->
name|pred
operator|->
name|pred_next
operator|->
name|pred_next
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"Loop %d's header does not have exactly 2 entries."
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|loops
operator|->
name|state
operator|&
name|LOOPS_HAVE_SIMPLE_LATCHES
condition|)
block|{
if|if
condition|(
operator|!
name|loop
operator|->
name|latch
operator|->
name|succ
operator|||
name|loop
operator|->
name|latch
operator|->
name|succ
operator|->
name|succ_next
condition|)
block|{
name|error
argument_list|(
literal|"Loop %d's latch does not have exactly 1 successor."
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|loop
operator|->
name|latch
operator|->
name|succ
operator|->
name|dest
operator|!=
name|loop
operator|->
name|header
condition|)
block|{
name|error
argument_list|(
literal|"Loop %d's latch does not have header as successor."
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|loop
operator|->
name|latch
operator|->
name|loop_father
operator|!=
name|loop
condition|)
block|{
name|error
argument_list|(
literal|"Loop %d's latch does not belong directly to it."
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|loop
operator|->
name|header
operator|->
name|loop_father
operator|!=
name|loop
condition|)
block|{
name|error
argument_list|(
literal|"Loop %d's header does not belong directly to it."
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|loops
operator|->
name|state
operator|&
name|LOOPS_HAVE_MARKED_IRREDUCIBLE_REGIONS
operator|)
operator|&&
operator|(
name|loop_latch_edge
argument_list|(
name|loop
argument_list|)
operator|->
name|flags
operator|&
name|EDGE_IRREDUCIBLE_LOOP
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"Loop %d's latch is marked as part of irreducible region."
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Check irreducible loops.  */
if|if
condition|(
name|loops
operator|->
name|state
operator|&
name|LOOPS_HAVE_MARKED_IRREDUCIBLE_REGIONS
condition|)
block|{
comment|/* Record old info.  */
name|irreds
operator|=
name|sbitmap_alloc
argument_list|(
name|last_basic_block
argument_list|)
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
if|if
condition|(
name|bb
operator|->
name|flags
operator|&
name|BB_IRREDUCIBLE_LOOP
condition|)
name|SET_BIT
argument_list|(
name|irreds
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
else|else
name|RESET_BIT
argument_list|(
name|irreds
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_IRREDUCIBLE_LOOP
condition|)
name|e
operator|->
name|flags
operator||=
name|EDGE_ALL_FLAGS
operator|+
literal|1
expr_stmt|;
block|}
comment|/* Recount it.  */
name|mark_irreducible_loops
argument_list|(
name|loops
argument_list|)
expr_stmt|;
comment|/* Compare.  */
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
if|if
condition|(
operator|(
name|bb
operator|->
name|flags
operator|&
name|BB_IRREDUCIBLE_LOOP
operator|)
operator|&&
operator|!
name|TEST_BIT
argument_list|(
name|irreds
argument_list|,
name|bb
operator|->
name|index
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"Basic block %d should be marked irreducible."
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|bb
operator|->
name|flags
operator|&
name|BB_IRREDUCIBLE_LOOP
operator|)
operator|&&
name|TEST_BIT
argument_list|(
name|irreds
argument_list|,
name|bb
operator|->
name|index
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"Basic block %d should not be marked irreducible."
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
block|{
if|if
condition|(
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_IRREDUCIBLE_LOOP
operator|)
operator|&&
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
operator|(
name|EDGE_ALL_FLAGS
operator|+
literal|1
operator|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"Edge from %d to %d should be marked irreducible."
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_IRREDUCIBLE_LOOP
operator|)
operator|&&
operator|(
name|e
operator|->
name|flags
operator|&
operator|(
name|EDGE_ALL_FLAGS
operator|+
literal|1
operator|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"Edge from %d to %d should not be marked irreducible."
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
name|e
operator|->
name|flags
operator|&=
operator|~
operator|(
name|EDGE_ALL_FLAGS
operator|+
literal|1
operator|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|irreds
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns latch edge of LOOP.  */
end_comment

begin_function
name|edge
name|loop_latch_edge
parameter_list|(
specifier|const
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|edge
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|loop
operator|->
name|header
operator|->
name|pred
init|;
name|e
operator|->
name|src
operator|!=
name|loop
operator|->
name|latch
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
continue|continue;
return|return
name|e
return|;
block|}
end_function

begin_comment
comment|/* Returns preheader edge of LOOP.  */
end_comment

begin_function
name|edge
name|loop_preheader_edge
parameter_list|(
specifier|const
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|edge
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|loop
operator|->
name|header
operator|->
name|pred
init|;
name|e
operator|->
name|src
operator|==
name|loop
operator|->
name|latch
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
continue|continue;
return|return
name|e
return|;
block|}
end_function

end_unit

