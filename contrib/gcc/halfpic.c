begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* OSF/rose half-pic support functions.    Copyright (C) 1992, 1997, 1998 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* The OSF/rose half-pic model assumes that the non-library code does    not need to have full PIC (position independent code), but rather,    that pointers to external references are put into the data section    and dereferenced as normal pointers.  References to static data does    not need to be PIC-ized.     Another optimization is to have the compiler know what symbols are    in the shared libraries, and to only lay down the pointers to    things which in the library proper.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HALF_PIC_INIT
end_ifdef

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_function_decl
specifier|extern
name|rtx
name|eliminate_constant_term
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|assemble_name
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|output_addr_const
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|flag_half_pic
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Global half-pic flag.  */
end_comment

begin_decl_stmt
name|int
name|half_pic_number_ptrs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # distinct pointers found */
end_comment

begin_decl_stmt
name|int
name|half_pic_number_refs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # half-pic references */
end_comment

begin_function_decl
name|int
function_decl|(
modifier|*
name|ptr_half_pic_address_p
function_decl|)
parameter_list|()
init|=
name|half_pic_address_p
function_decl|;
end_function_decl

begin_comment
comment|/* Obstack to hold generated pic names.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|half_pic_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of pointers created to pic references.  */
end_comment

begin_struct
struct|struct
name|all_refs
block|{
name|struct
name|all_refs
modifier|*
name|hash_next
decl_stmt|;
comment|/* next name in hash chain */
name|struct
name|all_refs
modifier|*
name|next
decl_stmt|;
comment|/* next name created */
name|int
name|external_p
decl_stmt|;
comment|/* name is an external reference */
name|int
name|pointer_p
decl_stmt|;
comment|/* pointer created.  */
name|char
modifier|*
name|ref_name
decl_stmt|;
comment|/* reference name to ptr to real_name */
name|int
name|ref_len
decl_stmt|;
comment|/* reference name length */
name|char
modifier|*
name|real_name
decl_stmt|;
comment|/* real function/data name */
name|int
name|real_len
decl_stmt|;
comment|/* strlen (real_name) */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|all_refs
modifier|*
name|half_pic_names
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|half_pic_prefix
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|half_pic_prefix_len
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Return the hash bucket of a name or NULL.  The hash chain is    organized as a self reorganizing circularly linked chain.  It is    assumed that any name passed to use will never be reallocated.  For    names in SYMBOL_REF's this is true, because the names are allocated    on the permanent obstack.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MAX_HASH_TABLE
end_ifndef

begin_define
define|#
directive|define
name|MAX_HASH_TABLE
value|1009
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|HASHBITS
value|30
end_define

begin_function
specifier|static
name|struct
name|all_refs
modifier|*
name|half_pic_hash
parameter_list|(
name|name
parameter_list|,
name|len
parameter_list|,
name|create_p
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name to hash */
name|int
name|len
decl_stmt|;
comment|/* length of the name (or 0 to call strlen) */
name|int
name|create_p
decl_stmt|;
comment|/* != 0 to create new hash bucket if new */
block|{
specifier|static
name|struct
name|all_refs
modifier|*
name|hash_table
index|[
name|MAX_HASH_TABLE
index|]
decl_stmt|;
specifier|static
name|struct
name|all_refs
name|zero_all_refs
decl_stmt|;
name|unsigned
name|char
modifier|*
name|uname
decl_stmt|;
name|int
name|hash
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|struct
name|all_refs
modifier|*
name|first
decl_stmt|;
name|struct
name|all_refs
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* Compute hash code */
name|uname
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|name
expr_stmt|;
name|ch
operator|=
name|uname
index|[
literal|0
index|]
expr_stmt|;
name|hash
operator|=
name|len
operator|*
literal|613
operator|+
name|ch
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|+=
literal|2
control|)
name|hash
operator|=
operator|(
name|hash
operator|*
literal|613
operator|)
operator|+
name|uname
index|[
name|i
index|]
expr_stmt|;
name|hash
operator|&=
operator|(
literal|1
operator|<<
name|HASHBITS
operator|)
operator|-
literal|1
expr_stmt|;
name|hash
operator|%=
name|MAX_HASH_TABLE
expr_stmt|;
comment|/* See if the name is in the hash table.  */
name|ptr
operator|=
name|first
operator|=
name|hash_table
index|[
name|hash
index|]
expr_stmt|;
if|if
condition|(
name|ptr
condition|)
block|{
do|do
block|{
if|if
condition|(
name|len
operator|==
name|ptr
operator|->
name|real_len
operator|&&
name|ch
operator|==
operator|*
operator|(
name|ptr
operator|->
name|real_name
operator|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|ptr
operator|->
name|real_name
argument_list|)
condition|)
block|{
name|hash_table
index|[
name|hash
index|]
operator|=
name|ptr
expr_stmt|;
return|return
name|ptr
return|;
block|}
name|ptr
operator|=
name|ptr
operator|->
name|hash_next
expr_stmt|;
block|}
do|while
condition|(
name|ptr
operator|!=
name|first
condition|)
do|;
block|}
comment|/* name not in hash table.  */
if|if
condition|(
operator|!
name|create_p
condition|)
return|return
operator|(
expr|struct
name|all_refs
operator|*
operator|)
literal|0
return|;
name|ptr
operator|=
operator|(
expr|struct
name|all_refs
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|half_pic_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|all_refs
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|=
name|zero_all_refs
expr_stmt|;
name|ptr
operator|->
name|real_name
operator|=
name|name
expr_stmt|;
name|ptr
operator|->
name|real_len
operator|=
name|len
expr_stmt|;
comment|/* Update circular links.  */
if|if
condition|(
name|first
operator|==
operator|(
expr|struct
name|all_refs
operator|*
operator|)
literal|0
condition|)
name|ptr
operator|->
name|hash_next
operator|=
name|ptr
expr_stmt|;
else|else
block|{
name|ptr
operator|->
name|hash_next
operator|=
name|first
operator|->
name|hash_next
expr_stmt|;
name|first
operator|->
name|hash_next
operator|=
name|ptr
expr_stmt|;
block|}
name|hash_table
index|[
name|hash
index|]
operator|=
name|ptr
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Do any half-pic initializations.  */
end_comment

begin_function
name|void
name|half_pic_init
parameter_list|()
block|{
name|flag_half_pic
operator|=
name|TRUE
expr_stmt|;
name|half_pic_prefix
operator|=
name|HALF_PIC_PREFIX
expr_stmt|;
name|half_pic_prefix_len
operator|=
name|strlen
argument_list|(
name|half_pic_prefix
argument_list|)
expr_stmt|;
name|obstack_init
argument_list|(
operator|&
name|half_pic_obstack
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Write out all pointers to pic references.  */
end_comment

begin_function
name|void
name|half_pic_finish
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|struct
name|all_refs
modifier|*
name|p
init|=
name|half_pic_names
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
return|return;
name|data_section
argument_list|()
expr_stmt|;
for|for
control|(
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
comment|/* Emit the pointer if used.  */
if|if
condition|(
name|p
operator|->
name|pointer_p
condition|)
block|{
name|ASM_OUTPUT_LABEL
argument_list|(
name|stream
argument_list|,
name|p
operator|->
name|ref_name
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INT
argument_list|(
name|stream
argument_list|,
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|p
operator|->
name|real_name
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Encode in a declaration whether or not it is half-pic.  */
end_comment

begin_function
name|void
name|half_pic_encode
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|tree
name|asm_name
decl_stmt|;
name|struct
name|all_refs
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
operator|!
name|flag_half_pic
condition|)
return|return;
if|if
condition|(
name|code
operator|!=
name|VAR_DECL
operator|&&
name|code
operator|!=
name|FUNCTION_DECL
condition|)
return|return;
name|asm_name
operator|=
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|asm_name
condition|)
return|return;
ifdef|#
directive|ifdef
name|HALF_PIC_DEBUG
if|if
condition|(
name|HALF_PIC_DEBUG
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n========== Half_pic_encode %.*s\n"
argument_list|,
name|IDENTIFIER_LENGTH
argument_list|(
name|asm_name
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|asm_name
argument_list|)
argument_list|)
expr_stmt|;
name|debug_tree
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* If this is not an external reference, it can't be half-pic.  */
if|if
condition|(
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
name|code
operator|!=
name|VAR_DECL
operator|||
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
return|return;
name|ptr
operator|=
name|half_pic_hash
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|asm_name
argument_list|)
argument_list|,
name|IDENTIFIER_LENGTH
argument_list|(
name|asm_name
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|external_p
operator|=
name|TRUE
expr_stmt|;
ifdef|#
directive|ifdef
name|HALF_PIC_DEBUG
if|if
condition|(
name|HALF_PIC_DEBUG
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n%.*s is half-pic\n"
argument_list|,
name|IDENTIFIER_LENGTH
argument_list|(
name|asm_name
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|asm_name
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Mark that an object is now local, and no longer needs half-pic.  */
end_comment

begin_function
name|void
name|half_pic_declare
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|all_refs
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
operator|!
name|flag_half_pic
condition|)
return|return;
name|ptr
operator|=
name|half_pic_hash
argument_list|(
name|name
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
return|return;
name|ptr
operator|->
name|external_p
operator|=
name|FALSE
expr_stmt|;
ifdef|#
directive|ifdef
name|HALF_PIC_DEBUG
if|if
condition|(
name|HALF_PIC_DEBUG
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n========== Half_pic_declare %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Mark that an object is explicitly external.  */
end_comment

begin_function
name|void
name|half_pic_external
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|all_refs
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
operator|!
name|flag_half_pic
condition|)
return|return;
name|ptr
operator|=
name|half_pic_hash
argument_list|(
name|name
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
return|return;
name|ptr
operator|->
name|external_p
operator|=
name|TRUE
expr_stmt|;
ifdef|#
directive|ifdef
name|HALF_PIC_DEBUG
if|if
condition|(
name|HALF_PIC_DEBUG
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n========== Half_pic_external %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return whether an address is half-pic.  */
end_comment

begin_function
name|int
name|half_pic_address_p
parameter_list|(
name|addr
parameter_list|)
name|rtx
name|addr
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|len
decl_stmt|;
name|struct
name|all_refs
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
operator|!
name|flag_half_pic
condition|)
return|return
name|FALSE
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
condition|)
block|{
default|default:
break|break;
case|case
name|CONST
case|:
block|{
name|rtx
name|offset
init|=
name|const0_rtx
decl_stmt|;
name|addr
operator|=
name|eliminate_constant_term
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* fall through */
case|case
name|SYMBOL_REF
case|:
name|name
operator|=
name|XSTR
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HALF_PIC_DEBUG
if|if
condition|(
name|HALF_PIC_DEBUG
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n========== Half_pic_address_p %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If this is a label, it will have a '*' in front of it.  */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
return|return
name|FALSE
return|;
comment|/* If this is a reference to the actual half-pic pointer, it 	 is obviously not half-pic.  */
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|half_pic_prefix_len
operator|&&
name|half_pic_prefix
index|[
literal|0
index|]
operator|==
name|name
index|[
literal|0
index|]
operator|&&
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
name|half_pic_prefix
argument_list|,
name|half_pic_prefix_len
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|ptr
operator|=
name|half_pic_hash
argument_list|(
name|name
argument_list|,
name|len
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
operator|(
expr|struct
name|all_refs
operator|*
operator|)
literal|0
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|ptr
operator|->
name|external_p
condition|)
block|{
ifdef|#
directive|ifdef
name|HALF_PIC_DEBUG
if|if
condition|(
name|HALF_PIC_DEBUG
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s is half-pic\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|TRUE
return|;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the name of the pointer to the PIC function, allocating    it if need be.  */
end_comment

begin_function
name|struct
name|rtx_def
modifier|*
name|half_pic_ptr
parameter_list|(
name|operand
parameter_list|)
name|rtx
name|operand
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|all_refs
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
return|return
name|operand
return|;
name|name
operator|=
name|XSTR
argument_list|(
name|operand
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|p
operator|=
name|half_pic_hash
argument_list|(
name|name
argument_list|,
name|len
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
operator|(
expr|struct
name|all_refs
operator|*
operator|)
literal|0
operator|||
operator|!
name|p
operator|->
name|external_p
condition|)
return|return
name|operand
return|;
if|if
condition|(
operator|!
name|p
operator|->
name|pointer_p
condition|)
block|{
comment|/* first time, create pointer */
name|obstack_grow
argument_list|(
operator|&
name|half_pic_obstack
argument_list|,
name|half_pic_prefix
argument_list|,
name|half_pic_prefix_len
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|half_pic_obstack
argument_list|,
name|name
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|half_pic_names
expr_stmt|;
name|p
operator|->
name|ref_name
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_finish
argument_list|(
operator|&
name|half_pic_obstack
argument_list|)
expr_stmt|;
name|p
operator|->
name|ref_len
operator|=
name|len
operator|+
name|half_pic_prefix_len
expr_stmt|;
name|p
operator|->
name|pointer_p
operator|=
name|TRUE
expr_stmt|;
name|half_pic_names
operator|=
name|p
expr_stmt|;
name|half_pic_number_ptrs
operator|++
expr_stmt|;
block|}
name|half_pic_number_refs
operator|++
expr_stmt|;
return|return
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|p
operator|->
name|ref_name
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HALF_PIC_INIT */
end_comment

end_unit

