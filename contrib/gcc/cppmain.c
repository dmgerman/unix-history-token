begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* CPP main program, using CPP Library.    Copyright (C) 1995, 1997 Free Software Foundation, Inc.    Written by Per Bothner, 1994-95.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.   In other words, you are welcome to use, share and improve this program.  You are forbidden to forbid anyone else to use, share and improve  what you give them.   Help stamp out software-hoarding!  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|EMACS
end_ifndef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"gansidecl.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_function_decl
specifier|extern
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not EMACS */
end_comment

begin_include
include|#
directive|include
file|"cpplib.h"
end_include

begin_decl_stmt
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|cpp_reader
name|parse_in
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|cpp_options
name|options
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|abort
end_ifdef

begin_comment
comment|/* More 'friendly' abort that prints the line and file.    config.h can #define abort fancy_abort if you like that sort of thing.  */
end_comment

begin_function
name|void
name|fatal
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|fputs
argument_list|(
name|s
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fancy_abort
parameter_list|()
block|{
name|fatal
argument_list|(
literal|"Internal gcc abort."
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|argi
init|=
literal|1
decl_stmt|;
comment|/* Next argument to handle.  */
name|struct
name|cpp_options
modifier|*
name|opts
init|=
operator|&
name|options
decl_stmt|;
name|p
operator|=
name|argv
index|[
literal|0
index|]
operator|+
name|strlen
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|argv
index|[
literal|0
index|]
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
operator|--
name|p
expr_stmt|;
name|progname
operator|=
name|p
expr_stmt|;
name|cpp_reader_init
argument_list|(
operator|&
name|parse_in
argument_list|)
expr_stmt|;
name|parse_in
operator|.
name|data
operator|=
name|opts
expr_stmt|;
name|cpp_options_init
argument_list|(
name|opts
argument_list|)
expr_stmt|;
name|argi
operator|+=
name|cpp_handle_options
argument_list|(
operator|&
name|parse_in
argument_list|,
name|argc
operator|-
name|argi
argument_list|,
name|argv
operator|+
name|argi
argument_list|)
expr_stmt|;
if|if
condition|(
name|argi
operator|<
name|argc
operator|&&
operator|!
name|CPP_FATAL_ERRORS
argument_list|(
operator|&
name|parse_in
argument_list|)
condition|)
name|cpp_fatal
argument_list|(
operator|&
name|parse_in
argument_list|,
literal|"Invalid option `%s'"
argument_list|,
name|argv
index|[
name|argi
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|CPP_FATAL_ERRORS
argument_list|(
operator|&
name|parse_in
argument_list|)
condition|)
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
name|parse_in
operator|.
name|show_column
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|cpp_start_read
argument_list|(
operator|&
name|parse_in
argument_list|,
name|opts
operator|->
name|in_fname
argument_list|)
condition|)
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
comment|/* Now that we know the input file is valid, open the output.  */
if|if
condition|(
operator|!
name|opts
operator|->
name|out_fname
operator|||
operator|!
name|strcmp
argument_list|(
name|opts
operator|->
name|out_fname
argument_list|,
literal|""
argument_list|)
condition|)
name|opts
operator|->
name|out_fname
operator|=
literal|"stdout"
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|freopen
argument_list|(
name|opts
operator|->
name|out_fname
argument_list|,
literal|"w"
argument_list|,
name|stdout
argument_list|)
condition|)
name|cpp_pfatal_with_name
argument_list|(
operator|&
name|parse_in
argument_list|,
name|opts
operator|->
name|out_fname
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|enum
name|cpp_token
name|kind
decl_stmt|;
if|if
condition|(
operator|!
name|opts
operator|->
name|no_output
condition|)
block|{
name|fwrite
argument_list|(
name|parse_in
operator|.
name|token_buffer
argument_list|,
literal|1
argument_list|,
name|CPP_WRITTEN
argument_list|(
operator|&
name|parse_in
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
name|CPP_SET_WRITTEN
argument_list|(
operator|&
name|parse_in
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|kind
operator|=
name|cpp_get_token
argument_list|(
operator|&
name|parse_in
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|CPP_EOF
condition|)
break|break;
block|}
name|cpp_finish
argument_list|(
operator|&
name|parse_in
argument_list|)
expr_stmt|;
if|if
condition|(
name|parse_in
operator|.
name|errors
condition|)
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|SUCCESS_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

