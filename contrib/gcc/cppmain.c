begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* CPP main program, using CPP Library.    Copyright (C) 1995 Free Software Foundation, Inc.    Written by Per Bothner, 1994-95.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.   In other words, you are welcome to use, share and improve this program.  You are forbidden to forbid anyone else to use, share and improve  what you give them.   Help stamp out software-hoarding!  */
end_comment

begin_include
include|#
directive|include
file|"cpplib.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|EMACS
end_ifndef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not EMACS */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|cpp_reader
name|parse_in
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|cpp_options
name|options
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* More 'friendly' abort that prints the line and file.    config.h can #define abort fancy_abort if you like that sort of thing.  */
end_comment

begin_function
name|void
name|fancy_abort
parameter_list|()
block|{
name|fatal
argument_list|(
literal|"Internal gcc abort."
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|argi
init|=
literal|1
decl_stmt|;
comment|/* Next argument to handle. */
name|struct
name|cpp_options
modifier|*
name|opts
init|=
operator|&
name|options
decl_stmt|;
name|p
operator|=
name|argv
index|[
literal|0
index|]
operator|+
name|strlen
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|argv
index|[
literal|0
index|]
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
operator|--
name|p
expr_stmt|;
name|progname
operator|=
name|p
expr_stmt|;
name|init_parse_file
argument_list|(
operator|&
name|parse_in
argument_list|)
expr_stmt|;
name|parse_in
operator|.
name|data
operator|=
name|opts
expr_stmt|;
name|init_parse_options
argument_list|(
name|opts
argument_list|)
expr_stmt|;
name|argi
operator|+=
name|cpp_handle_options
argument_list|(
operator|&
name|parse_in
argument_list|,
name|argc
operator|-
name|argi
argument_list|,
name|argv
operator|+
name|argi
argument_list|)
expr_stmt|;
if|if
condition|(
name|argi
operator|<
name|argc
condition|)
name|fatal
argument_list|(
literal|"Invalid option `%s'"
argument_list|,
name|argv
index|[
name|argi
index|]
argument_list|)
expr_stmt|;
name|parse_in
operator|.
name|show_column
operator|=
literal|1
expr_stmt|;
name|i
operator|=
name|push_parse_file
argument_list|(
operator|&
name|parse_in
argument_list|,
name|opts
operator|->
name|in_fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|SUCCESS_EXIT_CODE
condition|)
return|return
name|i
return|;
comment|/* Now that we know the input file is valid, open the output.  */
if|if
condition|(
operator|!
name|opts
operator|->
name|out_fname
operator|||
operator|!
name|strcmp
argument_list|(
name|opts
operator|->
name|out_fname
argument_list|,
literal|""
argument_list|)
condition|)
name|opts
operator|->
name|out_fname
operator|=
literal|"stdout"
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|freopen
argument_list|(
name|opts
operator|->
name|out_fname
argument_list|,
literal|"w"
argument_list|,
name|stdout
argument_list|)
condition|)
name|cpp_pfatal_with_name
argument_list|(
operator|&
name|parse_in
argument_list|,
name|opts
operator|->
name|out_fname
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|enum
name|cpp_token
name|kind
decl_stmt|;
if|if
condition|(
operator|!
name|opts
operator|->
name|no_output
condition|)
block|{
name|fwrite
argument_list|(
name|parse_in
operator|.
name|token_buffer
argument_list|,
literal|1
argument_list|,
name|CPP_WRITTEN
argument_list|(
operator|&
name|parse_in
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
name|parse_in
operator|.
name|limit
operator|=
name|parse_in
operator|.
name|token_buffer
expr_stmt|;
name|kind
operator|=
name|cpp_get_token
argument_list|(
operator|&
name|parse_in
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|CPP_EOF
condition|)
break|break;
block|}
name|cpp_finish
argument_list|(
operator|&
name|parse_in
argument_list|)
expr_stmt|;
if|if
condition|(
name|parse_in
operator|.
name|errors
condition|)
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|SUCCESS_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

