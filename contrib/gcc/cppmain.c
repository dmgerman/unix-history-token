begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* CPP main program, using CPP Library.    Copyright (C) 1995, 1997, 1998, 1999, 2000, 2001, 2002    Free Software Foundation, Inc.    Written by Per Bothner, 1994-95.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.   In other words, you are welcome to use, share and improve this program.  You are forbidden to forbid anyone else to use, share and improve  what you give them.   Help stamp out software-hoarding!  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"cpplib.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_comment
comment|/* Encapsulates state used to convert the stream of tokens coming from    cpp_get_token back into a text file.  */
end_comment

begin_struct
struct|struct
name|printer
block|{
name|FILE
modifier|*
name|outf
decl_stmt|;
comment|/* Stream to write to.  */
specifier|const
name|struct
name|line_map
modifier|*
name|map
decl_stmt|;
comment|/* Logical to physical line mappings.  */
specifier|const
name|cpp_token
modifier|*
name|prev
decl_stmt|;
comment|/* Previous token.  */
specifier|const
name|cpp_token
modifier|*
name|source
decl_stmt|;
comment|/* Source token for spacing.  */
name|unsigned
name|int
name|line
decl_stmt|;
comment|/* Line currently being written.  */
name|unsigned
name|char
name|printed
decl_stmt|;
comment|/* Nonzero if something output at line.  */
block|}
struct|;
end_struct

begin_decl_stmt
name|int
decl|main
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|general_init
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_preprocessing
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|setup_callbacks
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* General output routines.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|scan_translation_unit
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|check_multiline_token
name|PARAMS
argument_list|(
operator|(
specifier|const
name|cpp_string
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dump_macro
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|cpp_hashnode
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_line
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|line_map
operator|*
operator|,
name|unsigned
name|int
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|maybe_print_line
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|line_map
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Callback routines for the parser.   Most of these are active only    in specific modes.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|cb_line_change
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
specifier|const
name|cpp_token
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cb_define
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|unsigned
name|int
operator|,
name|cpp_hashnode
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cb_undef
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|unsigned
name|int
operator|,
name|cpp_hashnode
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cb_include
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|unsigned
name|int
operator|,
specifier|const
name|unsigned
name|char
operator|*
operator|,
specifier|const
name|cpp_token
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cb_ident
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|unsigned
name|int
operator|,
specifier|const
name|cpp_string
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cb_file_change
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
specifier|const
expr|struct
name|line_map
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cb_def_pragma
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Needs to be global.  */
end_comment

begin_decl_stmt
specifier|static
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* An opaque handle.  */
end_comment

begin_decl_stmt
specifier|static
name|cpp_options
modifier|*
name|options
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Options of pfile.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|printer
name|print
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|general_init
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Construct a reader with default language GNU C89.  */
name|pfile
operator|=
name|cpp_create_reader
argument_list|(
name|CLK_GNUC89
argument_list|)
expr_stmt|;
name|options
operator|=
name|cpp_get_options
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|do_preprocessing
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpp_destroy
argument_list|(
name|pfile
argument_list|)
condition|)
return|return
name|FATAL_EXIT_CODE
return|;
return|return
name|SUCCESS_EXIT_CODE
return|;
block|}
end_function

begin_comment
comment|/* Store the program name, and set the locale.  */
end_comment

begin_function
specifier|static
name|void
name|general_init
parameter_list|(
name|argv0
parameter_list|)
specifier|const
name|char
modifier|*
name|argv0
decl_stmt|;
block|{
name|progname
operator|=
name|argv0
operator|+
name|strlen
argument_list|(
name|argv0
argument_list|)
expr_stmt|;
while|while
condition|(
name|progname
operator|!=
name|argv0
operator|&&
operator|!
name|IS_DIR_SEPARATOR
argument_list|(
name|progname
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
operator|--
name|progname
expr_stmt|;
name|xmalloc_set_program_name
argument_list|(
name|progname
argument_list|)
expr_stmt|;
name|hex_init
argument_list|()
expr_stmt|;
name|gcc_init_libintl
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle switches, preprocess and output.  */
end_comment

begin_function
specifier|static
name|void
name|do_preprocessing
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|argi
init|=
literal|1
decl_stmt|;
comment|/* Next argument to handle.  */
name|argi
operator|+=
name|cpp_handle_options
argument_list|(
name|pfile
argument_list|,
name|argc
operator|-
name|argi
argument_list|,
name|argv
operator|+
name|argi
argument_list|)
expr_stmt|;
if|if
condition|(
name|CPP_FATAL_ERRORS
argument_list|(
name|pfile
argument_list|)
condition|)
return|return;
if|if
condition|(
name|argi
operator|<
name|argc
condition|)
block|{
name|cpp_fatal
argument_list|(
name|pfile
argument_list|,
literal|"invalid option %s"
argument_list|,
name|argv
index|[
name|argi
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
name|cpp_post_options
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|CPP_FATAL_ERRORS
argument_list|(
name|pfile
argument_list|)
condition|)
return|return;
comment|/* If cpp_handle_options saw --help or --version on the command      line, it will have set pfile->help_only to indicate this.  Exit      successfully.  [The library does not exit itself, because      e.g. cc1 needs to print its own --help message at this point.]  */
if|if
condition|(
name|options
operator|->
name|help_only
condition|)
return|return;
comment|/* Initialize the printer structure.  Setting print.line to -1 here      is a trick to guarantee that the first token of the file will      cause a linemarker to be output by maybe_print_line.  */
name|print
operator|.
name|line
operator|=
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
expr_stmt|;
name|print
operator|.
name|printed
operator|=
literal|0
expr_stmt|;
name|print
operator|.
name|prev
operator|=
literal|0
expr_stmt|;
name|print
operator|.
name|map
operator|=
literal|0
expr_stmt|;
comment|/* Open the output now.  We must do so even if no_output is on,      because there may be other output than from the actual      preprocessing (e.g. from -dM).  */
if|if
condition|(
name|options
operator|->
name|out_fname
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|print
operator|.
name|outf
operator|=
name|stdout
expr_stmt|;
else|else
block|{
name|print
operator|.
name|outf
operator|=
name|fopen
argument_list|(
name|options
operator|->
name|out_fname
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|print
operator|.
name|outf
operator|==
name|NULL
condition|)
block|{
name|cpp_notice_from_errno
argument_list|(
name|pfile
argument_list|,
name|options
operator|->
name|out_fname
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|setup_callbacks
argument_list|()
expr_stmt|;
if|if
condition|(
name|cpp_read_main_file
argument_list|(
name|pfile
argument_list|,
name|options
operator|->
name|in_fname
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|cpp_finish_options
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
comment|/* A successful cpp_read_main_file guarantees that we can call 	 cpp_scan_nooutput or cpp_get_token next.  */
if|if
condition|(
name|options
operator|->
name|no_output
condition|)
name|cpp_scan_nooutput
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
else|else
name|scan_translation_unit
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
comment|/* -dM command line option.  Should this be in cpp_finish?  */
if|if
condition|(
name|options
operator|->
name|dump_macros
operator|==
name|dump_only
condition|)
name|cpp_forall_identifiers
argument_list|(
name|pfile
argument_list|,
name|dump_macro
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cpp_finish
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
comment|/* Flush any pending output.  */
if|if
condition|(
name|print
operator|.
name|printed
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|print
operator|.
name|outf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|print
operator|.
name|outf
argument_list|)
operator|||
name|fclose
argument_list|(
name|print
operator|.
name|outf
argument_list|)
condition|)
name|cpp_notice_from_errno
argument_list|(
name|pfile
argument_list|,
name|options
operator|->
name|out_fname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set up the callbacks as appropriate.  */
end_comment

begin_function
specifier|static
name|void
name|setup_callbacks
parameter_list|()
block|{
name|cpp_callbacks
modifier|*
name|cb
init|=
name|cpp_get_callbacks
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|options
operator|->
name|no_output
condition|)
block|{
name|cb
operator|->
name|line_change
operator|=
name|cb_line_change
expr_stmt|;
name|cb
operator|->
name|ident
operator|=
name|cb_ident
expr_stmt|;
name|cb
operator|->
name|def_pragma
operator|=
name|cb_def_pragma
expr_stmt|;
if|if
condition|(
operator|!
name|options
operator|->
name|no_line_commands
condition|)
name|cb
operator|->
name|file_change
operator|=
name|cb_file_change
expr_stmt|;
block|}
if|if
condition|(
name|options
operator|->
name|dump_includes
condition|)
name|cb
operator|->
name|include
operator|=
name|cb_include
expr_stmt|;
if|if
condition|(
name|options
operator|->
name|dump_macros
operator|==
name|dump_names
operator|||
name|options
operator|->
name|dump_macros
operator|==
name|dump_definitions
condition|)
block|{
name|cb
operator|->
name|define
operator|=
name|cb_define
expr_stmt|;
name|cb
operator|->
name|undef
operator|=
name|cb_undef
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Writes out the preprocessed file, handling spacing and paste    avoidance issues.  */
end_comment

begin_function
specifier|static
name|void
name|scan_translation_unit
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|bool
name|avoid_paste
init|=
name|false
decl_stmt|;
name|print
operator|.
name|source
operator|=
name|NULL
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|const
name|cpp_token
modifier|*
name|token
init|=
name|cpp_get_token
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_PADDING
condition|)
block|{
name|avoid_paste
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|print
operator|.
name|source
operator|==
name|NULL
operator|||
operator|(
operator|!
operator|(
name|print
operator|.
name|source
operator|->
name|flags
operator|&
name|PREV_WHITE
operator|)
operator|&&
name|token
operator|->
name|val
operator|.
name|source
operator|==
name|NULL
operator|)
condition|)
name|print
operator|.
name|source
operator|=
name|token
operator|->
name|val
operator|.
name|source
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_EOF
condition|)
break|break;
comment|/* Subtle logic to output a space if and only if necessary.  */
if|if
condition|(
name|avoid_paste
condition|)
block|{
if|if
condition|(
name|print
operator|.
name|source
operator|==
name|NULL
condition|)
name|print
operator|.
name|source
operator|=
name|token
expr_stmt|;
if|if
condition|(
name|print
operator|.
name|source
operator|->
name|flags
operator|&
name|PREV_WHITE
operator|||
operator|(
name|print
operator|.
name|prev
operator|&&
name|cpp_avoid_paste
argument_list|(
name|pfile
argument_list|,
name|print
operator|.
name|prev
argument_list|,
name|token
argument_list|)
operator|)
operator|||
operator|(
name|print
operator|.
name|prev
operator|==
name|NULL
operator|&&
name|token
operator|->
name|type
operator|==
name|CPP_HASH
operator|)
condition|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|print
operator|.
name|outf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|->
name|flags
operator|&
name|PREV_WHITE
condition|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|print
operator|.
name|outf
argument_list|)
expr_stmt|;
name|avoid_paste
operator|=
name|false
expr_stmt|;
name|print
operator|.
name|source
operator|=
name|NULL
expr_stmt|;
name|print
operator|.
name|prev
operator|=
name|token
expr_stmt|;
name|cpp_output_token
argument_list|(
name|token
argument_list|,
name|print
operator|.
name|outf
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_STRING
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_WSTRING
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_COMMENT
condition|)
name|check_multiline_token
argument_list|(
operator|&
name|token
operator|->
name|val
operator|.
name|str
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Adjust print.line for newlines embedded in tokens.  */
end_comment

begin_function
specifier|static
name|void
name|check_multiline_token
parameter_list|(
name|str
parameter_list|)
specifier|const
name|cpp_string
modifier|*
name|str
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|str
operator|->
name|len
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|str
operator|->
name|text
index|[
name|i
index|]
operator|==
literal|'\n'
condition|)
name|print
operator|.
name|line
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If the token read on logical line LINE needs to be output on a    different line to the current one, output the required newlines or    a line marker, and return 1.  Otherwise return 0.  */
end_comment

begin_function
specifier|static
name|void
name|maybe_print_line
parameter_list|(
name|map
parameter_list|,
name|line
parameter_list|)
specifier|const
name|struct
name|line_map
modifier|*
name|map
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
block|{
comment|/* End the previous line of text.  */
if|if
condition|(
name|print
operator|.
name|printed
condition|)
block|{
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|print
operator|.
name|outf
argument_list|)
expr_stmt|;
name|print
operator|.
name|line
operator|++
expr_stmt|;
name|print
operator|.
name|printed
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|line
operator|>=
name|print
operator|.
name|line
operator|&&
name|line
operator|<
name|print
operator|.
name|line
operator|+
literal|8
condition|)
block|{
while|while
condition|(
name|line
operator|>
name|print
operator|.
name|line
condition|)
block|{
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|print
operator|.
name|outf
argument_list|)
expr_stmt|;
name|print
operator|.
name|line
operator|++
expr_stmt|;
block|}
block|}
else|else
name|print_line
argument_list|(
name|map
argument_list|,
name|line
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output a line marker for logical line LINE.  Special flags are "1"    or "2" indicating entering or leaving a file.  */
end_comment

begin_function
specifier|static
name|void
name|print_line
parameter_list|(
name|map
parameter_list|,
name|line
parameter_list|,
name|special_flags
parameter_list|)
specifier|const
name|struct
name|line_map
modifier|*
name|map
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
specifier|const
name|char
modifier|*
name|special_flags
decl_stmt|;
block|{
comment|/* End any previous line of text.  */
if|if
condition|(
name|print
operator|.
name|printed
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|print
operator|.
name|outf
argument_list|)
expr_stmt|;
name|print
operator|.
name|printed
operator|=
literal|0
expr_stmt|;
name|print
operator|.
name|line
operator|=
name|line
expr_stmt|;
if|if
condition|(
operator|!
name|options
operator|->
name|no_line_commands
condition|)
block|{
name|fprintf
argument_list|(
name|print
operator|.
name|outf
argument_list|,
literal|"# %u \"%s\"%s"
argument_list|,
name|SOURCE_LINE
argument_list|(
name|map
argument_list|,
name|print
operator|.
name|line
argument_list|)
argument_list|,
name|map
operator|->
name|to_file
argument_list|,
name|special_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|->
name|sysp
operator|==
literal|2
condition|)
name|fputs
argument_list|(
literal|" 3 4"
argument_list|,
name|print
operator|.
name|outf
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|map
operator|->
name|sysp
operator|==
literal|1
condition|)
name|fputs
argument_list|(
literal|" 3"
argument_list|,
name|print
operator|.
name|outf
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|print
operator|.
name|outf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Called when a line of output is started.  TOKEN is the first token    of the line, and at end of file will be CPP_EOF.  */
end_comment

begin_function
specifier|static
name|void
name|cb_line_change
parameter_list|(
name|pfile
parameter_list|,
name|token
parameter_list|,
name|parsing_args
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|cpp_token
modifier|*
name|token
decl_stmt|;
name|int
name|parsing_args
decl_stmt|;
block|{
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_EOF
operator|||
name|parsing_args
condition|)
return|return;
name|maybe_print_line
argument_list|(
name|print
operator|.
name|map
argument_list|,
name|token
operator|->
name|line
argument_list|)
expr_stmt|;
name|print
operator|.
name|printed
operator|=
literal|1
expr_stmt|;
name|print
operator|.
name|prev
operator|=
literal|0
expr_stmt|;
name|print
operator|.
name|source
operator|=
literal|0
expr_stmt|;
comment|/* Supply enough spaces to put this token in its original column,      one space per column greater than 2, since scan_translation_unit      will provide a space if PREV_WHITE.  Don't bother trying to      reconstruct tabs; we can't get it right in general, and nothing      ought to care.  Some things do care; the fault lies with them.  */
if|if
condition|(
name|token
operator|->
name|col
operator|>
literal|2
condition|)
block|{
name|unsigned
name|int
name|spaces
init|=
name|token
operator|->
name|col
operator|-
literal|2
decl_stmt|;
while|while
condition|(
name|spaces
operator|--
condition|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|print
operator|.
name|outf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|cb_ident
parameter_list|(
name|pfile
parameter_list|,
name|line
parameter_list|,
name|str
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
specifier|const
name|cpp_string
modifier|*
name|str
decl_stmt|;
block|{
name|maybe_print_line
argument_list|(
name|print
operator|.
name|map
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|print
operator|.
name|outf
argument_list|,
literal|"#ident \"%s\"\n"
argument_list|,
name|str
operator|->
name|text
argument_list|)
expr_stmt|;
name|print
operator|.
name|line
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cb_define
parameter_list|(
name|pfile
parameter_list|,
name|line
parameter_list|,
name|node
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
name|cpp_hashnode
modifier|*
name|node
decl_stmt|;
block|{
name|maybe_print_line
argument_list|(
name|print
operator|.
name|map
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"#define "
argument_list|,
name|print
operator|.
name|outf
argument_list|)
expr_stmt|;
comment|/* -dD command line option.  */
if|if
condition|(
name|options
operator|->
name|dump_macros
operator|==
name|dump_definitions
condition|)
name|fputs
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|cpp_macro_definition
argument_list|(
name|pfile
argument_list|,
name|node
argument_list|)
argument_list|,
name|print
operator|.
name|outf
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|NODE_NAME
argument_list|(
name|node
argument_list|)
argument_list|,
name|print
operator|.
name|outf
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|print
operator|.
name|outf
argument_list|)
expr_stmt|;
name|print
operator|.
name|line
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cb_undef
parameter_list|(
name|pfile
parameter_list|,
name|line
parameter_list|,
name|node
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
name|cpp_hashnode
modifier|*
name|node
decl_stmt|;
block|{
name|maybe_print_line
argument_list|(
name|print
operator|.
name|map
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|print
operator|.
name|outf
argument_list|,
literal|"#undef %s\n"
argument_list|,
name|NODE_NAME
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|print
operator|.
name|line
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cb_include
parameter_list|(
name|pfile
parameter_list|,
name|line
parameter_list|,
name|dir
parameter_list|,
name|header
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|dir
decl_stmt|;
specifier|const
name|cpp_token
modifier|*
name|header
decl_stmt|;
block|{
name|maybe_print_line
argument_list|(
name|print
operator|.
name|map
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|print
operator|.
name|outf
argument_list|,
literal|"#%s %s\n"
argument_list|,
name|dir
argument_list|,
name|cpp_token_as_text
argument_list|(
name|pfile
argument_list|,
name|header
argument_list|)
argument_list|)
expr_stmt|;
name|print
operator|.
name|line
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The file name, line number or system header flags have changed, as    described in MAP.  From this point on, the old print.map might be    pointing to freed memory, and so must not be dereferenced.  */
end_comment

begin_function
specifier|static
name|void
name|cb_file_change
parameter_list|(
name|pfile
parameter_list|,
name|map
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|struct
name|line_map
modifier|*
name|map
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|flags
init|=
literal|""
decl_stmt|;
comment|/* First time?  */
if|if
condition|(
name|print
operator|.
name|map
operator|==
name|NULL
condition|)
block|{
comment|/* Avoid printing foo.i when the main file is foo.c.  */
if|if
condition|(
operator|!
name|options
operator|->
name|preprocessed
condition|)
name|print_line
argument_list|(
name|map
argument_list|,
name|map
operator|->
name|from_line
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Bring current file to correct line when entering a new file.  */
if|if
condition|(
name|map
operator|->
name|reason
operator|==
name|LC_ENTER
condition|)
name|maybe_print_line
argument_list|(
name|map
operator|-
literal|1
argument_list|,
name|map
operator|->
name|from_line
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|->
name|reason
operator|==
name|LC_ENTER
condition|)
name|flags
operator|=
literal|" 1"
expr_stmt|;
elseif|else
if|if
condition|(
name|map
operator|->
name|reason
operator|==
name|LC_LEAVE
condition|)
name|flags
operator|=
literal|" 2"
expr_stmt|;
name|print_line
argument_list|(
name|map
argument_list|,
name|map
operator|->
name|from_line
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
name|print
operator|.
name|map
operator|=
name|map
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy a #pragma directive to the preprocessed output.  */
end_comment

begin_function
specifier|static
name|void
name|cb_def_pragma
parameter_list|(
name|pfile
parameter_list|,
name|line
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
block|{
name|maybe_print_line
argument_list|(
name|print
operator|.
name|map
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"#pragma "
argument_list|,
name|print
operator|.
name|outf
argument_list|)
expr_stmt|;
name|cpp_output_line
argument_list|(
name|pfile
argument_list|,
name|print
operator|.
name|outf
argument_list|)
expr_stmt|;
name|print
operator|.
name|line
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump out the hash table.  */
end_comment

begin_function
specifier|static
name|int
name|dump_macro
parameter_list|(
name|pfile
parameter_list|,
name|node
parameter_list|,
name|v
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|cpp_hashnode
modifier|*
name|node
decl_stmt|;
name|void
modifier|*
name|v
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|node
operator|->
name|type
operator|==
name|NT_MACRO
operator|&&
operator|!
operator|(
name|node
operator|->
name|flags
operator|&
name|NODE_BUILTIN
operator|)
condition|)
block|{
name|fputs
argument_list|(
literal|"#define "
argument_list|,
name|print
operator|.
name|outf
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|cpp_macro_definition
argument_list|(
name|pfile
argument_list|,
name|node
argument_list|)
argument_list|,
name|print
operator|.
name|outf
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|print
operator|.
name|outf
argument_list|)
expr_stmt|;
name|print
operator|.
name|line
operator|++
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

end_unit

