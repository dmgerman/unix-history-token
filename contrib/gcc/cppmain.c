begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Preprocess only, using cpplib.    Copyright (C) 1995, 1997, 1998, 1999, 2000, 2001, 2002, 2003    Free Software Foundation, Inc.    Written by Per Bothner, 1994-95.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.   In other words, you are welcome to use, share and improve this program.  You are forbidden to forbid anyone else to use, share and improve  what you give them.   Help stamp out software-hoarding!  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"cpplib.h"
end_include

begin_include
include|#
directive|include
file|"cpphash.h"
end_include

begin_decl_stmt
specifier|static
name|void
name|setup_callbacks
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* General output routines.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|scan_translation_unit
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|scan_translation_unit_trad
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|account_for_newlines
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
specifier|const
name|uchar
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dump_macro
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|cpp_hashnode
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_line
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
specifier|const
expr|struct
name|line_map
operator|*
operator|,
name|unsigned
name|int
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|maybe_print_line
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
specifier|const
expr|struct
name|line_map
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Callback routines for the parser.   Most of these are active only    in specific modes.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|cb_line_change
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
specifier|const
name|cpp_token
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cb_define
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|unsigned
name|int
operator|,
name|cpp_hashnode
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cb_undef
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|unsigned
name|int
operator|,
name|cpp_hashnode
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cb_include
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|unsigned
name|int
operator|,
specifier|const
name|unsigned
name|char
operator|*
operator|,
specifier|const
name|cpp_token
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cb_ident
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|unsigned
name|int
operator|,
specifier|const
name|cpp_string
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cb_file_change
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
specifier|const
expr|struct
name|line_map
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cb_def_pragma
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Preprocess and output.  */
end_comment

begin_function
name|void
name|cpp_preprocess_file
parameter_list|(
name|pfile
parameter_list|,
name|in_fname
parameter_list|,
name|out_stream
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|char
modifier|*
name|in_fname
decl_stmt|;
name|FILE
modifier|*
name|out_stream
decl_stmt|;
block|{
comment|/* Initialize the printer structure.  Setting print.line to -1 here      is a trick to guarantee that the first token of the file will      cause a linemarker to be output by maybe_print_line.  */
name|pfile
operator|->
name|print
operator|.
name|line
operator|=
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
expr_stmt|;
name|pfile
operator|->
name|print
operator|.
name|printed
operator|=
literal|0
expr_stmt|;
name|pfile
operator|->
name|print
operator|.
name|prev
operator|=
literal|0
expr_stmt|;
name|pfile
operator|->
name|print
operator|.
name|map
operator|=
literal|0
expr_stmt|;
name|pfile
operator|->
name|print
operator|.
name|outf
operator|=
name|out_stream
expr_stmt|;
name|setup_callbacks
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpp_read_main_file
argument_list|(
name|pfile
argument_list|,
name|in_fname
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|cpp_options
modifier|*
name|options
init|=
operator|&
name|pfile
operator|->
name|opts
decl_stmt|;
name|cpp_finish_options
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
comment|/* A successful cpp_read_main_file guarantees that we can call 	 cpp_scan_nooutput or cpp_get_token next.  */
if|if
condition|(
name|options
operator|->
name|no_output
condition|)
block|{
comment|/* Scan -included buffers, then the main file.  */
while|while
condition|(
name|pfile
operator|->
name|buffer
operator|->
name|prev
condition|)
name|cpp_scan_nooutput
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|cpp_scan_nooutput
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|options
operator|->
name|traditional
condition|)
name|scan_translation_unit_trad
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
else|else
name|scan_translation_unit
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
comment|/* -dM command line option.  Should this be in cpp_finish?  */
if|if
condition|(
name|options
operator|->
name|dump_macros
operator|==
name|dump_only
condition|)
name|cpp_forall_identifiers
argument_list|(
name|pfile
argument_list|,
name|dump_macro
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* Flush any pending output.  */
if|if
condition|(
name|pfile
operator|->
name|print
operator|.
name|printed
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|pfile
operator|->
name|print
operator|.
name|outf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set up the callbacks as appropriate.  */
end_comment

begin_function
specifier|static
name|void
name|setup_callbacks
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|cpp_options
modifier|*
name|options
init|=
operator|&
name|pfile
operator|->
name|opts
decl_stmt|;
name|cpp_callbacks
modifier|*
name|cb
init|=
name|cpp_get_callbacks
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|options
operator|->
name|no_output
condition|)
block|{
name|cb
operator|->
name|line_change
operator|=
name|cb_line_change
expr_stmt|;
comment|/* Don't emit #pragma or #ident directives if we are processing 	 assembly language; the assembler may choke on them.  */
if|if
condition|(
name|options
operator|->
name|lang
operator|!=
name|CLK_ASM
condition|)
block|{
name|cb
operator|->
name|ident
operator|=
name|cb_ident
expr_stmt|;
name|cb
operator|->
name|def_pragma
operator|=
name|cb_def_pragma
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|options
operator|->
name|no_line_commands
condition|)
name|cb
operator|->
name|file_change
operator|=
name|cb_file_change
expr_stmt|;
block|}
if|if
condition|(
name|options
operator|->
name|dump_includes
condition|)
name|cb
operator|->
name|include
operator|=
name|cb_include
expr_stmt|;
if|if
condition|(
name|options
operator|->
name|dump_macros
operator|==
name|dump_names
operator|||
name|options
operator|->
name|dump_macros
operator|==
name|dump_definitions
condition|)
block|{
name|cb
operator|->
name|define
operator|=
name|cb_define
expr_stmt|;
name|cb
operator|->
name|undef
operator|=
name|cb_undef
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Writes out the preprocessed file, handling spacing and paste    avoidance issues.  */
end_comment

begin_function
specifier|static
name|void
name|scan_translation_unit
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|bool
name|avoid_paste
init|=
name|false
decl_stmt|;
name|pfile
operator|->
name|print
operator|.
name|source
operator|=
name|NULL
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|const
name|cpp_token
modifier|*
name|token
init|=
name|cpp_get_token
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_PADDING
condition|)
block|{
name|avoid_paste
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|pfile
operator|->
name|print
operator|.
name|source
operator|==
name|NULL
operator|||
operator|(
operator|!
operator|(
name|pfile
operator|->
name|print
operator|.
name|source
operator|->
name|flags
operator|&
name|PREV_WHITE
operator|)
operator|&&
name|token
operator|->
name|val
operator|.
name|source
operator|==
name|NULL
operator|)
condition|)
name|pfile
operator|->
name|print
operator|.
name|source
operator|=
name|token
operator|->
name|val
operator|.
name|source
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_EOF
condition|)
break|break;
comment|/* Subtle logic to output a space if and only if necessary.  */
if|if
condition|(
name|avoid_paste
condition|)
block|{
if|if
condition|(
name|pfile
operator|->
name|print
operator|.
name|source
operator|==
name|NULL
condition|)
name|pfile
operator|->
name|print
operator|.
name|source
operator|=
name|token
expr_stmt|;
if|if
condition|(
name|pfile
operator|->
name|print
operator|.
name|source
operator|->
name|flags
operator|&
name|PREV_WHITE
operator|||
operator|(
name|pfile
operator|->
name|print
operator|.
name|prev
operator|&&
name|cpp_avoid_paste
argument_list|(
name|pfile
argument_list|,
name|pfile
operator|->
name|print
operator|.
name|prev
argument_list|,
name|token
argument_list|)
operator|)
operator|||
operator|(
name|pfile
operator|->
name|print
operator|.
name|prev
operator|==
name|NULL
operator|&&
name|token
operator|->
name|type
operator|==
name|CPP_HASH
operator|)
condition|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|pfile
operator|->
name|print
operator|.
name|outf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|->
name|flags
operator|&
name|PREV_WHITE
condition|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|pfile
operator|->
name|print
operator|.
name|outf
argument_list|)
expr_stmt|;
name|avoid_paste
operator|=
name|false
expr_stmt|;
name|pfile
operator|->
name|print
operator|.
name|source
operator|=
name|NULL
expr_stmt|;
name|pfile
operator|->
name|print
operator|.
name|prev
operator|=
name|token
expr_stmt|;
name|cpp_output_token
argument_list|(
name|token
argument_list|,
name|pfile
operator|->
name|print
operator|.
name|outf
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_COMMENT
condition|)
name|account_for_newlines
argument_list|(
name|pfile
argument_list|,
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|text
argument_list|,
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|len
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Adjust pfile->print.line for newlines embedded in output.  */
end_comment

begin_function
specifier|static
name|void
name|account_for_newlines
parameter_list|(
name|pfile
parameter_list|,
name|str
parameter_list|,
name|len
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|uchar
modifier|*
name|str
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|{
while|while
condition|(
name|len
operator|--
condition|)
if|if
condition|(
operator|*
name|str
operator|++
operator|==
literal|'\n'
condition|)
name|pfile
operator|->
name|print
operator|.
name|line
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Writes out a traditionally preprocessed file.  */
end_comment

begin_function
specifier|static
name|void
name|scan_translation_unit_trad
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
while|while
condition|(
name|_cpp_read_logical_line_trad
argument_list|(
name|pfile
argument_list|)
condition|)
block|{
name|size_t
name|len
init|=
name|pfile
operator|->
name|out
operator|.
name|cur
operator|-
name|pfile
operator|->
name|out
operator|.
name|base
decl_stmt|;
name|maybe_print_line
argument_list|(
name|pfile
argument_list|,
name|pfile
operator|->
name|print
operator|.
name|map
argument_list|,
name|pfile
operator|->
name|out
operator|.
name|first_line
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|pfile
operator|->
name|out
operator|.
name|base
argument_list|,
literal|1
argument_list|,
name|len
argument_list|,
name|pfile
operator|->
name|print
operator|.
name|outf
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|print
operator|.
name|printed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|discard_comments
argument_list|)
condition|)
name|account_for_newlines
argument_list|(
name|pfile
argument_list|,
name|pfile
operator|->
name|out
operator|.
name|base
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* If the token read on logical line LINE needs to be output on a    different line to the current one, output the required newlines or    a line marker, and return 1.  Otherwise return 0.  */
end_comment

begin_function
specifier|static
name|void
name|maybe_print_line
parameter_list|(
name|pfile
parameter_list|,
name|map
parameter_list|,
name|line
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|struct
name|line_map
modifier|*
name|map
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
block|{
comment|/* End the previous line of text.  */
if|if
condition|(
name|pfile
operator|->
name|print
operator|.
name|printed
condition|)
block|{
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|pfile
operator|->
name|print
operator|.
name|outf
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|print
operator|.
name|line
operator|++
expr_stmt|;
name|pfile
operator|->
name|print
operator|.
name|printed
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|line
operator|>=
name|pfile
operator|->
name|print
operator|.
name|line
operator|&&
name|line
operator|<
name|pfile
operator|->
name|print
operator|.
name|line
operator|+
literal|8
condition|)
block|{
while|while
condition|(
name|line
operator|>
name|pfile
operator|->
name|print
operator|.
name|line
condition|)
block|{
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|pfile
operator|->
name|print
operator|.
name|outf
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|print
operator|.
name|line
operator|++
expr_stmt|;
block|}
block|}
else|else
name|print_line
argument_list|(
name|pfile
argument_list|,
name|map
argument_list|,
name|line
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output a line marker for logical line LINE.  Special flags are "1"    or "2" indicating entering or leaving a file.  */
end_comment

begin_function
specifier|static
name|void
name|print_line
parameter_list|(
name|pfile
parameter_list|,
name|map
parameter_list|,
name|line
parameter_list|,
name|special_flags
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|struct
name|line_map
modifier|*
name|map
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
specifier|const
name|char
modifier|*
name|special_flags
decl_stmt|;
block|{
comment|/* End any previous line of text.  */
if|if
condition|(
name|pfile
operator|->
name|print
operator|.
name|printed
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|pfile
operator|->
name|print
operator|.
name|outf
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|print
operator|.
name|printed
operator|=
literal|0
expr_stmt|;
name|pfile
operator|->
name|print
operator|.
name|line
operator|=
name|line
expr_stmt|;
if|if
condition|(
operator|!
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|no_line_commands
argument_list|)
condition|)
block|{
name|size_t
name|to_file_len
init|=
name|strlen
argument_list|(
name|map
operator|->
name|to_file
argument_list|)
decl_stmt|;
name|unsigned
name|char
modifier|*
name|to_file_quoted
init|=
name|alloca
argument_list|(
name|to_file_len
operator|*
literal|4
operator|+
literal|1
argument_list|)
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
comment|/* cpp_quote_string does not nul-terminate, so we have to do it 	 ourselves.  */
name|p
operator|=
name|cpp_quote_string
argument_list|(
name|to_file_quoted
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|map
operator|->
name|to_file
argument_list|,
name|to_file_len
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|fprintf
argument_list|(
name|pfile
operator|->
name|print
operator|.
name|outf
argument_list|,
literal|"# %u \"%s\"%s"
argument_list|,
name|SOURCE_LINE
argument_list|(
name|map
argument_list|,
name|pfile
operator|->
name|print
operator|.
name|line
argument_list|)
argument_list|,
name|to_file_quoted
argument_list|,
name|special_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|->
name|sysp
operator|==
literal|2
condition|)
name|fputs
argument_list|(
literal|" 3 4"
argument_list|,
name|pfile
operator|->
name|print
operator|.
name|outf
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|map
operator|->
name|sysp
operator|==
literal|1
condition|)
name|fputs
argument_list|(
literal|" 3"
argument_list|,
name|pfile
operator|->
name|print
operator|.
name|outf
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|pfile
operator|->
name|print
operator|.
name|outf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Called when a line of output is started.  TOKEN is the first token    of the line, and at end of file will be CPP_EOF.  */
end_comment

begin_function
specifier|static
name|void
name|cb_line_change
parameter_list|(
name|pfile
parameter_list|,
name|token
parameter_list|,
name|parsing_args
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|cpp_token
modifier|*
name|token
decl_stmt|;
name|int
name|parsing_args
decl_stmt|;
block|{
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_EOF
operator|||
name|parsing_args
condition|)
return|return;
name|maybe_print_line
argument_list|(
name|pfile
argument_list|,
name|pfile
operator|->
name|print
operator|.
name|map
argument_list|,
name|token
operator|->
name|line
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|print
operator|.
name|prev
operator|=
literal|0
expr_stmt|;
name|pfile
operator|->
name|print
operator|.
name|source
operator|=
literal|0
expr_stmt|;
comment|/* Supply enough spaces to put this token in its original column,      one space per column greater than 2, since scan_translation_unit      will provide a space if PREV_WHITE.  Don't bother trying to      reconstruct tabs; we can't get it right in general, and nothing      ought to care.  Some things do care; the fault lies with them.  */
if|if
condition|(
operator|!
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|traditional
argument_list|)
condition|)
block|{
name|pfile
operator|->
name|print
operator|.
name|printed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|col
operator|>
literal|2
condition|)
block|{
name|unsigned
name|int
name|spaces
init|=
name|token
operator|->
name|col
operator|-
literal|2
decl_stmt|;
while|while
condition|(
name|spaces
operator|--
condition|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|pfile
operator|->
name|print
operator|.
name|outf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|cb_ident
parameter_list|(
name|pfile
parameter_list|,
name|line
parameter_list|,
name|str
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
specifier|const
name|cpp_string
modifier|*
name|str
decl_stmt|;
block|{
name|maybe_print_line
argument_list|(
name|pfile
argument_list|,
name|pfile
operator|->
name|print
operator|.
name|map
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|pfile
operator|->
name|print
operator|.
name|outf
argument_list|,
literal|"#ident \"%s\"\n"
argument_list|,
name|str
operator|->
name|text
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|print
operator|.
name|line
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cb_define
parameter_list|(
name|pfile
parameter_list|,
name|line
parameter_list|,
name|node
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
name|cpp_hashnode
modifier|*
name|node
decl_stmt|;
block|{
name|maybe_print_line
argument_list|(
name|pfile
argument_list|,
name|pfile
operator|->
name|print
operator|.
name|map
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"#define "
argument_list|,
name|pfile
operator|->
name|print
operator|.
name|outf
argument_list|)
expr_stmt|;
comment|/* -dD command line option.  */
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|dump_macros
argument_list|)
operator|==
name|dump_definitions
condition|)
name|fputs
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|cpp_macro_definition
argument_list|(
name|pfile
argument_list|,
name|node
argument_list|)
argument_list|,
name|pfile
operator|->
name|print
operator|.
name|outf
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|NODE_NAME
argument_list|(
name|node
argument_list|)
argument_list|,
name|pfile
operator|->
name|print
operator|.
name|outf
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|pfile
operator|->
name|print
operator|.
name|outf
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|print
operator|.
name|line
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cb_undef
parameter_list|(
name|pfile
parameter_list|,
name|line
parameter_list|,
name|node
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
name|cpp_hashnode
modifier|*
name|node
decl_stmt|;
block|{
name|maybe_print_line
argument_list|(
name|pfile
argument_list|,
name|pfile
operator|->
name|print
operator|.
name|map
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|pfile
operator|->
name|print
operator|.
name|outf
argument_list|,
literal|"#undef %s\n"
argument_list|,
name|NODE_NAME
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|print
operator|.
name|line
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cb_include
parameter_list|(
name|pfile
parameter_list|,
name|line
parameter_list|,
name|dir
parameter_list|,
name|header
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|dir
decl_stmt|;
specifier|const
name|cpp_token
modifier|*
name|header
decl_stmt|;
block|{
name|maybe_print_line
argument_list|(
name|pfile
argument_list|,
name|pfile
operator|->
name|print
operator|.
name|map
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|pfile
operator|->
name|print
operator|.
name|outf
argument_list|,
literal|"#%s %s\n"
argument_list|,
name|dir
argument_list|,
name|cpp_token_as_text
argument_list|(
name|pfile
argument_list|,
name|header
argument_list|)
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|print
operator|.
name|line
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The file name, line number or system header flags have changed, as    described in MAP.  From this point on, the old pfile->print.map might be    pointing to freed memory, and so must not be dereferenced.  */
end_comment

begin_function
specifier|static
name|void
name|cb_file_change
parameter_list|(
name|pfile
parameter_list|,
name|map
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|struct
name|line_map
modifier|*
name|map
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|flags
init|=
literal|""
decl_stmt|;
comment|/* First time?  */
if|if
condition|(
name|pfile
operator|->
name|print
operator|.
name|map
operator|==
name|NULL
condition|)
block|{
comment|/* Avoid printing foo.i when the main file is foo.c.  */
if|if
condition|(
operator|!
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|preprocessed
argument_list|)
condition|)
name|print_line
argument_list|(
name|pfile
argument_list|,
name|map
argument_list|,
name|map
operator|->
name|from_line
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Bring current file to correct line when entering a new file.  */
if|if
condition|(
name|map
operator|->
name|reason
operator|==
name|LC_ENTER
condition|)
name|maybe_print_line
argument_list|(
name|pfile
argument_list|,
name|map
operator|-
literal|1
argument_list|,
name|map
operator|->
name|from_line
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|->
name|reason
operator|==
name|LC_ENTER
condition|)
name|flags
operator|=
literal|" 1"
expr_stmt|;
elseif|else
if|if
condition|(
name|map
operator|->
name|reason
operator|==
name|LC_LEAVE
condition|)
name|flags
operator|=
literal|" 2"
expr_stmt|;
name|print_line
argument_list|(
name|pfile
argument_list|,
name|map
argument_list|,
name|map
operator|->
name|from_line
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
name|pfile
operator|->
name|print
operator|.
name|map
operator|=
name|map
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy a #pragma directive to the preprocessed output.  */
end_comment

begin_function
specifier|static
name|void
name|cb_def_pragma
parameter_list|(
name|pfile
parameter_list|,
name|line
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
block|{
name|maybe_print_line
argument_list|(
name|pfile
argument_list|,
name|pfile
operator|->
name|print
operator|.
name|map
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"#pragma "
argument_list|,
name|pfile
operator|->
name|print
operator|.
name|outf
argument_list|)
expr_stmt|;
name|cpp_output_line
argument_list|(
name|pfile
argument_list|,
name|pfile
operator|->
name|print
operator|.
name|outf
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|print
operator|.
name|line
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump out the hash table.  */
end_comment

begin_function
specifier|static
name|int
name|dump_macro
parameter_list|(
name|pfile
parameter_list|,
name|node
parameter_list|,
name|v
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|cpp_hashnode
modifier|*
name|node
decl_stmt|;
name|void
modifier|*
name|v
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|node
operator|->
name|type
operator|==
name|NT_MACRO
operator|&&
operator|!
operator|(
name|node
operator|->
name|flags
operator|&
name|NODE_BUILTIN
operator|)
condition|)
block|{
name|fputs
argument_list|(
literal|"#define "
argument_list|,
name|pfile
operator|->
name|print
operator|.
name|outf
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|cpp_macro_definition
argument_list|(
name|pfile
argument_list|,
name|node
argument_list|)
argument_list|,
name|pfile
operator|->
name|print
operator|.
name|outf
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|pfile
operator|->
name|print
operator|.
name|outf
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|print
operator|.
name|line
operator|++
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

end_unit

