begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Implement classes and message passing for Objective C.    Copyright (C) 1992, 1993, 1994, 1995 Free Software Foundation, Inc.    Contributed by Steve Naroff.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Purpose: This module implements the Objective-C 4.0 language.     compatibility issues (with the Stepstone translator):     - does not recognize the following 3.3 constructs.      @requires, @classes, @messages, = (...)    - methods with variable arguments must conform to ANSI standard.    - tagged structure definitions that appear in BOTH the interface      and implementation are not allowed.    - public/private: all instance variables are public within the      context of the implementation...I consider this to be a bug in      the translator.    - statically allocated objects are not supported. the user will      receive an error if this service is requested.     code generation `options':     - OBJC_INT_SELECTORS  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"c-tree.h"
end_include

begin_include
include|#
directive|include
file|"c-lex.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"objc-act.h"
end_include

begin_include
include|#
directive|include
file|"input.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_comment
comment|/* This is the default way of generating a method name.  */
end_comment

begin_comment
comment|/* I am not sure it is really correct.    Perhaps there's a danger that it will make name conflicts    if method names contain underscores. -- rms.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|OBJC_GEN_METHOD_LABEL
end_ifndef

begin_define
define|#
directive|define
name|OBJC_GEN_METHOD_LABEL
parameter_list|(
name|BUF
parameter_list|,
name|IS_INST
parameter_list|,
name|CLASS_NAME
parameter_list|,
name|CAT_NAME
parameter_list|,
name|SEL_NAME
parameter_list|,
name|NUM
parameter_list|)
define|\
value|do {					    \     char *temp;				    \     sprintf ((BUF), "_%s_%s_%s_%s",	    \ 	     ((IS_INST) ? "i" : "c"),	    \ 	     (CLASS_NAME),		    \ 	     ((CAT_NAME)? (CAT_NAME) : ""), \ 	     (SEL_NAME));		    \     for (temp = (BUF); *temp; temp++)	    \       if (*temp == ':') *temp = '_';	    \   } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* These need specifying.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|OBJC_FORWARDING_STACK_OFFSET
end_ifndef

begin_define
define|#
directive|define
name|OBJC_FORWARDING_STACK_OFFSET
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|OBJC_FORWARDING_MIN_OFFSET
end_ifndef

begin_define
define|#
directive|define
name|OBJC_FORWARDING_MIN_OFFSET
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Define the special tree codes that we use.  */
end_comment

begin_comment
comment|/* Table indexed by tree code giving a string containing a character    classifying the tree code.  Possibilities are    t, d, s, c, r,<, 1 and 2.  See objc-tree.def for details.  */
end_comment

begin_define
define|#
directive|define
name|DEFTREECODE
parameter_list|(
name|SYM
parameter_list|,
name|NAME
parameter_list|,
name|TYPE
parameter_list|,
name|LENGTH
parameter_list|)
value|TYPE,
end_define

begin_decl_stmt
name|char
modifier|*
name|objc_tree_code_type
index|[]
init|=
block|{
literal|"x"
block|,
include|#
directive|include
file|"objc-tree.def"
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|DEFTREECODE
end_undef

begin_comment
comment|/* Table indexed by tree code giving number of expression    operands beyond the fixed part of the node structure.    Not used for types or decls.  */
end_comment

begin_define
define|#
directive|define
name|DEFTREECODE
parameter_list|(
name|SYM
parameter_list|,
name|NAME
parameter_list|,
name|TYPE
parameter_list|,
name|LENGTH
parameter_list|)
value|LENGTH,
end_define

begin_decl_stmt
name|int
name|objc_tree_code_length
index|[]
init|=
block|{
literal|0
block|,
include|#
directive|include
file|"objc-tree.def"
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|DEFTREECODE
end_undef

begin_comment
comment|/* Names of tree components.    Used for printing out the tree and error messages.  */
end_comment

begin_define
define|#
directive|define
name|DEFTREECODE
parameter_list|(
name|SYM
parameter_list|,
name|NAME
parameter_list|,
name|TYPE
parameter_list|,
name|LEN
parameter_list|)
value|NAME,
end_define

begin_decl_stmt
name|char
modifier|*
name|objc_tree_code_name
index|[]
init|=
block|{
literal|"@@dummy"
block|,
include|#
directive|include
file|"objc-tree.def"
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|DEFTREECODE
end_undef

begin_escape
end_escape

begin_comment
comment|/* Set up for use of obstacks.  */
end_comment

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_comment
comment|/* This obstack is used to accumulate the encoding of a data type.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|util_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This points to the beginning of obstack contents,    so we can free the whole contents.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|util_firstobj
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of classes with list of their static instances.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|objc_static_instances
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The declaration of the array administrating the static instances.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|static_instances_decl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for encode_method_def */
end_comment

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"c-parse.h"
end_include

begin_define
define|#
directive|define
name|OBJC_VERSION
value|(flag_next_runtime ? 5 : 7)
end_define

begin_define
define|#
directive|define
name|PROTOCOL_VERSION
value|2
end_define

begin_define
define|#
directive|define
name|OBJC_ENCODE_INLINE_DEFS
value|0
end_define

begin_define
define|#
directive|define
name|OBJC_ENCODE_DONT_INLINE_DEFS
value|1
end_define

begin_comment
comment|/*** Private Interface (procedures) ***/
end_comment

begin_comment
comment|/* Used by compile_file. */
end_comment

begin_decl_stmt
specifier|static
name|void
name|init_objc
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|finish_objc
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Code generation. */
end_comment

begin_decl_stmt
specifier|static
name|void
name|synth_module_prologue
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_constructor
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|build_module_descriptor
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|init_module_descriptor
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_objc_method_call
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|generate_strings
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|get_proto_encoding
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|build_selector_translation_table
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_ivar_chain
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|objc_add_static_instance
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_ivar_template
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_method_template
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_private_template
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|build_class_template
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|build_selector_template
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|build_category_template
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_super_template
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_category_initializer
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_protocol_initializer
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|synth_forward_declarations
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|generate_ivar_lists
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|generate_dispatch_tables
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|generate_shared_structures
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|generate_protocol_list
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|generate_forward_declaration_to_string_table
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|build_protocol_reference
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|init_selector
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_keyword_selector
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|synth_id_with_class_suffix
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* From expr.c */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|apply_args_register_offset
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Misc. bookkeeping */
end_comment

begin_typedef
typedef|typedef
name|struct
name|hashed_entry
modifier|*
name|hash
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|hashed_attribute
modifier|*
name|attr
typedef|;
end_typedef

begin_struct
struct|struct
name|hashed_attribute
block|{
name|attr
name|next
decl_stmt|;
name|tree
name|value
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|hashed_entry
block|{
name|attr
name|list
decl_stmt|;
name|hash
name|next
decl_stmt|;
name|tree
name|key
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|void
name|hash_init
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|hash_enter
name|PROTO
argument_list|(
operator|(
name|hash
operator|*
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|hash
name|hash_lookup
name|PROTO
argument_list|(
operator|(
name|hash
operator|*
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|hash_add_attr
name|PROTO
argument_list|(
operator|(
name|hash
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|lookup_method
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|lookup_instance_method_static
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|lookup_class_method_static
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|add_class
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_category
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_enum
enum|enum
name|string_section
block|{
name|class_names
block|,
comment|/* class, category, protocol, module names */
name|meth_var_names
block|,
comment|/* method and variable names */
name|meth_var_types
comment|/* method and variable type descriptors */
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|tree
name|add_objc_string
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
expr|enum
name|string_section
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_objc_string_decl
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
expr|enum
name|string_section
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_selector_reference_decl
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Protocol additions. */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|add_protocol
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|lookup_protocol
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|lookup_and_install_protocols
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Type encoding. */
end_comment

begin_decl_stmt
specifier|static
name|void
name|encode_type_qualifiers
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|encode_pointer
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|encode_array
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|encode_aggregate
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|encode_bitfield
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|encode_type
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|encode_field_decl
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|really_start_method
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|comp_method_with_proto
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|comp_proto_with_proto
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|get_arg_type_list
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|expr_last
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Utilities for debugging and error diagnostics. */
end_comment

begin_decl_stmt
specifier|static
name|void
name|warn_with_method
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|error_with_ivar
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|gen_method_decl
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|gen_declaration
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|gen_declarator
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_complex_decl
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|adorn_decl
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_interface
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Everything else. */
end_comment

begin_decl_stmt
specifier|static
name|void
name|objc_fatal
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|define_decl
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|lookup_method_in_protocol_list
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|lookup_protocol_in_reflist
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|create_builtin_decl
name|PROTO
argument_list|(
operator|(
expr|enum
name|tree_code
operator|,
name|tree
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|my_build_string
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|build_objc_symtab_template
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|init_def_list
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|init_objc_symtab
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|forward_declare_categories
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|generate_objc_symtab_decl
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_selector
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_msg_pool_reference
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_typed_selector_reference
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_selector_reference
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_class_reference_decl
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_class_reference
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|objc_copy_list
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_protocol_template
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_descriptor_table_initializer
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_method_prototype_list_template
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_method_prototype_template
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|forwarding_offset
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|encode_method_prototype
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|generate_descriptor_table
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|generate_method_descriptors
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_tmp_function_decl
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|hack_method_prototype
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|generate_protocol_references
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|generate_protocols
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|check_ivars
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_ivar_list_template
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_method_list_template
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_ivar_list_initializer
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|generate_ivars_list
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_dispatch_table_initializer
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|generate_dispatch_table
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_shared_structure_initializer
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|generate_category
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_objc_type_qualifier
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|adjust_type_for_id_default
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|check_duplicates
name|PROTO
argument_list|(
operator|(
name|hash
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|receiver_is_class_object
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|check_methods
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|conforms_to_protocol
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|check_protocols
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|encode_method_def
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_declspecs
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|generate_classref_translation_entry
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_class_ref
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*** Private Interface (data) ***/
end_comment

begin_comment
comment|/* Reserved tag definitions. */
end_comment

begin_define
define|#
directive|define
name|TYPE_ID
value|"id"
end_define

begin_define
define|#
directive|define
name|TAG_OBJECT
value|"objc_object"
end_define

begin_define
define|#
directive|define
name|TAG_CLASS
value|"objc_class"
end_define

begin_define
define|#
directive|define
name|TAG_SUPER
value|"objc_super"
end_define

begin_define
define|#
directive|define
name|TAG_SELECTOR
value|"objc_selector"
end_define

begin_define
define|#
directive|define
name|UTAG_CLASS
value|"_objc_class"
end_define

begin_define
define|#
directive|define
name|UTAG_IVAR
value|"_objc_ivar"
end_define

begin_define
define|#
directive|define
name|UTAG_IVAR_LIST
value|"_objc_ivar_list"
end_define

begin_define
define|#
directive|define
name|UTAG_METHOD
value|"_objc_method"
end_define

begin_define
define|#
directive|define
name|UTAG_METHOD_LIST
value|"_objc_method_list"
end_define

begin_define
define|#
directive|define
name|UTAG_CATEGORY
value|"_objc_category"
end_define

begin_define
define|#
directive|define
name|UTAG_MODULE
value|"_objc_module"
end_define

begin_define
define|#
directive|define
name|UTAG_STATICS
value|"_objc_statics"
end_define

begin_define
define|#
directive|define
name|UTAG_SYMTAB
value|"_objc_symtab"
end_define

begin_define
define|#
directive|define
name|UTAG_SUPER
value|"_objc_super"
end_define

begin_define
define|#
directive|define
name|UTAG_SELECTOR
value|"_objc_selector"
end_define

begin_define
define|#
directive|define
name|UTAG_PROTOCOL
value|"_objc_protocol"
end_define

begin_define
define|#
directive|define
name|UTAG_PROTOCOL_LIST
value|"_objc_protocol_list"
end_define

begin_define
define|#
directive|define
name|UTAG_METHOD_PROTOTYPE
value|"_objc_method_prototype"
end_define

begin_define
define|#
directive|define
name|UTAG_METHOD_PROTOTYPE_LIST
value|"_objc__method_prototype_list"
end_define

begin_define
define|#
directive|define
name|STRING_OBJECT_CLASS_NAME
value|"NXConstantString"
end_define

begin_define
define|#
directive|define
name|PROTOCOL_OBJECT_CLASS_NAME
value|"Protocol"
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
name|TAG_GETCLASS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|TAG_GETMETACLASS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|TAG_MSGSEND
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|TAG_MSGSENDSUPER
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|TAG_EXECCLASS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set by `continue_class' and checked by `is_public'.  */
end_comment

begin_define
define|#
directive|define
name|TREE_STATIC_TEMPLATE
parameter_list|(
name|record_type
parameter_list|)
value|(TREE_PUBLIC (record_type))
end_define

begin_define
define|#
directive|define
name|TYPED_OBJECT
parameter_list|(
name|type
parameter_list|)
define|\
value|(TREE_CODE (type) == RECORD_TYPE&& TREE_STATIC_TEMPLATE (type))
end_define

begin_comment
comment|/* Some commonly used instances of "identifier_node".  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|self_id
decl_stmt|,
name|ucmd_id
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|unused_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|self_decl
decl_stmt|,
name|umsg_decl
decl_stmt|,
name|umsg_super_decl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|objc_get_class_decl
decl_stmt|,
name|objc_get_meta_class_decl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|super_type
decl_stmt|,
name|selector_type
decl_stmt|,
name|id_type
decl_stmt|,
name|objc_class_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|instance_type
decl_stmt|,
name|protocol_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Type checking macros.  */
end_comment

begin_define
define|#
directive|define
name|IS_ID
parameter_list|(
name|TYPE
parameter_list|)
define|\
value|(TYPE_MAIN_VARIANT (TYPE) == TYPE_MAIN_VARIANT (id_type))
end_define

begin_define
define|#
directive|define
name|IS_PROTOCOL_QUALIFIED_ID
parameter_list|(
name|TYPE
parameter_list|)
define|\
value|(IS_ID (TYPE)&& TYPE_PROTOCOL_LIST (TYPE))
end_define

begin_define
define|#
directive|define
name|IS_SUPER
parameter_list|(
name|TYPE
parameter_list|)
define|\
value|(super_type&& TYPE_MAIN_VARIANT (TYPE) == TYPE_MAIN_VARIANT (super_type))
end_define

begin_decl_stmt
specifier|static
name|tree
name|class_chain
init|=
name|NULL_TREE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|alias_chain
init|=
name|NULL_TREE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|interface_chain
init|=
name|NULL_TREE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|protocol_chain
init|=
name|NULL_TREE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chains to manage selectors that are referenced and defined in the module. */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|cls_ref_chain
init|=
name|NULL_TREE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Classes referenced. */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|sel_ref_chain
init|=
name|NULL_TREE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Selectors referenced. */
end_comment

begin_comment
comment|/* Chains to manage uniquing of strings. */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|class_names_chain
init|=
name|NULL_TREE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|meth_var_names_chain
init|=
name|NULL_TREE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|meth_var_types_chain
init|=
name|NULL_TREE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Hash tables to manage the global pool of method prototypes. */
end_comment

begin_decl_stmt
specifier|static
name|hash
modifier|*
name|nst_method_hash_list
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|hash
modifier|*
name|cls_method_hash_list
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Backend data declarations. */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|UOBJC_SYMBOLS_decl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|UOBJC_INSTANCE_VARIABLES_decl
decl_stmt|,
name|UOBJC_CLASS_VARIABLES_decl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|UOBJC_INSTANCE_METHODS_decl
decl_stmt|,
name|UOBJC_CLASS_METHODS_decl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|UOBJC_CLASS_decl
decl_stmt|,
name|UOBJC_METACLASS_decl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|UOBJC_SELECTOR_TABLE_decl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|UOBJC_MODULES_decl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|UOBJC_STRINGS_decl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following are used when compiling a class implementation.    implementation_template will normally be an interface, however if    none exists this will be equal to implementation_context...it is    set in start_class.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|implementation_context
init|=
name|NULL_TREE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|implementation_template
init|=
name|NULL_TREE
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|imp_entry
block|{
name|struct
name|imp_entry
modifier|*
name|next
decl_stmt|;
name|tree
name|imp_context
decl_stmt|;
name|tree
name|imp_template
decl_stmt|;
name|tree
name|class_decl
decl_stmt|;
comment|/* _OBJC_CLASS_<my_name>; */
name|tree
name|meta_decl
decl_stmt|;
comment|/* _OBJC_METACLASS_<my_name>; */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|void
name|handle_impent
name|PROTO
argument_list|(
operator|(
expr|struct
name|imp_entry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|imp_entry
modifier|*
name|imp_list
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|imp_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* `@implementation' */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cat_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* `@category' */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|objc_class_template
decl_stmt|,
name|objc_category_template
decl_stmt|,
name|uprivate_record
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|objc_protocol_template
decl_stmt|,
name|objc_selector_template
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|ucls_super_ref
decl_stmt|,
name|uucls_super_ref
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|objc_method_template
decl_stmt|,
name|objc_ivar_template
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|objc_symtab_template
decl_stmt|,
name|objc_module_template
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|objc_super_template
decl_stmt|,
name|objc_object_reference
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|objc_object_id
decl_stmt|,
name|objc_class_id
decl_stmt|,
name|objc_id_id
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|constant_string_id
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|constant_string_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|UOBJC_SUPER_decl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|method_context
init|=
name|NULL_TREE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|method_slot
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used by start_method_def, */
end_comment

begin_define
define|#
directive|define
name|BUFSIZE
value|1024
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
name|errbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer for error diagnostics */
end_comment

begin_comment
comment|/* Data imported from tree.c. */
end_comment

begin_decl_stmt
specifier|extern
name|enum
name|debug_info_type
name|write_symbols
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Data imported from toplev.c.  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|dump_base_name
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Generate code for GNU or NeXT runtime environment.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NEXT_OBJC_RUNTIME
end_ifdef

begin_decl_stmt
name|int
name|flag_next_runtime
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|flag_next_runtime
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|flag_typed_selectors
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Open and close the file for outputting class declarations, if requested.  */
end_comment

begin_decl_stmt
name|int
name|flag_gen_declaration
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|gen_declaration_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Warn if multiple methods are seen for the same selector, but with    different argument types. */
end_comment

begin_decl_stmt
name|int
name|warn_selector
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Warn if methods required by a protocol are not implemented in the     class adopting it.  When turned off, methods inherited to that    class are also considered implemented */
end_comment

begin_decl_stmt
name|int
name|flag_warn_protocol
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Tells "encode_pointer/encode_aggregate" whether we are generating    type descriptors for instance variables (as opposed to methods).    Type descriptors for instance variables contain more information    than methods (for static typing and embedded structures). This    was added to support features being planned for dbkit2. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|generating_instance_variables
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|lang_init
parameter_list|()
block|{
comment|/* The beginning of the file is a new line; check for #.      With luck, we discover the real source file's name from that      and put it in input_filename.  */
name|ungetc
argument_list|(
name|check_newline
argument_list|()
argument_list|,
name|finput
argument_list|)
expr_stmt|;
comment|/* The line number can be -1 if we had -g3 and the input file      had a directive specifying line 0.  But we want predefined      functions to have a line number of 0, not -1.  */
if|if
condition|(
name|lineno
operator|==
operator|-
literal|1
condition|)
name|lineno
operator|=
literal|0
expr_stmt|;
comment|/* If gen_declaration desired, open the output file.  */
if|if
condition|(
name|flag_gen_declaration
condition|)
block|{
name|int
name|dump_base_name_length
init|=
name|strlen
argument_list|(
name|dump_base_name
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|dumpname
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|dump_base_name_length
operator|+
literal|7
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|dumpname
argument_list|,
name|dump_base_name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dumpname
argument_list|,
literal|".decl"
argument_list|)
expr_stmt|;
name|gen_declaration_file
operator|=
name|fopen
argument_list|(
name|dumpname
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|gen_declaration_file
operator|==
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|dumpname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_next_runtime
condition|)
block|{
name|TAG_GETCLASS
operator|=
literal|"objc_getClass"
expr_stmt|;
name|TAG_GETMETACLASS
operator|=
literal|"objc_getMetaClass"
expr_stmt|;
name|TAG_MSGSEND
operator|=
literal|"objc_msgSend"
expr_stmt|;
name|TAG_MSGSENDSUPER
operator|=
literal|"objc_msgSendSuper"
expr_stmt|;
name|TAG_EXECCLASS
operator|=
literal|"__objc_execClass"
expr_stmt|;
block|}
else|else
block|{
name|TAG_GETCLASS
operator|=
literal|"objc_get_class"
expr_stmt|;
name|TAG_GETMETACLASS
operator|=
literal|"objc_get_meta_class"
expr_stmt|;
name|TAG_MSGSEND
operator|=
literal|"objc_msg_lookup"
expr_stmt|;
name|TAG_MSGSENDSUPER
operator|=
literal|"objc_msg_lookup_super"
expr_stmt|;
name|TAG_EXECCLASS
operator|=
literal|"__objc_exec_class"
expr_stmt|;
name|flag_typed_selectors
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|doing_objc_thang
condition|)
name|init_objc
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|objc_fatal
parameter_list|()
block|{
name|fatal
argument_list|(
literal|"Objective-C text in C source file"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|finish_file
parameter_list|()
block|{
if|if
condition|(
name|doing_objc_thang
condition|)
name|finish_objc
argument_list|()
expr_stmt|;
comment|/* Objective-C finalization */
if|if
condition|(
name|gen_declaration_file
condition|)
name|fclose
argument_list|(
name|gen_declaration_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lang_finish
parameter_list|()
block|{ }
end_function

begin_function
name|char
modifier|*
name|lang_identify
parameter_list|()
block|{
return|return
literal|"objc"
return|;
block|}
end_function

begin_function
name|int
name|lang_decode_option
parameter_list|(
name|p
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-lang-objc"
argument_list|)
condition|)
name|doing_objc_thang
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-gen-decls"
argument_list|)
condition|)
name|flag_gen_declaration
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-Wselector"
argument_list|)
condition|)
name|warn_selector
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-Wno-selector"
argument_list|)
condition|)
name|warn_selector
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-Wprotocol"
argument_list|)
condition|)
name|flag_warn_protocol
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-Wno-protocol"
argument_list|)
condition|)
name|flag_warn_protocol
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-fgnu-runtime"
argument_list|)
condition|)
name|flag_next_runtime
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-fno-next-runtime"
argument_list|)
condition|)
name|flag_next_runtime
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-fno-gnu-runtime"
argument_list|)
condition|)
name|flag_next_runtime
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-fnext-runtime"
argument_list|)
condition|)
name|flag_next_runtime
operator|=
literal|1
expr_stmt|;
else|else
return|return
name|c_decode_option
argument_list|(
name|p
argument_list|)
return|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|tree
name|define_decl
parameter_list|(
name|declarator
parameter_list|,
name|declspecs
parameter_list|)
name|tree
name|declarator
decl_stmt|;
name|tree
name|declspecs
decl_stmt|;
block|{
name|tree
name|decl
init|=
name|start_decl
argument_list|(
name|declarator
argument_list|,
name|declspecs
argument_list|,
literal|0
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|finish_decl
argument_list|(
name|decl
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if LHS and RHS are compatible types for assignment or    various other operations.  Return 0 if they are incompatible, and    return -1 if we choose to not decide.  When the operation is    REFLEXIVE, check for compatibility in either direction.     For statically typed objects, an assignment of the form `a' = `b'    is permitted if:     `a' is of type "id",    `a' and `b' are the same class type, or    `a' and `b' are of class types A and B such that B is a descendant of A.  */
end_comment

begin_function
name|int
name|maybe_objc_comptypes
parameter_list|(
name|lhs
parameter_list|,
name|rhs
parameter_list|,
name|reflexive
parameter_list|)
name|tree
name|lhs
decl_stmt|,
name|rhs
decl_stmt|;
name|int
name|reflexive
decl_stmt|;
block|{
if|if
condition|(
name|doing_objc_thang
condition|)
return|return
name|objc_comptypes
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|,
name|reflexive
argument_list|)
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|lookup_method_in_protocol_list
parameter_list|(
name|rproto_list
parameter_list|,
name|sel_name
parameter_list|,
name|class_meth
parameter_list|)
name|tree
name|rproto_list
decl_stmt|;
name|tree
name|sel_name
decl_stmt|;
name|int
name|class_meth
decl_stmt|;
block|{
name|tree
name|rproto
decl_stmt|,
name|p
decl_stmt|;
name|tree
name|fnd
init|=
literal|0
decl_stmt|;
for|for
control|(
name|rproto
operator|=
name|rproto_list
init|;
name|rproto
condition|;
name|rproto
operator|=
name|TREE_CHAIN
argument_list|(
name|rproto
argument_list|)
control|)
block|{
name|p
operator|=
name|TREE_VALUE
argument_list|(
name|rproto
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|PROTOCOL_INTERFACE_TYPE
condition|)
block|{
if|if
condition|(
operator|(
name|fnd
operator|=
name|lookup_method
argument_list|(
name|class_meth
condition|?
name|PROTOCOL_CLS_METHODS
argument_list|(
name|p
argument_list|)
else|:
name|PROTOCOL_NST_METHODS
argument_list|(
name|p
argument_list|)
argument_list|,
name|sel_name
argument_list|)
operator|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|PROTOCOL_LIST
argument_list|(
name|p
argument_list|)
condition|)
name|fnd
operator|=
name|lookup_method_in_protocol_list
argument_list|(
name|PROTOCOL_LIST
argument_list|(
name|p
argument_list|)
argument_list|,
name|sel_name
argument_list|,
name|class_meth
argument_list|)
expr_stmt|;
block|}
else|else
empty_stmt|;
comment|/* An identifier...if we could not find a protocol.  */
if|if
condition|(
name|fnd
condition|)
return|return
name|fnd
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|lookup_protocol_in_reflist
parameter_list|(
name|rproto_list
parameter_list|,
name|lproto
parameter_list|)
name|tree
name|rproto_list
decl_stmt|;
name|tree
name|lproto
decl_stmt|;
block|{
name|tree
name|rproto
decl_stmt|,
name|p
decl_stmt|;
comment|/* Make sure the protocol is support by the object on the rhs. */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lproto
argument_list|)
operator|==
name|PROTOCOL_INTERFACE_TYPE
condition|)
block|{
name|tree
name|fnd
init|=
literal|0
decl_stmt|;
for|for
control|(
name|rproto
operator|=
name|rproto_list
init|;
name|rproto
condition|;
name|rproto
operator|=
name|TREE_CHAIN
argument_list|(
name|rproto
argument_list|)
control|)
block|{
name|p
operator|=
name|TREE_VALUE
argument_list|(
name|rproto
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|PROTOCOL_INTERFACE_TYPE
condition|)
block|{
if|if
condition|(
name|lproto
operator|==
name|p
condition|)
name|fnd
operator|=
name|lproto
expr_stmt|;
elseif|else
if|if
condition|(
name|PROTOCOL_LIST
argument_list|(
name|p
argument_list|)
condition|)
name|fnd
operator|=
name|lookup_protocol_in_reflist
argument_list|(
name|PROTOCOL_LIST
argument_list|(
name|p
argument_list|)
argument_list|,
name|lproto
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fnd
condition|)
return|return
name|fnd
return|;
block|}
block|}
else|else
empty_stmt|;
comment|/* An identifier...if we could not find a protocol. */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if LHS and RHS are compatible types for assignment    or various other operations.  Return 0 if they are incompatible,    and return -1 if we choose to not decide.  When the operation    is REFLEXIVE, check for compatibility in either direction.  */
end_comment

begin_function
name|int
name|objc_comptypes
parameter_list|(
name|lhs
parameter_list|,
name|rhs
parameter_list|,
name|reflexive
parameter_list|)
name|tree
name|lhs
decl_stmt|;
name|tree
name|rhs
decl_stmt|;
name|int
name|reflexive
decl_stmt|;
block|{
comment|/* New clause for protocols. */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
name|int
name|lhs_is_proto
init|=
name|IS_PROTOCOL_QUALIFIED_ID
argument_list|(
name|lhs
argument_list|)
decl_stmt|;
name|int
name|rhs_is_proto
init|=
name|IS_PROTOCOL_QUALIFIED_ID
argument_list|(
name|rhs
argument_list|)
decl_stmt|;
if|if
condition|(
name|lhs_is_proto
condition|)
block|{
name|tree
name|lproto
decl_stmt|,
name|lproto_list
init|=
name|TYPE_PROTOCOL_LIST
argument_list|(
name|lhs
argument_list|)
decl_stmt|;
name|tree
name|rproto
decl_stmt|,
name|rproto_list
decl_stmt|;
name|tree
name|p
decl_stmt|;
if|if
condition|(
name|rhs_is_proto
condition|)
block|{
name|rproto_list
operator|=
name|TYPE_PROTOCOL_LIST
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
comment|/* Make sure the protocol is supported by the object 		 on the rhs.  */
for|for
control|(
name|lproto
operator|=
name|lproto_list
init|;
name|lproto
condition|;
name|lproto
operator|=
name|TREE_CHAIN
argument_list|(
name|lproto
argument_list|)
control|)
block|{
name|p
operator|=
name|TREE_VALUE
argument_list|(
name|lproto
argument_list|)
expr_stmt|;
name|rproto
operator|=
name|lookup_protocol_in_reflist
argument_list|(
name|rproto_list
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rproto
condition|)
name|warning
argument_list|(
literal|"object does not conform to the `%s' protocol"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|PROTOCOL_NAME
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TYPED_OBJECT
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|rname
init|=
name|TYPE_NAME
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|rinter
decl_stmt|;
comment|/* Make sure the protocol is supported by the object 		 on the rhs.  */
for|for
control|(
name|lproto
operator|=
name|lproto_list
init|;
name|lproto
condition|;
name|lproto
operator|=
name|TREE_CHAIN
argument_list|(
name|lproto
argument_list|)
control|)
block|{
name|p
operator|=
name|TREE_VALUE
argument_list|(
name|lproto
argument_list|)
expr_stmt|;
name|rproto
operator|=
literal|0
expr_stmt|;
name|rinter
operator|=
name|lookup_interface
argument_list|(
name|rname
argument_list|)
expr_stmt|;
while|while
condition|(
name|rinter
operator|&&
operator|!
name|rproto
condition|)
block|{
name|tree
name|cat
decl_stmt|;
name|rproto_list
operator|=
name|CLASS_PROTOCOL_LIST
argument_list|(
name|rinter
argument_list|)
expr_stmt|;
name|rproto
operator|=
name|lookup_protocol_in_reflist
argument_list|(
name|rproto_list
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* Check for protocols adopted by categories. */
name|cat
operator|=
name|CLASS_CATEGORY_LIST
argument_list|(
name|rinter
argument_list|)
expr_stmt|;
while|while
condition|(
name|cat
operator|&&
operator|!
name|rproto
condition|)
block|{
name|rproto_list
operator|=
name|CLASS_PROTOCOL_LIST
argument_list|(
name|cat
argument_list|)
expr_stmt|;
name|rproto
operator|=
name|lookup_protocol_in_reflist
argument_list|(
name|rproto_list
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|cat
operator|=
name|CLASS_CATEGORY_LIST
argument_list|(
name|cat
argument_list|)
expr_stmt|;
block|}
name|rinter
operator|=
name|lookup_interface
argument_list|(
name|CLASS_SUPER_NAME
argument_list|(
name|rinter
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|rproto
condition|)
name|warning
argument_list|(
literal|"class `%s' does not implement the `%s' protocol"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TYPE_NAME
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|PROTOCOL_NAME
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* May change...based on whether there was any mismatch */
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|rhs_is_proto
condition|)
comment|/* Lhs is not a protocol...warn if it is statically typed */
return|return
operator|(
name|TYPED_OBJECT
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|)
operator|!=
literal|0
operator|)
return|;
else|else
comment|/* Defer to comptypes .*/
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
empty_stmt|;
comment|/* Fall thru.  This is the case we have been handling all along */
else|else
comment|/* Defer to comptypes. */
return|return
operator|-
literal|1
return|;
comment|/* `id' = `<class> *', `<class> *' = `id' */
if|if
condition|(
operator|(
name|TYPE_NAME
argument_list|(
name|lhs
argument_list|)
operator|==
name|objc_object_id
operator|&&
name|TYPED_OBJECT
argument_list|(
name|rhs
argument_list|)
operator|)
operator|||
operator|(
name|TYPE_NAME
argument_list|(
name|rhs
argument_list|)
operator|==
name|objc_object_id
operator|&&
name|TYPED_OBJECT
argument_list|(
name|lhs
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
comment|/* `id' = `Class', `Class' = `id' */
elseif|else
if|if
condition|(
operator|(
name|TYPE_NAME
argument_list|(
name|lhs
argument_list|)
operator|==
name|objc_object_id
operator|&&
name|TYPE_NAME
argument_list|(
name|rhs
argument_list|)
operator|==
name|objc_class_id
operator|)
operator|||
operator|(
name|TYPE_NAME
argument_list|(
name|lhs
argument_list|)
operator|==
name|objc_class_id
operator|&&
name|TYPE_NAME
argument_list|(
name|rhs
argument_list|)
operator|==
name|objc_object_id
operator|)
condition|)
return|return
literal|1
return|;
comment|/* `<class> *' = `<class> *' */
elseif|else
if|if
condition|(
name|TYPED_OBJECT
argument_list|(
name|lhs
argument_list|)
operator|&&
name|TYPED_OBJECT
argument_list|(
name|rhs
argument_list|)
condition|)
block|{
name|tree
name|lname
init|=
name|TYPE_NAME
argument_list|(
name|lhs
argument_list|)
decl_stmt|;
name|tree
name|rname
init|=
name|TYPE_NAME
argument_list|(
name|rhs
argument_list|)
decl_stmt|;
name|tree
name|inter
decl_stmt|;
if|if
condition|(
name|lname
operator|==
name|rname
condition|)
return|return
literal|1
return|;
comment|/* If the left hand side is a super class of the right hand side, 	 allow it.  */
for|for
control|(
name|inter
operator|=
name|lookup_interface
argument_list|(
name|rname
argument_list|)
init|;
name|inter
condition|;
name|inter
operator|=
name|lookup_interface
argument_list|(
name|CLASS_SUPER_NAME
argument_list|(
name|inter
argument_list|)
argument_list|)
control|)
if|if
condition|(
name|lname
operator|==
name|CLASS_SUPER_NAME
argument_list|(
name|inter
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Allow the reverse when reflexive.  */
if|if
condition|(
name|reflexive
condition|)
for|for
control|(
name|inter
operator|=
name|lookup_interface
argument_list|(
name|lname
argument_list|)
init|;
name|inter
condition|;
name|inter
operator|=
name|lookup_interface
argument_list|(
name|CLASS_SUPER_NAME
argument_list|(
name|inter
argument_list|)
argument_list|)
control|)
if|if
condition|(
name|rname
operator|==
name|CLASS_SUPER_NAME
argument_list|(
name|inter
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
else|else
comment|/* Defer to comptypes. */
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Called from c-decl.c before all calls to rest_of_decl_compilation.  */
end_comment

begin_function
name|void
name|objc_check_decl
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|TREE_STATIC_TEMPLATE
argument_list|(
name|type
argument_list|)
operator|&&
name|type
operator|!=
name|constant_string_type
condition|)
block|{
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"`%s' cannot be statically allocated"
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
literal|"statically allocated objects not supported"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|maybe_objc_check_decl
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
name|doing_objc_thang
condition|)
name|objc_check_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Implement static typing.  At this point, we know we have an interface.  */
end_comment

begin_function
name|tree
name|get_static_reference
parameter_list|(
name|interface
parameter_list|,
name|protocols
parameter_list|)
name|tree
name|interface
decl_stmt|;
name|tree
name|protocols
decl_stmt|;
block|{
name|tree
name|type
init|=
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|interface
argument_list|)
decl_stmt|;
if|if
condition|(
name|protocols
condition|)
block|{
name|tree
name|t
decl_stmt|,
name|m
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|end_temporary_allocation
argument_list|()
expr_stmt|;
name|t
operator|=
name|copy_node
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
operator|=
name|make_tree_vec
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
comment|/* Add this type to the chain of variants of TYPE.  */
name|TYPE_NEXT_VARIANT
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|TYPE_NEXT_VARIANT
argument_list|(
name|m
argument_list|)
operator|=
name|t
expr_stmt|;
comment|/* Look up protocols and install in lang specific list.  */
name|TYPE_PROTOCOL_LIST
argument_list|(
name|t
argument_list|)
operator|=
name|lookup_and_install_protocols
argument_list|(
name|protocols
argument_list|)
expr_stmt|;
comment|/* This forces a new pointer type to be created later 	 (in build_pointer_type)...so that the new template 	 we just created will actually be used...what a hack!  */
if|if
condition|(
name|TYPE_POINTER_TO
argument_list|(
name|t
argument_list|)
condition|)
name|TYPE_POINTER_TO
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|type
operator|=
name|t
expr_stmt|;
block|}
return|return
name|type
return|;
block|}
end_function

begin_function
name|tree
name|get_object_reference
parameter_list|(
name|protocols
parameter_list|)
name|tree
name|protocols
decl_stmt|;
block|{
name|tree
name|type_decl
init|=
name|lookup_name
argument_list|(
name|objc_id_id
argument_list|)
decl_stmt|;
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|type_decl
operator|&&
name|TREE_CODE
argument_list|(
name|type_decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|!=
name|id_type
condition|)
name|warning
argument_list|(
literal|"Unexpected type for `id' (%s)"
argument_list|,
name|gen_declaration
argument_list|(
name|type
argument_list|,
name|errbuf
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|fatal
argument_list|(
literal|"Undefined type `id', please import<objc/objc.h>"
argument_list|)
expr_stmt|;
comment|/* This clause creates a new pointer type that is qualified with      the protocol specification...this info is used later to do more      elaborate type checking.  */
if|if
condition|(
name|protocols
condition|)
block|{
name|tree
name|t
decl_stmt|,
name|m
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|end_temporary_allocation
argument_list|()
expr_stmt|;
name|t
operator|=
name|copy_node
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
operator|=
name|make_tree_vec
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
comment|/* Add this type to the chain of variants of TYPE.  */
name|TYPE_NEXT_VARIANT
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|TYPE_NEXT_VARIANT
argument_list|(
name|m
argument_list|)
operator|=
name|t
expr_stmt|;
comment|/* Look up protocols...and install in lang specific list */
name|TYPE_PROTOCOL_LIST
argument_list|(
name|t
argument_list|)
operator|=
name|lookup_and_install_protocols
argument_list|(
name|protocols
argument_list|)
expr_stmt|;
comment|/* This forces a new pointer type to be created later 	 (in build_pointer_type)...so that the new template 	 we just created will actually be used...what a hack!  */
if|if
condition|(
name|TYPE_POINTER_TO
argument_list|(
name|t
argument_list|)
condition|)
name|TYPE_POINTER_TO
argument_list|(
name|t
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|type
operator|=
name|t
expr_stmt|;
block|}
return|return
name|type
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|lookup_and_install_protocols
parameter_list|(
name|protocols
parameter_list|)
name|tree
name|protocols
decl_stmt|;
block|{
name|tree
name|proto
decl_stmt|;
name|tree
name|prev
init|=
name|NULL
decl_stmt|;
name|tree
name|return_value
init|=
name|protocols
decl_stmt|;
for|for
control|(
name|proto
operator|=
name|protocols
init|;
name|proto
condition|;
name|proto
operator|=
name|TREE_CHAIN
argument_list|(
name|proto
argument_list|)
control|)
block|{
name|tree
name|ident
init|=
name|TREE_VALUE
argument_list|(
name|proto
argument_list|)
decl_stmt|;
name|tree
name|p
init|=
name|lookup_protocol
argument_list|(
name|ident
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
block|{
name|error
argument_list|(
literal|"Cannot find protocol declaration for `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|ident
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
condition|)
name|TREE_CHAIN
argument_list|(
name|prev
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|proto
argument_list|)
expr_stmt|;
else|else
name|return_value
operator|=
name|TREE_CHAIN
argument_list|(
name|proto
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Replace identifier with actual protocol node. */
name|TREE_VALUE
argument_list|(
name|proto
argument_list|)
operator|=
name|p
expr_stmt|;
name|prev
operator|=
name|proto
expr_stmt|;
block|}
block|}
return|return
name|return_value
return|;
block|}
end_function

begin_comment
comment|/* Create and push a decl for a built-in external variable or field NAME.    CODE says which.    TYPE is its data type.  */
end_comment

begin_function
specifier|static
name|tree
name|create_builtin_decl
parameter_list|(
name|code
parameter_list|,
name|type
parameter_list|,
name|name
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|tree
name|decl
init|=
name|build_decl
argument_list|(
name|code
argument_list|,
name|get_identifier
argument_list|(
name|name
argument_list|)
argument_list|,
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|VAR_DECL
condition|)
block|{
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|make_decl_rtl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Purpose: "play" parser, creating/installing representations    of the declarations that are required by Objective-C.     Model:   	type_spec--------->sc_spec  	(tree_list)        (tree_list)  	    |                  |  	    |                  |  	identifier_node    identifier_node  */
end_comment

begin_function
specifier|static
name|void
name|synth_module_prologue
parameter_list|()
block|{
name|tree
name|temp_type
decl_stmt|;
name|tree
name|super_p
decl_stmt|;
comment|/* Defined in `objc.h' */
name|objc_object_id
operator|=
name|get_identifier
argument_list|(
name|TAG_OBJECT
argument_list|)
expr_stmt|;
name|objc_object_reference
operator|=
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|objc_object_id
argument_list|)
expr_stmt|;
name|id_type
operator|=
name|build_pointer_type
argument_list|(
name|objc_object_reference
argument_list|)
expr_stmt|;
name|objc_id_id
operator|=
name|get_identifier
argument_list|(
name|TYPE_ID
argument_list|)
expr_stmt|;
name|objc_class_id
operator|=
name|get_identifier
argument_list|(
name|TAG_CLASS
argument_list|)
expr_stmt|;
name|objc_class_type
operator|=
name|build_pointer_type
argument_list|(
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|objc_class_id
argument_list|)
argument_list|)
expr_stmt|;
name|protocol_type
operator|=
name|build_pointer_type
argument_list|(
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|PROTOCOL_OBJECT_CLASS_NAME
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Declare type of selector-objects that represent an operation name.  */
ifdef|#
directive|ifdef
name|OBJC_INT_SELECTORS
comment|/* `unsigned int' */
name|selector_type
operator|=
name|unsigned_type_node
expr_stmt|;
else|#
directive|else
comment|/* `struct objc_selector *' */
name|selector_type
operator|=
name|build_pointer_type
argument_list|(
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|TAG_SELECTOR
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not OBJC_INT_SELECTORS */
comment|/* Forward declare type, or else the prototype for msgSendSuper will      complain.  */
name|super_p
operator|=
name|build_pointer_type
argument_list|(
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|TAG_SUPER
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* id objc_msgSend (id, SEL, ...); */
name|temp_type
operator|=
name|build_function_type
argument_list|(
name|id_type
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|id_type
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|selector_type
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag_next_runtime
condition|)
block|{
name|umsg_decl
operator|=
name|build_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|get_identifier
argument_list|(
name|TAG_MSGSEND
argument_list|)
argument_list|,
name|temp_type
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|umsg_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|umsg_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_INLINE
argument_list|(
name|umsg_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|umsg_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|flag_traditional
operator|&&
name|TAG_MSGSEND
index|[
literal|0
index|]
operator|!=
literal|'_'
condition|)
name|DECL_BUILT_IN_NONANSI
argument_list|(
name|umsg_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|make_decl_rtl
argument_list|(
name|umsg_decl
argument_list|,
name|NULL_PTR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|umsg_decl
argument_list|)
expr_stmt|;
block|}
else|else
name|umsg_decl
operator|=
name|builtin_function
argument_list|(
name|TAG_MSGSEND
argument_list|,
name|temp_type
argument_list|,
name|NOT_BUILT_IN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* id objc_msgSendSuper (struct objc_super *, SEL, ...); */
name|temp_type
operator|=
name|build_function_type
argument_list|(
name|id_type
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|super_p
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|selector_type
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|umsg_super_decl
operator|=
name|builtin_function
argument_list|(
name|TAG_MSGSENDSUPER
argument_list|,
name|temp_type
argument_list|,
name|NOT_BUILT_IN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* id objc_getClass (const char *); */
name|temp_type
operator|=
name|build_function_type
argument_list|(
name|id_type
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|const_string_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|void_type_node
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|objc_get_class_decl
operator|=
name|builtin_function
argument_list|(
name|TAG_GETCLASS
argument_list|,
name|temp_type
argument_list|,
name|NOT_BUILT_IN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* id objc_getMetaClass (const char *); */
name|objc_get_meta_class_decl
operator|=
name|builtin_function
argument_list|(
name|TAG_GETMETACLASS
argument_list|,
name|temp_type
argument_list|,
name|NOT_BUILT_IN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* static SEL _OBJC_SELECTOR_TABLE[]; */
if|if
condition|(
operator|!
name|flag_next_runtime
condition|)
block|{
if|if
condition|(
name|flag_typed_selectors
condition|)
block|{
comment|/* Suppress outputting debug symbols, because 	     dbxout_init hasn'r been called yet.  */
name|enum
name|debug_info_type
name|save_write_symbols
init|=
name|write_symbols
decl_stmt|;
name|write_symbols
operator|=
name|NO_DEBUG
expr_stmt|;
name|build_selector_template
argument_list|()
expr_stmt|;
name|temp_type
operator|=
name|build_array_type
argument_list|(
name|objc_selector_template
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|write_symbols
operator|=
name|save_write_symbols
expr_stmt|;
block|}
else|else
name|temp_type
operator|=
name|build_array_type
argument_list|(
name|selector_type
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|temp_type
argument_list|)
expr_stmt|;
name|UOBJC_SELECTOR_TABLE_decl
operator|=
name|create_builtin_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|temp_type
argument_list|,
literal|"_OBJC_SELECTOR_TABLE"
argument_list|)
expr_stmt|;
comment|/* Avoid warning when not sending messages.  */
name|TREE_USED
argument_list|(
name|UOBJC_SELECTOR_TABLE_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|generate_forward_declaration_to_string_table
argument_list|()
expr_stmt|;
comment|/* Forward declare constant_string_id and constant_string_type.  */
name|constant_string_id
operator|=
name|get_identifier
argument_list|(
name|STRING_OBJECT_CLASS_NAME
argument_list|)
expr_stmt|;
name|constant_string_type
operator|=
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|constant_string_id
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Custom build_string which sets TREE_TYPE!  */
end_comment

begin_function
specifier|static
name|tree
name|my_build_string
parameter_list|(
name|len
parameter_list|,
name|str
parameter_list|)
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|int
name|wide_flag
init|=
literal|0
decl_stmt|;
name|tree
name|a_string
init|=
name|build_string
argument_list|(
name|len
argument_list|,
name|str
argument_list|)
decl_stmt|;
comment|/* Some code from combine_strings, which is local to c-parse.y.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|a_string
argument_list|)
operator|==
name|int_array_type_node
condition|)
name|wide_flag
operator|=
literal|1
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|a_string
argument_list|)
operator|=
name|build_array_type
argument_list|(
name|wide_flag
condition|?
name|integer_type_node
else|:
name|char_type_node
argument_list|,
name|build_index_type
argument_list|(
name|build_int_2
argument_list|(
name|len
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|a_string
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Puts string in the readonly segment */
name|TREE_STATIC
argument_list|(
name|a_string
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|a_string
return|;
block|}
end_function

begin_comment
comment|/* Return a newly constructed OBJC_STRING_CST node whose value is    the LEN characters at STR.    The TREE_TYPE is not initialized.  */
end_comment

begin_function
name|tree
name|build_objc_string
parameter_list|(
name|len
parameter_list|,
name|str
parameter_list|)
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|tree
name|s
init|=
name|build_string
argument_list|(
name|len
argument_list|,
name|str
argument_list|)
decl_stmt|;
name|TREE_SET_CODE
argument_list|(
name|s
argument_list|,
name|OBJC_STRING_CST
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* Given a chain of OBJC_STRING_CST's, build a static instance of    NXConstanString which points at the concatenation of those strings.    We place the string object in the __string_objects section of the    __OBJC segment.  The Objective-C runtime will initialize the isa    pointers of the string objects to point at the NXConstandString class    object.  */
end_comment

begin_function
name|tree
name|build_objc_string_object
parameter_list|(
name|strings
parameter_list|)
name|tree
name|strings
decl_stmt|;
block|{
name|tree
name|string
decl_stmt|,
name|initlist
decl_stmt|,
name|constructor
decl_stmt|;
name|int
name|length
decl_stmt|;
if|if
condition|(
operator|!
name|doing_objc_thang
condition|)
name|objc_fatal
argument_list|()
expr_stmt|;
if|if
condition|(
name|lookup_interface
argument_list|(
name|constant_string_id
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"Cannot find interface declaration for `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|constant_string_id
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|add_class_reference
argument_list|(
name|constant_string_id
argument_list|)
expr_stmt|;
comment|/* Combine_strings will work for OBJC_STRING_CST's too.  */
name|string
operator|=
name|combine_strings
argument_list|(
name|strings
argument_list|)
expr_stmt|;
name|TREE_SET_CODE
argument_list|(
name|string
argument_list|,
name|STRING_CST
argument_list|)
expr_stmt|;
name|length
operator|=
name|TREE_STRING_LENGTH
argument_list|(
name|string
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|flag_next_runtime
condition|)
block|{
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|end_temporary_allocation
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_PERMANENT
argument_list|(
name|strings
argument_list|)
condition|)
name|string
operator|=
name|my_build_string
argument_list|(
name|length
operator|+
literal|1
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*& ((NXConstantString) {0, string, length})  */
name|initlist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|copy_node
argument_list|(
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|string
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
name|length
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
name|constructor
operator|=
name|build_constructor
argument_list|(
name|constant_string_type
argument_list|,
name|nreverse
argument_list|(
name|initlist
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag_next_runtime
condition|)
block|{
name|constructor
operator|=
name|objc_add_static_instance
argument_list|(
name|constructor
argument_list|,
name|constant_string_type
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|constructor
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Declare a static instance of CLASS_DECL initialized by CONSTRUCTOR.  */
end_comment

begin_function
specifier|static
name|tree
name|objc_add_static_instance
parameter_list|(
name|constructor
parameter_list|,
name|class_decl
parameter_list|)
name|tree
name|constructor
decl_stmt|,
name|class_decl
decl_stmt|;
block|{
specifier|static
name|int
name|num_static_inst
decl_stmt|;
name|tree
modifier|*
name|chain
decl_stmt|,
name|decl
decl_stmt|,
name|decl_spec
decl_stmt|,
name|decl_expr
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|end_temporary_allocation
argument_list|()
expr_stmt|;
comment|/* Find the list of static instances for the CLASS_DECL.  Create one if      not found.  */
for|for
control|(
name|chain
operator|=
operator|&
name|objc_static_instances
init|;
operator|*
name|chain
operator|&&
name|TREE_VALUE
argument_list|(
operator|*
name|chain
argument_list|)
operator|!=
name|class_decl
condition|;
name|chain
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|chain
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
operator|!
operator|*
name|chain
condition|)
block|{
operator|*
name|chain
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|class_decl
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|add_objc_string
argument_list|(
name|TYPE_NAME
argument_list|(
name|class_decl
argument_list|)
argument_list|,
name|class_names
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"_OBJC_INSTANCE_%d"
argument_list|,
name|num_static_inst
operator|++
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|get_identifier
argument_list|(
name|buf
argument_list|)
argument_list|,
name|class_decl
argument_list|)
expr_stmt|;
name|DECL_COMMON
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|pushdecl_top_level
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Do this here so it gets output later instead of possibly      inside something else we are writing.  */
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|constructor
expr_stmt|;
comment|/* Add the DECL to the head of this CLASS' list.  */
name|TREE_PURPOSE
argument_list|(
operator|*
name|chain
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|decl
argument_list|,
name|TREE_PURPOSE
argument_list|(
operator|*
name|chain
argument_list|)
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Build a static constant CONSTRUCTOR    with type TYPE and elements ELTS.  */
end_comment

begin_function
specifier|static
name|tree
name|build_constructor
parameter_list|(
name|type
parameter_list|,
name|elts
parameter_list|)
name|tree
name|type
decl_stmt|,
name|elts
decl_stmt|;
block|{
name|tree
name|constructor
init|=
name|build
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|type
argument_list|,
name|NULL_TREE
argument_list|,
name|elts
argument_list|)
decl_stmt|;
name|TREE_CONSTANT
argument_list|(
name|constructor
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|constructor
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|constructor
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|constructor
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Take care of defining and initializing _OBJC_SYMBOLS.  */
end_comment

begin_comment
comment|/* Predefine the following data type:     struct _objc_symtab    {      long sel_ref_cnt;      SEL *refs;      short cls_def_cnt;      short cat_def_cnt;      void *defs[cls_def_cnt + cat_def_cnt];    }; */
end_comment

begin_function
specifier|static
name|void
name|build_objc_symtab_template
parameter_list|()
block|{
name|tree
name|field_decl
decl_stmt|,
name|field_decl_chain
decl_stmt|,
name|index
decl_stmt|;
name|objc_symtab_template
operator|=
name|start_struct
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_SYMTAB
argument_list|)
argument_list|)
expr_stmt|;
comment|/* long sel_ref_cnt; */
name|field_decl
operator|=
name|create_builtin_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|long_integer_type_node
argument_list|,
literal|"sel_ref_cnt"
argument_list|)
expr_stmt|;
name|field_decl_chain
operator|=
name|field_decl
expr_stmt|;
comment|/* SEL *refs; */
name|field_decl
operator|=
name|create_builtin_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|build_pointer_type
argument_list|(
name|selector_type
argument_list|)
argument_list|,
literal|"refs"
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* short cls_def_cnt; */
name|field_decl
operator|=
name|create_builtin_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|short_integer_type_node
argument_list|,
literal|"cls_def_cnt"
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* short cat_def_cnt; */
name|field_decl
operator|=
name|create_builtin_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|short_integer_type_node
argument_list|,
literal|"cat_def_cnt"
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* void *defs[cls_def_cnt + cat_def_cnt]; */
name|index
operator|=
name|build_index_type
argument_list|(
name|build_int_2
argument_list|(
name|imp_count
operator|+
name|cat_count
operator|-
literal|1
argument_list|,
name|imp_count
operator|==
literal|0
operator|&&
name|cat_count
operator|==
literal|0
condition|?
operator|-
literal|1
else|:
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|create_builtin_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|build_array_type
argument_list|(
name|ptr_type_node
argument_list|,
name|index
argument_list|)
argument_list|,
literal|"defs"
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
name|finish_struct
argument_list|(
name|objc_symtab_template
argument_list|,
name|field_decl_chain
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create the initial value for the `defs' field of _objc_symtab.    This is a CONSTRUCTOR.  */
end_comment

begin_function
specifier|static
name|tree
name|init_def_list
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|expr
decl_stmt|,
name|initlist
init|=
name|NULL_TREE
decl_stmt|;
name|struct
name|imp_entry
modifier|*
name|impent
decl_stmt|;
if|if
condition|(
name|imp_count
condition|)
for|for
control|(
name|impent
operator|=
name|imp_list
init|;
name|impent
condition|;
name|impent
operator|=
name|impent
operator|->
name|next
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|impent
operator|->
name|imp_context
argument_list|)
operator|==
name|CLASS_IMPLEMENTATION_TYPE
condition|)
block|{
name|expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|impent
operator|->
name|class_decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cat_count
condition|)
for|for
control|(
name|impent
operator|=
name|imp_list
init|;
name|impent
condition|;
name|impent
operator|=
name|impent
operator|->
name|next
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|impent
operator|->
name|imp_context
argument_list|)
operator|==
name|CATEGORY_IMPLEMENTATION_TYPE
condition|)
block|{
name|expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|impent
operator|->
name|class_decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|build_constructor
argument_list|(
name|type
argument_list|,
name|nreverse
argument_list|(
name|initlist
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Construct the initial value for all of _objc_symtab.  */
end_comment

begin_function
specifier|static
name|tree
name|init_objc_symtab
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|initlist
decl_stmt|;
comment|/* sel_ref_cnt = { ..., 5, ... } */
name|initlist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* refs = { ..., _OBJC_SELECTOR_TABLE, ... } */
if|if
condition|(
name|flag_next_runtime
operator|||
operator|!
name|sel_ref_chain
condition|)
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
else|else
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|UOBJC_SELECTOR_TABLE_decl
argument_list|,
literal|1
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
comment|/* cls_def_cnt = { ..., 5, ... } */
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
name|imp_count
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
comment|/* cat_def_cnt = { ..., 5, ... } */
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
name|cat_count
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
comment|/* cls_def = { ..., {&Foo,&Bar, ...}, ... } */
if|if
condition|(
name|imp_count
operator|||
name|cat_count
condition|)
block|{
name|tree
name|field
init|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|init_def_list
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
block|}
return|return
name|build_constructor
argument_list|(
name|type
argument_list|,
name|nreverse
argument_list|(
name|initlist
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Push forward-declarations of all the categories    so that init_def_list can use them in a CONSTRUCTOR.  */
end_comment

begin_function
specifier|static
name|void
name|forward_declare_categories
parameter_list|()
block|{
name|struct
name|imp_entry
modifier|*
name|impent
decl_stmt|;
name|tree
name|sav
init|=
name|implementation_context
decl_stmt|;
for|for
control|(
name|impent
operator|=
name|imp_list
init|;
name|impent
condition|;
name|impent
operator|=
name|impent
operator|->
name|next
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|impent
operator|->
name|imp_context
argument_list|)
operator|==
name|CATEGORY_IMPLEMENTATION_TYPE
condition|)
block|{
comment|/* Set an invisible arg to synth_id_with_class_suffix.  */
name|implementation_context
operator|=
name|impent
operator|->
name|imp_context
expr_stmt|;
name|impent
operator|->
name|class_decl
operator|=
name|create_builtin_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|objc_category_template
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|synth_id_with_class_suffix
argument_list|(
literal|"_OBJC_CATEGORY"
argument_list|,
name|implementation_context
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|implementation_context
operator|=
name|sav
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create the declaration of _OBJC_SYMBOLS, with type `strict _objc_symtab'    and initialized appropriately.  */
end_comment

begin_function
specifier|static
name|void
name|generate_objc_symtab_decl
parameter_list|()
block|{
name|tree
name|sc_spec
decl_stmt|;
if|if
condition|(
operator|!
name|objc_category_template
condition|)
name|build_category_template
argument_list|()
expr_stmt|;
comment|/* forward declare categories */
if|if
condition|(
name|cat_count
condition|)
name|forward_declare_categories
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|objc_symtab_template
condition|)
name|build_objc_symtab_template
argument_list|()
expr_stmt|;
name|sc_spec
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_STATIC
index|]
argument_list|)
expr_stmt|;
name|UOBJC_SYMBOLS_decl
operator|=
name|start_decl
argument_list|(
name|get_identifier
argument_list|(
literal|"_OBJC_SYMBOLS"
argument_list|)
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|objc_symtab_template
argument_list|,
name|sc_spec
argument_list|)
argument_list|,
literal|1
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|UOBJC_SYMBOLS_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_IGNORED_P
argument_list|(
name|UOBJC_SYMBOLS_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|UOBJC_SYMBOLS_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|finish_decl
argument_list|(
name|UOBJC_SYMBOLS_decl
argument_list|,
name|init_objc_symtab
argument_list|(
name|TREE_TYPE
argument_list|(
name|UOBJC_SYMBOLS_decl
argument_list|)
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|tree
name|init_module_descriptor
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|initlist
decl_stmt|,
name|expr
decl_stmt|;
comment|/* version = { 1, ... } */
name|expr
operator|=
name|build_int_2
argument_list|(
name|OBJC_VERSION
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|)
expr_stmt|;
comment|/* size = { ..., sizeof (struct objc_module), ... } */
name|expr
operator|=
name|size_in_bytes
argument_list|(
name|objc_module_template
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
comment|/* name = { ..., "foo.m", ... } */
name|expr
operator|=
name|add_objc_string
argument_list|(
name|get_identifier
argument_list|(
name|input_filename
argument_list|)
argument_list|,
name|class_names
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag_next_runtime
condition|)
block|{
comment|/* statics = { ..., _OBJC_STATIC_INSTANCES, ... }  */
if|if
condition|(
name|static_instances_decl
condition|)
name|expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|static_instances_decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|expr
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
block|}
comment|/* symtab = { ..., _OBJC_SYMBOLS, ... } */
if|if
condition|(
name|UOBJC_SYMBOLS_decl
condition|)
name|expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|UOBJC_SYMBOLS_decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|expr
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
return|return
name|build_constructor
argument_list|(
name|type
argument_list|,
name|nreverse
argument_list|(
name|initlist
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Write out the data structures to describe Objective C classes defined.    If appropriate, compile and output a setup function to initialize them.    Return a string which is the name of a function to call to initialize    the Objective C data structures for this file (and perhaps for other files    also).     struct objc_module { ... } _OBJC_MODULE = { ... };   */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|build_module_descriptor
parameter_list|()
block|{
name|tree
name|decl_specs
decl_stmt|,
name|field_decl
decl_stmt|,
name|field_decl_chain
decl_stmt|;
name|objc_module_template
operator|=
name|start_struct
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_MODULE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Long version; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_LONG
index|]
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|get_identifier
argument_list|(
literal|"version"
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|field_decl_chain
operator|=
name|field_decl
expr_stmt|;
comment|/* long  size; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_LONG
index|]
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|get_identifier
argument_list|(
literal|"size"
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* char  *name; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CHAR
index|]
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"name"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag_next_runtime
condition|)
block|{
comment|/* void *statics */
name|decl_specs
operator|=
name|get_identifier
argument_list|(
name|UTAG_STATICS
argument_list|)
expr_stmt|;
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|decl_specs
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"statics"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
block|}
comment|/* struct objc_symtab *symtab; */
name|decl_specs
operator|=
name|get_identifier
argument_list|(
name|UTAG_SYMTAB
argument_list|)
expr_stmt|;
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|decl_specs
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"symtab"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
name|finish_struct
argument_list|(
name|objc_module_template
argument_list|,
name|field_decl_chain
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* Create an instance of "objc_module". */
name|decl_specs
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|objc_module_template
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_STATIC
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|UOBJC_MODULES_decl
operator|=
name|start_decl
argument_list|(
name|get_identifier
argument_list|(
literal|"_OBJC_MODULES"
argument_list|)
argument_list|,
name|decl_specs
argument_list|,
literal|1
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|UOBJC_MODULES_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_IGNORED_P
argument_list|(
name|UOBJC_MODULES_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|finish_decl
argument_list|(
name|UOBJC_MODULES_decl
argument_list|,
name|init_module_descriptor
argument_list|(
name|TREE_TYPE
argument_list|(
name|UOBJC_MODULES_decl
argument_list|)
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* Mark the decl to avoid "defined but not used" warning. */
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|UOBJC_MODULES_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Generate a constructor call for the module descriptor.      This code was generated by reading the grammar rules      of c-parse.in;  Therefore, it may not be the most efficient      way of generating the requisite code. */
if|if
condition|(
name|flag_next_runtime
condition|)
return|return
literal|0
return|;
block|{
name|tree
name|parms
decl_stmt|,
name|function_decl
decl_stmt|,
name|decelerator
decl_stmt|,
name|void_list_node
decl_stmt|;
name|tree
name|function_type
decl_stmt|;
specifier|extern
name|tree
name|get_file_function_name
parameter_list|()
function_decl|;
name|tree
name|init_function_name
init|=
name|get_file_function_name
argument_list|(
literal|'I'
argument_list|)
decl_stmt|;
comment|/* Declare void __objc_execClass (void*); */
name|void_list_node
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|void_type_node
argument_list|)
expr_stmt|;
name|function_type
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|void_list_node
argument_list|)
argument_list|)
expr_stmt|;
name|function_decl
operator|=
name|build_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|get_identifier
argument_list|(
name|TAG_EXECCLASS
argument_list|)
argument_list|,
name|function_type
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|function_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|function_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|function_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|pushdecl
argument_list|(
name|function_decl
argument_list|)
expr_stmt|;
name|rest_of_decl_compilation
argument_list|(
name|function_decl
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|parms
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|UOBJC_MODULES_decl
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|decelerator
operator|=
name|build_function_call
argument_list|(
name|function_decl
argument_list|,
name|parms
argument_list|)
expr_stmt|;
comment|/* void _GLOBAL_$I$<gnyf> () {objc_execClass (&L_OBJC_MODULES);}  */
name|start_function
argument_list|(
name|void_list_node
argument_list|,
name|build_parse_node
argument_list|(
name|CALL_EXPR
argument_list|,
name|init_function_name
argument_list|,
comment|/* This has the format of the output 					 of get_parm_info.  */
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|void_list_node
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This should be turned back on later 	 for the systems where collect is not needed.  */
comment|/* Make these functions nonglobal        so each file can use the same name.  */
block|TREE_PUBLIC (current_function_decl) = 0;
endif|#
directive|endif
name|TREE_USED
argument_list|(
name|current_function_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|store_parm_decls
argument_list|()
expr_stmt|;
name|assemble_external
argument_list|(
name|function_decl
argument_list|)
expr_stmt|;
name|c_expand_expr_stmt
argument_list|(
name|decelerator
argument_list|)
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|current_function_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|function_decl
operator|=
name|current_function_decl
expr_stmt|;
name|finish_function
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Return the name of the constructor function.  */
return|return
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|function_decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* extern const char _OBJC_STRINGS[]; */
end_comment

begin_function
specifier|static
name|void
name|generate_forward_declaration_to_string_table
parameter_list|()
block|{
name|tree
name|sc_spec
decl_stmt|,
name|decl_specs
decl_stmt|,
name|expr_decl
decl_stmt|;
name|sc_spec
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_EXTERN
index|]
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|decl_specs
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CHAR
index|]
argument_list|,
name|sc_spec
argument_list|)
expr_stmt|;
name|expr_decl
operator|=
name|build_nt
argument_list|(
name|ARRAY_REF
argument_list|,
name|get_identifier
argument_list|(
literal|"_OBJC_STRINGS"
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|UOBJC_STRINGS_decl
operator|=
name|define_decl
argument_list|(
name|expr_decl
argument_list|,
name|decl_specs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the DECL of the string IDENT in the SECTION.  */
end_comment

begin_function
specifier|static
name|tree
name|get_objc_string_decl
parameter_list|(
name|ident
parameter_list|,
name|section
parameter_list|)
name|tree
name|ident
decl_stmt|;
name|enum
name|string_section
name|section
decl_stmt|;
block|{
name|tree
name|chain
decl_stmt|,
name|decl
decl_stmt|;
if|if
condition|(
name|section
operator|==
name|class_names
condition|)
name|chain
operator|=
name|class_names_chain
expr_stmt|;
elseif|else
if|if
condition|(
name|section
operator|==
name|meth_var_names
condition|)
name|chain
operator|=
name|meth_var_names_chain
expr_stmt|;
elseif|else
if|if
condition|(
name|section
operator|==
name|meth_var_types
condition|)
name|chain
operator|=
name|meth_var_types_chain
expr_stmt|;
for|for
control|(
init|;
name|chain
operator|!=
literal|0
condition|;
name|chain
operator|=
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
control|)
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
operator|==
name|ident
condition|)
return|return
operator|(
name|TREE_PURPOSE
argument_list|(
name|chain
argument_list|)
operator|)
return|;
name|abort
argument_list|()
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Output references to all statically allocated objects.  Return the DECL    for the array built.  */
end_comment

begin_function
specifier|static
name|tree
name|generate_static_references
parameter_list|()
block|{
name|tree
name|decls
init|=
name|NULL_TREE
decl_stmt|,
name|ident
decl_stmt|,
name|decl_spec
decl_stmt|,
name|expr_decl
decl_stmt|,
name|expr
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|class_name
decl_stmt|,
name|class
decl_stmt|,
name|decl
decl_stmt|,
name|instance
decl_stmt|,
name|idecl
decl_stmt|,
name|initlist
decl_stmt|;
name|tree
name|cl_chain
decl_stmt|,
name|in_chain
decl_stmt|,
name|type
decl_stmt|;
name|int
name|num_inst
decl_stmt|,
name|num_class
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
if|if
condition|(
name|flag_next_runtime
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|cl_chain
operator|=
name|objc_static_instances
operator|,
name|num_class
operator|=
literal|0
init|;
name|cl_chain
condition|;
name|cl_chain
operator|=
name|TREE_CHAIN
argument_list|(
name|cl_chain
argument_list|)
operator|,
name|num_class
operator|++
control|)
block|{
for|for
control|(
name|num_inst
operator|=
literal|0
operator|,
name|in_chain
operator|=
name|TREE_PURPOSE
argument_list|(
name|cl_chain
argument_list|)
init|;
name|in_chain
condition|;
name|num_inst
operator|++
operator|,
name|in_chain
operator|=
name|TREE_CHAIN
argument_list|(
name|in_chain
argument_list|)
control|)
empty_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"_OBJC_STATIC_INSTANCES_%d"
argument_list|,
name|num_class
argument_list|)
expr_stmt|;
name|ident
operator|=
name|get_identifier
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|expr_decl
operator|=
name|build_nt
argument_list|(
name|ARRAY_REF
argument_list|,
name|ident
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|decl_spec
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_pointer_type
argument_list|(
name|void_type_node
argument_list|)
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_STATIC
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|decl
operator|=
name|start_decl
argument_list|(
name|expr_decl
argument_list|,
name|decl_spec
argument_list|,
literal|1
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Output {class_name, ...}.  */
name|class
operator|=
name|TREE_VALUE
argument_list|(
name|cl_chain
argument_list|)
expr_stmt|;
name|class_name
operator|=
name|get_objc_string_decl
argument_list|(
name|TYPE_NAME
argument_list|(
name|class
argument_list|)
argument_list|,
name|class_names
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|class_name
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Output {..., instance, ...}.  */
for|for
control|(
name|in_chain
operator|=
name|TREE_PURPOSE
argument_list|(
name|cl_chain
argument_list|)
init|;
name|in_chain
condition|;
name|in_chain
operator|=
name|TREE_CHAIN
argument_list|(
name|in_chain
argument_list|)
control|)
block|{
name|expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|TREE_VALUE
argument_list|(
name|in_chain
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
block|}
comment|/* Output {..., NULL}.  */
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
name|expr
operator|=
name|build_constructor
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|nreverse
argument_list|(
name|initlist
argument_list|)
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|decl
argument_list|,
name|expr
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|type
operator|=
name|build_array_type
argument_list|(
name|build_pointer_type
argument_list|(
name|void_type_node
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|ident
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|make_decl_rtl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|decls
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|decl
argument_list|,
literal|1
argument_list|)
argument_list|,
name|decls
argument_list|)
expr_stmt|;
block|}
name|decls
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|decls
argument_list|)
expr_stmt|;
name|ident
operator|=
name|get_identifier
argument_list|(
literal|"_OBJC_STATIC_INSTANCES"
argument_list|)
expr_stmt|;
name|expr_decl
operator|=
name|build_nt
argument_list|(
name|ARRAY_REF
argument_list|,
name|ident
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|decl_spec
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_pointer_type
argument_list|(
name|void_type_node
argument_list|)
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_STATIC
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|static_instances_decl
operator|=
name|start_decl
argument_list|(
name|expr_decl
argument_list|,
name|decl_spec
argument_list|,
literal|1
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|static_instances_decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|static_instances_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|end_temporary_allocation
argument_list|()
expr_stmt|;
name|expr
operator|=
name|build_constructor
argument_list|(
name|TREE_TYPE
argument_list|(
name|static_instances_decl
argument_list|)
argument_list|,
name|nreverse
argument_list|(
name|decls
argument_list|)
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|static_instances_decl
argument_list|,
name|expr
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output all strings. */
end_comment

begin_function
specifier|static
name|void
name|generate_strings
parameter_list|()
block|{
name|tree
name|sc_spec
decl_stmt|,
name|decl_specs
decl_stmt|,
name|expr_decl
decl_stmt|;
name|tree
name|chain
decl_stmt|,
name|string_expr
decl_stmt|;
name|tree
name|string
decl_stmt|,
name|decl
decl_stmt|;
for|for
control|(
name|chain
operator|=
name|class_names_chain
init|;
name|chain
condition|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
control|)
block|{
name|string
operator|=
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|decl
operator|=
name|TREE_PURPOSE
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|sc_spec
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_STATIC
index|]
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|decl_specs
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CHAR
index|]
argument_list|,
name|sc_spec
argument_list|)
expr_stmt|;
name|expr_decl
operator|=
name|build_nt
argument_list|(
name|ARRAY_REF
argument_list|,
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|decl
operator|=
name|start_decl
argument_list|(
name|expr_decl
argument_list|,
name|decl_specs
argument_list|,
literal|1
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|end_temporary_allocation
argument_list|()
expr_stmt|;
name|string_expr
operator|=
name|my_build_string
argument_list|(
name|IDENTIFIER_LENGTH
argument_list|(
name|string
argument_list|)
operator|+
literal|1
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|decl
argument_list|,
name|string_expr
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|chain
operator|=
name|meth_var_names_chain
init|;
name|chain
condition|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
control|)
block|{
name|string
operator|=
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|decl
operator|=
name|TREE_PURPOSE
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|sc_spec
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_STATIC
index|]
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|decl_specs
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CHAR
index|]
argument_list|,
name|sc_spec
argument_list|)
expr_stmt|;
name|expr_decl
operator|=
name|build_nt
argument_list|(
name|ARRAY_REF
argument_list|,
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|decl
operator|=
name|start_decl
argument_list|(
name|expr_decl
argument_list|,
name|decl_specs
argument_list|,
literal|1
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|string_expr
operator|=
name|my_build_string
argument_list|(
name|IDENTIFIER_LENGTH
argument_list|(
name|string
argument_list|)
operator|+
literal|1
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|decl
argument_list|,
name|string_expr
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|chain
operator|=
name|meth_var_types_chain
init|;
name|chain
condition|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
control|)
block|{
name|string
operator|=
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|decl
operator|=
name|TREE_PURPOSE
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|sc_spec
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_STATIC
index|]
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|decl_specs
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CHAR
index|]
argument_list|,
name|sc_spec
argument_list|)
expr_stmt|;
name|expr_decl
operator|=
name|build_nt
argument_list|(
name|ARRAY_REF
argument_list|,
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|decl
operator|=
name|start_decl
argument_list|(
name|expr_decl
argument_list|,
name|decl_specs
argument_list|,
literal|1
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|string_expr
operator|=
name|my_build_string
argument_list|(
name|IDENTIFIER_LENGTH
argument_list|(
name|string
argument_list|)
operator|+
literal|1
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|decl
argument_list|,
name|string_expr
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|tree
name|build_selector_reference_decl
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|,
name|ident
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
specifier|static
name|int
name|idx
init|=
literal|0
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"_OBJC_SELECTOR_REFERENCES_%d"
argument_list|,
name|idx
operator|++
argument_list|)
expr_stmt|;
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|end_temporary_allocation
argument_list|()
expr_stmt|;
name|ident
operator|=
name|get_identifier
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|ident
argument_list|,
name|selector_type
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|make_decl_rtl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pushdecl_top_level
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Just a handy wrapper for add_objc_string.  */
end_comment

begin_function
specifier|static
name|tree
name|build_selector
parameter_list|(
name|ident
parameter_list|)
name|tree
name|ident
decl_stmt|;
block|{
name|tree
name|expr
init|=
name|add_objc_string
argument_list|(
name|ident
argument_list|,
name|meth_var_names
argument_list|)
decl_stmt|;
if|if
condition|(
name|flag_typed_selectors
condition|)
return|return
name|expr
return|;
else|else
return|return
name|build_c_cast
argument_list|(
name|selector_type
argument_list|,
name|expr
argument_list|)
return|;
comment|/* cast! */
block|}
end_function

begin_comment
comment|/* Synthesize the following expr: (char *)&_OBJC_STRINGS[<offset>]    The cast stops the compiler from issuing the following message:    grok.m: warning: initialization of non-const * pointer from const *    grok.m: warning: initialization between incompatible pointer types.  */
end_comment

begin_function
specifier|static
name|tree
name|build_msg_pool_reference
parameter_list|(
name|offset
parameter_list|)
name|int
name|offset
decl_stmt|;
block|{
name|tree
name|expr
init|=
name|build_int_2
argument_list|(
name|offset
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|cast
decl_stmt|;
name|expr
operator|=
name|build_array_ref
argument_list|(
name|UOBJC_STRINGS_decl
argument_list|,
name|expr
argument_list|)
expr_stmt|;
name|expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cast
operator|=
name|build_tree_list
argument_list|(
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CHAR
index|]
argument_list|)
argument_list|,
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|=
name|groktypename
argument_list|(
name|cast
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|init_selector
parameter_list|(
name|offset
parameter_list|)
name|int
name|offset
decl_stmt|;
block|{
name|tree
name|expr
init|=
name|build_msg_pool_reference
argument_list|(
name|offset
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|=
name|selector_type
expr_stmt|;
return|return
name|expr
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|build_selector_translation_table
parameter_list|()
block|{
name|tree
name|sc_spec
decl_stmt|,
name|decl_specs
decl_stmt|;
name|tree
name|chain
decl_stmt|,
name|initlist
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|tree
name|decl
decl_stmt|,
name|var_decl
decl_stmt|,
name|name
decl_stmt|;
comment|/* The corresponding pop_obstacks is in finish_decl,      called at the end of this function.  */
if|if
condition|(
operator|!
name|flag_next_runtime
condition|)
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
for|for
control|(
name|chain
operator|=
name|sel_ref_chain
init|;
name|chain
condition|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
control|)
block|{
name|tree
name|expr
decl_stmt|;
name|expr
operator|=
name|build_selector
argument_list|(
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_next_runtime
condition|)
block|{
name|name
operator|=
name|DECL_NAME
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|chain
argument_list|)
argument_list|)
expr_stmt|;
name|sc_spec
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_STATIC
index|]
argument_list|)
expr_stmt|;
comment|/* static SEL _OBJC_SELECTOR_REFERENCES_n = ...; */
name|decl_specs
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|selector_type
argument_list|,
name|sc_spec
argument_list|)
expr_stmt|;
name|var_decl
operator|=
name|name
expr_stmt|;
comment|/* The `decl' that is returned from start_decl is the one that we 	     forward declared in `build_selector_reference'  */
name|decl
operator|=
name|start_decl
argument_list|(
name|var_decl
argument_list|,
name|decl_specs
argument_list|,
literal|1
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
comment|/* add one for the '\0' character */
name|offset
operator|+=
name|IDENTIFIER_LENGTH
argument_list|(
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|flag_next_runtime
condition|)
name|finish_decl
argument_list|(
name|decl
argument_list|,
name|expr
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|flag_typed_selectors
condition|)
block|{
name|tree
name|eltlist
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|encoding
init|=
name|get_proto_encoding
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|chain
argument_list|)
argument_list|)
decl_stmt|;
name|eltlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|eltlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|encoding
argument_list|,
name|eltlist
argument_list|)
expr_stmt|;
name|expr
operator|=
name|build_constructor
argument_list|(
name|objc_selector_template
argument_list|,
name|nreverse
argument_list|(
name|eltlist
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|flag_next_runtime
condition|)
block|{
comment|/* Cause the variable and its initial value to be actually output.  */
name|DECL_EXTERNAL
argument_list|(
name|UOBJC_SELECTOR_TABLE_decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|UOBJC_SELECTOR_TABLE_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* NULL terminate the list and fix the decl for output. */
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|UOBJC_SELECTOR_TABLE_decl
argument_list|)
operator|=
operator|(
name|tree
operator|)
literal|1
expr_stmt|;
name|initlist
operator|=
name|build_constructor
argument_list|(
name|TREE_TYPE
argument_list|(
name|UOBJC_SELECTOR_TABLE_decl
argument_list|)
argument_list|,
name|nreverse
argument_list|(
name|initlist
argument_list|)
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|UOBJC_SELECTOR_TABLE_decl
argument_list|,
name|initlist
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|current_function_decl
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|tree
name|get_proto_encoding
parameter_list|(
name|proto
parameter_list|)
name|tree
name|proto
decl_stmt|;
block|{
name|tree
name|encoding
decl_stmt|;
if|if
condition|(
name|proto
condition|)
block|{
name|tree
name|tmp_decl
decl_stmt|;
if|if
condition|(
operator|!
name|METHOD_ENCODING
argument_list|(
name|proto
argument_list|)
condition|)
block|{
name|tmp_decl
operator|=
name|build_tmp_function_decl
argument_list|()
expr_stmt|;
name|hack_method_prototype
argument_list|(
name|proto
argument_list|,
name|tmp_decl
argument_list|)
expr_stmt|;
name|encoding
operator|=
name|encode_method_prototype
argument_list|(
name|proto
argument_list|,
name|tmp_decl
argument_list|)
expr_stmt|;
name|METHOD_ENCODING
argument_list|(
name|proto
argument_list|)
operator|=
name|encoding
expr_stmt|;
block|}
else|else
name|encoding
operator|=
name|METHOD_ENCODING
argument_list|(
name|proto
argument_list|)
expr_stmt|;
return|return
name|add_objc_string
argument_list|(
name|encoding
argument_list|,
name|meth_var_types
argument_list|)
return|;
block|}
else|else
return|return
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* sel_ref_chain is a list whose "value" fields will be instances of    identifier_node that represent the selector.  */
end_comment

begin_function
specifier|static
name|tree
name|build_typed_selector_reference
parameter_list|(
name|ident
parameter_list|,
name|proto
parameter_list|)
name|tree
name|ident
decl_stmt|,
name|proto
decl_stmt|;
block|{
name|tree
modifier|*
name|chain
init|=
operator|&
name|sel_ref_chain
decl_stmt|;
name|tree
name|expr
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|chain
condition|)
block|{
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
operator|*
name|chain
argument_list|)
operator|==
name|ident
operator|&&
name|TREE_VALUE
argument_list|(
operator|*
name|chain
argument_list|)
operator|==
name|proto
condition|)
goto|goto
name|return_at_index
goto|;
name|index
operator|++
expr_stmt|;
name|chain
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|chain
argument_list|)
expr_stmt|;
block|}
operator|*
name|chain
operator|=
name|perm_tree_cons
argument_list|(
name|proto
argument_list|,
name|ident
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|return_at_index
label|:
name|expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_array_ref
argument_list|(
name|UOBJC_SELECTOR_TABLE_decl
argument_list|,
name|build_int_2
argument_list|(
name|index
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|build_c_cast
argument_list|(
name|selector_type
argument_list|,
name|expr
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|build_selector_reference
parameter_list|(
name|ident
parameter_list|)
name|tree
name|ident
decl_stmt|;
block|{
name|tree
modifier|*
name|chain
init|=
operator|&
name|sel_ref_chain
decl_stmt|;
name|tree
name|expr
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|chain
condition|)
block|{
if|if
condition|(
name|TREE_VALUE
argument_list|(
operator|*
name|chain
argument_list|)
operator|==
name|ident
condition|)
return|return
operator|(
name|flag_next_runtime
condition|?
name|TREE_PURPOSE
argument_list|(
operator|*
name|chain
argument_list|)
else|:
name|build_array_ref
argument_list|(
name|UOBJC_SELECTOR_TABLE_decl
argument_list|,
name|build_int_2
argument_list|(
name|index
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
return|;
name|index
operator|++
expr_stmt|;
name|chain
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|chain
argument_list|)
expr_stmt|;
block|}
name|expr
operator|=
name|build_selector_reference_decl
argument_list|(
name|ident
argument_list|)
expr_stmt|;
operator|*
name|chain
operator|=
name|perm_tree_cons
argument_list|(
name|expr
argument_list|,
name|ident
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
operator|(
name|flag_next_runtime
condition|?
name|expr
else|:
name|build_array_ref
argument_list|(
name|UOBJC_SELECTOR_TABLE_decl
argument_list|,
name|build_int_2
argument_list|(
name|index
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|build_class_reference_decl
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|,
name|ident
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
specifier|static
name|int
name|idx
init|=
literal|0
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"_OBJC_CLASS_REFERENCES_%d"
argument_list|,
name|idx
operator|++
argument_list|)
expr_stmt|;
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|end_temporary_allocation
argument_list|()
expr_stmt|;
name|ident
operator|=
name|get_identifier
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|ident
argument_list|,
name|objc_class_type
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|make_decl_rtl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pushdecl_top_level
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Create a class reference, but don't create a variable to reference    it.  */
end_comment

begin_function
specifier|static
name|void
name|add_class_reference
parameter_list|(
name|ident
parameter_list|)
name|tree
name|ident
decl_stmt|;
block|{
name|tree
name|chain
decl_stmt|;
if|if
condition|(
operator|(
name|chain
operator|=
name|cls_ref_chain
operator|)
condition|)
block|{
name|tree
name|tail
decl_stmt|;
do|do
block|{
if|if
condition|(
name|ident
operator|==
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
condition|)
return|return;
name|tail
operator|=
name|chain
expr_stmt|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|chain
condition|)
do|;
comment|/* Append to the end of the list */
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
operator|=
name|perm_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ident
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
else|else
name|cls_ref_chain
operator|=
name|perm_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ident
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get a class reference, creating it if necessary.  Also create the    reference variable.  */
end_comment

begin_function
name|tree
name|get_class_reference
parameter_list|(
name|ident
parameter_list|)
name|tree
name|ident
decl_stmt|;
block|{
if|if
condition|(
name|flag_next_runtime
condition|)
block|{
name|tree
modifier|*
name|chain
decl_stmt|;
name|tree
name|decl
decl_stmt|;
for|for
control|(
name|chain
operator|=
operator|&
name|cls_ref_chain
init|;
operator|*
name|chain
condition|;
name|chain
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|chain
argument_list|)
control|)
if|if
condition|(
name|TREE_VALUE
argument_list|(
operator|*
name|chain
argument_list|)
operator|==
name|ident
condition|)
block|{
if|if
condition|(
operator|!
name|TREE_PURPOSE
argument_list|(
operator|*
name|chain
argument_list|)
condition|)
name|TREE_PURPOSE
argument_list|(
operator|*
name|chain
argument_list|)
operator|=
name|build_class_reference_decl
argument_list|(
name|ident
argument_list|)
expr_stmt|;
return|return
name|TREE_PURPOSE
argument_list|(
operator|*
name|chain
argument_list|)
return|;
block|}
name|decl
operator|=
name|build_class_reference_decl
argument_list|(
name|ident
argument_list|)
expr_stmt|;
operator|*
name|chain
operator|=
name|perm_tree_cons
argument_list|(
name|decl
argument_list|,
name|ident
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
else|else
block|{
name|tree
name|params
decl_stmt|;
name|add_class_reference
argument_list|(
name|ident
argument_list|)
expr_stmt|;
name|params
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|my_build_string
argument_list|(
name|IDENTIFIER_LENGTH
argument_list|(
name|ident
argument_list|)
operator|+
literal|1
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|ident
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assemble_external
argument_list|(
name|objc_get_class_decl
argument_list|)
expr_stmt|;
return|return
name|build_function_call
argument_list|(
name|objc_get_class_decl
argument_list|,
name|params
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* SEL_REFDEF_CHAIN is a list whose "value" fields will be instances    of identifier_node that represent the selector. It returns the    offset of the selector from the beginning of the _OBJC_STRINGS    pool. This offset is typically used by init_selector during code    generation.     For each string section we have a chain which maps identifier nodes    to decls for the strings. */
end_comment

begin_function
specifier|static
name|tree
name|add_objc_string
parameter_list|(
name|ident
parameter_list|,
name|section
parameter_list|)
name|tree
name|ident
decl_stmt|;
name|enum
name|string_section
name|section
decl_stmt|;
block|{
name|tree
modifier|*
name|chain
decl_stmt|,
name|decl
decl_stmt|;
if|if
condition|(
name|section
operator|==
name|class_names
condition|)
name|chain
operator|=
operator|&
name|class_names_chain
expr_stmt|;
elseif|else
if|if
condition|(
name|section
operator|==
name|meth_var_names
condition|)
name|chain
operator|=
operator|&
name|meth_var_names_chain
expr_stmt|;
elseif|else
if|if
condition|(
name|section
operator|==
name|meth_var_types
condition|)
name|chain
operator|=
operator|&
name|meth_var_types_chain
expr_stmt|;
while|while
condition|(
operator|*
name|chain
condition|)
block|{
if|if
condition|(
name|TREE_VALUE
argument_list|(
operator|*
name|chain
argument_list|)
operator|==
name|ident
condition|)
return|return
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|TREE_PURPOSE
argument_list|(
operator|*
name|chain
argument_list|)
argument_list|,
literal|1
argument_list|)
return|;
name|chain
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|chain
argument_list|)
expr_stmt|;
block|}
name|decl
operator|=
name|build_objc_string_decl
argument_list|(
name|ident
argument_list|,
name|section
argument_list|)
expr_stmt|;
operator|*
name|chain
operator|=
name|perm_tree_cons
argument_list|(
name|decl
argument_list|,
name|ident
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|decl
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|build_objc_string_decl
parameter_list|(
name|name
parameter_list|,
name|section
parameter_list|)
name|tree
name|name
decl_stmt|;
name|enum
name|string_section
name|section
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|,
name|ident
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
specifier|static
name|int
name|class_names_idx
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|meth_var_names_idx
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|meth_var_types_idx
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|section
operator|==
name|class_names
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"_OBJC_CLASS_NAME_%d"
argument_list|,
name|class_names_idx
operator|++
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|section
operator|==
name|meth_var_names
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"_OBJC_METH_VAR_NAME_%d"
argument_list|,
name|meth_var_names_idx
operator|++
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|section
operator|==
name|meth_var_types
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"_OBJC_METH_VAR_TYPE_%d"
argument_list|,
name|meth_var_types_idx
operator|++
argument_list|)
expr_stmt|;
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|end_temporary_allocation
argument_list|()
expr_stmt|;
name|ident
operator|=
name|get_identifier
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|ident
argument_list|,
name|build_array_type
argument_list|(
name|char_type_node
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|make_decl_rtl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pushdecl_top_level
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_function
name|void
name|objc_declare_alias
parameter_list|(
name|alias_ident
parameter_list|,
name|class_ident
parameter_list|)
name|tree
name|alias_ident
decl_stmt|;
name|tree
name|class_ident
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|doing_objc_thang
condition|)
name|objc_fatal
argument_list|()
expr_stmt|;
if|if
condition|(
name|is_class_name
argument_list|(
name|class_ident
argument_list|)
operator|!=
name|class_ident
condition|)
name|warning
argument_list|(
literal|"Cannot find class `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|class_ident
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|is_class_name
argument_list|(
name|alias_ident
argument_list|)
condition|)
name|warning
argument_list|(
literal|"Class `%s' already exists"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|alias_ident
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|alias_chain
operator|=
name|tree_cons
argument_list|(
name|class_ident
argument_list|,
name|alias_ident
argument_list|,
name|alias_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|objc_declare_class
parameter_list|(
name|ident_list
parameter_list|)
name|tree
name|ident_list
decl_stmt|;
block|{
name|tree
name|list
decl_stmt|;
if|if
condition|(
operator|!
name|doing_objc_thang
condition|)
name|objc_fatal
argument_list|()
expr_stmt|;
for|for
control|(
name|list
operator|=
name|ident_list
init|;
name|list
condition|;
name|list
operator|=
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
control|)
block|{
name|tree
name|ident
init|=
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
decl_stmt|;
name|tree
name|decl
decl_stmt|;
if|if
condition|(
operator|(
name|decl
operator|=
name|lookup_name
argument_list|(
name|ident
argument_list|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"`%s' redeclared as different kind of symbol"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|ident
argument_list|)
argument_list|)
expr_stmt|;
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"previous declaration of `%s'"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|is_class_name
argument_list|(
name|ident
argument_list|)
condition|)
block|{
name|tree
name|record
init|=
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|ident
argument_list|)
decl_stmt|;
name|TREE_STATIC_TEMPLATE
argument_list|(
name|record
argument_list|)
operator|=
literal|1
expr_stmt|;
name|class_chain
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ident
argument_list|,
name|class_chain
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|tree
name|is_class_name
parameter_list|(
name|ident
parameter_list|)
name|tree
name|ident
decl_stmt|;
block|{
name|tree
name|chain
decl_stmt|;
if|if
condition|(
name|lookup_interface
argument_list|(
name|ident
argument_list|)
condition|)
return|return
name|ident
return|;
for|for
control|(
name|chain
operator|=
name|class_chain
init|;
name|chain
condition|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
control|)
block|{
if|if
condition|(
name|ident
operator|==
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
condition|)
return|return
name|ident
return|;
block|}
for|for
control|(
name|chain
operator|=
name|alias_chain
init|;
name|chain
condition|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
control|)
block|{
if|if
condition|(
name|ident
operator|==
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
condition|)
return|return
name|TREE_PURPOSE
argument_list|(
name|chain
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|tree
name|lookup_interface
parameter_list|(
name|ident
parameter_list|)
name|tree
name|ident
decl_stmt|;
block|{
name|tree
name|chain
decl_stmt|;
for|for
control|(
name|chain
operator|=
name|interface_chain
init|;
name|chain
condition|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
control|)
block|{
if|if
condition|(
name|ident
operator|==
name|CLASS_NAME
argument_list|(
name|chain
argument_list|)
condition|)
return|return
name|chain
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|objc_copy_list
parameter_list|(
name|list
parameter_list|,
name|head
parameter_list|)
name|tree
name|list
decl_stmt|;
name|tree
modifier|*
name|head
decl_stmt|;
block|{
name|tree
name|newlist
init|=
name|NULL_TREE
decl_stmt|,
name|tail
init|=
name|NULL_TREE
decl_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|tail
operator|=
name|copy_node
argument_list|(
name|list
argument_list|)
expr_stmt|;
comment|/* The following statement fixes a bug when inheriting instance 	 variables that are declared to be bitfields. finish_struct 	 expects to find the width of the bitfield in DECL_INITIAL, 	 which it nulls out after processing the decl of the super 	 class...rather than change the way finish_struct works (which 	 is risky), I create the situation it expects...s.naroff 	 (7/23/89).  */
if|if
condition|(
name|DECL_BIT_FIELD
argument_list|(
name|tail
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|tail
argument_list|)
operator|==
literal|0
condition|)
name|DECL_INITIAL
argument_list|(
name|tail
argument_list|)
operator|=
name|build_int_2
argument_list|(
name|DECL_FIELD_SIZE
argument_list|(
name|tail
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|newlist
operator|=
name|chainon
argument_list|(
name|newlist
argument_list|,
name|tail
argument_list|)
expr_stmt|;
name|list
operator|=
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
operator|*
name|head
operator|=
name|newlist
expr_stmt|;
return|return
name|tail
return|;
block|}
end_function

begin_comment
comment|/* Used by: build_private_template, get_class_ivars, and    continue_class.  COPY is 1 when called from @defs.  In this case    copy all fields.  Otherwise don't copy leaf ivars since we rely on    them being side-effected exactly once by finish_struct.  */
end_comment

begin_function
specifier|static
name|tree
name|build_ivar_chain
parameter_list|(
name|interface
parameter_list|,
name|copy
parameter_list|)
name|tree
name|interface
decl_stmt|;
name|int
name|copy
decl_stmt|;
block|{
name|tree
name|my_name
decl_stmt|,
name|super_name
decl_stmt|,
name|ivar_chain
decl_stmt|;
name|my_name
operator|=
name|CLASS_NAME
argument_list|(
name|interface
argument_list|)
expr_stmt|;
name|super_name
operator|=
name|CLASS_SUPER_NAME
argument_list|(
name|interface
argument_list|)
expr_stmt|;
comment|/* Possibly copy leaf ivars.  */
if|if
condition|(
name|copy
condition|)
name|objc_copy_list
argument_list|(
name|CLASS_IVARS
argument_list|(
name|interface
argument_list|)
argument_list|,
operator|&
name|ivar_chain
argument_list|)
expr_stmt|;
else|else
name|ivar_chain
operator|=
name|CLASS_IVARS
argument_list|(
name|interface
argument_list|)
expr_stmt|;
while|while
condition|(
name|super_name
condition|)
block|{
name|tree
name|op1
decl_stmt|;
name|tree
name|super_interface
init|=
name|lookup_interface
argument_list|(
name|super_name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|super_interface
condition|)
block|{
comment|/* fatal did not work with 2 args...should fix */
name|error
argument_list|(
literal|"Cannot find interface declaration for `%s', superclass of `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|super_name
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|my_name
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|super_interface
operator|==
name|interface
condition|)
block|{
name|fatal
argument_list|(
literal|"Circular inheritance in interface declaration for `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|super_name
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|interface
operator|=
name|super_interface
expr_stmt|;
name|my_name
operator|=
name|CLASS_NAME
argument_list|(
name|interface
argument_list|)
expr_stmt|;
name|super_name
operator|=
name|CLASS_SUPER_NAME
argument_list|(
name|interface
argument_list|)
expr_stmt|;
name|op1
operator|=
name|CLASS_IVARS
argument_list|(
name|interface
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
condition|)
block|{
name|tree
name|head
decl_stmt|,
name|tail
init|=
name|objc_copy_list
argument_list|(
name|op1
argument_list|,
operator|&
name|head
argument_list|)
decl_stmt|;
comment|/* Prepend super class ivars...make a copy of the list, we 	     do not want to alter the original.  */
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
operator|=
name|ivar_chain
expr_stmt|;
name|ivar_chain
operator|=
name|head
expr_stmt|;
block|}
block|}
return|return
name|ivar_chain
return|;
block|}
end_function

begin_comment
comment|/* struct<classname> {      struct objc_class *isa;      ...    };  */
end_comment

begin_function
specifier|static
name|tree
name|build_private_template
parameter_list|(
name|class
parameter_list|)
name|tree
name|class
decl_stmt|;
block|{
name|tree
name|ivar_context
decl_stmt|;
if|if
condition|(
name|CLASS_STATIC_TEMPLATE
argument_list|(
name|class
argument_list|)
condition|)
block|{
name|uprivate_record
operator|=
name|CLASS_STATIC_TEMPLATE
argument_list|(
name|class
argument_list|)
expr_stmt|;
name|ivar_context
operator|=
name|TYPE_FIELDS
argument_list|(
name|CLASS_STATIC_TEMPLATE
argument_list|(
name|class
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|uprivate_record
operator|=
name|start_struct
argument_list|(
name|RECORD_TYPE
argument_list|,
name|CLASS_NAME
argument_list|(
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|ivar_context
operator|=
name|build_ivar_chain
argument_list|(
name|class
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|finish_struct
argument_list|(
name|uprivate_record
argument_list|,
name|ivar_context
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|CLASS_STATIC_TEMPLATE
argument_list|(
name|class
argument_list|)
operator|=
name|uprivate_record
expr_stmt|;
comment|/* mark this record as class template - for class type checking */
name|TREE_STATIC_TEMPLATE
argument_list|(
name|uprivate_record
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|instance_type
operator|=
name|groktypename
argument_list|(
name|build_tree_list
argument_list|(
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|uprivate_record
argument_list|)
argument_list|,
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ivar_context
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Begin code generation for protocols... */
end_comment

begin_comment
comment|/* struct objc_protocol {      char *protocol_name;      struct objc_protocol **protocol_list;      struct objc_method_desc *instance_methods;      struct objc_method_desc *class_methods;    };  */
end_comment

begin_function
specifier|static
name|tree
name|build_protocol_template
parameter_list|()
block|{
name|tree
name|decl_specs
decl_stmt|,
name|field_decl
decl_stmt|,
name|field_decl_chain
decl_stmt|;
name|tree
name|template
decl_stmt|;
name|template
operator|=
name|start_struct
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_PROTOCOL
argument_list|)
argument_list|)
expr_stmt|;
comment|/* struct objc_class *isa; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_CLASS
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"isa"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|field_decl_chain
operator|=
name|field_decl
expr_stmt|;
comment|/* char *protocol_name; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CHAR
index|]
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"protocol_name"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* struct objc_protocol **protocol_list; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|template
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"protocol_list"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* struct objc_method_list *instance_methods; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_METHOD_PROTOTYPE_LIST
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"instance_methods"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* struct objc_method_list *class_methods; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_METHOD_PROTOTYPE_LIST
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"class_methods"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
return|return
name|finish_struct
argument_list|(
name|template
argument_list|,
name|field_decl_chain
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|build_descriptor_table_initializer
parameter_list|(
name|type
parameter_list|,
name|entries
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|entries
decl_stmt|;
block|{
name|tree
name|initlist
init|=
name|NULL_TREE
decl_stmt|;
do|do
block|{
name|tree
name|eltlist
init|=
name|NULL_TREE
decl_stmt|;
name|eltlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_selector
argument_list|(
name|METHOD_SEL_NAME
argument_list|(
name|entries
argument_list|)
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|eltlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|add_objc_string
argument_list|(
name|METHOD_ENCODING
argument_list|(
name|entries
argument_list|)
argument_list|,
name|meth_var_types
argument_list|)
argument_list|,
name|eltlist
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_constructor
argument_list|(
name|type
argument_list|,
name|nreverse
argument_list|(
name|eltlist
argument_list|)
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
name|entries
operator|=
name|TREE_CHAIN
argument_list|(
name|entries
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|entries
condition|)
do|;
return|return
name|build_constructor
argument_list|(
name|build_array_type
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
argument_list|,
name|nreverse
argument_list|(
name|initlist
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* struct objc_method_prototype_list {      int count;      struct objc_method_prototype {  	SEL name;  	char *types;      } list[1];    };  */
end_comment

begin_function
specifier|static
name|tree
name|build_method_prototype_list_template
parameter_list|(
name|list_type
parameter_list|,
name|size
parameter_list|)
name|tree
name|list_type
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|tree
name|objc_ivar_list_record
decl_stmt|;
name|tree
name|decl_specs
decl_stmt|,
name|field_decl
decl_stmt|,
name|field_decl_chain
decl_stmt|;
comment|/* Generate an unnamed struct definition. */
name|objc_ivar_list_record
operator|=
name|start_struct
argument_list|(
name|RECORD_TYPE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* int method_count; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_INT
index|]
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|get_identifier
argument_list|(
literal|"method_count"
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|field_decl_chain
operator|=
name|field_decl
expr_stmt|;
comment|/* struct objc_method method_list[]; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|list_type
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build_nt
argument_list|(
name|ARRAY_REF
argument_list|,
name|get_identifier
argument_list|(
literal|"method_list"
argument_list|)
argument_list|,
name|build_int_2
argument_list|(
name|size
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
name|finish_struct
argument_list|(
name|objc_ivar_list_record
argument_list|,
name|field_decl_chain
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|objc_ivar_list_record
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|build_method_prototype_template
parameter_list|()
block|{
name|tree
name|proto_record
decl_stmt|;
name|tree
name|decl_specs
decl_stmt|,
name|field_decl
decl_stmt|,
name|field_decl_chain
decl_stmt|;
name|proto_record
operator|=
name|start_struct
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_METHOD_PROTOTYPE
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJC_INT_SELECTORS
comment|/* unsigned int _cmd; */
name|decl_specs
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_UNSIGNED
index|]
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|decl_specs
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_INT
index|]
argument_list|,
name|decl_specs
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|get_identifier
argument_list|(
literal|"_cmd"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* OBJC_INT_SELECTORS */
comment|/* struct objc_selector *_cmd; */
name|decl_specs
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|TAG_SELECTOR
argument_list|)
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"_cmd"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OBJC_INT_SELECTORS */
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|field_decl_chain
operator|=
name|field_decl
expr_stmt|;
name|decl_specs
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CHAR
index|]
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"method_types"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
name|finish_struct
argument_list|(
name|proto_record
argument_list|,
name|field_decl_chain
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|proto_record
return|;
block|}
end_function

begin_comment
comment|/* True if last call to forwarding_offset yielded a register offset. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|offset_is_register
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|forwarding_offset
parameter_list|(
name|parm
parameter_list|)
name|tree
name|parm
decl_stmt|;
block|{
name|int
name|offset_in_bytes
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_INCOMING_RTL
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|rtx
name|addr
init|=
name|XEXP
argument_list|(
name|DECL_INCOMING_RTL
argument_list|(
name|parm
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* ??? Here we assume that the parm address is indexed 	  off the frame pointer or arg pointer. 	  If that is not true, we produce meaningless results, 	  but do not crash.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|offset_in_bytes
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|offset_in_bytes
operator|=
literal|0
expr_stmt|;
name|offset_in_bytes
operator|+=
name|OBJC_FORWARDING_STACK_OFFSET
expr_stmt|;
name|offset_is_register
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_INCOMING_RTL
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|DECL_INCOMING_RTL
argument_list|(
name|parm
argument_list|)
argument_list|)
decl_stmt|;
name|offset_in_bytes
operator|=
name|apply_args_register_offset
argument_list|(
name|regno
argument_list|)
expr_stmt|;
name|offset_is_register
operator|=
literal|1
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
comment|/* This is the case where the parm is passed as an int or double      and it is converted to a char, short or float and stored back      in the parmlist.  In this case, describe the parm      with the variable's declared type, and adjust the address      if the least significant bytes (which we are using) are not      the first ones.  */
if|if
condition|(
name|BYTES_BIG_ENDIAN
operator|&&
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
operator|!=
name|DECL_ARG_TYPE
argument_list|(
name|parm
argument_list|)
condition|)
name|offset_in_bytes
operator|+=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|DECL_ARG_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
argument_list|)
operator|-
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|DECL_RTL
argument_list|(
name|parm
argument_list|)
argument_list|)
argument_list|)
operator|)
expr_stmt|;
return|return
name|offset_in_bytes
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|encode_method_prototype
parameter_list|(
name|method_decl
parameter_list|,
name|func_decl
parameter_list|)
name|tree
name|method_decl
decl_stmt|;
name|tree
name|func_decl
decl_stmt|;
block|{
name|tree
name|parms
decl_stmt|;
name|int
name|stack_size
decl_stmt|,
name|i
decl_stmt|;
name|tree
name|user_args
decl_stmt|;
name|int
name|max_parm_end
init|=
literal|0
decl_stmt|;
name|char
name|buf
index|[
literal|40
index|]
decl_stmt|;
name|tree
name|result
decl_stmt|;
comment|/* ONEWAY and BYCOPY, for remote object are the only method qualifiers. */
name|encode_type_qualifiers
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|TREE_TYPE
argument_list|(
name|method_decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* C type. */
name|encode_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|func_decl
argument_list|)
argument_list|)
argument_list|,
name|obstack_object_size
argument_list|(
operator|&
name|util_obstack
argument_list|)
argument_list|,
name|OBJC_ENCODE_INLINE_DEFS
argument_list|)
expr_stmt|;
comment|/* Stack size. */
for|for
control|(
name|parms
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|func_decl
argument_list|)
init|;
name|parms
condition|;
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
control|)
block|{
name|int
name|parm_end
init|=
operator|(
name|forwarding_offset
argument_list|(
name|parms
argument_list|)
operator|+
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|offset_is_register
operator|&&
name|max_parm_end
operator|<
name|parm_end
condition|)
name|max_parm_end
operator|=
name|parm_end
expr_stmt|;
block|}
name|stack_size
operator|=
name|max_parm_end
operator|-
name|OBJC_FORWARDING_MIN_OFFSET
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|stack_size
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|user_args
operator|=
name|METHOD_SEL_ARGS
argument_list|(
name|method_decl
argument_list|)
expr_stmt|;
comment|/* Argument types. */
for|for
control|(
name|parms
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|func_decl
argument_list|)
operator|,
name|i
operator|=
literal|0
init|;
name|parms
condition|;
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
comment|/* Process argument qualifiers for user supplied arguments. */
if|if
condition|(
name|i
operator|>
literal|1
condition|)
block|{
name|encode_type_qualifiers
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|TREE_TYPE
argument_list|(
name|user_args
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|user_args
operator|=
name|TREE_CHAIN
argument_list|(
name|user_args
argument_list|)
expr_stmt|;
block|}
comment|/* Type. */
name|encode_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
argument_list|,
name|obstack_object_size
argument_list|(
operator|&
name|util_obstack
argument_list|)
argument_list|,
name|OBJC_ENCODE_INLINE_DEFS
argument_list|)
expr_stmt|;
comment|/* Compute offset. */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|forwarding_offset
argument_list|(
name|parms
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Indicate register. */
if|if
condition|(
name|offset_is_register
condition|)
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'+'
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
name|result
operator|=
name|get_identifier
argument_list|(
name|obstack_finish
argument_list|(
operator|&
name|util_obstack
argument_list|)
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|util_obstack
argument_list|,
name|util_firstobj
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|generate_descriptor_table
parameter_list|(
name|type
parameter_list|,
name|name
parameter_list|,
name|size
parameter_list|,
name|list
parameter_list|,
name|proto
parameter_list|)
name|tree
name|type
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|size
decl_stmt|;
name|tree
name|list
decl_stmt|;
name|tree
name|proto
decl_stmt|;
block|{
name|tree
name|sc_spec
decl_stmt|,
name|decl_specs
decl_stmt|,
name|decl
decl_stmt|,
name|initlist
decl_stmt|;
name|sc_spec
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_STATIC
index|]
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|decl_specs
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|type
argument_list|,
name|sc_spec
argument_list|)
expr_stmt|;
name|decl
operator|=
name|start_decl
argument_list|(
name|synth_id_with_class_suffix
argument_list|(
name|name
argument_list|,
name|proto
argument_list|)
argument_list|,
name|decl_specs
argument_list|,
literal|1
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
name|size
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|list
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|decl
argument_list|,
name|build_constructor
argument_list|(
name|type
argument_list|,
name|nreverse
argument_list|(
name|initlist
argument_list|)
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|generate_method_descriptors
parameter_list|(
name|protocol
parameter_list|)
comment|/* generate_dispatch_tables */
name|tree
name|protocol
decl_stmt|;
block|{
specifier|static
name|tree
name|objc_method_prototype_template
decl_stmt|;
name|tree
name|initlist
decl_stmt|,
name|chain
decl_stmt|,
name|method_list_template
decl_stmt|;
name|tree
name|cast
decl_stmt|,
name|variable_length_type
decl_stmt|;
name|int
name|size
decl_stmt|;
if|if
condition|(
operator|!
name|objc_method_prototype_template
condition|)
name|objc_method_prototype_template
operator|=
name|build_method_prototype_template
argument_list|()
expr_stmt|;
name|cast
operator|=
name|build_tree_list
argument_list|(
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_METHOD_PROTOTYPE_LIST
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|variable_length_type
operator|=
name|groktypename
argument_list|(
name|cast
argument_list|)
expr_stmt|;
name|chain
operator|=
name|PROTOCOL_CLS_METHODS
argument_list|(
name|protocol
argument_list|)
expr_stmt|;
if|if
condition|(
name|chain
condition|)
block|{
name|size
operator|=
name|list_length
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|method_list_template
operator|=
name|build_method_prototype_list_template
argument_list|(
name|objc_method_prototype_template
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|build_descriptor_table_initializer
argument_list|(
name|objc_method_prototype_template
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|UOBJC_CLASS_METHODS_decl
operator|=
name|generate_descriptor_table
argument_list|(
name|method_list_template
argument_list|,
literal|"_OBJC_PROTOCOL_CLASS_METHODS"
argument_list|,
name|size
argument_list|,
name|initlist
argument_list|,
name|protocol
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|UOBJC_CLASS_METHODS_decl
argument_list|)
operator|=
name|variable_length_type
expr_stmt|;
block|}
else|else
name|UOBJC_CLASS_METHODS_decl
operator|=
literal|0
expr_stmt|;
name|chain
operator|=
name|PROTOCOL_NST_METHODS
argument_list|(
name|protocol
argument_list|)
expr_stmt|;
if|if
condition|(
name|chain
condition|)
block|{
name|size
operator|=
name|list_length
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|method_list_template
operator|=
name|build_method_prototype_list_template
argument_list|(
name|objc_method_prototype_template
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|build_descriptor_table_initializer
argument_list|(
name|objc_method_prototype_template
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|UOBJC_INSTANCE_METHODS_decl
operator|=
name|generate_descriptor_table
argument_list|(
name|method_list_template
argument_list|,
literal|"_OBJC_PROTOCOL_INSTANCE_METHODS"
argument_list|,
name|size
argument_list|,
name|initlist
argument_list|,
name|protocol
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|UOBJC_INSTANCE_METHODS_decl
argument_list|)
operator|=
name|variable_length_type
expr_stmt|;
block|}
else|else
name|UOBJC_INSTANCE_METHODS_decl
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|tree
name|build_tmp_function_decl
parameter_list|()
block|{
name|tree
name|decl_specs
decl_stmt|,
name|expr_decl
decl_stmt|,
name|parms
decl_stmt|;
specifier|static
name|int
name|xxx
init|=
literal|0
decl_stmt|;
name|char
name|buffer
index|[
literal|80
index|]
decl_stmt|;
comment|/* struct objc_object *objc_xxx (id, SEL, ...); */
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|objc_object_reference
argument_list|)
expr_stmt|;
name|push_parm_decl
argument_list|(
name|build_tree_list
argument_list|(
name|build_tree_list
argument_list|(
name|decl_specs
argument_list|,
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|TAG_SELECTOR
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|push_parm_decl
argument_list|(
name|build_tree_list
argument_list|(
name|build_tree_list
argument_list|(
name|decl_specs
argument_list|,
name|expr_decl
argument_list|)
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|parms
operator|=
name|get_parm_info
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|poplevel
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|objc_object_reference
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"__objc_tmp_%x"
argument_list|,
name|xxx
operator|++
argument_list|)
expr_stmt|;
name|expr_decl
operator|=
name|build_nt
argument_list|(
name|CALL_EXPR
argument_list|,
name|get_identifier
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|parms
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|expr_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|expr_decl
argument_list|)
expr_stmt|;
return|return
name|define_decl
argument_list|(
name|expr_decl
argument_list|,
name|decl_specs
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hack_method_prototype
parameter_list|(
name|nst_methods
parameter_list|,
name|tmp_decl
parameter_list|)
name|tree
name|nst_methods
decl_stmt|;
name|tree
name|tmp_decl
decl_stmt|;
block|{
name|tree
name|parms
decl_stmt|;
name|tree
name|parm
decl_stmt|;
comment|/* Hack to avoid problem with static typing of self arg. */
name|TREE_SET_CODE
argument_list|(
name|nst_methods
argument_list|,
name|CLASS_METHOD_DECL
argument_list|)
expr_stmt|;
name|start_method_def
argument_list|(
name|nst_methods
argument_list|)
expr_stmt|;
name|TREE_SET_CODE
argument_list|(
name|nst_methods
argument_list|,
name|INSTANCE_METHOD_DECL
argument_list|)
expr_stmt|;
if|if
condition|(
name|METHOD_ADD_ARGS
argument_list|(
name|nst_methods
argument_list|)
operator|==
operator|(
name|tree
operator|)
literal|1
condition|)
name|parms
operator|=
name|get_parm_info
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* we have a `, ...' */
else|else
name|parms
operator|=
name|get_parm_info
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* place a `void_at_end' */
name|poplevel
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Must be called BEFORE start_function.  */
comment|/* Usually called from store_parm_decls -> init_function_start.  */
name|DECL_ARGUMENTS
argument_list|(
name|tmp_decl
argument_list|)
operator|=
name|TREE_PURPOSE
argument_list|(
name|parms
argument_list|)
expr_stmt|;
name|current_function_decl
operator|=
name|tmp_decl
expr_stmt|;
block|{
comment|/* Code taken from start_function.  */
name|tree
name|restype
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|tmp_decl
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Promote the value to int before returning it.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|restype
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_PRECISION
argument_list|(
name|restype
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
condition|)
name|restype
operator|=
name|integer_type_node
expr_stmt|;
name|DECL_RESULT
argument_list|(
name|tmp_decl
argument_list|)
operator|=
name|build_decl
argument_list|(
name|RESULT_DECL
argument_list|,
literal|0
argument_list|,
name|restype
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|parm
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|tmp_decl
argument_list|)
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
name|DECL_CONTEXT
argument_list|(
name|parm
argument_list|)
operator|=
name|tmp_decl
expr_stmt|;
name|init_function_start
argument_list|(
name|tmp_decl
argument_list|,
literal|"objc-act"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Typically called from expand_function_start for function definitions.  */
name|assign_parms
argument_list|(
name|tmp_decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* install return type */
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|tmp_decl
argument_list|)
argument_list|)
operator|=
name|groktypename
argument_list|(
name|TREE_TYPE
argument_list|(
name|nst_methods
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|generate_protocol_references
parameter_list|(
name|plist
parameter_list|)
name|tree
name|plist
decl_stmt|;
block|{
name|tree
name|lproto
decl_stmt|;
comment|/* Forward declare protocols referenced. */
for|for
control|(
name|lproto
operator|=
name|plist
init|;
name|lproto
condition|;
name|lproto
operator|=
name|TREE_CHAIN
argument_list|(
name|lproto
argument_list|)
control|)
block|{
name|tree
name|proto
init|=
name|TREE_VALUE
argument_list|(
name|lproto
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|proto
argument_list|)
operator|==
name|PROTOCOL_INTERFACE_TYPE
operator|&&
name|PROTOCOL_NAME
argument_list|(
name|proto
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|PROTOCOL_FORWARD_DECL
argument_list|(
name|proto
argument_list|)
condition|)
name|build_protocol_reference
argument_list|(
name|proto
argument_list|)
expr_stmt|;
if|if
condition|(
name|PROTOCOL_LIST
argument_list|(
name|proto
argument_list|)
condition|)
name|generate_protocol_references
argument_list|(
name|PROTOCOL_LIST
argument_list|(
name|proto
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|generate_protocols
parameter_list|()
block|{
name|tree
name|p
decl_stmt|,
name|tmp_decl
decl_stmt|,
name|encoding
decl_stmt|;
name|tree
name|sc_spec
decl_stmt|,
name|decl_specs
decl_stmt|,
name|decl
decl_stmt|;
name|tree
name|initlist
decl_stmt|,
name|protocol_name_expr
decl_stmt|,
name|refs_decl
decl_stmt|,
name|refs_expr
decl_stmt|;
name|tree
name|cast_type2
init|=
literal|0
decl_stmt|;
name|tmp_decl
operator|=
name|build_tmp_function_decl
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|objc_protocol_template
condition|)
name|objc_protocol_template
operator|=
name|build_protocol_template
argument_list|()
expr_stmt|;
comment|/* If a protocol was directly referenced, pull in indirect references.  */
for|for
control|(
name|p
operator|=
name|protocol_chain
init|;
name|p
condition|;
name|p
operator|=
name|TREE_CHAIN
argument_list|(
name|p
argument_list|)
control|)
if|if
condition|(
name|PROTOCOL_FORWARD_DECL
argument_list|(
name|p
argument_list|)
operator|&&
name|PROTOCOL_LIST
argument_list|(
name|p
argument_list|)
condition|)
name|generate_protocol_references
argument_list|(
name|PROTOCOL_LIST
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|protocol_chain
init|;
name|p
condition|;
name|p
operator|=
name|TREE_CHAIN
argument_list|(
name|p
argument_list|)
control|)
block|{
name|tree
name|nst_methods
init|=
name|PROTOCOL_NST_METHODS
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|tree
name|cls_methods
init|=
name|PROTOCOL_CLS_METHODS
argument_list|(
name|p
argument_list|)
decl_stmt|;
comment|/* If protocol wasn't referenced, don't generate any code.  */
if|if
condition|(
operator|!
name|PROTOCOL_FORWARD_DECL
argument_list|(
name|p
argument_list|)
condition|)
continue|continue;
comment|/* Make sure we link in the Protocol class. */
name|add_class_reference
argument_list|(
name|get_identifier
argument_list|(
name|PROTOCOL_OBJECT_CLASS_NAME
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|nst_methods
condition|)
block|{
if|if
condition|(
operator|!
name|METHOD_ENCODING
argument_list|(
name|nst_methods
argument_list|)
condition|)
block|{
name|hack_method_prototype
argument_list|(
name|nst_methods
argument_list|,
name|tmp_decl
argument_list|)
expr_stmt|;
name|encoding
operator|=
name|encode_method_prototype
argument_list|(
name|nst_methods
argument_list|,
name|tmp_decl
argument_list|)
expr_stmt|;
name|METHOD_ENCODING
argument_list|(
name|nst_methods
argument_list|)
operator|=
name|encoding
expr_stmt|;
block|}
name|nst_methods
operator|=
name|TREE_CHAIN
argument_list|(
name|nst_methods
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|cls_methods
condition|)
block|{
if|if
condition|(
operator|!
name|METHOD_ENCODING
argument_list|(
name|cls_methods
argument_list|)
condition|)
block|{
name|hack_method_prototype
argument_list|(
name|cls_methods
argument_list|,
name|tmp_decl
argument_list|)
expr_stmt|;
name|encoding
operator|=
name|encode_method_prototype
argument_list|(
name|cls_methods
argument_list|,
name|tmp_decl
argument_list|)
expr_stmt|;
name|METHOD_ENCODING
argument_list|(
name|cls_methods
argument_list|)
operator|=
name|encoding
expr_stmt|;
block|}
name|cls_methods
operator|=
name|TREE_CHAIN
argument_list|(
name|cls_methods
argument_list|)
expr_stmt|;
block|}
name|generate_method_descriptors
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|PROTOCOL_LIST
argument_list|(
name|p
argument_list|)
condition|)
name|refs_decl
operator|=
name|generate_protocol_list
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
name|refs_decl
operator|=
literal|0
expr_stmt|;
comment|/* static struct objc_protocol _OBJC_PROTOCOL_<mumble>; */
name|sc_spec
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_STATIC
index|]
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|decl_specs
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|objc_protocol_template
argument_list|,
name|sc_spec
argument_list|)
expr_stmt|;
name|decl
operator|=
name|start_decl
argument_list|(
name|synth_id_with_class_suffix
argument_list|(
literal|"_OBJC_PROTOCOL"
argument_list|,
name|p
argument_list|)
argument_list|,
name|decl_specs
argument_list|,
literal|1
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|protocol_name_expr
operator|=
name|add_objc_string
argument_list|(
name|PROTOCOL_NAME
argument_list|(
name|p
argument_list|)
argument_list|,
name|class_names
argument_list|)
expr_stmt|;
if|if
condition|(
name|refs_decl
condition|)
block|{
if|if
condition|(
operator|!
name|cast_type2
condition|)
name|cast_type2
operator|=
name|groktypename
argument_list|(
name|build_tree_list
argument_list|(
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|objc_protocol_template
argument_list|)
argument_list|,
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|refs_expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|refs_decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|refs_expr
argument_list|)
operator|=
name|cast_type2
expr_stmt|;
block|}
else|else
name|refs_expr
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* UOBJC_INSTANCE_METHODS_decl/UOBJC_CLASS_METHODS_decl are set 	 by generate_method_descriptors, which is called above.  */
name|initlist
operator|=
name|build_protocol_initializer
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|protocol_name_expr
argument_list|,
name|refs_expr
argument_list|,
name|UOBJC_INSTANCE_METHODS_decl
argument_list|,
name|UOBJC_CLASS_METHODS_decl
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|decl
argument_list|,
name|initlist
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* Mark the decl as used to avoid "defined but not used" warning. */
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|tree
name|build_protocol_initializer
parameter_list|(
name|type
parameter_list|,
name|protocol_name
parameter_list|,
name|protocol_list
parameter_list|,
name|instance_methods
parameter_list|,
name|class_methods
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|protocol_name
decl_stmt|;
name|tree
name|protocol_list
decl_stmt|;
name|tree
name|instance_methods
decl_stmt|;
name|tree
name|class_methods
decl_stmt|;
block|{
name|tree
name|initlist
init|=
name|NULL_TREE
decl_stmt|,
name|expr
decl_stmt|;
specifier|static
name|tree
name|cast_type
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|cast_type
condition|)
name|cast_type
operator|=
name|groktypename
argument_list|(
name|build_tree_list
argument_list|(
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_CLASS
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Filling the "isa" in with one allows the runtime system to      detect that the version change...should remove before final release.  */
name|expr
operator|=
name|build_int_2
argument_list|(
name|PROTOCOL_VERSION
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|=
name|cast_type
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|protocol_name
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|protocol_list
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|instance_methods
condition|)
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
else|else
block|{
name|expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|instance_methods
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|class_methods
condition|)
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
else|else
block|{
name|expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|class_methods
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
block|}
return|return
name|build_constructor
argument_list|(
name|type
argument_list|,
name|nreverse
argument_list|(
name|initlist
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* struct objc_category {      char *category_name;      char *class_name;      struct objc_method_list *instance_methods;      struct objc_method_list *class_methods;      struct objc_protocol_list *protocols;    };   */
end_comment

begin_function
specifier|static
name|void
name|build_category_template
parameter_list|()
block|{
name|tree
name|decl_specs
decl_stmt|,
name|field_decl
decl_stmt|,
name|field_decl_chain
decl_stmt|;
name|objc_category_template
operator|=
name|start_struct
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_CATEGORY
argument_list|)
argument_list|)
expr_stmt|;
comment|/* char *category_name; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CHAR
index|]
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"category_name"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|field_decl_chain
operator|=
name|field_decl
expr_stmt|;
comment|/* char *class_name; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CHAR
index|]
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"class_name"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* struct objc_method_list *instance_methods; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_METHOD_LIST
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"instance_methods"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* struct objc_method_list *class_methods; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_METHOD_LIST
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"class_methods"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* struct objc_protocol **protocol_list; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_PROTOCOL
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"protocol_list"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
name|finish_struct
argument_list|(
name|objc_category_template
argument_list|,
name|field_decl_chain
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* struct objc_selector {      void *sel_id;      char *sel_type;    }; */
end_comment

begin_function
specifier|static
name|void
name|build_selector_template
parameter_list|()
block|{
name|tree
name|decl_specs
decl_stmt|,
name|field_decl
decl_stmt|,
name|field_decl_chain
decl_stmt|;
name|objc_selector_template
operator|=
name|start_struct
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_SELECTOR
argument_list|)
argument_list|)
expr_stmt|;
comment|/* void *sel_id; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_VOID
index|]
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"sel_id"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|field_decl_chain
operator|=
name|field_decl
expr_stmt|;
comment|/* char *sel_type; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CHAR
index|]
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"sel_type"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
name|finish_struct
argument_list|(
name|objc_selector_template
argument_list|,
name|field_decl_chain
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* struct objc_class {      struct objc_class *isa;      struct objc_class *super_class;      char *name;      long version;      long info;      long instance_size;      struct objc_ivar_list *ivars;      struct objc_method_list *methods;      if (flag_next_runtime)        struct objc_cache *cache;      else {        struct sarray *dtable;        struct objc_class *subclass_list;        struct objc_class *sibling_class;      }      struct objc_protocol_list *protocols;    };  */
end_comment

begin_function
specifier|static
name|void
name|build_class_template
parameter_list|()
block|{
name|tree
name|decl_specs
decl_stmt|,
name|field_decl
decl_stmt|,
name|field_decl_chain
decl_stmt|;
name|objc_class_template
operator|=
name|start_struct
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_CLASS
argument_list|)
argument_list|)
expr_stmt|;
comment|/* struct objc_class *isa; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|objc_class_template
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"isa"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|field_decl_chain
operator|=
name|field_decl
expr_stmt|;
comment|/* struct objc_class *super_class; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|objc_class_template
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"super_class"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* char *name; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CHAR
index|]
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"name"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* long version; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_LONG
index|]
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|get_identifier
argument_list|(
literal|"version"
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* long info; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_LONG
index|]
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|get_identifier
argument_list|(
literal|"info"
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* long instance_size; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_LONG
index|]
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|get_identifier
argument_list|(
literal|"instance_size"
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* struct objc_ivar_list *ivars; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_IVAR_LIST
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"ivars"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* struct objc_method_list *methods; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_METHOD_LIST
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"methods"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_next_runtime
condition|)
block|{
comment|/* struct objc_cache *cache; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
literal|"objc_cache"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"cache"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* struct sarray *dtable; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
literal|"sarray"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"dtable"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* struct objc_class *subclass_list; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|objc_class_template
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"subclass_list"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* struct objc_class *sibling_class; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|objc_class_template
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"sibling_class"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
block|}
comment|/* struct objc_protocol **protocol_list; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_PROTOCOL
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"protocol_list"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
name|finish_struct
argument_list|(
name|objc_class_template
argument_list|,
name|field_decl_chain
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate appropriate forward declarations for an implementation.  */
end_comment

begin_function
specifier|static
name|void
name|synth_forward_declarations
parameter_list|()
block|{
name|tree
name|sc_spec
decl_stmt|,
name|decl_specs
decl_stmt|,
name|an_id
decl_stmt|;
comment|/* extern struct objc_class _OBJC_CLASS_<my_name>; */
name|an_id
operator|=
name|synth_id_with_class_suffix
argument_list|(
literal|"_OBJC_CLASS"
argument_list|,
name|implementation_context
argument_list|)
expr_stmt|;
name|sc_spec
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_EXTERN
index|]
argument_list|)
expr_stmt|;
name|decl_specs
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|objc_class_template
argument_list|,
name|sc_spec
argument_list|)
expr_stmt|;
name|UOBJC_CLASS_decl
operator|=
name|define_decl
argument_list|(
name|an_id
argument_list|,
name|decl_specs
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|UOBJC_CLASS_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|UOBJC_CLASS_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* extern struct objc_class _OBJC_METACLASS_<my_name>; */
name|an_id
operator|=
name|synth_id_with_class_suffix
argument_list|(
literal|"_OBJC_METACLASS"
argument_list|,
name|implementation_context
argument_list|)
expr_stmt|;
name|UOBJC_METACLASS_decl
operator|=
name|define_decl
argument_list|(
name|an_id
argument_list|,
name|decl_specs
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|UOBJC_METACLASS_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|UOBJC_METACLASS_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Pre-build the following entities - for speed/convenience. */
name|an_id
operator|=
name|get_identifier
argument_list|(
literal|"super_class"
argument_list|)
expr_stmt|;
name|ucls_super_ref
operator|=
name|build_component_ref
argument_list|(
name|UOBJC_CLASS_decl
argument_list|,
name|an_id
argument_list|)
expr_stmt|;
name|uucls_super_ref
operator|=
name|build_component_ref
argument_list|(
name|UOBJC_METACLASS_decl
argument_list|,
name|an_id
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|error_with_ivar
parameter_list|(
name|message
parameter_list|,
name|decl
parameter_list|,
name|rawdecl
parameter_list|)
name|char
modifier|*
name|message
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|tree
name|rawdecl
decl_stmt|;
block|{
name|count_error
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|report_error_function
argument_list|(
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: "
argument_list|,
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|errbuf
argument_list|,
name|BUFSIZE
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s `%s'\n"
argument_list|,
name|message
argument_list|,
name|gen_declaration
argument_list|(
name|rawdecl
argument_list|,
name|errbuf
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|USERTYPE
parameter_list|(
name|t
parameter_list|)
define|\
value|(TREE_CODE (t) == RECORD_TYPE || TREE_CODE (t) == UNION_TYPE \   ||  TREE_CODE (t) == ENUMERAL_TYPE)
end_define

begin_function
specifier|static
name|void
name|check_ivars
parameter_list|(
name|inter
parameter_list|,
name|imp
parameter_list|)
name|tree
name|inter
decl_stmt|;
name|tree
name|imp
decl_stmt|;
block|{
name|tree
name|intdecls
init|=
name|CLASS_IVARS
argument_list|(
name|inter
argument_list|)
decl_stmt|;
name|tree
name|impdecls
init|=
name|CLASS_IVARS
argument_list|(
name|imp
argument_list|)
decl_stmt|;
name|tree
name|rawintdecls
init|=
name|CLASS_RAW_IVARS
argument_list|(
name|inter
argument_list|)
decl_stmt|;
name|tree
name|rawimpdecls
init|=
name|CLASS_RAW_IVARS
argument_list|(
name|imp
argument_list|)
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|tree
name|t1
decl_stmt|,
name|t2
decl_stmt|;
if|if
condition|(
name|intdecls
operator|==
literal|0
operator|&&
name|impdecls
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|intdecls
operator|==
literal|0
operator|||
name|impdecls
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"inconsistent instance variable specification"
argument_list|)
expr_stmt|;
break|break;
block|}
name|t1
operator|=
name|TREE_TYPE
argument_list|(
name|intdecls
argument_list|)
expr_stmt|;
name|t2
operator|=
name|TREE_TYPE
argument_list|(
name|impdecls
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|comptypes
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|intdecls
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|impdecls
argument_list|)
condition|)
block|{
name|error_with_ivar
argument_list|(
literal|"conflicting instance variable type"
argument_list|,
name|impdecls
argument_list|,
name|rawimpdecls
argument_list|)
expr_stmt|;
name|error_with_ivar
argument_list|(
literal|"previous declaration of"
argument_list|,
name|intdecls
argument_list|,
name|rawintdecls
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* both the type and the name don't match */
block|{
name|error
argument_list|(
literal|"inconsistent instance variable specification"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|DECL_NAME
argument_list|(
name|intdecls
argument_list|)
operator|!=
name|DECL_NAME
argument_list|(
name|impdecls
argument_list|)
condition|)
block|{
name|error_with_ivar
argument_list|(
literal|"conflicting instance variable name"
argument_list|,
name|impdecls
argument_list|,
name|rawimpdecls
argument_list|)
expr_stmt|;
name|error_with_ivar
argument_list|(
literal|"previous declaration of"
argument_list|,
name|intdecls
argument_list|,
name|rawintdecls
argument_list|)
expr_stmt|;
block|}
name|intdecls
operator|=
name|TREE_CHAIN
argument_list|(
name|intdecls
argument_list|)
expr_stmt|;
name|impdecls
operator|=
name|TREE_CHAIN
argument_list|(
name|impdecls
argument_list|)
expr_stmt|;
name|rawintdecls
operator|=
name|TREE_CHAIN
argument_list|(
name|rawintdecls
argument_list|)
expr_stmt|;
name|rawimpdecls
operator|=
name|TREE_CHAIN
argument_list|(
name|rawimpdecls
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Set super_type to the data type node for struct objc_super *,    first defining struct objc_super itself.    This needs to be done just once per compilation.  */
end_comment

begin_function
specifier|static
name|tree
name|build_super_template
parameter_list|()
block|{
name|tree
name|record
decl_stmt|,
name|decl_specs
decl_stmt|,
name|field_decl
decl_stmt|,
name|field_decl_chain
decl_stmt|;
name|record
operator|=
name|start_struct
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_SUPER
argument_list|)
argument_list|)
expr_stmt|;
comment|/* struct objc_object *self; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|objc_object_reference
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|get_identifier
argument_list|(
literal|"self"
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|field_decl_chain
operator|=
name|field_decl
expr_stmt|;
comment|/* struct objc_class *class; */
name|decl_specs
operator|=
name|get_identifier
argument_list|(
name|UTAG_CLASS
argument_list|)
expr_stmt|;
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|decl_specs
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"class"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
name|finish_struct
argument_list|(
name|record
argument_list|,
name|field_decl_chain
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* `struct objc_super *' */
name|super_type
operator|=
name|groktypename
argument_list|(
name|build_tree_list
argument_list|(
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|record
argument_list|)
argument_list|,
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|record
return|;
block|}
end_function

begin_comment
comment|/* struct objc_ivar {      char *ivar_name;      char *ivar_type;      int ivar_offset;    };  */
end_comment

begin_function
specifier|static
name|tree
name|build_ivar_template
parameter_list|()
block|{
name|tree
name|objc_ivar_id
decl_stmt|,
name|objc_ivar_record
decl_stmt|;
name|tree
name|decl_specs
decl_stmt|,
name|field_decl
decl_stmt|,
name|field_decl_chain
decl_stmt|;
name|objc_ivar_id
operator|=
name|get_identifier
argument_list|(
name|UTAG_IVAR
argument_list|)
expr_stmt|;
name|objc_ivar_record
operator|=
name|start_struct
argument_list|(
name|RECORD_TYPE
argument_list|,
name|objc_ivar_id
argument_list|)
expr_stmt|;
comment|/* char *ivar_name; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CHAR
index|]
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"ivar_name"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|field_decl_chain
operator|=
name|field_decl
expr_stmt|;
comment|/* char *ivar_type; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CHAR
index|]
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"ivar_type"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* int ivar_offset; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_INT
index|]
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|get_identifier
argument_list|(
literal|"ivar_offset"
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
name|finish_struct
argument_list|(
name|objc_ivar_record
argument_list|,
name|field_decl_chain
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|objc_ivar_record
return|;
block|}
end_function

begin_comment
comment|/* struct {      int ivar_count;      struct objc_ivar ivar_list[ivar_count];    };  */
end_comment

begin_function
specifier|static
name|tree
name|build_ivar_list_template
parameter_list|(
name|list_type
parameter_list|,
name|size
parameter_list|)
name|tree
name|list_type
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|tree
name|objc_ivar_list_record
decl_stmt|;
name|tree
name|decl_specs
decl_stmt|,
name|field_decl
decl_stmt|,
name|field_decl_chain
decl_stmt|;
name|objc_ivar_list_record
operator|=
name|start_struct
argument_list|(
name|RECORD_TYPE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* int ivar_count; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_INT
index|]
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|get_identifier
argument_list|(
literal|"ivar_count"
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|field_decl_chain
operator|=
name|field_decl
expr_stmt|;
comment|/* struct objc_ivar ivar_list[]; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|list_type
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build_nt
argument_list|(
name|ARRAY_REF
argument_list|,
name|get_identifier
argument_list|(
literal|"ivar_list"
argument_list|)
argument_list|,
name|build_int_2
argument_list|(
name|size
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
name|finish_struct
argument_list|(
name|objc_ivar_list_record
argument_list|,
name|field_decl_chain
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|objc_ivar_list_record
return|;
block|}
end_function

begin_comment
comment|/* struct {      int method_next;      int method_count;      struct objc_method method_list[method_count];    };  */
end_comment

begin_function
specifier|static
name|tree
name|build_method_list_template
parameter_list|(
name|list_type
parameter_list|,
name|size
parameter_list|)
name|tree
name|list_type
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|tree
name|objc_ivar_list_record
decl_stmt|;
name|tree
name|decl_specs
decl_stmt|,
name|field_decl
decl_stmt|,
name|field_decl_chain
decl_stmt|;
name|objc_ivar_list_record
operator|=
name|start_struct
argument_list|(
name|RECORD_TYPE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* int method_next; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_METHOD_PROTOTYPE_LIST
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"method_next"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|field_decl_chain
operator|=
name|field_decl
expr_stmt|;
comment|/* int method_count; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_INT
index|]
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|get_identifier
argument_list|(
literal|"method_count"
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* struct objc_method method_list[]; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|list_type
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build_nt
argument_list|(
name|ARRAY_REF
argument_list|,
name|get_identifier
argument_list|(
literal|"method_list"
argument_list|)
argument_list|,
name|build_int_2
argument_list|(
name|size
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
name|finish_struct
argument_list|(
name|objc_ivar_list_record
argument_list|,
name|field_decl_chain
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|objc_ivar_list_record
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|build_ivar_list_initializer
parameter_list|(
name|type
parameter_list|,
name|field_decl
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|field_decl
decl_stmt|;
block|{
name|tree
name|initlist
init|=
name|NULL_TREE
decl_stmt|;
do|do
block|{
name|tree
name|ivar
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Set name. */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field_decl
argument_list|)
condition|)
name|ivar
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|add_objc_string
argument_list|(
name|DECL_NAME
argument_list|(
name|field_decl
argument_list|)
argument_list|,
name|meth_var_names
argument_list|)
argument_list|,
name|ivar
argument_list|)
expr_stmt|;
else|else
comment|/* Unnamed bit-field ivar (yuck). */
name|ivar
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|ivar
argument_list|)
expr_stmt|;
comment|/* Set type. */
name|encode_field_decl
argument_list|(
name|field_decl
argument_list|,
name|obstack_object_size
argument_list|(
operator|&
name|util_obstack
argument_list|)
argument_list|,
name|OBJC_ENCODE_DONT_INLINE_DEFS
argument_list|)
expr_stmt|;
comment|/* Null terminate string.  */
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ivar
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|add_objc_string
argument_list|(
name|get_identifier
argument_list|(
name|obstack_finish
argument_list|(
operator|&
name|util_obstack
argument_list|)
argument_list|)
argument_list|,
name|meth_var_types
argument_list|)
argument_list|,
name|ivar
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|util_obstack
argument_list|,
name|util_firstobj
argument_list|)
expr_stmt|;
comment|/* set offset */
name|ivar
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_FIELD_BITPOS
argument_list|(
name|field_decl
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
operator|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|ivar
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_constructor
argument_list|(
name|type
argument_list|,
name|nreverse
argument_list|(
name|ivar
argument_list|)
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|TREE_CHAIN
argument_list|(
name|field_decl
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|field_decl
condition|)
do|;
return|return
name|build_constructor
argument_list|(
name|build_array_type
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
argument_list|,
name|nreverse
argument_list|(
name|initlist
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|generate_ivars_list
parameter_list|(
name|type
parameter_list|,
name|name
parameter_list|,
name|size
parameter_list|,
name|list
parameter_list|)
name|tree
name|type
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|size
decl_stmt|;
name|tree
name|list
decl_stmt|;
block|{
name|tree
name|sc_spec
decl_stmt|,
name|decl_specs
decl_stmt|,
name|decl
decl_stmt|,
name|initlist
decl_stmt|;
name|sc_spec
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_STATIC
index|]
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|decl_specs
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|type
argument_list|,
name|sc_spec
argument_list|)
expr_stmt|;
name|decl
operator|=
name|start_decl
argument_list|(
name|synth_id_with_class_suffix
argument_list|(
name|name
argument_list|,
name|implementation_context
argument_list|)
argument_list|,
name|decl_specs
argument_list|,
literal|1
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
name|size
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|list
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|decl
argument_list|,
name|build_constructor
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|nreverse
argument_list|(
name|initlist
argument_list|)
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|generate_ivar_lists
parameter_list|()
block|{
name|tree
name|initlist
decl_stmt|,
name|ivar_list_template
decl_stmt|,
name|chain
decl_stmt|;
name|tree
name|cast
decl_stmt|,
name|variable_length_type
decl_stmt|;
name|int
name|size
decl_stmt|;
name|generating_instance_variables
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|objc_ivar_template
condition|)
name|objc_ivar_template
operator|=
name|build_ivar_template
argument_list|()
expr_stmt|;
name|cast
operator|=
name|build_tree_list
argument_list|(
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_IVAR_LIST
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|variable_length_type
operator|=
name|groktypename
argument_list|(
name|cast
argument_list|)
expr_stmt|;
comment|/* Only generate class variables for the root of the inheritance      hierarchy since these will be the same for every class. */
if|if
condition|(
name|CLASS_SUPER_NAME
argument_list|(
name|implementation_template
argument_list|)
operator|==
name|NULL_TREE
operator|&&
operator|(
name|chain
operator|=
name|TYPE_FIELDS
argument_list|(
name|objc_class_template
argument_list|)
operator|)
condition|)
block|{
name|size
operator|=
name|list_length
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|ivar_list_template
operator|=
name|build_ivar_list_template
argument_list|(
name|objc_ivar_template
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|build_ivar_list_initializer
argument_list|(
name|objc_ivar_template
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|UOBJC_CLASS_VARIABLES_decl
operator|=
name|generate_ivars_list
argument_list|(
name|ivar_list_template
argument_list|,
literal|"_OBJC_CLASS_VARIABLES"
argument_list|,
name|size
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|UOBJC_CLASS_VARIABLES_decl
argument_list|)
operator|=
name|variable_length_type
expr_stmt|;
block|}
else|else
name|UOBJC_CLASS_VARIABLES_decl
operator|=
literal|0
expr_stmt|;
name|chain
operator|=
name|CLASS_IVARS
argument_list|(
name|implementation_template
argument_list|)
expr_stmt|;
if|if
condition|(
name|chain
condition|)
block|{
name|size
operator|=
name|list_length
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|ivar_list_template
operator|=
name|build_ivar_list_template
argument_list|(
name|objc_ivar_template
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|build_ivar_list_initializer
argument_list|(
name|objc_ivar_template
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|UOBJC_INSTANCE_VARIABLES_decl
operator|=
name|generate_ivars_list
argument_list|(
name|ivar_list_template
argument_list|,
literal|"_OBJC_INSTANCE_VARIABLES"
argument_list|,
name|size
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|UOBJC_INSTANCE_VARIABLES_decl
argument_list|)
operator|=
name|variable_length_type
expr_stmt|;
block|}
else|else
name|UOBJC_INSTANCE_VARIABLES_decl
operator|=
literal|0
expr_stmt|;
name|generating_instance_variables
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|tree
name|build_dispatch_table_initializer
parameter_list|(
name|type
parameter_list|,
name|entries
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|entries
decl_stmt|;
block|{
name|tree
name|initlist
init|=
name|NULL_TREE
decl_stmt|;
do|do
block|{
name|tree
name|elemlist
init|=
name|NULL_TREE
decl_stmt|;
name|elemlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_selector
argument_list|(
name|METHOD_SEL_NAME
argument_list|(
name|entries
argument_list|)
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|elemlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|add_objc_string
argument_list|(
name|METHOD_ENCODING
argument_list|(
name|entries
argument_list|)
argument_list|,
name|meth_var_types
argument_list|)
argument_list|,
name|elemlist
argument_list|)
expr_stmt|;
name|elemlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|METHOD_DEFINITION
argument_list|(
name|entries
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|elemlist
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_constructor
argument_list|(
name|type
argument_list|,
name|nreverse
argument_list|(
name|elemlist
argument_list|)
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
name|entries
operator|=
name|TREE_CHAIN
argument_list|(
name|entries
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|entries
condition|)
do|;
return|return
name|build_constructor
argument_list|(
name|build_array_type
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
argument_list|,
name|nreverse
argument_list|(
name|initlist
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* To accomplish method prototyping without generating all kinds of    inane warnings, the definition of the dispatch table entries were    changed from:     	struct objc_method { SEL _cmd; ...; id (*_imp)(); };    to:    	struct objc_method { SEL _cmd; ...; void *_imp; };  */
end_comment

begin_function
specifier|static
name|tree
name|build_method_template
parameter_list|()
block|{
name|tree
name|_SLT_record
decl_stmt|;
name|tree
name|decl_specs
decl_stmt|,
name|field_decl
decl_stmt|,
name|field_decl_chain
decl_stmt|;
name|_SLT_record
operator|=
name|start_struct
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_METHOD
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJC_INT_SELECTORS
comment|/* unsigned int _cmd; */
name|decl_specs
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_UNSIGNED
index|]
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|decl_specs
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_INT
index|]
argument_list|,
name|decl_specs
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|get_identifier
argument_list|(
literal|"_cmd"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not OBJC_INT_SELECTORS */
comment|/* struct objc_selector *_cmd; */
name|decl_specs
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|TAG_SELECTOR
argument_list|)
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"_cmd"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not OBJC_INT_SELECTORS */
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|field_decl_chain
operator|=
name|field_decl
expr_stmt|;
name|decl_specs
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CHAR
index|]
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"method_types"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* void *_imp; */
name|decl_specs
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_VOID
index|]
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"_imp"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
name|finish_struct
argument_list|(
name|_SLT_record
argument_list|,
name|field_decl_chain
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|_SLT_record
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|generate_dispatch_table
parameter_list|(
name|type
parameter_list|,
name|name
parameter_list|,
name|size
parameter_list|,
name|list
parameter_list|)
name|tree
name|type
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|size
decl_stmt|;
name|tree
name|list
decl_stmt|;
block|{
name|tree
name|sc_spec
decl_stmt|,
name|decl_specs
decl_stmt|,
name|decl
decl_stmt|,
name|initlist
decl_stmt|;
name|sc_spec
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_STATIC
index|]
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|decl_specs
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|type
argument_list|,
name|sc_spec
argument_list|)
expr_stmt|;
name|decl
operator|=
name|start_decl
argument_list|(
name|synth_id_with_class_suffix
argument_list|(
name|name
argument_list|,
name|implementation_context
argument_list|)
argument_list|,
name|decl_specs
argument_list|,
literal|1
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
name|size
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|list
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|decl
argument_list|,
name|build_constructor
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|nreverse
argument_list|(
name|initlist
argument_list|)
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|generate_dispatch_tables
parameter_list|()
block|{
name|tree
name|initlist
decl_stmt|,
name|chain
decl_stmt|,
name|method_list_template
decl_stmt|;
name|tree
name|cast
decl_stmt|,
name|variable_length_type
decl_stmt|;
name|int
name|size
decl_stmt|;
if|if
condition|(
operator|!
name|objc_method_template
condition|)
name|objc_method_template
operator|=
name|build_method_template
argument_list|()
expr_stmt|;
name|cast
operator|=
name|build_tree_list
argument_list|(
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_METHOD_LIST
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|variable_length_type
operator|=
name|groktypename
argument_list|(
name|cast
argument_list|)
expr_stmt|;
name|chain
operator|=
name|CLASS_CLS_METHODS
argument_list|(
name|implementation_context
argument_list|)
expr_stmt|;
if|if
condition|(
name|chain
condition|)
block|{
name|size
operator|=
name|list_length
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|method_list_template
operator|=
name|build_method_list_template
argument_list|(
name|objc_method_template
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|build_dispatch_table_initializer
argument_list|(
name|objc_method_template
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|UOBJC_CLASS_METHODS_decl
operator|=
name|generate_dispatch_table
argument_list|(
name|method_list_template
argument_list|,
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|implementation_context
argument_list|)
operator|==
name|CLASS_IMPLEMENTATION_TYPE
operator|)
condition|?
literal|"_OBJC_CLASS_METHODS"
else|:
literal|"_OBJC_CATEGORY_CLASS_METHODS"
operator|)
argument_list|,
name|size
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|UOBJC_CLASS_METHODS_decl
argument_list|)
operator|=
name|variable_length_type
expr_stmt|;
block|}
else|else
name|UOBJC_CLASS_METHODS_decl
operator|=
literal|0
expr_stmt|;
name|chain
operator|=
name|CLASS_NST_METHODS
argument_list|(
name|implementation_context
argument_list|)
expr_stmt|;
if|if
condition|(
name|chain
condition|)
block|{
name|size
operator|=
name|list_length
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|method_list_template
operator|=
name|build_method_list_template
argument_list|(
name|objc_method_template
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|build_dispatch_table_initializer
argument_list|(
name|objc_method_template
argument_list|,
name|chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|implementation_context
argument_list|)
operator|==
name|CLASS_IMPLEMENTATION_TYPE
condition|)
name|UOBJC_INSTANCE_METHODS_decl
operator|=
name|generate_dispatch_table
argument_list|(
name|method_list_template
argument_list|,
literal|"_OBJC_INSTANCE_METHODS"
argument_list|,
name|size
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
else|else
comment|/* We have a category. */
name|UOBJC_INSTANCE_METHODS_decl
operator|=
name|generate_dispatch_table
argument_list|(
name|method_list_template
argument_list|,
literal|"_OBJC_CATEGORY_INSTANCE_METHODS"
argument_list|,
name|size
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|UOBJC_INSTANCE_METHODS_decl
argument_list|)
operator|=
name|variable_length_type
expr_stmt|;
block|}
else|else
name|UOBJC_INSTANCE_METHODS_decl
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|tree
name|generate_protocol_list
parameter_list|(
name|i_or_p
parameter_list|)
name|tree
name|i_or_p
decl_stmt|;
block|{
specifier|static
name|tree
name|cast_type
init|=
literal|0
decl_stmt|;
name|tree
name|initlist
decl_stmt|,
name|decl_specs
decl_stmt|,
name|sc_spec
decl_stmt|;
name|tree
name|refs_decl
decl_stmt|,
name|expr_decl
decl_stmt|,
name|lproto
decl_stmt|,
name|e
decl_stmt|,
name|plist
decl_stmt|;
name|int
name|size
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|i_or_p
argument_list|)
operator|==
name|CLASS_INTERFACE_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|i_or_p
argument_list|)
operator|==
name|CATEGORY_INTERFACE_TYPE
condition|)
name|plist
operator|=
name|CLASS_PROTOCOL_LIST
argument_list|(
name|i_or_p
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|i_or_p
argument_list|)
operator|==
name|PROTOCOL_INTERFACE_TYPE
condition|)
name|plist
operator|=
name|PROTOCOL_LIST
argument_list|(
name|i_or_p
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|cast_type
condition|)
name|cast_type
operator|=
name|groktypename
argument_list|(
name|build_tree_list
argument_list|(
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_PROTOCOL
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Compute size. */
for|for
control|(
name|lproto
operator|=
name|plist
init|;
name|lproto
condition|;
name|lproto
operator|=
name|TREE_CHAIN
argument_list|(
name|lproto
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|lproto
argument_list|)
argument_list|)
operator|==
name|PROTOCOL_INTERFACE_TYPE
operator|&&
name|PROTOCOL_FORWARD_DECL
argument_list|(
name|TREE_VALUE
argument_list|(
name|lproto
argument_list|)
argument_list|)
condition|)
name|size
operator|++
expr_stmt|;
comment|/* Build initializer. */
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|e
operator|=
name|build_int_2
argument_list|(
name|size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
operator|=
name|cast_type
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|e
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
for|for
control|(
name|lproto
operator|=
name|plist
init|;
name|lproto
condition|;
name|lproto
operator|=
name|TREE_CHAIN
argument_list|(
name|lproto
argument_list|)
control|)
block|{
name|tree
name|pval
init|=
name|TREE_VALUE
argument_list|(
name|lproto
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|pval
argument_list|)
operator|==
name|PROTOCOL_INTERFACE_TYPE
operator|&&
name|PROTOCOL_FORWARD_DECL
argument_list|(
name|pval
argument_list|)
condition|)
block|{
name|e
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|PROTOCOL_FORWARD_DECL
argument_list|(
name|pval
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|e
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* static struct objc_protocol *refs[n]; */
name|sc_spec
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_STATIC
index|]
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|decl_specs
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_PROTOCOL
argument_list|)
argument_list|)
argument_list|,
name|sc_spec
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|i_or_p
argument_list|)
operator|==
name|PROTOCOL_INTERFACE_TYPE
condition|)
name|expr_decl
operator|=
name|build_nt
argument_list|(
name|ARRAY_REF
argument_list|,
name|synth_id_with_class_suffix
argument_list|(
literal|"_OBJC_PROTOCOL_REFS"
argument_list|,
name|i_or_p
argument_list|)
argument_list|,
name|build_int_2
argument_list|(
name|size
operator|+
literal|2
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|i_or_p
argument_list|)
operator|==
name|CLASS_INTERFACE_TYPE
condition|)
name|expr_decl
operator|=
name|build_nt
argument_list|(
name|ARRAY_REF
argument_list|,
name|synth_id_with_class_suffix
argument_list|(
literal|"_OBJC_CLASS_PROTOCOLS"
argument_list|,
name|i_or_p
argument_list|)
argument_list|,
name|build_int_2
argument_list|(
name|size
operator|+
literal|2
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|i_or_p
argument_list|)
operator|==
name|CATEGORY_INTERFACE_TYPE
condition|)
name|expr_decl
operator|=
name|build_nt
argument_list|(
name|ARRAY_REF
argument_list|,
name|synth_id_with_class_suffix
argument_list|(
literal|"_OBJC_CATEGORY_PROTOCOLS"
argument_list|,
name|i_or_p
argument_list|)
argument_list|,
name|build_int_2
argument_list|(
name|size
operator|+
literal|2
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|expr_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|expr_decl
argument_list|)
expr_stmt|;
name|refs_decl
operator|=
name|start_decl
argument_list|(
name|expr_decl
argument_list|,
name|decl_specs
argument_list|,
literal|1
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|refs_decl
argument_list|,
name|build_constructor
argument_list|(
name|TREE_TYPE
argument_list|(
name|refs_decl
argument_list|)
argument_list|,
name|nreverse
argument_list|(
name|initlist
argument_list|)
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|refs_decl
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|build_category_initializer
parameter_list|(
name|type
parameter_list|,
name|cat_name
parameter_list|,
name|class_name
parameter_list|,
name|instance_methods
parameter_list|,
name|class_methods
parameter_list|,
name|protocol_list
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|cat_name
decl_stmt|;
name|tree
name|class_name
decl_stmt|;
name|tree
name|instance_methods
decl_stmt|;
name|tree
name|class_methods
decl_stmt|;
name|tree
name|protocol_list
decl_stmt|;
block|{
name|tree
name|initlist
init|=
name|NULL_TREE
decl_stmt|,
name|expr
decl_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|cat_name
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|class_name
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|instance_methods
condition|)
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
else|else
block|{
name|expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|instance_methods
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|class_methods
condition|)
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
else|else
block|{
name|expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|class_methods
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
block|}
comment|/* protocol_list = */
if|if
condition|(
operator|!
name|protocol_list
condition|)
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
else|else
block|{
specifier|static
name|tree
name|cast_type2
decl_stmt|;
if|if
condition|(
operator|!
name|cast_type2
condition|)
name|cast_type2
operator|=
name|groktypename
argument_list|(
name|build_tree_list
argument_list|(
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_PROTOCOL
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|protocol_list
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|=
name|cast_type2
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
block|}
return|return
name|build_constructor
argument_list|(
name|type
argument_list|,
name|nreverse
argument_list|(
name|initlist
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* struct objc_class {      struct objc_class *isa;      struct objc_class *super_class;      char *name;      long version;      long info;      long instance_size;      struct objc_ivar_list *ivars;      struct objc_method_list *methods;      if (flag_next_runtime)        struct objc_cache *cache;      else {        struct sarray *dtable;        struct objc_class *subclass_list;        struct objc_class *sibling_class;      }      struct objc_protocol_list *protocols;    };  */
end_comment

begin_function
specifier|static
name|tree
name|build_shared_structure_initializer
parameter_list|(
name|type
parameter_list|,
name|isa
parameter_list|,
name|super
parameter_list|,
name|name
parameter_list|,
name|size
parameter_list|,
name|status
parameter_list|,
name|dispatch_table
parameter_list|,
name|ivar_list
parameter_list|,
name|protocol_list
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|isa
decl_stmt|;
name|tree
name|super
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|size
decl_stmt|;
name|int
name|status
decl_stmt|;
name|tree
name|dispatch_table
decl_stmt|;
name|tree
name|ivar_list
decl_stmt|;
name|tree
name|protocol_list
decl_stmt|;
block|{
name|tree
name|initlist
init|=
name|NULL_TREE
decl_stmt|,
name|expr
decl_stmt|;
comment|/* isa = */
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|isa
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
comment|/* super_class = */
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|super
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
comment|/* name = */
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|default_conversion
argument_list|(
name|name
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
comment|/* version = */
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
comment|/* info = */
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
name|status
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
comment|/* instance_size = */
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|size
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
comment|/* objc_ivar_list = */
if|if
condition|(
operator|!
name|ivar_list
condition|)
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
else|else
block|{
name|expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|ivar_list
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
block|}
comment|/* objc_method_list = */
if|if
condition|(
operator|!
name|dispatch_table
condition|)
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
else|else
block|{
name|expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|dispatch_table
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_next_runtime
condition|)
comment|/* method_cache = */
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* dtable = */
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
comment|/* subclass_list = */
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
comment|/* sibling_class = */
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
block|}
comment|/* protocol_list = */
if|if
condition|(
operator|!
name|protocol_list
condition|)
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
else|else
block|{
specifier|static
name|tree
name|cast_type2
decl_stmt|;
if|if
condition|(
operator|!
name|cast_type2
condition|)
name|cast_type2
operator|=
name|groktypename
argument_list|(
name|build_tree_list
argument_list|(
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_PROTOCOL
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|protocol_list
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|=
name|cast_type2
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
block|}
return|return
name|build_constructor
argument_list|(
name|type
argument_list|,
name|nreverse
argument_list|(
name|initlist
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* static struct objc_category _OBJC_CATEGORY_<name> = { ... };  */
end_comment

begin_function
specifier|static
name|void
name|generate_category
parameter_list|(
name|cat
parameter_list|)
name|tree
name|cat
decl_stmt|;
block|{
name|tree
name|sc_spec
decl_stmt|,
name|decl_specs
decl_stmt|,
name|decl
decl_stmt|;
name|tree
name|initlist
decl_stmt|,
name|cat_name_expr
decl_stmt|,
name|class_name_expr
decl_stmt|;
name|tree
name|protocol_decl
decl_stmt|,
name|category
decl_stmt|;
name|add_class_reference
argument_list|(
name|CLASS_NAME
argument_list|(
name|cat
argument_list|)
argument_list|)
expr_stmt|;
name|cat_name_expr
operator|=
name|add_objc_string
argument_list|(
name|CLASS_SUPER_NAME
argument_list|(
name|cat
argument_list|)
argument_list|,
name|class_names
argument_list|)
expr_stmt|;
name|class_name_expr
operator|=
name|add_objc_string
argument_list|(
name|CLASS_NAME
argument_list|(
name|cat
argument_list|)
argument_list|,
name|class_names
argument_list|)
expr_stmt|;
name|category
operator|=
name|CLASS_CATEGORY_LIST
argument_list|(
name|implementation_template
argument_list|)
expr_stmt|;
comment|/* find the category interface from the class it is associated with */
while|while
condition|(
name|category
condition|)
block|{
if|if
condition|(
name|CLASS_SUPER_NAME
argument_list|(
name|cat
argument_list|)
operator|==
name|CLASS_SUPER_NAME
argument_list|(
name|category
argument_list|)
condition|)
break|break;
name|category
operator|=
name|CLASS_CATEGORY_LIST
argument_list|(
name|category
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|category
operator|&&
name|CLASS_PROTOCOL_LIST
argument_list|(
name|category
argument_list|)
condition|)
block|{
name|generate_protocol_references
argument_list|(
name|CLASS_PROTOCOL_LIST
argument_list|(
name|category
argument_list|)
argument_list|)
expr_stmt|;
name|protocol_decl
operator|=
name|generate_protocol_list
argument_list|(
name|category
argument_list|)
expr_stmt|;
block|}
else|else
name|protocol_decl
operator|=
literal|0
expr_stmt|;
name|sc_spec
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_STATIC
index|]
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|decl_specs
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|objc_category_template
argument_list|,
name|sc_spec
argument_list|)
expr_stmt|;
name|decl
operator|=
name|start_decl
argument_list|(
name|synth_id_with_class_suffix
argument_list|(
literal|"_OBJC_CATEGORY"
argument_list|,
name|implementation_context
argument_list|)
argument_list|,
name|decl_specs
argument_list|,
literal|1
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|build_category_initializer
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|cat_name_expr
argument_list|,
name|class_name_expr
argument_list|,
name|UOBJC_INSTANCE_METHODS_decl
argument_list|,
name|UOBJC_CLASS_METHODS_decl
argument_list|,
name|protocol_decl
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|finish_decl
argument_list|(
name|decl
argument_list|,
name|initlist
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* static struct objc_class _OBJC_METACLASS_Foo={ ... };    static struct objc_class _OBJC_CLASS_Foo={ ... };  */
end_comment

begin_function
specifier|static
name|void
name|generate_shared_structures
parameter_list|()
block|{
name|tree
name|sc_spec
decl_stmt|,
name|decl_specs
decl_stmt|,
name|decl
decl_stmt|;
name|tree
name|name_expr
decl_stmt|,
name|super_expr
decl_stmt|,
name|root_expr
decl_stmt|;
name|tree
name|my_root_id
init|=
name|NULL_TREE
decl_stmt|,
name|my_super_id
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|cast_type
decl_stmt|,
name|initlist
decl_stmt|,
name|protocol_decl
decl_stmt|;
name|my_super_id
operator|=
name|CLASS_SUPER_NAME
argument_list|(
name|implementation_template
argument_list|)
expr_stmt|;
if|if
condition|(
name|my_super_id
condition|)
block|{
name|add_class_reference
argument_list|(
name|my_super_id
argument_list|)
expr_stmt|;
comment|/* Compute "my_root_id" - this is required for code generation.          the "isa" for all meta class structures points to the root of          the inheritance hierarchy (e.g. "__Object")...  */
name|my_root_id
operator|=
name|my_super_id
expr_stmt|;
do|do
block|{
name|tree
name|my_root_int
init|=
name|lookup_interface
argument_list|(
name|my_root_id
argument_list|)
decl_stmt|;
if|if
condition|(
name|my_root_int
operator|&&
name|CLASS_SUPER_NAME
argument_list|(
name|my_root_int
argument_list|)
condition|)
name|my_root_id
operator|=
name|CLASS_SUPER_NAME
argument_list|(
name|my_root_int
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
do|while
condition|(
literal|1
condition|)
do|;
block|}
else|else
comment|/* No super class. */
name|my_root_id
operator|=
name|CLASS_NAME
argument_list|(
name|implementation_template
argument_list|)
expr_stmt|;
name|cast_type
operator|=
name|groktypename
argument_list|(
name|build_tree_list
argument_list|(
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|objc_class_template
argument_list|)
argument_list|,
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|name_expr
operator|=
name|add_objc_string
argument_list|(
name|CLASS_NAME
argument_list|(
name|implementation_template
argument_list|)
argument_list|,
name|class_names
argument_list|)
expr_stmt|;
comment|/* Install class `isa' and `super' pointers at runtime. */
if|if
condition|(
name|my_super_id
condition|)
block|{
name|super_expr
operator|=
name|add_objc_string
argument_list|(
name|my_super_id
argument_list|,
name|class_names
argument_list|)
expr_stmt|;
name|super_expr
operator|=
name|build_c_cast
argument_list|(
name|cast_type
argument_list|,
name|super_expr
argument_list|)
expr_stmt|;
comment|/* cast! */
block|}
else|else
name|super_expr
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|root_expr
operator|=
name|add_objc_string
argument_list|(
name|my_root_id
argument_list|,
name|class_names
argument_list|)
expr_stmt|;
name|root_expr
operator|=
name|build_c_cast
argument_list|(
name|cast_type
argument_list|,
name|root_expr
argument_list|)
expr_stmt|;
comment|/* cast! */
if|if
condition|(
name|CLASS_PROTOCOL_LIST
argument_list|(
name|implementation_template
argument_list|)
condition|)
block|{
name|generate_protocol_references
argument_list|(
name|CLASS_PROTOCOL_LIST
argument_list|(
name|implementation_template
argument_list|)
argument_list|)
expr_stmt|;
name|protocol_decl
operator|=
name|generate_protocol_list
argument_list|(
name|implementation_template
argument_list|)
expr_stmt|;
block|}
else|else
name|protocol_decl
operator|=
literal|0
expr_stmt|;
comment|/* static struct objc_class _OBJC_METACLASS_Foo = { ... }; */
name|sc_spec
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_STATIC
index|]
argument_list|)
expr_stmt|;
name|decl_specs
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|objc_class_template
argument_list|,
name|sc_spec
argument_list|)
expr_stmt|;
name|decl
operator|=
name|start_decl
argument_list|(
name|DECL_NAME
argument_list|(
name|UOBJC_METACLASS_decl
argument_list|)
argument_list|,
name|decl_specs
argument_list|,
literal|1
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|build_shared_structure_initializer
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|root_expr
argument_list|,
name|super_expr
argument_list|,
name|name_expr
argument_list|,
name|build_int_2
argument_list|(
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|objc_class_template
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
operator|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|2
comment|/*CLS_META*/
argument_list|,
name|UOBJC_CLASS_METHODS_decl
argument_list|,
name|UOBJC_CLASS_VARIABLES_decl
argument_list|,
name|protocol_decl
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|decl
argument_list|,
name|initlist
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* static struct objc_class _OBJC_CLASS_Foo={ ... }; */
name|decl
operator|=
name|start_decl
argument_list|(
name|DECL_NAME
argument_list|(
name|UOBJC_CLASS_decl
argument_list|)
argument_list|,
name|decl_specs
argument_list|,
literal|1
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|build_shared_structure_initializer
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|UOBJC_METACLASS_decl
argument_list|,
literal|0
argument_list|)
argument_list|,
name|super_expr
argument_list|,
name|name_expr
argument_list|,
name|build_int_2
argument_list|(
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|CLASS_STATIC_TEMPLATE
argument_list|(
name|implementation_template
argument_list|)
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
operator|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
comment|/*CLS_FACTORY*/
argument_list|,
name|UOBJC_INSTANCE_METHODS_decl
argument_list|,
name|UOBJC_INSTANCE_VARIABLES_decl
argument_list|,
name|protocol_decl
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|decl
argument_list|,
name|initlist
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|tree
name|synth_id_with_class_suffix
parameter_list|(
name|preamble
parameter_list|,
name|ctxt
parameter_list|)
name|char
modifier|*
name|preamble
decl_stmt|;
name|tree
name|ctxt
decl_stmt|;
block|{
name|char
modifier|*
name|string
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ctxt
argument_list|)
operator|==
name|CLASS_IMPLEMENTATION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|ctxt
argument_list|)
operator|==
name|CLASS_INTERFACE_TYPE
condition|)
block|{
name|char
modifier|*
name|class_name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_NAME
argument_list|(
name|implementation_context
argument_list|)
argument_list|)
decl_stmt|;
name|string
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|preamble
argument_list|)
operator|+
name|strlen
argument_list|(
name|class_name
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"%s_%s"
argument_list|,
name|preamble
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_NAME
argument_list|(
name|ctxt
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ctxt
argument_list|)
operator|==
name|CATEGORY_IMPLEMENTATION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|ctxt
argument_list|)
operator|==
name|CATEGORY_INTERFACE_TYPE
condition|)
block|{
comment|/* We have a category. */
name|char
modifier|*
name|class_name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_NAME
argument_list|(
name|implementation_context
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|class_super_name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_SUPER_NAME
argument_list|(
name|implementation_context
argument_list|)
argument_list|)
decl_stmt|;
name|string
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|preamble
argument_list|)
operator|+
name|strlen
argument_list|(
name|class_name
argument_list|)
operator|+
name|strlen
argument_list|(
name|class_super_name
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"%s_%s_%s"
argument_list|,
name|preamble
argument_list|,
name|class_name
argument_list|,
name|class_super_name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ctxt
argument_list|)
operator|==
name|PROTOCOL_INTERFACE_TYPE
condition|)
block|{
name|char
modifier|*
name|protocol_name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|PROTOCOL_NAME
argument_list|(
name|ctxt
argument_list|)
argument_list|)
decl_stmt|;
name|string
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|preamble
argument_list|)
operator|+
name|strlen
argument_list|(
name|protocol_name
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"%s_%s"
argument_list|,
name|preamble
argument_list|,
name|protocol_name
argument_list|)
expr_stmt|;
block|}
return|return
name|get_identifier
argument_list|(
name|string
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_objc_type_qualifier
parameter_list|(
name|node
parameter_list|)
name|tree
name|node
decl_stmt|;
block|{
return|return
operator|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|&&
operator|(
name|node
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CONST
index|]
operator|||
name|node
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_VOLATILE
index|]
operator|||
name|node
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_IN
index|]
operator|||
name|node
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_OUT
index|]
operator|||
name|node
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_INOUT
index|]
operator|||
name|node
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_BYCOPY
index|]
operator|||
name|node
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_ONEWAY
index|]
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* If type is empty or only type qualifiers are present, add default    type of id (otherwise grokdeclarator will default to int).  */
end_comment

begin_function
specifier|static
name|tree
name|adjust_type_for_id_default
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|declspecs
decl_stmt|,
name|chain
decl_stmt|;
if|if
condition|(
operator|!
name|type
condition|)
return|return
name|build_tree_list
argument_list|(
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|objc_object_reference
argument_list|)
argument_list|,
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
return|;
name|declspecs
operator|=
name|TREE_PURPOSE
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Determine if a typespec is present.  */
for|for
control|(
name|chain
operator|=
name|declspecs
init|;
name|chain
condition|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|is_objc_type_qualifier
argument_list|(
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
argument_list|)
condition|)
return|return
name|type
return|;
block|}
return|return
name|build_tree_list
argument_list|(
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|objc_object_reference
argument_list|,
name|declspecs
argument_list|)
argument_list|,
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*   Usage:   		keyworddecl:   			selector ':' '(' typename ')' identifier         Purpose:   		Transform an Objective-C keyword argument into   		the C equivalent parameter declarator.         In:	key_name, an "identifier_node" (optional).   		arg_type, a  "tree_list" (optional).   		arg_name, an "identifier_node".         Note:	It would be really nice to strongly type the preceding   		arguments in the function prototype; however, then I   		could not use the "accessor" macros defined in "tree.h".         Out:	an instance of "keyword_decl".  */
end_comment

begin_function
name|tree
name|build_keyword_decl
parameter_list|(
name|key_name
parameter_list|,
name|arg_type
parameter_list|,
name|arg_name
parameter_list|)
name|tree
name|key_name
decl_stmt|;
name|tree
name|arg_type
decl_stmt|;
name|tree
name|arg_name
decl_stmt|;
block|{
name|tree
name|keyword_decl
decl_stmt|;
comment|/* If no type is specified, default to "id". */
name|arg_type
operator|=
name|adjust_type_for_id_default
argument_list|(
name|arg_type
argument_list|)
expr_stmt|;
name|keyword_decl
operator|=
name|make_node
argument_list|(
name|KEYWORD_DECL
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|keyword_decl
argument_list|)
operator|=
name|arg_type
expr_stmt|;
name|KEYWORD_ARG_NAME
argument_list|(
name|keyword_decl
argument_list|)
operator|=
name|arg_name
expr_stmt|;
name|KEYWORD_KEY_NAME
argument_list|(
name|keyword_decl
argument_list|)
operator|=
name|key_name
expr_stmt|;
return|return
name|keyword_decl
return|;
block|}
end_function

begin_comment
comment|/* Given a chain of keyword_decl's, synthesize the full keyword selector.  */
end_comment

begin_function
specifier|static
name|tree
name|build_keyword_selector
parameter_list|(
name|selector
parameter_list|)
name|tree
name|selector
decl_stmt|;
block|{
name|int
name|len
init|=
literal|0
decl_stmt|;
name|tree
name|key_chain
decl_stmt|,
name|key_name
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
for|for
control|(
name|key_chain
operator|=
name|selector
init|;
name|key_chain
condition|;
name|key_chain
operator|=
name|TREE_CHAIN
argument_list|(
name|key_chain
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|selector
argument_list|)
operator|==
name|KEYWORD_DECL
condition|)
name|key_name
operator|=
name|KEYWORD_KEY_NAME
argument_list|(
name|key_chain
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|selector
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|key_name
operator|=
name|TREE_PURPOSE
argument_list|(
name|key_chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|key_name
condition|)
name|len
operator|+=
name|IDENTIFIER_LENGTH
argument_list|(
name|key_name
argument_list|)
operator|+
literal|1
expr_stmt|;
else|else
comment|/* Just a ':' arg. */
name|len
operator|++
expr_stmt|;
block|}
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|buf
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|key_chain
operator|=
name|selector
init|;
name|key_chain
condition|;
name|key_chain
operator|=
name|TREE_CHAIN
argument_list|(
name|key_chain
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|selector
argument_list|)
operator|==
name|KEYWORD_DECL
condition|)
name|key_name
operator|=
name|KEYWORD_KEY_NAME
argument_list|(
name|key_chain
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|selector
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|key_name
operator|=
name|TREE_PURPOSE
argument_list|(
name|key_chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|key_name
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|key_name
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
block|}
return|return
name|get_identifier
argument_list|(
name|buf
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Used for declarations and definitions. */
end_comment

begin_function
name|tree
name|build_method_decl
parameter_list|(
name|code
parameter_list|,
name|ret_type
parameter_list|,
name|selector
parameter_list|,
name|add_args
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|ret_type
decl_stmt|;
name|tree
name|selector
decl_stmt|;
name|tree
name|add_args
decl_stmt|;
block|{
name|tree
name|method_decl
decl_stmt|;
comment|/* If no type is specified, default to "id". */
name|ret_type
operator|=
name|adjust_type_for_id_default
argument_list|(
name|ret_type
argument_list|)
expr_stmt|;
name|method_decl
operator|=
name|make_node
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|method_decl
argument_list|)
operator|=
name|ret_type
expr_stmt|;
comment|/* If we have a keyword selector, create an identifier_node that      represents the full selector name (`:' included)...  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|selector
argument_list|)
operator|==
name|KEYWORD_DECL
condition|)
block|{
name|METHOD_SEL_NAME
argument_list|(
name|method_decl
argument_list|)
operator|=
name|build_keyword_selector
argument_list|(
name|selector
argument_list|)
expr_stmt|;
name|METHOD_SEL_ARGS
argument_list|(
name|method_decl
argument_list|)
operator|=
name|selector
expr_stmt|;
name|METHOD_ADD_ARGS
argument_list|(
name|method_decl
argument_list|)
operator|=
name|add_args
expr_stmt|;
block|}
else|else
block|{
name|METHOD_SEL_NAME
argument_list|(
name|method_decl
argument_list|)
operator|=
name|selector
expr_stmt|;
name|METHOD_SEL_ARGS
argument_list|(
name|method_decl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|METHOD_ADD_ARGS
argument_list|(
name|method_decl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
return|return
name|method_decl
return|;
block|}
end_function

begin_define
define|#
directive|define
name|METHOD_DEF
value|0
end_define

begin_define
define|#
directive|define
name|METHOD_REF
value|1
end_define

begin_comment
comment|/* Used by `build_message_expr' and `comp_method_types'.  Return an    argument list for method METH.  CONTEXT is either METHOD_DEF or    METHOD_REF, saying whether we are trying to define a method or call    one.  SUPERFLAG says this is for a send to super; this makes a    difference for the NeXT calling sequence in which the lookup and    the method call are done together.  */
end_comment

begin_function
specifier|static
name|tree
name|get_arg_type_list
parameter_list|(
name|meth
parameter_list|,
name|context
parameter_list|,
name|superflag
parameter_list|)
name|tree
name|meth
decl_stmt|;
name|int
name|context
decl_stmt|;
name|int
name|superflag
decl_stmt|;
block|{
name|tree
name|arglist
decl_stmt|,
name|akey
decl_stmt|;
comment|/* Receiver type. */
if|if
condition|(
name|flag_next_runtime
operator|&&
name|superflag
condition|)
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|super_type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|context
operator|==
name|METHOD_DEF
condition|)
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_TYPE
argument_list|(
name|self_decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|id_type
argument_list|)
expr_stmt|;
comment|/* Selector type - will eventually change to `int'. */
name|chainon
argument_list|(
name|arglist
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|selector_type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Build a list of argument types. */
for|for
control|(
name|akey
operator|=
name|METHOD_SEL_ARGS
argument_list|(
name|meth
argument_list|)
init|;
name|akey
condition|;
name|akey
operator|=
name|TREE_CHAIN
argument_list|(
name|akey
argument_list|)
control|)
block|{
name|tree
name|arg_decl
init|=
name|groktypename_in_parm_context
argument_list|(
name|TREE_TYPE
argument_list|(
name|akey
argument_list|)
argument_list|)
decl_stmt|;
name|chainon
argument_list|(
name|arglist
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg_decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|METHOD_ADD_ARGS
argument_list|(
name|meth
argument_list|)
operator|==
operator|(
name|tree
operator|)
literal|1
condition|)
comment|/* We have a `, ...' immediately following the selector,        finalize the arglist...simulate get_parm_info (0).  */
empty_stmt|;
elseif|else
if|if
condition|(
name|METHOD_ADD_ARGS
argument_list|(
name|meth
argument_list|)
condition|)
block|{
comment|/* we have a variable length selector */
name|tree
name|add_arg_list
init|=
name|TREE_CHAIN
argument_list|(
name|METHOD_ADD_ARGS
argument_list|(
name|meth
argument_list|)
argument_list|)
decl_stmt|;
name|chainon
argument_list|(
name|arglist
argument_list|,
name|add_arg_list
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* finalize the arglist...simulate get_parm_info (1) */
name|chainon
argument_list|(
name|arglist
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|void_type_node
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|arglist
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|check_duplicates
parameter_list|(
name|hsh
parameter_list|)
name|hash
name|hsh
decl_stmt|;
block|{
name|tree
name|meth
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|hsh
condition|)
block|{
name|meth
operator|=
name|hsh
operator|->
name|key
expr_stmt|;
if|if
condition|(
name|hsh
operator|->
name|list
condition|)
block|{
comment|/* We have two methods with the same name and different types. */
name|attr
name|loop
decl_stmt|;
name|char
name|type
init|=
operator|(
name|TREE_CODE
argument_list|(
name|meth
argument_list|)
operator|==
name|INSTANCE_METHOD_DECL
operator|)
condition|?
literal|'-'
else|:
literal|'+'
decl_stmt|;
name|warning
argument_list|(
literal|"multiple declarations for method `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|METHOD_SEL_NAME
argument_list|(
name|meth
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|warn_with_method
argument_list|(
literal|"using"
argument_list|,
name|type
argument_list|,
name|meth
argument_list|)
expr_stmt|;
for|for
control|(
name|loop
operator|=
name|hsh
operator|->
name|list
init|;
name|loop
condition|;
name|loop
operator|=
name|loop
operator|->
name|next
control|)
name|warn_with_method
argument_list|(
literal|"also found"
argument_list|,
name|type
argument_list|,
name|loop
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|meth
return|;
block|}
end_function

begin_comment
comment|/* If RECEIVER is a class reference, return the identifier node for the    referenced class.  RECEIVER is created by get_class_reference, so we    check the exact form created depending on which runtimes are used.  */
end_comment

begin_function
specifier|static
name|tree
name|receiver_is_class_object
parameter_list|(
name|receiver
parameter_list|)
name|tree
name|receiver
decl_stmt|;
block|{
name|tree
name|chain
decl_stmt|,
name|exp
decl_stmt|,
name|arg
decl_stmt|;
if|if
condition|(
name|flag_next_runtime
condition|)
block|{
comment|/* The receiver is a variable created by build_class_reference_decl.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|receiver
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_TYPE
argument_list|(
name|receiver
argument_list|)
operator|==
name|objc_class_type
condition|)
comment|/* Look up the identifier. */
for|for
control|(
name|chain
operator|=
name|cls_ref_chain
init|;
name|chain
condition|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|chain
argument_list|)
operator|==
name|receiver
condition|)
return|return
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
return|;
block|}
else|else
block|{
comment|/* The receiver is a function call that returns an id.  Check if 	 it is a call to objc_getClass, if so, pick up the class name.  */
if|if
condition|(
operator|(
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|receiver
argument_list|,
literal|0
argument_list|)
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
operator|(
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|exp
operator|==
name|objc_get_class_decl
comment|/* we have a call to objc_getClass! */
operator|&&
operator|(
name|arg
operator|=
name|TREE_OPERAND
argument_list|(
name|receiver
argument_list|,
literal|1
argument_list|)
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TREE_LIST
operator|&&
operator|(
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
operator|)
condition|)
block|{
name|STRIP_NOPS
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
operator|(
name|arg
operator|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|STRING_CST
condition|)
comment|/* Finally, we have the class name.  */
return|return
name|get_identifier
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|arg
argument_list|)
argument_list|)
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If we are currently building a message expr, this holds    the identifier of the selector of the message.  This is    used when printing warnings about argument mismatches. */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|building_objc_message_expr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|tree
name|maybe_building_objc_message_expr
parameter_list|()
block|{
return|return
name|building_objc_message_expr
return|;
block|}
end_function

begin_comment
comment|/* Construct an expression for sending a message.    MESS has the object to send to in TREE_PURPOSE    and the argument list (including selector) in TREE_VALUE.     (*(<abstract_decl>(*)())_msg)(receiver, selTransTbl[n], ...);    (*(<abstract_decl>(*)())_msgSuper)(receiver, selTransTbl[n], ...);  */
end_comment

begin_function
name|tree
name|build_message_expr
parameter_list|(
name|mess
parameter_list|)
name|tree
name|mess
decl_stmt|;
block|{
name|tree
name|receiver
init|=
name|TREE_PURPOSE
argument_list|(
name|mess
argument_list|)
decl_stmt|;
name|tree
name|selector
decl_stmt|,
name|self_object
decl_stmt|;
name|tree
name|rtype
decl_stmt|,
name|sel_name
decl_stmt|;
name|tree
name|args
init|=
name|TREE_VALUE
argument_list|(
name|mess
argument_list|)
decl_stmt|;
name|tree
name|method_params
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|method_prototype
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|retval
decl_stmt|;
name|int
name|statically_typed
init|=
literal|0
decl_stmt|,
name|statically_allocated
init|=
literal|0
decl_stmt|;
name|tree
name|class_ident
init|=
literal|0
decl_stmt|;
comment|/* 1 if this is sending to the superclass.  */
name|int
name|super
decl_stmt|;
if|if
condition|(
operator|!
name|doing_objc_thang
condition|)
name|objc_fatal
argument_list|()
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|receiver
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
comment|/* Determine receiver type. */
name|rtype
operator|=
name|TREE_TYPE
argument_list|(
name|receiver
argument_list|)
expr_stmt|;
name|super
operator|=
name|IS_SUPER
argument_list|(
name|rtype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|super
condition|)
block|{
if|if
condition|(
name|TREE_STATIC_TEMPLATE
argument_list|(
name|rtype
argument_list|)
condition|)
name|statically_allocated
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rtype
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_STATIC_TEMPLATE
argument_list|(
name|TREE_TYPE
argument_list|(
name|rtype
argument_list|)
argument_list|)
condition|)
name|statically_typed
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|flag_next_runtime
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|receiver
argument_list|)
operator|==
name|CALL_EXPR
operator|&&
name|IS_ID
argument_list|(
name|rtype
argument_list|)
operator|)
operator|)
operator|&&
operator|(
name|class_ident
operator|=
name|receiver_is_class_object
argument_list|(
name|receiver
argument_list|)
operator|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|IS_ID
argument_list|(
name|rtype
argument_list|)
comment|/* Allow any type that matches objc_class_type.  */
operator|&&
operator|!
name|comptypes
argument_list|(
name|rtype
argument_list|,
name|objc_class_type
argument_list|)
condition|)
block|{
name|bzero
argument_list|(
name|errbuf
argument_list|,
name|BUFSIZE
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"invalid receiver type `%s'"
argument_list|,
name|gen_declaration
argument_list|(
name|rtype
argument_list|,
name|errbuf
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|statically_allocated
condition|)
name|receiver
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|receiver
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Don't evaluate the receiver twice. */
name|receiver
operator|=
name|save_expr
argument_list|(
name|receiver
argument_list|)
expr_stmt|;
name|self_object
operator|=
name|receiver
expr_stmt|;
block|}
else|else
comment|/* If sending to `super', use current self as the object.  */
name|self_object
operator|=
name|self_decl
expr_stmt|;
comment|/* Obtain the full selector name.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|args
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
comment|/* A unary selector. */
name|sel_name
operator|=
name|args
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|args
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|sel_name
operator|=
name|build_keyword_selector
argument_list|(
name|args
argument_list|)
expr_stmt|;
comment|/* Build the parameter list to give to the method.  */
name|method_params
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|args
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|tree
name|chain
init|=
name|args
decl_stmt|,
name|prev
init|=
name|NULL_TREE
decl_stmt|;
comment|/* We have a keyword selector--check for comma expressions.  */
while|while
condition|(
name|chain
condition|)
block|{
name|tree
name|element
init|=
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
decl_stmt|;
comment|/* We have a comma expression, must collapse...  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|element
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
if|if
condition|(
name|prev
condition|)
name|TREE_CHAIN
argument_list|(
name|prev
argument_list|)
operator|=
name|element
expr_stmt|;
else|else
name|args
operator|=
name|element
expr_stmt|;
block|}
name|prev
operator|=
name|chain
expr_stmt|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
expr_stmt|;
block|}
name|method_params
operator|=
name|args
expr_stmt|;
block|}
comment|/* Determine operation return type.  */
if|if
condition|(
name|IS_SUPER
argument_list|(
name|rtype
argument_list|)
condition|)
block|{
name|tree
name|iface
decl_stmt|;
if|if
condition|(
name|CLASS_SUPER_NAME
argument_list|(
name|implementation_template
argument_list|)
condition|)
block|{
name|iface
operator|=
name|lookup_interface
argument_list|(
name|CLASS_SUPER_NAME
argument_list|(
name|implementation_template
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|method_context
argument_list|)
operator|==
name|INSTANCE_METHOD_DECL
condition|)
name|method_prototype
operator|=
name|lookup_instance_method_static
argument_list|(
name|iface
argument_list|,
name|sel_name
argument_list|)
expr_stmt|;
else|else
name|method_prototype
operator|=
name|lookup_class_method_static
argument_list|(
name|iface
argument_list|,
name|sel_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|iface
operator|&&
operator|!
name|method_prototype
condition|)
name|warning
argument_list|(
literal|"`%s' does not respond to `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_SUPER_NAME
argument_list|(
name|implementation_template
argument_list|)
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|sel_name
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"no super class declared in interface for `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_NAME
argument_list|(
name|implementation_template
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|statically_allocated
condition|)
block|{
name|tree
name|ctype
init|=
name|TREE_TYPE
argument_list|(
name|rtype
argument_list|)
decl_stmt|;
name|tree
name|iface
init|=
name|lookup_interface
argument_list|(
name|TYPE_NAME
argument_list|(
name|rtype
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|iface
condition|)
name|method_prototype
operator|=
name|lookup_instance_method_static
argument_list|(
name|iface
argument_list|,
name|sel_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|method_prototype
operator|&&
name|TYPE_PROTOCOL_LIST
argument_list|(
name|ctype
argument_list|)
condition|)
name|method_prototype
operator|=
name|lookup_method_in_protocol_list
argument_list|(
name|TYPE_PROTOCOL_LIST
argument_list|(
name|ctype
argument_list|)
argument_list|,
name|sel_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|method_prototype
condition|)
name|warning
argument_list|(
literal|"`%s' does not respond to `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TYPE_NAME
argument_list|(
name|rtype
argument_list|)
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|sel_name
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|statically_typed
condition|)
block|{
name|tree
name|ctype
init|=
name|TREE_TYPE
argument_list|(
name|rtype
argument_list|)
decl_stmt|;
comment|/* `self' is now statically_typed.  All methods should be visible          within the context of the implementation.  */
if|if
condition|(
name|implementation_context
operator|&&
name|CLASS_NAME
argument_list|(
name|implementation_context
argument_list|)
operator|==
name|TYPE_NAME
argument_list|(
name|ctype
argument_list|)
condition|)
block|{
name|method_prototype
operator|=
name|lookup_instance_method_static
argument_list|(
name|implementation_template
argument_list|,
name|sel_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|method_prototype
operator|&&
name|TYPE_PROTOCOL_LIST
argument_list|(
name|ctype
argument_list|)
condition|)
name|method_prototype
operator|=
name|lookup_method_in_protocol_list
argument_list|(
name|TYPE_PROTOCOL_LIST
argument_list|(
name|ctype
argument_list|)
argument_list|,
name|sel_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|method_prototype
operator|&&
name|implementation_template
operator|!=
name|implementation_context
condition|)
comment|/* The method is not published in the interface.  Check locally. */
name|method_prototype
operator|=
name|lookup_method
argument_list|(
name|CLASS_NST_METHODS
argument_list|(
name|implementation_context
argument_list|)
argument_list|,
name|sel_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|iface
decl_stmt|;
if|if
condition|(
operator|(
name|iface
operator|=
name|lookup_interface
argument_list|(
name|TYPE_NAME
argument_list|(
name|ctype
argument_list|)
argument_list|)
operator|)
condition|)
name|method_prototype
operator|=
name|lookup_instance_method_static
argument_list|(
name|iface
argument_list|,
name|sel_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|method_prototype
condition|)
block|{
name|tree
name|protocol_list
init|=
name|TYPE_PROTOCOL_LIST
argument_list|(
name|ctype
argument_list|)
decl_stmt|;
if|if
condition|(
name|protocol_list
condition|)
name|method_prototype
operator|=
name|lookup_method_in_protocol_list
argument_list|(
name|protocol_list
argument_list|,
name|sel_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|method_prototype
condition|)
name|warning
argument_list|(
literal|"`%s' does not respond to `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TYPE_NAME
argument_list|(
name|ctype
argument_list|)
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|sel_name
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|class_ident
condition|)
block|{
if|if
condition|(
name|implementation_context
operator|&&
name|CLASS_NAME
argument_list|(
name|implementation_context
argument_list|)
operator|==
name|class_ident
condition|)
block|{
name|method_prototype
operator|=
name|lookup_class_method_static
argument_list|(
name|implementation_template
argument_list|,
name|sel_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|method_prototype
operator|&&
name|implementation_template
operator|!=
name|implementation_context
condition|)
comment|/* The method is not published in the interface. Check locally. */
name|method_prototype
operator|=
name|lookup_method
argument_list|(
name|CLASS_CLS_METHODS
argument_list|(
name|implementation_context
argument_list|)
argument_list|,
name|sel_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|iface
decl_stmt|;
if|if
condition|(
operator|(
name|iface
operator|=
name|lookup_interface
argument_list|(
name|class_ident
argument_list|)
operator|)
condition|)
name|method_prototype
operator|=
name|lookup_class_method_static
argument_list|(
name|iface
argument_list|,
name|sel_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|method_prototype
condition|)
block|{
name|warning
argument_list|(
literal|"cannot find class (factory) method."
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"return type for `%s' defaults to id"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|sel_name
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|IS_PROTOCOL_QUALIFIED_ID
argument_list|(
name|rtype
argument_list|)
condition|)
block|{
comment|/* An anonymous object that has been qualified with a protocol.  */
name|tree
name|protocol_list
init|=
name|TYPE_PROTOCOL_LIST
argument_list|(
name|rtype
argument_list|)
decl_stmt|;
name|method_prototype
operator|=
name|lookup_method_in_protocol_list
argument_list|(
name|protocol_list
argument_list|,
name|sel_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|method_prototype
condition|)
block|{
name|hash
name|hsh
decl_stmt|;
name|warning
argument_list|(
literal|"method `%s' not implemented by protocol."
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|sel_name
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Try and find the method signature in the global pools. */
if|if
condition|(
operator|!
operator|(
name|hsh
operator|=
name|hash_lookup
argument_list|(
name|nst_method_hash_list
argument_list|,
name|sel_name
argument_list|)
operator|)
condition|)
name|hsh
operator|=
name|hash_lookup
argument_list|(
name|cls_method_hash_list
argument_list|,
name|sel_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|method_prototype
operator|=
name|check_duplicates
argument_list|(
name|hsh
argument_list|)
operator|)
condition|)
name|warning
argument_list|(
literal|"return type defaults to id"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|hash
name|hsh
decl_stmt|;
comment|/* We think we have an instance...loophole: extern id Object; */
name|hsh
operator|=
name|hash_lookup
argument_list|(
name|nst_method_hash_list
argument_list|,
name|sel_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hsh
condition|)
comment|/* For various loopholes, like sending messages to self in a 	   factory context. */
name|hsh
operator|=
name|hash_lookup
argument_list|(
name|cls_method_hash_list
argument_list|,
name|sel_name
argument_list|)
expr_stmt|;
name|method_prototype
operator|=
name|check_duplicates
argument_list|(
name|hsh
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|method_prototype
condition|)
block|{
name|warning
argument_list|(
literal|"cannot find method."
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"return type for `%s' defaults to id"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|sel_name
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Save the selector name for printing error messages.  */
name|building_objc_message_expr
operator|=
name|sel_name
expr_stmt|;
comment|/* Build the parameters list for looking up the method.      These are the object itself and the selector.  */
if|if
condition|(
name|flag_typed_selectors
condition|)
name|selector
operator|=
name|build_typed_selector_reference
argument_list|(
name|sel_name
argument_list|,
name|method_prototype
argument_list|)
expr_stmt|;
else|else
name|selector
operator|=
name|build_selector_reference
argument_list|(
name|sel_name
argument_list|)
expr_stmt|;
name|retval
operator|=
name|build_objc_method_call
argument_list|(
name|super
argument_list|,
name|method_prototype
argument_list|,
name|receiver
argument_list|,
name|self_object
argument_list|,
name|selector
argument_list|,
name|method_params
argument_list|)
expr_stmt|;
name|building_objc_message_expr
operator|=
literal|0
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Build a tree expression to send OBJECT the operation SELECTOR,    looking up the method on object LOOKUP_OBJECT (often same as OBJECT),    assuming the method has prototype METHOD_PROTOTYPE.    (That is an INSTANCE_METHOD_DECL or CLASS_METHOD_DECL.)    Use METHOD_PARAMS as list of args to pass to the method.    If SUPER_FLAG is nonzero, we look up the superclass's method.  */
end_comment

begin_function
specifier|static
name|tree
name|build_objc_method_call
parameter_list|(
name|super_flag
parameter_list|,
name|method_prototype
parameter_list|,
name|lookup_object
parameter_list|,
name|object
parameter_list|,
name|selector
parameter_list|,
name|method_params
parameter_list|)
name|int
name|super_flag
decl_stmt|;
name|tree
name|method_prototype
decl_stmt|,
name|lookup_object
decl_stmt|,
name|object
decl_stmt|,
name|selector
decl_stmt|,
name|method_params
decl_stmt|;
block|{
name|tree
name|sender
init|=
operator|(
name|super_flag
condition|?
name|umsg_super_decl
else|:
name|umsg_decl
operator|)
decl_stmt|;
name|tree
name|rcv_p
init|=
operator|(
name|super_flag
condition|?
name|build_pointer_type
argument_list|(
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|TAG_SUPER
argument_list|)
argument_list|)
argument_list|)
else|:
name|id_type
operator|)
decl_stmt|;
if|if
condition|(
name|flag_next_runtime
condition|)
block|{
if|if
condition|(
operator|!
name|method_prototype
condition|)
block|{
name|method_params
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|lookup_object
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|selector
argument_list|,
name|method_params
argument_list|)
argument_list|)
expr_stmt|;
name|assemble_external
argument_list|(
name|sender
argument_list|)
expr_stmt|;
return|return
name|build_function_call
argument_list|(
name|sender
argument_list|,
name|method_params
argument_list|)
return|;
block|}
else|else
block|{
comment|/* This is a real kludge, but it is used only for the Next. 	     Clobber the data type of SENDER temporarily to accept 	     all the arguments for this operation, and to return 	     whatever this operation returns.  */
name|tree
name|arglist
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|retval
decl_stmt|;
comment|/* Save the proper contents of SENDER's data type.  */
name|tree
name|savarg
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|sender
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|savret
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|sender
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Install this method's argument types.  */
name|arglist
operator|=
name|get_arg_type_list
argument_list|(
name|method_prototype
argument_list|,
name|METHOD_REF
argument_list|,
name|super_flag
argument_list|)
expr_stmt|;
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|sender
argument_list|)
argument_list|)
operator|=
name|arglist
expr_stmt|;
comment|/* Install this method's return type.  */
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|sender
argument_list|)
argument_list|)
operator|=
name|groktypename
argument_list|(
name|TREE_TYPE
argument_list|(
name|method_prototype
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Call SENDER with all the parameters.  This will do type 	     checking using the arg types for this method.  */
name|method_params
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|lookup_object
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|selector
argument_list|,
name|method_params
argument_list|)
argument_list|)
expr_stmt|;
name|assemble_external
argument_list|(
name|sender
argument_list|)
expr_stmt|;
name|retval
operator|=
name|build_function_call
argument_list|(
name|sender
argument_list|,
name|method_params
argument_list|)
expr_stmt|;
comment|/* Restore SENDER's return/argument types.  */
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|sender
argument_list|)
argument_list|)
operator|=
name|savarg
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|sender
argument_list|)
argument_list|)
operator|=
name|savret
expr_stmt|;
return|return
name|retval
return|;
block|}
block|}
else|else
block|{
comment|/* This is the portable way. 	 First call the lookup function to get a pointer to the method, 	 then cast the pointer, then call it with the method arguments.  */
name|tree
name|method
decl_stmt|;
comment|/* Avoid trouble since we may evaluate each of these twice.  */
name|object
operator|=
name|save_expr
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|selector
operator|=
name|save_expr
argument_list|(
name|selector
argument_list|)
expr_stmt|;
name|lookup_object
operator|=
name|build_c_cast
argument_list|(
name|rcv_p
argument_list|,
name|lookup_object
argument_list|)
expr_stmt|;
name|assemble_external
argument_list|(
name|sender
argument_list|)
expr_stmt|;
name|method
operator|=
name|build_function_call
argument_list|(
name|sender
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|lookup_object
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|selector
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we have a method prototype, construct the data type this 	 method needs, and cast what we got from SENDER into a pointer 	 to that type.  */
if|if
condition|(
name|method_prototype
condition|)
block|{
name|tree
name|arglist
init|=
name|get_arg_type_list
argument_list|(
name|method_prototype
argument_list|,
name|METHOD_REF
argument_list|,
name|super_flag
argument_list|)
decl_stmt|;
name|tree
name|valtype
init|=
name|groktypename
argument_list|(
name|TREE_TYPE
argument_list|(
name|method_prototype
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|fake_function_type
init|=
name|build_function_type
argument_list|(
name|valtype
argument_list|,
name|arglist
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|method
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|fake_function_type
argument_list|)
expr_stmt|;
block|}
else|else
name|TREE_TYPE
argument_list|(
name|method
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Pass the object to the method.  */
name|assemble_external
argument_list|(
name|method
argument_list|)
expr_stmt|;
return|return
name|build_function_call
argument_list|(
name|method
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|object
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|selector
argument_list|,
name|method_params
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|build_protocol_reference
parameter_list|(
name|p
parameter_list|)
name|tree
name|p
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|,
name|ident
decl_stmt|,
name|ptype
decl_stmt|;
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|end_temporary_allocation
argument_list|()
expr_stmt|;
comment|/* extern struct objc_protocol _OBJC_PROTOCOL_<mumble>; */
name|ident
operator|=
name|synth_id_with_class_suffix
argument_list|(
literal|"_OBJC_PROTOCOL"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|ptype
operator|=
name|groktypename
argument_list|(
name|build_tree_list
argument_list|(
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|objc_protocol_template
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|ident
argument_list|)
condition|)
name|decl
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|ident
argument_list|)
expr_stmt|;
comment|/* Set by pushdecl.  */
else|else
block|{
name|decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|ident
argument_list|,
name|ptype
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|make_decl_rtl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pushdecl_top_level
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
name|PROTOCOL_FORWARD_DECL
argument_list|(
name|p
argument_list|)
operator|=
name|decl
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|tree
name|build_protocol_expr
parameter_list|(
name|protoname
parameter_list|)
name|tree
name|protoname
decl_stmt|;
block|{
name|tree
name|expr
decl_stmt|;
name|tree
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|doing_objc_thang
condition|)
name|objc_fatal
argument_list|()
expr_stmt|;
name|p
operator|=
name|lookup_protocol
argument_list|(
name|protoname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
block|{
name|error
argument_list|(
literal|"Cannot find protocol declaration for `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|protoname
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
operator|!
name|PROTOCOL_FORWARD_DECL
argument_list|(
name|p
argument_list|)
condition|)
name|build_protocol_reference
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|PROTOCOL_FORWARD_DECL
argument_list|(
name|p
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|=
name|protocol_type
expr_stmt|;
return|return
name|expr
return|;
block|}
end_function

begin_function
name|tree
name|build_selector_expr
parameter_list|(
name|selnamelist
parameter_list|)
name|tree
name|selnamelist
decl_stmt|;
block|{
name|tree
name|selname
decl_stmt|;
if|if
condition|(
operator|!
name|doing_objc_thang
condition|)
name|objc_fatal
argument_list|()
expr_stmt|;
comment|/* Obtain the full selector name. */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|selnamelist
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
comment|/* A unary selector. */
name|selname
operator|=
name|selnamelist
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|selnamelist
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|selname
operator|=
name|build_keyword_selector
argument_list|(
name|selnamelist
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_typed_selectors
condition|)
return|return
name|build_typed_selector_reference
argument_list|(
name|selname
argument_list|,
literal|0
argument_list|)
return|;
else|else
return|return
name|build_selector_reference
argument_list|(
name|selname
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|build_encode_expr
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|result
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
if|if
condition|(
operator|!
name|doing_objc_thang
condition|)
name|objc_fatal
argument_list|()
expr_stmt|;
name|encode_type
argument_list|(
name|type
argument_list|,
name|obstack_object_size
argument_list|(
operator|&
name|util_obstack
argument_list|)
argument_list|,
name|OBJC_ENCODE_INLINE_DEFS
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* null terminate string */
name|string
operator|=
name|obstack_finish
argument_list|(
operator|&
name|util_obstack
argument_list|)
expr_stmt|;
comment|/* Synthesize a string that represents the encoded struct/union. */
name|result
operator|=
name|my_build_string
argument_list|(
name|strlen
argument_list|(
name|string
argument_list|)
operator|+
literal|1
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|util_obstack
argument_list|,
name|util_firstobj
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|tree
name|build_ivar_reference
parameter_list|(
name|id
parameter_list|)
name|tree
name|id
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|method_context
argument_list|)
operator|==
name|CLASS_METHOD_DECL
condition|)
block|{
comment|/* Historically, a class method that produced objects (factory 	 method) would assign `self' to the instance that it 	 allocated.  This would effectively turn the class method into 	 an instance method.  Following this assignment, the instance 	 variables could be accessed.  That practice, while safe, 	 violates the simple rule that a class method should not refer 	 to an instance variable.  It's better to catch the cases 	 where this is done unknowingly than to support the above 	 paradigm.  */
name|warning
argument_list|(
literal|"instance variable `%s' accessed in class method"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|self_decl
argument_list|)
operator|=
name|instance_type
expr_stmt|;
comment|/* cast */
block|}
return|return
name|build_component_ref
argument_list|(
name|build_indirect_ref
argument_list|(
name|self_decl
argument_list|,
literal|"->"
argument_list|)
argument_list|,
name|id
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|HASH_ALLOC_LIST_SIZE
value|170
end_define

begin_define
define|#
directive|define
name|ATTR_ALLOC_LIST_SIZE
value|170
end_define

begin_define
define|#
directive|define
name|SIZEHASHTABLE
value|257
end_define

begin_comment
comment|/* make positive */
end_comment

begin_define
define|#
directive|define
name|HASHFUNCTION
parameter_list|(
name|key
parameter_list|)
value|((HOST_WIDE_INT) key& 0x7fffffff)
end_define

begin_function
specifier|static
name|void
name|hash_init
parameter_list|()
block|{
name|nst_method_hash_list
operator|=
operator|(
name|hash
operator|*
operator|)
name|xmalloc
argument_list|(
name|SIZEHASHTABLE
operator|*
sizeof|sizeof
argument_list|(
name|hash
argument_list|)
argument_list|)
expr_stmt|;
name|cls_method_hash_list
operator|=
operator|(
name|hash
operator|*
operator|)
name|xmalloc
argument_list|(
name|SIZEHASHTABLE
operator|*
sizeof|sizeof
argument_list|(
name|hash
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nst_method_hash_list
operator|||
operator|!
name|cls_method_hash_list
condition|)
name|perror
argument_list|(
literal|"unable to allocate space in objc-tree.c"
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SIZEHASHTABLE
condition|;
name|i
operator|++
control|)
block|{
name|nst_method_hash_list
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|cls_method_hash_list
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hash_enter
parameter_list|(
name|hashlist
parameter_list|,
name|method
parameter_list|)
name|hash
modifier|*
name|hashlist
decl_stmt|;
name|tree
name|method
decl_stmt|;
block|{
specifier|static
name|hash
name|hash_alloc_list
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|hash_alloc_index
init|=
literal|0
decl_stmt|;
name|hash
name|obj
decl_stmt|;
name|int
name|slot
init|=
name|HASHFUNCTION
argument_list|(
name|METHOD_SEL_NAME
argument_list|(
name|method
argument_list|)
argument_list|)
operator|%
name|SIZEHASHTABLE
decl_stmt|;
if|if
condition|(
operator|!
name|hash_alloc_list
operator|||
name|hash_alloc_index
operator|>=
name|HASH_ALLOC_LIST_SIZE
condition|)
block|{
name|hash_alloc_index
operator|=
literal|0
expr_stmt|;
name|hash_alloc_list
operator|=
operator|(
name|hash
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|hashed_entry
argument_list|)
operator|*
name|HASH_ALLOC_LIST_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hash_alloc_list
condition|)
name|perror
argument_list|(
literal|"unable to allocate in objc-tree.c"
argument_list|)
expr_stmt|;
block|}
name|obj
operator|=
operator|&
name|hash_alloc_list
index|[
name|hash_alloc_index
operator|++
index|]
expr_stmt|;
name|obj
operator|->
name|list
operator|=
literal|0
expr_stmt|;
name|obj
operator|->
name|next
operator|=
name|hashlist
index|[
name|slot
index|]
expr_stmt|;
name|obj
operator|->
name|key
operator|=
name|method
expr_stmt|;
name|hashlist
index|[
name|slot
index|]
operator|=
name|obj
expr_stmt|;
comment|/* append to front */
block|}
end_function

begin_function
specifier|static
name|hash
name|hash_lookup
parameter_list|(
name|hashlist
parameter_list|,
name|sel_name
parameter_list|)
name|hash
modifier|*
name|hashlist
decl_stmt|;
name|tree
name|sel_name
decl_stmt|;
block|{
name|hash
name|target
decl_stmt|;
name|target
operator|=
name|hashlist
index|[
name|HASHFUNCTION
argument_list|(
name|sel_name
argument_list|)
operator|%
name|SIZEHASHTABLE
index|]
expr_stmt|;
while|while
condition|(
name|target
condition|)
block|{
if|if
condition|(
name|sel_name
operator|==
name|METHOD_SEL_NAME
argument_list|(
name|target
operator|->
name|key
argument_list|)
condition|)
return|return
name|target
return|;
name|target
operator|=
name|target
operator|->
name|next
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hash_add_attr
parameter_list|(
name|entry
parameter_list|,
name|value
parameter_list|)
name|hash
name|entry
decl_stmt|;
name|tree
name|value
decl_stmt|;
block|{
specifier|static
name|attr
name|attr_alloc_list
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|attr_alloc_index
init|=
literal|0
decl_stmt|;
name|attr
name|obj
decl_stmt|;
if|if
condition|(
operator|!
name|attr_alloc_list
operator|||
name|attr_alloc_index
operator|>=
name|ATTR_ALLOC_LIST_SIZE
condition|)
block|{
name|attr_alloc_index
operator|=
literal|0
expr_stmt|;
name|attr_alloc_list
operator|=
operator|(
name|attr
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|hashed_attribute
argument_list|)
operator|*
name|ATTR_ALLOC_LIST_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|attr_alloc_list
condition|)
name|perror
argument_list|(
literal|"unable to allocate in objc-tree.c"
argument_list|)
expr_stmt|;
block|}
name|obj
operator|=
operator|&
name|attr_alloc_list
index|[
name|attr_alloc_index
operator|++
index|]
expr_stmt|;
name|obj
operator|->
name|next
operator|=
name|entry
operator|->
name|list
expr_stmt|;
name|obj
operator|->
name|value
operator|=
name|value
expr_stmt|;
name|entry
operator|->
name|list
operator|=
name|obj
expr_stmt|;
comment|/* append to front */
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|tree
name|lookup_method
parameter_list|(
name|mchain
parameter_list|,
name|method
parameter_list|)
name|tree
name|mchain
decl_stmt|;
name|tree
name|method
decl_stmt|;
block|{
name|tree
name|key
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|method
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|key
operator|=
name|method
expr_stmt|;
else|else
name|key
operator|=
name|METHOD_SEL_NAME
argument_list|(
name|method
argument_list|)
expr_stmt|;
while|while
condition|(
name|mchain
condition|)
block|{
if|if
condition|(
name|METHOD_SEL_NAME
argument_list|(
name|mchain
argument_list|)
operator|==
name|key
condition|)
return|return
name|mchain
return|;
name|mchain
operator|=
name|TREE_CHAIN
argument_list|(
name|mchain
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|lookup_instance_method_static
parameter_list|(
name|interface
parameter_list|,
name|ident
parameter_list|)
name|tree
name|interface
decl_stmt|;
name|tree
name|ident
decl_stmt|;
block|{
name|tree
name|inter
init|=
name|interface
decl_stmt|;
name|tree
name|chain
init|=
name|CLASS_NST_METHODS
argument_list|(
name|inter
argument_list|)
decl_stmt|;
name|tree
name|meth
init|=
name|NULL_TREE
decl_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|meth
operator|=
name|lookup_method
argument_list|(
name|chain
argument_list|,
name|ident
argument_list|)
operator|)
condition|)
return|return
name|meth
return|;
if|if
condition|(
name|CLASS_CATEGORY_LIST
argument_list|(
name|inter
argument_list|)
condition|)
block|{
name|tree
name|category
init|=
name|CLASS_CATEGORY_LIST
argument_list|(
name|inter
argument_list|)
decl_stmt|;
name|chain
operator|=
name|CLASS_NST_METHODS
argument_list|(
name|category
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|meth
operator|=
name|lookup_method
argument_list|(
name|chain
argument_list|,
name|ident
argument_list|)
operator|)
condition|)
return|return
name|meth
return|;
comment|/* Check for instance methods in protocols in categories.  */
if|if
condition|(
name|CLASS_PROTOCOL_LIST
argument_list|(
name|category
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|meth
operator|=
operator|(
name|lookup_method_in_protocol_list
argument_list|(
name|CLASS_PROTOCOL_LIST
argument_list|(
name|category
argument_list|)
argument_list|,
name|ident
argument_list|,
literal|0
argument_list|)
operator|)
operator|)
condition|)
return|return
name|meth
return|;
block|}
if|if
condition|(
operator|(
name|category
operator|=
name|CLASS_CATEGORY_LIST
argument_list|(
name|category
argument_list|)
operator|)
condition|)
name|chain
operator|=
name|CLASS_NST_METHODS
argument_list|(
name|category
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|category
condition|)
do|;
block|}
if|if
condition|(
name|CLASS_PROTOCOL_LIST
argument_list|(
name|inter
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|meth
operator|=
operator|(
name|lookup_method_in_protocol_list
argument_list|(
name|CLASS_PROTOCOL_LIST
argument_list|(
name|inter
argument_list|)
argument_list|,
name|ident
argument_list|,
literal|0
argument_list|)
operator|)
operator|)
condition|)
return|return
name|meth
return|;
block|}
if|if
condition|(
operator|(
name|inter
operator|=
name|lookup_interface
argument_list|(
name|CLASS_SUPER_NAME
argument_list|(
name|inter
argument_list|)
argument_list|)
operator|)
condition|)
name|chain
operator|=
name|CLASS_NST_METHODS
argument_list|(
name|inter
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|inter
condition|)
do|;
return|return
name|meth
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|lookup_class_method_static
parameter_list|(
name|interface
parameter_list|,
name|ident
parameter_list|)
name|tree
name|interface
decl_stmt|;
name|tree
name|ident
decl_stmt|;
block|{
name|tree
name|inter
init|=
name|interface
decl_stmt|;
name|tree
name|chain
init|=
name|CLASS_CLS_METHODS
argument_list|(
name|inter
argument_list|)
decl_stmt|;
name|tree
name|meth
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|root_inter
init|=
name|NULL_TREE
decl_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|meth
operator|=
name|lookup_method
argument_list|(
name|chain
argument_list|,
name|ident
argument_list|)
operator|)
condition|)
return|return
name|meth
return|;
if|if
condition|(
name|CLASS_CATEGORY_LIST
argument_list|(
name|inter
argument_list|)
condition|)
block|{
name|tree
name|category
init|=
name|CLASS_CATEGORY_LIST
argument_list|(
name|inter
argument_list|)
decl_stmt|;
name|chain
operator|=
name|CLASS_CLS_METHODS
argument_list|(
name|category
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|meth
operator|=
name|lookup_method
argument_list|(
name|chain
argument_list|,
name|ident
argument_list|)
operator|)
condition|)
return|return
name|meth
return|;
comment|/* Check for class methods in protocols in categories.  */
if|if
condition|(
name|CLASS_PROTOCOL_LIST
argument_list|(
name|category
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|meth
operator|=
operator|(
name|lookup_method_in_protocol_list
argument_list|(
name|CLASS_PROTOCOL_LIST
argument_list|(
name|category
argument_list|)
argument_list|,
name|ident
argument_list|,
literal|1
argument_list|)
operator|)
operator|)
condition|)
return|return
name|meth
return|;
block|}
if|if
condition|(
operator|(
name|category
operator|=
name|CLASS_CATEGORY_LIST
argument_list|(
name|category
argument_list|)
operator|)
condition|)
name|chain
operator|=
name|CLASS_CLS_METHODS
argument_list|(
name|category
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|category
condition|)
do|;
block|}
comment|/* Check for class methods in protocols.  */
if|if
condition|(
name|CLASS_PROTOCOL_LIST
argument_list|(
name|inter
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|meth
operator|=
operator|(
name|lookup_method_in_protocol_list
argument_list|(
name|CLASS_PROTOCOL_LIST
argument_list|(
name|inter
argument_list|)
argument_list|,
name|ident
argument_list|,
literal|1
argument_list|)
operator|)
operator|)
condition|)
return|return
name|meth
return|;
block|}
name|root_inter
operator|=
name|inter
expr_stmt|;
if|if
condition|(
operator|(
name|inter
operator|=
name|lookup_interface
argument_list|(
name|CLASS_SUPER_NAME
argument_list|(
name|inter
argument_list|)
argument_list|)
operator|)
condition|)
name|chain
operator|=
name|CLASS_CLS_METHODS
argument_list|(
name|inter
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|inter
condition|)
do|;
comment|/* Simulate wrap around.  */
return|return
name|lookup_instance_method_static
argument_list|(
name|root_inter
argument_list|,
name|ident
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|add_class_method
parameter_list|(
name|class
parameter_list|,
name|method
parameter_list|)
name|tree
name|class
decl_stmt|;
name|tree
name|method
decl_stmt|;
block|{
name|tree
name|mth
decl_stmt|;
name|hash
name|hsh
decl_stmt|;
comment|/* We will have allocated the method parameter declarations on the      maybepermanent_obstack.  Need to make sure they stick around!  */
name|preserve_data
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|mth
operator|=
name|lookup_method
argument_list|(
name|CLASS_CLS_METHODS
argument_list|(
name|class
argument_list|)
argument_list|,
name|method
argument_list|)
operator|)
condition|)
block|{
comment|/* put method on list in reverse order */
name|TREE_CHAIN
argument_list|(
name|method
argument_list|)
operator|=
name|CLASS_CLS_METHODS
argument_list|(
name|class
argument_list|)
expr_stmt|;
name|CLASS_CLS_METHODS
argument_list|(
name|class
argument_list|)
operator|=
name|method
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|class
argument_list|)
operator|==
name|CLASS_IMPLEMENTATION_TYPE
condition|)
name|error
argument_list|(
literal|"duplicate definition of class method `%s'."
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|METHOD_SEL_NAME
argument_list|(
name|mth
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Check types; if different, complain. */
if|if
condition|(
operator|!
name|comp_proto_with_proto
argument_list|(
name|method
argument_list|,
name|mth
argument_list|)
condition|)
name|error
argument_list|(
literal|"duplicate declaration of class method `%s'."
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|METHOD_SEL_NAME
argument_list|(
name|mth
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|hsh
operator|=
name|hash_lookup
argument_list|(
name|cls_method_hash_list
argument_list|,
name|METHOD_SEL_NAME
argument_list|(
name|method
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/* Install on a global chain. */
name|hash_enter
argument_list|(
name|cls_method_hash_list
argument_list|,
name|method
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Check types; if different, add to a list. */
if|if
condition|(
operator|!
name|comp_proto_with_proto
argument_list|(
name|method
argument_list|,
name|hsh
operator|->
name|key
argument_list|)
condition|)
name|hash_add_attr
argument_list|(
name|hsh
argument_list|,
name|method
argument_list|)
expr_stmt|;
block|}
return|return
name|method
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|tree
name|add_instance_method
parameter_list|(
name|class
parameter_list|,
name|method
parameter_list|)
name|tree
name|class
decl_stmt|;
name|tree
name|method
decl_stmt|;
block|{
name|tree
name|mth
decl_stmt|;
name|hash
name|hsh
decl_stmt|;
comment|/* We will have allocated the method parameter declarations on the      maybepermanent_obstack.  Need to make sure they stick around!  */
name|preserve_data
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|mth
operator|=
name|lookup_method
argument_list|(
name|CLASS_NST_METHODS
argument_list|(
name|class
argument_list|)
argument_list|,
name|method
argument_list|)
operator|)
condition|)
block|{
comment|/* Put method on list in reverse order.  */
name|TREE_CHAIN
argument_list|(
name|method
argument_list|)
operator|=
name|CLASS_NST_METHODS
argument_list|(
name|class
argument_list|)
expr_stmt|;
name|CLASS_NST_METHODS
argument_list|(
name|class
argument_list|)
operator|=
name|method
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|class
argument_list|)
operator|==
name|CLASS_IMPLEMENTATION_TYPE
condition|)
name|error
argument_list|(
literal|"duplicate definition of instance method `%s'."
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|METHOD_SEL_NAME
argument_list|(
name|mth
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Check types; if different, complain. */
if|if
condition|(
operator|!
name|comp_proto_with_proto
argument_list|(
name|method
argument_list|,
name|mth
argument_list|)
condition|)
name|error
argument_list|(
literal|"duplicate declaration of instance method `%s'."
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|METHOD_SEL_NAME
argument_list|(
name|mth
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|hsh
operator|=
name|hash_lookup
argument_list|(
name|nst_method_hash_list
argument_list|,
name|METHOD_SEL_NAME
argument_list|(
name|method
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/* Install on a global chain. */
name|hash_enter
argument_list|(
name|nst_method_hash_list
argument_list|,
name|method
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Check types; if different, add to a list.  */
if|if
condition|(
operator|!
name|comp_proto_with_proto
argument_list|(
name|method
argument_list|,
name|hsh
operator|->
name|key
argument_list|)
condition|)
name|hash_add_attr
argument_list|(
name|hsh
argument_list|,
name|method
argument_list|)
expr_stmt|;
block|}
return|return
name|method
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|add_class
parameter_list|(
name|class
parameter_list|)
name|tree
name|class
decl_stmt|;
block|{
comment|/* Put interfaces on list in reverse order. */
name|TREE_CHAIN
argument_list|(
name|class
argument_list|)
operator|=
name|interface_chain
expr_stmt|;
name|interface_chain
operator|=
name|class
expr_stmt|;
return|return
name|interface_chain
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_category
parameter_list|(
name|class
parameter_list|,
name|category
parameter_list|)
name|tree
name|class
decl_stmt|;
name|tree
name|category
decl_stmt|;
block|{
comment|/* Put categories on list in reverse order. */
name|tree
name|cat
init|=
name|CLASS_CATEGORY_LIST
argument_list|(
name|class
argument_list|)
decl_stmt|;
while|while
condition|(
name|cat
condition|)
block|{
if|if
condition|(
name|CLASS_SUPER_NAME
argument_list|(
name|cat
argument_list|)
operator|==
name|CLASS_SUPER_NAME
argument_list|(
name|category
argument_list|)
condition|)
name|warning
argument_list|(
literal|"duplicate interface declaration for category `%s(%s)'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_NAME
argument_list|(
name|class
argument_list|)
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_SUPER_NAME
argument_list|(
name|category
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|cat
operator|=
name|CLASS_CATEGORY_LIST
argument_list|(
name|cat
argument_list|)
expr_stmt|;
block|}
name|CLASS_CATEGORY_LIST
argument_list|(
name|category
argument_list|)
operator|=
name|CLASS_CATEGORY_LIST
argument_list|(
name|class
argument_list|)
expr_stmt|;
name|CLASS_CATEGORY_LIST
argument_list|(
name|class
argument_list|)
operator|=
name|category
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called after parsing each instance variable declaration. Necessary to    preserve typedefs and implement public/private...     PUBLIC is 1 for public, 0 for protected, and 2 for private.  */
end_comment

begin_function
name|tree
name|add_instance_variable
parameter_list|(
name|class
parameter_list|,
name|public
parameter_list|,
name|declarator
parameter_list|,
name|declspecs
parameter_list|,
name|width
parameter_list|)
name|tree
name|class
decl_stmt|;
name|int
name|public
decl_stmt|;
name|tree
name|declarator
decl_stmt|;
name|tree
name|declspecs
decl_stmt|;
name|tree
name|width
decl_stmt|;
block|{
name|tree
name|field_decl
decl_stmt|,
name|raw_decl
decl_stmt|;
name|raw_decl
operator|=
name|build_tree_list
argument_list|(
name|declspecs
argument_list|,
name|declarator
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASS_RAW_IVARS
argument_list|(
name|class
argument_list|)
condition|)
name|chainon
argument_list|(
name|CLASS_RAW_IVARS
argument_list|(
name|class
argument_list|)
argument_list|,
name|raw_decl
argument_list|)
expr_stmt|;
else|else
name|CLASS_RAW_IVARS
argument_list|(
name|class
argument_list|)
operator|=
name|raw_decl
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|declarator
argument_list|,
name|declspecs
argument_list|,
name|width
argument_list|)
expr_stmt|;
comment|/* Overload the public attribute, it is not used for FIELD_DECLs. */
switch|switch
condition|(
name|public
condition|)
block|{
case|case
literal|0
case|:
name|TREE_PUBLIC
argument_list|(
name|field_decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_PRIVATE
argument_list|(
name|field_decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_PROTECTED
argument_list|(
name|field_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|TREE_PUBLIC
argument_list|(
name|field_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PRIVATE
argument_list|(
name|field_decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_PROTECTED
argument_list|(
name|field_decl
argument_list|)
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|TREE_PUBLIC
argument_list|(
name|field_decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_PRIVATE
argument_list|(
name|field_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PROTECTED
argument_list|(
name|field_decl
argument_list|)
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|CLASS_IVARS
argument_list|(
name|class
argument_list|)
condition|)
name|chainon
argument_list|(
name|CLASS_IVARS
argument_list|(
name|class
argument_list|)
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
else|else
name|CLASS_IVARS
argument_list|(
name|class
argument_list|)
operator|=
name|field_decl
expr_stmt|;
return|return
name|class
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|tree
name|is_ivar
parameter_list|(
name|decl_chain
parameter_list|,
name|ident
parameter_list|)
name|tree
name|decl_chain
decl_stmt|;
name|tree
name|ident
decl_stmt|;
block|{
for|for
control|(
init|;
name|decl_chain
condition|;
name|decl_chain
operator|=
name|TREE_CHAIN
argument_list|(
name|decl_chain
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl_chain
argument_list|)
operator|==
name|ident
condition|)
return|return
name|decl_chain
return|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* True if the ivar is private and we are not in its implementation.  */
end_comment

begin_function
name|int
name|is_private
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
name|TREE_PRIVATE
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|is_ivar
argument_list|(
name|CLASS_IVARS
argument_list|(
name|implementation_template
argument_list|)
argument_list|,
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"instance variable `%s' is declared private"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* We have an instance variable reference;, check to see if it is public.  */
end_comment

begin_function
name|int
name|is_public
parameter_list|(
name|expr
parameter_list|,
name|identifier
parameter_list|)
name|tree
name|expr
decl_stmt|;
name|tree
name|identifier
decl_stmt|;
block|{
name|tree
name|basetype
init|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
decl_stmt|;
name|tree
name|decl
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|RECORD_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_STATIC_TEMPLATE
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|lookup_interface
argument_list|(
name|TYPE_NAME
argument_list|(
name|basetype
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"Cannot find interface declaration for `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TYPE_NAME
argument_list|(
name|basetype
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|decl
operator|=
name|is_ivar
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|identifier
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Important difference between the Stepstone translator: 		 all instance variables should be public within the context 		 of the implementation.  */
if|if
condition|(
name|implementation_context
operator|&&
operator|(
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|implementation_context
argument_list|)
operator|==
name|CLASS_IMPLEMENTATION_TYPE
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|implementation_context
argument_list|)
operator|==
name|CATEGORY_IMPLEMENTATION_TYPE
operator|)
operator|)
operator|&&
operator|(
name|CLASS_NAME
argument_list|(
name|implementation_context
argument_list|)
operator|==
name|TYPE_NAME
argument_list|(
name|basetype
argument_list|)
operator|)
operator|)
condition|)
return|return
operator|!
name|is_private
argument_list|(
name|decl
argument_list|)
return|;
name|error
argument_list|(
literal|"instance variable `%s' is declared %s"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|identifier
argument_list|)
argument_list|,
name|TREE_PRIVATE
argument_list|(
name|decl
argument_list|)
condition|?
literal|"private"
else|:
literal|"protected"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|implementation_context
operator|&&
operator|(
name|basetype
operator|==
name|objc_object_reference
operator|)
condition|)
block|{
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|=
name|uprivate_record
expr_stmt|;
name|warning
argument_list|(
literal|"static access to object of type `id'"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Implement @defs (<classname>) within struct bodies. */
end_comment

begin_function
name|tree
name|get_class_ivars
parameter_list|(
name|interface
parameter_list|)
name|tree
name|interface
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|doing_objc_thang
condition|)
name|objc_fatal
argument_list|()
expr_stmt|;
return|return
name|build_ivar_chain
argument_list|(
name|interface
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make sure all entries in CHAIN are also in LIST. */
end_comment

begin_function
specifier|static
name|int
name|check_methods
parameter_list|(
name|chain
parameter_list|,
name|list
parameter_list|,
name|mtype
parameter_list|)
name|tree
name|chain
decl_stmt|;
name|tree
name|list
decl_stmt|;
name|int
name|mtype
decl_stmt|;
block|{
name|int
name|first
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|chain
condition|)
block|{
if|if
condition|(
operator|!
name|lookup_method
argument_list|(
name|list
argument_list|,
name|chain
argument_list|)
condition|)
block|{
if|if
condition|(
name|first
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|implementation_context
argument_list|)
operator|==
name|CLASS_IMPLEMENTATION_TYPE
condition|)
name|warning
argument_list|(
literal|"incomplete implementation of class `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_NAME
argument_list|(
name|implementation_context
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|implementation_context
argument_list|)
operator|==
name|CATEGORY_IMPLEMENTATION_TYPE
condition|)
name|warning
argument_list|(
literal|"incomplete implementation of category `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_SUPER_NAME
argument_list|(
name|implementation_context
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
name|warning
argument_list|(
literal|"method definition for `%c%s' not found"
argument_list|,
name|mtype
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|METHOD_SEL_NAME
argument_list|(
name|chain
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
expr_stmt|;
block|}
return|return
name|first
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|conforms_to_protocol
parameter_list|(
name|class
parameter_list|,
name|protocol
parameter_list|)
name|tree
name|class
decl_stmt|;
name|tree
name|protocol
decl_stmt|;
block|{
while|while
condition|(
name|protocol
condition|)
block|{
name|tree
name|p
init|=
name|CLASS_PROTOCOL_LIST
argument_list|(
name|class
argument_list|)
decl_stmt|;
while|while
condition|(
name|p
operator|&&
name|TREE_VALUE
argument_list|(
name|p
argument_list|)
operator|!=
name|TREE_VALUE
argument_list|(
name|protocol
argument_list|)
condition|)
name|p
operator|=
name|TREE_CHAIN
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
block|{
name|tree
name|super
init|=
operator|(
name|CLASS_SUPER_NAME
argument_list|(
name|class
argument_list|)
condition|?
name|lookup_interface
argument_list|(
name|CLASS_SUPER_NAME
argument_list|(
name|class
argument_list|)
argument_list|)
else|:
name|NULL_TREE
operator|)
decl_stmt|;
name|int
name|tmp
init|=
name|super
condition|?
name|conforms_to_protocol
argument_list|(
name|super
argument_list|,
name|protocol
argument_list|)
else|:
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|tmp
condition|)
return|return
literal|0
return|;
block|}
name|protocol
operator|=
name|TREE_CHAIN
argument_list|(
name|protocol
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Make sure all methods in CHAIN are accessible as MTYPE methods in     CONTEXT.  This is one of two mechanisms to check protocol integrity. */
end_comment

begin_function
specifier|static
name|int
name|check_methods_accessible
parameter_list|(
name|chain
parameter_list|,
name|context
parameter_list|,
name|mtype
parameter_list|)
name|tree
name|chain
decl_stmt|;
name|tree
name|context
decl_stmt|;
name|int
name|mtype
decl_stmt|;
block|{
name|int
name|first
init|=
literal|1
decl_stmt|;
name|tree
name|list
decl_stmt|;
name|tree
name|base_context
init|=
name|context
decl_stmt|;
while|while
condition|(
name|chain
condition|)
block|{
name|context
operator|=
name|base_context
expr_stmt|;
while|while
condition|(
name|context
condition|)
block|{
if|if
condition|(
name|mtype
operator|==
literal|'+'
condition|)
name|list
operator|=
name|CLASS_CLS_METHODS
argument_list|(
name|context
argument_list|)
expr_stmt|;
else|else
name|list
operator|=
name|CLASS_NST_METHODS
argument_list|(
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|lookup_method
argument_list|(
name|list
argument_list|,
name|chain
argument_list|)
condition|)
break|break;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|==
name|CLASS_IMPLEMENTATION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|==
name|CLASS_INTERFACE_TYPE
condition|)
name|context
operator|=
operator|(
name|CLASS_SUPER_NAME
argument_list|(
name|context
argument_list|)
condition|?
name|lookup_interface
argument_list|(
name|CLASS_SUPER_NAME
argument_list|(
name|context
argument_list|)
argument_list|)
else|:
name|NULL_TREE
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|==
name|CATEGORY_IMPLEMENTATION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|==
name|CATEGORY_INTERFACE_TYPE
condition|)
name|context
operator|=
operator|(
name|CLASS_NAME
argument_list|(
name|context
argument_list|)
condition|?
name|lookup_interface
argument_list|(
name|CLASS_NAME
argument_list|(
name|context
argument_list|)
argument_list|)
else|:
name|NULL_TREE
operator|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|context
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|first
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|implementation_context
argument_list|)
operator|==
name|CLASS_IMPLEMENTATION_TYPE
condition|)
name|warning
argument_list|(
literal|"incomplete implementation of class `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_NAME
argument_list|(
name|implementation_context
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|implementation_context
argument_list|)
operator|==
name|CATEGORY_IMPLEMENTATION_TYPE
condition|)
name|warning
argument_list|(
literal|"incomplete implementation of category `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_SUPER_NAME
argument_list|(
name|implementation_context
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
name|warning
argument_list|(
literal|"method definition for `%c%s' not found"
argument_list|,
name|mtype
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|METHOD_SEL_NAME
argument_list|(
name|chain
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
expr_stmt|;
comment|/* next method... */
block|}
return|return
name|first
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|check_protocols
parameter_list|(
name|proto_list
parameter_list|,
name|type
parameter_list|,
name|name
parameter_list|)
name|tree
name|proto_list
decl_stmt|;
name|char
modifier|*
name|type
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
for|for
control|(
init|;
name|proto_list
condition|;
name|proto_list
operator|=
name|TREE_CHAIN
argument_list|(
name|proto_list
argument_list|)
control|)
block|{
name|tree
name|p
init|=
name|TREE_VALUE
argument_list|(
name|proto_list
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|PROTOCOL_INTERFACE_TYPE
condition|)
block|{
name|int
name|f1
decl_stmt|,
name|f2
decl_stmt|;
comment|/* Ensure that all protocols have bodies. */
if|if
condition|(
name|flag_warn_protocol
condition|)
block|{
name|f1
operator|=
name|check_methods
argument_list|(
name|PROTOCOL_CLS_METHODS
argument_list|(
name|p
argument_list|)
argument_list|,
name|CLASS_CLS_METHODS
argument_list|(
name|implementation_context
argument_list|)
argument_list|,
literal|'+'
argument_list|)
expr_stmt|;
name|f2
operator|=
name|check_methods
argument_list|(
name|PROTOCOL_NST_METHODS
argument_list|(
name|p
argument_list|)
argument_list|,
name|CLASS_NST_METHODS
argument_list|(
name|implementation_context
argument_list|)
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|f1
operator|=
name|check_methods_accessible
argument_list|(
name|PROTOCOL_CLS_METHODS
argument_list|(
name|p
argument_list|)
argument_list|,
name|implementation_context
argument_list|,
literal|'+'
argument_list|)
expr_stmt|;
name|f2
operator|=
name|check_methods_accessible
argument_list|(
name|PROTOCOL_NST_METHODS
argument_list|(
name|p
argument_list|)
argument_list|,
name|implementation_context
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|f1
operator|||
operator|!
name|f2
condition|)
name|warning
argument_list|(
literal|"%s `%s' does not fully implement the `%s' protocol"
argument_list|,
name|type
argument_list|,
name|name
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|PROTOCOL_NAME
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
empty_stmt|;
comment|/* An identifier if we could not find a protocol.  */
comment|/* Check protocols recursively. */
if|if
condition|(
name|PROTOCOL_LIST
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|tree
name|super_class
init|=
name|lookup_interface
argument_list|(
name|CLASS_SUPER_NAME
argument_list|(
name|implementation_template
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|conforms_to_protocol
argument_list|(
name|super_class
argument_list|,
name|PROTOCOL_LIST
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
name|check_protocols
argument_list|(
name|PROTOCOL_LIST
argument_list|(
name|p
argument_list|)
argument_list|,
name|type
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make sure that the class CLASS_NAME is defined    CODE says which kind of thing CLASS_NAME ought to be.    It can be CLASS_INTERFACE_TYPE, CLASS_IMPLEMENTATION_TYPE,    CATEGORY_INTERFACE_TYPE, or CATEGORY_IMPLEMENTATION_TYPE.     If CODE is CLASS_INTERFACE_TYPE, we also do a push_obstacks_nochange    whose matching pop is in continue_class.  */
end_comment

begin_function
name|tree
name|start_class
parameter_list|(
name|code
parameter_list|,
name|class_name
parameter_list|,
name|super_name
parameter_list|,
name|protocol_list
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|class_name
decl_stmt|;
name|tree
name|super_name
decl_stmt|;
name|tree
name|protocol_list
decl_stmt|;
block|{
name|tree
name|class
decl_stmt|,
name|decl
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|CLASS_INTERFACE_TYPE
condition|)
block|{
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|end_temporary_allocation
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|doing_objc_thang
condition|)
name|objc_fatal
argument_list|()
expr_stmt|;
name|class
operator|=
name|make_node
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|TYPE_BINFO
argument_list|(
name|class
argument_list|)
operator|=
name|make_tree_vec
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|CLASS_NAME
argument_list|(
name|class
argument_list|)
operator|=
name|class_name
expr_stmt|;
name|CLASS_SUPER_NAME
argument_list|(
name|class
argument_list|)
operator|=
name|super_name
expr_stmt|;
name|CLASS_CLS_METHODS
argument_list|(
name|class
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
operator|!
name|is_class_name
argument_list|(
name|class_name
argument_list|)
operator|&&
operator|(
name|decl
operator|=
name|lookup_name
argument_list|(
name|class_name
argument_list|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"`%s' redeclared as different kind of symbol"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|class_name
argument_list|)
argument_list|)
expr_stmt|;
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"previous declaration of `%s'"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
name|CLASS_IMPLEMENTATION_TYPE
condition|)
block|{
block|{
specifier|static
name|tree
name|implemented_classes
init|=
literal|0
decl_stmt|;
name|tree
name|chain
init|=
name|implemented_classes
decl_stmt|;
for|for
control|(
name|chain
operator|=
name|implemented_classes
init|;
name|chain
condition|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
control|)
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
operator|==
name|class_name
condition|)
block|{
name|error
argument_list|(
literal|"reimplementation of class `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|class_name
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|implemented_classes
operator|=
name|perm_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|class_name
argument_list|,
name|implemented_classes
argument_list|)
expr_stmt|;
block|}
comment|/* Pre-build the following entities - for speed/convenience. */
if|if
condition|(
operator|!
name|self_id
condition|)
name|self_id
operator|=
name|get_identifier
argument_list|(
literal|"self"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ucmd_id
condition|)
name|ucmd_id
operator|=
name|get_identifier
argument_list|(
literal|"_cmd"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|unused_list
condition|)
name|unused_list
operator|=
name|build_tree_list
argument_list|(
name|get_identifier
argument_list|(
literal|"__unused__"
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|objc_super_template
condition|)
name|objc_super_template
operator|=
name|build_super_template
argument_list|()
expr_stmt|;
comment|/* Reset for multiple classes per file.  */
name|method_slot
operator|=
literal|0
expr_stmt|;
name|implementation_context
operator|=
name|class
expr_stmt|;
comment|/* Lookup the interface for this implementation. */
if|if
condition|(
operator|!
operator|(
name|implementation_template
operator|=
name|lookup_interface
argument_list|(
name|class_name
argument_list|)
operator|)
condition|)
block|{
name|warning
argument_list|(
literal|"Cannot find interface declaration for `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|class_name
argument_list|)
argument_list|)
expr_stmt|;
name|add_class
argument_list|(
name|implementation_template
operator|=
name|implementation_context
argument_list|)
expr_stmt|;
block|}
comment|/* If a super class has been specified in the implementation, 	 insure it conforms to the one specified in the interface.  */
if|if
condition|(
name|super_name
operator|&&
operator|(
name|super_name
operator|!=
name|CLASS_SUPER_NAME
argument_list|(
name|implementation_template
argument_list|)
operator|)
condition|)
block|{
name|tree
name|previous_name
init|=
name|CLASS_SUPER_NAME
argument_list|(
name|implementation_template
argument_list|)
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|previous_name
condition|?
name|IDENTIFIER_POINTER
argument_list|(
name|previous_name
argument_list|)
else|:
literal|""
decl_stmt|;
name|error
argument_list|(
literal|"conflicting super class name `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|super_name
argument_list|)
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"previous declaration of `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|super_name
condition|)
block|{
name|CLASS_SUPER_NAME
argument_list|(
name|implementation_context
argument_list|)
operator|=
name|CLASS_SUPER_NAME
argument_list|(
name|implementation_template
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|CLASS_INTERFACE_TYPE
condition|)
block|{
if|if
condition|(
name|lookup_interface
argument_list|(
name|class_name
argument_list|)
condition|)
name|warning
argument_list|(
literal|"duplicate interface declaration for class `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|class_name
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|add_class
argument_list|(
name|class
argument_list|)
expr_stmt|;
if|if
condition|(
name|protocol_list
condition|)
name|CLASS_PROTOCOL_LIST
argument_list|(
name|class
argument_list|)
operator|=
name|lookup_and_install_protocols
argument_list|(
name|protocol_list
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|CATEGORY_INTERFACE_TYPE
condition|)
block|{
name|tree
name|class_category_is_assoc_with
decl_stmt|;
comment|/* For a category, class_name is really the name of the class that 	 the following set of methods will be associated with. We must 	 find the interface so that can derive the objects template.  */
if|if
condition|(
operator|!
operator|(
name|class_category_is_assoc_with
operator|=
name|lookup_interface
argument_list|(
name|class_name
argument_list|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"Cannot find interface declaration for `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|class_name
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
else|else
name|add_category
argument_list|(
name|class_category_is_assoc_with
argument_list|,
name|class
argument_list|)
expr_stmt|;
if|if
condition|(
name|protocol_list
condition|)
name|CLASS_PROTOCOL_LIST
argument_list|(
name|class
argument_list|)
operator|=
name|lookup_and_install_protocols
argument_list|(
name|protocol_list
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|CATEGORY_IMPLEMENTATION_TYPE
condition|)
block|{
comment|/* Pre-build the following entities for speed/convenience. */
if|if
condition|(
operator|!
name|self_id
condition|)
name|self_id
operator|=
name|get_identifier
argument_list|(
literal|"self"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ucmd_id
condition|)
name|ucmd_id
operator|=
name|get_identifier
argument_list|(
literal|"_cmd"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|unused_list
condition|)
name|unused_list
operator|=
name|build_tree_list
argument_list|(
name|get_identifier
argument_list|(
literal|"__unused__"
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|objc_super_template
condition|)
name|objc_super_template
operator|=
name|build_super_template
argument_list|()
expr_stmt|;
comment|/* Reset for multiple classes per file.  */
name|method_slot
operator|=
literal|0
expr_stmt|;
name|implementation_context
operator|=
name|class
expr_stmt|;
comment|/* For a category, class_name is really the name of the class that 	 the following set of methods will be associated with.  We must 	 find the interface so that can derive the objects template. */
if|if
condition|(
operator|!
operator|(
name|implementation_template
operator|=
name|lookup_interface
argument_list|(
name|class_name
argument_list|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"Cannot find interface declaration for `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|class_name
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|class
return|;
block|}
end_function

begin_function
name|tree
name|continue_class
parameter_list|(
name|class
parameter_list|)
name|tree
name|class
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|class
argument_list|)
operator|==
name|CLASS_IMPLEMENTATION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|class
argument_list|)
operator|==
name|CATEGORY_IMPLEMENTATION_TYPE
condition|)
block|{
name|struct
name|imp_entry
modifier|*
name|imp_entry
decl_stmt|;
name|tree
name|ivar_context
decl_stmt|;
comment|/* Check consistency of the instance variables. */
if|if
condition|(
name|CLASS_IVARS
argument_list|(
name|class
argument_list|)
condition|)
name|check_ivars
argument_list|(
name|implementation_template
argument_list|,
name|class
argument_list|)
expr_stmt|;
comment|/* code generation */
name|ivar_context
operator|=
name|build_private_template
argument_list|(
name|implementation_template
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|objc_class_template
condition|)
name|build_class_template
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|imp_entry
operator|=
operator|(
expr|struct
name|imp_entry
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|imp_entry
argument_list|)
argument_list|)
operator|)
condition|)
name|perror
argument_list|(
literal|"unable to allocate in objc-tree.c"
argument_list|)
expr_stmt|;
name|imp_entry
operator|->
name|next
operator|=
name|imp_list
expr_stmt|;
name|imp_entry
operator|->
name|imp_context
operator|=
name|class
expr_stmt|;
name|imp_entry
operator|->
name|imp_template
operator|=
name|implementation_template
expr_stmt|;
name|synth_forward_declarations
argument_list|()
expr_stmt|;
name|imp_entry
operator|->
name|class_decl
operator|=
name|UOBJC_CLASS_decl
expr_stmt|;
name|imp_entry
operator|->
name|meta_decl
operator|=
name|UOBJC_METACLASS_decl
expr_stmt|;
comment|/* Append to front and increment count. */
name|imp_list
operator|=
name|imp_entry
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|class
argument_list|)
operator|==
name|CLASS_IMPLEMENTATION_TYPE
condition|)
name|imp_count
operator|++
expr_stmt|;
else|else
name|cat_count
operator|++
expr_stmt|;
return|return
name|ivar_context
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|class
argument_list|)
operator|==
name|CLASS_INTERFACE_TYPE
condition|)
block|{
name|tree
name|record
init|=
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|CLASS_NAME
argument_list|(
name|class
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|TYPE_FIELDS
argument_list|(
name|record
argument_list|)
condition|)
block|{
name|finish_struct
argument_list|(
name|record
argument_list|,
name|build_ivar_chain
argument_list|(
name|class
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|CLASS_STATIC_TEMPLATE
argument_list|(
name|class
argument_list|)
operator|=
name|record
expr_stmt|;
comment|/* Mark this record as a class template for static typing.  */
name|TREE_STATIC_TEMPLATE
argument_list|(
name|record
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
else|else
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* This is called once we see the "@end" in an interface/implementation.  */
end_comment

begin_function
name|void
name|finish_class
parameter_list|(
name|class
parameter_list|)
name|tree
name|class
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|class
argument_list|)
operator|==
name|CLASS_IMPLEMENTATION_TYPE
condition|)
block|{
comment|/* All code generation is done in finish_objc. */
if|if
condition|(
name|implementation_template
operator|!=
name|implementation_context
condition|)
block|{
comment|/* Ensure that all method listed in the interface contain bodies. */
name|check_methods
argument_list|(
name|CLASS_CLS_METHODS
argument_list|(
name|implementation_template
argument_list|)
argument_list|,
name|CLASS_CLS_METHODS
argument_list|(
name|implementation_context
argument_list|)
argument_list|,
literal|'+'
argument_list|)
expr_stmt|;
name|check_methods
argument_list|(
name|CLASS_NST_METHODS
argument_list|(
name|implementation_template
argument_list|)
argument_list|,
name|CLASS_NST_METHODS
argument_list|(
name|implementation_context
argument_list|)
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASS_PROTOCOL_LIST
argument_list|(
name|implementation_template
argument_list|)
condition|)
name|check_protocols
argument_list|(
name|CLASS_PROTOCOL_LIST
argument_list|(
name|implementation_template
argument_list|)
argument_list|,
literal|"class"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_NAME
argument_list|(
name|implementation_context
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|class
argument_list|)
operator|==
name|CATEGORY_IMPLEMENTATION_TYPE
condition|)
block|{
name|tree
name|category
init|=
name|CLASS_CATEGORY_LIST
argument_list|(
name|implementation_template
argument_list|)
decl_stmt|;
comment|/* Find the category interface from the class it is associated with. */
while|while
condition|(
name|category
condition|)
block|{
if|if
condition|(
name|CLASS_SUPER_NAME
argument_list|(
name|class
argument_list|)
operator|==
name|CLASS_SUPER_NAME
argument_list|(
name|category
argument_list|)
condition|)
break|break;
name|category
operator|=
name|CLASS_CATEGORY_LIST
argument_list|(
name|category
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|category
condition|)
block|{
comment|/* Ensure all method listed in the interface contain bodies. */
name|check_methods
argument_list|(
name|CLASS_CLS_METHODS
argument_list|(
name|category
argument_list|)
argument_list|,
name|CLASS_CLS_METHODS
argument_list|(
name|implementation_context
argument_list|)
argument_list|,
literal|'+'
argument_list|)
expr_stmt|;
name|check_methods
argument_list|(
name|CLASS_NST_METHODS
argument_list|(
name|category
argument_list|)
argument_list|,
name|CLASS_NST_METHODS
argument_list|(
name|implementation_context
argument_list|)
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASS_PROTOCOL_LIST
argument_list|(
name|category
argument_list|)
condition|)
name|check_protocols
argument_list|(
name|CLASS_PROTOCOL_LIST
argument_list|(
name|category
argument_list|)
argument_list|,
literal|"category"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_SUPER_NAME
argument_list|(
name|implementation_context
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|class
argument_list|)
operator|==
name|CLASS_INTERFACE_TYPE
condition|)
block|{
name|tree
name|decl_specs
decl_stmt|;
name|char
modifier|*
name|class_name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_NAME
argument_list|(
name|class
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|string
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|class_name
argument_list|)
operator|+
literal|3
argument_list|)
decl_stmt|;
comment|/* extern struct objc_object *_<my_name>; */
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"_%s"
argument_list|,
name|class_name
argument_list|)
expr_stmt|;
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_EXTERN
index|]
argument_list|)
expr_stmt|;
name|decl_specs
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|objc_object_reference
argument_list|,
name|decl_specs
argument_list|)
expr_stmt|;
name|define_decl
argument_list|(
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
name|string
argument_list|)
argument_list|)
argument_list|,
name|decl_specs
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|tree
name|add_protocol
parameter_list|(
name|protocol
parameter_list|)
name|tree
name|protocol
decl_stmt|;
block|{
comment|/* Put protocol on list in reverse order. */
name|TREE_CHAIN
argument_list|(
name|protocol
argument_list|)
operator|=
name|protocol_chain
expr_stmt|;
name|protocol_chain
operator|=
name|protocol
expr_stmt|;
return|return
name|protocol_chain
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|lookup_protocol
parameter_list|(
name|ident
parameter_list|)
name|tree
name|ident
decl_stmt|;
block|{
name|tree
name|chain
decl_stmt|;
for|for
control|(
name|chain
operator|=
name|protocol_chain
init|;
name|chain
condition|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
control|)
block|{
if|if
condition|(
name|ident
operator|==
name|PROTOCOL_NAME
argument_list|(
name|chain
argument_list|)
condition|)
return|return
name|chain
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_function
name|tree
name|start_protocol
parameter_list|(
name|code
parameter_list|,
name|name
parameter_list|,
name|list
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|list
decl_stmt|;
block|{
name|tree
name|protocol
decl_stmt|;
if|if
condition|(
operator|!
name|doing_objc_thang
condition|)
name|objc_fatal
argument_list|()
expr_stmt|;
comment|/* This is as good a place as any.  Need to invoke push_tag_toplevel.  */
if|if
condition|(
operator|!
name|objc_protocol_template
condition|)
name|objc_protocol_template
operator|=
name|build_protocol_template
argument_list|()
expr_stmt|;
name|protocol
operator|=
name|make_node
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|TYPE_BINFO
argument_list|(
name|protocol
argument_list|)
operator|=
name|make_tree_vec
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|PROTOCOL_NAME
argument_list|(
name|protocol
argument_list|)
operator|=
name|name
expr_stmt|;
name|PROTOCOL_LIST
argument_list|(
name|protocol
argument_list|)
operator|=
name|list
expr_stmt|;
name|lookup_and_install_protocols
argument_list|(
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|lookup_protocol
argument_list|(
name|name
argument_list|)
condition|)
name|warning
argument_list|(
literal|"duplicate declaration for protocol `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|add_protocol
argument_list|(
name|protocol
argument_list|)
expr_stmt|;
name|PROTOCOL_FORWARD_DECL
argument_list|(
name|protocol
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
return|return
name|protocol
return|;
block|}
end_function

begin_function
name|void
name|finish_protocol
parameter_list|(
name|protocol
parameter_list|)
name|tree
name|protocol
decl_stmt|;
block|{ }
end_function

begin_escape
end_escape

begin_comment
comment|/* "Encode" a data type into a string, which grows in util_obstack.    ??? What is the FORMAT?  Someone please document this!  */
end_comment

begin_function
specifier|static
name|void
name|encode_type_qualifiers
parameter_list|(
name|declspecs
parameter_list|)
name|tree
name|declspecs
decl_stmt|;
block|{
name|tree
name|spec
decl_stmt|;
for|for
control|(
name|spec
operator|=
name|declspecs
init|;
name|spec
condition|;
name|spec
operator|=
name|TREE_CHAIN
argument_list|(
name|spec
argument_list|)
control|)
block|{
if|if
condition|(
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CONST
index|]
operator|==
name|TREE_VALUE
argument_list|(
name|spec
argument_list|)
condition|)
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'r'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_IN
index|]
operator|==
name|TREE_VALUE
argument_list|(
name|spec
argument_list|)
condition|)
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'n'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_INOUT
index|]
operator|==
name|TREE_VALUE
argument_list|(
name|spec
argument_list|)
condition|)
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'N'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_OUT
index|]
operator|==
name|TREE_VALUE
argument_list|(
name|spec
argument_list|)
condition|)
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'o'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_BYCOPY
index|]
operator|==
name|TREE_VALUE
argument_list|(
name|spec
argument_list|)
condition|)
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'O'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_ONEWAY
index|]
operator|==
name|TREE_VALUE
argument_list|(
name|spec
argument_list|)
condition|)
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'V'
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Encode a pointer type.  */
end_comment

begin_function
specifier|static
name|void
name|encode_pointer
parameter_list|(
name|type
parameter_list|,
name|curtype
parameter_list|,
name|format
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|curtype
decl_stmt|;
name|int
name|format
decl_stmt|;
block|{
name|tree
name|pointer_to
init|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|pointer_to
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|pointer_to
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|pointer_to
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
name|char
modifier|*
name|name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|TYPE_NAME
argument_list|(
name|pointer_to
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|TAG_OBJECT
argument_list|)
operator|==
literal|0
condition|)
comment|/* '@' */
block|{
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|TREE_STATIC_TEMPLATE
argument_list|(
name|pointer_to
argument_list|)
condition|)
block|{
if|if
condition|(
name|generating_instance_variables
condition|)
block|{
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'"'
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'"'
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|TAG_CLASS
argument_list|)
operator|==
literal|0
condition|)
comment|/* '#' */
block|{
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'#'
argument_list|)
expr_stmt|;
return|return;
block|}
ifndef|#
directive|ifndef
name|OBJC_INT_SELECTORS
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|TAG_SELECTOR
argument_list|)
operator|==
literal|0
condition|)
comment|/* ':' */
block|{
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* OBJC_INT_SELECTORS */
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|pointer_to
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_MODE
argument_list|(
name|pointer_to
argument_list|)
operator|==
name|QImode
condition|)
block|{
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'*'
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* We have a type that does not get special treatment.  */
comment|/* NeXT extension */
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'^'
argument_list|)
expr_stmt|;
name|encode_type
argument_list|(
name|pointer_to
argument_list|,
name|curtype
argument_list|,
name|format
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|encode_array
parameter_list|(
name|type
parameter_list|,
name|curtype
parameter_list|,
name|format
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|curtype
decl_stmt|;
name|int
name|format
decl_stmt|;
block|{
name|tree
name|an_int_cst
init|=
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|array_of
init|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|char
name|buffer
index|[
literal|40
index|]
decl_stmt|;
comment|/* An incomplete array is treated like a pointer.  */
if|if
condition|(
name|an_int_cst
operator|==
name|NULL
condition|)
block|{
name|encode_pointer
argument_list|(
name|type
argument_list|,
name|curtype
argument_list|,
name|format
argument_list|)
expr_stmt|;
return|return;
block|}
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"[%d"
argument_list|,
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|an_int_cst
argument_list|)
operator|/
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|array_of
argument_list|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
name|buffer
argument_list|,
name|strlen
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|encode_type
argument_list|(
name|array_of
argument_list|,
name|curtype
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|']'
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|encode_aggregate
parameter_list|(
name|type
parameter_list|,
name|curtype
parameter_list|,
name|format
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|curtype
decl_stmt|;
name|int
name|format
decl_stmt|;
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|RECORD_TYPE
case|:
block|{
if|if
condition|(
name|obstack_object_size
argument_list|(
operator|&
name|util_obstack
argument_list|)
operator|>
literal|0
operator|&&
operator|*
operator|(
name|obstack_next_free
argument_list|(
operator|&
name|util_obstack
argument_list|)
operator|-
literal|1
operator|)
operator|==
literal|'^'
condition|)
block|{
name|tree
name|name
init|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* We have a reference; this is a NeXT extension. */
if|if
condition|(
name|obstack_object_size
argument_list|(
operator|&
name|util_obstack
argument_list|)
operator|-
name|curtype
operator|==
literal|1
operator|&&
name|format
operator|==
name|OBJC_ENCODE_INLINE_DEFS
condition|)
block|{
comment|/* Output format of struct for first level only. */
name|tree
name|fields
init|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
operator|&&
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'{'
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
block|}
else|else
name|obstack_grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|"{?="
argument_list|,
literal|3
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|fields
condition|;
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
control|)
name|encode_field_decl
argument_list|(
name|fields
argument_list|,
name|curtype
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'}'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|&&
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'{'
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'}'
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* We have an untagged structure or a typedef. */
name|obstack_grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|"{?}"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|name
init|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|fields
init|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|format
operator|==
name|OBJC_ENCODE_INLINE_DEFS
operator|||
name|generating_instance_variables
condition|)
block|{
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'{'
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|&&
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|obstack_grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'?'
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|fields
condition|;
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
control|)
block|{
if|if
condition|(
name|generating_instance_variables
condition|)
block|{
name|tree
name|fname
init|=
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
decl_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'"'
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
operator|&&
name|TREE_CODE
argument_list|(
name|fname
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
name|obstack_grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|fname
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|fname
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'"'
argument_list|)
expr_stmt|;
block|}
name|encode_field_decl
argument_list|(
name|fields
argument_list|,
name|curtype
argument_list|,
name|format
argument_list|)
expr_stmt|;
block|}
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'}'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'{'
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|&&
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|obstack_grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* We have an untagged structure or a typedef. */
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'?'
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'}'
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|UNION_TYPE
case|:
block|{
if|if
condition|(
operator|*
name|obstack_next_free
argument_list|(
operator|&
name|util_obstack
argument_list|)
operator|==
literal|'^'
operator|||
name|format
operator|!=
name|OBJC_ENCODE_INLINE_DEFS
condition|)
block|{
comment|/* We have a reference (this is a NeXT extension) 	       or we don't want the details.  */
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* We have an untagged structure or a typedef. */
name|obstack_grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|"(?)"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|fields
init|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|fields
condition|;
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
control|)
name|encode_field_decl
argument_list|(
name|fields
argument_list|,
name|curtype
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|ENUMERAL_TYPE
case|:
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'i'
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Support bitfields.  The current version of Objective-C does not support    them.  The string will consist of one or more "b:n"'s where n is an    integer describing the width of the bitfield. Currently, classes in    the kit implement a method "-(char *)describeBitfieldStruct:" that    simulates this. If they do not implement this method, the archiver    assumes the bitfield is 16 bits wide (padded if necessary) and packed    according to the GNU compiler. After looking at the "kit", it appears    that all classes currently rely on this default behavior, rather than    hand generating this string (which is tedious).  */
end_comment

begin_function
specifier|static
name|void
name|encode_bitfield
parameter_list|(
name|width
parameter_list|,
name|format
parameter_list|)
name|int
name|width
decl_stmt|;
name|int
name|format
decl_stmt|;
block|{
name|char
name|buffer
index|[
literal|40
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"b%d"
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
name|buffer
argument_list|,
name|strlen
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* FORMAT will be OBJC_ENCODE_INLINE_DEFS or OBJC_ENCODE_DONT_INLINE_DEFS.  */
end_comment

begin_function
specifier|static
name|void
name|encode_type
parameter_list|(
name|type
parameter_list|,
name|curtype
parameter_list|,
name|format
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|curtype
decl_stmt|;
name|int
name|format
decl_stmt|;
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|INTEGER_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Unsigned integer types. */
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|QImode
condition|)
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'C'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|HImode
condition|)
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'S'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|SImode
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|long_unsigned_type_node
condition|)
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'L'
argument_list|)
expr_stmt|;
else|else
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'I'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|DImode
condition|)
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'Q'
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Signed integer types. */
block|{
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|QImode
condition|)
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'c'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|HImode
condition|)
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'s'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|SImode
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|long_integer_type_node
condition|)
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'l'
argument_list|)
expr_stmt|;
else|else
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'i'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|DImode
condition|)
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'q'
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|REAL_TYPE
condition|)
block|{
comment|/* Floating point types. */
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|SFmode
condition|)
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'f'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|DFmode
operator|||
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|TFmode
condition|)
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'d'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|VOID_TYPE
condition|)
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'v'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|ARRAY_TYPE
condition|)
name|encode_array
argument_list|(
name|type
argument_list|,
name|curtype
argument_list|,
name|format
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|POINTER_TYPE
condition|)
name|encode_pointer
argument_list|(
name|type
argument_list|,
name|curtype
argument_list|,
name|format
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|RECORD_TYPE
operator|||
name|code
operator|==
name|UNION_TYPE
operator|||
name|code
operator|==
name|ENUMERAL_TYPE
condition|)
name|encode_aggregate
argument_list|(
name|type
argument_list|,
name|curtype
argument_list|,
name|format
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|FUNCTION_TYPE
condition|)
comment|/* '?' */
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'?'
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|encode_field_decl
parameter_list|(
name|field_decl
parameter_list|,
name|curtype
parameter_list|,
name|format
parameter_list|)
name|tree
name|field_decl
decl_stmt|;
name|int
name|curtype
decl_stmt|;
name|int
name|format
decl_stmt|;
block|{
name|tree
name|type
decl_stmt|;
comment|/* If this field is obviously a bitfield, or is a bitfield that has been      clobbered to look like a ordinary integer mode, go ahead and generate      the bitfield typing information. */
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|field_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_BIT_FIELD
argument_list|(
name|field_decl
argument_list|)
condition|)
name|encode_bitfield
argument_list|(
name|DECL_FIELD_SIZE
argument_list|(
name|field_decl
argument_list|)
argument_list|,
name|format
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|DECL_FIELD_SIZE
argument_list|(
name|field_decl
argument_list|)
operator|&&
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|>
name|DECL_MODE
argument_list|(
name|field_decl
argument_list|)
condition|)
name|encode_bitfield
argument_list|(
name|DECL_FIELD_SIZE
argument_list|(
name|field_decl
argument_list|)
argument_list|,
name|format
argument_list|)
expr_stmt|;
else|else
name|encode_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|field_decl
argument_list|)
argument_list|,
name|curtype
argument_list|,
name|format
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|tree
name|expr_last
parameter_list|(
name|complex_expr
parameter_list|)
name|tree
name|complex_expr
decl_stmt|;
block|{
name|tree
name|next
decl_stmt|;
if|if
condition|(
name|complex_expr
condition|)
while|while
condition|(
operator|(
name|next
operator|=
name|TREE_OPERAND
argument_list|(
name|complex_expr
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
name|complex_expr
operator|=
name|next
expr_stmt|;
return|return
name|complex_expr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The selector of the current method,    or NULL if we aren't compiling a method.  */
end_comment

begin_function
name|tree
name|maybe_objc_method_name
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
name|method_context
condition|)
return|return
name|METHOD_SEL_NAME
argument_list|(
name|method_context
argument_list|)
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Transform a method definition into a function definition as follows:    - synthesize the first two arguments, "self" and "_cmd".  */
end_comment

begin_function
name|void
name|start_method_def
parameter_list|(
name|method
parameter_list|)
name|tree
name|method
decl_stmt|;
block|{
name|tree
name|decl_specs
decl_stmt|;
comment|/* Required to implement _msgSuper.  */
name|method_context
operator|=
name|method
expr_stmt|;
name|UOBJC_SUPER_decl
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Must be called BEFORE start_function.  */
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Generate prototype declarations for arguments..."new-style".  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|method_context
argument_list|)
operator|==
name|INSTANCE_METHOD_DECL
condition|)
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|uprivate_record
argument_list|)
expr_stmt|;
else|else
comment|/* Really a `struct objc_class *'. However, we allow people to        assign to self, which changes its type midstream.  */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|objc_object_reference
argument_list|)
expr_stmt|;
name|push_parm_decl
argument_list|(
name|build_tree_list
argument_list|(
name|build_tree_list
argument_list|(
name|decl_specs
argument_list|,
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|self_id
argument_list|)
argument_list|)
argument_list|,
name|build_tree_list
argument_list|(
name|unused_list
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJC_INT_SELECTORS
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_UNSIGNED
index|]
argument_list|)
expr_stmt|;
name|decl_specs
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_INT
index|]
argument_list|,
name|decl_specs
argument_list|)
expr_stmt|;
name|push_parm_decl
argument_list|(
name|build_tree_list
argument_list|(
name|build_tree_list
argument_list|(
name|decl_specs
argument_list|,
name|ucmd_id
argument_list|)
argument_list|,
name|build_tree_list
argument_list|(
name|unused_list
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not OBJC_INT_SELECTORS */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|TAG_SELECTOR
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|push_parm_decl
argument_list|(
name|build_tree_list
argument_list|(
name|build_tree_list
argument_list|(
name|decl_specs
argument_list|,
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|ucmd_id
argument_list|)
argument_list|)
argument_list|,
name|build_tree_list
argument_list|(
name|unused_list
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not OBJC_INT_SELECTORS */
comment|/* Generate argument declarations if a keyword_decl. */
if|if
condition|(
name|METHOD_SEL_ARGS
argument_list|(
name|method
argument_list|)
condition|)
block|{
name|tree
name|arglist
init|=
name|METHOD_SEL_ARGS
argument_list|(
name|method
argument_list|)
decl_stmt|;
do|do
block|{
name|tree
name|arg_spec
init|=
name|TREE_PURPOSE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arg_decl
init|=
name|TREE_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|arg_decl
condition|)
block|{
name|tree
name|last_expr
init|=
name|expr_last
argument_list|(
name|arg_decl
argument_list|)
decl_stmt|;
comment|/* Unite the abstract decl with its name. */
name|TREE_OPERAND
argument_list|(
name|last_expr
argument_list|,
literal|0
argument_list|)
operator|=
name|KEYWORD_ARG_NAME
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|push_parm_decl
argument_list|(
name|build_tree_list
argument_list|(
name|build_tree_list
argument_list|(
name|arg_spec
argument_list|,
name|arg_decl
argument_list|)
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Unhook: restore the abstract declarator. */
name|TREE_OPERAND
argument_list|(
name|last_expr
argument_list|,
literal|0
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
name|push_parm_decl
argument_list|(
name|build_tree_list
argument_list|(
name|build_tree_list
argument_list|(
name|arg_spec
argument_list|,
name|KEYWORD_ARG_NAME
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|arglist
condition|)
do|;
block|}
if|if
condition|(
name|METHOD_ADD_ARGS
argument_list|(
name|method
argument_list|)
operator|>
operator|(
name|tree
operator|)
literal|1
condition|)
block|{
comment|/* We have a variable length selector - in "prototype" format. */
name|tree
name|akey
init|=
name|TREE_PURPOSE
argument_list|(
name|METHOD_ADD_ARGS
argument_list|(
name|method
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|akey
condition|)
block|{
comment|/* This must be done prior to calling pushdecl.  pushdecl is 	     going to change our chain on us.  */
name|tree
name|nextkey
init|=
name|TREE_CHAIN
argument_list|(
name|akey
argument_list|)
decl_stmt|;
name|pushdecl
argument_list|(
name|akey
argument_list|)
expr_stmt|;
name|akey
operator|=
name|nextkey
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|warn_with_method
parameter_list|(
name|message
parameter_list|,
name|mtype
parameter_list|,
name|method
parameter_list|)
name|char
modifier|*
name|message
decl_stmt|;
name|int
name|mtype
decl_stmt|;
name|tree
name|method
decl_stmt|;
block|{
if|if
condition|(
name|count_error
argument_list|(
literal|1
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|report_error_function
argument_list|(
name|DECL_SOURCE_FILE
argument_list|(
name|method
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: warning: "
argument_list|,
name|DECL_SOURCE_FILE
argument_list|(
name|method
argument_list|)
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|method
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|errbuf
argument_list|,
name|BUFSIZE
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s `%c%s'\n"
argument_list|,
name|message
argument_list|,
name|mtype
argument_list|,
name|gen_method_decl
argument_list|(
name|method
argument_list|,
name|errbuf
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return 1 if METHOD is consistent with PROTO. */
end_comment

begin_function
specifier|static
name|int
name|comp_method_with_proto
parameter_list|(
name|method
parameter_list|,
name|proto
parameter_list|)
name|tree
name|method
decl_stmt|,
name|proto
decl_stmt|;
block|{
specifier|static
name|tree
name|function_type
init|=
literal|0
decl_stmt|;
comment|/* Create a function_type node once. */
if|if
condition|(
operator|!
name|function_type
condition|)
block|{
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|end_temporary_allocation
argument_list|()
expr_stmt|;
name|function_type
operator|=
name|make_node
argument_list|(
name|FUNCTION_TYPE
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
comment|/* Install argument types - normally set by build_function_type.  */
name|TYPE_ARG_TYPES
argument_list|(
name|function_type
argument_list|)
operator|=
name|get_arg_type_list
argument_list|(
name|proto
argument_list|,
name|METHOD_DEF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* install return type */
name|TREE_TYPE
argument_list|(
name|function_type
argument_list|)
operator|=
name|groktypename
argument_list|(
name|TREE_TYPE
argument_list|(
name|proto
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|METHOD_DEFINITION
argument_list|(
name|method
argument_list|)
argument_list|)
argument_list|,
name|function_type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if PROTO1 is consistent with PROTO2. */
end_comment

begin_function
specifier|static
name|int
name|comp_proto_with_proto
parameter_list|(
name|proto1
parameter_list|,
name|proto2
parameter_list|)
name|tree
name|proto1
decl_stmt|,
name|proto2
decl_stmt|;
block|{
specifier|static
name|tree
name|function_type1
init|=
literal|0
decl_stmt|,
name|function_type2
init|=
literal|0
decl_stmt|;
comment|/* Create a couple function_type node's once. */
if|if
condition|(
operator|!
name|function_type1
condition|)
block|{
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|end_temporary_allocation
argument_list|()
expr_stmt|;
name|function_type1
operator|=
name|make_node
argument_list|(
name|FUNCTION_TYPE
argument_list|)
expr_stmt|;
name|function_type2
operator|=
name|make_node
argument_list|(
name|FUNCTION_TYPE
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
comment|/* Install argument types; normally set by build_function_type.  */
name|TYPE_ARG_TYPES
argument_list|(
name|function_type1
argument_list|)
operator|=
name|get_arg_type_list
argument_list|(
name|proto1
argument_list|,
name|METHOD_REF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TYPE_ARG_TYPES
argument_list|(
name|function_type2
argument_list|)
operator|=
name|get_arg_type_list
argument_list|(
name|proto2
argument_list|,
name|METHOD_REF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Install return type. */
name|TREE_TYPE
argument_list|(
name|function_type1
argument_list|)
operator|=
name|groktypename
argument_list|(
name|TREE_TYPE
argument_list|(
name|proto1
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|function_type2
argument_list|)
operator|=
name|groktypename
argument_list|(
name|TREE_TYPE
argument_list|(
name|proto2
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|comptypes
argument_list|(
name|function_type1
argument_list|,
name|function_type2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* - Generate an identifier for the function. the format is "_n_cls",      where 1<= n<= nMethods, and cls is the name the implementation we      are processing.    - Install the return type from the method declaration.    - If we have a prototype, check for type consistency.  */
end_comment

begin_function
specifier|static
name|void
name|really_start_method
parameter_list|(
name|method
parameter_list|,
name|parmlist
parameter_list|)
name|tree
name|method
decl_stmt|,
name|parmlist
decl_stmt|;
block|{
name|tree
name|sc_spec
decl_stmt|,
name|ret_spec
decl_stmt|,
name|ret_decl
decl_stmt|,
name|decl_specs
decl_stmt|;
name|tree
name|method_decl
decl_stmt|,
name|method_id
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|sel_name
decl_stmt|,
modifier|*
name|class_name
decl_stmt|,
modifier|*
name|cat_name
decl_stmt|;
comment|/* Synth the storage class& assemble the return type. */
name|sc_spec
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_STATIC
index|]
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|ret_spec
operator|=
name|TREE_PURPOSE
argument_list|(
name|TREE_TYPE
argument_list|(
name|method
argument_list|)
argument_list|)
expr_stmt|;
name|decl_specs
operator|=
name|chainon
argument_list|(
name|sc_spec
argument_list|,
name|ret_spec
argument_list|)
expr_stmt|;
name|sel_name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|METHOD_SEL_NAME
argument_list|(
name|method
argument_list|)
argument_list|)
expr_stmt|;
name|class_name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_NAME
argument_list|(
name|implementation_context
argument_list|)
argument_list|)
expr_stmt|;
name|cat_name
operator|=
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|implementation_context
argument_list|)
operator|==
name|CLASS_IMPLEMENTATION_TYPE
operator|)
condition|?
name|NULL
else|:
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_SUPER_NAME
argument_list|(
name|implementation_context
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|method_slot
operator|++
expr_stmt|;
comment|/* Make sure this is big enough for any plausible method label.  */
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|50
operator|+
name|strlen
argument_list|(
name|sel_name
argument_list|)
operator|+
name|strlen
argument_list|(
name|class_name
argument_list|)
operator|+
operator|(
name|cat_name
condition|?
name|strlen
argument_list|(
name|cat_name
argument_list|)
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|OBJC_GEN_METHOD_LABEL
argument_list|(
name|buf
argument_list|,
name|TREE_CODE
argument_list|(
name|method
argument_list|)
operator|==
name|INSTANCE_METHOD_DECL
argument_list|,
name|class_name
argument_list|,
name|cat_name
argument_list|,
name|sel_name
argument_list|,
name|method_slot
argument_list|)
expr_stmt|;
name|method_id
operator|=
name|get_identifier
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|method_decl
operator|=
name|build_nt
argument_list|(
name|CALL_EXPR
argument_list|,
name|method_id
argument_list|,
name|parmlist
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* Check the declarator portion of the return type for the method. */
if|if
condition|(
operator|(
name|ret_decl
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|method
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/* Unite the complex decl (specified in the abstract decl) with the 	 function decl just synthesized..(int *), (int (*)()), (int (*)[]).  */
name|tree
name|save_expr
init|=
name|expr_last
argument_list|(
name|ret_decl
argument_list|)
decl_stmt|;
name|TREE_OPERAND
argument_list|(
name|save_expr
argument_list|,
literal|0
argument_list|)
operator|=
name|method_decl
expr_stmt|;
name|method_decl
operator|=
name|ret_decl
expr_stmt|;
comment|/* Fool the parser into thinking it is starting a function. */
name|start_function
argument_list|(
name|decl_specs
argument_list|,
name|method_decl
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Unhook: this has the effect of restoring the abstract declarator. */
name|TREE_OPERAND
argument_list|(
name|save_expr
argument_list|,
literal|0
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
block|{
name|TREE_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|method
argument_list|)
argument_list|)
operator|=
name|method_decl
expr_stmt|;
comment|/* Fool the parser into thinking it is starting a function. */
name|start_function
argument_list|(
name|decl_specs
argument_list|,
name|method_decl
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Unhook: this has the effect of restoring the abstract declarator. */
name|TREE_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|method
argument_list|)
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|METHOD_DEFINITION
argument_list|(
name|method
argument_list|)
operator|=
name|current_function_decl
expr_stmt|;
if|if
condition|(
name|implementation_template
operator|!=
name|implementation_context
condition|)
block|{
name|tree
name|proto
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|method
argument_list|)
operator|==
name|INSTANCE_METHOD_DECL
condition|)
name|proto
operator|=
name|lookup_instance_method_static
argument_list|(
name|implementation_template
argument_list|,
name|METHOD_SEL_NAME
argument_list|(
name|method
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|proto
operator|=
name|lookup_class_method_static
argument_list|(
name|implementation_template
argument_list|,
name|METHOD_SEL_NAME
argument_list|(
name|method
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|proto
operator|&&
operator|!
name|comp_method_with_proto
argument_list|(
name|method
argument_list|,
name|proto
argument_list|)
condition|)
block|{
name|char
name|type
init|=
operator|(
name|TREE_CODE
argument_list|(
name|method
argument_list|)
operator|==
name|INSTANCE_METHOD_DECL
condition|?
literal|'-'
else|:
literal|'+'
operator|)
decl_stmt|;
name|warn_with_method
argument_list|(
literal|"conflicting types for"
argument_list|,
name|type
argument_list|,
name|method
argument_list|)
expr_stmt|;
name|warn_with_method
argument_list|(
literal|"previous declaration of"
argument_list|,
name|type
argument_list|,
name|proto
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* The following routine is always called...this "architecture" is to    accommodate "old-style" variable length selectors.      - a:a b:b // prototype  ; id c; id d; // old-style.  */
end_comment

begin_function
name|void
name|continue_method_def
parameter_list|()
block|{
name|tree
name|parmlist
decl_stmt|;
if|if
condition|(
name|METHOD_ADD_ARGS
argument_list|(
name|method_context
argument_list|)
operator|==
operator|(
name|tree
operator|)
literal|1
condition|)
comment|/* We have a `, ...' immediately following the selector.  */
name|parmlist
operator|=
name|get_parm_info
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|else
name|parmlist
operator|=
name|get_parm_info
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* place a `void_at_end' */
comment|/* Set self_decl from the first argument...this global is used by      build_ivar_reference calling build_indirect_ref.  */
name|self_decl
operator|=
name|TREE_PURPOSE
argument_list|(
name|parmlist
argument_list|)
expr_stmt|;
name|poplevel
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|really_start_method
argument_list|(
name|method_context
argument_list|,
name|parmlist
argument_list|)
expr_stmt|;
name|store_parm_decls
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called by the parser, from the `pushlevel' production.  */
end_comment

begin_function
name|void
name|add_objc_decls
parameter_list|()
block|{
if|if
condition|(
operator|!
name|UOBJC_SUPER_decl
condition|)
block|{
name|UOBJC_SUPER_decl
operator|=
name|start_decl
argument_list|(
name|get_identifier
argument_list|(
name|UTAG_SUPER
argument_list|)
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|objc_super_template
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|UOBJC_SUPER_decl
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* This prevents `unused variable' warnings when compiling with -Wall. */
name|TREE_USED
argument_list|(
name|UOBJC_SUPER_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|UOBJC_SUPER_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* _n_Method (id self, SEL sel, ...)      {        struct objc_super _S;        _msgSuper ((_S.self = self, _S.class = _cls,&_S), ...);      }  */
end_comment

begin_function
name|tree
name|get_super_receiver
parameter_list|()
block|{
if|if
condition|(
name|method_context
condition|)
block|{
name|tree
name|super_expr
decl_stmt|,
name|super_expr_list
decl_stmt|;
comment|/* Set receiver to self. */
name|super_expr
operator|=
name|build_component_ref
argument_list|(
name|UOBJC_SUPER_decl
argument_list|,
name|self_id
argument_list|)
expr_stmt|;
name|super_expr
operator|=
name|build_modify_expr
argument_list|(
name|super_expr
argument_list|,
name|NOP_EXPR
argument_list|,
name|self_decl
argument_list|)
expr_stmt|;
name|super_expr_list
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|super_expr
argument_list|)
expr_stmt|;
comment|/* Set class to begin searching. */
name|super_expr
operator|=
name|build_component_ref
argument_list|(
name|UOBJC_SUPER_decl
argument_list|,
name|get_identifier
argument_list|(
literal|"class"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|implementation_context
argument_list|)
operator|==
name|CLASS_IMPLEMENTATION_TYPE
condition|)
block|{
comment|/* [_cls, __cls]Super are "pre-built" in 	     synth_forward_declarations.  */
name|super_expr
operator|=
name|build_modify_expr
argument_list|(
name|super_expr
argument_list|,
name|NOP_EXPR
argument_list|,
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|method_context
argument_list|)
operator|==
name|INSTANCE_METHOD_DECL
operator|)
condition|?
name|ucls_super_ref
else|:
name|uucls_super_ref
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* We have a category. */
block|{
name|tree
name|super_name
init|=
name|CLASS_SUPER_NAME
argument_list|(
name|implementation_template
argument_list|)
decl_stmt|;
name|tree
name|super_class
decl_stmt|;
if|if
condition|(
operator|!
name|super_name
condition|)
block|{
name|error
argument_list|(
literal|"no super class declared in interface for `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_NAME
argument_list|(
name|implementation_template
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|flag_next_runtime
condition|)
block|{
name|super_class
operator|=
name|get_class_reference
argument_list|(
name|super_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|method_context
argument_list|)
operator|==
name|CLASS_METHOD_DECL
condition|)
name|super_class
operator|=
name|build_component_ref
argument_list|(
name|build_indirect_ref
argument_list|(
name|super_class
argument_list|,
literal|"->"
argument_list|)
argument_list|,
name|get_identifier
argument_list|(
literal|"isa"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|add_class_reference
argument_list|(
name|super_name
argument_list|)
expr_stmt|;
name|super_class
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|method_context
argument_list|)
operator|==
name|INSTANCE_METHOD_DECL
condition|?
name|objc_get_class_decl
else|:
name|objc_get_meta_class_decl
operator|)
expr_stmt|;
name|assemble_external
argument_list|(
name|super_class
argument_list|)
expr_stmt|;
name|super_class
operator|=
name|build_function_call
argument_list|(
name|super_class
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|my_build_string
argument_list|(
name|IDENTIFIER_LENGTH
argument_list|(
name|super_name
argument_list|)
operator|+
literal|1
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|super_name
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|TREE_TYPE
argument_list|(
name|super_class
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|ucls_super_ref
argument_list|)
expr_stmt|;
name|super_expr
operator|=
name|build_modify_expr
argument_list|(
name|super_expr
argument_list|,
name|NOP_EXPR
argument_list|,
name|super_class
argument_list|)
expr_stmt|;
block|}
name|chainon
argument_list|(
name|super_expr_list
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|super_expr
argument_list|)
argument_list|)
expr_stmt|;
name|super_expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|UOBJC_SUPER_decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|super_expr_list
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|super_expr
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build_compound_expr
argument_list|(
name|super_expr_list
argument_list|)
return|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"[super ...] must appear in a method context"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|tree
name|encode_method_def
parameter_list|(
name|func_decl
parameter_list|)
name|tree
name|func_decl
decl_stmt|;
block|{
name|tree
name|parms
decl_stmt|;
name|int
name|stack_size
decl_stmt|;
name|int
name|max_parm_end
init|=
literal|0
decl_stmt|;
name|char
name|buffer
index|[
literal|40
index|]
decl_stmt|;
name|tree
name|result
decl_stmt|;
comment|/* Return type. */
name|encode_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|func_decl
argument_list|)
argument_list|)
argument_list|,
name|obstack_object_size
argument_list|(
operator|&
name|util_obstack
argument_list|)
argument_list|,
name|OBJC_ENCODE_INLINE_DEFS
argument_list|)
expr_stmt|;
comment|/* Stack size. */
for|for
control|(
name|parms
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|func_decl
argument_list|)
init|;
name|parms
condition|;
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
control|)
block|{
name|int
name|parm_end
init|=
operator|(
name|forwarding_offset
argument_list|(
name|parms
argument_list|)
operator|+
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|offset_is_register
operator|&&
name|parm_end
operator|>
name|max_parm_end
condition|)
name|max_parm_end
operator|=
name|parm_end
expr_stmt|;
block|}
name|stack_size
operator|=
name|max_parm_end
operator|-
name|OBJC_FORWARDING_MIN_OFFSET
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%d"
argument_list|,
name|stack_size
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
name|buffer
argument_list|,
name|strlen
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Argument types. */
for|for
control|(
name|parms
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|func_decl
argument_list|)
init|;
name|parms
condition|;
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
control|)
block|{
comment|/* Type. */
name|encode_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
argument_list|,
name|obstack_object_size
argument_list|(
operator|&
name|util_obstack
argument_list|)
argument_list|,
name|OBJC_ENCODE_INLINE_DEFS
argument_list|)
expr_stmt|;
comment|/* Compute offset. */
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%d"
argument_list|,
name|forwarding_offset
argument_list|(
name|parms
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Indicate register. */
if|if
condition|(
name|offset_is_register
condition|)
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'+'
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
name|buffer
argument_list|,
name|strlen
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|result
operator|=
name|get_identifier
argument_list|(
name|obstack_finish
argument_list|(
operator|&
name|util_obstack
argument_list|)
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|util_obstack
argument_list|,
name|util_firstobj
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|void
name|finish_method_def
parameter_list|()
block|{
name|METHOD_ENCODING
argument_list|(
name|method_context
argument_list|)
operator|=
name|encode_method_def
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
name|finish_function
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Required to implement _msgSuper. This must be done AFTER finish_function,      since the optimizer may find "may be used before set" errors.  */
name|method_context
operator|=
name|NULL_TREE
expr_stmt|;
block|}
end_function

begin_function
name|int
name|lang_report_error_function
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
name|method_context
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"In method `%s'\n"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|METHOD_SEL_NAME
argument_list|(
name|method_context
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_complex_decl
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
return|return
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
operator|!
name|IS_ID
argument_list|(
name|type
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Code to convert a decl node into text for a declaration in C.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|tmpbuf
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|adorn_decl
parameter_list|(
name|decl
parameter_list|,
name|str
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|ARRAY_REF
condition|)
block|{
name|tree
name|an_int_cst
init|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|an_int_cst
operator|&&
name|TREE_CODE
argument_list|(
name|an_int_cst
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|sprintf
argument_list|(
name|str
operator|+
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|,
literal|"[%d]"
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|an_int_cst
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|strcat
argument_list|(
name|str
argument_list|,
literal|"[]"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|tree
name|an_int_cst
init|=
name|TYPE_SIZE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|tree
name|array_of
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|an_int_cst
operator|&&
name|TREE_CODE
argument_list|(
name|an_int_cst
argument_list|)
operator|==
name|INTEGER_TYPE
condition|)
name|sprintf
argument_list|(
name|str
operator|+
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|,
literal|"[%d]"
argument_list|,
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|an_int_cst
argument_list|)
operator|/
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|array_of
argument_list|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
else|else
name|strcat
argument_list|(
name|str
argument_list|,
literal|"[]"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|CALL_EXPR
condition|)
block|{
name|tree
name|chain
init|=
name|TREE_PURPOSE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|strcat
argument_list|(
name|str
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
while|while
condition|(
name|chain
condition|)
block|{
name|gen_declaration
argument_list|(
name|chain
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|chain
condition|)
name|strcat
argument_list|(
name|str
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
block|}
name|strcat
argument_list|(
name|str
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|tree
name|chain
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|strcat
argument_list|(
name|str
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
while|while
condition|(
name|chain
operator|&&
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
operator|!=
name|void_type_node
condition|)
block|{
name|gen_declaration
argument_list|(
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|chain
operator|&&
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
operator|!=
name|void_type_node
condition|)
name|strcat
argument_list|(
name|str
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
block|}
name|strcat
argument_list|(
name|str
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|INDIRECT_REF
condition|)
block|{
name|strcpy
argument_list|(
name|tmpbuf
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|tree
name|chain
decl_stmt|;
for|for
control|(
name|chain
operator|=
name|nreverse
argument_list|(
name|copy_list
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
init|;
name|chain
condition|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
name|strcat
argument_list|(
name|tmpbuf
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmpbuf
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|str
index|[
literal|0
index|]
condition|)
name|strcat
argument_list|(
name|tmpbuf
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
name|strcat
argument_list|(
name|tmpbuf
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|str
argument_list|,
name|tmpbuf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|POINTER_TYPE
condition|)
block|{
name|strcpy
argument_list|(
name|tmpbuf
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|||
name|TYPE_VOLATILE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
condition|)
name|strcat
argument_list|(
name|tmpbuf
argument_list|,
literal|" const"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_VOLATILE
argument_list|(
name|decl
argument_list|)
condition|)
name|strcat
argument_list|(
name|tmpbuf
argument_list|,
literal|" volatile"
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
index|[
literal|0
index|]
condition|)
name|strcat
argument_list|(
name|tmpbuf
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
name|strcat
argument_list|(
name|tmpbuf
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|str
argument_list|,
name|tmpbuf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|gen_declarator
parameter_list|(
name|decl
parameter_list|,
name|buf
parameter_list|,
name|name
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
if|if
condition|(
name|decl
condition|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|tree
name|op
decl_stmt|;
name|int
name|wrap
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|ARRAY_REF
case|:
case|case
name|INDIRECT_REF
case|:
case|case
name|CALL_EXPR
case|:
name|op
operator|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* We have a pointer to a function or array...(*)(), (*)[] */
if|if
condition|(
operator|(
name|code
operator|==
name|ARRAY_REF
operator|||
name|code
operator|==
name|CALL_EXPR
operator|)
operator|&&
name|op
operator|&&
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
name|wrap
operator|=
literal|1
expr_stmt|;
name|str
operator|=
name|gen_declarator
argument_list|(
name|op
argument_list|,
name|buf
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|wrap
condition|)
block|{
name|strcpy
argument_list|(
name|tmpbuf
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmpbuf
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmpbuf
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|str
argument_list|,
name|tmpbuf
argument_list|)
expr_stmt|;
block|}
name|adorn_decl
argument_list|(
name|decl
argument_list|,
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARRAY_TYPE
case|:
case|case
name|FUNCTION_TYPE
case|:
case|case
name|POINTER_TYPE
case|:
name|strcpy
argument_list|(
name|buf
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|str
operator|=
name|buf
expr_stmt|;
comment|/* This clause is done iteratively rather than recursively. */
do|do
block|{
name|op
operator|=
operator|(
name|is_complex_decl
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|?
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
else|:
name|NULL_TREE
operator|)
expr_stmt|;
name|adorn_decl
argument_list|(
name|decl
argument_list|,
name|str
argument_list|)
expr_stmt|;
comment|/* We have a pointer to a function or array...(*)(), (*)[] */
if|if
condition|(
name|code
operator|==
name|POINTER_TYPE
operator|&&
name|op
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|ARRAY_TYPE
operator|)
condition|)
block|{
name|strcpy
argument_list|(
name|tmpbuf
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmpbuf
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmpbuf
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|str
argument_list|,
name|tmpbuf
argument_list|)
expr_stmt|;
block|}
name|decl
operator|=
operator|(
name|is_complex_decl
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|?
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
else|:
name|NULL_TREE
operator|)
expr_stmt|;
block|}
do|while
condition|(
name|decl
operator|&&
operator|(
name|code
operator|=
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
do|;
break|break;
case|case
name|IDENTIFIER_NODE
case|:
comment|/* Will only happen if we are processing a "raw" expr-decl. */
name|strcpy
argument_list|(
name|buf
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
return|return
name|str
return|;
block|}
else|else
comment|/* We have an abstract declarator or a _DECL node. */
block|{
name|strcpy
argument_list|(
name|buf
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|gen_declspecs
parameter_list|(
name|declspecs
parameter_list|,
name|buf
parameter_list|,
name|raw
parameter_list|)
name|tree
name|declspecs
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|raw
decl_stmt|;
block|{
if|if
condition|(
name|raw
condition|)
block|{
name|tree
name|chain
decl_stmt|;
for|for
control|(
name|chain
operator|=
name|nreverse
argument_list|(
name|copy_list
argument_list|(
name|declspecs
argument_list|)
argument_list|)
init|;
name|chain
condition|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
control|)
block|{
name|tree
name|aspec
init|=
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|aspec
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|aspec
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|aspec
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|aspec
argument_list|)
condition|)
block|{
name|tree
name|protocol_list
init|=
name|TYPE_PROTOCOL_LIST
argument_list|(
name|aspec
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|TREE_STATIC_TEMPLATE
argument_list|(
name|aspec
argument_list|)
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"struct "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TYPE_NAME
argument_list|(
name|aspec
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NEW!!! */
if|if
condition|(
name|protocol_list
condition|)
block|{
name|tree
name|chain
init|=
name|protocol_list
decl_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"<"
argument_list|)
expr_stmt|;
while|while
condition|(
name|chain
condition|)
block|{
name|strcat
argument_list|(
name|buf
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|PROTOCOL_NAME
argument_list|(
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|chain
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
block|}
name|strcat
argument_list|(
name|buf
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"untagged struct"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|aspec
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|aspec
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|TREE_STATIC_TEMPLATE
argument_list|(
name|aspec
argument_list|)
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"union "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TYPE_NAME
argument_list|(
name|aspec
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"untagged union"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|aspec
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
block|{
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|aspec
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|TREE_STATIC_TEMPLATE
argument_list|(
name|aspec
argument_list|)
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"enum "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TYPE_NAME
argument_list|(
name|aspec
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"untagged enum"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|aspec
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_NAME
argument_list|(
name|aspec
argument_list|)
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|aspec
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_ID
argument_list|(
name|aspec
argument_list|)
condition|)
block|{
name|tree
name|protocol_list
init|=
name|TYPE_PROTOCOL_LIST
argument_list|(
name|aspec
argument_list|)
decl_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"id"
argument_list|)
expr_stmt|;
if|if
condition|(
name|protocol_list
condition|)
block|{
name|tree
name|chain
init|=
name|protocol_list
decl_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"<"
argument_list|)
expr_stmt|;
while|while
condition|(
name|chain
condition|)
block|{
name|strcat
argument_list|(
name|buf
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|PROTOCOL_NAME
argument_list|(
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|chain
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
block|}
name|strcat
argument_list|(
name|buf
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Type qualifiers. */
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|declspecs
argument_list|)
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"const "
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_VOLATILE
argument_list|(
name|declspecs
argument_list|)
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"volatile "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|declspecs
argument_list|)
condition|)
block|{
comment|/* Type specifiers. */
case|case
name|INTEGER_TYPE
case|:
name|declspecs
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|declspecs
argument_list|)
expr_stmt|;
comment|/* Signed integer types.  */
if|if
condition|(
name|declspecs
operator|==
name|short_integer_type_node
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"short int "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|declspecs
operator|==
name|integer_type_node
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"int "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|declspecs
operator|==
name|long_integer_type_node
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"long int "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|declspecs
operator|==
name|long_long_integer_type_node
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"long long int "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|declspecs
operator|==
name|signed_char_type_node
operator|||
name|declspecs
operator|==
name|char_type_node
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"char "
argument_list|)
expr_stmt|;
comment|/* Unsigned integer types. */
elseif|else
if|if
condition|(
name|declspecs
operator|==
name|short_unsigned_type_node
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"unsigned short "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|declspecs
operator|==
name|unsigned_type_node
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"unsigned int "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|declspecs
operator|==
name|long_unsigned_type_node
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"unsigned long "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|declspecs
operator|==
name|long_long_unsigned_type_node
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"unsigned long long "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|declspecs
operator|==
name|unsigned_char_type_node
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"unsigned char "
argument_list|)
expr_stmt|;
break|break;
case|case
name|REAL_TYPE
case|:
name|declspecs
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|declspecs
argument_list|)
expr_stmt|;
if|if
condition|(
name|declspecs
operator|==
name|float_type_node
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"float "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|declspecs
operator|==
name|double_type_node
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"double "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|declspecs
operator|==
name|long_double_type_node
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"long double "
argument_list|)
expr_stmt|;
break|break;
case|case
name|RECORD_TYPE
case|:
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|declspecs
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|declspecs
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
name|tree
name|protocol_list
init|=
name|TYPE_PROTOCOL_LIST
argument_list|(
name|declspecs
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|TREE_STATIC_TEMPLATE
argument_list|(
name|declspecs
argument_list|)
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"struct "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TYPE_NAME
argument_list|(
name|declspecs
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|protocol_list
condition|)
block|{
name|tree
name|chain
init|=
name|protocol_list
decl_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"<"
argument_list|)
expr_stmt|;
while|while
condition|(
name|chain
condition|)
block|{
name|strcat
argument_list|(
name|buf
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|PROTOCOL_NAME
argument_list|(
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|chain
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
block|}
name|strcat
argument_list|(
name|buf
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"untagged struct"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNION_TYPE
case|:
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|declspecs
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|declspecs
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"union "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TYPE_NAME
argument_list|(
name|declspecs
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
else|else
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"untagged union "
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENUMERAL_TYPE
case|:
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|declspecs
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|declspecs
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"enum "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TYPE_NAME
argument_list|(
name|declspecs
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
else|else
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"untagged enum "
argument_list|)
expr_stmt|;
break|break;
case|case
name|VOID_TYPE
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"void "
argument_list|)
expr_stmt|;
break|break;
case|case
name|POINTER_TYPE
case|:
block|{
name|tree
name|protocol_list
init|=
name|TYPE_PROTOCOL_LIST
argument_list|(
name|declspecs
argument_list|)
decl_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"id"
argument_list|)
expr_stmt|;
if|if
condition|(
name|protocol_list
condition|)
block|{
name|tree
name|chain
init|=
name|protocol_list
decl_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"<"
argument_list|)
expr_stmt|;
while|while
condition|(
name|chain
condition|)
block|{
name|strcat
argument_list|(
name|buf
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|PROTOCOL_NAME
argument_list|(
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|chain
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
block|}
name|strcat
argument_list|(
name|buf
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|gen_declaration
parameter_list|(
name|atype_or_adecl
parameter_list|,
name|buf
parameter_list|)
name|tree
name|atype_or_adecl
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
block|{
name|char
name|declbuf
index|[
literal|256
index|]
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|atype_or_adecl
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|tree
name|declspecs
decl_stmt|;
comment|/* "identifier_node", "record_type" */
name|tree
name|declarator
decl_stmt|;
comment|/* "array_ref", "indirect_ref", "call_expr"... */
comment|/* We have a "raw", abstract declarator (typename). */
name|declarator
operator|=
name|TREE_VALUE
argument_list|(
name|atype_or_adecl
argument_list|)
expr_stmt|;
name|declspecs
operator|=
name|TREE_PURPOSE
argument_list|(
name|atype_or_adecl
argument_list|)
expr_stmt|;
name|gen_declspecs
argument_list|(
name|declspecs
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|declarator
condition|)
block|{
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
name|gen_declarator
argument_list|(
name|declarator
argument_list|,
name|declbuf
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|tree
name|atype
decl_stmt|;
name|tree
name|declspecs
decl_stmt|;
comment|/* "integer_type", "real_type", "record_type"... */
name|tree
name|declarator
decl_stmt|;
comment|/* "array_type", "function_type", "pointer_type". */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|atype_or_adecl
argument_list|)
operator|==
name|FIELD_DECL
operator|||
name|TREE_CODE
argument_list|(
name|atype_or_adecl
argument_list|)
operator|==
name|PARM_DECL
operator|||
name|TREE_CODE
argument_list|(
name|atype_or_adecl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|atype
operator|=
name|TREE_TYPE
argument_list|(
name|atype_or_adecl
argument_list|)
expr_stmt|;
else|else
comment|/* Assume we have a *_type node. */
name|atype
operator|=
name|atype_or_adecl
expr_stmt|;
if|if
condition|(
name|is_complex_decl
argument_list|(
name|atype
argument_list|)
condition|)
block|{
name|tree
name|chain
decl_stmt|;
comment|/* Get the declaration specifier; it is at the end of the list. */
name|declarator
operator|=
name|chain
operator|=
name|atype
expr_stmt|;
do|do
name|chain
operator|=
name|TREE_TYPE
argument_list|(
name|chain
argument_list|)
expr_stmt|;
comment|/* not TREE_CHAIN (chain); */
do|while
condition|(
name|is_complex_decl
argument_list|(
name|chain
argument_list|)
condition|)
do|;
name|declspecs
operator|=
name|chain
expr_stmt|;
block|}
else|else
block|{
name|declspecs
operator|=
name|atype
expr_stmt|;
name|declarator
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|gen_declspecs
argument_list|(
name|declspecs
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|atype_or_adecl
argument_list|)
operator|==
name|FIELD_DECL
operator|||
name|TREE_CODE
argument_list|(
name|atype_or_adecl
argument_list|)
operator|==
name|PARM_DECL
operator|||
name|TREE_CODE
argument_list|(
name|atype_or_adecl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|char
modifier|*
name|decl_name
init|=
operator|(
name|DECL_NAME
argument_list|(
name|atype_or_adecl
argument_list|)
condition|?
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|atype_or_adecl
argument_list|)
argument_list|)
else|:
literal|""
operator|)
decl_stmt|;
if|if
condition|(
name|declarator
condition|)
block|{
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
name|gen_declarator
argument_list|(
name|declarator
argument_list|,
name|declbuf
argument_list|,
name|decl_name
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|decl_name
index|[
literal|0
index|]
condition|)
block|{
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
name|decl_name
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|declarator
condition|)
block|{
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
name|gen_declarator
argument_list|(
name|declarator
argument_list|,
name|declbuf
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|buf
return|;
block|}
end_function

begin_define
define|#
directive|define
name|RAW_TYPESPEC
parameter_list|(
name|meth
parameter_list|)
value|(TREE_VALUE (TREE_PURPOSE (TREE_TYPE (meth))))
end_define

begin_function
specifier|static
name|char
modifier|*
name|gen_method_decl
parameter_list|(
name|method
parameter_list|,
name|buf
parameter_list|)
name|tree
name|method
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
block|{
name|tree
name|chain
decl_stmt|;
if|if
condition|(
name|RAW_TYPESPEC
argument_list|(
name|method
argument_list|)
operator|!=
name|objc_object_reference
condition|)
block|{
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|gen_declaration
argument_list|(
name|TREE_TYPE
argument_list|(
name|method
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
name|chain
operator|=
name|METHOD_SEL_ARGS
argument_list|(
name|method
argument_list|)
expr_stmt|;
if|if
condition|(
name|chain
condition|)
block|{
comment|/* We have a chain of keyword_decls. */
do|do
block|{
if|if
condition|(
name|KEYWORD_KEY_NAME
argument_list|(
name|chain
argument_list|)
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|KEYWORD_KEY_NAME
argument_list|(
name|chain
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
if|if
condition|(
name|RAW_TYPESPEC
argument_list|(
name|chain
argument_list|)
operator|!=
name|objc_object_reference
condition|)
block|{
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|gen_declaration
argument_list|(
name|TREE_TYPE
argument_list|(
name|chain
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
name|strcat
argument_list|(
name|buf
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|KEYWORD_ARG_NAME
argument_list|(
name|chain
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
operator|)
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|chain
condition|)
do|;
if|if
condition|(
name|METHOD_ADD_ARGS
argument_list|(
name|method
argument_list|)
operator|==
operator|(
name|tree
operator|)
literal|1
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", ..."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|METHOD_ADD_ARGS
argument_list|(
name|method
argument_list|)
condition|)
block|{
comment|/* We have a tree list node as generate by get_parm_info.  */
name|chain
operator|=
name|TREE_PURPOSE
argument_list|(
name|METHOD_ADD_ARGS
argument_list|(
name|method
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Know we have a chain of parm_decls. */
while|while
condition|(
name|chain
condition|)
block|{
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|gen_declaration
argument_list|(
name|chain
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
comment|/* We have a unary selector. */
name|strcat
argument_list|(
name|buf
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|METHOD_SEL_NAME
argument_list|(
name|method
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Debug info.  */
end_comment

begin_function
specifier|static
name|void
name|dump_interface
parameter_list|(
name|fp
parameter_list|,
name|chain
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
name|tree
name|chain
decl_stmt|;
block|{
name|char
modifier|*
name|buf
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|256
argument_list|)
decl_stmt|;
name|char
modifier|*
name|my_name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_NAME
argument_list|(
name|chain
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|ivar_decls
init|=
name|CLASS_RAW_IVARS
argument_list|(
name|chain
argument_list|)
decl_stmt|;
name|tree
name|nst_methods
init|=
name|CLASS_NST_METHODS
argument_list|(
name|chain
argument_list|)
decl_stmt|;
name|tree
name|cls_methods
init|=
name|CLASS_CLS_METHODS
argument_list|(
name|chain
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n@interface %s"
argument_list|,
name|my_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASS_SUPER_NAME
argument_list|(
name|chain
argument_list|)
condition|)
block|{
name|char
modifier|*
name|super_name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_SUPER_NAME
argument_list|(
name|chain
argument_list|)
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" : %s\n"
argument_list|,
name|super_name
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ivar_decls
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"{\n"
argument_list|)
expr_stmt|;
do|do
block|{
name|bzero
argument_list|(
name|buf
argument_list|,
literal|256
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t%s;\n"
argument_list|,
name|gen_declaration
argument_list|(
name|ivar_decls
argument_list|,
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|ivar_decls
operator|=
name|TREE_CHAIN
argument_list|(
name|ivar_decls
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ivar_decls
condition|)
do|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|nst_methods
condition|)
block|{
name|bzero
argument_list|(
name|buf
argument_list|,
literal|256
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"- %s;\n"
argument_list|,
name|gen_method_decl
argument_list|(
name|nst_methods
argument_list|,
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|nst_methods
operator|=
name|TREE_CHAIN
argument_list|(
name|nst_methods
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|cls_methods
condition|)
block|{
name|bzero
argument_list|(
name|buf
argument_list|,
literal|256
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"+ %s;\n"
argument_list|,
name|gen_method_decl
argument_list|(
name|cls_methods
argument_list|,
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|cls_methods
operator|=
name|TREE_CHAIN
argument_list|(
name|cls_methods
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n@end"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_objc
parameter_list|()
block|{
comment|/* Add the special tree codes of Objective C to the tables.  */
define|#
directive|define
name|LAST_CODE
value|LAST_AND_UNUSED_TREE_CODE
name|gcc_obstack_init
argument_list|(
operator|&
name|util_obstack
argument_list|)
expr_stmt|;
name|util_firstobj
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_finish
argument_list|(
operator|&
name|util_obstack
argument_list|)
expr_stmt|;
name|tree_code_type
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|tree_code_type
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
name|LAST_OBJC_TREE_CODE
argument_list|)
expr_stmt|;
name|tree_code_length
operator|=
operator|(
name|int
operator|*
operator|)
name|xrealloc
argument_list|(
name|tree_code_length
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|LAST_OBJC_TREE_CODE
argument_list|)
expr_stmt|;
name|tree_code_name
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|tree_code_name
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
name|LAST_OBJC_TREE_CODE
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|objc_tree_code_type
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|tree_code_type
operator|+
operator|(
name|int
operator|)
name|LAST_CODE
operator|)
argument_list|,
operator|(
operator|(
operator|(
name|int
operator|)
name|LAST_OBJC_TREE_CODE
operator|-
operator|(
name|int
operator|)
name|LAST_CODE
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|objc_tree_code_length
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|tree_code_length
operator|+
operator|(
name|int
operator|)
name|LAST_CODE
operator|)
argument_list|,
operator|(
operator|(
operator|(
name|int
operator|)
name|LAST_OBJC_TREE_CODE
operator|-
operator|(
name|int
operator|)
name|LAST_CODE
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|objc_tree_code_name
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|tree_code_name
operator|+
operator|(
name|int
operator|)
name|LAST_CODE
operator|)
argument_list|,
operator|(
operator|(
operator|(
name|int
operator|)
name|LAST_OBJC_TREE_CODE
operator|-
operator|(
name|int
operator|)
name|LAST_CODE
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|errbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|BUFSIZE
argument_list|)
expr_stmt|;
name|hash_init
argument_list|()
expr_stmt|;
name|synth_module_prologue
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|finish_objc
parameter_list|()
block|{
name|struct
name|imp_entry
modifier|*
name|impent
decl_stmt|;
name|tree
name|chain
decl_stmt|;
comment|/* The internally generated initializers appear to have missing braces.      Don't warn about this.  */
name|int
name|save_warn_missing_braces
init|=
name|warn_missing_braces
decl_stmt|;
name|warn_missing_braces
operator|=
literal|0
expr_stmt|;
name|generate_forward_declaration_to_string_table
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJC_PROLOGUE
name|OBJC_PROLOGUE
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|implementation_context
operator|||
name|class_names_chain
operator|||
name|meth_var_names_chain
operator|||
name|meth_var_types_chain
operator|||
name|sel_ref_chain
condition|)
name|generate_objc_symtab_decl
argument_list|()
expr_stmt|;
for|for
control|(
name|impent
operator|=
name|imp_list
init|;
name|impent
condition|;
name|impent
operator|=
name|impent
operator|->
name|next
control|)
block|{
name|implementation_context
operator|=
name|impent
operator|->
name|imp_context
expr_stmt|;
name|implementation_template
operator|=
name|impent
operator|->
name|imp_template
expr_stmt|;
name|UOBJC_CLASS_decl
operator|=
name|impent
operator|->
name|class_decl
expr_stmt|;
name|UOBJC_METACLASS_decl
operator|=
name|impent
operator|->
name|meta_decl
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|implementation_context
argument_list|)
operator|==
name|CLASS_IMPLEMENTATION_TYPE
condition|)
block|{
comment|/* all of the following reference the string pool...  */
name|generate_ivar_lists
argument_list|()
expr_stmt|;
name|generate_dispatch_tables
argument_list|()
expr_stmt|;
name|generate_shared_structures
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|generate_dispatch_tables
argument_list|()
expr_stmt|;
name|generate_category
argument_list|(
name|implementation_context
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If we are using an array of selectors, we must always      finish up the array decl even if no selectors were used.  */
if|if
condition|(
operator|!
name|flag_next_runtime
operator|||
name|sel_ref_chain
condition|)
name|build_selector_translation_table
argument_list|()
expr_stmt|;
if|if
condition|(
name|protocol_chain
condition|)
name|generate_protocols
argument_list|()
expr_stmt|;
if|if
condition|(
name|objc_static_instances
condition|)
name|generate_static_references
argument_list|()
expr_stmt|;
if|if
condition|(
name|implementation_context
operator|||
name|class_names_chain
operator|||
name|objc_static_instances
operator|||
name|meth_var_names_chain
operator|||
name|meth_var_types_chain
operator|||
name|sel_ref_chain
condition|)
block|{
comment|/* Arrange for Objc data structures to be initialized at run time.  */
name|char
modifier|*
name|init_name
init|=
name|build_module_descriptor
argument_list|()
decl_stmt|;
if|if
condition|(
name|init_name
condition|)
name|assemble_constructor
argument_list|(
name|init_name
argument_list|)
expr_stmt|;
block|}
comment|/* Dump the class references.  This forces the appropriate classes      to be linked into the executable image, preserving unix archive      semantics.  This can be removed when we move to a more dynamically      linked environment.  */
for|for
control|(
name|chain
operator|=
name|cls_ref_chain
init|;
name|chain
condition|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
control|)
block|{
name|handle_class_ref
argument_list|(
name|chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|chain
argument_list|)
condition|)
name|generate_classref_translation_entry
argument_list|(
name|chain
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|impent
operator|=
name|imp_list
init|;
name|impent
condition|;
name|impent
operator|=
name|impent
operator|->
name|next
control|)
name|handle_impent
argument_list|(
name|impent
argument_list|)
expr_stmt|;
comment|/* Dump the string table last. */
name|generate_strings
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_gen_declaration
condition|)
block|{
name|add_class
argument_list|(
name|implementation_context
argument_list|)
expr_stmt|;
name|dump_interface
argument_list|(
name|gen_declaration_file
argument_list|,
name|implementation_context
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|warn_selector
condition|)
block|{
name|int
name|slot
decl_stmt|;
name|hash
name|hsh
decl_stmt|;
comment|/* Run through the selector hash tables and print a warning for any          selector which has multiple methods. */
for|for
control|(
name|slot
operator|=
literal|0
init|;
name|slot
operator|<
name|SIZEHASHTABLE
condition|;
name|slot
operator|++
control|)
for|for
control|(
name|hsh
operator|=
name|cls_method_hash_list
index|[
name|slot
index|]
init|;
name|hsh
condition|;
name|hsh
operator|=
name|hsh
operator|->
name|next
control|)
if|if
condition|(
name|hsh
operator|->
name|list
condition|)
block|{
name|tree
name|meth
init|=
name|hsh
operator|->
name|key
decl_stmt|;
name|char
name|type
init|=
operator|(
name|TREE_CODE
argument_list|(
name|meth
argument_list|)
operator|==
name|INSTANCE_METHOD_DECL
condition|?
literal|'-'
else|:
literal|'+'
operator|)
decl_stmt|;
name|attr
name|loop
decl_stmt|;
name|warning
argument_list|(
literal|"potential selector conflict for method `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|METHOD_SEL_NAME
argument_list|(
name|meth
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|warn_with_method
argument_list|(
literal|"found"
argument_list|,
name|type
argument_list|,
name|meth
argument_list|)
expr_stmt|;
for|for
control|(
name|loop
operator|=
name|hsh
operator|->
name|list
init|;
name|loop
condition|;
name|loop
operator|=
name|loop
operator|->
name|next
control|)
name|warn_with_method
argument_list|(
literal|"found"
argument_list|,
name|type
argument_list|,
name|loop
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|slot
operator|=
literal|0
init|;
name|slot
operator|<
name|SIZEHASHTABLE
condition|;
name|slot
operator|++
control|)
for|for
control|(
name|hsh
operator|=
name|nst_method_hash_list
index|[
name|slot
index|]
init|;
name|hsh
condition|;
name|hsh
operator|=
name|hsh
operator|->
name|next
control|)
if|if
condition|(
name|hsh
operator|->
name|list
condition|)
block|{
name|tree
name|meth
init|=
name|hsh
operator|->
name|key
decl_stmt|;
name|char
name|type
init|=
operator|(
name|TREE_CODE
argument_list|(
name|meth
argument_list|)
operator|==
name|INSTANCE_METHOD_DECL
condition|?
literal|'-'
else|:
literal|'+'
operator|)
decl_stmt|;
name|attr
name|loop
decl_stmt|;
name|warning
argument_list|(
literal|"potential selector conflict for method `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|METHOD_SEL_NAME
argument_list|(
name|meth
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|warn_with_method
argument_list|(
literal|"found"
argument_list|,
name|type
argument_list|,
name|meth
argument_list|)
expr_stmt|;
for|for
control|(
name|loop
operator|=
name|hsh
operator|->
name|list
init|;
name|loop
condition|;
name|loop
operator|=
name|loop
operator|->
name|next
control|)
name|warn_with_method
argument_list|(
literal|"found"
argument_list|,
name|type
argument_list|,
name|loop
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
block|}
name|warn_missing_braces
operator|=
name|save_warn_missing_braces
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutines of finish_objc.  */
end_comment

begin_function
specifier|static
name|void
name|generate_classref_translation_entry
parameter_list|(
name|chain
parameter_list|)
name|tree
name|chain
decl_stmt|;
block|{
name|tree
name|expr
decl_stmt|,
name|name
decl_stmt|,
name|decl_specs
decl_stmt|,
name|decl
decl_stmt|,
name|sc_spec
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|chain
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|add_objc_string
argument_list|(
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
argument_list|,
name|class_names
argument_list|)
expr_stmt|;
name|expr
operator|=
name|build_c_cast
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
expr_stmt|;
comment|/* cast! */
name|name
operator|=
name|DECL_NAME
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|chain
argument_list|)
argument_list|)
expr_stmt|;
name|sc_spec
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_STATIC
index|]
argument_list|)
expr_stmt|;
comment|/* static struct objc_class * _OBJC_CLASS_REFERENCES_n = ...; */
name|decl_specs
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|type
argument_list|,
name|sc_spec
argument_list|)
expr_stmt|;
comment|/* The decl that is returned from start_decl is the one that we      forward declared in build_class_reference.  */
name|decl
operator|=
name|start_decl
argument_list|(
name|name
argument_list|,
name|decl_specs
argument_list|,
literal|1
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|decl
argument_list|,
name|expr
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|handle_class_ref
parameter_list|(
name|chain
parameter_list|)
name|tree
name|chain
decl_stmt|;
block|{
name|char
modifier|*
name|name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|flag_next_runtime
condition|)
block|{
name|tree
name|decl
decl_stmt|;
name|char
modifier|*
name|string
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|30
argument_list|)
decl_stmt|;
name|tree
name|exp
decl_stmt|;
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"%sobjc_class_name_%s"
argument_list|,
operator|(
name|flag_next_runtime
condition|?
literal|"."
else|:
literal|"__"
operator|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Make a decl for this name, so we can use its address in a tree.  */
name|decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|get_identifier
argument_list|(
name|string
argument_list|)
argument_list|,
name|char_type_node
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Make following constant read-only (why not)?  */
name|readonly_data_section
argument_list|()
expr_stmt|;
name|exp
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|string_type_node
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* Align the section properly.  */
name|assemble_constant_align
argument_list|(
name|exp
argument_list|)
expr_stmt|;
comment|/* Inform the assembler about this new external thing.  */
name|assemble_external
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Output a constant to reference this address.  */
name|output_constant
argument_list|(
name|exp
argument_list|,
name|int_size_in_bytes
argument_list|(
name|string_type_node
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This overreliance on our assembler (i.e. lack of portability) 	 should be dealt with at some point.  The GNU strategy (above) 	 won't work either, but it is a start.  */
name|char
modifier|*
name|string
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|30
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|string
argument_list|,
literal|".reference .objc_class_name_%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|assemble_asm
argument_list|(
name|my_build_string
argument_list|(
name|strlen
argument_list|(
name|string
argument_list|)
operator|+
literal|1
argument_list|,
name|string
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|handle_impent
parameter_list|(
name|impent
parameter_list|)
name|struct
name|imp_entry
modifier|*
name|impent
decl_stmt|;
block|{
name|implementation_context
operator|=
name|impent
operator|->
name|imp_context
expr_stmt|;
name|implementation_template
operator|=
name|impent
operator|->
name|imp_template
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|impent
operator|->
name|imp_context
argument_list|)
operator|==
name|CLASS_IMPLEMENTATION_TYPE
condition|)
block|{
name|char
modifier|*
name|class_name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_NAME
argument_list|(
name|impent
operator|->
name|imp_context
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|string
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|class_name
argument_list|)
operator|+
literal|30
argument_list|)
decl_stmt|;
if|if
condition|(
name|flag_next_runtime
condition|)
block|{
comment|/* Grossly unportable. 	     People should know better than to assume 	     such things about assembler syntax!  */
name|sprintf
argument_list|(
name|string
argument_list|,
literal|".objc_class_name_%s=0"
argument_list|,
name|class_name
argument_list|)
expr_stmt|;
name|assemble_asm
argument_list|(
name|my_build_string
argument_list|(
name|strlen
argument_list|(
name|string
argument_list|)
operator|+
literal|1
argument_list|,
name|string
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|string
argument_list|,
literal|".globl .objc_class_name_%s"
argument_list|,
name|class_name
argument_list|)
expr_stmt|;
name|assemble_asm
argument_list|(
name|my_build_string
argument_list|(
name|strlen
argument_list|(
name|string
argument_list|)
operator|+
literal|1
argument_list|,
name|string
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"%sobjc_class_name_%s"
argument_list|,
operator|(
name|flag_next_runtime
condition|?
literal|"."
else|:
literal|"__"
operator|)
argument_list|,
name|class_name
argument_list|)
expr_stmt|;
name|assemble_global
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|assemble_label
argument_list|(
name|string
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|impent
operator|->
name|imp_context
argument_list|)
operator|==
name|CATEGORY_IMPLEMENTATION_TYPE
condition|)
block|{
name|char
modifier|*
name|class_name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_NAME
argument_list|(
name|impent
operator|->
name|imp_context
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|class_super_name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_SUPER_NAME
argument_list|(
name|impent
operator|->
name|imp_context
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|string
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|class_name
argument_list|)
operator|+
name|strlen
argument_list|(
name|class_super_name
argument_list|)
operator|+
literal|30
argument_list|)
decl_stmt|;
comment|/* Do the same for categories.  Even though no references to these 	 symbols are generated automatically by the compiler, it gives 	 you a handle to pull them into an archive by hand. */
if|if
condition|(
name|flag_next_runtime
condition|)
block|{
comment|/* Grossly unportable.  */
name|sprintf
argument_list|(
name|string
argument_list|,
literal|".objc_category_name_%s_%s=0"
argument_list|,
name|class_name
argument_list|,
name|class_super_name
argument_list|)
expr_stmt|;
name|assemble_asm
argument_list|(
name|my_build_string
argument_list|(
name|strlen
argument_list|(
name|string
argument_list|)
operator|+
literal|1
argument_list|,
name|string
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|string
argument_list|,
literal|".globl .objc_category_name_%s_%s"
argument_list|,
name|class_name
argument_list|,
name|class_super_name
argument_list|)
expr_stmt|;
name|assemble_asm
argument_list|(
name|my_build_string
argument_list|(
name|strlen
argument_list|(
name|string
argument_list|)
operator|+
literal|1
argument_list|,
name|string
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"%sobjc_category_name_%s_%s"
argument_list|,
operator|(
name|flag_next_runtime
condition|?
literal|"."
else|:
literal|"__"
operator|)
argument_list|,
name|class_name
argument_list|,
name|class_super_name
argument_list|)
expr_stmt|;
name|assemble_global
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|assemble_label
argument_list|(
name|string
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|objc_debug
parameter_list|(
name|fp
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|char
modifier|*
name|buf
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|256
argument_list|)
decl_stmt|;
block|{
comment|/* dump function prototypes */
name|tree
name|loop
init|=
name|UOBJC_MODULES_decl
decl_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n\nfunction prototypes:\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|loop
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|loop
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|loop
argument_list|)
condition|)
block|{
comment|/* We have a function definition: generate prototype. */
name|bzero
argument_list|(
name|errbuf
argument_list|,
name|BUFSIZE
argument_list|)
expr_stmt|;
name|gen_declaration
argument_list|(
name|loop
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s;\n"
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
block|}
name|loop
operator|=
name|TREE_CHAIN
argument_list|(
name|loop
argument_list|)
expr_stmt|;
block|}
block|}
block|{
comment|/* Dump global chains. */
name|tree
name|loop
decl_stmt|;
name|int
name|i
decl_stmt|,
name|index
init|=
literal|0
decl_stmt|,
name|offset
init|=
literal|0
decl_stmt|;
name|hash
name|hashlist
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SIZEHASHTABLE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|hashlist
operator|=
name|nst_method_hash_list
index|[
name|i
index|]
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n\nnst_method_hash_list[%d]:\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
do|do
block|{
name|bzero
argument_list|(
name|buf
argument_list|,
literal|256
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"-%s;\n"
argument_list|,
name|gen_method_decl
argument_list|(
name|hashlist
operator|->
name|key
argument_list|,
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|hashlist
operator|=
name|hashlist
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|hashlist
condition|)
do|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SIZEHASHTABLE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|hashlist
operator|=
name|cls_method_hash_list
index|[
name|i
index|]
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n\ncls_method_hash_list[%d]:\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
do|do
block|{
name|bzero
argument_list|(
name|buf
argument_list|,
literal|256
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"-%s;\n"
argument_list|,
name|gen_method_decl
argument_list|(
name|hashlist
operator|->
name|key
argument_list|,
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|hashlist
operator|=
name|hashlist
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|hashlist
condition|)
do|;
block|}
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\nsel_refdef_chain:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|loop
operator|=
name|sel_refdef_chain
init|;
name|loop
condition|;
name|loop
operator|=
name|TREE_CHAIN
argument_list|(
name|loop
argument_list|)
control|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"(index: %4d offset: %4d) %s\n"
argument_list|,
name|index
argument_list|,
name|offset
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|loop
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|index
operator|++
expr_stmt|;
comment|/* add one for the '\0' character */
name|offset
operator|+=
name|IDENTIFIER_LENGTH
argument_list|(
name|TREE_VALUE
argument_list|(
name|loop
argument_list|)
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n (max_selector_index: %4d.\n"
argument_list|,
name|max_selector_index
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|print_lang_statistics
parameter_list|()
block|{ }
end_function

end_unit

