begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Array prefetching.    Copyright (C) 2005 Free Software Foundation, Inc.     This file is part of GCC.     GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.     GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.     You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"tree-dump.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"cfgloop.h"
end_include

begin_include
include|#
directive|include
file|"varray.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"tree-chrec.h"
end_include

begin_include
include|#
directive|include
file|"tree-scalar-evolution.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_comment
comment|/* This pass inserts prefetch instructions to optimize cache usage during    accesses to arrays in loops.  It processes loops sequentially and:     1) Gathers all memory references in the single loop.    2) For each of the references it decides when it is profitable to prefetch       it.  To do it, we evaluate the reuse among the accesses, and determines       two values: PREFETCH_BEFORE (meaning that it only makes sense to do       prefetching in the first PREFETCH_BEFORE iterations of the loop) and       PREFETCH_MOD (meaning that it only makes sense to prefetch in the       iterations of the loop that are zero modulo PREFETCH_MOD).  For example       (assuming cache line size is 64 bytes, char has size 1 byte and there       is no hardware sequential prefetch):        char *a;       for (i = 0; i< max; i++) 	{ 	  a[255] = ...;		(0) 	  a[i] = ...;		(1) 	  a[i + 64] = ...;	(2) 	  a[16*i] = ...;	(3) 	  a[187*i] = ...;	(4) 	  a[187*i + 50] = ...;	(5) 	}         (0) obviously has PREFETCH_BEFORE 1        (1) has PREFETCH_BEFORE 64, since (2) accesses the same memory            location 64 iterations before it, and PREFETCH_MOD 64 (since 	   it hits the same cache line otherwise).        (2) has PREFETCH_MOD 64        (3) has PREFETCH_MOD 4        (4) has PREFETCH_MOD 1.  We do not set PREFETCH_BEFORE here, since            the cache line accessed by (4) is the same with probability only 	   7/32.        (5) has PREFETCH_MOD 1 as well.     3) We determine how much ahead we need to prefetch.  The number of       iterations needed is time to fetch / time spent in one iteration of       the loop.  The problem is that we do not know either of these values,       so we just make a heuristic guess based on a magic (possibly)       target-specific constant and size of the loop.     4) Determine which of the references we prefetch.  We take into account       that there is a maximum number of simultaneous prefetches (provided       by machine description).  We prefetch as many prefetches as possible       while still within this bound (starting with those with lowest       prefetch_mod, since they are responsible for most of the cache       misses).           5) We unroll and peel loops so that we are able to satisfy PREFETCH_MOD       and PREFETCH_BEFORE requirements (within some bounds), and to avoid       prefetching nonaccessed memory.       TODO -- actually implement peeling.           6) We actually emit the prefetch instructions.  ??? Perhaps emit the       prefetch instructions with guards in cases where 5) was not sufficient       to satisfy the constraints?     Some other TODO:       -- write and use more general reuse analysis (that could be also used 	 in other cache aimed loop optimizations)       -- make it behave sanely together with the prefetches given by user 	 (now we just ignore them; at the very least we should avoid 	 optimizing loops in that user put his own prefetches)       -- we assume cache line size alignment of arrays; this could be 	 improved.  */
end_comment

begin_comment
comment|/* Magic constants follow.  These should be replaced by machine specific    numbers.  */
end_comment

begin_comment
comment|/* A number that should roughly correspond to the number of instructions    executed before the prefetch is completed.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PREFETCH_LATENCY
end_ifndef

begin_define
define|#
directive|define
name|PREFETCH_LATENCY
value|200
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Number of prefetches that can run at the same time.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SIMULTANEOUS_PREFETCHES
end_ifndef

begin_define
define|#
directive|define
name|SIMULTANEOUS_PREFETCHES
value|3
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* True if write can be prefetched by a read prefetch.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|WRITE_CAN_USE_READ_PREFETCH
end_ifndef

begin_define
define|#
directive|define
name|WRITE_CAN_USE_READ_PREFETCH
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* True if read can be prefetched by a write prefetch. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|READ_CAN_USE_WRITE_PREFETCH
end_ifndef

begin_define
define|#
directive|define
name|READ_CAN_USE_WRITE_PREFETCH
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Cache line size.  Assumed to be a power of two.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PREFETCH_BLOCK
end_ifndef

begin_define
define|#
directive|define
name|PREFETCH_BLOCK
value|32
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Do we have a forward hardware sequential prefetching?  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_FORWARD_PREFETCH
end_ifndef

begin_define
define|#
directive|define
name|HAVE_FORWARD_PREFETCH
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Do we have a backward hardware sequential prefetching?  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_BACKWARD_PREFETCH
end_ifndef

begin_define
define|#
directive|define
name|HAVE_BACKWARD_PREFETCH
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* In some cases we are only able to determine that there is a certain    probability that the two accesses hit the same cache line.  In this    case, we issue the prefetches for both of them if this probability    is less then (1000 - ACCEPTABLE_MISS_RATE) promile.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ACCEPTABLE_MISS_RATE
end_ifndef

begin_define
define|#
directive|define
name|ACCEPTABLE_MISS_RATE
value|50
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_prefetch
end_ifndef

begin_define
define|#
directive|define
name|HAVE_prefetch
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The group of references between that reuse may occur.  */
end_comment

begin_struct
struct|struct
name|mem_ref_group
block|{
name|tree
name|base
decl_stmt|;
comment|/* Base of the reference.  */
name|HOST_WIDE_INT
name|step
decl_stmt|;
comment|/* Step of the reference.  */
name|struct
name|mem_ref
modifier|*
name|refs
decl_stmt|;
comment|/* References in the group.  */
name|struct
name|mem_ref_group
modifier|*
name|next
decl_stmt|;
comment|/* Next group of references.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Assigned to PREFETCH_BEFORE when all iterations are to be prefetched.  */
end_comment

begin_define
define|#
directive|define
name|PREFETCH_ALL
value|(~(unsigned HOST_WIDE_INT) 0)
end_define

begin_comment
comment|/* The memory reference.  */
end_comment

begin_struct
struct|struct
name|mem_ref
block|{
name|tree
name|stmt
decl_stmt|;
comment|/* Statement in that the reference appears.  */
name|tree
name|mem
decl_stmt|;
comment|/* The reference.  */
name|HOST_WIDE_INT
name|delta
decl_stmt|;
comment|/* Constant offset of the reference.  */
name|bool
name|write_p
decl_stmt|;
comment|/* Is it a write?  */
name|struct
name|mem_ref_group
modifier|*
name|group
decl_stmt|;
comment|/* The group of references it belongs to.  */
name|unsigned
name|HOST_WIDE_INT
name|prefetch_mod
decl_stmt|;
comment|/* Prefetch only each PREFETCH_MOD-th 				   iteration.  */
name|unsigned
name|HOST_WIDE_INT
name|prefetch_before
decl_stmt|;
comment|/* Prefetch only first PREFETCH_BEFORE 				   iterations.  */
name|bool
name|issue_prefetch_p
decl_stmt|;
comment|/* Should we really issue the prefetch?  */
name|struct
name|mem_ref
modifier|*
name|next
decl_stmt|;
comment|/* The next reference in the group.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Dumps information about reference REF to FILE.  */
end_comment

begin_function
specifier|static
name|void
name|dump_mem_ref
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|struct
name|mem_ref
modifier|*
name|ref
parameter_list|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Reference %p:\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ref
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"  group %p (base "
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ref
operator|->
name|group
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|file
argument_list|,
name|ref
operator|->
name|group
operator|->
name|base
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|", step "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|ref
operator|->
name|group
operator|->
name|step
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  delta "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|ref
operator|->
name|delta
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"  %s\n"
argument_list|,
name|ref
operator|->
name|write_p
condition|?
literal|"write"
else|:
literal|"read"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finds a group with BASE and STEP in GROUPS, or creates one if it does not    exist.  */
end_comment

begin_function
specifier|static
name|struct
name|mem_ref_group
modifier|*
name|find_or_create_group
parameter_list|(
name|struct
name|mem_ref_group
modifier|*
modifier|*
name|groups
parameter_list|,
name|tree
name|base
parameter_list|,
name|HOST_WIDE_INT
name|step
parameter_list|)
block|{
name|struct
name|mem_ref_group
modifier|*
name|group
decl_stmt|;
for|for
control|(
init|;
operator|*
name|groups
condition|;
name|groups
operator|=
operator|&
operator|(
operator|*
name|groups
operator|)
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|groups
operator|)
operator|->
name|step
operator|==
name|step
operator|&&
name|operand_equal_p
argument_list|(
operator|(
operator|*
name|groups
operator|)
operator|->
name|base
argument_list|,
name|base
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|*
name|groups
return|;
comment|/* Keep the list of groups sorted by decreasing step.  */
if|if
condition|(
operator|(
operator|*
name|groups
operator|)
operator|->
name|step
operator|<
name|step
condition|)
break|break;
block|}
name|group
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mem_ref_group
argument_list|)
argument_list|)
expr_stmt|;
name|group
operator|->
name|base
operator|=
name|base
expr_stmt|;
name|group
operator|->
name|step
operator|=
name|step
expr_stmt|;
name|group
operator|->
name|refs
operator|=
name|NULL
expr_stmt|;
name|group
operator|->
name|next
operator|=
operator|*
name|groups
expr_stmt|;
operator|*
name|groups
operator|=
name|group
expr_stmt|;
return|return
name|group
return|;
block|}
end_function

begin_comment
comment|/* Records a memory reference MEM in GROUP with offset DELTA and write status    WRITE_P.  The reference occurs in statement STMT.  */
end_comment

begin_function
specifier|static
name|void
name|record_ref
parameter_list|(
name|struct
name|mem_ref_group
modifier|*
name|group
parameter_list|,
name|tree
name|stmt
parameter_list|,
name|tree
name|mem
parameter_list|,
name|HOST_WIDE_INT
name|delta
parameter_list|,
name|bool
name|write_p
parameter_list|)
block|{
name|struct
name|mem_ref
modifier|*
modifier|*
name|aref
decl_stmt|;
comment|/* Do not record the same address twice.  */
for|for
control|(
name|aref
operator|=
operator|&
name|group
operator|->
name|refs
init|;
operator|*
name|aref
condition|;
name|aref
operator|=
operator|&
operator|(
operator|*
name|aref
operator|)
operator|->
name|next
control|)
block|{
comment|/* It does not have to be possible for write reference to reuse the read 	 prefetch, or vice versa.  */
if|if
condition|(
operator|!
name|WRITE_CAN_USE_READ_PREFETCH
operator|&&
name|write_p
operator|&&
operator|!
operator|(
operator|*
name|aref
operator|)
operator|->
name|write_p
condition|)
continue|continue;
if|if
condition|(
operator|!
name|READ_CAN_USE_WRITE_PREFETCH
operator|&&
operator|!
name|write_p
operator|&&
operator|(
operator|*
name|aref
operator|)
operator|->
name|write_p
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|*
name|aref
operator|)
operator|->
name|delta
operator|==
name|delta
condition|)
return|return;
block|}
operator|(
operator|*
name|aref
operator|)
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mem_ref
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|aref
operator|)
operator|->
name|stmt
operator|=
name|stmt
expr_stmt|;
operator|(
operator|*
name|aref
operator|)
operator|->
name|mem
operator|=
name|mem
expr_stmt|;
operator|(
operator|*
name|aref
operator|)
operator|->
name|delta
operator|=
name|delta
expr_stmt|;
operator|(
operator|*
name|aref
operator|)
operator|->
name|write_p
operator|=
name|write_p
expr_stmt|;
operator|(
operator|*
name|aref
operator|)
operator|->
name|prefetch_before
operator|=
name|PREFETCH_ALL
expr_stmt|;
operator|(
operator|*
name|aref
operator|)
operator|->
name|prefetch_mod
operator|=
literal|1
expr_stmt|;
operator|(
operator|*
name|aref
operator|)
operator|->
name|issue_prefetch_p
operator|=
name|false
expr_stmt|;
operator|(
operator|*
name|aref
operator|)
operator|->
name|group
operator|=
name|group
expr_stmt|;
operator|(
operator|*
name|aref
operator|)
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|dump_mem_ref
argument_list|(
name|dump_file
argument_list|,
operator|*
name|aref
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Release memory references in GROUPS.  */
end_comment

begin_function
specifier|static
name|void
name|release_mem_refs
parameter_list|(
name|struct
name|mem_ref_group
modifier|*
name|groups
parameter_list|)
block|{
name|struct
name|mem_ref_group
modifier|*
name|next_g
decl_stmt|;
name|struct
name|mem_ref
modifier|*
name|ref
decl_stmt|,
modifier|*
name|next_r
decl_stmt|;
for|for
control|(
init|;
name|groups
condition|;
name|groups
operator|=
name|next_g
control|)
block|{
name|next_g
operator|=
name|groups
operator|->
name|next
expr_stmt|;
for|for
control|(
name|ref
operator|=
name|groups
operator|->
name|refs
init|;
name|ref
condition|;
name|ref
operator|=
name|next_r
control|)
block|{
name|next_r
operator|=
name|ref
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|ref
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|groups
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* A structure used to pass arguments to idx_analyze_ref.  */
end_comment

begin_struct
struct|struct
name|ar_data
block|{
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
comment|/* Loop of the reference.  */
name|tree
name|stmt
decl_stmt|;
comment|/* Statement of the reference.  */
name|HOST_WIDE_INT
modifier|*
name|step
decl_stmt|;
comment|/* Step of the memory reference.  */
name|HOST_WIDE_INT
modifier|*
name|delta
decl_stmt|;
comment|/* Offset of the memory reference.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Analyzes a single INDEX of a memory reference to obtain information    described at analyze_ref.  Callback for for_each_index.  */
end_comment

begin_function
specifier|static
name|bool
name|idx_analyze_ref
parameter_list|(
name|tree
name|base
parameter_list|,
name|tree
modifier|*
name|index
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|ar_data
modifier|*
name|ar_data
init|=
name|data
decl_stmt|;
name|tree
name|ibase
decl_stmt|,
name|step
decl_stmt|,
name|stepsize
decl_stmt|;
name|HOST_WIDE_INT
name|istep
decl_stmt|,
name|idelta
init|=
literal|0
decl_stmt|,
name|imult
init|=
literal|1
decl_stmt|;
name|affine_iv
name|iv
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|MISALIGNED_INDIRECT_REF
operator|||
name|TREE_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|ALIGN_INDIRECT_REF
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|simple_iv
argument_list|(
name|ar_data
operator|->
name|loop
argument_list|,
name|ar_data
operator|->
name|stmt
argument_list|,
operator|*
name|index
argument_list|,
operator|&
name|iv
argument_list|,
name|false
argument_list|)
condition|)
return|return
name|false
return|;
name|ibase
operator|=
name|iv
operator|.
name|base
expr_stmt|;
name|step
operator|=
name|iv
operator|.
name|step
expr_stmt|;
if|if
condition|(
name|zero_p
argument_list|(
name|step
argument_list|)
condition|)
name|istep
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|cst_and_fits_in_hwi
argument_list|(
name|step
argument_list|)
condition|)
return|return
name|false
return|;
name|istep
operator|=
name|int_cst_value
argument_list|(
name|step
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ibase
argument_list|)
operator|==
name|PLUS_EXPR
operator|&&
name|cst_and_fits_in_hwi
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ibase
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|idelta
operator|=
name|int_cst_value
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ibase
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|ibase
operator|=
name|TREE_OPERAND
argument_list|(
name|ibase
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cst_and_fits_in_hwi
argument_list|(
name|ibase
argument_list|)
condition|)
block|{
name|idelta
operator|+=
name|int_cst_value
argument_list|(
name|ibase
argument_list|)
expr_stmt|;
name|ibase
operator|=
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|ibase
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|ARRAY_REF
condition|)
block|{
name|stepsize
operator|=
name|array_ref_element_size
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cst_and_fits_in_hwi
argument_list|(
name|stepsize
argument_list|)
condition|)
return|return
name|false
return|;
name|imult
operator|=
name|int_cst_value
argument_list|(
name|stepsize
argument_list|)
expr_stmt|;
name|istep
operator|*=
name|imult
expr_stmt|;
name|idelta
operator|*=
name|imult
expr_stmt|;
block|}
operator|*
name|ar_data
operator|->
name|step
operator|+=
name|istep
expr_stmt|;
operator|*
name|ar_data
operator|->
name|delta
operator|+=
name|idelta
expr_stmt|;
operator|*
name|index
operator|=
name|ibase
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Tries to express REF_P in shape&BASE + STEP * iter + DELTA, where DELTA and    STEP are integer constants and iter is number of iterations of LOOP.  The    reference occurs in statement STMT.  Strips nonaddressable component    references from REF_P.  */
end_comment

begin_function
specifier|static
name|bool
name|analyze_ref
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|tree
modifier|*
name|ref_p
parameter_list|,
name|tree
modifier|*
name|base
parameter_list|,
name|HOST_WIDE_INT
modifier|*
name|step
parameter_list|,
name|HOST_WIDE_INT
modifier|*
name|delta
parameter_list|,
name|tree
name|stmt
parameter_list|)
block|{
name|struct
name|ar_data
name|ar_data
decl_stmt|;
name|tree
name|off
decl_stmt|;
name|HOST_WIDE_INT
name|bit_offset
decl_stmt|;
name|tree
name|ref
init|=
operator|*
name|ref_p
decl_stmt|;
operator|*
name|step
operator|=
literal|0
expr_stmt|;
operator|*
name|delta
operator|=
literal|0
expr_stmt|;
comment|/* First strip off the component references.  Ignore bitfields.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
name|DECL_NONADDRESSABLE_P
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|ref
operator|=
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|ref_p
operator|=
name|ref
expr_stmt|;
for|for
control|(
init|;
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|COMPONENT_REF
condition|;
name|ref
operator|=
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
control|)
block|{
name|off
operator|=
name|DECL_FIELD_BIT_OFFSET
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|bit_offset
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|off
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|bit_offset
operator|%
name|BITS_PER_UNIT
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|*
name|delta
operator|+=
name|bit_offset
operator|/
name|BITS_PER_UNIT
expr_stmt|;
block|}
operator|*
name|base
operator|=
name|unshare_expr
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|ar_data
operator|.
name|loop
operator|=
name|loop
expr_stmt|;
name|ar_data
operator|.
name|stmt
operator|=
name|stmt
expr_stmt|;
name|ar_data
operator|.
name|step
operator|=
name|step
expr_stmt|;
name|ar_data
operator|.
name|delta
operator|=
name|delta
expr_stmt|;
return|return
name|for_each_index
argument_list|(
name|base
argument_list|,
name|idx_analyze_ref
argument_list|,
operator|&
name|ar_data
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Record a memory reference REF to the list REFS.  The reference occurs in    LOOP in statement STMT and it is write if WRITE_P.  */
end_comment

begin_function
specifier|static
name|void
name|gather_memory_references_ref
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|struct
name|mem_ref_group
modifier|*
modifier|*
name|refs
parameter_list|,
name|tree
name|ref
parameter_list|,
name|bool
name|write_p
parameter_list|,
name|tree
name|stmt
parameter_list|)
block|{
name|tree
name|base
decl_stmt|;
name|HOST_WIDE_INT
name|step
decl_stmt|,
name|delta
decl_stmt|;
name|struct
name|mem_ref_group
modifier|*
name|agrp
decl_stmt|;
if|if
condition|(
operator|!
name|analyze_ref
argument_list|(
name|loop
argument_list|,
operator|&
name|ref
argument_list|,
operator|&
name|base
argument_list|,
operator|&
name|step
argument_list|,
operator|&
name|delta
argument_list|,
name|stmt
argument_list|)
condition|)
return|return;
comment|/* Now we know that REF =&BASE + STEP * iter + DELTA, where DELTA and STEP      are integer constants.  */
name|agrp
operator|=
name|find_or_create_group
argument_list|(
name|refs
argument_list|,
name|base
argument_list|,
name|step
argument_list|)
expr_stmt|;
name|record_ref
argument_list|(
name|agrp
argument_list|,
name|stmt
argument_list|,
name|ref
argument_list|,
name|delta
argument_list|,
name|write_p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record the suitable memory references in LOOP.  */
end_comment

begin_function
specifier|static
name|struct
name|mem_ref_group
modifier|*
name|gather_memory_references
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|basic_block
modifier|*
name|body
init|=
name|get_loop_body_in_dom_order
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|tree
name|stmt
decl_stmt|,
name|lhs
decl_stmt|,
name|rhs
decl_stmt|;
name|struct
name|mem_ref_group
modifier|*
name|refs
init|=
name|NULL
decl_stmt|;
comment|/* Scan the loop body in order, so that the former references precede the      later ones.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loop
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
block|{
name|bb
operator|=
name|body
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|loop_father
operator|!=
name|loop
condition|)
continue|continue;
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
block|{
name|stmt
operator|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|!=
name|MODIFY_EXPR
condition|)
continue|continue;
name|lhs
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|REFERENCE_CLASS_P
argument_list|(
name|rhs
argument_list|)
condition|)
name|gather_memory_references_ref
argument_list|(
name|loop
argument_list|,
operator|&
name|refs
argument_list|,
name|rhs
argument_list|,
name|false
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|REFERENCE_CLASS_P
argument_list|(
name|lhs
argument_list|)
condition|)
name|gather_memory_references_ref
argument_list|(
name|loop
argument_list|,
operator|&
name|refs
argument_list|,
name|lhs
argument_list|,
name|true
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|body
argument_list|)
expr_stmt|;
return|return
name|refs
return|;
block|}
end_function

begin_comment
comment|/* Prune the prefetch candidate REF using the self-reuse.  */
end_comment

begin_function
specifier|static
name|void
name|prune_ref_by_self_reuse
parameter_list|(
name|struct
name|mem_ref
modifier|*
name|ref
parameter_list|)
block|{
name|HOST_WIDE_INT
name|step
init|=
name|ref
operator|->
name|group
operator|->
name|step
decl_stmt|;
name|bool
name|backward
init|=
name|step
operator|<
literal|0
decl_stmt|;
if|if
condition|(
name|step
operator|==
literal|0
condition|)
block|{
comment|/* Prefetch references to invariant address just once.  */
name|ref
operator|->
name|prefetch_before
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|backward
condition|)
name|step
operator|=
operator|-
name|step
expr_stmt|;
if|if
condition|(
name|step
operator|>
name|PREFETCH_BLOCK
condition|)
return|return;
if|if
condition|(
operator|(
name|backward
operator|&&
name|HAVE_BACKWARD_PREFETCH
operator|)
operator|||
operator|(
operator|!
name|backward
operator|&&
name|HAVE_FORWARD_PREFETCH
operator|)
condition|)
block|{
name|ref
operator|->
name|prefetch_before
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|ref
operator|->
name|prefetch_mod
operator|=
name|PREFETCH_BLOCK
operator|/
name|step
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Divides X by BY, rounding down.  */
end_comment

begin_function
specifier|static
name|HOST_WIDE_INT
name|ddown
parameter_list|(
name|HOST_WIDE_INT
name|x
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|by
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|by
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|>=
literal|0
condition|)
return|return
name|x
operator|/
name|by
return|;
else|else
return|return
operator|(
name|x
operator|+
name|by
operator|-
literal|1
operator|)
operator|/
name|by
return|;
block|}
end_function

begin_comment
comment|/* Prune the prefetch candidate REF using the reuse with BY.    If BY_IS_BEFORE is true, BY is before REF in the loop.  */
end_comment

begin_function
specifier|static
name|void
name|prune_ref_by_group_reuse
parameter_list|(
name|struct
name|mem_ref
modifier|*
name|ref
parameter_list|,
name|struct
name|mem_ref
modifier|*
name|by
parameter_list|,
name|bool
name|by_is_before
parameter_list|)
block|{
name|HOST_WIDE_INT
name|step
init|=
name|ref
operator|->
name|group
operator|->
name|step
decl_stmt|;
name|bool
name|backward
init|=
name|step
operator|<
literal|0
decl_stmt|;
name|HOST_WIDE_INT
name|delta_r
init|=
name|ref
operator|->
name|delta
decl_stmt|,
name|delta_b
init|=
name|by
operator|->
name|delta
decl_stmt|;
name|HOST_WIDE_INT
name|delta
init|=
name|delta_b
operator|-
name|delta_r
decl_stmt|;
name|HOST_WIDE_INT
name|hit_from
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|prefetch_before
decl_stmt|,
name|prefetch_block
decl_stmt|;
if|if
condition|(
name|delta
operator|==
literal|0
condition|)
block|{
comment|/* If the references has the same address, only prefetch the 	 former.  */
if|if
condition|(
name|by_is_before
condition|)
name|ref
operator|->
name|prefetch_before
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|step
condition|)
block|{
comment|/* If the reference addresses are invariant and fall into the 	 same cache line, prefetch just the first one.  */
if|if
condition|(
operator|!
name|by_is_before
condition|)
return|return;
if|if
condition|(
name|ddown
argument_list|(
name|ref
operator|->
name|delta
argument_list|,
name|PREFETCH_BLOCK
argument_list|)
operator|!=
name|ddown
argument_list|(
name|by
operator|->
name|delta
argument_list|,
name|PREFETCH_BLOCK
argument_list|)
condition|)
return|return;
name|ref
operator|->
name|prefetch_before
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* Only prune the reference that is behind in the array.  */
if|if
condition|(
name|backward
condition|)
block|{
if|if
condition|(
name|delta
operator|>
literal|0
condition|)
return|return;
comment|/* Transform the data so that we may assume that the accesses 	 are forward.  */
name|delta
operator|=
operator|-
name|delta
expr_stmt|;
name|step
operator|=
operator|-
name|step
expr_stmt|;
name|delta_r
operator|=
name|PREFETCH_BLOCK
operator|-
literal|1
operator|-
name|delta_r
expr_stmt|;
name|delta_b
operator|=
name|PREFETCH_BLOCK
operator|-
literal|1
operator|-
name|delta_b
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|delta
operator|<
literal|0
condition|)
return|return;
block|}
comment|/* Check whether the two references are likely to hit the same cache      line, and how distant the iterations in that it occurs are from      each other.  */
if|if
condition|(
name|step
operator|<=
name|PREFETCH_BLOCK
condition|)
block|{
comment|/* The accesses are sure to meet.  Let us check when.  */
name|hit_from
operator|=
name|ddown
argument_list|(
name|delta_b
argument_list|,
name|PREFETCH_BLOCK
argument_list|)
operator|*
name|PREFETCH_BLOCK
expr_stmt|;
name|prefetch_before
operator|=
operator|(
name|hit_from
operator|-
name|delta_r
operator|+
name|step
operator|-
literal|1
operator|)
operator|/
name|step
expr_stmt|;
if|if
condition|(
name|prefetch_before
operator|<
name|ref
operator|->
name|prefetch_before
condition|)
name|ref
operator|->
name|prefetch_before
operator|=
name|prefetch_before
expr_stmt|;
return|return;
block|}
comment|/* A more complicated case.  First let us ensure that size of cache line      and step are coprime (here we assume that PREFETCH_BLOCK is a power      of two.  */
name|prefetch_block
operator|=
name|PREFETCH_BLOCK
expr_stmt|;
while|while
condition|(
operator|(
name|step
operator|&
literal|1
operator|)
operator|==
literal|0
operator|&&
name|prefetch_block
operator|>
literal|1
condition|)
block|{
name|step
operator|>>=
literal|1
expr_stmt|;
name|prefetch_block
operator|>>=
literal|1
expr_stmt|;
name|delta
operator|>>=
literal|1
expr_stmt|;
block|}
comment|/* Now step> prefetch_block, and step and prefetch_block are coprime.      Determine the probability that the accesses hit the same cache line.  */
name|prefetch_before
operator|=
name|delta
operator|/
name|step
expr_stmt|;
name|delta
operator|%=
name|step
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|delta
operator|<=
operator|(
name|prefetch_block
operator|*
name|ACCEPTABLE_MISS_RATE
operator|/
literal|1000
operator|)
condition|)
block|{
if|if
condition|(
name|prefetch_before
operator|<
name|ref
operator|->
name|prefetch_before
condition|)
name|ref
operator|->
name|prefetch_before
operator|=
name|prefetch_before
expr_stmt|;
return|return;
block|}
comment|/* Try also the following iteration.  */
name|prefetch_before
operator|++
expr_stmt|;
name|delta
operator|=
name|step
operator|-
name|delta
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|delta
operator|<=
operator|(
name|prefetch_block
operator|*
name|ACCEPTABLE_MISS_RATE
operator|/
literal|1000
operator|)
condition|)
block|{
if|if
condition|(
name|prefetch_before
operator|<
name|ref
operator|->
name|prefetch_before
condition|)
name|ref
operator|->
name|prefetch_before
operator|=
name|prefetch_before
expr_stmt|;
return|return;
block|}
comment|/* The ref probably does not reuse by.  */
return|return;
block|}
end_function

begin_comment
comment|/* Prune the prefetch candidate REF using the reuses with other references    in REFS.  */
end_comment

begin_function
specifier|static
name|void
name|prune_ref_by_reuse
parameter_list|(
name|struct
name|mem_ref
modifier|*
name|ref
parameter_list|,
name|struct
name|mem_ref
modifier|*
name|refs
parameter_list|)
block|{
name|struct
name|mem_ref
modifier|*
name|prune_by
decl_stmt|;
name|bool
name|before
init|=
name|true
decl_stmt|;
name|prune_ref_by_self_reuse
argument_list|(
name|ref
argument_list|)
expr_stmt|;
for|for
control|(
name|prune_by
operator|=
name|refs
init|;
name|prune_by
condition|;
name|prune_by
operator|=
name|prune_by
operator|->
name|next
control|)
block|{
if|if
condition|(
name|prune_by
operator|==
name|ref
condition|)
block|{
name|before
operator|=
name|false
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|WRITE_CAN_USE_READ_PREFETCH
operator|&&
name|ref
operator|->
name|write_p
operator|&&
operator|!
name|prune_by
operator|->
name|write_p
condition|)
continue|continue;
if|if
condition|(
operator|!
name|READ_CAN_USE_WRITE_PREFETCH
operator|&&
operator|!
name|ref
operator|->
name|write_p
operator|&&
name|prune_by
operator|->
name|write_p
condition|)
continue|continue;
name|prune_ref_by_group_reuse
argument_list|(
name|ref
argument_list|,
name|prune_by
argument_list|,
name|before
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Prune the prefetch candidates in GROUP using the reuse analysis.  */
end_comment

begin_function
specifier|static
name|void
name|prune_group_by_reuse
parameter_list|(
name|struct
name|mem_ref_group
modifier|*
name|group
parameter_list|)
block|{
name|struct
name|mem_ref
modifier|*
name|ref_pruned
decl_stmt|;
for|for
control|(
name|ref_pruned
operator|=
name|group
operator|->
name|refs
init|;
name|ref_pruned
condition|;
name|ref_pruned
operator|=
name|ref_pruned
operator|->
name|next
control|)
block|{
name|prune_ref_by_reuse
argument_list|(
name|ref_pruned
argument_list|,
name|group
operator|->
name|refs
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Reference %p:"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ref_pruned
argument_list|)
expr_stmt|;
if|if
condition|(
name|ref_pruned
operator|->
name|prefetch_before
operator|==
name|PREFETCH_ALL
operator|&&
name|ref_pruned
operator|->
name|prefetch_mod
operator|==
literal|1
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" no restrictions"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ref_pruned
operator|->
name|prefetch_before
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" do not prefetch"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ref_pruned
operator|->
name|prefetch_before
operator|<=
name|ref_pruned
operator|->
name|prefetch_mod
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" prefetch once"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|ref_pruned
operator|->
name|prefetch_before
operator|!=
name|PREFETCH_ALL
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" prefetch before "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|ref_pruned
operator|->
name|prefetch_before
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ref_pruned
operator|->
name|prefetch_mod
operator|!=
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" prefetch mod "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|ref_pruned
operator|->
name|prefetch_mod
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Prune the list of prefetch candidates GROUPS using the reuse analysis.  */
end_comment

begin_function
specifier|static
name|void
name|prune_by_reuse
parameter_list|(
name|struct
name|mem_ref_group
modifier|*
name|groups
parameter_list|)
block|{
for|for
control|(
init|;
name|groups
condition|;
name|groups
operator|=
name|groups
operator|->
name|next
control|)
name|prune_group_by_reuse
argument_list|(
name|groups
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns true if we should issue prefetch for REF.  */
end_comment

begin_function
specifier|static
name|bool
name|should_issue_prefetch_p
parameter_list|(
name|struct
name|mem_ref
modifier|*
name|ref
parameter_list|)
block|{
comment|/* For now do not issue prefetches for only first few of the      iterations.  */
if|if
condition|(
name|ref
operator|->
name|prefetch_before
operator|!=
name|PREFETCH_ALL
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Decide which of the prefetch candidates in GROUPS to prefetch.    AHEAD is the number of iterations to prefetch ahead (which corresponds    to the number of simultaneous instances of one prefetch running at a    time).  UNROLL_FACTOR is the factor by that the loop is going to be    unrolled.  Returns true if there is anything to prefetch.  */
end_comment

begin_function
specifier|static
name|bool
name|schedule_prefetches
parameter_list|(
name|struct
name|mem_ref_group
modifier|*
name|groups
parameter_list|,
name|unsigned
name|unroll_factor
parameter_list|,
name|unsigned
name|ahead
parameter_list|)
block|{
name|unsigned
name|max_prefetches
decl_stmt|,
name|n_prefetches
decl_stmt|;
name|struct
name|mem_ref
modifier|*
name|ref
decl_stmt|;
name|bool
name|any
init|=
name|false
decl_stmt|;
name|max_prefetches
operator|=
operator|(
name|SIMULTANEOUS_PREFETCHES
operator|*
name|unroll_factor
operator|)
operator|/
name|ahead
expr_stmt|;
if|if
condition|(
name|max_prefetches
operator|>
operator|(
name|unsigned
operator|)
name|SIMULTANEOUS_PREFETCHES
condition|)
name|max_prefetches
operator|=
name|SIMULTANEOUS_PREFETCHES
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Max prefetches to issue: %d.\n"
argument_list|,
name|max_prefetches
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|max_prefetches
condition|)
return|return
name|false
return|;
comment|/* For now we just take memory references one by one and issue      prefetches for as many as possible.  The groups are sorted      starting with the largest step, since the references with      large step are more likely to cause many cache misses.  */
for|for
control|(
init|;
name|groups
condition|;
name|groups
operator|=
name|groups
operator|->
name|next
control|)
for|for
control|(
name|ref
operator|=
name|groups
operator|->
name|refs
init|;
name|ref
condition|;
name|ref
operator|=
name|ref
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|should_issue_prefetch_p
argument_list|(
name|ref
argument_list|)
condition|)
continue|continue;
name|ref
operator|->
name|issue_prefetch_p
operator|=
name|true
expr_stmt|;
comment|/* If prefetch_mod is less then unroll_factor, we need to insert 	   several prefetches for the reference.  */
name|n_prefetches
operator|=
operator|(
operator|(
name|unroll_factor
operator|+
name|ref
operator|->
name|prefetch_mod
operator|-
literal|1
operator|)
operator|/
name|ref
operator|->
name|prefetch_mod
operator|)
expr_stmt|;
if|if
condition|(
name|max_prefetches
operator|<=
name|n_prefetches
condition|)
return|return
name|true
return|;
name|max_prefetches
operator|-=
name|n_prefetches
expr_stmt|;
name|any
operator|=
name|true
expr_stmt|;
block|}
return|return
name|any
return|;
block|}
end_function

begin_comment
comment|/* Determine whether there is any reference suitable for prefetching    in GROUPS.  */
end_comment

begin_function
specifier|static
name|bool
name|anything_to_prefetch_p
parameter_list|(
name|struct
name|mem_ref_group
modifier|*
name|groups
parameter_list|)
block|{
name|struct
name|mem_ref
modifier|*
name|ref
decl_stmt|;
for|for
control|(
init|;
name|groups
condition|;
name|groups
operator|=
name|groups
operator|->
name|next
control|)
for|for
control|(
name|ref
operator|=
name|groups
operator|->
name|refs
init|;
name|ref
condition|;
name|ref
operator|=
name|ref
operator|->
name|next
control|)
if|if
condition|(
name|should_issue_prefetch_p
argument_list|(
name|ref
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Issue prefetches for the reference REF into loop as decided before.    HEAD is the number of iterations to prefetch ahead.  UNROLL_FACTOR    is the factor by which LOOP was unrolled.  */
end_comment

begin_function
specifier|static
name|void
name|issue_prefetch_ref
parameter_list|(
name|struct
name|mem_ref
modifier|*
name|ref
parameter_list|,
name|unsigned
name|unroll_factor
parameter_list|,
name|unsigned
name|ahead
parameter_list|)
block|{
name|HOST_WIDE_INT
name|delta
decl_stmt|;
name|tree
name|addr
decl_stmt|,
name|addr_base
decl_stmt|,
name|prefetch
decl_stmt|,
name|params
decl_stmt|,
name|write_p
decl_stmt|;
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|unsigned
name|n_prefetches
decl_stmt|,
name|ap
decl_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Issued prefetch for %p.\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ref
argument_list|)
expr_stmt|;
name|bsi
operator|=
name|bsi_for_stmt
argument_list|(
name|ref
operator|->
name|stmt
argument_list|)
expr_stmt|;
name|n_prefetches
operator|=
operator|(
operator|(
name|unroll_factor
operator|+
name|ref
operator|->
name|prefetch_mod
operator|-
literal|1
operator|)
operator|/
name|ref
operator|->
name|prefetch_mod
operator|)
expr_stmt|;
name|addr_base
operator|=
name|build_fold_addr_expr_with_type
argument_list|(
name|ref
operator|->
name|mem
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|addr_base
operator|=
name|force_gimple_operand_bsi
argument_list|(
operator|&
name|bsi
argument_list|,
name|unshare_expr
argument_list|(
name|addr_base
argument_list|)
argument_list|,
name|true
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|ap
operator|=
literal|0
init|;
name|ap
operator|<
name|n_prefetches
condition|;
name|ap
operator|++
control|)
block|{
comment|/* Determine the address to prefetch.  */
name|delta
operator|=
operator|(
name|ahead
operator|+
name|ap
operator|*
name|ref
operator|->
name|prefetch_mod
operator|)
operator|*
name|ref
operator|->
name|group
operator|->
name|step
expr_stmt|;
name|addr
operator|=
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|addr_base
argument_list|,
name|build_int_cst
argument_list|(
name|ptr_type_node
argument_list|,
name|delta
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|=
name|force_gimple_operand_bsi
argument_list|(
operator|&
name|bsi
argument_list|,
name|unshare_expr
argument_list|(
name|addr
argument_list|)
argument_list|,
name|true
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Create the prefetch instruction.  */
name|write_p
operator|=
name|ref
operator|->
name|write_p
condition|?
name|integer_one_node
else|:
name|integer_zero_node
expr_stmt|;
name|params
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|addr
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|write_p
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
name|prefetch
operator|=
name|build_function_call_expr
argument_list|(
name|built_in_decls
index|[
name|BUILT_IN_PREFETCH
index|]
argument_list|,
name|params
argument_list|)
expr_stmt|;
name|bsi_insert_before
argument_list|(
operator|&
name|bsi
argument_list|,
name|prefetch
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Issue prefetches for the references in GROUPS into loop as decided before.    HEAD is the number of iterations to prefetch ahead.  UNROLL_FACTOR is the    factor by that LOOP was unrolled.  */
end_comment

begin_function
specifier|static
name|void
name|issue_prefetches
parameter_list|(
name|struct
name|mem_ref_group
modifier|*
name|groups
parameter_list|,
name|unsigned
name|unroll_factor
parameter_list|,
name|unsigned
name|ahead
parameter_list|)
block|{
name|struct
name|mem_ref
modifier|*
name|ref
decl_stmt|;
for|for
control|(
init|;
name|groups
condition|;
name|groups
operator|=
name|groups
operator|->
name|next
control|)
for|for
control|(
name|ref
operator|=
name|groups
operator|->
name|refs
init|;
name|ref
condition|;
name|ref
operator|=
name|ref
operator|->
name|next
control|)
if|if
condition|(
name|ref
operator|->
name|issue_prefetch_p
condition|)
name|issue_prefetch_ref
argument_list|(
name|ref
argument_list|,
name|unroll_factor
argument_list|,
name|ahead
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Determines whether we can profitably unroll LOOP FACTOR times, and if    this is the case, fill in DESC by the description of number of    iterations.  */
end_comment

begin_function
specifier|static
name|bool
name|should_unroll_loop_p
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|struct
name|tree_niter_desc
modifier|*
name|desc
parameter_list|,
name|unsigned
name|factor
parameter_list|)
block|{
if|if
condition|(
operator|!
name|can_unroll_loop_p
argument_list|(
name|loop
argument_list|,
name|factor
argument_list|,
name|desc
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* We only consider loops without control flow for unrolling.  This is not      a hard restriction -- tree_unroll_loop works with arbitrary loops      as well; but the unrolling/prefetching is usually more profitable for      loops consisting of a single basic block, and we want to limit the      code growth.  */
if|if
condition|(
name|loop
operator|->
name|num_nodes
operator|>
literal|2
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Determine the coefficient by that unroll LOOP, from the information    contained in the list of memory references REFS.  Description of    umber of iterations of LOOP is stored to DESC.  AHEAD is the number    of iterations ahead that we need to prefetch.  NINSNS is number of    insns of the LOOP.  */
end_comment

begin_function
specifier|static
name|unsigned
name|determine_unroll_factor
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|struct
name|mem_ref_group
modifier|*
name|refs
parameter_list|,
name|unsigned
name|ahead
parameter_list|,
name|unsigned
name|ninsns
parameter_list|,
name|struct
name|tree_niter_desc
modifier|*
name|desc
parameter_list|)
block|{
name|unsigned
name|upper_bound
decl_stmt|,
name|size_factor
decl_stmt|,
name|constraint_factor
decl_stmt|;
name|unsigned
name|factor
decl_stmt|,
name|max_mod_constraint
decl_stmt|,
name|ahead_factor
decl_stmt|;
name|struct
name|mem_ref_group
modifier|*
name|agp
decl_stmt|;
name|struct
name|mem_ref
modifier|*
name|ref
decl_stmt|;
name|upper_bound
operator|=
name|PARAM_VALUE
argument_list|(
name|PARAM_MAX_UNROLL_TIMES
argument_list|)
expr_stmt|;
comment|/* First check whether the loop is not too large to unroll.  */
name|size_factor
operator|=
name|PARAM_VALUE
argument_list|(
name|PARAM_MAX_UNROLLED_INSNS
argument_list|)
operator|/
name|ninsns
expr_stmt|;
if|if
condition|(
name|size_factor
operator|<=
literal|1
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|size_factor
operator|<
name|upper_bound
condition|)
name|upper_bound
operator|=
name|size_factor
expr_stmt|;
name|max_mod_constraint
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|agp
operator|=
name|refs
init|;
name|agp
condition|;
name|agp
operator|=
name|agp
operator|->
name|next
control|)
for|for
control|(
name|ref
operator|=
name|agp
operator|->
name|refs
init|;
name|ref
condition|;
name|ref
operator|=
name|ref
operator|->
name|next
control|)
if|if
condition|(
name|should_issue_prefetch_p
argument_list|(
name|ref
argument_list|)
operator|&&
name|ref
operator|->
name|prefetch_mod
operator|>
name|max_mod_constraint
condition|)
name|max_mod_constraint
operator|=
name|ref
operator|->
name|prefetch_mod
expr_stmt|;
comment|/* Set constraint_factor as large as needed to be able to satisfy the      largest modulo constraint.  */
name|constraint_factor
operator|=
name|max_mod_constraint
expr_stmt|;
comment|/* If ahead is too large in comparison with the number of available      prefetches, unroll the loop as much as needed to be able to prefetch      at least partially some of the references in the loop.  */
name|ahead_factor
operator|=
operator|(
operator|(
name|ahead
operator|+
name|SIMULTANEOUS_PREFETCHES
operator|-
literal|1
operator|)
operator|/
name|SIMULTANEOUS_PREFETCHES
operator|)
expr_stmt|;
comment|/* Unroll as much as useful, but bound the code size growth.  */
if|if
condition|(
name|constraint_factor
operator|<
name|ahead_factor
condition|)
name|factor
operator|=
name|ahead_factor
expr_stmt|;
else|else
name|factor
operator|=
name|constraint_factor
expr_stmt|;
if|if
condition|(
name|factor
operator|>
name|upper_bound
condition|)
name|factor
operator|=
name|upper_bound
expr_stmt|;
if|if
condition|(
operator|!
name|should_unroll_loop_p
argument_list|(
name|loop
argument_list|,
name|desc
argument_list|,
name|factor
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
name|factor
return|;
block|}
end_function

begin_comment
comment|/* Issue prefetch instructions for array references in LOOP.  Returns    true if the LOOP was unrolled.  LOOPS is the array containing all    loops.  */
end_comment

begin_function
specifier|static
name|bool
name|loop_prefetch_arrays
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|,
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|struct
name|mem_ref_group
modifier|*
name|refs
decl_stmt|;
name|unsigned
name|ahead
decl_stmt|,
name|ninsns
decl_stmt|,
name|unroll_factor
decl_stmt|;
name|struct
name|tree_niter_desc
name|desc
decl_stmt|;
name|bool
name|unrolled
init|=
name|false
decl_stmt|;
comment|/* Step 1: gather the memory references.  */
name|refs
operator|=
name|gather_memory_references
argument_list|(
name|loop
argument_list|)
expr_stmt|;
comment|/* Step 2: estimate the reuse effects.  */
name|prune_by_reuse
argument_list|(
name|refs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|anything_to_prefetch_p
argument_list|(
name|refs
argument_list|)
condition|)
goto|goto
name|fail
goto|;
comment|/* Step 3: determine the ahead and unroll factor.  */
comment|/* FIXME: We should use not size of the loop, but the average number of      instructions executed per iteration of the loop.  */
name|ninsns
operator|=
name|tree_num_loop_insns
argument_list|(
name|loop
argument_list|)
expr_stmt|;
name|ahead
operator|=
operator|(
name|PREFETCH_LATENCY
operator|+
name|ninsns
operator|-
literal|1
operator|)
operator|/
name|ninsns
expr_stmt|;
name|unroll_factor
operator|=
name|determine_unroll_factor
argument_list|(
name|loop
argument_list|,
name|refs
argument_list|,
name|ahead
argument_list|,
name|ninsns
argument_list|,
operator|&
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Ahead %d, unroll factor %d\n"
argument_list|,
name|ahead
argument_list|,
name|unroll_factor
argument_list|)
expr_stmt|;
comment|/* If the loop rolls less than the required unroll factor, prefetching      is useless.  */
if|if
condition|(
name|unroll_factor
operator|>
literal|1
operator|&&
name|cst_and_fits_in_hwi
argument_list|(
name|desc
operator|.
name|niter
argument_list|)
operator|&&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|int_cst_value
argument_list|(
name|desc
operator|.
name|niter
argument_list|)
operator|<
name|unroll_factor
condition|)
goto|goto
name|fail
goto|;
comment|/* Step 4: what to prefetch?  */
if|if
condition|(
operator|!
name|schedule_prefetches
argument_list|(
name|refs
argument_list|,
name|unroll_factor
argument_list|,
name|ahead
argument_list|)
condition|)
goto|goto
name|fail
goto|;
comment|/* Step 5: unroll the loop.  TODO -- peeling of first and last few      iterations so that we do not issue superfluous prefetches.  */
if|if
condition|(
name|unroll_factor
operator|!=
literal|1
condition|)
block|{
name|tree_unroll_loop
argument_list|(
name|loops
argument_list|,
name|loop
argument_list|,
name|unroll_factor
argument_list|,
name|single_dom_exit
argument_list|(
name|loop
argument_list|)
argument_list|,
operator|&
name|desc
argument_list|)
expr_stmt|;
name|unrolled
operator|=
name|true
expr_stmt|;
block|}
comment|/* Step 6: issue the prefetches.  */
name|issue_prefetches
argument_list|(
name|refs
argument_list|,
name|unroll_factor
argument_list|,
name|ahead
argument_list|)
expr_stmt|;
name|fail
label|:
name|release_mem_refs
argument_list|(
name|refs
argument_list|)
expr_stmt|;
return|return
name|unrolled
return|;
block|}
end_function

begin_comment
comment|/* Issue prefetch instructions for array references in LOOPS.  */
end_comment

begin_function
name|unsigned
name|int
name|tree_ssa_prefetch_arrays
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|bool
name|unrolled
init|=
name|false
decl_stmt|;
name|int
name|todo_flags
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|HAVE_prefetch
comment|/* It is possible to ask compiler for say -mtune=i486 -march=pentium4. 	 -mtune=i486 causes us having PREFETCH_BLOCK 0, since this is part 	 of processor costs and i486 does not have prefetch, but 	 -march=pentium4 causes HAVE_prefetch to be true.  Ugh.  */
operator|||
name|PREFETCH_BLOCK
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|initialize_original_copy_tables
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|built_in_decls
index|[
name|BUILT_IN_PREFETCH
index|]
condition|)
block|{
name|tree
name|type
init|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|const_ptr_type_node
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|decl
init|=
name|lang_hooks
operator|.
name|builtin_function
argument_list|(
literal|"__builtin_prefetch"
argument_list|,
name|type
argument_list|,
name|BUILT_IN_PREFETCH
argument_list|,
name|BUILT_IN_NORMAL
argument_list|,
name|NULL
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|DECL_IS_NOVOPS
argument_list|(
name|decl
argument_list|)
operator|=
name|true
expr_stmt|;
name|built_in_decls
index|[
name|BUILT_IN_PREFETCH
index|]
operator|=
name|decl
expr_stmt|;
block|}
comment|/* We assume that size of cache line is a power of two, so verify this      here.  */
name|gcc_assert
argument_list|(
operator|(
name|PREFETCH_BLOCK
operator|&
operator|(
name|PREFETCH_BLOCK
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|loops
operator|->
name|num
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|loop
operator|=
name|loops
operator|->
name|parray
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Processing loop %d:\n"
argument_list|,
name|loop
operator|->
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop
condition|)
name|unrolled
operator||=
name|loop_prefetch_arrays
argument_list|(
name|loops
argument_list|,
name|loop
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|unrolled
condition|)
block|{
name|scev_reset
argument_list|()
expr_stmt|;
name|todo_flags
operator||=
name|TODO_cleanup_cfg
expr_stmt|;
block|}
name|free_original_copy_tables
argument_list|()
expr_stmt|;
return|return
name|todo_flags
return|;
block|}
end_function

end_unit

