begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Data flow functions for trees.    Copyright (C) 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.    Contributed by Diego Novillo<dnovillo@redhat.com>  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"pointer-set.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"tree-dump.h"
end_include

begin_include
include|#
directive|include
file|"tree-gimple.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"tree-inline.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"convert.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_include
include|#
directive|include
file|"cgraph.h"
end_include

begin_comment
comment|/* Build and maintain data flow information for trees.  */
end_comment

begin_comment
comment|/* Counters used to display DFA and SSA statistics.  */
end_comment

begin_struct
struct|struct
name|dfa_stats_d
block|{
name|long
name|num_stmt_anns
decl_stmt|;
name|long
name|num_var_anns
decl_stmt|;
name|long
name|num_defs
decl_stmt|;
name|long
name|num_uses
decl_stmt|;
name|long
name|num_phis
decl_stmt|;
name|long
name|num_phi_args
decl_stmt|;
name|int
name|max_num_phi_args
decl_stmt|;
name|long
name|num_v_may_defs
decl_stmt|;
name|long
name|num_vuses
decl_stmt|;
name|long
name|num_v_must_defs
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Local functions.  */
end_comment

begin_function_decl
specifier|static
name|void
name|collect_dfa_stats
parameter_list|(
name|struct
name|dfa_stats_d
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|collect_dfa_stats_r
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|find_vars_r
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Global declarations.  */
end_comment

begin_comment
comment|/* Array of all variables referenced in the function.  */
end_comment

begin_decl_stmt
name|htab_t
name|referenced_vars
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default definition for this symbols.  If set for symbol, it    means that the first reference to this variable in the function is a    USE or a VUSE.  In those cases, the SSA renamer creates an SSA name    for this variable with an empty defining statement.  */
end_comment

begin_decl_stmt
name|htab_t
name|default_defs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*--------------------------------------------------------------------------- 			Dataflow analysis (DFA) routines ---------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/* Find all the variables referenced in the function.  This function    builds the global arrays REFERENCED_VARS and CALL_CLOBBERED_VARS.     Note that this function does not look for statement operands, it simply    determines what variables are referenced in the program and detects    various attributes for each variable used by alias analysis and the    optimizer.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|find_referenced_vars
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|block_stmt_iterator
name|si
decl_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
for|for
control|(
name|si
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|si
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|si
argument_list|)
control|)
block|{
name|tree
modifier|*
name|stmt_p
init|=
name|bsi_stmt_ptr
argument_list|(
name|si
argument_list|)
decl_stmt|;
name|walk_tree
argument_list|(
name|stmt_p
argument_list|,
name|find_vars_r
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_referenced_vars
init|=
block|{
name|NULL
block|,
comment|/* name */
name|NULL
block|,
comment|/* gate */
name|find_referenced_vars
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
name|TV_FIND_REFERENCED_VARS
block|,
comment|/* tv_id */
name|PROP_gimple_leh
operator||
name|PROP_cfg
block|,
comment|/* properties_required */
name|PROP_referenced_vars
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
literal|0
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*--------------------------------------------------------------------------- 			    Manage annotations ---------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/* Create a new annotation for a _DECL node T.  */
end_comment

begin_function
name|var_ann_t
name|create_var_ann
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|var_ann_t
name|ann
decl_stmt|;
name|gcc_assert
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|DECL_P
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|t
operator|->
name|common
operator|.
name|ann
operator|||
name|t
operator|->
name|common
operator|.
name|ann
operator|->
name|common
operator|.
name|type
operator|==
name|VAR_ANN
argument_list|)
expr_stmt|;
name|ann
operator|=
name|GGC_CNEW
argument_list|(
expr|struct
name|var_ann_d
argument_list|)
expr_stmt|;
name|ann
operator|->
name|common
operator|.
name|type
operator|=
name|VAR_ANN
expr_stmt|;
name|t
operator|->
name|common
operator|.
name|ann
operator|=
operator|(
name|tree_ann_t
operator|)
name|ann
expr_stmt|;
return|return
name|ann
return|;
block|}
end_function

begin_comment
comment|/* Create a new annotation for a FUNCTION_DECL node T.  */
end_comment

begin_function
name|function_ann_t
name|create_function_ann
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|function_ann_t
name|ann
decl_stmt|;
name|gcc_assert
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_DECL
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|t
operator|->
name|common
operator|.
name|ann
operator|||
name|t
operator|->
name|common
operator|.
name|ann
operator|->
name|common
operator|.
name|type
operator|==
name|FUNCTION_ANN
argument_list|)
expr_stmt|;
name|ann
operator|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ann
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
name|ann
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ann
argument_list|)
argument_list|)
expr_stmt|;
name|ann
operator|->
name|common
operator|.
name|type
operator|=
name|FUNCTION_ANN
expr_stmt|;
name|t
operator|->
name|common
operator|.
name|ann
operator|=
operator|(
name|tree_ann_t
operator|)
name|ann
expr_stmt|;
return|return
name|ann
return|;
block|}
end_function

begin_comment
comment|/* Create a new annotation for a statement node T.  */
end_comment

begin_function
name|stmt_ann_t
name|create_stmt_ann
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|stmt_ann_t
name|ann
decl_stmt|;
name|gcc_assert
argument_list|(
name|is_gimple_stmt
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|t
operator|->
name|common
operator|.
name|ann
operator|||
name|t
operator|->
name|common
operator|.
name|ann
operator|->
name|common
operator|.
name|type
operator|==
name|STMT_ANN
argument_list|)
expr_stmt|;
name|ann
operator|=
name|GGC_CNEW
argument_list|(
expr|struct
name|stmt_ann_d
argument_list|)
expr_stmt|;
name|ann
operator|->
name|common
operator|.
name|type
operator|=
name|STMT_ANN
expr_stmt|;
comment|/* Since we just created the annotation, mark the statement modified.  */
name|ann
operator|->
name|modified
operator|=
name|true
expr_stmt|;
name|t
operator|->
name|common
operator|.
name|ann
operator|=
operator|(
name|tree_ann_t
operator|)
name|ann
expr_stmt|;
return|return
name|ann
return|;
block|}
end_function

begin_comment
comment|/* Create a new annotation for a tree T.  */
end_comment

begin_function
name|tree_ann_common_t
name|create_tree_common_ann
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|tree_ann_common_t
name|ann
decl_stmt|;
name|gcc_assert
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|t
operator|->
name|common
operator|.
name|ann
operator|||
name|t
operator|->
name|common
operator|.
name|ann
operator|->
name|common
operator|.
name|type
operator|==
name|TREE_ANN_COMMON
argument_list|)
expr_stmt|;
name|ann
operator|=
name|GGC_CNEW
argument_list|(
expr|struct
name|tree_ann_common_d
argument_list|)
expr_stmt|;
name|ann
operator|->
name|type
operator|=
name|TREE_ANN_COMMON
expr_stmt|;
name|t
operator|->
name|common
operator|.
name|ann
operator|=
operator|(
name|tree_ann_t
operator|)
name|ann
expr_stmt|;
return|return
name|ann
return|;
block|}
end_function

begin_comment
comment|/* Build a temporary.  Make sure and register it to be renamed.  */
end_comment

begin_function
name|tree
name|make_rename_temp
parameter_list|(
name|tree
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|tree
name|t
init|=
name|create_tmp_var
argument_list|(
name|type
argument_list|,
name|prefix
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
name|DECL_COMPLEX_GIMPLE_REG_P
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|referenced_vars
condition|)
block|{
name|add_referenced_var
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|mark_sym_for_renaming
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 			      Debugging functions ---------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/* Dump the list of all the referenced variables in the current function to    FILE.  */
end_comment

begin_function
name|void
name|dump_referenced_vars
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|tree
name|var
decl_stmt|;
name|referenced_var_iterator
name|rvi
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\nReferenced variables in %s: %u\n\n"
argument_list|,
name|get_name
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|num_referenced_vars
argument_list|)
expr_stmt|;
name|FOR_EACH_REFERENCED_VAR
argument_list|(
argument|var
argument_list|,
argument|rvi
argument_list|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Variable: "
argument_list|)
expr_stmt|;
name|dump_variable
argument_list|(
name|file
argument_list|,
name|var
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Dump the list of all the referenced variables to stderr.  */
end_comment

begin_function
name|void
name|debug_referenced_vars
parameter_list|(
name|void
parameter_list|)
block|{
name|dump_referenced_vars
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump sub-variables for VAR to FILE.  */
end_comment

begin_function
name|void
name|dump_subvars_for
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|tree
name|var
parameter_list|)
block|{
name|subvar_t
name|sv
init|=
name|get_subvars_for_var
argument_list|(
name|var
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sv
condition|)
return|return;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"{ "
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|sv
condition|;
name|sv
operator|=
name|sv
operator|->
name|next
control|)
block|{
name|print_generic_expr
argument_list|(
name|file
argument_list|,
name|sv
operator|->
name|var
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dumb sub-variables for VAR to stderr.  */
end_comment

begin_function
name|void
name|debug_subvars_for
parameter_list|(
name|tree
name|var
parameter_list|)
block|{
name|dump_subvars_for
argument_list|(
name|stderr
argument_list|,
name|var
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump variable VAR and its may-aliases to FILE.  */
end_comment

begin_function
name|void
name|dump_variable
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|tree
name|var
parameter_list|)
block|{
name|var_ann_t
name|ann
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|var
argument_list|)
argument_list|)
condition|)
name|dump_points_to_info_for
argument_list|(
name|file
argument_list|,
name|var
argument_list|)
expr_stmt|;
name|var
operator|=
name|SSA_NAME_VAR
argument_list|(
name|var
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|var
operator|==
name|NULL_TREE
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"<nil>"
argument_list|)
expr_stmt|;
return|return;
block|}
name|print_generic_expr
argument_list|(
name|file
argument_list|,
name|var
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
name|ann
operator|=
name|var_ann
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|", UID %u"
argument_list|,
operator|(
name|unsigned
operator|)
name|DECL_UID
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|file
argument_list|,
name|TREE_TYPE
argument_list|(
name|var
argument_list|)
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|ann
operator|&&
name|ann
operator|->
name|symbol_mem_tag
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|", symbol memory tag: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|file
argument_list|,
name|ann
operator|->
name|symbol_mem_tag
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ann
operator|&&
name|ann
operator|->
name|is_aliased
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|", is aliased"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|var
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|", is addressable"
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_global_var
argument_list|(
name|var
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|", is global"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|var
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|", is volatile"
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_call_clobbered
argument_list|(
name|var
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|", call clobbered"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_flags
operator|&
name|TDF_DETAILS
condition|)
block|{
name|var_ann_t
name|va
init|=
name|var_ann
argument_list|(
name|var
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|escape_mask
init|=
name|va
operator|->
name|escape_mask
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" ("
argument_list|)
expr_stmt|;
if|if
condition|(
name|escape_mask
operator|&
name|ESCAPE_STORED_IN_GLOBAL
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|", stored in global"
argument_list|)
expr_stmt|;
if|if
condition|(
name|escape_mask
operator|&
name|ESCAPE_TO_ASM
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|", goes through ASM"
argument_list|)
expr_stmt|;
if|if
condition|(
name|escape_mask
operator|&
name|ESCAPE_TO_CALL
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|", passed to call"
argument_list|)
expr_stmt|;
if|if
condition|(
name|escape_mask
operator|&
name|ESCAPE_BAD_CAST
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|", bad cast"
argument_list|)
expr_stmt|;
if|if
condition|(
name|escape_mask
operator|&
name|ESCAPE_TO_RETURN
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|", returned from func"
argument_list|)
expr_stmt|;
if|if
condition|(
name|escape_mask
operator|&
name|ESCAPE_TO_PURE_CONST
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|", passed to pure/const"
argument_list|)
expr_stmt|;
if|if
condition|(
name|escape_mask
operator|&
name|ESCAPE_IS_GLOBAL
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|", is global var"
argument_list|)
expr_stmt|;
if|if
condition|(
name|escape_mask
operator|&
name|ESCAPE_IS_PARM
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|", is incoming pointer"
argument_list|)
expr_stmt|;
if|if
condition|(
name|escape_mask
operator|&
name|ESCAPE_UNKNOWN
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|", unknown escape"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" )"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|default_def
argument_list|(
name|var
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|", default def: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|file
argument_list|,
name|default_def
argument_list|(
name|var
argument_list|)
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|may_aliases
argument_list|(
name|var
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|", may aliases: "
argument_list|)
expr_stmt|;
name|dump_may_aliases_for
argument_list|(
name|file
argument_list|,
name|var
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|get_subvars_for_var
argument_list|(
name|var
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|", sub-vars: "
argument_list|)
expr_stmt|;
name|dump_subvars_for
argument_list|(
name|file
argument_list|,
name|var
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump variable VAR and its may-aliases to stderr.  */
end_comment

begin_function
name|void
name|debug_variable
parameter_list|(
name|tree
name|var
parameter_list|)
block|{
name|dump_variable
argument_list|(
name|stderr
argument_list|,
name|var
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump various DFA statistics to FILE.  */
end_comment

begin_function
name|void
name|dump_dfa_stats
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|dfa_stats_d
name|dfa_stats
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|,
name|total
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|fmt_str
init|=
literal|"%-30s%-13s%12s\n"
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|fmt_str_1
init|=
literal|"%-30s%13lu%11lu%c\n"
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|fmt_str_3
init|=
literal|"%-43s%11lu%c\n"
decl_stmt|;
specifier|const
name|char
modifier|*
name|funcname
init|=
name|lang_hooks
operator|.
name|decl_printable_name
argument_list|(
name|current_function_decl
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|collect_dfa_stats
argument_list|(
operator|&
name|dfa_stats
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\nDFA Statistics for %s\n\n"
argument_list|,
name|funcname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"---------------------------------------------------------\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|fmt_str
argument_list|,
literal|""
argument_list|,
literal|"  Number of  "
argument_list|,
literal|"Memory"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|fmt_str
argument_list|,
literal|""
argument_list|,
literal|"  instances  "
argument_list|,
literal|"used "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"---------------------------------------------------------\n"
argument_list|)
expr_stmt|;
name|size
operator|=
name|num_referenced_vars
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
expr_stmt|;
name|total
operator|+=
name|size
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|fmt_str_1
argument_list|,
literal|"Referenced variables"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|num_referenced_vars
argument_list|,
name|SCALE
argument_list|(
name|size
argument_list|)
argument_list|,
name|LABEL
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
name|dfa_stats
operator|.
name|num_stmt_anns
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|stmt_ann_d
argument_list|)
expr_stmt|;
name|total
operator|+=
name|size
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|fmt_str_1
argument_list|,
literal|"Statements annotated"
argument_list|,
name|dfa_stats
operator|.
name|num_stmt_anns
argument_list|,
name|SCALE
argument_list|(
name|size
argument_list|)
argument_list|,
name|LABEL
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
name|dfa_stats
operator|.
name|num_var_anns
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|var_ann_d
argument_list|)
expr_stmt|;
name|total
operator|+=
name|size
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|fmt_str_1
argument_list|,
literal|"Variables annotated"
argument_list|,
name|dfa_stats
operator|.
name|num_var_anns
argument_list|,
name|SCALE
argument_list|(
name|size
argument_list|)
argument_list|,
name|LABEL
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
name|dfa_stats
operator|.
name|num_uses
operator|*
sizeof|sizeof
argument_list|(
name|tree
operator|*
argument_list|)
expr_stmt|;
name|total
operator|+=
name|size
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|fmt_str_1
argument_list|,
literal|"USE operands"
argument_list|,
name|dfa_stats
operator|.
name|num_uses
argument_list|,
name|SCALE
argument_list|(
name|size
argument_list|)
argument_list|,
name|LABEL
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
name|dfa_stats
operator|.
name|num_defs
operator|*
sizeof|sizeof
argument_list|(
name|tree
operator|*
argument_list|)
expr_stmt|;
name|total
operator|+=
name|size
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|fmt_str_1
argument_list|,
literal|"DEF operands"
argument_list|,
name|dfa_stats
operator|.
name|num_defs
argument_list|,
name|SCALE
argument_list|(
name|size
argument_list|)
argument_list|,
name|LABEL
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
name|dfa_stats
operator|.
name|num_vuses
operator|*
sizeof|sizeof
argument_list|(
name|tree
operator|*
argument_list|)
expr_stmt|;
name|total
operator|+=
name|size
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|fmt_str_1
argument_list|,
literal|"VUSE operands"
argument_list|,
name|dfa_stats
operator|.
name|num_vuses
argument_list|,
name|SCALE
argument_list|(
name|size
argument_list|)
argument_list|,
name|LABEL
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
name|dfa_stats
operator|.
name|num_v_may_defs
operator|*
sizeof|sizeof
argument_list|(
name|tree
operator|*
argument_list|)
expr_stmt|;
name|total
operator|+=
name|size
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|fmt_str_1
argument_list|,
literal|"V_MAY_DEF operands"
argument_list|,
name|dfa_stats
operator|.
name|num_v_may_defs
argument_list|,
name|SCALE
argument_list|(
name|size
argument_list|)
argument_list|,
name|LABEL
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
name|dfa_stats
operator|.
name|num_v_must_defs
operator|*
sizeof|sizeof
argument_list|(
name|tree
operator|*
argument_list|)
expr_stmt|;
name|total
operator|+=
name|size
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|fmt_str_1
argument_list|,
literal|"V_MUST_DEF operands"
argument_list|,
name|dfa_stats
operator|.
name|num_v_must_defs
argument_list|,
name|SCALE
argument_list|(
name|size
argument_list|)
argument_list|,
name|LABEL
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
name|dfa_stats
operator|.
name|num_phis
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|tree_phi_node
argument_list|)
expr_stmt|;
name|total
operator|+=
name|size
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|fmt_str_1
argument_list|,
literal|"PHI nodes"
argument_list|,
name|dfa_stats
operator|.
name|num_phis
argument_list|,
name|SCALE
argument_list|(
name|size
argument_list|)
argument_list|,
name|LABEL
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
name|dfa_stats
operator|.
name|num_phi_args
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|phi_arg_d
argument_list|)
expr_stmt|;
name|total
operator|+=
name|size
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|fmt_str_1
argument_list|,
literal|"PHI arguments"
argument_list|,
name|dfa_stats
operator|.
name|num_phi_args
argument_list|,
name|SCALE
argument_list|(
name|size
argument_list|)
argument_list|,
name|LABEL
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"---------------------------------------------------------\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|fmt_str_3
argument_list|,
literal|"Total memory used by DFA/SSA data"
argument_list|,
name|SCALE
argument_list|(
name|total
argument_list|)
argument_list|,
name|LABEL
argument_list|(
name|total
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"---------------------------------------------------------\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dfa_stats
operator|.
name|num_phis
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Average number of arguments per PHI node: %.1f (max: %d)\n"
argument_list|,
operator|(
name|float
operator|)
name|dfa_stats
operator|.
name|num_phi_args
operator|/
operator|(
name|float
operator|)
name|dfa_stats
operator|.
name|num_phis
argument_list|,
name|dfa_stats
operator|.
name|max_num_phi_args
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump DFA statistics on stderr.  */
end_comment

begin_function
name|void
name|debug_dfa_stats
parameter_list|(
name|void
parameter_list|)
block|{
name|dump_dfa_stats
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Collect DFA statistics and store them in the structure pointed to by    DFA_STATS_P.  */
end_comment

begin_function
specifier|static
name|void
name|collect_dfa_stats
parameter_list|(
name|struct
name|dfa_stats_d
modifier|*
name|dfa_stats_p
parameter_list|)
block|{
name|struct
name|pointer_set_t
modifier|*
name|pset
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|block_stmt_iterator
name|i
decl_stmt|;
name|gcc_assert
argument_list|(
name|dfa_stats_p
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
name|dfa_stats_p
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dfa_stats_d
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Walk all the trees in the function counting references.  Start at      basic block NUM_FIXED_BLOCKS, but don't stop at block boundaries.  */
name|pset
operator|=
name|pointer_set_create
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
name|bsi_start
argument_list|(
name|BASIC_BLOCK
argument_list|(
name|NUM_FIXED_BLOCKS
argument_list|)
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|i
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|i
argument_list|)
control|)
name|walk_tree
argument_list|(
name|bsi_stmt_ptr
argument_list|(
name|i
argument_list|)
argument_list|,
name|collect_dfa_stats_r
argument_list|,
operator|(
name|void
operator|*
operator|)
name|dfa_stats_p
argument_list|,
name|pset
argument_list|)
expr_stmt|;
name|pointer_set_destroy
argument_list|(
name|pset
argument_list|)
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|tree
name|phi
decl_stmt|;
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|bb
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
block|{
name|dfa_stats_p
operator|->
name|num_phis
operator|++
expr_stmt|;
name|dfa_stats_p
operator|->
name|num_phi_args
operator|+=
name|PHI_NUM_ARGS
argument_list|(
name|phi
argument_list|)
expr_stmt|;
if|if
condition|(
name|PHI_NUM_ARGS
argument_list|(
name|phi
argument_list|)
operator|>
name|dfa_stats_p
operator|->
name|max_num_phi_args
condition|)
name|dfa_stats_p
operator|->
name|max_num_phi_args
operator|=
name|PHI_NUM_ARGS
argument_list|(
name|phi
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Callback for walk_tree to collect DFA statistics for a tree and its    children.  */
end_comment

begin_function
specifier|static
name|tree
name|collect_dfa_stats_r
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|walk_subtrees
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|tree
name|t
init|=
operator|*
name|tp
decl_stmt|;
name|struct
name|dfa_stats_d
modifier|*
name|dfa_stats_p
init|=
operator|(
expr|struct
name|dfa_stats_d
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|t
operator|->
name|common
operator|.
name|ann
condition|)
block|{
switch|switch
condition|(
name|ann_type
argument_list|(
name|t
operator|->
name|common
operator|.
name|ann
argument_list|)
condition|)
block|{
case|case
name|STMT_ANN
case|:
block|{
name|dfa_stats_p
operator|->
name|num_stmt_anns
operator|++
expr_stmt|;
name|dfa_stats_p
operator|->
name|num_defs
operator|+=
name|NUM_SSA_OPERANDS
argument_list|(
name|t
argument_list|,
name|SSA_OP_DEF
argument_list|)
expr_stmt|;
name|dfa_stats_p
operator|->
name|num_uses
operator|+=
name|NUM_SSA_OPERANDS
argument_list|(
name|t
argument_list|,
name|SSA_OP_USE
argument_list|)
expr_stmt|;
name|dfa_stats_p
operator|->
name|num_v_may_defs
operator|+=
name|NUM_SSA_OPERANDS
argument_list|(
name|t
argument_list|,
name|SSA_OP_VMAYDEF
argument_list|)
expr_stmt|;
name|dfa_stats_p
operator|->
name|num_vuses
operator|+=
name|NUM_SSA_OPERANDS
argument_list|(
name|t
argument_list|,
name|SSA_OP_VUSE
argument_list|)
expr_stmt|;
name|dfa_stats_p
operator|->
name|num_v_must_defs
operator|+=
name|NUM_SSA_OPERANDS
argument_list|(
name|t
argument_list|,
name|SSA_OP_VMUSTDEF
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|VAR_ANN
case|:
name|dfa_stats_p
operator|->
name|num_var_anns
operator|++
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 			     Miscellaneous helpers ---------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/* Callback for walk_tree.  Used to collect variables referenced in    the function.  */
end_comment

begin_function
specifier|static
name|tree
name|find_vars_r
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|walk_subtrees
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* If T is a regular variable that the optimizers are interested      in, add it to the list of variables.  */
if|if
condition|(
name|SSA_VAR_P
argument_list|(
operator|*
name|tp
argument_list|)
condition|)
name|add_referenced_var
argument_list|(
operator|*
name|tp
argument_list|)
expr_stmt|;
comment|/* Type, _DECL and constant nodes have no interesting children.      Ignore them.  */
elseif|else
if|if
condition|(
name|IS_TYPE_OR_DECL_P
argument_list|(
operator|*
name|tp
argument_list|)
operator|||
name|CONSTANT_CLASS_P
argument_list|(
operator|*
name|tp
argument_list|)
condition|)
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Lookup UID in the referenced_vars hashtable and return the associated    variable.  */
end_comment

begin_function
name|tree
name|referenced_var_lookup
parameter_list|(
name|unsigned
name|int
name|uid
parameter_list|)
block|{
name|struct
name|int_tree_map
modifier|*
name|h
decl_stmt|,
name|in
decl_stmt|;
name|in
operator|.
name|uid
operator|=
name|uid
expr_stmt|;
name|h
operator|=
operator|(
expr|struct
name|int_tree_map
operator|*
operator|)
name|htab_find_with_hash
argument_list|(
name|referenced_vars
argument_list|,
operator|&
name|in
argument_list|,
name|uid
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|h
operator|||
name|uid
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
condition|)
return|return
name|h
operator|->
name|to
return|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Check if TO is in the referenced_vars hash table and insert it if not.      Return true if it required insertion.  */
end_comment

begin_function
name|bool
name|referenced_var_check_and_insert
parameter_list|(
name|tree
name|to
parameter_list|)
block|{
name|struct
name|int_tree_map
modifier|*
name|h
decl_stmt|,
name|in
decl_stmt|;
name|void
modifier|*
modifier|*
name|loc
decl_stmt|;
name|unsigned
name|int
name|uid
init|=
name|DECL_UID
argument_list|(
name|to
argument_list|)
decl_stmt|;
name|in
operator|.
name|uid
operator|=
name|uid
expr_stmt|;
name|in
operator|.
name|to
operator|=
name|to
expr_stmt|;
name|h
operator|=
operator|(
expr|struct
name|int_tree_map
operator|*
operator|)
name|htab_find_with_hash
argument_list|(
name|referenced_vars
argument_list|,
operator|&
name|in
argument_list|,
name|uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
condition|)
block|{
comment|/* DECL_UID has already been entered in the table.  Verify that it is 	 the same entry as TO.  See PR 27793.  */
name|gcc_assert
argument_list|(
name|h
operator|->
name|to
operator|==
name|to
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|h
operator|=
name|GGC_NEW
argument_list|(
expr|struct
name|int_tree_map
argument_list|)
expr_stmt|;
name|h
operator|->
name|uid
operator|=
name|uid
expr_stmt|;
name|h
operator|->
name|to
operator|=
name|to
expr_stmt|;
name|loc
operator|=
name|htab_find_slot_with_hash
argument_list|(
name|referenced_vars
argument_list|,
name|h
argument_list|,
name|uid
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
operator|*
operator|(
expr|struct
name|int_tree_map
operator|*
operator|*
operator|)
name|loc
operator|=
name|h
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Lookup VAR UID in the default_defs hashtable and return the associated    variable.  */
end_comment

begin_function
name|tree
name|default_def
parameter_list|(
name|tree
name|var
parameter_list|)
block|{
name|struct
name|int_tree_map
modifier|*
name|h
decl_stmt|,
name|in
decl_stmt|;
name|gcc_assert
argument_list|(
name|SSA_VAR_P
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
name|in
operator|.
name|uid
operator|=
name|DECL_UID
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|h
operator|=
operator|(
expr|struct
name|int_tree_map
operator|*
operator|)
name|htab_find_with_hash
argument_list|(
name|default_defs
argument_list|,
operator|&
name|in
argument_list|,
name|DECL_UID
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
condition|)
return|return
name|h
operator|->
name|to
return|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Insert the pair VAR's UID, DEF into the default_defs hashtable.  */
end_comment

begin_function
name|void
name|set_default_def
parameter_list|(
name|tree
name|var
parameter_list|,
name|tree
name|def
parameter_list|)
block|{
name|struct
name|int_tree_map
name|in
decl_stmt|;
name|struct
name|int_tree_map
modifier|*
name|h
decl_stmt|;
name|void
modifier|*
modifier|*
name|loc
decl_stmt|;
name|gcc_assert
argument_list|(
name|SSA_VAR_P
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
name|in
operator|.
name|uid
operator|=
name|DECL_UID
argument_list|(
name|var
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|def
operator|&&
name|default_def
argument_list|(
name|var
argument_list|)
condition|)
block|{
name|loc
operator|=
name|htab_find_slot_with_hash
argument_list|(
name|default_defs
argument_list|,
operator|&
name|in
argument_list|,
name|DECL_UID
argument_list|(
name|var
argument_list|)
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
name|htab_remove_elt
argument_list|(
name|default_defs
argument_list|,
operator|*
name|loc
argument_list|)
expr_stmt|;
return|return;
block|}
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|def
argument_list|)
operator|==
name|SSA_NAME
argument_list|)
expr_stmt|;
name|loc
operator|=
name|htab_find_slot_with_hash
argument_list|(
name|default_defs
argument_list|,
operator|&
name|in
argument_list|,
name|DECL_UID
argument_list|(
name|var
argument_list|)
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
comment|/* Default definition might be changed by tail call optimization.  */
if|if
condition|(
operator|!
operator|*
name|loc
condition|)
block|{
name|h
operator|=
name|GGC_NEW
argument_list|(
expr|struct
name|int_tree_map
argument_list|)
expr_stmt|;
name|h
operator|->
name|uid
operator|=
name|DECL_UID
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|h
operator|->
name|to
operator|=
name|def
expr_stmt|;
operator|*
operator|(
expr|struct
name|int_tree_map
operator|*
operator|*
operator|)
name|loc
operator|=
name|h
expr_stmt|;
block|}
else|else
block|{
name|h
operator|=
operator|(
expr|struct
name|int_tree_map
operator|*
operator|)
operator|*
name|loc
expr_stmt|;
name|h
operator|->
name|to
operator|=
name|def
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Add VAR to the list of referenced variables if it isn't already there.  */
end_comment

begin_function
name|void
name|add_referenced_var
parameter_list|(
name|tree
name|var
parameter_list|)
block|{
name|var_ann_t
name|v_ann
decl_stmt|;
name|v_ann
operator|=
name|get_var_ann
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|DECL_P
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Insert VAR into the referenced_vars has table if it isn't present.  */
if|if
condition|(
name|referenced_var_check_and_insert
argument_list|(
name|var
argument_list|)
condition|)
block|{
comment|/* This is the first time we found this variable, annotate it with 	 attributes that are intrinsic to the variable.  */
comment|/* Tag's don't have DECL_INITIAL.  */
if|if
condition|(
name|MTAG_P
argument_list|(
name|var
argument_list|)
condition|)
return|return;
comment|/* Scan DECL_INITIAL for pointer variables as they may contain 	 address arithmetic referencing the address of other 	 variables.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|var
argument_list|)
comment|/* Initializers of external variables are not useful to the 	     optimizers.  */
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|var
argument_list|)
comment|/* It's not necessary to walk the initial value of non-constant 	     variables because it cannot be propagated by the 	     optimizers.  */
operator|&&
operator|(
name|TREE_CONSTANT
argument_list|(
name|var
argument_list|)
operator|||
name|TREE_READONLY
argument_list|(
name|var
argument_list|)
operator|)
condition|)
name|walk_tree
argument_list|(
operator|&
name|DECL_INITIAL
argument_list|(
name|var
argument_list|)
argument_list|,
name|find_vars_r
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return the virtual variable associated to the non-scalar variable VAR.  */
end_comment

begin_function
name|tree
name|get_virtual_var
parameter_list|(
name|tree
name|var
parameter_list|)
block|{
name|STRIP_NOPS
argument_list|(
name|var
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|SSA_NAME
condition|)
name|var
operator|=
name|SSA_NAME_VAR
argument_list|(
name|var
argument_list|)
expr_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|REALPART_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|IMAGPART_EXPR
operator|||
name|handled_component_p
argument_list|(
name|var
argument_list|)
condition|)
name|var
operator|=
name|TREE_OPERAND
argument_list|(
name|var
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Treating GIMPLE registers as virtual variables makes no sense.      Also complain if we couldn't extract a _DECL out of the original      expression.  */
name|gcc_assert
argument_list|(
name|SSA_VAR_P
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|is_gimple_reg
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|var
return|;
block|}
end_function

begin_comment
comment|/* Mark all the non-SSA variables found in STMT's operands to be    processed by update_ssa.  */
end_comment

begin_function
name|void
name|mark_new_vars_to_rename
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
name|ssa_op_iter
name|iter
decl_stmt|;
name|tree
name|val
decl_stmt|;
name|bitmap
name|vars_in_vops_to_rename
decl_stmt|;
name|bool
name|found_exposed_symbol
init|=
name|false
decl_stmt|;
name|int
name|v_may_defs_before
decl_stmt|,
name|v_may_defs_after
decl_stmt|;
name|int
name|v_must_defs_before
decl_stmt|,
name|v_must_defs_after
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|PHI_NODE
condition|)
return|return;
name|get_stmt_ann
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|vars_in_vops_to_rename
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* Before re-scanning the statement for operands, mark the existing      virtual operands to be renamed again.  We do this because when new      symbols are exposed, the virtual operands that were here before due to      aliasing will probably be removed by the call to get_stmt_operand.      Therefore, we need to flag them to be renamed beforehand.       We flag them in a separate bitmap because we don't really want to      rename them if there are not any newly exposed symbols in the      statement operands.  */
name|v_may_defs_before
operator|=
name|NUM_SSA_OPERANDS
argument_list|(
name|stmt
argument_list|,
name|SSA_OP_VMAYDEF
argument_list|)
expr_stmt|;
name|v_must_defs_before
operator|=
name|NUM_SSA_OPERANDS
argument_list|(
name|stmt
argument_list|,
name|SSA_OP_VMUSTDEF
argument_list|)
expr_stmt|;
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|val
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_VMAYDEF | SSA_OP_VUSE | SSA_OP_VMUSTDEF
argument_list|)
block|{
if|if
condition|(
operator|!
name|DECL_P
argument_list|(
name|val
argument_list|)
condition|)
name|val
operator|=
name|SSA_NAME_VAR
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|vars_in_vops_to_rename
argument_list|,
name|DECL_UID
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Now force an operand re-scan on the statement and mark any newly      exposed variables.  */
name|update_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|v_may_defs_after
operator|=
name|NUM_SSA_OPERANDS
argument_list|(
name|stmt
argument_list|,
name|SSA_OP_VMAYDEF
argument_list|)
expr_stmt|;
name|v_must_defs_after
operator|=
name|NUM_SSA_OPERANDS
argument_list|(
name|stmt
argument_list|,
name|SSA_OP_VMUSTDEF
argument_list|)
expr_stmt|;
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|val
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_ALL_OPERANDS
argument_list|)
if|if
condition|(
name|DECL_P
argument_list|(
name|val
argument_list|)
condition|)
block|{
name|found_exposed_symbol
operator|=
name|true
expr_stmt|;
name|mark_sym_for_renaming
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
comment|/* If we found any newly exposed symbols, or if there are fewer VDEF      operands in the statement, add the variables we had set in      VARS_IN_VOPS_TO_RENAME to VARS_TO_RENAME.  We need to check for      vanishing VDEFs because in those cases, the names that were formerly      generated by this statement are not going to be available anymore.  */
if|if
condition|(
name|found_exposed_symbol
operator|||
name|v_may_defs_before
operator|>
name|v_may_defs_after
operator|||
name|v_must_defs_before
operator|>
name|v_must_defs_after
condition|)
name|mark_set_for_renaming
argument_list|(
name|vars_in_vops_to_rename
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|vars_in_vops_to_rename
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find all variables within the gimplified statement that were not previously    visible to the function and add them to the referenced variables list.  */
end_comment

begin_function
specifier|static
name|tree
name|find_new_referenced_vars_1
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|walk_subtrees
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|tree
name|t
init|=
operator|*
name|tp
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|!
name|var_ann
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|add_referenced_var
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|mark_sym_for_renaming
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|IS_TYPE_OR_DECL_P
argument_list|(
name|t
argument_list|)
condition|)
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|find_new_referenced_vars
parameter_list|(
name|tree
modifier|*
name|stmt_p
parameter_list|)
block|{
name|walk_tree
argument_list|(
name|stmt_p
argument_list|,
name|find_new_referenced_vars_1
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If REF is a handled component reference for a structure, return the    base variable.  The access range is delimited by bit positions *POFFSET and    *POFFSET + *PMAX_SIZE.  The access size is *PSIZE bits.  If either    *PSIZE or *PMAX_SIZE is -1, they could not be determined.  If *PSIZE    and *PMAX_SIZE are equal, the access is non-variable.  */
end_comment

begin_function
name|tree
name|get_ref_base_and_extent
parameter_list|(
name|tree
name|exp
parameter_list|,
name|HOST_WIDE_INT
modifier|*
name|poffset
parameter_list|,
name|HOST_WIDE_INT
modifier|*
name|psize
parameter_list|,
name|HOST_WIDE_INT
modifier|*
name|pmax_size
parameter_list|)
block|{
name|HOST_WIDE_INT
name|bitsize
init|=
operator|-
literal|1
decl_stmt|;
name|HOST_WIDE_INT
name|maxsize
init|=
operator|-
literal|1
decl_stmt|;
name|tree
name|size_tree
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|bit_offset
init|=
name|bitsize_zero_node
decl_stmt|;
name|bool
name|seen_variable_array_ref
init|=
name|false
decl_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|SSA_VAR_P
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* First get the final access size from just the outermost expression.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
name|size_tree
operator|=
name|DECL_SIZE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|BIT_FIELD_REF
condition|)
name|size_tree
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|enum
name|machine_mode
name|mode
init|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|BLKmode
condition|)
name|size_tree
operator|=
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|bitsize
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|size_tree
operator|!=
name|NULL_TREE
condition|)
block|{
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|size_tree
argument_list|,
literal|1
argument_list|)
condition|)
name|bitsize
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|bitsize
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|size_tree
argument_list|)
expr_stmt|;
block|}
comment|/* Initially, maxsize is the same as the accessed element size.      In the following it will only grow (or become -1).  */
name|maxsize
operator|=
name|bitsize
expr_stmt|;
comment|/* Compute cumulative bit-offset for nested component-refs and array-refs,      and find the ultimate containing object.  */
while|while
condition|(
literal|1
condition|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|BIT_FIELD_REF
case|:
name|bit_offset
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|bit_offset
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPONENT_REF
case|:
block|{
name|tree
name|field
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|this_offset
init|=
name|component_ref_field_offset
argument_list|(
name|exp
argument_list|)
decl_stmt|;
if|if
condition|(
name|this_offset
operator|&&
name|TREE_CODE
argument_list|(
name|this_offset
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|this_offset
operator|=
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|fold_convert
argument_list|(
name|bitsizetype
argument_list|,
name|this_offset
argument_list|)
argument_list|,
name|bitsize_unit_node
argument_list|)
expr_stmt|;
name|bit_offset
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|bit_offset
argument_list|,
name|this_offset
argument_list|)
expr_stmt|;
name|bit_offset
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|bit_offset
argument_list|,
name|DECL_FIELD_BIT_OFFSET
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|csize
init|=
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* We need to adjust maxsize to the whole structure bitsize. 		   But we can subtract any constant offset seen sofar, 		   because that would get us out of the structure otherwise.  */
if|if
condition|(
name|maxsize
operator|!=
operator|-
literal|1
operator|&&
name|csize
operator|&&
name|host_integerp
argument_list|(
name|csize
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|maxsize
operator|=
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|csize
argument_list|)
operator|-
name|TREE_INT_CST_LOW
argument_list|(
name|bit_offset
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
name|maxsize
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
break|break;
case|case
name|ARRAY_REF
case|:
case|case
name|ARRAY_RANGE_REF
case|:
block|{
name|tree
name|index
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|low_bound
init|=
name|array_ref_low_bound
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|tree
name|unit_size
init|=
name|array_ref_element_size
argument_list|(
name|exp
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|low_bound
argument_list|)
condition|)
name|index
operator|=
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|index
argument_list|)
argument_list|,
name|index
argument_list|,
name|low_bound
argument_list|)
expr_stmt|;
name|index
operator|=
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|fold_convert
argument_list|(
name|sizetype
argument_list|,
name|index
argument_list|)
argument_list|,
name|unit_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|index
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|index
operator|=
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|fold_convert
argument_list|(
name|bitsizetype
argument_list|,
name|index
argument_list|)
argument_list|,
name|bitsize_unit_node
argument_list|)
expr_stmt|;
name|bit_offset
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|bit_offset
argument_list|,
name|index
argument_list|)
expr_stmt|;
comment|/* An array ref with a constant index up in the structure 		   hierarchy will constrain the size of any variable array ref 		   lower in the access hierarchy.  */
name|seen_variable_array_ref
operator|=
name|false
expr_stmt|;
block|}
else|else
block|{
name|tree
name|asize
init|=
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* We need to adjust maxsize to the whole array bitsize. 		   But we can subtract any constant offset seen sofar, 		   because that would get us outside of the array otherwise.  */
if|if
condition|(
name|maxsize
operator|!=
operator|-
literal|1
operator|&&
name|asize
operator|&&
name|host_integerp
argument_list|(
name|asize
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|maxsize
operator|=
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|asize
argument_list|)
operator|-
name|TREE_INT_CST_LOW
argument_list|(
name|bit_offset
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
name|maxsize
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Remember that we have seen an array ref with a variable 		   index.  */
name|seen_variable_array_ref
operator|=
name|true
expr_stmt|;
block|}
block|}
break|break;
case|case
name|REALPART_EXPR
case|:
break|break;
case|case
name|IMAGPART_EXPR
case|:
name|bit_offset
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|bit_offset
argument_list|,
name|bitsize_int
argument_list|(
name|bitsize
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|VIEW_CONVERT_EXPR
case|:
comment|/* ???  We probably should give up here and bail out.  */
break|break;
default|default:
goto|goto
name|done
goto|;
block|}
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|done
label|:
comment|/* We need to deal with variable arrays ending structures such as        struct { int length; int a[1]; } x;           x.a[d]        struct { struct { int a; int b; } a[1]; } x;  x.a[d].a        struct { struct { int a[1]; } a[1]; } x;      x.a[0][d], x.a[d][0]      where we do not know maxsize for variable index accesses to      the array.  The simplest way to conservatively deal with this      is to punt in the case that offset + maxsize reaches the      base type boundary.  */
if|if
condition|(
name|seen_variable_array_ref
operator|&&
name|maxsize
operator|!=
operator|-
literal|1
operator|&&
name|host_integerp
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|bit_offset
argument_list|)
operator|+
name|maxsize
operator|==
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
condition|)
name|maxsize
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* ???  Due to negative offsets in ARRAY_REF we can end up with      negative bit_offset here.  We might want to store a zero offset      in this case.  */
operator|*
name|poffset
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|bit_offset
argument_list|)
expr_stmt|;
operator|*
name|psize
operator|=
name|bitsize
expr_stmt|;
operator|*
name|pmax_size
operator|=
name|maxsize
expr_stmt|;
return|return
name|exp
return|;
block|}
end_function

end_unit

