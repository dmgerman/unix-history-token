begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Multibyte Character Functions.    Copyright (C) 1998 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Note regarding cross compilation:     In general, translation of multibyte characters to wide characters can    only work in a native compiler since the translation function (mbtowc)    needs to know about both the source and target character encoding.  However,    this particular implementation for JIS, SJIS and EUCJP source characters    will work for any compiler with a newlib target.  Other targets may also    work provided that their wchar_t implementation is 2 bytes and the encoding    leaves the source character values unchanged (except for removing the    state shifting markers).  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|MULTIBYTE_CHARS
end_ifdef

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"mbchar.h"
end_include

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_typedef
typedef|typedef
enum|enum
block|{
name|ESCAPE
block|,
name|DOLLAR
block|,
name|BRACKET
block|,
name|AT
block|,
name|B
block|,
name|J
block|,
name|NUL
block|,
name|JIS_CHAR
block|,
name|OTHER
block|,
name|JIS_C_NUM
block|}
name|JIS_CHAR_TYPE
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|ASCII
block|,
name|A_ESC
block|,
name|A_ESC_DL
block|,
name|JIS
block|,
name|JIS_1
block|,
name|JIS_2
block|,
name|J_ESC
block|,
name|J_ESC_BR
block|,
name|J2_ESC
block|,
name|J2_ESC_BR
block|,
name|INV
block|,
name|JIS_S_NUM
block|}
name|JIS_STATE
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|COPYA
block|,
name|COPYJ
block|,
name|COPYJ2
block|,
name|MAKE_A
block|,
name|MAKE_J
block|,
name|NOOP
block|,
name|EMPTY
block|,
name|ERROR
block|}
name|JIS_ACTION
typedef|;
end_typedef

begin_comment
comment|/* State/action tables for processing JIS encoding:     Where possible, switches to JIS are grouped with proceding JIS characters    and switches to ASCII are grouped with preceding JIS characters.    Thus, maximum returned length is:      2 (switch to JIS) + 2 (JIS characters) + 2 (switch back to ASCII) = 6.  */
end_comment

begin_decl_stmt
specifier|static
name|JIS_STATE
name|JIS_state_table
index|[
name|JIS_S_NUM
index|]
index|[
name|JIS_C_NUM
index|]
init|=
block|{
comment|/*            ESCAPE DOLLAR   BRACKET   AT     B      J     NUL JIS_CHAR OTH*/
comment|/*ASCII*/
block|{
name|A_ESC
block|,
name|ASCII
block|,
name|ASCII
block|,
name|ASCII
block|,
name|ASCII
block|,
name|ASCII
block|,
name|ASCII
block|,
name|ASCII
block|,
name|ASCII
block|}
block|,
comment|/*A_ESC*/
block|{
name|ASCII
block|,
name|A_ESC_DL
block|,
name|ASCII
block|,
name|ASCII
block|,
name|ASCII
block|,
name|ASCII
block|,
name|ASCII
block|,
name|ASCII
block|,
name|ASCII
block|}
block|,
comment|/*A_ESC_DL*/
block|{
name|ASCII
block|,
name|ASCII
block|,
name|ASCII
block|,
name|JIS
block|,
name|JIS
block|,
name|ASCII
block|,
name|ASCII
block|,
name|ASCII
block|,
name|ASCII
block|}
block|,
comment|/*JIS*/
block|{
name|J_ESC
block|,
name|JIS_1
block|,
name|JIS_1
block|,
name|JIS_1
block|,
name|JIS_1
block|,
name|JIS_1
block|,
name|INV
block|,
name|JIS_1
block|,
name|INV
block|}
block|,
comment|/*JIS_1*/
block|{
name|INV
block|,
name|JIS_2
block|,
name|JIS_2
block|,
name|JIS_2
block|,
name|JIS_2
block|,
name|JIS_2
block|,
name|INV
block|,
name|JIS_2
block|,
name|INV
block|}
block|,
comment|/*JIS_2*/
block|{
name|J2_ESC
block|,
name|JIS
block|,
name|JIS
block|,
name|JIS
block|,
name|JIS
block|,
name|JIS
block|,
name|INV
block|,
name|JIS
block|,
name|JIS
block|}
block|,
comment|/*J_ESC*/
block|{
name|INV
block|,
name|INV
block|,
name|J_ESC_BR
block|,
name|INV
block|,
name|INV
block|,
name|INV
block|,
name|INV
block|,
name|INV
block|,
name|INV
block|}
block|,
comment|/*J_ESC_BR*/
block|{
name|INV
block|,
name|INV
block|,
name|INV
block|,
name|INV
block|,
name|ASCII
block|,
name|ASCII
block|,
name|INV
block|,
name|INV
block|,
name|INV
block|}
block|,
comment|/*J2_ESC*/
block|{
name|INV
block|,
name|INV
block|,
name|J2_ESC_BR
block|,
name|INV
block|,
name|INV
block|,
name|INV
block|,
name|INV
block|,
name|INV
block|,
name|INV
block|}
block|,
comment|/*J2_ESC_BR*/
block|{
name|INV
block|,
name|INV
block|,
name|INV
block|,
name|INV
block|,
name|ASCII
block|,
name|ASCII
block|,
name|INV
block|,
name|INV
block|,
name|INV
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|JIS_ACTION
name|JIS_action_table
index|[
name|JIS_S_NUM
index|]
index|[
name|JIS_C_NUM
index|]
init|=
block|{
comment|/*            ESCAPE DOLLAR BRACKET AT     B       J      NUL  JIS_CHAR OTH */
comment|/*ASCII */
block|{
name|NOOP
block|,
name|COPYA
block|,
name|COPYA
block|,
name|COPYA
block|,
name|COPYA
block|,
name|COPYA
block|,
name|EMPTY
block|,
name|COPYA
block|,
name|COPYA
block|}
block|,
comment|/*A_ESC */
block|{
name|COPYA
block|,
name|NOOP
block|,
name|COPYA
block|,
name|COPYA
block|,
name|COPYA
block|,
name|COPYA
block|,
name|COPYA
block|,
name|COPYA
block|,
name|COPYA
block|}
block|,
comment|/*A_ESC_DL */
block|{
name|COPYA
block|,
name|COPYA
block|,
name|COPYA
block|,
name|MAKE_J
block|,
name|MAKE_J
block|,
name|COPYA
block|,
name|COPYA
block|,
name|COPYA
block|,
name|COPYA
block|}
block|,
comment|/*JIS */
block|{
name|NOOP
block|,
name|NOOP
block|,
name|NOOP
block|,
name|NOOP
block|,
name|NOOP
block|,
name|NOOP
block|,
name|ERROR
block|,
name|NOOP
block|,
name|ERROR
block|}
block|,
comment|/*JIS_1 */
block|{
name|ERROR
block|,
name|NOOP
block|,
name|NOOP
block|,
name|NOOP
block|,
name|NOOP
block|,
name|NOOP
block|,
name|ERROR
block|,
name|NOOP
block|,
name|ERROR
block|}
block|,
comment|/*JIS_2 */
block|{
name|NOOP
block|,
name|COPYJ2
block|,
name|COPYJ2
block|,
name|COPYJ2
block|,
name|COPYJ2
block|,
name|COPYJ2
block|,
name|ERROR
block|,
name|COPYJ2
block|,
name|COPYJ2
block|}
block|,
comment|/*J_ESC */
block|{
name|ERROR
block|,
name|ERROR
block|,
name|NOOP
block|,
name|ERROR
block|,
name|ERROR
block|,
name|ERROR
block|,
name|ERROR
block|,
name|ERROR
block|,
name|ERROR
block|}
block|,
comment|/*J_ESC_BR */
block|{
name|ERROR
block|,
name|ERROR
block|,
name|ERROR
block|,
name|ERROR
block|,
name|NOOP
block|,
name|NOOP
block|,
name|ERROR
block|,
name|ERROR
block|,
name|ERROR
block|}
block|,
comment|/*J2_ESC */
block|{
name|ERROR
block|,
name|ERROR
block|,
name|NOOP
block|,
name|ERROR
block|,
name|ERROR
block|,
name|ERROR
block|,
name|ERROR
block|,
name|ERROR
block|,
name|ERROR
block|}
block|,
comment|/*J2_ESC_BR*/
block|{
name|ERROR
block|,
name|ERROR
block|,
name|ERROR
block|,
name|ERROR
block|,
name|COPYJ
block|,
name|COPYJ
block|,
name|ERROR
block|,
name|ERROR
block|,
name|ERROR
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|literal_codeset
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Store into *PWC (if PWC is not null) the wide character    corresponding to the multibyte character at the start of the    buffer S of size N.  Return the number of bytes in the multibyte    character.  Return -1 if the bytes do not form a valid character,    or 0 if S is null or points to a null byte.     This function behaves like the Standard C function mbtowc, except    it treats locale names of the form "C-..." specially.  */
end_comment

begin_function
name|int
name|local_mbtowc
parameter_list|(
name|pwc
parameter_list|,
name|s
parameter_list|,
name|n
parameter_list|)
name|wchar_t
modifier|*
name|pwc
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|size_t
name|n
decl_stmt|;
block|{
specifier|static
name|JIS_STATE
name|save_state
init|=
name|ASCII
decl_stmt|;
name|JIS_STATE
name|curr_state
init|=
name|save_state
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|t
init|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|s
decl_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
name|n
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|literal_codeset
operator|==
name|NULL
operator|||
name|strlen
argument_list|(
name|literal_codeset
argument_list|)
operator|<=
literal|1
condition|)
comment|/* This must be the "C" locale or unknown locale -- fall thru */
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|literal_codeset
argument_list|,
literal|"C-SJIS"
argument_list|)
condition|)
block|{
name|int
name|char1
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
comment|/* Not state-dependent.  */
return|return
literal|0
return|;
name|char1
operator|=
operator|*
name|t
expr_stmt|;
if|if
condition|(
name|ISSJIS1
argument_list|(
name|char1
argument_list|)
condition|)
block|{
name|int
name|char2
init|=
name|t
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|n
operator|<=
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|ISSJIS2
argument_list|(
name|char2
argument_list|)
condition|)
block|{
if|if
condition|(
name|pwc
operator|!=
name|NULL
condition|)
operator|*
name|pwc
operator|=
operator|(
operator|(
operator|(
name|wchar_t
operator|)
operator|*
name|t
operator|)
operator|<<
literal|8
operator|)
operator|+
call|(
name|wchar_t
call|)
argument_list|(
operator|*
operator|(
name|t
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|pwc
operator|!=
name|NULL
condition|)
operator|*
name|pwc
operator|=
operator|(
name|wchar_t
operator|)
operator|*
name|t
expr_stmt|;
if|if
condition|(
operator|*
name|t
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|literal_codeset
argument_list|,
literal|"C-EUCJP"
argument_list|)
condition|)
block|{
name|int
name|char1
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
comment|/* Not state-dependent.  */
return|return
literal|0
return|;
name|char1
operator|=
operator|*
name|t
expr_stmt|;
if|if
condition|(
name|ISEUCJP
argument_list|(
name|char1
argument_list|)
condition|)
block|{
name|int
name|char2
init|=
name|t
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|n
operator|<=
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|ISEUCJP
argument_list|(
name|char2
argument_list|)
condition|)
block|{
if|if
condition|(
name|pwc
operator|!=
name|NULL
condition|)
operator|*
name|pwc
operator|=
operator|(
operator|(
operator|(
name|wchar_t
operator|)
operator|*
name|t
operator|)
operator|<<
literal|8
operator|)
operator|+
call|(
name|wchar_t
call|)
argument_list|(
operator|*
operator|(
name|t
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|pwc
operator|!=
name|NULL
condition|)
operator|*
name|pwc
operator|=
operator|(
name|wchar_t
operator|)
operator|*
name|t
expr_stmt|;
if|if
condition|(
operator|*
name|t
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|literal_codeset
argument_list|,
literal|"C-JIS"
argument_list|)
condition|)
block|{
name|JIS_ACTION
name|action
decl_stmt|;
name|JIS_CHAR_TYPE
name|ch
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|ptr
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|curr_ch
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
name|save_state
operator|=
name|ASCII
expr_stmt|;
comment|/* State-dependent.  */
return|return
literal|1
return|;
block|}
name|ptr
operator|=
name|t
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|curr_ch
operator|=
name|t
index|[
name|i
index|]
expr_stmt|;
switch|switch
condition|(
name|curr_ch
condition|)
block|{
case|case
name|JIS_ESC_CHAR
case|:
name|ch
operator|=
name|ESCAPE
expr_stmt|;
break|break;
case|case
literal|'$'
case|:
name|ch
operator|=
name|DOLLAR
expr_stmt|;
break|break;
case|case
literal|'@'
case|:
name|ch
operator|=
name|AT
expr_stmt|;
break|break;
case|case
literal|'('
case|:
name|ch
operator|=
name|BRACKET
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|ch
operator|=
name|B
expr_stmt|;
break|break;
case|case
literal|'J'
case|:
name|ch
operator|=
name|J
expr_stmt|;
break|break;
case|case
literal|'\0'
case|:
name|ch
operator|=
name|NUL
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|ISJIS
argument_list|(
name|curr_ch
argument_list|)
condition|)
name|ch
operator|=
name|JIS_CHAR
expr_stmt|;
else|else
name|ch
operator|=
name|OTHER
expr_stmt|;
block|}
name|action
operator|=
name|JIS_action_table
index|[
name|curr_state
index|]
index|[
name|ch
index|]
expr_stmt|;
name|curr_state
operator|=
name|JIS_state_table
index|[
name|curr_state
index|]
index|[
name|ch
index|]
expr_stmt|;
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|NOOP
case|:
break|break;
case|case
name|EMPTY
case|:
if|if
condition|(
name|pwc
operator|!=
name|NULL
condition|)
operator|*
name|pwc
operator|=
operator|(
name|wchar_t
operator|)
literal|0
expr_stmt|;
name|save_state
operator|=
name|curr_state
expr_stmt|;
return|return
name|i
return|;
case|case
name|COPYA
case|:
if|if
condition|(
name|pwc
operator|!=
name|NULL
condition|)
operator|*
name|pwc
operator|=
operator|(
name|wchar_t
operator|)
operator|*
name|ptr
expr_stmt|;
name|save_state
operator|=
name|curr_state
expr_stmt|;
return|return
name|i
operator|+
literal|1
return|;
case|case
name|COPYJ
case|:
if|if
condition|(
name|pwc
operator|!=
name|NULL
condition|)
operator|*
name|pwc
operator|=
operator|(
operator|(
operator|(
name|wchar_t
operator|)
operator|*
name|ptr
operator|)
operator|<<
literal|8
operator|)
operator|+
call|(
name|wchar_t
call|)
argument_list|(
operator|*
operator|(
name|ptr
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|save_state
operator|=
name|curr_state
expr_stmt|;
return|return
name|i
operator|+
literal|1
return|;
case|case
name|COPYJ2
case|:
if|if
condition|(
name|pwc
operator|!=
name|NULL
condition|)
operator|*
name|pwc
operator|=
operator|(
operator|(
operator|(
name|wchar_t
operator|)
operator|*
name|ptr
operator|)
operator|<<
literal|8
operator|)
operator|+
call|(
name|wchar_t
call|)
argument_list|(
operator|*
operator|(
name|ptr
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|save_state
operator|=
name|curr_state
expr_stmt|;
return|return
name|ptr
operator|-
name|t
operator|+
literal|2
return|;
case|case
name|MAKE_A
case|:
case|case
name|MAKE_J
case|:
name|ptr
operator|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
operator|(
name|t
operator|+
name|i
operator|+
literal|1
operator|)
expr_stmt|;
break|break;
case|case
name|ERROR
case|:
default|default:
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/* More than n bytes needed.  */
return|return
operator|-
literal|1
return|;
block|}
ifdef|#
directive|ifdef
name|CROSS_COMPILE
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
comment|/* Not state-dependent.  */
return|return
literal|0
return|;
if|if
condition|(
name|pwc
operator|!=
name|NULL
condition|)
operator|*
name|pwc
operator|=
operator|*
name|s
expr_stmt|;
return|return
literal|1
return|;
else|#
directive|else
comment|/* This must be the "C" locale or unknown locale.  */
return|return
name|mbtowc
argument_list|(
name|pwc
argument_list|,
name|s
argument_list|,
name|n
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Return the number of bytes in the multibyte character at the start    of the buffer S of size N.  Return -1 if the bytes do not form a    valid character, or 0 if S is null or points to a null byte.     This function behaves like the Standard C function mblen, except    it treats locale names of the form "C-..." specially.  */
end_comment

begin_function
name|int
name|local_mblen
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|)
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|size_t
name|n
decl_stmt|;
block|{
return|return
name|local_mbtowc
argument_list|(
name|NULL
argument_list|,
name|s
argument_list|,
name|n
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the maximum mumber of bytes in a multibyte character.     This function returns the same value as the Standard C macro MB_CUR_MAX,    except it treats locale names of the form "C-..." specially.  */
end_comment

begin_function
name|int
name|local_mb_cur_max
parameter_list|()
block|{
if|if
condition|(
name|literal_codeset
operator|==
name|NULL
operator|||
name|strlen
argument_list|(
name|literal_codeset
argument_list|)
operator|<=
literal|1
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|literal_codeset
argument_list|,
literal|"C-SJIS"
argument_list|)
condition|)
return|return
literal|2
return|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|literal_codeset
argument_list|,
literal|"C-EUCJP"
argument_list|)
condition|)
return|return
literal|2
return|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|literal_codeset
argument_list|,
literal|"C-JIS"
argument_list|)
condition|)
return|return
literal|8
return|;
comment|/* 3 + 2 + 3 */
ifdef|#
directive|ifdef
name|CROSS_COMPILE
return|return
literal|1
return|;
else|#
directive|else
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|0
condition|)
return|return
name|MB_CUR_MAX
return|;
return|return
literal|1
return|;
comment|/* default */
endif|#
directive|endif
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* MULTIBYTE_CHARS */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|dummy
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* silence 'ANSI C forbids an empty source file' warning */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MULTIBYTE_CHARS */
end_comment

end_unit

