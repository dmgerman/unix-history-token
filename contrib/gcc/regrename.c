begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Register renaming for the GNU compiler.    Copyright (C) 2000, 2001, 2002 Free Software Foundation, Inc.     This file is part of GCC.     GCC is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GCC is distributed in the hope that it will be useful, but WITHOUT    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public    License for more details.     You should have received a copy of the GNU General Public License    along with GCC; see the file COPYING.  If not, write to the Free    Software Foundation, 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_define
define|#
directive|define
name|REG_OK_STRICT
end_define

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|REGNO_MODE_OK_FOR_BASE_P
end_ifndef

begin_define
define|#
directive|define
name|REGNO_MODE_OK_FOR_BASE_P
parameter_list|(
name|REGNO
parameter_list|,
name|MODE
parameter_list|)
value|REGNO_OK_FOR_BASE_P (REGNO)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|REG_MODE_OK_FOR_BASE_P
end_ifndef

begin_define
define|#
directive|define
name|REG_MODE_OK_FOR_BASE_P
parameter_list|(
name|REGNO
parameter_list|,
name|MODE
parameter_list|)
value|REG_OK_FOR_BASE_P (REGNO)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|reg_class_names
index|[]
init|=
name|REG_CLASS_NAMES
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|du_chain
block|{
name|struct
name|du_chain
modifier|*
name|next_chain
decl_stmt|;
name|struct
name|du_chain
modifier|*
name|next_use
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|rtx
modifier|*
name|loc
decl_stmt|;
name|enum
name|reg_class
name|class
decl_stmt|;
name|unsigned
name|int
name|need_caller_save_reg
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|earlyclobber
range|:
literal|1
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
name|scan_actions
block|{
name|terminate_all_read
block|,
name|terminate_overlapping_read
block|,
name|terminate_write
block|,
name|terminate_dead
block|,
name|mark_read
block|,
name|mark_write
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|scan_actions_name
index|[]
init|=
block|{
literal|"terminate_all_read"
block|,
literal|"terminate_overlapping_read"
block|,
literal|"terminate_write"
block|,
literal|"terminate_dead"
block|,
literal|"mark_read"
block|,
literal|"mark_write"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|rename_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_replace
name|PARAMS
argument_list|(
operator|(
expr|struct
name|du_chain
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|scan_rtx_reg
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|*
operator|,
expr|enum
name|reg_class
operator|,
expr|enum
name|scan_actions
operator|,
expr|enum
name|op_type
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|scan_rtx_address
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|*
operator|,
expr|enum
name|reg_class
operator|,
expr|enum
name|scan_actions
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|scan_rtx
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|*
operator|,
expr|enum
name|reg_class
operator|,
expr|enum
name|scan_actions
operator|,
expr|enum
name|op_type
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|du_chain
modifier|*
name|build_def_use
name|PARAMS
argument_list|(
operator|(
name|basic_block
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_def_use_chain
name|PARAMS
argument_list|(
operator|(
expr|struct
name|du_chain
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|note_sets
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|clear_dead_regs
name|PARAMS
argument_list|(
operator|(
name|HARD_REG_SET
operator|*
operator|,
expr|enum
name|machine_mode
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|merge_overlapping_regs
name|PARAMS
argument_list|(
operator|(
name|basic_block
operator|,
name|HARD_REG_SET
operator|*
operator|,
expr|struct
name|du_chain
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Called through note_stores from update_life.  Find sets of registers, and    record them in *DATA (which is actually a HARD_REG_SET *).  */
end_comment

begin_function
specifier|static
name|void
name|note_sets
parameter_list|(
name|x
parameter_list|,
name|set
parameter_list|,
name|data
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|set
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|HARD_REG_SET
modifier|*
name|pset
init|=
operator|(
name|HARD_REG_SET
operator|*
operator|)
name|data
decl_stmt|;
name|unsigned
name|int
name|regno
decl_stmt|;
name|int
name|nregs
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
condition|)
return|return;
name|regno
operator|=
name|REGNO
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|nregs
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
comment|/* There must not be pseudos at this point.  */
if|if
condition|(
name|regno
operator|+
name|nregs
operator|>
name|FIRST_PSEUDO_REGISTER
condition|)
name|abort
argument_list|()
expr_stmt|;
while|while
condition|(
name|nregs
operator|--
operator|>
literal|0
condition|)
name|SET_HARD_REG_BIT
argument_list|(
operator|*
name|pset
argument_list|,
name|regno
operator|+
name|nregs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clear all registers from *PSET for which a note of kind KIND can be found    in the list NOTES.  */
end_comment

begin_function
specifier|static
name|void
name|clear_dead_regs
parameter_list|(
name|pset
parameter_list|,
name|kind
parameter_list|,
name|notes
parameter_list|)
name|HARD_REG_SET
modifier|*
name|pset
decl_stmt|;
name|enum
name|machine_mode
name|kind
decl_stmt|;
name|rtx
name|notes
decl_stmt|;
block|{
name|rtx
name|note
decl_stmt|;
for|for
control|(
name|note
operator|=
name|notes
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|kind
operator|&&
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|reg
init|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|reg
argument_list|)
decl_stmt|;
name|int
name|nregs
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
decl_stmt|;
comment|/* There must not be pseudos at this point.  */
if|if
condition|(
name|regno
operator|+
name|nregs
operator|>
name|FIRST_PSEUDO_REGISTER
condition|)
name|abort
argument_list|()
expr_stmt|;
while|while
condition|(
name|nregs
operator|--
operator|>
literal|0
condition|)
name|CLEAR_HARD_REG_BIT
argument_list|(
operator|*
name|pset
argument_list|,
name|regno
operator|+
name|nregs
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* For a def-use chain CHAIN in basic block B, find which registers overlap    its lifetime and set the corresponding bits in *PSET.  */
end_comment

begin_function
specifier|static
name|void
name|merge_overlapping_regs
parameter_list|(
name|b
parameter_list|,
name|pset
parameter_list|,
name|chain
parameter_list|)
name|basic_block
name|b
decl_stmt|;
name|HARD_REG_SET
modifier|*
name|pset
decl_stmt|;
name|struct
name|du_chain
modifier|*
name|chain
decl_stmt|;
block|{
name|struct
name|du_chain
modifier|*
name|t
init|=
name|chain
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|HARD_REG_SET
name|live
decl_stmt|;
name|REG_SET_TO_HARD_REG_SET
argument_list|(
name|live
argument_list|,
name|b
operator|->
name|global_live_at_start
argument_list|)
expr_stmt|;
name|insn
operator|=
name|b
operator|->
name|head
expr_stmt|;
while|while
condition|(
name|t
condition|)
block|{
comment|/* Search forward until the next reference to the register to be 	 renamed.  */
while|while
condition|(
name|insn
operator|!=
name|t
operator|->
name|insn
condition|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|clear_dead_regs
argument_list|(
operator|&
name|live
argument_list|,
name|REG_DEAD
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|note_sets
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|live
argument_list|)
expr_stmt|;
comment|/* Only record currently live regs if we are inside the 		 reg's live range.  */
if|if
condition|(
name|t
operator|!=
name|chain
condition|)
name|IOR_HARD_REG_SET
argument_list|(
operator|*
name|pset
argument_list|,
name|live
argument_list|)
expr_stmt|;
name|clear_dead_regs
argument_list|(
operator|&
name|live
argument_list|,
name|REG_UNUSED
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
name|IOR_HARD_REG_SET
argument_list|(
operator|*
name|pset
argument_list|,
name|live
argument_list|)
expr_stmt|;
comment|/* For the last reference, also merge in all registers set in the 	 same insn. 	 @@@ We only have take earlyclobbered sets into account.  */
if|if
condition|(
operator|!
name|t
operator|->
name|next_use
condition|)
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|note_sets
argument_list|,
operator|(
name|void
operator|*
operator|)
name|pset
argument_list|)
expr_stmt|;
name|t
operator|=
name|t
operator|->
name|next_use
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Perform register renaming on the current function.  */
end_comment

begin_function
name|void
name|regrename_optimize
parameter_list|()
block|{
name|int
name|tick
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
name|int
name|this_tick
init|=
literal|0
decl_stmt|;
name|int
name|b
decl_stmt|;
name|char
modifier|*
name|first_obj
decl_stmt|;
name|memset
argument_list|(
name|tick
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|tick
argument_list|)
expr_stmt|;
name|gcc_obstack_init
argument_list|(
operator|&
name|rename_obstack
argument_list|)
expr_stmt|;
name|first_obj
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|rename_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|n_basic_blocks
condition|;
name|b
operator|++
control|)
block|{
name|basic_block
name|bb
init|=
name|BASIC_BLOCK
argument_list|(
name|b
argument_list|)
decl_stmt|;
name|struct
name|du_chain
modifier|*
name|all_chains
init|=
literal|0
decl_stmt|;
name|HARD_REG_SET
name|unavailable
decl_stmt|;
name|HARD_REG_SET
name|regs_seen
decl_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|unavailable
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"\nBasic block %d:\n"
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|all_chains
operator|=
name|build_def_use
argument_list|(
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|dump_def_use_chain
argument_list|(
name|all_chains
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|unavailable
argument_list|)
expr_stmt|;
comment|/* Don't clobber traceback for noreturn functions.  */
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|FRAME_POINTER_REGNUM
argument_list|,
name|Pmode
argument_list|)
init|;
name|i
operator|--
condition|;
control|)
name|SET_HARD_REG_BIT
argument_list|(
name|unavailable
argument_list|,
name|FRAME_POINTER_REGNUM
operator|+
name|i
argument_list|)
expr_stmt|;
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|HARD_FRAME_POINTER_REGNUM
for|for
control|(
name|i
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|HARD_FRAME_POINTER_REGNUM
argument_list|,
name|Pmode
argument_list|)
init|;
name|i
operator|--
condition|;
control|)
name|SET_HARD_REG_BIT
argument_list|(
name|unavailable
argument_list|,
name|HARD_FRAME_POINTER_REGNUM
operator|+
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|CLEAR_HARD_REG_SET
argument_list|(
name|regs_seen
argument_list|)
expr_stmt|;
while|while
condition|(
name|all_chains
condition|)
block|{
name|int
name|new_reg
decl_stmt|,
name|best_new_reg
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|n_uses
decl_stmt|;
name|struct
name|du_chain
modifier|*
name|this
init|=
name|all_chains
decl_stmt|;
name|struct
name|du_chain
modifier|*
name|tmp
decl_stmt|,
modifier|*
name|last
decl_stmt|;
name|HARD_REG_SET
name|this_unavailable
decl_stmt|;
name|int
name|reg
init|=
name|REGNO
argument_list|(
operator|*
name|this
operator|->
name|loc
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|all_chains
operator|=
name|this
operator|->
name|next_chain
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This just disables optimization opportunities.  */
comment|/* Only rename once we've seen the reg more than once.  */
block|if (! TEST_HARD_REG_BIT (regs_seen, reg)) 	    { 	      SET_HARD_REG_BIT (regs_seen, reg); 	      continue; 	    }
endif|#
directive|endif
if|if
condition|(
name|fixed_regs
index|[
name|reg
index|]
operator|||
name|global_regs
index|[
name|reg
index|]
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|HARD_FRAME_POINTER_REGNUM
operator|||
operator|(
name|frame_pointer_needed
operator|&&
name|reg
operator|==
name|HARD_FRAME_POINTER_REGNUM
operator|)
else|#
directive|else
operator|||
operator|(
name|frame_pointer_needed
operator|&&
name|reg
operator|==
name|FRAME_POINTER_REGNUM
operator|)
endif|#
directive|endif
condition|)
continue|continue;
name|COPY_HARD_REG_SET
argument_list|(
name|this_unavailable
argument_list|,
name|unavailable
argument_list|)
expr_stmt|;
comment|/* Find last entry on chain (which has the need_caller_save bit), 	     count number of uses, and narrow the set of registers we can 	     use for renaming.  */
name|n_uses
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|last
operator|=
name|this
init|;
name|last
operator|->
name|next_use
condition|;
name|last
operator|=
name|last
operator|->
name|next_use
control|)
block|{
name|n_uses
operator|++
expr_stmt|;
name|IOR_COMPL_HARD_REG_SET
argument_list|(
name|this_unavailable
argument_list|,
name|reg_class_contents
index|[
name|last
operator|->
name|class
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n_uses
operator|<
literal|1
condition|)
continue|continue;
name|IOR_COMPL_HARD_REG_SET
argument_list|(
name|this_unavailable
argument_list|,
name|reg_class_contents
index|[
name|last
operator|->
name|class
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|->
name|need_caller_save_reg
condition|)
name|IOR_HARD_REG_SET
argument_list|(
name|this_unavailable
argument_list|,
name|call_used_reg_set
argument_list|)
expr_stmt|;
name|merge_overlapping_regs
argument_list|(
name|bb
argument_list|,
operator|&
name|this_unavailable
argument_list|,
name|this
argument_list|)
expr_stmt|;
comment|/* Now potential_regs is a reasonable approximation, let's 	     have a closer look at each register still in there.  */
for|for
control|(
name|new_reg
operator|=
literal|0
init|;
name|new_reg
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|new_reg
operator|++
control|)
block|{
name|int
name|nregs
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|new_reg
argument_list|,
name|GET_MODE
argument_list|(
operator|*
name|this
operator|->
name|loc
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
name|nregs
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|this_unavailable
argument_list|,
name|new_reg
operator|+
name|i
argument_list|)
operator|||
name|fixed_regs
index|[
name|new_reg
operator|+
name|i
index|]
operator|||
name|global_regs
index|[
name|new_reg
operator|+
name|i
index|]
comment|/* Can't use regs which aren't saved by the prologue.  */
operator|||
operator|(
operator|!
name|regs_ever_live
index|[
name|new_reg
operator|+
name|i
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|new_reg
operator|+
name|i
index|]
operator|)
ifdef|#
directive|ifdef
name|LEAF_REGISTERS
comment|/* We can't use a non-leaf register if we're in a  		       leaf function.  */
operator|||
operator|(
name|current_function_is_leaf
operator|&&
operator|!
name|LEAF_REGISTERS
index|[
name|new_reg
operator|+
name|i
index|]
operator|)
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HARD_REGNO_RENAME_OK
operator|||
operator|!
name|HARD_REGNO_RENAME_OK
argument_list|(
name|reg
operator|+
name|i
argument_list|,
name|new_reg
operator|+
name|i
argument_list|)
endif|#
directive|endif
condition|)
break|break;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
continue|continue;
comment|/* See whether it accepts all modes that occur in 		 definition and uses.  */
for|for
control|(
name|tmp
operator|=
name|this
init|;
name|tmp
condition|;
name|tmp
operator|=
name|tmp
operator|->
name|next_use
control|)
if|if
condition|(
operator|!
name|HARD_REGNO_MODE_OK
argument_list|(
name|new_reg
argument_list|,
name|GET_MODE
argument_list|(
operator|*
name|tmp
operator|->
name|loc
argument_list|)
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|tmp
condition|)
block|{
if|if
condition|(
name|best_new_reg
operator|==
operator|-
literal|1
operator|||
name|tick
index|[
name|best_new_reg
index|]
operator|>
name|tick
index|[
name|new_reg
index|]
condition|)
name|best_new_reg
operator|=
name|new_reg
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rtl_dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Register %s in insn %d"
argument_list|,
name|reg_names
index|[
name|reg
index|]
argument_list|,
name|INSN_UID
argument_list|(
name|last
operator|->
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|last
operator|->
name|need_caller_save_reg
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|" crosses a call"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|best_new_reg
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"; no available registers\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|do_replace
argument_list|(
name|this
argument_list|,
name|best_new_reg
argument_list|)
expr_stmt|;
name|tick
index|[
name|best_new_reg
index|]
operator|=
name|this_tick
operator|++
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|", renamed as %s\n"
argument_list|,
name|reg_names
index|[
name|best_new_reg
index|]
argument_list|)
expr_stmt|;
block|}
name|obstack_free
argument_list|(
operator|&
name|rename_obstack
argument_list|,
name|first_obj
argument_list|)
expr_stmt|;
block|}
name|obstack_free
argument_list|(
operator|&
name|rename_obstack
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|count_or_remove_death_notes
argument_list|(
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|update_life_info
argument_list|(
name|NULL
argument_list|,
name|UPDATE_LIFE_LOCAL
argument_list|,
name|PROP_REG_INFO
operator||
name|PROP_DEATH_NOTES
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_replace
parameter_list|(
name|chain
parameter_list|,
name|reg
parameter_list|)
name|struct
name|du_chain
modifier|*
name|chain
decl_stmt|;
name|int
name|reg
decl_stmt|;
block|{
while|while
condition|(
name|chain
condition|)
block|{
name|unsigned
name|int
name|regno
init|=
name|ORIGINAL_REGNO
argument_list|(
operator|*
name|chain
operator|->
name|loc
argument_list|)
decl_stmt|;
operator|*
name|chain
operator|->
name|loc
operator|=
name|gen_raw_REG
argument_list|(
name|GET_MODE
argument_list|(
operator|*
name|chain
operator|->
name|loc
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|ORIGINAL_REGNO
argument_list|(
operator|*
name|chain
operator|->
name|loc
argument_list|)
operator|=
name|regno
expr_stmt|;
name|chain
operator|=
name|chain
operator|->
name|next_use
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|du_chain
modifier|*
name|open_chains
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|du_chain
modifier|*
name|closed_chains
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|scan_rtx_reg
parameter_list|(
name|insn
parameter_list|,
name|loc
parameter_list|,
name|class
parameter_list|,
name|action
parameter_list|,
name|type
parameter_list|,
name|earlyclobber
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
modifier|*
name|loc
decl_stmt|;
name|enum
name|reg_class
name|class
decl_stmt|;
name|enum
name|scan_actions
name|action
decl_stmt|;
name|enum
name|op_type
name|type
decl_stmt|;
name|int
name|earlyclobber
decl_stmt|;
block|{
name|struct
name|du_chain
modifier|*
modifier|*
name|p
decl_stmt|;
name|rtx
name|x
init|=
operator|*
name|loc
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|this_regno
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|this_nregs
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|this_regno
argument_list|,
name|mode
argument_list|)
decl_stmt|;
if|if
condition|(
name|action
operator|==
name|mark_write
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|OP_OUT
condition|)
block|{
name|struct
name|du_chain
modifier|*
name|this
init|=
operator|(
expr|struct
name|du_chain
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|rename_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|du_chain
argument_list|)
argument_list|)
decl_stmt|;
name|this
operator|->
name|next_use
operator|=
literal|0
expr_stmt|;
name|this
operator|->
name|next_chain
operator|=
name|open_chains
expr_stmt|;
name|this
operator|->
name|loc
operator|=
name|loc
expr_stmt|;
name|this
operator|->
name|insn
operator|=
name|insn
expr_stmt|;
name|this
operator|->
name|class
operator|=
name|class
expr_stmt|;
name|this
operator|->
name|need_caller_save_reg
operator|=
literal|0
expr_stmt|;
name|this
operator|->
name|earlyclobber
operator|=
name|earlyclobber
expr_stmt|;
name|open_chains
operator|=
name|this
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
operator|(
name|type
operator|==
name|OP_OUT
operator|&&
name|action
operator|!=
name|terminate_write
operator|)
operator|||
operator|(
name|type
operator|!=
name|OP_OUT
operator|&&
name|action
operator|==
name|terminate_write
operator|)
condition|)
return|return;
for|for
control|(
name|p
operator|=
operator|&
name|open_chains
init|;
operator|*
name|p
condition|;
control|)
block|{
name|struct
name|du_chain
modifier|*
name|this
init|=
operator|*
name|p
decl_stmt|;
comment|/* Check if the chain has been terminated if it has then skip to 	 the next chain.  	 This can happen when we've already appended the location to 	 the chain in Step 3, but are trying to hide in-out operands 	 from terminate_write in Step 5.  */
if|if
condition|(
operator|*
name|this
operator|->
name|loc
operator|==
name|cc0_rtx
condition|)
name|p
operator|=
operator|&
name|this
operator|->
name|next_chain
expr_stmt|;
else|else
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
operator|*
name|this
operator|->
name|loc
argument_list|)
decl_stmt|;
name|int
name|nregs
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
operator|*
name|this
operator|->
name|loc
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|exact_match
init|=
operator|(
name|regno
operator|==
name|this_regno
operator|&&
name|nregs
operator|==
name|this_nregs
operator|)
decl_stmt|;
if|if
condition|(
name|regno
operator|+
name|nregs
operator|<=
name|this_regno
operator|||
name|this_regno
operator|+
name|this_nregs
operator|<=
name|regno
condition|)
block|{
name|p
operator|=
operator|&
name|this
operator|->
name|next_chain
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|action
operator|==
name|mark_read
condition|)
block|{
if|if
condition|(
operator|!
name|exact_match
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* ??? Class NO_REGS can happen if the md file makes use of  		 EXTRA_CONSTRAINTS to match registers.  Which is arguably 		 wrong, but there we are.  Since we know not what this may 		 be replaced with, terminate the chain.  */
if|if
condition|(
name|class
operator|!=
name|NO_REGS
condition|)
block|{
name|this
operator|=
operator|(
expr|struct
name|du_chain
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|rename_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|du_chain
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|->
name|next_use
operator|=
literal|0
expr_stmt|;
name|this
operator|->
name|next_chain
operator|=
operator|(
operator|*
name|p
operator|)
operator|->
name|next_chain
expr_stmt|;
name|this
operator|->
name|loc
operator|=
name|loc
expr_stmt|;
name|this
operator|->
name|insn
operator|=
name|insn
expr_stmt|;
name|this
operator|->
name|class
operator|=
name|class
expr_stmt|;
name|this
operator|->
name|need_caller_save_reg
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
name|p
operator|=
operator|&
operator|(
operator|*
name|p
operator|)
operator|->
name|next_use
expr_stmt|;
operator|*
name|p
operator|=
name|this
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|action
operator|!=
name|terminate_overlapping_read
operator|||
operator|!
name|exact_match
condition|)
block|{
name|struct
name|du_chain
modifier|*
name|next
init|=
name|this
operator|->
name|next_chain
decl_stmt|;
comment|/* Whether the terminated chain can be used for renaming 	         depends on the action and this being an exact match. 	         In either case, we remove this element from open_chains.  */
if|if
condition|(
operator|(
name|action
operator|==
name|terminate_dead
operator|||
name|action
operator|==
name|terminate_write
operator|)
operator|&&
name|exact_match
condition|)
block|{
name|this
operator|->
name|next_chain
operator|=
name|closed_chains
expr_stmt|;
name|closed_chains
operator|=
name|this
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Closing chain %s at insn %d (%s)\n"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
operator|*
name|this
operator|->
name|loc
argument_list|)
index|]
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|scan_actions_name
index|[
operator|(
name|int
operator|)
name|action
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Discarding chain %s at insn %d (%s)\n"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
operator|*
name|this
operator|->
name|loc
argument_list|)
index|]
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|scan_actions_name
index|[
operator|(
name|int
operator|)
name|action
index|]
argument_list|)
expr_stmt|;
block|}
operator|*
name|p
operator|=
name|next
expr_stmt|;
block|}
else|else
name|p
operator|=
operator|&
name|this
operator|->
name|next_chain
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Adapted from find_reloads_address_1.  CLASS is INDEX_REG_CLASS or    BASE_REG_CLASS depending on how the register is being considered.  */
end_comment

begin_function
specifier|static
name|void
name|scan_rtx_address
parameter_list|(
name|insn
parameter_list|,
name|loc
parameter_list|,
name|class
parameter_list|,
name|action
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
modifier|*
name|loc
decl_stmt|;
name|enum
name|reg_class
name|class
decl_stmt|;
name|enum
name|scan_actions
name|action
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|rtx
name|x
init|=
operator|*
name|loc
decl_stmt|;
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|action
operator|==
name|mark_write
condition|)
return|return;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS
case|:
block|{
name|rtx
name|orig_op0
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|orig_op1
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|RTX_CODE
name|code0
init|=
name|GET_CODE
argument_list|(
name|orig_op0
argument_list|)
decl_stmt|;
name|RTX_CODE
name|code1
init|=
name|GET_CODE
argument_list|(
name|orig_op1
argument_list|)
decl_stmt|;
name|rtx
name|op0
init|=
name|orig_op0
decl_stmt|;
name|rtx
name|op1
init|=
name|orig_op1
decl_stmt|;
name|rtx
modifier|*
name|locI
init|=
name|NULL
decl_stmt|;
name|rtx
modifier|*
name|locB
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|op0
operator|=
name|SUBREG_REG
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|code0
operator|=
name|GET_CODE
argument_list|(
name|op0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|op1
operator|=
name|SUBREG_REG
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|code1
operator|=
name|GET_CODE
argument_list|(
name|op1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code0
operator|==
name|MULT
operator|||
name|code0
operator|==
name|SIGN_EXTEND
operator|||
name|code0
operator|==
name|TRUNCATE
operator|||
name|code0
operator|==
name|ZERO_EXTEND
operator|||
name|code1
operator|==
name|MEM
condition|)
block|{
name|locI
operator|=
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|locB
operator|=
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|MULT
operator|||
name|code1
operator|==
name|SIGN_EXTEND
operator|||
name|code1
operator|==
name|TRUNCATE
operator|||
name|code1
operator|==
name|ZERO_EXTEND
operator|||
name|code0
operator|==
name|MEM
condition|)
block|{
name|locI
operator|=
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|locB
operator|=
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|CONST_INT
operator|||
name|code0
operator|==
name|CONST
operator|||
name|code0
operator|==
name|SYMBOL_REF
operator|||
name|code0
operator|==
name|LABEL_REF
condition|)
name|locB
operator|=
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code1
operator|==
name|CONST_INT
operator|||
name|code1
operator|==
name|CONST
operator|||
name|code1
operator|==
name|SYMBOL_REF
operator|||
name|code1
operator|==
name|LABEL_REF
condition|)
name|locB
operator|=
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code0
operator|==
name|REG
operator|&&
name|code1
operator|==
name|REG
condition|)
block|{
name|int
name|index_op
decl_stmt|;
if|if
condition|(
name|REG_OK_FOR_INDEX_P
argument_list|(
name|op0
argument_list|)
operator|&&
name|REG_MODE_OK_FOR_BASE_P
argument_list|(
name|op1
argument_list|,
name|mode
argument_list|)
condition|)
name|index_op
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_OK_FOR_INDEX_P
argument_list|(
name|op1
argument_list|)
operator|&&
name|REG_MODE_OK_FOR_BASE_P
argument_list|(
name|op0
argument_list|,
name|mode
argument_list|)
condition|)
name|index_op
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_MODE_OK_FOR_BASE_P
argument_list|(
name|op1
argument_list|,
name|mode
argument_list|)
condition|)
name|index_op
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_MODE_OK_FOR_BASE_P
argument_list|(
name|op0
argument_list|,
name|mode
argument_list|)
condition|)
name|index_op
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_OK_FOR_INDEX_P
argument_list|(
name|op1
argument_list|)
condition|)
name|index_op
operator|=
literal|1
expr_stmt|;
else|else
name|index_op
operator|=
literal|0
expr_stmt|;
name|locI
operator|=
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|index_op
argument_list|)
expr_stmt|;
name|locB
operator|=
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
operator|!
name|index_op
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|REG
condition|)
block|{
name|locI
operator|=
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|locB
operator|=
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|REG
condition|)
block|{
name|locI
operator|=
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|locB
operator|=
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|locI
condition|)
name|scan_rtx_address
argument_list|(
name|insn
argument_list|,
name|locI
argument_list|,
name|INDEX_REG_CLASS
argument_list|,
name|action
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|locB
condition|)
name|scan_rtx_address
argument_list|(
name|insn
argument_list|,
name|locB
argument_list|,
name|MODE_BASE_REG_CLASS
argument_list|(
name|mode
argument_list|)
argument_list|,
name|action
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|POST_INC
case|:
case|case
name|POST_DEC
case|:
case|case
name|POST_MODIFY
case|:
case|case
name|PRE_INC
case|:
case|case
name|PRE_DEC
case|:
case|case
name|PRE_MODIFY
case|:
ifndef|#
directive|ifndef
name|AUTO_INC_DEC
comment|/* If the target doesn't claim to handle autoinc, this must be 	 something special, like a stack push.  Kill this chain.  */
name|action
operator|=
name|terminate_all_read
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|MEM
case|:
name|scan_rtx_address
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|MODE_BASE_REG_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|action
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|REG
case|:
name|scan_rtx_reg
argument_list|(
name|insn
argument_list|,
name|loc
argument_list|,
name|class
argument_list|,
name|action
argument_list|,
name|OP_IN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
default|default:
break|break;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|scan_rtx_address
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|class
argument_list|,
name|action
argument_list|,
name|mode
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|scan_rtx_address
argument_list|(
name|insn
argument_list|,
operator|&
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|class
argument_list|,
name|action
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|scan_rtx
parameter_list|(
name|insn
parameter_list|,
name|loc
parameter_list|,
name|class
parameter_list|,
name|action
parameter_list|,
name|type
parameter_list|,
name|earlyclobber
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
modifier|*
name|loc
decl_stmt|;
name|enum
name|reg_class
name|class
decl_stmt|;
name|enum
name|scan_actions
name|action
decl_stmt|;
name|enum
name|op_type
name|type
decl_stmt|;
name|int
name|earlyclobber
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|rtx
name|x
init|=
operator|*
name|loc
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|CC0
case|:
case|case
name|PC
case|:
return|return;
case|case
name|REG
case|:
name|scan_rtx_reg
argument_list|(
name|insn
argument_list|,
name|loc
argument_list|,
name|class
argument_list|,
name|action
argument_list|,
name|type
argument_list|,
name|earlyclobber
argument_list|)
expr_stmt|;
return|return;
case|case
name|MEM
case|:
name|scan_rtx_address
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|MODE_BASE_REG_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|action
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|SET
case|:
name|scan_rtx
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|class
argument_list|,
name|action
argument_list|,
name|OP_IN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|scan_rtx
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|class
argument_list|,
name|action
argument_list|,
name|OP_OUT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|STRICT_LOW_PART
case|:
name|scan_rtx
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|class
argument_list|,
name|action
argument_list|,
name|OP_INOUT
argument_list|,
name|earlyclobber
argument_list|)
expr_stmt|;
return|return;
case|case
name|ZERO_EXTRACT
case|:
case|case
name|SIGN_EXTRACT
case|:
name|scan_rtx
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|class
argument_list|,
name|action
argument_list|,
name|type
operator|==
name|OP_IN
condition|?
name|OP_IN
else|:
name|OP_INOUT
argument_list|,
name|earlyclobber
argument_list|)
expr_stmt|;
name|scan_rtx
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|class
argument_list|,
name|action
argument_list|,
name|OP_IN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|scan_rtx
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|,
name|class
argument_list|,
name|action
argument_list|,
name|OP_IN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|POST_INC
case|:
case|case
name|PRE_INC
case|:
case|case
name|POST_DEC
case|:
case|case
name|PRE_DEC
case|:
case|case
name|POST_MODIFY
case|:
case|case
name|PRE_MODIFY
case|:
comment|/* Should only happen inside MEM.  */
name|abort
argument_list|()
expr_stmt|;
case|case
name|CLOBBER
case|:
name|scan_rtx
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|class
argument_list|,
name|action
argument_list|,
name|OP_OUT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
case|case
name|EXPR_LIST
case|:
name|scan_rtx
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|class
argument_list|,
name|action
argument_list|,
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
name|scan_rtx
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|class
argument_list|,
name|action
argument_list|,
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
default|default:
break|break;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|scan_rtx
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|class
argument_list|,
name|action
argument_list|,
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|scan_rtx
argument_list|(
name|insn
argument_list|,
operator|&
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|class
argument_list|,
name|action
argument_list|,
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Build def/use chain */
end_comment

begin_function
specifier|static
name|struct
name|du_chain
modifier|*
name|build_def_use
parameter_list|(
name|bb
parameter_list|)
name|basic_block
name|bb
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
name|open_chains
operator|=
name|closed_chains
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|bb
operator|->
name|head
init|;
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|int
name|n_ops
decl_stmt|;
name|rtx
name|note
decl_stmt|;
name|rtx
name|old_operands
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|rtx
name|old_dups
index|[
name|MAX_DUP_OPERANDS
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|alt
decl_stmt|;
name|int
name|predicated
decl_stmt|;
comment|/* Process the insn, determining its effect on the def-use 	     chains.  We perform the following steps with the register 	     references in the insn: 	     (1) Any read that overlaps an open chain, but doesn't exactly 	         match, causes that chain to be closed.  We can't deal 	         with overlaps yet. 	     (2) Any read outside an operand causes any chain it overlaps 	         with to be closed, since we can't replace it. 	     (3) Any read inside an operand is added if there's already 	         an open chain for it. 	     (4) For any REG_DEAD note we find, close open chains that 	         overlap it. 	     (5) For any write we find, close open chains that overlap it. 	     (6) For any write we find in an operand, make a new chain. 	     (7) For any REG_UNUSED, close any chains we just opened.  */
name|extract_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|constrain_operands
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|preprocess_constraints
argument_list|()
expr_stmt|;
name|alt
operator|=
name|which_alternative
expr_stmt|;
name|n_ops
operator|=
name|recog_data
operator|.
name|n_operands
expr_stmt|;
comment|/* Simplify the code below by rewriting things to reflect 	     matching constraints.  Also promote OP_OUT to OP_INOUT 	     in predicated instructions.  */
name|predicated
operator|=
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|COND_EXEC
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_ops
condition|;
operator|++
name|i
control|)
block|{
name|int
name|matches
init|=
name|recog_op_alt
index|[
name|i
index|]
index|[
name|alt
index|]
operator|.
name|matches
decl_stmt|;
if|if
condition|(
name|matches
operator|>=
literal|0
condition|)
name|recog_op_alt
index|[
name|i
index|]
index|[
name|alt
index|]
operator|.
name|class
operator|=
name|recog_op_alt
index|[
name|matches
index|]
index|[
name|alt
index|]
operator|.
name|class
expr_stmt|;
if|if
condition|(
name|matches
operator|>=
literal|0
operator|||
name|recog_op_alt
index|[
name|i
index|]
index|[
name|alt
index|]
operator|.
name|matched
operator|>=
literal|0
operator|||
operator|(
name|predicated
operator|&&
name|recog_data
operator|.
name|operand_type
index|[
name|i
index|]
operator|==
name|OP_OUT
operator|)
condition|)
name|recog_data
operator|.
name|operand_type
index|[
name|i
index|]
operator|=
name|OP_INOUT
expr_stmt|;
block|}
comment|/* Step 1: Close chains for which we have overlapping reads.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_ops
condition|;
name|i
operator|++
control|)
name|scan_rtx
argument_list|(
name|insn
argument_list|,
name|recog_data
operator|.
name|operand_loc
index|[
name|i
index|]
argument_list|,
name|NO_REGS
argument_list|,
name|terminate_overlapping_read
argument_list|,
name|recog_data
operator|.
name|operand_type
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Step 2: Close chains for which we have reads outside operands. 	     We do this by munging all operands into CC0, and closing  	     everything remaining.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_ops
condition|;
name|i
operator|++
control|)
block|{
name|old_operands
index|[
name|i
index|]
operator|=
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
expr_stmt|;
comment|/* Don't squash match_operator or match_parallel here, since 		 we don't know that all of the contained registers are  		 reachable by proper operands.  */
if|if
condition|(
name|recog_data
operator|.
name|constraints
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
continue|continue;
operator|*
name|recog_data
operator|.
name|operand_loc
index|[
name|i
index|]
operator|=
name|cc0_rtx
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|recog_data
operator|.
name|n_dups
condition|;
name|i
operator|++
control|)
block|{
name|old_dups
index|[
name|i
index|]
operator|=
operator|*
name|recog_data
operator|.
name|dup_loc
index|[
name|i
index|]
expr_stmt|;
operator|*
name|recog_data
operator|.
name|dup_loc
index|[
name|i
index|]
operator|=
name|cc0_rtx
expr_stmt|;
block|}
name|scan_rtx
argument_list|(
name|insn
argument_list|,
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|NO_REGS
argument_list|,
name|terminate_all_read
argument_list|,
name|OP_IN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|recog_data
operator|.
name|n_dups
condition|;
name|i
operator|++
control|)
operator|*
name|recog_data
operator|.
name|dup_loc
index|[
name|i
index|]
operator|=
name|old_dups
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_ops
condition|;
name|i
operator|++
control|)
operator|*
name|recog_data
operator|.
name|operand_loc
index|[
name|i
index|]
operator|=
name|old_operands
index|[
name|i
index|]
expr_stmt|;
comment|/* Step 2B: Can't rename function call argument registers.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
condition|)
name|scan_rtx
argument_list|(
name|insn
argument_list|,
operator|&
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
argument_list|,
name|NO_REGS
argument_list|,
name|terminate_all_read
argument_list|,
name|OP_IN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Step 2C: Can't rename asm operands that were originally 	     hard registers.  */
if|if
condition|(
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|>
literal|0
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_ops
condition|;
name|i
operator|++
control|)
block|{
name|rtx
modifier|*
name|loc
init|=
name|recog_data
operator|.
name|operand_loc
index|[
name|i
index|]
decl_stmt|;
name|rtx
name|op
init|=
operator|*
name|loc
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|==
name|ORIGINAL_REGNO
argument_list|(
name|op
argument_list|)
operator|&&
operator|(
name|recog_data
operator|.
name|operand_type
index|[
name|i
index|]
operator|==
name|OP_IN
operator|||
name|recog_data
operator|.
name|operand_type
index|[
name|i
index|]
operator|==
name|OP_INOUT
operator|)
condition|)
name|scan_rtx
argument_list|(
name|insn
argument_list|,
name|loc
argument_list|,
name|NO_REGS
argument_list|,
name|terminate_all_read
argument_list|,
name|OP_IN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Step 3: Append to chains for reads inside operands.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_ops
operator|+
name|recog_data
operator|.
name|n_dups
condition|;
name|i
operator|++
control|)
block|{
name|int
name|opn
init|=
name|i
operator|<
name|n_ops
condition|?
name|i
else|:
name|recog_data
operator|.
name|dup_num
index|[
name|i
operator|-
name|n_ops
index|]
decl_stmt|;
name|rtx
modifier|*
name|loc
init|=
operator|(
name|i
operator|<
name|n_ops
condition|?
name|recog_data
operator|.
name|operand_loc
index|[
name|opn
index|]
else|:
name|recog_data
operator|.
name|dup_loc
index|[
name|i
operator|-
name|n_ops
index|]
operator|)
decl_stmt|;
name|enum
name|reg_class
name|class
init|=
name|recog_op_alt
index|[
name|opn
index|]
index|[
name|alt
index|]
operator|.
name|class
decl_stmt|;
name|enum
name|op_type
name|type
init|=
name|recog_data
operator|.
name|operand_type
index|[
name|opn
index|]
decl_stmt|;
comment|/* Don't scan match_operand here, since we've no reg class 		 information to pass down.  Any operands that we could 		 substitute in will be represented elsewhere.  */
if|if
condition|(
name|recog_data
operator|.
name|constraints
index|[
name|opn
index|]
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
continue|continue;
if|if
condition|(
name|recog_op_alt
index|[
name|opn
index|]
index|[
name|alt
index|]
operator|.
name|is_address
condition|)
name|scan_rtx_address
argument_list|(
name|insn
argument_list|,
name|loc
argument_list|,
name|class
argument_list|,
name|mark_read
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
else|else
name|scan_rtx
argument_list|(
name|insn
argument_list|,
name|loc
argument_list|,
name|class
argument_list|,
name|mark_read
argument_list|,
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Step 4: Close chains for registers that die here. 	     Also record updates for REG_INC notes.  */
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
block|{
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_DEAD
condition|)
name|scan_rtx
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NO_REGS
argument_list|,
name|terminate_dead
argument_list|,
name|OP_IN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_INC
condition|)
name|scan_rtx
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|ALL_REGS
argument_list|,
name|mark_read
argument_list|,
name|OP_INOUT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Step 4B: If this is a call, any chain live at this point 	     requires a caller-saved reg.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|struct
name|du_chain
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|open_chains
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next_chain
control|)
name|p
operator|->
name|need_caller_save_reg
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Step 5: Close open chains that overlap writes.  Similar to 	     step 2, we hide in-out operands, since we do not want to 	     close these chains.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_ops
condition|;
name|i
operator|++
control|)
block|{
name|old_operands
index|[
name|i
index|]
operator|=
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|recog_data
operator|.
name|operand_type
index|[
name|i
index|]
operator|==
name|OP_INOUT
condition|)
operator|*
name|recog_data
operator|.
name|operand_loc
index|[
name|i
index|]
operator|=
name|cc0_rtx
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|recog_data
operator|.
name|n_dups
condition|;
name|i
operator|++
control|)
block|{
name|int
name|opn
init|=
name|recog_data
operator|.
name|dup_num
index|[
name|i
index|]
decl_stmt|;
name|old_dups
index|[
name|i
index|]
operator|=
operator|*
name|recog_data
operator|.
name|dup_loc
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|recog_data
operator|.
name|operand_type
index|[
name|opn
index|]
operator|==
name|OP_INOUT
condition|)
operator|*
name|recog_data
operator|.
name|dup_loc
index|[
name|i
index|]
operator|=
name|cc0_rtx
expr_stmt|;
block|}
name|scan_rtx
argument_list|(
name|insn
argument_list|,
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|NO_REGS
argument_list|,
name|terminate_write
argument_list|,
name|OP_IN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|recog_data
operator|.
name|n_dups
condition|;
name|i
operator|++
control|)
operator|*
name|recog_data
operator|.
name|dup_loc
index|[
name|i
index|]
operator|=
name|old_dups
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_ops
condition|;
name|i
operator|++
control|)
operator|*
name|recog_data
operator|.
name|operand_loc
index|[
name|i
index|]
operator|=
name|old_operands
index|[
name|i
index|]
expr_stmt|;
comment|/* Step 6: Begin new chains for writes inside operands.  */
comment|/* ??? Many targets have output constraints on the SET_DEST 	     of a call insn, which is stupid, since these are certainly 	     ABI defined hard registers.  Don't change calls at all. 	     Similarly take special care for asm statement that originally 	     referenced hard registers.  */
if|if
condition|(
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_ops
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|recog_data
operator|.
name|operand_type
index|[
name|i
index|]
operator|==
name|OP_OUT
condition|)
block|{
name|rtx
modifier|*
name|loc
init|=
name|recog_data
operator|.
name|operand_loc
index|[
name|i
index|]
decl_stmt|;
name|rtx
name|op
init|=
operator|*
name|loc
decl_stmt|;
name|enum
name|reg_class
name|class
init|=
name|recog_op_alt
index|[
name|i
index|]
index|[
name|alt
index|]
operator|.
name|class
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|==
name|ORIGINAL_REGNO
argument_list|(
name|op
argument_list|)
condition|)
continue|continue;
name|scan_rtx
argument_list|(
name|insn
argument_list|,
name|loc
argument_list|,
name|class
argument_list|,
name|mark_write
argument_list|,
name|OP_OUT
argument_list|,
name|recog_op_alt
index|[
name|i
index|]
index|[
name|alt
index|]
operator|.
name|earlyclobber
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|CALL_INSN
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_ops
operator|+
name|recog_data
operator|.
name|n_dups
condition|;
name|i
operator|++
control|)
block|{
name|int
name|opn
init|=
name|i
operator|<
name|n_ops
condition|?
name|i
else|:
name|recog_data
operator|.
name|dup_num
index|[
name|i
operator|-
name|n_ops
index|]
decl_stmt|;
name|rtx
modifier|*
name|loc
init|=
operator|(
name|i
operator|<
name|n_ops
condition|?
name|recog_data
operator|.
name|operand_loc
index|[
name|opn
index|]
else|:
name|recog_data
operator|.
name|dup_loc
index|[
name|i
operator|-
name|n_ops
index|]
operator|)
decl_stmt|;
name|enum
name|reg_class
name|class
init|=
name|recog_op_alt
index|[
name|opn
index|]
index|[
name|alt
index|]
operator|.
name|class
decl_stmt|;
if|if
condition|(
name|recog_data
operator|.
name|operand_type
index|[
name|opn
index|]
operator|==
name|OP_OUT
condition|)
name|scan_rtx
argument_list|(
name|insn
argument_list|,
name|loc
argument_list|,
name|class
argument_list|,
name|mark_write
argument_list|,
name|OP_OUT
argument_list|,
name|recog_op_alt
index|[
name|opn
index|]
index|[
name|alt
index|]
operator|.
name|earlyclobber
argument_list|)
expr_stmt|;
block|}
comment|/* Step 7: Close chains for registers that were never 	     really used here.  */
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_UNUSED
condition|)
name|scan_rtx
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NO_REGS
argument_list|,
name|terminate_dead
argument_list|,
name|OP_IN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|insn
operator|==
name|bb
operator|->
name|end
condition|)
break|break;
block|}
comment|/* Since we close every chain when we find a REG_DEAD note, anything that      is still open lives past the basic block, so it can't be renamed.  */
return|return
name|closed_chains
return|;
block|}
end_function

begin_comment
comment|/* Dump all def/use chains in CHAINS to RTL_DUMP_FILE.  They are    printed in reverse order as that's how we build them.  */
end_comment

begin_function
specifier|static
name|void
name|dump_def_use_chain
parameter_list|(
name|chains
parameter_list|)
name|struct
name|du_chain
modifier|*
name|chains
decl_stmt|;
block|{
while|while
condition|(
name|chains
condition|)
block|{
name|struct
name|du_chain
modifier|*
name|this
init|=
name|chains
decl_stmt|;
name|int
name|r
init|=
name|REGNO
argument_list|(
operator|*
name|this
operator|->
name|loc
argument_list|)
decl_stmt|;
name|int
name|nregs
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|r
argument_list|,
name|GET_MODE
argument_list|(
operator|*
name|this
operator|->
name|loc
argument_list|)
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Register %s (%d):"
argument_list|,
name|reg_names
index|[
name|r
index|]
argument_list|,
name|nregs
argument_list|)
expr_stmt|;
while|while
condition|(
name|this
condition|)
block|{
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|" %d [%s]"
argument_list|,
name|INSN_UID
argument_list|(
name|this
operator|->
name|insn
argument_list|)
argument_list|,
name|reg_class_names
index|[
name|this
operator|->
name|class
index|]
argument_list|)
expr_stmt|;
name|this
operator|=
name|this
operator|->
name|next_use
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|chains
operator|=
name|chains
operator|->
name|next_chain
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The following code does forward propagation of hard register copies.    The object is to eliminate as many dependencies as possible, so that    we have the most scheduling freedom.  As a side effect, we also clean    up some silly register allocation decisions made by reload.  This     code may be obsoleted by a new register allocator.  */
end_comment

begin_comment
comment|/* For each register, we have a list of registers that contain the same    value.  The OLDEST_REGNO field points to the head of the list, and     the NEXT_REGNO field runs through the list.  The MODE field indicates    what mode the data is known to be in; this field is VOIDmode when the    register is not known to contain valid data.  */
end_comment

begin_struct
struct|struct
name|value_data_entry
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|unsigned
name|int
name|oldest_regno
decl_stmt|;
name|unsigned
name|int
name|next_regno
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|value_data
block|{
name|struct
name|value_data_entry
name|e
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
name|unsigned
name|int
name|max_value_regs
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|void
name|kill_value_regno
name|PARAMS
argument_list|(
operator|(
name|unsigned
operator|,
expr|struct
name|value_data
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|kill_value
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
expr|struct
name|value_data
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_value_regno
name|PARAMS
argument_list|(
operator|(
name|unsigned
operator|,
expr|enum
name|machine_mode
operator|,
expr|struct
name|value_data
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_value_data
name|PARAMS
argument_list|(
operator|(
expr|struct
name|value_data
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|kill_clobbered_value
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|kill_set_value
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|kill_autoinc_value
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|copy_value
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
expr|struct
name|value_data
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|mode_change_ok
name|PARAMS
argument_list|(
operator|(
expr|enum
name|machine_mode
operator|,
expr|enum
name|machine_mode
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|find_oldest_value_reg
name|PARAMS
argument_list|(
operator|(
expr|enum
name|reg_class
operator|,
name|rtx
operator|,
expr|struct
name|value_data
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|replace_oldest_value_reg
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|*
operator|,
expr|enum
name|reg_class
operator|,
name|rtx
operator|,
expr|struct
name|value_data
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|replace_oldest_value_addr
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|*
operator|,
expr|enum
name|reg_class
operator|,
expr|enum
name|machine_mode
operator|,
name|rtx
operator|,
expr|struct
name|value_data
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|replace_oldest_value_mem
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
expr|struct
name|value_data
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|copyprop_hardreg_forward_1
name|PARAMS
argument_list|(
operator|(
name|basic_block
operator|,
expr|struct
name|value_data
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|debug_value_data
name|PARAMS
argument_list|(
operator|(
expr|struct
name|value_data
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|validate_value_data
name|PARAMS
argument_list|(
operator|(
expr|struct
name|value_data
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Kill register REGNO.  This involves removing it from any value lists,    and resetting the value mode to VOIDmode.  */
end_comment

begin_function
specifier|static
name|void
name|kill_value_regno
parameter_list|(
name|regno
parameter_list|,
name|vd
parameter_list|)
name|unsigned
name|int
name|regno
decl_stmt|;
name|struct
name|value_data
modifier|*
name|vd
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|next
decl_stmt|;
if|if
condition|(
name|vd
operator|->
name|e
index|[
name|regno
index|]
operator|.
name|oldest_regno
operator|!=
name|regno
condition|)
block|{
for|for
control|(
name|i
operator|=
name|vd
operator|->
name|e
index|[
name|regno
index|]
operator|.
name|oldest_regno
init|;
name|vd
operator|->
name|e
index|[
name|i
index|]
operator|.
name|next_regno
operator|!=
name|regno
condition|;
name|i
operator|=
name|vd
operator|->
name|e
index|[
name|i
index|]
operator|.
name|next_regno
control|)
continue|continue;
name|vd
operator|->
name|e
index|[
name|i
index|]
operator|.
name|next_regno
operator|=
name|vd
operator|->
name|e
index|[
name|regno
index|]
operator|.
name|next_regno
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|next
operator|=
name|vd
operator|->
name|e
index|[
name|regno
index|]
operator|.
name|next_regno
operator|)
operator|!=
name|INVALID_REGNUM
condition|)
block|{
for|for
control|(
name|i
operator|=
name|next
init|;
name|i
operator|!=
name|INVALID_REGNUM
condition|;
name|i
operator|=
name|vd
operator|->
name|e
index|[
name|i
index|]
operator|.
name|next_regno
control|)
name|vd
operator|->
name|e
index|[
name|i
index|]
operator|.
name|oldest_regno
operator|=
name|next
expr_stmt|;
block|}
name|vd
operator|->
name|e
index|[
name|regno
index|]
operator|.
name|mode
operator|=
name|VOIDmode
expr_stmt|;
name|vd
operator|->
name|e
index|[
name|regno
index|]
operator|.
name|oldest_regno
operator|=
name|regno
expr_stmt|;
name|vd
operator|->
name|e
index|[
name|regno
index|]
operator|.
name|next_regno
operator|=
name|INVALID_REGNUM
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|validate_value_data
argument_list|(
name|vd
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Kill X.  This is a convenience function for kill_value_regno    so that we mind the mode the register is in.  */
end_comment

begin_function
specifier|static
name|void
name|kill_value
parameter_list|(
name|x
parameter_list|,
name|vd
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|struct
name|value_data
modifier|*
name|vd
decl_stmt|;
block|{
if|if
condition|(
name|REG_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|n
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* Kill the value we're told to kill.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
name|kill_value_regno
argument_list|(
name|regno
operator|+
name|i
argument_list|,
name|vd
argument_list|)
expr_stmt|;
comment|/* Kill everything that overlapped what we're told to kill.  */
if|if
condition|(
name|regno
operator|<
name|vd
operator|->
name|max_value_regs
condition|)
name|j
operator|=
literal|0
expr_stmt|;
else|else
name|j
operator|=
name|regno
operator|-
name|vd
operator|->
name|max_value_regs
expr_stmt|;
for|for
control|(
init|;
name|j
operator|<
name|regno
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|vd
operator|->
name|e
index|[
name|j
index|]
operator|.
name|mode
operator|==
name|VOIDmode
condition|)
continue|continue;
name|n
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|j
argument_list|,
name|vd
operator|->
name|e
index|[
name|j
index|]
operator|.
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|+
name|n
operator|>
name|regno
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
name|kill_value_regno
argument_list|(
name|j
operator|+
name|i
argument_list|,
name|vd
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Remember that REGNO is valid in MODE.  */
end_comment

begin_function
specifier|static
name|void
name|set_value_regno
parameter_list|(
name|regno
parameter_list|,
name|mode
parameter_list|,
name|vd
parameter_list|)
name|unsigned
name|int
name|regno
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|struct
name|value_data
modifier|*
name|vd
decl_stmt|;
block|{
name|unsigned
name|int
name|nregs
decl_stmt|;
name|vd
operator|->
name|e
index|[
name|regno
index|]
operator|.
name|mode
operator|=
name|mode
expr_stmt|;
name|nregs
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|nregs
operator|>
name|vd
operator|->
name|max_value_regs
condition|)
name|vd
operator|->
name|max_value_regs
operator|=
name|nregs
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize VD such that there are no known relationships between regs.  */
end_comment

begin_function
specifier|static
name|void
name|init_value_data
parameter_list|(
name|vd
parameter_list|)
name|struct
name|value_data
modifier|*
name|vd
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
operator|++
name|i
control|)
block|{
name|vd
operator|->
name|e
index|[
name|i
index|]
operator|.
name|mode
operator|=
name|VOIDmode
expr_stmt|;
name|vd
operator|->
name|e
index|[
name|i
index|]
operator|.
name|oldest_regno
operator|=
name|i
expr_stmt|;
name|vd
operator|->
name|e
index|[
name|i
index|]
operator|.
name|next_regno
operator|=
name|INVALID_REGNUM
expr_stmt|;
block|}
name|vd
operator|->
name|max_value_regs
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called through note_stores.  If X is clobbered, kill its value.  */
end_comment

begin_function
specifier|static
name|void
name|kill_clobbered_value
parameter_list|(
name|x
parameter_list|,
name|set
parameter_list|,
name|data
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|set
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|struct
name|value_data
modifier|*
name|vd
init|=
name|data
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|set
argument_list|)
operator|==
name|CLOBBER
condition|)
name|kill_value
argument_list|(
name|x
argument_list|,
name|vd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called through note_stores.  If X is set, not clobbered, kill its     current value and install it as the root of its own value list.  */
end_comment

begin_function
specifier|static
name|void
name|kill_set_value
parameter_list|(
name|x
parameter_list|,
name|set
parameter_list|,
name|data
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|set
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|struct
name|value_data
modifier|*
name|vd
init|=
name|data
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|set
argument_list|)
operator|!=
name|CLOBBER
operator|&&
name|REG_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|kill_value
argument_list|(
name|x
argument_list|,
name|vd
argument_list|)
expr_stmt|;
name|set_value_regno
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|vd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Called through for_each_rtx.  Kill any register used as the base of an    auto-increment expression, and install that register as the root of its    own value list.  */
end_comment

begin_function
specifier|static
name|int
name|kill_autoinc_value
parameter_list|(
name|px
parameter_list|,
name|data
parameter_list|)
name|rtx
modifier|*
name|px
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|rtx
name|x
init|=
operator|*
name|px
decl_stmt|;
name|struct
name|value_data
modifier|*
name|vd
init|=
name|data
decl_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
literal|'a'
condition|)
block|{
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|kill_value
argument_list|(
name|x
argument_list|,
name|vd
argument_list|)
expr_stmt|;
name|set_value_regno
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|vd
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Assert that SRC has been copied to DEST.  Adjust the data structures    to reflect that SRC contains an older copy of the shared value.  */
end_comment

begin_function
specifier|static
name|void
name|copy_value
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|,
name|vd
parameter_list|)
name|rtx
name|dest
decl_stmt|;
name|rtx
name|src
decl_stmt|;
name|struct
name|value_data
modifier|*
name|vd
decl_stmt|;
block|{
name|unsigned
name|int
name|dr
init|=
name|REGNO
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|sr
init|=
name|REGNO
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|dn
decl_stmt|,
name|sn
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* ??? At present, it's possible to see noop sets.  It'd be nice if      this were cleaned up beforehand...  */
if|if
condition|(
name|sr
operator|==
name|dr
condition|)
return|return;
comment|/* Do not propagate copies to the stack pointer, as that can leave      memory accesses with no scheduling dependancy on the stack update.  */
if|if
condition|(
name|dr
operator|==
name|STACK_POINTER_REGNUM
condition|)
return|return;
comment|/* Likewise with the frame pointer, if we're using one.  */
if|if
condition|(
name|frame_pointer_needed
operator|&&
name|dr
operator|==
name|HARD_FRAME_POINTER_REGNUM
condition|)
return|return;
comment|/* If SRC and DEST overlap, don't record anything.  */
name|dn
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|dr
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
name|sn
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|sr
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dr
operator|>
name|sr
operator|&&
name|dr
operator|<
name|sr
operator|+
name|sn
operator|)
operator|||
operator|(
name|sr
operator|>
name|dr
operator|&&
name|sr
operator|<
name|dr
operator|+
name|dn
operator|)
condition|)
return|return;
comment|/* If SRC had no assigned mode (i.e. we didn't know it was live)      assign it now and assume the value came from an input argument      or somesuch.  */
if|if
condition|(
name|vd
operator|->
name|e
index|[
name|sr
index|]
operator|.
name|mode
operator|==
name|VOIDmode
condition|)
name|set_value_regno
argument_list|(
name|sr
argument_list|,
name|vd
operator|->
name|e
index|[
name|dr
index|]
operator|.
name|mode
argument_list|,
name|vd
argument_list|)
expr_stmt|;
comment|/* If SRC had been assigned a mode narrower than the copy, we can't      link DEST into the chain, because not all of the pieces of the      copy came from oldest_regno.  */
elseif|else
if|if
condition|(
name|sn
operator|>
operator|(
name|unsigned
name|int
operator|)
name|HARD_REGNO_NREGS
argument_list|(
name|sr
argument_list|,
name|vd
operator|->
name|e
index|[
name|sr
index|]
operator|.
name|mode
argument_list|)
condition|)
return|return;
comment|/* Link DR at the end of the value chain used by SR.  */
name|vd
operator|->
name|e
index|[
name|dr
index|]
operator|.
name|oldest_regno
operator|=
name|vd
operator|->
name|e
index|[
name|sr
index|]
operator|.
name|oldest_regno
expr_stmt|;
for|for
control|(
name|i
operator|=
name|sr
init|;
name|vd
operator|->
name|e
index|[
name|i
index|]
operator|.
name|next_regno
operator|!=
name|INVALID_REGNUM
condition|;
name|i
operator|=
name|vd
operator|->
name|e
index|[
name|i
index|]
operator|.
name|next_regno
control|)
continue|continue;
name|vd
operator|->
name|e
index|[
name|i
index|]
operator|.
name|next_regno
operator|=
name|dr
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|validate_value_data
argument_list|(
name|vd
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Return true if a mode change from ORIG to NEW is allowed for REGNO.  */
end_comment

begin_function
specifier|static
name|bool
name|mode_change_ok
parameter_list|(
name|orig_mode
parameter_list|,
name|new_mode
parameter_list|,
name|regno
parameter_list|)
name|enum
name|machine_mode
name|orig_mode
decl_stmt|,
name|new_mode
decl_stmt|;
name|unsigned
name|int
name|regno
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|orig_mode
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|new_mode
argument_list|)
condition|)
return|return
name|false
return|;
ifdef|#
directive|ifdef
name|CLASS_CANNOT_CHANGE_MODE
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|CLASS_CANNOT_CHANGE_MODE
index|]
argument_list|,
name|regno
argument_list|)
operator|&&
name|CLASS_CANNOT_CHANGE_MODE_P
argument_list|(
name|orig_mode
argument_list|,
name|new_mode
argument_list|)
condition|)
return|return
name|false
return|;
endif|#
directive|endif
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Find the oldest copy of the value contained in REGNO that is in    register class CLASS and has mode MODE.  If found, return an rtx    of that oldest register, otherwise return NULL.  */
end_comment

begin_function
specifier|static
name|rtx
name|find_oldest_value_reg
parameter_list|(
name|class
parameter_list|,
name|reg
parameter_list|,
name|vd
parameter_list|)
name|enum
name|reg_class
name|class
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
name|struct
name|value_data
modifier|*
name|vd
decl_stmt|;
block|{
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|reg
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|reg
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* If we are accessing REG in some mode other that what we set it in,      make sure that the replacement is valid.  In particular, consider 	(set (reg:DI r11) (...)) 	(set (reg:SI r9) (reg:SI r11)) 	(set (reg:SI r10) (...)) 	(set (...) (reg:DI r9))      Replacing r9 with r11 is invalid.  */
if|if
condition|(
name|mode
operator|!=
name|vd
operator|->
name|e
index|[
name|regno
index|]
operator|.
name|mode
condition|)
block|{
if|if
condition|(
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|>
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|vd
operator|->
name|e
index|[
name|regno
index|]
operator|.
name|mode
argument_list|)
condition|)
return|return
name|NULL_RTX
return|;
block|}
for|for
control|(
name|i
operator|=
name|vd
operator|->
name|e
index|[
name|regno
index|]
operator|.
name|oldest_regno
init|;
name|i
operator|!=
name|regno
condition|;
name|i
operator|=
name|vd
operator|->
name|e
index|[
name|i
index|]
operator|.
name|next_regno
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|class
index|]
argument_list|,
name|i
argument_list|)
operator|&&
operator|(
name|vd
operator|->
name|e
index|[
name|i
index|]
operator|.
name|mode
operator|==
name|mode
operator|||
name|mode_change_ok
argument_list|(
name|vd
operator|->
name|e
index|[
name|i
index|]
operator|.
name|mode
argument_list|,
name|mode
argument_list|,
name|i
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|new
init|=
name|gen_rtx_raw_REG
argument_list|(
name|mode
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|ORIGINAL_REGNO
argument_list|(
name|new
argument_list|)
operator|=
name|ORIGINAL_REGNO
argument_list|(
name|reg
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_comment
comment|/* If possible, replace the register at *LOC with the oldest register    in register class CLASS.  Return true if successfully replaced.  */
end_comment

begin_function
specifier|static
name|bool
name|replace_oldest_value_reg
parameter_list|(
name|loc
parameter_list|,
name|class
parameter_list|,
name|insn
parameter_list|,
name|vd
parameter_list|)
name|rtx
modifier|*
name|loc
decl_stmt|;
name|enum
name|reg_class
name|class
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|struct
name|value_data
modifier|*
name|vd
decl_stmt|;
block|{
name|rtx
name|new
init|=
name|find_oldest_value_reg
argument_list|(
name|class
argument_list|,
operator|*
name|loc
argument_list|,
name|vd
argument_list|)
decl_stmt|;
if|if
condition|(
name|new
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"insn %u: replaced reg %u with %u\n"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|REGNO
argument_list|(
operator|*
name|loc
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|new
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|loc
operator|=
name|new
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Similar to replace_oldest_value_reg, but *LOC contains an address.    Adapted from find_reloads_address_1.  CLASS is INDEX_REG_CLASS or    BASE_REG_CLASS depending on how the register is being considered.  */
end_comment

begin_function
specifier|static
name|bool
name|replace_oldest_value_addr
parameter_list|(
name|loc
parameter_list|,
name|class
parameter_list|,
name|mode
parameter_list|,
name|insn
parameter_list|,
name|vd
parameter_list|)
name|rtx
modifier|*
name|loc
decl_stmt|;
name|enum
name|reg_class
name|class
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|struct
name|value_data
modifier|*
name|vd
decl_stmt|;
block|{
name|rtx
name|x
init|=
operator|*
name|loc
decl_stmt|;
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|bool
name|changed
init|=
name|false
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS
case|:
block|{
name|rtx
name|orig_op0
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|orig_op1
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|RTX_CODE
name|code0
init|=
name|GET_CODE
argument_list|(
name|orig_op0
argument_list|)
decl_stmt|;
name|RTX_CODE
name|code1
init|=
name|GET_CODE
argument_list|(
name|orig_op1
argument_list|)
decl_stmt|;
name|rtx
name|op0
init|=
name|orig_op0
decl_stmt|;
name|rtx
name|op1
init|=
name|orig_op1
decl_stmt|;
name|rtx
modifier|*
name|locI
init|=
name|NULL
decl_stmt|;
name|rtx
modifier|*
name|locB
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|op0
operator|=
name|SUBREG_REG
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|code0
operator|=
name|GET_CODE
argument_list|(
name|op0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|op1
operator|=
name|SUBREG_REG
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|code1
operator|=
name|GET_CODE
argument_list|(
name|op1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code0
operator|==
name|MULT
operator|||
name|code0
operator|==
name|SIGN_EXTEND
operator|||
name|code0
operator|==
name|TRUNCATE
operator|||
name|code0
operator|==
name|ZERO_EXTEND
operator|||
name|code1
operator|==
name|MEM
condition|)
block|{
name|locI
operator|=
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|locB
operator|=
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|MULT
operator|||
name|code1
operator|==
name|SIGN_EXTEND
operator|||
name|code1
operator|==
name|TRUNCATE
operator|||
name|code1
operator|==
name|ZERO_EXTEND
operator|||
name|code0
operator|==
name|MEM
condition|)
block|{
name|locI
operator|=
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|locB
operator|=
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|CONST_INT
operator|||
name|code0
operator|==
name|CONST
operator|||
name|code0
operator|==
name|SYMBOL_REF
operator|||
name|code0
operator|==
name|LABEL_REF
condition|)
name|locB
operator|=
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code1
operator|==
name|CONST_INT
operator|||
name|code1
operator|==
name|CONST
operator|||
name|code1
operator|==
name|SYMBOL_REF
operator|||
name|code1
operator|==
name|LABEL_REF
condition|)
name|locB
operator|=
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code0
operator|==
name|REG
operator|&&
name|code1
operator|==
name|REG
condition|)
block|{
name|int
name|index_op
decl_stmt|;
if|if
condition|(
name|REG_OK_FOR_INDEX_P
argument_list|(
name|op0
argument_list|)
operator|&&
name|REG_MODE_OK_FOR_BASE_P
argument_list|(
name|op1
argument_list|,
name|mode
argument_list|)
condition|)
name|index_op
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_OK_FOR_INDEX_P
argument_list|(
name|op1
argument_list|)
operator|&&
name|REG_MODE_OK_FOR_BASE_P
argument_list|(
name|op0
argument_list|,
name|mode
argument_list|)
condition|)
name|index_op
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_MODE_OK_FOR_BASE_P
argument_list|(
name|op1
argument_list|,
name|mode
argument_list|)
condition|)
name|index_op
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_MODE_OK_FOR_BASE_P
argument_list|(
name|op0
argument_list|,
name|mode
argument_list|)
condition|)
name|index_op
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_OK_FOR_INDEX_P
argument_list|(
name|op1
argument_list|)
condition|)
name|index_op
operator|=
literal|1
expr_stmt|;
else|else
name|index_op
operator|=
literal|0
expr_stmt|;
name|locI
operator|=
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|index_op
argument_list|)
expr_stmt|;
name|locB
operator|=
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
operator|!
name|index_op
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|REG
condition|)
block|{
name|locI
operator|=
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|locB
operator|=
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|REG
condition|)
block|{
name|locI
operator|=
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|locB
operator|=
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|locI
condition|)
name|changed
operator||=
name|replace_oldest_value_addr
argument_list|(
name|locI
argument_list|,
name|INDEX_REG_CLASS
argument_list|,
name|mode
argument_list|,
name|insn
argument_list|,
name|vd
argument_list|)
expr_stmt|;
if|if
condition|(
name|locB
condition|)
name|changed
operator||=
name|replace_oldest_value_addr
argument_list|(
name|locB
argument_list|,
name|MODE_BASE_REG_CLASS
argument_list|(
name|mode
argument_list|)
argument_list|,
name|mode
argument_list|,
name|insn
argument_list|,
name|vd
argument_list|)
expr_stmt|;
return|return
name|changed
return|;
block|}
case|case
name|POST_INC
case|:
case|case
name|POST_DEC
case|:
case|case
name|POST_MODIFY
case|:
case|case
name|PRE_INC
case|:
case|case
name|PRE_DEC
case|:
case|case
name|PRE_MODIFY
case|:
return|return
name|false
return|;
case|case
name|MEM
case|:
return|return
name|replace_oldest_value_mem
argument_list|(
name|x
argument_list|,
name|insn
argument_list|,
name|vd
argument_list|)
return|;
case|case
name|REG
case|:
return|return
name|replace_oldest_value_reg
argument_list|(
name|loc
argument_list|,
name|class
argument_list|,
name|insn
argument_list|,
name|vd
argument_list|)
return|;
default|default:
break|break;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|changed
operator||=
name|replace_oldest_value_addr
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|class
argument_list|,
name|mode
argument_list|,
name|insn
argument_list|,
name|vd
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|changed
operator||=
name|replace_oldest_value_addr
argument_list|(
operator|&
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|class
argument_list|,
name|mode
argument_list|,
name|insn
argument_list|,
name|vd
argument_list|)
expr_stmt|;
block|}
return|return
name|changed
return|;
block|}
end_function

begin_comment
comment|/* Similar to replace_oldest_value_reg, but X contains a memory.  */
end_comment

begin_function
specifier|static
name|bool
name|replace_oldest_value_mem
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|,
name|vd
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|struct
name|value_data
modifier|*
name|vd
decl_stmt|;
block|{
return|return
name|replace_oldest_value_addr
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|MODE_BASE_REG_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|insn
argument_list|,
name|vd
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Perform the forward copy propagation on basic block BB.  */
end_comment

begin_function
specifier|static
name|bool
name|copyprop_hardreg_forward_1
parameter_list|(
name|bb
parameter_list|,
name|vd
parameter_list|)
name|basic_block
name|bb
decl_stmt|;
name|struct
name|value_data
modifier|*
name|vd
decl_stmt|;
block|{
name|bool
name|changed
init|=
name|false
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|bb
operator|->
name|head
init|;
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|int
name|n_ops
decl_stmt|,
name|i
decl_stmt|,
name|alt
decl_stmt|,
name|predicated
decl_stmt|;
name|bool
name|is_asm
decl_stmt|;
name|rtx
name|set
decl_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
if|if
condition|(
name|insn
operator|==
name|bb
operator|->
name|end
condition|)
break|break;
else|else
continue|continue;
block|}
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|extract_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|constrain_operands
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|preprocess_constraints
argument_list|()
expr_stmt|;
name|alt
operator|=
name|which_alternative
expr_stmt|;
name|n_ops
operator|=
name|recog_data
operator|.
name|n_operands
expr_stmt|;
name|is_asm
operator|=
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|>=
literal|0
expr_stmt|;
comment|/* Simplify the code below by rewriting things to reflect 	 matching constraints.  Also promote OP_OUT to OP_INOUT 	 in predicated instructions.  */
name|predicated
operator|=
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|COND_EXEC
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_ops
condition|;
operator|++
name|i
control|)
block|{
name|int
name|matches
init|=
name|recog_op_alt
index|[
name|i
index|]
index|[
name|alt
index|]
operator|.
name|matches
decl_stmt|;
if|if
condition|(
name|matches
operator|>=
literal|0
condition|)
name|recog_op_alt
index|[
name|i
index|]
index|[
name|alt
index|]
operator|.
name|class
operator|=
name|recog_op_alt
index|[
name|matches
index|]
index|[
name|alt
index|]
operator|.
name|class
expr_stmt|;
if|if
condition|(
name|matches
operator|>=
literal|0
operator|||
name|recog_op_alt
index|[
name|i
index|]
index|[
name|alt
index|]
operator|.
name|matched
operator|>=
literal|0
operator|||
operator|(
name|predicated
operator|&&
name|recog_data
operator|.
name|operand_type
index|[
name|i
index|]
operator|==
name|OP_OUT
operator|)
condition|)
name|recog_data
operator|.
name|operand_type
index|[
name|i
index|]
operator|=
name|OP_INOUT
expr_stmt|;
block|}
comment|/* For each earlyclobber operand, zap the value data.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_ops
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|recog_op_alt
index|[
name|i
index|]
index|[
name|alt
index|]
operator|.
name|earlyclobber
condition|)
name|kill_value
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|,
name|vd
argument_list|)
expr_stmt|;
comment|/* Within asms, a clobber cannot overlap inputs or outputs. 	 I wouldn't think this were true for regular insns, but 	 scan_rtx treats them like that...  */
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|kill_clobbered_value
argument_list|,
name|vd
argument_list|)
expr_stmt|;
comment|/* Kill all auto-incremented values.  */
comment|/* ??? REG_INC is useless, since stack pushes aren't done that way.  */
name|for_each_rtx
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|kill_autoinc_value
argument_list|,
name|vd
argument_list|)
expr_stmt|;
comment|/* Kill all early-clobbered operands.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_ops
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|recog_op_alt
index|[
name|i
index|]
index|[
name|alt
index|]
operator|.
name|earlyclobber
condition|)
name|kill_value
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|,
name|vd
argument_list|)
expr_stmt|;
comment|/* Special-case plain move instructions, since we may well 	 be able to do the move from a different register class.  */
if|if
condition|(
name|set
operator|&&
name|REG_P
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|rtx
name|new
decl_stmt|;
comment|/* If we are accessing SRC in some mode other that what we 	     set it in, make sure that the replacement is valid.  */
if|if
condition|(
name|mode
operator|!=
name|vd
operator|->
name|e
index|[
name|regno
index|]
operator|.
name|mode
condition|)
block|{
if|if
condition|(
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|>
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|vd
operator|->
name|e
index|[
name|regno
index|]
operator|.
name|mode
argument_list|)
condition|)
goto|goto
name|no_move_special_case
goto|;
block|}
comment|/* If the destination is also a register, try to find a source 	     register in the same class.  */
if|if
condition|(
name|REG_P
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
condition|)
block|{
name|new
operator|=
name|find_oldest_value_reg
argument_list|(
name|REGNO_REG_CLASS
argument_list|(
name|regno
argument_list|)
argument_list|,
name|src
argument_list|,
name|vd
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|&&
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|new
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"insn %u: replaced reg %u with %u\n"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|regno
argument_list|,
name|REGNO
argument_list|(
name|new
argument_list|)
argument_list|)
expr_stmt|;
name|changed
operator|=
name|true
expr_stmt|;
goto|goto
name|did_replacement
goto|;
block|}
block|}
comment|/* Otherwise, try all valid registers and see if its valid.  */
for|for
control|(
name|i
operator|=
name|vd
operator|->
name|e
index|[
name|regno
index|]
operator|.
name|oldest_regno
init|;
name|i
operator|!=
name|regno
condition|;
name|i
operator|=
name|vd
operator|->
name|e
index|[
name|i
index|]
operator|.
name|next_regno
control|)
if|if
condition|(
name|vd
operator|->
name|e
index|[
name|i
index|]
operator|.
name|mode
operator|==
name|mode
operator|||
name|mode_change_ok
argument_list|(
name|vd
operator|->
name|e
index|[
name|i
index|]
operator|.
name|mode
argument_list|,
name|mode
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|new
operator|=
name|gen_rtx_raw_REG
argument_list|(
name|mode
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|new
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|ORIGINAL_REGNO
argument_list|(
name|new
argument_list|)
operator|=
name|ORIGINAL_REGNO
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"insn %u: replaced reg %u with %u\n"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|regno
argument_list|,
name|REGNO
argument_list|(
name|new
argument_list|)
argument_list|)
expr_stmt|;
name|changed
operator|=
name|true
expr_stmt|;
goto|goto
name|did_replacement
goto|;
block|}
block|}
block|}
name|no_move_special_case
label|:
comment|/* For each input operand, replace a hard register with the 	 eldest live copy that's in an appropriate register class.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_ops
condition|;
name|i
operator|++
control|)
block|{
name|bool
name|replaced
init|=
name|false
decl_stmt|;
comment|/* Don't scan match_operand here, since we've no reg class 	     information to pass down.  Any operands that we could 	     substitute in will be represented elsewhere.  */
if|if
condition|(
name|recog_data
operator|.
name|constraints
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
continue|continue;
comment|/* Don't replace in asms intentionally referencing hard regs.  */
if|if
condition|(
name|is_asm
operator|&&
name|GET_CODE
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|REGNO
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
operator|==
name|ORIGINAL_REGNO
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
operator|)
condition|)
continue|continue;
if|if
condition|(
name|recog_data
operator|.
name|operand_type
index|[
name|i
index|]
operator|==
name|OP_IN
condition|)
block|{
if|if
condition|(
name|recog_op_alt
index|[
name|i
index|]
index|[
name|alt
index|]
operator|.
name|is_address
condition|)
name|replaced
operator|=
name|replace_oldest_value_addr
argument_list|(
name|recog_data
operator|.
name|operand_loc
index|[
name|i
index|]
argument_list|,
name|recog_op_alt
index|[
name|i
index|]
index|[
name|alt
index|]
operator|.
name|class
argument_list|,
name|VOIDmode
argument_list|,
name|insn
argument_list|,
name|vd
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_P
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
condition|)
name|replaced
operator|=
name|replace_oldest_value_reg
argument_list|(
name|recog_data
operator|.
name|operand_loc
index|[
name|i
index|]
argument_list|,
name|recog_op_alt
index|[
name|i
index|]
index|[
name|alt
index|]
operator|.
name|class
argument_list|,
name|insn
argument_list|,
name|vd
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
operator|==
name|MEM
condition|)
name|replaced
operator|=
name|replace_oldest_value_mem
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|,
name|insn
argument_list|,
name|vd
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
operator|==
name|MEM
condition|)
name|replaced
operator|=
name|replace_oldest_value_mem
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|,
name|insn
argument_list|,
name|vd
argument_list|)
expr_stmt|;
comment|/* If we performed any replacement, update match_dups.  */
if|if
condition|(
name|replaced
condition|)
block|{
name|int
name|j
decl_stmt|;
name|rtx
name|new
decl_stmt|;
name|changed
operator|=
name|true
expr_stmt|;
name|new
operator|=
operator|*
name|recog_data
operator|.
name|operand_loc
index|[
name|i
index|]
expr_stmt|;
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
operator|=
name|new
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|recog_data
operator|.
name|n_dups
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|recog_data
operator|.
name|dup_num
index|[
name|j
index|]
operator|==
name|i
condition|)
operator|*
name|recog_data
operator|.
name|dup_loc
index|[
name|j
index|]
operator|=
name|new
expr_stmt|;
block|}
block|}
name|did_replacement
label|:
comment|/* Clobber call-clobbered registers.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|regs_invalidated_by_call
argument_list|,
name|i
argument_list|)
condition|)
name|kill_value_regno
argument_list|(
name|i
argument_list|,
name|vd
argument_list|)
expr_stmt|;
comment|/* Notice stores.  */
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|kill_set_value
argument_list|,
name|vd
argument_list|)
expr_stmt|;
comment|/* Notice copies.  */
if|if
condition|(
name|set
operator|&&
name|REG_P
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|&&
name|REG_P
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
condition|)
name|copy_value
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|vd
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|bb
operator|->
name|end
condition|)
break|break;
block|}
return|return
name|changed
return|;
block|}
end_function

begin_comment
comment|/* Main entry point for the forward copy propagation optimization.  */
end_comment

begin_function
name|void
name|copyprop_hardreg_forward
parameter_list|()
block|{
name|struct
name|value_data
modifier|*
name|all_vd
decl_stmt|;
name|bool
name|need_refresh
decl_stmt|;
name|int
name|b
decl_stmt|;
name|need_refresh
operator|=
name|false
expr_stmt|;
name|all_vd
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|value_data
argument_list|)
operator|*
name|n_basic_blocks
argument_list|)
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|n_basic_blocks
condition|;
name|b
operator|++
control|)
block|{
name|basic_block
name|bb
init|=
name|BASIC_BLOCK
argument_list|(
name|b
argument_list|)
decl_stmt|;
comment|/* If a block has a single predecessor, that we've already 	 processed, begin with the value data that was live at 	 the end of the predecessor block.  */
comment|/* ??? Ought to use more intelligent queueing of blocks.  */
if|if
condition|(
name|bb
operator|->
name|pred
operator|&&
operator|!
name|bb
operator|->
name|pred
operator|->
name|pred_next
operator|&&
operator|!
operator|(
name|bb
operator|->
name|pred
operator|->
name|flags
operator|&
operator|(
name|EDGE_ABNORMAL_CALL
operator||
name|EDGE_EH
operator|)
operator|)
operator|&&
name|bb
operator|->
name|pred
operator|->
name|src
operator|->
name|index
operator|!=
name|ENTRY_BLOCK
operator|&&
name|bb
operator|->
name|pred
operator|->
name|src
operator|->
name|index
operator|<
name|b
condition|)
name|all_vd
index|[
name|b
index|]
operator|=
name|all_vd
index|[
name|bb
operator|->
name|pred
operator|->
name|src
operator|->
name|index
index|]
expr_stmt|;
else|else
name|init_value_data
argument_list|(
name|all_vd
operator|+
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|copyprop_hardreg_forward_1
argument_list|(
name|bb
argument_list|,
name|all_vd
operator|+
name|b
argument_list|)
condition|)
name|need_refresh
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|need_refresh
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
name|fputs
argument_list|(
literal|"\n\n"
argument_list|,
name|rtl_dump_file
argument_list|)
expr_stmt|;
comment|/* ??? Irritatingly, delete_noop_moves does not take a set of blocks 	 to scan, so we have to do a life update with no initial set of 	 blocks Just In Case.  */
name|delete_noop_moves
argument_list|(
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
name|update_life_info
argument_list|(
name|NULL
argument_list|,
name|UPDATE_LIFE_GLOBAL_RM_NOTES
argument_list|,
name|PROP_DEATH_NOTES
operator||
name|PROP_SCAN_DEAD_CODE
operator||
name|PROP_KILL_DEAD_CODE
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|all_vd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump the value chain data to stderr.  */
end_comment

begin_function
name|void
name|debug_value_data
parameter_list|(
name|vd
parameter_list|)
name|struct
name|value_data
modifier|*
name|vd
decl_stmt|;
block|{
name|HARD_REG_SET
name|set
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|set
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|vd
operator|->
name|e
index|[
name|i
index|]
operator|.
name|oldest_regno
operator|==
name|i
condition|)
block|{
if|if
condition|(
name|vd
operator|->
name|e
index|[
name|i
index|]
operator|.
name|mode
operator|==
name|VOIDmode
condition|)
block|{
if|if
condition|(
name|vd
operator|->
name|e
index|[
name|i
index|]
operator|.
name|next_regno
operator|!=
name|INVALID_REGNUM
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[%u] Bad next_regno for empty chain (%u)\n"
argument_list|,
name|i
argument_list|,
name|vd
operator|->
name|e
index|[
name|i
index|]
operator|.
name|next_regno
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|SET_HARD_REG_BIT
argument_list|(
name|set
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[%u %s] "
argument_list|,
name|i
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|vd
operator|->
name|e
index|[
name|i
index|]
operator|.
name|mode
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|vd
operator|->
name|e
index|[
name|i
index|]
operator|.
name|next_regno
init|;
name|j
operator|!=
name|INVALID_REGNUM
condition|;
name|j
operator|=
name|vd
operator|->
name|e
index|[
name|j
index|]
operator|.
name|next_regno
control|)
block|{
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|set
argument_list|,
name|j
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[%u] Loop in regno chain\n"
argument_list|,
name|j
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|vd
operator|->
name|e
index|[
name|j
index|]
operator|.
name|oldest_regno
operator|!=
name|i
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[%u] Bad oldest_regno (%u)\n"
argument_list|,
name|j
argument_list|,
name|vd
operator|->
name|e
index|[
name|j
index|]
operator|.
name|oldest_regno
argument_list|)
expr_stmt|;
return|return;
block|}
name|SET_HARD_REG_BIT
argument_list|(
name|set
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[%u %s] "
argument_list|,
name|j
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|vd
operator|->
name|e
index|[
name|j
index|]
operator|.
name|mode
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|set
argument_list|,
name|i
argument_list|)
operator|&&
operator|(
name|vd
operator|->
name|e
index|[
name|i
index|]
operator|.
name|mode
operator|!=
name|VOIDmode
operator|||
name|vd
operator|->
name|e
index|[
name|i
index|]
operator|.
name|oldest_regno
operator|!=
name|i
operator|||
name|vd
operator|->
name|e
index|[
name|i
index|]
operator|.
name|next_regno
operator|!=
name|INVALID_REGNUM
operator|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[%u] Non-empty reg in chain (%s %u %i)\n"
argument_list|,
name|i
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|vd
operator|->
name|e
index|[
name|i
index|]
operator|.
name|mode
argument_list|)
argument_list|,
name|vd
operator|->
name|e
index|[
name|i
index|]
operator|.
name|oldest_regno
argument_list|,
name|vd
operator|->
name|e
index|[
name|i
index|]
operator|.
name|next_regno
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
end_ifdef

begin_function
specifier|static
name|void
name|validate_value_data
parameter_list|(
name|vd
parameter_list|)
name|struct
name|value_data
modifier|*
name|vd
decl_stmt|;
block|{
name|HARD_REG_SET
name|set
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|set
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|vd
operator|->
name|e
index|[
name|i
index|]
operator|.
name|oldest_regno
operator|==
name|i
condition|)
block|{
if|if
condition|(
name|vd
operator|->
name|e
index|[
name|i
index|]
operator|.
name|mode
operator|==
name|VOIDmode
condition|)
block|{
if|if
condition|(
name|vd
operator|->
name|e
index|[
name|i
index|]
operator|.
name|next_regno
operator|!=
name|INVALID_REGNUM
condition|)
name|internal_error
argument_list|(
literal|"validate_value_data: [%u] Bad next_regno for empty chain (%u)"
argument_list|,
name|i
argument_list|,
name|vd
operator|->
name|e
index|[
name|i
index|]
operator|.
name|next_regno
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|SET_HARD_REG_BIT
argument_list|(
name|set
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|vd
operator|->
name|e
index|[
name|i
index|]
operator|.
name|next_regno
init|;
name|j
operator|!=
name|INVALID_REGNUM
condition|;
name|j
operator|=
name|vd
operator|->
name|e
index|[
name|j
index|]
operator|.
name|next_regno
control|)
block|{
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|set
argument_list|,
name|j
argument_list|)
condition|)
name|internal_error
argument_list|(
literal|"validate_value_data: Loop in regno chain (%u)"
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|e
index|[
name|j
index|]
operator|.
name|oldest_regno
operator|!=
name|i
condition|)
name|internal_error
argument_list|(
literal|"validate_value_data: [%u] Bad oldest_regno (%u)"
argument_list|,
name|j
argument_list|,
name|vd
operator|->
name|e
index|[
name|j
index|]
operator|.
name|oldest_regno
argument_list|)
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|set
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|set
argument_list|,
name|i
argument_list|)
operator|&&
operator|(
name|vd
operator|->
name|e
index|[
name|i
index|]
operator|.
name|mode
operator|!=
name|VOIDmode
operator|||
name|vd
operator|->
name|e
index|[
name|i
index|]
operator|.
name|oldest_regno
operator|!=
name|i
operator|||
name|vd
operator|->
name|e
index|[
name|i
index|]
operator|.
name|next_regno
operator|!=
name|INVALID_REGNUM
operator|)
condition|)
name|internal_error
argument_list|(
literal|"validate_value_data: [%u] Non-empty reg in chain (%s %u %i)"
argument_list|,
name|i
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|vd
operator|->
name|e
index|[
name|i
index|]
operator|.
name|mode
argument_list|)
argument_list|,
name|vd
operator|->
name|e
index|[
name|i
index|]
operator|.
name|oldest_regno
argument_list|,
name|vd
operator|->
name|e
index|[
name|i
index|]
operator|.
name|next_regno
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

