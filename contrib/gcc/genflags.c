begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Generate from machine description:     - some flags HAVE_... saying which simple standard instructions are    available for this machine.    Copyright (C) 1987, 1991, 1995, 1998, 1999 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"hconfig.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|obstack
modifier|*
name|rtl_obstack
init|=
operator|&
name|obstack
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_decl_stmt
name|void
name|fatal
name|PVPROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
name|ATTRIBUTE_PRINTF_1
name|ATTRIBUTE_NORETURN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|fancy_abort
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
name|ATTRIBUTE_NORETURN
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Names for patterns.  Need to allow linking with print-rtl.  */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|insn_name_ptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Obstacks to remember normal, and call insns.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|call_obstack
decl_stmt|,
name|normal_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Max size of names encountered.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_id_len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|num_operands
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_proto
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_nonproto
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_insn
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Count the number of match_operand's found.  */
end_comment

begin_function
specifier|static
name|int
name|num_operands
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|char
modifier|*
name|format_ptr
init|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|MATCH_OPERAND
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|code
operator|==
name|MATCH_OPERATOR
operator|||
name|code
operator|==
name|MATCH_PARALLEL
condition|)
name|count
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|format_ptr
operator|++
condition|)
block|{
case|case
literal|'u'
case|:
case|case
literal|'e'
case|:
name|count
operator|+=
name|num_operands
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
if|if
condition|(
name|XVEC
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|NULL
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|count
operator|+=
name|num_operands
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/* Print out prototype information for a function.  */
end_comment

begin_function
specifier|static
name|void
name|gen_proto
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|num
init|=
name|num_operands
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"extern rtx gen_%-*s PROTO(("
argument_list|,
name|max_id_len
argument_list|,
name|XSTR
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|num
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"void"
argument_list|)
expr_stmt|;
else|else
block|{
while|while
condition|(
name|num
operator|--
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"rtx, "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"rtx"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"));\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print out a function declaration without a prototype.  */
end_comment

begin_function
specifier|static
name|void
name|gen_nonproto
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"extern rtx gen_%s ();\n"
argument_list|,
name|XSTR
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gen_insn
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|char
modifier|*
name|name
init|=
name|XSTR
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|obstack
modifier|*
name|obstack_ptr
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* Don't mention instructions whose names are the null string      or begin with '*'.  They are in the machine description just      to be recognized.  */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|0
operator|||
name|name
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
return|return;
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|max_id_len
condition|)
name|max_id_len
operator|=
name|len
expr_stmt|;
name|printf
argument_list|(
literal|"#define HAVE_%s "
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|XSTR
argument_list|(
name|insn
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"1\n"
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Write the macro definition, putting \'s at the end of each line, 	 if more than one.  */
name|printf
argument_list|(
literal|"("
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|XSTR
argument_list|(
name|insn
argument_list|,
literal|2
argument_list|)
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
name|printf
argument_list|(
literal|" \\\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%c"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Save the current insn, so that we can later put out appropriate      prototypes.  At present, most md files have the wrong number of      arguments for the call insns (call, call_value, call_pop,      call_value_pop) ignoring the extra arguments that are passed for      some machines, so by default, turn off the prototype.  */
name|obstack_ptr
operator|=
operator|(
name|name
index|[
literal|0
index|]
operator|==
literal|'c'
operator|&&
operator|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"call"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"call_value"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"call_pop"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"call_value_pop"
argument_list|)
operator|)
operator|)
condition|?
operator|&
name|call_obstack
else|:
operator|&
name|normal_obstack
expr_stmt|;
name|obstack_grow
argument_list|(
name|obstack_ptr
argument_list|,
operator|&
name|insn
argument_list|,
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|PTR
name|xmalloc
parameter_list|(
name|size
parameter_list|)
name|size_t
name|size
decl_stmt|;
block|{
specifier|register
name|PTR
name|val
init|=
operator|(
name|PTR
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
name|PTR
name|xrealloc
parameter_list|(
name|old
parameter_list|,
name|size
parameter_list|)
name|PTR
name|old
decl_stmt|;
name|size_t
name|size
decl_stmt|;
block|{
specifier|register
name|PTR
name|ptr
decl_stmt|;
if|if
condition|(
name|old
condition|)
name|ptr
operator|=
operator|(
name|PTR
operator|)
name|realloc
argument_list|(
name|old
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
name|ptr
operator|=
operator|(
name|PTR
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
name|fatal
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_decl_stmt
name|void
name|fatal
name|VPROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|format
operator|,
operator|...
operator|)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
specifier|const
name|char
modifier|*
name|format
decl_stmt|;
endif|#
directive|endif
name|va_list
name|ap
decl_stmt|;
name|VA_START
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|format
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"genflags: "
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* More 'friendly' abort that prints the line and file.    config.h can #define abort fancy_abort if you like that sort of thing.  */
end_comment

begin_function
name|void
name|fancy_abort
parameter_list|()
block|{
name|fatal
argument_list|(
literal|"Internal gcc abort."
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|rtx
name|desc
decl_stmt|;
name|rtx
name|dummy
decl_stmt|;
name|rtx
modifier|*
name|call_insns
decl_stmt|;
name|rtx
modifier|*
name|normal_insns
decl_stmt|;
name|rtx
modifier|*
name|insn_ptr
decl_stmt|;
name|FILE
modifier|*
name|infile
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|obstack_init
argument_list|(
name|rtl_obstack
argument_list|)
expr_stmt|;
name|obstack_init
argument_list|(
operator|&
name|call_obstack
argument_list|)
expr_stmt|;
name|obstack_init
argument_list|(
operator|&
name|normal_obstack
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|<=
literal|1
condition|)
name|fatal
argument_list|(
literal|"No input file name."
argument_list|)
expr_stmt|;
name|infile
operator|=
name|fopen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|infile
operator|==
literal|0
condition|)
block|{
name|perror
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
name|init_rtl
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"/* Generated automatically by the program `genflags'\n\ from the machine description file `md'.  */\n\n"
argument_list|)
expr_stmt|;
comment|/* Read the machine description.  */
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
name|read_skip_spaces
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
name|ungetc
argument_list|(
name|c
argument_list|,
name|infile
argument_list|)
expr_stmt|;
name|desc
operator|=
name|read_rtx
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_INSN
operator|||
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_EXPAND
condition|)
name|gen_insn
argument_list|(
name|desc
argument_list|)
expr_stmt|;
block|}
comment|/* Print out the prototypes now.  */
name|dummy
operator|=
operator|(
name|rtx
operator|)
literal|0
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|call_obstack
argument_list|,
operator|&
name|dummy
argument_list|,
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|call_insns
operator|=
operator|(
name|rtx
operator|*
operator|)
name|obstack_finish
argument_list|(
operator|&
name|call_obstack
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|normal_obstack
argument_list|,
operator|&
name|dummy
argument_list|,
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|normal_insns
operator|=
operator|(
name|rtx
operator|*
operator|)
name|obstack_finish
argument_list|(
operator|&
name|normal_obstack
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n#ifndef NO_MD_PROTOTYPES\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|insn_ptr
operator|=
name|normal_insns
init|;
operator|*
name|insn_ptr
condition|;
name|insn_ptr
operator|++
control|)
name|gen_proto
argument_list|(
operator|*
name|insn_ptr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n#ifdef MD_CALL_PROTOTYPES\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|insn_ptr
operator|=
name|call_insns
init|;
operator|*
name|insn_ptr
condition|;
name|insn_ptr
operator|++
control|)
name|gen_proto
argument_list|(
operator|*
name|insn_ptr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n#else /* !MD_CALL_PROTOTYPES */\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|insn_ptr
operator|=
name|call_insns
init|;
operator|*
name|insn_ptr
condition|;
name|insn_ptr
operator|++
control|)
name|gen_nonproto
argument_list|(
operator|*
name|insn_ptr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#endif /* !MD_CALL_PROTOTYPES */\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n#else  /* NO_MD_PROTOTYPES */\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|insn_ptr
operator|=
name|normal_insns
init|;
operator|*
name|insn_ptr
condition|;
name|insn_ptr
operator|++
control|)
name|gen_nonproto
argument_list|(
operator|*
name|insn_ptr
argument_list|)
expr_stmt|;
for|for
control|(
name|insn_ptr
operator|=
name|call_insns
init|;
operator|*
name|insn_ptr
condition|;
name|insn_ptr
operator|++
control|)
name|gen_nonproto
argument_list|(
operator|*
name|insn_ptr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#endif  /* NO_MD_PROTOTYPES */\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|ferror
argument_list|(
name|stdout
argument_list|)
operator|!=
literal|0
condition|?
name|FATAL_EXIT_CODE
else|:
name|SUCCESS_EXIT_CODE
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
literal|0
return|;
block|}
end_function

end_unit

