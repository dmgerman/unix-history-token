begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Generate from machine description:    - some flags HAVE_... saying which simple standard instructions are    available for this machine.    Copyright (C) 1987, 1991, 1995, 1998,    1999, 2000 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"hconfig.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"errors.h"
end_include

begin_include
include|#
directive|include
file|"gensupport.h"
end_include

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_comment
comment|/* Obstack to remember insns with.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Max size of names encountered.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_id_len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Max operand encountered in a scan over some insn.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_opno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|max_operand_1
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|num_operands
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_proto
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_macro
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_insn
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Count the number of match_operand's found.  */
end_comment

begin_function
specifier|static
name|void
name|max_operand_1
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|RTX_CODE
name|code
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|MATCH_OPERAND
operator|||
name|code
operator|==
name|MATCH_OPERATOR
operator|||
name|code
operator|==
name|MATCH_PARALLEL
condition|)
name|max_opno
operator|=
name|MAX
argument_list|(
name|max_opno
argument_list|,
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|len
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|||
name|fmt
index|[
name|i
index|]
operator|==
literal|'u'
condition|)
name|max_operand_1
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|max_operand_1
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|num_operands
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|len
init|=
name|XVECLEN
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|max_opno
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|max_operand_1
argument_list|(
name|XVECEXP
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|max_opno
operator|+
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Print out a wrapper macro for a function which corrects the number    of arguments it takes.  Any missing arguments are assumed to be at    the end.  */
end_comment

begin_function
specifier|static
name|void
name|gen_macro
parameter_list|(
name|name
parameter_list|,
name|real
parameter_list|,
name|expect
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|real
decl_stmt|,
name|expect
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|real
operator|>
name|expect
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|real
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* #define GEN_CALL(A, B, C, D) gen_call((A), (B)) */
name|fputs
argument_list|(
literal|"#define GEN_"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|name
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|putchar
argument_list|(
name|TOUPPER
argument_list|(
name|name
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|expect
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%c, "
argument_list|,
name|i
operator|+
literal|'A'
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%c) gen_%s ("
argument_list|,
name|i
operator|+
literal|'A'
argument_list|,
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|real
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"(%c), "
argument_list|,
name|i
operator|+
literal|'A'
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"(%c))\n"
argument_list|,
name|i
operator|+
literal|'A'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print out prototype information for a function.  */
end_comment

begin_function
specifier|static
name|void
name|gen_proto
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|num
init|=
name|num_operands
argument_list|(
name|insn
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|XSTR
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* Many md files don't refer to the last two operands passed to the      call patterns.  This means their generator functions will be two      arguments too short.  Instead of changing every md file to touch      those operands, we wrap the prototypes in macros that take the      correct number of arguments.  */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'c'
operator|||
name|name
index|[
literal|0
index|]
operator|==
literal|'s'
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"call"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"call_pop"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"sibcall"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"sibcall_pop"
argument_list|)
condition|)
name|gen_macro
argument_list|(
name|name
argument_list|,
name|num
argument_list|,
literal|4
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"call_value"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"call_value_pop"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"sibcall_value"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"sibcall_value_pop"
argument_list|)
condition|)
name|gen_macro
argument_list|(
name|name
argument_list|,
name|num
argument_list|,
literal|5
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"extern struct rtx_def *gen_%-*s PARAMS (("
argument_list|,
name|max_id_len
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|num
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"void"
argument_list|)
expr_stmt|;
else|else
block|{
while|while
condition|(
name|num
operator|--
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"struct rtx_def *, "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"struct rtx_def *"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"));\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gen_insn
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|XSTR
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* Don't mention instructions whose names are the null string      or begin with '*'.  They are in the machine description just      to be recognized.  */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|0
operator|||
name|name
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
return|return;
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|max_id_len
condition|)
name|max_id_len
operator|=
name|len
expr_stmt|;
name|printf
argument_list|(
literal|"#define HAVE_%s "
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|XSTR
argument_list|(
name|insn
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"1\n"
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Write the macro definition, putting \'s at the end of each line, 	 if more than one.  */
name|printf
argument_list|(
literal|"("
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|XSTR
argument_list|(
name|insn
argument_list|,
literal|2
argument_list|)
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
name|printf
argument_list|(
literal|" \\\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%c"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
block|}
name|obstack_grow
argument_list|(
operator|&
name|obstack
argument_list|,
operator|&
name|insn
argument_list|,
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|extern
name|int
decl|main
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|rtx
name|desc
decl_stmt|;
name|rtx
name|dummy
decl_stmt|;
name|rtx
modifier|*
name|insns
decl_stmt|;
name|rtx
modifier|*
name|insn_ptr
decl_stmt|;
name|progname
operator|=
literal|"genflags"
expr_stmt|;
name|obstack_init
argument_list|(
operator|&
name|obstack
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|<=
literal|1
condition|)
name|fatal
argument_list|(
literal|"no input file name"
argument_list|)
expr_stmt|;
if|if
condition|(
name|init_md_reader_args
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
operator|!=
name|SUCCESS_EXIT_CODE
condition|)
return|return
operator|(
name|FATAL_EXIT_CODE
operator|)
return|;
name|puts
argument_list|(
literal|"/* Generated automatically by the program `genflags'"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"   from the machine description file `md'.  */\n"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"#ifndef GCC_INSN_FLAGS_H"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"#define GCC_INSN_FLAGS_H\n"
argument_list|)
expr_stmt|;
comment|/* Read the machine description.  */
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|line_no
decl_stmt|,
name|insn_code_number
init|=
literal|0
decl_stmt|;
name|desc
operator|=
name|read_md_rtx
argument_list|(
operator|&
name|line_no
argument_list|,
operator|&
name|insn_code_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_INSN
operator|||
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_EXPAND
condition|)
name|gen_insn
argument_list|(
name|desc
argument_list|)
expr_stmt|;
block|}
comment|/* Print out the prototypes now.  */
name|dummy
operator|=
operator|(
name|rtx
operator|)
literal|0
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|obstack
argument_list|,
operator|&
name|dummy
argument_list|,
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|insns
operator|=
operator|(
name|rtx
operator|*
operator|)
name|obstack_finish
argument_list|(
operator|&
name|obstack
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"struct rtx_def;\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|insn_ptr
operator|=
name|insns
init|;
operator|*
name|insn_ptr
condition|;
name|insn_ptr
operator|++
control|)
name|gen_proto
argument_list|(
operator|*
name|insn_ptr
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"\n#endif /* GCC_INSN_FLAGS_H */"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stdout
argument_list|)
operator|||
name|fflush
argument_list|(
name|stdout
argument_list|)
operator|||
name|fclose
argument_list|(
name|stdout
argument_list|)
condition|)
return|return
name|FATAL_EXIT_CODE
return|;
return|return
name|SUCCESS_EXIT_CODE
return|;
block|}
end_function

begin_comment
comment|/* Define this so we can link with print-rtl.o to get debug_rtx function.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|get_insn_name
parameter_list|(
name|code
parameter_list|)
name|int
name|code
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|NULL
return|;
block|}
end_function

end_unit

