begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Rtl-level induction variable analysis.    Copyright (C) 2004, 2005 Free Software Foundation, Inc.     This file is part of GCC.     GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.     GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.     You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* This is a simple analysis of induction variables of the loop.  The major use    is for determining the number of iterations of a loop for loop unrolling,    doloop optimization and branch prediction.  The iv information is computed    on demand.     Induction variable is analyzed by walking the use-def chains.  When a biv    is found, it is cached in the bivs hash table.  When register is proved    to be a giv, its description is stored to DF_REF_DATA of the def reference.     The analysis works always with one loop -- you must call    iv_analysis_loop_init (loop) for it.  All the other functions then work with    this loop.   When you need to work with another loop, just call    iv_analysis_loop_init for it.  When you no longer need iv analysis, call    iv_analysis_done () to clean up the memory.     The available functions are:      iv_analyze (insn, reg, iv): Stores the description of the induction variable      corresponding to the use of register REG in INSN to IV.  Returns true if      REG is an induction variable in INSN. false otherwise.      If use of REG is not found in INSN, following insns are scanned (so that      we may call this function on insn returned by get_condition).    iv_analyze_result (insn, def, iv):  Stores to IV the description of the iv      corresponding to DEF, which is a register defined in INSN.    iv_analyze_expr (insn, rhs, mode, iv):  Stores to IV the description of iv      corresponding to expression EXPR evaluated at INSN.  All registers used bu      EXPR must also be used in INSN.    iv_current_loop_df (): Returns the dataflow object for the current loop used      by iv analysis.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"cfgloop.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"df.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_comment
comment|/* Possible return values of iv_get_reaching_def.  */
end_comment

begin_enum
enum|enum
name|iv_grd_result
block|{
comment|/* More than one reaching def, or reaching def that does not      dominate the use.  */
name|GRD_INVALID
block|,
comment|/* The use is trivial invariant of the loop, i.e. is not changed      inside the loop.  */
name|GRD_INVARIANT
block|,
comment|/* The use is reached by initial value and a value from the      previous iteration.  */
name|GRD_MAYBE_BIV
block|,
comment|/* The use has single dominating def.  */
name|GRD_SINGLE_DOM
block|}
enum|;
end_enum

begin_comment
comment|/* Information about a biv.  */
end_comment

begin_struct
struct|struct
name|biv_entry
block|{
name|unsigned
name|regno
decl_stmt|;
comment|/* The register of the biv.  */
name|struct
name|rtx_iv
name|iv
decl_stmt|;
comment|/* Value of the biv.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Induction variable stored at the reference.  */
end_comment

begin_define
define|#
directive|define
name|DF_REF_IV
parameter_list|(
name|REF
parameter_list|)
value|((struct rtx_iv *) DF_REF_DATA (REF))
end_define

begin_define
define|#
directive|define
name|DF_REF_IV_SET
parameter_list|(
name|REF
parameter_list|,
name|IV
parameter_list|)
value|DF_REF_DATA (REF) = (IV)
end_define

begin_comment
comment|/* The current loop.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|loop
modifier|*
name|current_loop
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Dataflow information for the current loop.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|df
modifier|*
name|df
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Bivs of the current loop.  */
end_comment

begin_decl_stmt
specifier|static
name|htab_t
name|bivs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return the dataflow object for the current loop.  */
end_comment

begin_function
name|struct
name|df
modifier|*
name|iv_current_loop_df
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|df
return|;
block|}
end_function

begin_function_decl
specifier|static
name|bool
name|iv_analyze_op
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|struct
name|rtx_iv
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Dumps information about IV to FILE.  */
end_comment

begin_function_decl
specifier|extern
name|void
name|dump_iv_info
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|struct
name|rtx_iv
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|dump_iv_info
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|struct
name|rtx_iv
modifier|*
name|iv
parameter_list|)
block|{
if|if
condition|(
operator|!
name|iv
operator|->
name|base
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"not simple"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|iv
operator|->
name|step
operator|==
name|const0_rtx
operator|&&
operator|!
name|iv
operator|->
name|first_special
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"invariant "
argument_list|)
expr_stmt|;
name|print_rtl
argument_list|(
name|file
argument_list|,
name|iv
operator|->
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|iv
operator|->
name|step
operator|!=
name|const0_rtx
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" + "
argument_list|)
expr_stmt|;
name|print_rtl
argument_list|(
name|file
argument_list|,
name|iv
operator|->
name|step
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" * iteration"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" (in %s)"
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|iv
operator|->
name|mode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|iv
operator|->
name|mode
operator|!=
name|iv
operator|->
name|extend_mode
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %s to %s"
argument_list|,
name|rtx_name
index|[
name|iv
operator|->
name|extend
index|]
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|iv
operator|->
name|extend_mode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|iv
operator|->
name|mult
operator|!=
name|const1_rtx
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" * "
argument_list|)
expr_stmt|;
name|print_rtl
argument_list|(
name|file
argument_list|,
name|iv
operator|->
name|mult
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|iv
operator|->
name|delta
operator|!=
name|const0_rtx
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" + "
argument_list|)
expr_stmt|;
name|print_rtl
argument_list|(
name|file
argument_list|,
name|iv
operator|->
name|delta
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|iv
operator|->
name|first_special
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" (first special)"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generates a subreg to get the least significant part of EXPR (in mode    INNER_MODE) to OUTER_MODE.  */
end_comment

begin_function
name|rtx
name|lowpart_subreg
parameter_list|(
name|enum
name|machine_mode
name|outer_mode
parameter_list|,
name|rtx
name|expr
parameter_list|,
name|enum
name|machine_mode
name|inner_mode
parameter_list|)
block|{
return|return
name|simplify_gen_subreg
argument_list|(
name|outer_mode
argument_list|,
name|expr
argument_list|,
name|inner_mode
argument_list|,
name|subreg_lowpart_offset
argument_list|(
name|outer_mode
argument_list|,
name|inner_mode
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Checks whether REG is a well-behaved register.  */
end_comment

begin_function
specifier|static
name|bool
name|simple_reg_p
parameter_list|(
name|rtx
name|reg
parameter_list|)
block|{
name|unsigned
name|r
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
if|if
condition|(
operator|!
name|subreg_lowpart_p
argument_list|(
name|reg
argument_list|)
condition|)
return|return
name|false
return|;
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|reg
argument_list|)
condition|)
return|return
name|false
return|;
name|r
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|HARD_REGISTER_NUM_P
argument_list|(
name|r
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|!=
name|MODE_INT
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Clears the information about ivs stored in df.  */
end_comment

begin_function
specifier|static
name|void
name|clear_iv_info
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|,
name|n_defs
init|=
name|DF_DEFS_SIZE
argument_list|(
name|df
argument_list|)
decl_stmt|;
name|struct
name|rtx_iv
modifier|*
name|iv
decl_stmt|;
name|struct
name|df_ref
modifier|*
name|def
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_defs
condition|;
name|i
operator|++
control|)
block|{
name|def
operator|=
name|DF_DEFS_GET
argument_list|(
name|df
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|iv
operator|=
name|DF_REF_IV
argument_list|(
name|def
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iv
condition|)
continue|continue;
name|free
argument_list|(
name|iv
argument_list|)
expr_stmt|;
name|DF_REF_IV_SET
argument_list|(
name|def
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|htab_empty
argument_list|(
name|bivs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns hash value for biv B.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|biv_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
return|return
operator|(
operator|(
specifier|const
expr|struct
name|biv_entry
operator|*
operator|)
name|b
operator|)
operator|->
name|regno
return|;
block|}
end_function

begin_comment
comment|/* Compares biv B and register R.  */
end_comment

begin_function
specifier|static
name|int
name|biv_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|b
parameter_list|,
specifier|const
name|void
modifier|*
name|r
parameter_list|)
block|{
return|return
operator|(
operator|(
specifier|const
expr|struct
name|biv_entry
operator|*
operator|)
name|b
operator|)
operator|->
name|regno
operator|==
name|REGNO
argument_list|(
operator|(
name|rtx
operator|)
name|r
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Prepare the data for an induction variable analysis of a LOOP.  */
end_comment

begin_function
name|void
name|iv_analysis_loop_init
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|basic_block
modifier|*
name|body
init|=
name|get_loop_body_in_dom_order
argument_list|(
name|loop
argument_list|)
decl_stmt|,
name|bb
decl_stmt|;
name|bitmap
name|blocks
init|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|bool
name|first_time
init|=
operator|(
name|df
operator|==
name|NULL
operator|)
decl_stmt|;
name|current_loop
operator|=
name|loop
expr_stmt|;
comment|/* Clear the information from the analysis of the previous loop.  */
if|if
condition|(
name|first_time
condition|)
block|{
name|df
operator|=
name|df_init
argument_list|(
name|DF_HARD_REGS
operator||
name|DF_EQUIV_NOTES
argument_list|)
expr_stmt|;
name|df_chain_add_problem
argument_list|(
name|df
argument_list|,
name|DF_UD_CHAIN
argument_list|)
expr_stmt|;
name|bivs
operator|=
name|htab_create
argument_list|(
literal|10
argument_list|,
name|biv_hash
argument_list|,
name|biv_eq
argument_list|,
name|free
argument_list|)
expr_stmt|;
block|}
else|else
name|clear_iv_info
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loop
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
block|{
name|bb
operator|=
name|body
index|[
name|i
index|]
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|blocks
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
name|df_set_blocks
argument_list|(
name|df
argument_list|,
name|blocks
argument_list|)
expr_stmt|;
name|df_analyze
argument_list|(
name|df
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|blocks
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|body
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finds the definition of REG that dominates loop latch and stores    it to DEF.  Returns false if there is not a single definition    dominating the latch.  If REG has no definition in loop, DEF    is set to NULL and true is returned.  */
end_comment

begin_function
specifier|static
name|bool
name|latch_dominating_def
parameter_list|(
name|rtx
name|reg
parameter_list|,
name|struct
name|df_ref
modifier|*
modifier|*
name|def
parameter_list|)
block|{
name|struct
name|df_ref
modifier|*
name|single_rd
init|=
name|NULL
decl_stmt|,
modifier|*
name|adef
decl_stmt|;
name|unsigned
name|regno
init|=
name|REGNO
argument_list|(
name|reg
argument_list|)
decl_stmt|;
name|struct
name|df_reg_info
modifier|*
name|reg_info
init|=
name|DF_REG_DEF_GET
argument_list|(
name|df
argument_list|,
name|regno
argument_list|)
decl_stmt|;
name|struct
name|df_rd_bb_info
modifier|*
name|bb_info
init|=
name|DF_RD_BB_INFO
argument_list|(
name|df
argument_list|,
name|current_loop
operator|->
name|latch
argument_list|)
decl_stmt|;
for|for
control|(
name|adef
operator|=
name|reg_info
operator|->
name|reg_chain
init|;
name|adef
condition|;
name|adef
operator|=
name|adef
operator|->
name|next_reg
control|)
block|{
if|if
condition|(
operator|!
name|bitmap_bit_p
argument_list|(
name|bb_info
operator|->
name|out
argument_list|,
name|DF_REF_ID
argument_list|(
name|adef
argument_list|)
argument_list|)
condition|)
continue|continue;
comment|/* More than one reaching definition.  */
if|if
condition|(
name|single_rd
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|just_once_each_iteration_p
argument_list|(
name|current_loop
argument_list|,
name|DF_REF_BB
argument_list|(
name|adef
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
name|single_rd
operator|=
name|adef
expr_stmt|;
block|}
operator|*
name|def
operator|=
name|single_rd
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Gets definition of REG reaching its use in INSN and stores it to DEF.  */
end_comment

begin_function
specifier|static
name|enum
name|iv_grd_result
name|iv_get_reaching_def
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|reg
parameter_list|,
name|struct
name|df_ref
modifier|*
modifier|*
name|def
parameter_list|)
block|{
name|struct
name|df_ref
modifier|*
name|use
decl_stmt|,
modifier|*
name|adef
decl_stmt|;
name|basic_block
name|def_bb
decl_stmt|,
name|use_bb
decl_stmt|;
name|rtx
name|def_insn
decl_stmt|;
name|bool
name|dom_p
decl_stmt|;
operator|*
name|def
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|simple_reg_p
argument_list|(
name|reg
argument_list|)
condition|)
return|return
name|GRD_INVALID
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
condition|)
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|REG_P
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
name|use
operator|=
name|df_find_use
argument_list|(
name|df
argument_list|,
name|insn
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|use
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DF_REF_CHAIN
argument_list|(
name|use
argument_list|)
condition|)
return|return
name|GRD_INVARIANT
return|;
comment|/* More than one reaching def.  */
if|if
condition|(
name|DF_REF_CHAIN
argument_list|(
name|use
argument_list|)
operator|->
name|next
condition|)
return|return
name|GRD_INVALID
return|;
name|adef
operator|=
name|DF_REF_CHAIN
argument_list|(
name|use
argument_list|)
operator|->
name|ref
expr_stmt|;
name|def_insn
operator|=
name|DF_REF_INSN
argument_list|(
name|adef
argument_list|)
expr_stmt|;
name|def_bb
operator|=
name|DF_REF_BB
argument_list|(
name|adef
argument_list|)
expr_stmt|;
name|use_bb
operator|=
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_bb
operator|==
name|def_bb
condition|)
name|dom_p
operator|=
operator|(
name|DF_INSN_LUID
argument_list|(
name|df
argument_list|,
name|def_insn
argument_list|)
operator|<
name|DF_INSN_LUID
argument_list|(
name|df
argument_list|,
name|insn
argument_list|)
operator|)
expr_stmt|;
else|else
name|dom_p
operator|=
name|dominated_by_p
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|use_bb
argument_list|,
name|def_bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|dom_p
condition|)
block|{
operator|*
name|def
operator|=
name|adef
expr_stmt|;
return|return
name|GRD_SINGLE_DOM
return|;
block|}
comment|/* The definition does not dominate the use.  This is still OK if      this may be a use of a biv, i.e. if the def_bb dominates loop      latch.  */
if|if
condition|(
name|just_once_each_iteration_p
argument_list|(
name|current_loop
argument_list|,
name|def_bb
argument_list|)
condition|)
return|return
name|GRD_MAYBE_BIV
return|;
return|return
name|GRD_INVALID
return|;
block|}
end_function

begin_comment
comment|/* Sets IV to invariant CST in MODE.  Always returns true (just for    consistency with other iv manipulation functions that may fail).  */
end_comment

begin_function
specifier|static
name|bool
name|iv_constant
parameter_list|(
name|struct
name|rtx_iv
modifier|*
name|iv
parameter_list|,
name|rtx
name|cst
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|mode
operator|=
name|GET_MODE
argument_list|(
name|cst
argument_list|)
expr_stmt|;
name|iv
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
name|iv
operator|->
name|base
operator|=
name|cst
expr_stmt|;
name|iv
operator|->
name|step
operator|=
name|const0_rtx
expr_stmt|;
name|iv
operator|->
name|first_special
operator|=
name|false
expr_stmt|;
name|iv
operator|->
name|extend
operator|=
name|UNKNOWN
expr_stmt|;
name|iv
operator|->
name|extend_mode
operator|=
name|iv
operator|->
name|mode
expr_stmt|;
name|iv
operator|->
name|delta
operator|=
name|const0_rtx
expr_stmt|;
name|iv
operator|->
name|mult
operator|=
name|const1_rtx
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Evaluates application of subreg to MODE on IV.  */
end_comment

begin_function
specifier|static
name|bool
name|iv_subreg
parameter_list|(
name|struct
name|rtx_iv
modifier|*
name|iv
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
comment|/* If iv is invariant, just calculate the new value.  */
if|if
condition|(
name|iv
operator|->
name|step
operator|==
name|const0_rtx
operator|&&
operator|!
name|iv
operator|->
name|first_special
condition|)
block|{
name|rtx
name|val
init|=
name|get_iv_value
argument_list|(
name|iv
argument_list|,
name|const0_rtx
argument_list|)
decl_stmt|;
name|val
operator|=
name|lowpart_subreg
argument_list|(
name|mode
argument_list|,
name|val
argument_list|,
name|iv
operator|->
name|extend_mode
argument_list|)
expr_stmt|;
name|iv
operator|->
name|base
operator|=
name|val
expr_stmt|;
name|iv
operator|->
name|extend
operator|=
name|UNKNOWN
expr_stmt|;
name|iv
operator|->
name|mode
operator|=
name|iv
operator|->
name|extend_mode
operator|=
name|mode
expr_stmt|;
name|iv
operator|->
name|delta
operator|=
name|const0_rtx
expr_stmt|;
name|iv
operator|->
name|mult
operator|=
name|const1_rtx
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|iv
operator|->
name|extend_mode
operator|==
name|mode
condition|)
return|return
name|true
return|;
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|>
name|GET_MODE_BITSIZE
argument_list|(
name|iv
operator|->
name|mode
argument_list|)
condition|)
return|return
name|false
return|;
name|iv
operator|->
name|extend
operator|=
name|UNKNOWN
expr_stmt|;
name|iv
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
name|iv
operator|->
name|base
operator|=
name|simplify_gen_binary
argument_list|(
name|PLUS
argument_list|,
name|iv
operator|->
name|extend_mode
argument_list|,
name|iv
operator|->
name|delta
argument_list|,
name|simplify_gen_binary
argument_list|(
name|MULT
argument_list|,
name|iv
operator|->
name|extend_mode
argument_list|,
name|iv
operator|->
name|base
argument_list|,
name|iv
operator|->
name|mult
argument_list|)
argument_list|)
expr_stmt|;
name|iv
operator|->
name|step
operator|=
name|simplify_gen_binary
argument_list|(
name|MULT
argument_list|,
name|iv
operator|->
name|extend_mode
argument_list|,
name|iv
operator|->
name|step
argument_list|,
name|iv
operator|->
name|mult
argument_list|)
expr_stmt|;
name|iv
operator|->
name|mult
operator|=
name|const1_rtx
expr_stmt|;
name|iv
operator|->
name|delta
operator|=
name|const0_rtx
expr_stmt|;
name|iv
operator|->
name|first_special
operator|=
name|false
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Evaluates application of EXTEND to MODE on IV.  */
end_comment

begin_function
specifier|static
name|bool
name|iv_extend
parameter_list|(
name|struct
name|rtx_iv
modifier|*
name|iv
parameter_list|,
name|enum
name|rtx_code
name|extend
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
comment|/* If iv is invariant, just calculate the new value.  */
if|if
condition|(
name|iv
operator|->
name|step
operator|==
name|const0_rtx
operator|&&
operator|!
name|iv
operator|->
name|first_special
condition|)
block|{
name|rtx
name|val
init|=
name|get_iv_value
argument_list|(
name|iv
argument_list|,
name|const0_rtx
argument_list|)
decl_stmt|;
name|val
operator|=
name|simplify_gen_unary
argument_list|(
name|extend
argument_list|,
name|mode
argument_list|,
name|val
argument_list|,
name|iv
operator|->
name|extend_mode
argument_list|)
expr_stmt|;
name|iv
operator|->
name|base
operator|=
name|val
expr_stmt|;
name|iv
operator|->
name|extend
operator|=
name|UNKNOWN
expr_stmt|;
name|iv
operator|->
name|mode
operator|=
name|iv
operator|->
name|extend_mode
operator|=
name|mode
expr_stmt|;
name|iv
operator|->
name|delta
operator|=
name|const0_rtx
expr_stmt|;
name|iv
operator|->
name|mult
operator|=
name|const1_rtx
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|mode
operator|!=
name|iv
operator|->
name|extend_mode
condition|)
return|return
name|false
return|;
if|if
condition|(
name|iv
operator|->
name|extend
operator|!=
name|UNKNOWN
operator|&&
name|iv
operator|->
name|extend
operator|!=
name|extend
condition|)
return|return
name|false
return|;
name|iv
operator|->
name|extend
operator|=
name|extend
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Evaluates negation of IV.  */
end_comment

begin_function
specifier|static
name|bool
name|iv_neg
parameter_list|(
name|struct
name|rtx_iv
modifier|*
name|iv
parameter_list|)
block|{
if|if
condition|(
name|iv
operator|->
name|extend
operator|==
name|UNKNOWN
condition|)
block|{
name|iv
operator|->
name|base
operator|=
name|simplify_gen_unary
argument_list|(
name|NEG
argument_list|,
name|iv
operator|->
name|extend_mode
argument_list|,
name|iv
operator|->
name|base
argument_list|,
name|iv
operator|->
name|extend_mode
argument_list|)
expr_stmt|;
name|iv
operator|->
name|step
operator|=
name|simplify_gen_unary
argument_list|(
name|NEG
argument_list|,
name|iv
operator|->
name|extend_mode
argument_list|,
name|iv
operator|->
name|step
argument_list|,
name|iv
operator|->
name|extend_mode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|iv
operator|->
name|delta
operator|=
name|simplify_gen_unary
argument_list|(
name|NEG
argument_list|,
name|iv
operator|->
name|extend_mode
argument_list|,
name|iv
operator|->
name|delta
argument_list|,
name|iv
operator|->
name|extend_mode
argument_list|)
expr_stmt|;
name|iv
operator|->
name|mult
operator|=
name|simplify_gen_unary
argument_list|(
name|NEG
argument_list|,
name|iv
operator|->
name|extend_mode
argument_list|,
name|iv
operator|->
name|mult
argument_list|,
name|iv
operator|->
name|extend_mode
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Evaluates addition or subtraction (according to OP) of IV1 to IV0.  */
end_comment

begin_function
specifier|static
name|bool
name|iv_add
parameter_list|(
name|struct
name|rtx_iv
modifier|*
name|iv0
parameter_list|,
name|struct
name|rtx_iv
modifier|*
name|iv1
parameter_list|,
name|enum
name|rtx_code
name|op
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|arg
decl_stmt|;
comment|/* Extend the constant to extend_mode of the other operand if necessary.  */
if|if
condition|(
name|iv0
operator|->
name|extend
operator|==
name|UNKNOWN
operator|&&
name|iv0
operator|->
name|mode
operator|==
name|iv0
operator|->
name|extend_mode
operator|&&
name|iv0
operator|->
name|step
operator|==
name|const0_rtx
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|iv0
operator|->
name|extend_mode
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|iv1
operator|->
name|extend_mode
argument_list|)
condition|)
block|{
name|iv0
operator|->
name|extend_mode
operator|=
name|iv1
operator|->
name|extend_mode
expr_stmt|;
name|iv0
operator|->
name|base
operator|=
name|simplify_gen_unary
argument_list|(
name|ZERO_EXTEND
argument_list|,
name|iv0
operator|->
name|extend_mode
argument_list|,
name|iv0
operator|->
name|base
argument_list|,
name|iv0
operator|->
name|mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|iv1
operator|->
name|extend
operator|==
name|UNKNOWN
operator|&&
name|iv1
operator|->
name|mode
operator|==
name|iv1
operator|->
name|extend_mode
operator|&&
name|iv1
operator|->
name|step
operator|==
name|const0_rtx
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|iv1
operator|->
name|extend_mode
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|iv0
operator|->
name|extend_mode
argument_list|)
condition|)
block|{
name|iv1
operator|->
name|extend_mode
operator|=
name|iv0
operator|->
name|extend_mode
expr_stmt|;
name|iv1
operator|->
name|base
operator|=
name|simplify_gen_unary
argument_list|(
name|ZERO_EXTEND
argument_list|,
name|iv1
operator|->
name|extend_mode
argument_list|,
name|iv1
operator|->
name|base
argument_list|,
name|iv1
operator|->
name|mode
argument_list|)
expr_stmt|;
block|}
name|mode
operator|=
name|iv0
operator|->
name|extend_mode
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|iv1
operator|->
name|extend_mode
condition|)
return|return
name|false
return|;
if|if
condition|(
name|iv0
operator|->
name|extend
operator|==
name|UNKNOWN
operator|&&
name|iv1
operator|->
name|extend
operator|==
name|UNKNOWN
condition|)
block|{
if|if
condition|(
name|iv0
operator|->
name|mode
operator|!=
name|iv1
operator|->
name|mode
condition|)
return|return
name|false
return|;
name|iv0
operator|->
name|base
operator|=
name|simplify_gen_binary
argument_list|(
name|op
argument_list|,
name|mode
argument_list|,
name|iv0
operator|->
name|base
argument_list|,
name|iv1
operator|->
name|base
argument_list|)
expr_stmt|;
name|iv0
operator|->
name|step
operator|=
name|simplify_gen_binary
argument_list|(
name|op
argument_list|,
name|mode
argument_list|,
name|iv0
operator|->
name|step
argument_list|,
name|iv1
operator|->
name|step
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* Handle addition of constant.  */
if|if
condition|(
name|iv1
operator|->
name|extend
operator|==
name|UNKNOWN
operator|&&
name|iv1
operator|->
name|mode
operator|==
name|mode
operator|&&
name|iv1
operator|->
name|step
operator|==
name|const0_rtx
condition|)
block|{
name|iv0
operator|->
name|delta
operator|=
name|simplify_gen_binary
argument_list|(
name|op
argument_list|,
name|mode
argument_list|,
name|iv0
operator|->
name|delta
argument_list|,
name|iv1
operator|->
name|base
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|iv0
operator|->
name|extend
operator|==
name|UNKNOWN
operator|&&
name|iv0
operator|->
name|mode
operator|==
name|mode
operator|&&
name|iv0
operator|->
name|step
operator|==
name|const0_rtx
condition|)
block|{
name|arg
operator|=
name|iv0
operator|->
name|base
expr_stmt|;
operator|*
name|iv0
operator|=
operator|*
name|iv1
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|MINUS
operator|&&
operator|!
name|iv_neg
argument_list|(
name|iv0
argument_list|)
condition|)
return|return
name|false
return|;
name|iv0
operator|->
name|delta
operator|=
name|simplify_gen_binary
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|iv0
operator|->
name|delta
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Evaluates multiplication of IV by constant CST.  */
end_comment

begin_function
specifier|static
name|bool
name|iv_mult
parameter_list|(
name|struct
name|rtx_iv
modifier|*
name|iv
parameter_list|,
name|rtx
name|mby
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|iv
operator|->
name|extend_mode
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|mby
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|mby
argument_list|)
operator|!=
name|mode
condition|)
return|return
name|false
return|;
if|if
condition|(
name|iv
operator|->
name|extend
operator|==
name|UNKNOWN
condition|)
block|{
name|iv
operator|->
name|base
operator|=
name|simplify_gen_binary
argument_list|(
name|MULT
argument_list|,
name|mode
argument_list|,
name|iv
operator|->
name|base
argument_list|,
name|mby
argument_list|)
expr_stmt|;
name|iv
operator|->
name|step
operator|=
name|simplify_gen_binary
argument_list|(
name|MULT
argument_list|,
name|mode
argument_list|,
name|iv
operator|->
name|step
argument_list|,
name|mby
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|iv
operator|->
name|delta
operator|=
name|simplify_gen_binary
argument_list|(
name|MULT
argument_list|,
name|mode
argument_list|,
name|iv
operator|->
name|delta
argument_list|,
name|mby
argument_list|)
expr_stmt|;
name|iv
operator|->
name|mult
operator|=
name|simplify_gen_binary
argument_list|(
name|MULT
argument_list|,
name|mode
argument_list|,
name|iv
operator|->
name|mult
argument_list|,
name|mby
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Evaluates shift of IV by constant CST.  */
end_comment

begin_function
specifier|static
name|bool
name|iv_shift
parameter_list|(
name|struct
name|rtx_iv
modifier|*
name|iv
parameter_list|,
name|rtx
name|mby
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|iv
operator|->
name|extend_mode
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|mby
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|mby
argument_list|)
operator|!=
name|mode
condition|)
return|return
name|false
return|;
if|if
condition|(
name|iv
operator|->
name|extend
operator|==
name|UNKNOWN
condition|)
block|{
name|iv
operator|->
name|base
operator|=
name|simplify_gen_binary
argument_list|(
name|ASHIFT
argument_list|,
name|mode
argument_list|,
name|iv
operator|->
name|base
argument_list|,
name|mby
argument_list|)
expr_stmt|;
name|iv
operator|->
name|step
operator|=
name|simplify_gen_binary
argument_list|(
name|ASHIFT
argument_list|,
name|mode
argument_list|,
name|iv
operator|->
name|step
argument_list|,
name|mby
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|iv
operator|->
name|delta
operator|=
name|simplify_gen_binary
argument_list|(
name|ASHIFT
argument_list|,
name|mode
argument_list|,
name|iv
operator|->
name|delta
argument_list|,
name|mby
argument_list|)
expr_stmt|;
name|iv
operator|->
name|mult
operator|=
name|simplify_gen_binary
argument_list|(
name|ASHIFT
argument_list|,
name|mode
argument_list|,
name|iv
operator|->
name|mult
argument_list|,
name|mby
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* The recursive part of get_biv_step.  Gets the value of the single value    defined by DEF wrto initial value of REG inside loop, in shape described    at get_biv_step.  */
end_comment

begin_function
specifier|static
name|bool
name|get_biv_step_1
parameter_list|(
name|struct
name|df_ref
modifier|*
name|def
parameter_list|,
name|rtx
name|reg
parameter_list|,
name|rtx
modifier|*
name|inner_step
parameter_list|,
name|enum
name|machine_mode
modifier|*
name|inner_mode
parameter_list|,
name|enum
name|rtx_code
modifier|*
name|extend
parameter_list|,
name|enum
name|machine_mode
name|outer_mode
parameter_list|,
name|rtx
modifier|*
name|outer_step
parameter_list|)
block|{
name|rtx
name|set
decl_stmt|,
name|rhs
decl_stmt|,
name|op0
init|=
name|NULL_RTX
decl_stmt|,
name|op1
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|next
decl_stmt|,
name|nextr
decl_stmt|,
name|tmp
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|rtx
name|insn
init|=
name|DF_REF_INSN
argument_list|(
name|def
argument_list|)
decl_stmt|;
name|struct
name|df_ref
modifier|*
name|next_def
decl_stmt|;
name|enum
name|iv_grd_result
name|res
decl_stmt|;
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set
condition|)
return|return
name|false
return|;
name|rhs
operator|=
name|find_reg_equal_equiv_note
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|rhs
condition|)
name|rhs
operator|=
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|rhs
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|SUBREG
case|:
case|case
name|REG
case|:
name|next
operator|=
name|rhs
expr_stmt|;
break|break;
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
name|op0
operator|=
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|PLUS
operator|&&
name|CONSTANT_P
argument_list|(
name|op0
argument_list|)
condition|)
block|{
name|tmp
operator|=
name|op0
expr_stmt|;
name|op0
operator|=
name|op1
expr_stmt|;
name|op1
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|simple_reg_p
argument_list|(
name|op0
argument_list|)
operator|||
operator|!
name|CONSTANT_P
argument_list|(
name|op1
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|rhs
argument_list|)
operator|!=
name|outer_mode
condition|)
block|{
comment|/* ppc64 uses expressions like  	     (set x:SI (plus:SI (subreg:SI y:DI) 1)).  	     this is equivalent to  	     (set x':DI (plus:DI y:DI 1)) 	     (set x:SI (subreg:SI (x':DI)).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|SUBREG
condition|)
return|return
name|false
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|!=
name|outer_mode
condition|)
return|return
name|false
return|;
block|}
name|next
operator|=
name|op0
expr_stmt|;
break|break;
case|case
name|SIGN_EXTEND
case|:
case|case
name|ZERO_EXTEND
case|:
if|if
condition|(
name|GET_MODE
argument_list|(
name|rhs
argument_list|)
operator|!=
name|outer_mode
condition|)
return|return
name|false
return|;
name|op0
operator|=
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|simple_reg_p
argument_list|(
name|op0
argument_list|)
condition|)
return|return
name|false
return|;
name|next
operator|=
name|op0
expr_stmt|;
break|break;
default|default:
return|return
name|false
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
if|if
condition|(
operator|!
name|subreg_lowpart_p
argument_list|(
name|next
argument_list|)
condition|)
return|return
name|false
return|;
name|nextr
operator|=
name|SUBREG_REG
argument_list|(
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|nextr
argument_list|)
operator|!=
name|outer_mode
condition|)
return|return
name|false
return|;
block|}
else|else
name|nextr
operator|=
name|next
expr_stmt|;
name|res
operator|=
name|iv_get_reaching_def
argument_list|(
name|insn
argument_list|,
name|nextr
argument_list|,
operator|&
name|next_def
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|GRD_INVALID
operator|||
name|res
operator|==
name|GRD_INVARIANT
condition|)
return|return
name|false
return|;
if|if
condition|(
name|res
operator|==
name|GRD_MAYBE_BIV
condition|)
block|{
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|nextr
argument_list|,
name|reg
argument_list|)
condition|)
return|return
name|false
return|;
operator|*
name|inner_step
operator|=
name|const0_rtx
expr_stmt|;
operator|*
name|extend
operator|=
name|UNKNOWN
expr_stmt|;
operator|*
name|inner_mode
operator|=
name|outer_mode
expr_stmt|;
operator|*
name|outer_step
operator|=
name|const0_rtx
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|get_biv_step_1
argument_list|(
name|next_def
argument_list|,
name|reg
argument_list|,
name|inner_step
argument_list|,
name|inner_mode
argument_list|,
name|extend
argument_list|,
name|outer_mode
argument_list|,
name|outer_step
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|enum
name|machine_mode
name|amode
init|=
name|GET_MODE
argument_list|(
name|next
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|amode
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
operator|*
name|inner_mode
argument_list|)
condition|)
return|return
name|false
return|;
operator|*
name|inner_mode
operator|=
name|amode
expr_stmt|;
operator|*
name|inner_step
operator|=
name|simplify_gen_binary
argument_list|(
name|PLUS
argument_list|,
name|outer_mode
argument_list|,
operator|*
name|inner_step
argument_list|,
operator|*
name|outer_step
argument_list|)
expr_stmt|;
operator|*
name|outer_step
operator|=
name|const0_rtx
expr_stmt|;
operator|*
name|extend
operator|=
name|UNKNOWN
expr_stmt|;
block|}
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
case|case
name|SUBREG
case|:
break|break;
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
if|if
condition|(
operator|*
name|inner_mode
operator|==
name|outer_mode
comment|/* See comment in previous switch.  */
operator|||
name|GET_MODE
argument_list|(
name|rhs
argument_list|)
operator|!=
name|outer_mode
condition|)
operator|*
name|inner_step
operator|=
name|simplify_gen_binary
argument_list|(
name|code
argument_list|,
name|outer_mode
argument_list|,
operator|*
name|inner_step
argument_list|,
name|op1
argument_list|)
expr_stmt|;
else|else
operator|*
name|outer_step
operator|=
name|simplify_gen_binary
argument_list|(
name|code
argument_list|,
name|outer_mode
argument_list|,
operator|*
name|outer_step
argument_list|,
name|op1
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIGN_EXTEND
case|:
case|case
name|ZERO_EXTEND
case|:
name|gcc_assert
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
operator|*
name|inner_mode
operator|&&
operator|*
name|extend
operator|==
name|UNKNOWN
operator|&&
operator|*
name|outer_step
operator|==
name|const0_rtx
argument_list|)
expr_stmt|;
operator|*
name|extend
operator|=
name|code
expr_stmt|;
break|break;
default|default:
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Gets the operation on register REG inside loop, in shape     OUTER_STEP + EXTEND_{OUTER_MODE} (SUBREG_{INNER_MODE} (REG + INNER_STEP))     If the operation cannot be described in this shape, return false.    LAST_DEF is the definition of REG that dominates loop latch.  */
end_comment

begin_function
specifier|static
name|bool
name|get_biv_step
parameter_list|(
name|struct
name|df_ref
modifier|*
name|last_def
parameter_list|,
name|rtx
name|reg
parameter_list|,
name|rtx
modifier|*
name|inner_step
parameter_list|,
name|enum
name|machine_mode
modifier|*
name|inner_mode
parameter_list|,
name|enum
name|rtx_code
modifier|*
name|extend
parameter_list|,
name|enum
name|machine_mode
modifier|*
name|outer_mode
parameter_list|,
name|rtx
modifier|*
name|outer_step
parameter_list|)
block|{
operator|*
name|outer_mode
operator|=
name|GET_MODE
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|get_biv_step_1
argument_list|(
name|last_def
argument_list|,
name|reg
argument_list|,
name|inner_step
argument_list|,
name|inner_mode
argument_list|,
name|extend
argument_list|,
operator|*
name|outer_mode
argument_list|,
name|outer_step
argument_list|)
condition|)
return|return
name|false
return|;
name|gcc_assert
argument_list|(
operator|(
operator|*
name|inner_mode
operator|==
operator|*
name|outer_mode
operator|)
operator|!=
operator|(
operator|*
name|extend
operator|!=
name|UNKNOWN
operator|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|*
name|inner_mode
operator|!=
operator|*
name|outer_mode
operator|||
operator|*
name|outer_step
operator|==
name|const0_rtx
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Records information that DEF is induction variable IV.  */
end_comment

begin_function
specifier|static
name|void
name|record_iv
parameter_list|(
name|struct
name|df_ref
modifier|*
name|def
parameter_list|,
name|struct
name|rtx_iv
modifier|*
name|iv
parameter_list|)
block|{
name|struct
name|rtx_iv
modifier|*
name|recorded_iv
init|=
name|XNEW
argument_list|(
expr|struct
name|rtx_iv
argument_list|)
decl_stmt|;
operator|*
name|recorded_iv
operator|=
operator|*
name|iv
expr_stmt|;
name|DF_REF_IV_SET
argument_list|(
name|def
argument_list|,
name|recorded_iv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If DEF was already analyzed for bivness, store the description of the biv to    IV and return true.  Otherwise return false.  */
end_comment

begin_function
specifier|static
name|bool
name|analyzed_for_bivness_p
parameter_list|(
name|rtx
name|def
parameter_list|,
name|struct
name|rtx_iv
modifier|*
name|iv
parameter_list|)
block|{
name|struct
name|biv_entry
modifier|*
name|biv
init|=
name|htab_find_with_hash
argument_list|(
name|bivs
argument_list|,
name|def
argument_list|,
name|REGNO
argument_list|(
name|def
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|biv
condition|)
return|return
name|false
return|;
operator|*
name|iv
operator|=
name|biv
operator|->
name|iv
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|record_biv
parameter_list|(
name|rtx
name|def
parameter_list|,
name|struct
name|rtx_iv
modifier|*
name|iv
parameter_list|)
block|{
name|struct
name|biv_entry
modifier|*
name|biv
init|=
name|XNEW
argument_list|(
expr|struct
name|biv_entry
argument_list|)
decl_stmt|;
name|void
modifier|*
modifier|*
name|slot
init|=
name|htab_find_slot_with_hash
argument_list|(
name|bivs
argument_list|,
name|def
argument_list|,
name|REGNO
argument_list|(
name|def
argument_list|)
argument_list|,
name|INSERT
argument_list|)
decl_stmt|;
name|biv
operator|->
name|regno
operator|=
name|REGNO
argument_list|(
name|def
argument_list|)
expr_stmt|;
name|biv
operator|->
name|iv
operator|=
operator|*
name|iv
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
operator|*
name|slot
argument_list|)
expr_stmt|;
operator|*
name|slot
operator|=
name|biv
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Determines whether DEF is a biv and if so, stores its description    to *IV.  */
end_comment

begin_function
specifier|static
name|bool
name|iv_analyze_biv
parameter_list|(
name|rtx
name|def
parameter_list|,
name|struct
name|rtx_iv
modifier|*
name|iv
parameter_list|)
block|{
name|rtx
name|inner_step
decl_stmt|,
name|outer_step
decl_stmt|;
name|enum
name|machine_mode
name|inner_mode
decl_stmt|,
name|outer_mode
decl_stmt|;
name|enum
name|rtx_code
name|extend
decl_stmt|;
name|struct
name|df_ref
modifier|*
name|last_def
decl_stmt|;
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Analyzing "
argument_list|)
expr_stmt|;
name|print_rtl
argument_list|(
name|dump_file
argument_list|,
name|def
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" for bivness.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|def
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|CONSTANT_P
argument_list|(
name|def
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|iv_constant
argument_list|(
name|iv
argument_list|,
name|def
argument_list|,
name|VOIDmode
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|latch_dominating_def
argument_list|(
name|def
argument_list|,
operator|&
name|last_def
argument_list|)
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  not simple.\n"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|last_def
condition|)
return|return
name|iv_constant
argument_list|(
name|iv
argument_list|,
name|def
argument_list|,
name|VOIDmode
argument_list|)
return|;
if|if
condition|(
name|analyzed_for_bivness_p
argument_list|(
name|def
argument_list|,
name|iv
argument_list|)
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  already analysed.\n"
argument_list|)
expr_stmt|;
return|return
name|iv
operator|->
name|base
operator|!=
name|NULL_RTX
return|;
block|}
if|if
condition|(
operator|!
name|get_biv_step
argument_list|(
name|last_def
argument_list|,
name|def
argument_list|,
operator|&
name|inner_step
argument_list|,
operator|&
name|inner_mode
argument_list|,
operator|&
name|extend
argument_list|,
operator|&
name|outer_mode
argument_list|,
operator|&
name|outer_step
argument_list|)
condition|)
block|{
name|iv
operator|->
name|base
operator|=
name|NULL_RTX
expr_stmt|;
goto|goto
name|end
goto|;
block|}
comment|/* Loop transforms base to es (base + inner_step) + outer_step,      where es means extend of subreg between inner_mode and outer_mode.      The corresponding induction variable is       es ((base - outer_step) + i * (inner_step + outer_step)) + outer_step  */
name|iv
operator|->
name|base
operator|=
name|simplify_gen_binary
argument_list|(
name|MINUS
argument_list|,
name|outer_mode
argument_list|,
name|def
argument_list|,
name|outer_step
argument_list|)
expr_stmt|;
name|iv
operator|->
name|step
operator|=
name|simplify_gen_binary
argument_list|(
name|PLUS
argument_list|,
name|outer_mode
argument_list|,
name|inner_step
argument_list|,
name|outer_step
argument_list|)
expr_stmt|;
name|iv
operator|->
name|mode
operator|=
name|inner_mode
expr_stmt|;
name|iv
operator|->
name|extend_mode
operator|=
name|outer_mode
expr_stmt|;
name|iv
operator|->
name|extend
operator|=
name|extend
expr_stmt|;
name|iv
operator|->
name|mult
operator|=
name|const1_rtx
expr_stmt|;
name|iv
operator|->
name|delta
operator|=
name|outer_step
expr_stmt|;
name|iv
operator|->
name|first_special
operator|=
name|inner_mode
operator|!=
name|outer_mode
expr_stmt|;
name|end
label|:
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  "
argument_list|)
expr_stmt|;
name|dump_iv_info
argument_list|(
name|dump_file
argument_list|,
name|iv
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|record_biv
argument_list|(
name|def
argument_list|,
name|iv
argument_list|)
expr_stmt|;
return|return
name|iv
operator|->
name|base
operator|!=
name|NULL_RTX
return|;
block|}
end_function

begin_comment
comment|/* Analyzes expression RHS used at INSN and stores the result to *IV.     The mode of the induction variable is MODE.  */
end_comment

begin_function
name|bool
name|iv_analyze_expr
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|rhs
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|struct
name|rtx_iv
modifier|*
name|iv
parameter_list|)
block|{
name|rtx
name|mby
init|=
name|NULL_RTX
decl_stmt|,
name|tmp
decl_stmt|;
name|rtx
name|op0
init|=
name|NULL_RTX
decl_stmt|,
name|op1
init|=
name|NULL_RTX
decl_stmt|;
name|struct
name|rtx_iv
name|iv0
decl_stmt|,
name|iv1
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|rhs
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|omode
init|=
name|mode
decl_stmt|;
name|iv
operator|->
name|mode
operator|=
name|VOIDmode
expr_stmt|;
name|iv
operator|->
name|base
operator|=
name|NULL_RTX
expr_stmt|;
name|iv
operator|->
name|step
operator|=
name|NULL_RTX
expr_stmt|;
name|gcc_assert
argument_list|(
name|GET_MODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|mode
operator|||
name|GET_MODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|VOIDmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|rhs
argument_list|)
operator|||
name|REG_P
argument_list|(
name|rhs
argument_list|)
operator|||
name|code
operator|==
name|SUBREG
condition|)
block|{
if|if
condition|(
operator|!
name|iv_analyze_op
argument_list|(
name|insn
argument_list|,
name|rhs
argument_list|,
name|iv
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|iv
operator|->
name|mode
operator|==
name|VOIDmode
condition|)
block|{
name|iv
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
name|iv
operator|->
name|extend_mode
operator|=
name|mode
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
name|op0
operator|=
name|rhs
expr_stmt|;
break|break;
case|case
name|SIGN_EXTEND
case|:
case|case
name|ZERO_EXTEND
case|:
case|case
name|NEG
case|:
name|op0
operator|=
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|omode
operator|=
name|GET_MODE
argument_list|(
name|op0
argument_list|)
expr_stmt|;
break|break;
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
name|op0
operator|=
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|MULT
case|:
name|op0
operator|=
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mby
operator|=
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CONSTANT_P
argument_list|(
name|mby
argument_list|)
condition|)
block|{
name|tmp
operator|=
name|op0
expr_stmt|;
name|op0
operator|=
name|mby
expr_stmt|;
name|mby
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|CONSTANT_P
argument_list|(
name|mby
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
name|ASHIFT
case|:
name|op0
operator|=
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mby
operator|=
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CONSTANT_P
argument_list|(
name|mby
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
default|default:
return|return
name|false
return|;
block|}
if|if
condition|(
name|op0
operator|&&
operator|!
name|iv_analyze_expr
argument_list|(
name|insn
argument_list|,
name|op0
argument_list|,
name|omode
argument_list|,
operator|&
name|iv0
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|op1
operator|&&
operator|!
name|iv_analyze_expr
argument_list|(
name|insn
argument_list|,
name|op1
argument_list|,
name|omode
argument_list|,
operator|&
name|iv1
argument_list|)
condition|)
return|return
name|false
return|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|SIGN_EXTEND
case|:
case|case
name|ZERO_EXTEND
case|:
if|if
condition|(
operator|!
name|iv_extend
argument_list|(
operator|&
name|iv0
argument_list|,
name|code
argument_list|,
name|mode
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
name|NEG
case|:
if|if
condition|(
operator|!
name|iv_neg
argument_list|(
operator|&
name|iv0
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
if|if
condition|(
operator|!
name|iv_add
argument_list|(
operator|&
name|iv0
argument_list|,
operator|&
name|iv1
argument_list|,
name|code
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
name|MULT
case|:
if|if
condition|(
operator|!
name|iv_mult
argument_list|(
operator|&
name|iv0
argument_list|,
name|mby
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
name|ASHIFT
case|:
if|if
condition|(
operator|!
name|iv_shift
argument_list|(
operator|&
name|iv0
argument_list|,
name|mby
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
default|default:
break|break;
block|}
operator|*
name|iv
operator|=
name|iv0
expr_stmt|;
return|return
name|iv
operator|->
name|base
operator|!=
name|NULL_RTX
return|;
block|}
end_function

begin_comment
comment|/* Analyzes iv DEF and stores the result to *IV.  */
end_comment

begin_function
specifier|static
name|bool
name|iv_analyze_def
parameter_list|(
name|struct
name|df_ref
modifier|*
name|def
parameter_list|,
name|struct
name|rtx_iv
modifier|*
name|iv
parameter_list|)
block|{
name|rtx
name|insn
init|=
name|DF_REF_INSN
argument_list|(
name|def
argument_list|)
decl_stmt|;
name|rtx
name|reg
init|=
name|DF_REF_REG
argument_list|(
name|def
argument_list|)
decl_stmt|;
name|rtx
name|set
decl_stmt|,
name|rhs
decl_stmt|;
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Analysing def of "
argument_list|)
expr_stmt|;
name|print_rtl
argument_list|(
name|dump_file
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" in insn "
argument_list|)
expr_stmt|;
name|print_rtl_single
argument_list|(
name|dump_file
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DF_REF_IV
argument_list|(
name|def
argument_list|)
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  already analysed.\n"
argument_list|)
expr_stmt|;
operator|*
name|iv
operator|=
operator|*
name|DF_REF_IV
argument_list|(
name|def
argument_list|)
expr_stmt|;
return|return
name|iv
operator|->
name|base
operator|!=
name|NULL_RTX
return|;
block|}
name|iv
operator|->
name|mode
operator|=
name|VOIDmode
expr_stmt|;
name|iv
operator|->
name|base
operator|=
name|NULL_RTX
expr_stmt|;
name|iv
operator|->
name|step
operator|=
name|NULL_RTX
expr_stmt|;
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set
operator|||
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|!=
name|reg
condition|)
return|return
name|false
return|;
name|rhs
operator|=
name|find_reg_equal_equiv_note
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|rhs
condition|)
name|rhs
operator|=
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|rhs
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|iv_analyze_expr
argument_list|(
name|insn
argument_list|,
name|rhs
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|iv
argument_list|)
expr_stmt|;
name|record_iv
argument_list|(
name|def
argument_list|,
name|iv
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
block|{
name|print_rtl
argument_list|(
name|dump_file
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" in insn "
argument_list|)
expr_stmt|;
name|print_rtl_single
argument_list|(
name|dump_file
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  is "
argument_list|)
expr_stmt|;
name|dump_iv_info
argument_list|(
name|dump_file
argument_list|,
name|iv
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|iv
operator|->
name|base
operator|!=
name|NULL_RTX
return|;
block|}
end_function

begin_comment
comment|/* Analyzes operand OP of INSN and stores the result to *IV.  */
end_comment

begin_function
specifier|static
name|bool
name|iv_analyze_op
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|op
parameter_list|,
name|struct
name|rtx_iv
modifier|*
name|iv
parameter_list|)
block|{
name|struct
name|df_ref
modifier|*
name|def
init|=
name|NULL
decl_stmt|;
name|enum
name|iv_grd_result
name|res
decl_stmt|;
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Analysing operand "
argument_list|)
expr_stmt|;
name|print_rtl
argument_list|(
name|dump_file
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" of insn "
argument_list|)
expr_stmt|;
name|print_rtl_single
argument_list|(
name|dump_file
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
condition|)
name|res
operator|=
name|GRD_INVARIANT
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
if|if
condition|(
operator|!
name|subreg_lowpart_p
argument_list|(
name|op
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|iv_analyze_op
argument_list|(
name|insn
argument_list|,
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|,
name|iv
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|iv_subreg
argument_list|(
name|iv
argument_list|,
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
name|res
operator|=
name|iv_get_reaching_def
argument_list|(
name|insn
argument_list|,
name|op
argument_list|,
operator|&
name|def
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|GRD_INVALID
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  not simple.\n"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
if|if
condition|(
name|res
operator|==
name|GRD_INVARIANT
condition|)
block|{
name|iv_constant
argument_list|(
name|iv
argument_list|,
name|op
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  "
argument_list|)
expr_stmt|;
name|dump_iv_info
argument_list|(
name|dump_file
argument_list|,
name|iv
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
if|if
condition|(
name|res
operator|==
name|GRD_MAYBE_BIV
condition|)
return|return
name|iv_analyze_biv
argument_list|(
name|op
argument_list|,
name|iv
argument_list|)
return|;
return|return
name|iv_analyze_def
argument_list|(
name|def
argument_list|,
name|iv
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Analyzes value VAL at INSN and stores the result to *IV.  */
end_comment

begin_function
name|bool
name|iv_analyze
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|val
parameter_list|,
name|struct
name|rtx_iv
modifier|*
name|iv
parameter_list|)
block|{
name|rtx
name|reg
decl_stmt|;
comment|/* We must find the insn in that val is used, so that we get to UD chains.      Since the function is sometimes called on result of get_condition,      this does not necessarily have to be directly INSN; scan also the      following insns.  */
if|if
condition|(
name|simple_reg_p
argument_list|(
name|val
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|SUBREG
condition|)
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|val
argument_list|)
expr_stmt|;
else|else
name|reg
operator|=
name|val
expr_stmt|;
while|while
condition|(
operator|!
name|df_find_use
argument_list|(
name|df
argument_list|,
name|insn
argument_list|,
name|reg
argument_list|)
condition|)
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
return|return
name|iv_analyze_op
argument_list|(
name|insn
argument_list|,
name|val
argument_list|,
name|iv
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Analyzes definition of DEF in INSN and stores the result to IV.  */
end_comment

begin_function
name|bool
name|iv_analyze_result
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|def
parameter_list|,
name|struct
name|rtx_iv
modifier|*
name|iv
parameter_list|)
block|{
name|struct
name|df_ref
modifier|*
name|adef
decl_stmt|;
name|adef
operator|=
name|df_find_def
argument_list|(
name|df
argument_list|,
name|insn
argument_list|,
name|def
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|adef
condition|)
return|return
name|false
return|;
return|return
name|iv_analyze_def
argument_list|(
name|adef
argument_list|,
name|iv
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Checks whether definition of register REG in INSN is a basic induction    variable.  IV analysis must have been initialized (via a call to    iv_analysis_loop_init) for this function to produce a result.  */
end_comment

begin_function
name|bool
name|biv_p
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|reg
parameter_list|)
block|{
name|struct
name|rtx_iv
name|iv
decl_stmt|;
name|struct
name|df_ref
modifier|*
name|def
decl_stmt|,
modifier|*
name|last_def
decl_stmt|;
if|if
condition|(
operator|!
name|simple_reg_p
argument_list|(
name|reg
argument_list|)
condition|)
return|return
name|false
return|;
name|def
operator|=
name|df_find_def
argument_list|(
name|df
argument_list|,
name|insn
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|def
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|latch_dominating_def
argument_list|(
name|reg
argument_list|,
operator|&
name|last_def
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|last_def
operator|!=
name|def
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|iv_analyze_biv
argument_list|(
name|reg
argument_list|,
operator|&
name|iv
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|iv
operator|.
name|step
operator|!=
name|const0_rtx
return|;
block|}
end_function

begin_comment
comment|/* Calculates value of IV at ITERATION-th iteration.  */
end_comment

begin_function
name|rtx
name|get_iv_value
parameter_list|(
name|struct
name|rtx_iv
modifier|*
name|iv
parameter_list|,
name|rtx
name|iteration
parameter_list|)
block|{
name|rtx
name|val
decl_stmt|;
comment|/* We would need to generate some if_then_else patterns, and so far      it is not needed anywhere.  */
name|gcc_assert
argument_list|(
operator|!
name|iv
operator|->
name|first_special
argument_list|)
expr_stmt|;
if|if
condition|(
name|iv
operator|->
name|step
operator|!=
name|const0_rtx
operator|&&
name|iteration
operator|!=
name|const0_rtx
condition|)
name|val
operator|=
name|simplify_gen_binary
argument_list|(
name|PLUS
argument_list|,
name|iv
operator|->
name|extend_mode
argument_list|,
name|iv
operator|->
name|base
argument_list|,
name|simplify_gen_binary
argument_list|(
name|MULT
argument_list|,
name|iv
operator|->
name|extend_mode
argument_list|,
name|iv
operator|->
name|step
argument_list|,
name|iteration
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|val
operator|=
name|iv
operator|->
name|base
expr_stmt|;
if|if
condition|(
name|iv
operator|->
name|extend_mode
operator|==
name|iv
operator|->
name|mode
condition|)
return|return
name|val
return|;
name|val
operator|=
name|lowpart_subreg
argument_list|(
name|iv
operator|->
name|mode
argument_list|,
name|val
argument_list|,
name|iv
operator|->
name|extend_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|iv
operator|->
name|extend
operator|==
name|UNKNOWN
condition|)
return|return
name|val
return|;
name|val
operator|=
name|simplify_gen_unary
argument_list|(
name|iv
operator|->
name|extend
argument_list|,
name|iv
operator|->
name|extend_mode
argument_list|,
name|val
argument_list|,
name|iv
operator|->
name|mode
argument_list|)
expr_stmt|;
name|val
operator|=
name|simplify_gen_binary
argument_list|(
name|PLUS
argument_list|,
name|iv
operator|->
name|extend_mode
argument_list|,
name|iv
operator|->
name|delta
argument_list|,
name|simplify_gen_binary
argument_list|(
name|MULT
argument_list|,
name|iv
operator|->
name|extend_mode
argument_list|,
name|iv
operator|->
name|mult
argument_list|,
name|val
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Free the data for an induction variable analysis.  */
end_comment

begin_function
name|void
name|iv_analysis_done
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|df
condition|)
block|{
name|clear_iv_info
argument_list|()
expr_stmt|;
name|df_finish
argument_list|(
name|df
argument_list|)
expr_stmt|;
name|df
operator|=
name|NULL
expr_stmt|;
name|htab_delete
argument_list|(
name|bivs
argument_list|)
expr_stmt|;
name|bivs
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Computes inverse to X modulo (1<< MOD).  */
end_comment

begin_function
specifier|static
name|unsigned
name|HOST_WIDEST_INT
name|inverse
parameter_list|(
name|unsigned
name|HOST_WIDEST_INT
name|x
parameter_list|,
name|int
name|mod
parameter_list|)
block|{
name|unsigned
name|HOST_WIDEST_INT
name|mask
init|=
operator|(
operator|(
name|unsigned
name|HOST_WIDEST_INT
operator|)
literal|1
operator|<<
operator|(
name|mod
operator|-
literal|1
operator|)
operator|<<
literal|1
operator|)
operator|-
literal|1
decl_stmt|;
name|unsigned
name|HOST_WIDEST_INT
name|rslt
init|=
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mod
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|rslt
operator|=
operator|(
name|rslt
operator|*
name|x
operator|)
operator|&
name|mask
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|*
name|x
operator|)
operator|&
name|mask
expr_stmt|;
block|}
return|return
name|rslt
return|;
block|}
end_function

begin_comment
comment|/* Tries to estimate the maximum number of iterations.  */
end_comment

begin_function
specifier|static
name|unsigned
name|HOST_WIDEST_INT
name|determine_max_iter
parameter_list|(
name|struct
name|niter_desc
modifier|*
name|desc
parameter_list|)
block|{
name|rtx
name|niter
init|=
name|desc
operator|->
name|niter_expr
decl_stmt|;
name|rtx
name|mmin
decl_stmt|,
name|mmax
decl_stmt|,
name|left
decl_stmt|,
name|right
decl_stmt|;
name|unsigned
name|HOST_WIDEST_INT
name|nmax
decl_stmt|,
name|inc
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|niter
argument_list|)
operator|==
name|AND
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|niter
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|nmax
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|niter
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|nmax
operator|&
operator|(
name|nmax
operator|+
literal|1
operator|)
operator|)
condition|)
block|{
name|desc
operator|->
name|niter_max
operator|=
name|nmax
expr_stmt|;
return|return
name|nmax
return|;
block|}
block|}
name|get_mode_bounds
argument_list|(
name|desc
operator|->
name|mode
argument_list|,
name|desc
operator|->
name|signed_p
argument_list|,
name|desc
operator|->
name|mode
argument_list|,
operator|&
name|mmin
argument_list|,
operator|&
name|mmax
argument_list|)
expr_stmt|;
name|nmax
operator|=
name|INTVAL
argument_list|(
name|mmax
argument_list|)
operator|-
name|INTVAL
argument_list|(
name|mmin
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|niter
argument_list|)
operator|==
name|UDIV
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|niter
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
block|{
name|desc
operator|->
name|niter_max
operator|=
name|nmax
expr_stmt|;
return|return
name|nmax
return|;
block|}
name|inc
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|niter
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|niter
operator|=
name|XEXP
argument_list|(
name|niter
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|inc
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|niter
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|left
operator|=
name|XEXP
argument_list|(
name|niter
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|right
operator|=
name|XEXP
argument_list|(
name|niter
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|right
argument_list|)
operator|==
name|CONST_INT
condition|)
name|right
operator|=
name|GEN_INT
argument_list|(
operator|-
name|INTVAL
argument_list|(
name|right
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|niter
argument_list|)
operator|==
name|MINUS
condition|)
block|{
name|left
operator|=
name|XEXP
argument_list|(
name|niter
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|right
operator|=
name|XEXP
argument_list|(
name|niter
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|left
operator|=
name|niter
expr_stmt|;
name|right
operator|=
name|mmin
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|left
argument_list|)
operator|==
name|CONST_INT
condition|)
name|mmax
operator|=
name|left
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|right
argument_list|)
operator|==
name|CONST_INT
condition|)
name|mmin
operator|=
name|right
expr_stmt|;
name|nmax
operator|=
name|INTVAL
argument_list|(
name|mmax
argument_list|)
operator|-
name|INTVAL
argument_list|(
name|mmin
argument_list|)
expr_stmt|;
name|desc
operator|->
name|niter_max
operator|=
name|nmax
operator|/
name|inc
expr_stmt|;
return|return
name|nmax
operator|/
name|inc
return|;
block|}
end_function

begin_comment
comment|/* Checks whether register *REG is in set ALT.  Callback for for_each_rtx.  */
end_comment

begin_function
specifier|static
name|int
name|altered_reg_used
parameter_list|(
name|rtx
modifier|*
name|reg
parameter_list|,
name|void
modifier|*
name|alt
parameter_list|)
block|{
if|if
condition|(
operator|!
name|REG_P
argument_list|(
operator|*
name|reg
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|REGNO_REG_SET_P
argument_list|(
name|alt
argument_list|,
name|REGNO
argument_list|(
operator|*
name|reg
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Marks registers altered by EXPR in set ALT.  */
end_comment

begin_function
specifier|static
name|void
name|mark_altered
parameter_list|(
name|rtx
name|expr
parameter_list|,
name|rtx
name|by
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|alt
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|SUBREG
condition|)
name|expr
operator|=
name|SUBREG_REG
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|expr
argument_list|)
condition|)
return|return;
name|SET_REGNO_REG_SET
argument_list|(
name|alt
argument_list|,
name|REGNO
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Checks whether RHS is simple enough to process.  */
end_comment

begin_function
specifier|static
name|bool
name|simple_rhs_p
parameter_list|(
name|rtx
name|rhs
parameter_list|)
block|{
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|rhs
argument_list|)
operator|||
name|REG_P
argument_list|(
name|rhs
argument_list|)
condition|)
return|return
name|true
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|rhs
argument_list|)
condition|)
block|{
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
name|op0
operator|=
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Allow reg + const sets only.  */
if|if
condition|(
name|REG_P
argument_list|(
name|op0
argument_list|)
operator|&&
name|CONSTANT_P
argument_list|(
name|op1
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|REG_P
argument_list|(
name|op1
argument_list|)
operator|&&
name|CONSTANT_P
argument_list|(
name|op0
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
end_function

begin_comment
comment|/* Simplifies *EXPR using assignment in INSN.  ALTERED is the set of registers    altered so far.  */
end_comment

begin_function
specifier|static
name|void
name|simplify_using_assignment
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
modifier|*
name|expr
parameter_list|,
name|regset
name|altered
parameter_list|)
block|{
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|lhs
init|=
name|NULL_RTX
decl_stmt|,
name|rhs
decl_stmt|;
name|bool
name|ret
init|=
name|false
decl_stmt|;
if|if
condition|(
name|set
condition|)
block|{
name|lhs
operator|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|lhs
argument_list|)
operator|||
name|altered_reg_used
argument_list|(
operator|&
name|lhs
argument_list|,
name|altered
argument_list|)
condition|)
name|ret
operator|=
name|true
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|true
expr_stmt|;
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|mark_altered
argument_list|,
name|altered
argument_list|)
expr_stmt|;
if|if
condition|(
name|CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Kill all call clobbered registers.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|regs_invalidated_by_call
argument_list|,
name|i
argument_list|)
condition|)
name|SET_REGNO_REG_SET
argument_list|(
name|altered
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
condition|)
return|return;
name|rhs
operator|=
name|find_reg_equal_equiv_note
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|rhs
condition|)
name|rhs
operator|=
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|rhs
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|simple_rhs_p
argument_list|(
name|rhs
argument_list|)
condition|)
return|return;
if|if
condition|(
name|for_each_rtx
argument_list|(
operator|&
name|rhs
argument_list|,
name|altered_reg_used
argument_list|,
name|altered
argument_list|)
condition|)
return|return;
operator|*
name|expr
operator|=
name|simplify_replace_rtx
argument_list|(
operator|*
name|expr
argument_list|,
name|lhs
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Checks whether A implies B.  */
end_comment

begin_function
specifier|static
name|bool
name|implies_p
parameter_list|(
name|rtx
name|a
parameter_list|,
name|rtx
name|b
parameter_list|)
block|{
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|,
name|opb0
decl_stmt|,
name|opb1
decl_stmt|,
name|r
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|a
argument_list|)
operator|==
name|EQ
condition|)
block|{
name|op0
operator|=
name|XEXP
argument_list|(
name|a
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|XEXP
argument_list|(
name|a
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|op0
argument_list|)
condition|)
block|{
name|r
operator|=
name|simplify_replace_rtx
argument_list|(
name|b
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|const_true_rtx
condition|)
return|return
name|true
return|;
block|}
if|if
condition|(
name|REG_P
argument_list|(
name|op1
argument_list|)
condition|)
block|{
name|r
operator|=
name|simplify_replace_rtx
argument_list|(
name|b
argument_list|,
name|op1
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|const_true_rtx
condition|)
return|return
name|true
return|;
block|}
block|}
comment|/* A< B implies A + 1<= B.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|a
argument_list|)
operator|==
name|GT
operator|||
name|GET_CODE
argument_list|(
name|a
argument_list|)
operator|==
name|LT
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|b
argument_list|)
operator|==
name|GE
operator|||
name|GET_CODE
argument_list|(
name|b
argument_list|)
operator|==
name|LE
operator|)
condition|)
block|{
name|op0
operator|=
name|XEXP
argument_list|(
name|a
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|XEXP
argument_list|(
name|a
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|opb0
operator|=
name|XEXP
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|opb1
operator|=
name|XEXP
argument_list|(
name|b
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|a
argument_list|)
operator|==
name|GT
condition|)
block|{
name|r
operator|=
name|op0
expr_stmt|;
name|op0
operator|=
name|op1
expr_stmt|;
name|op1
operator|=
name|r
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|b
argument_list|)
operator|==
name|GE
condition|)
block|{
name|r
operator|=
name|opb0
expr_stmt|;
name|opb0
operator|=
name|opb1
expr_stmt|;
name|opb1
operator|=
name|r
expr_stmt|;
block|}
name|mode
operator|=
name|GET_MODE
argument_list|(
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|opb0
argument_list|)
condition|)
name|mode
operator|=
name|VOIDmode
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
block|{
name|mode
operator|=
name|GET_MODE
argument_list|(
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|opb1
argument_list|)
condition|)
name|mode
operator|=
name|VOIDmode
expr_stmt|;
block|}
if|if
condition|(
name|SCALAR_INT_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|op1
argument_list|,
name|opb1
argument_list|)
operator|&&
name|simplify_gen_binary
argument_list|(
name|MINUS
argument_list|,
name|mode
argument_list|,
name|opb0
argument_list|,
name|op0
argument_list|)
operator|==
name|const1_rtx
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Canonicalizes COND so that     (1) Ensure that operands are ordered according to        swap_commutative_operands_p.    (2) (LE x const) will be replaced with (LT x<const+1>) and similarly        for GE, GEU, and LEU.  */
end_comment

begin_function
name|rtx
name|canon_condition
parameter_list|(
name|rtx
name|cond
parameter_list|)
block|{
name|rtx
name|tem
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|cond
argument_list|)
expr_stmt|;
name|op0
operator|=
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|swap_commutative_operands_p
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
condition|)
block|{
name|code
operator|=
name|swap_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|tem
operator|=
name|op0
expr_stmt|;
name|op0
operator|=
name|op1
expr_stmt|;
name|op1
operator|=
name|tem
expr_stmt|;
block|}
name|mode
operator|=
name|GET_MODE
argument_list|(
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|mode
operator|=
name|GET_MODE
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|mode
operator|!=
name|VOIDmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_CC
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|HOST_WIDE_INT
name|const_val
init|=
name|INTVAL
argument_list|(
name|op1
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|uconst_val
init|=
name|const_val
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|max_val
init|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LE
case|:
if|if
condition|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|const_val
operator|!=
name|max_val
operator|>>
literal|1
condition|)
name|code
operator|=
name|LT
operator|,
name|op1
operator|=
name|gen_int_mode
argument_list|(
name|const_val
operator|+
literal|1
argument_list|,
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|/* When cross-compiling, const_val might be sign-extended from 	   BITS_PER_WORD to HOST_BITS_PER_WIDE_INT */
case|case
name|GE
case|:
if|if
condition|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
name|const_val
operator|&
name|max_val
argument_list|)
operator|!=
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
name|code
operator|=
name|GT
operator|,
name|op1
operator|=
name|gen_int_mode
argument_list|(
name|const_val
operator|-
literal|1
argument_list|,
name|mode
argument_list|)
expr_stmt|;
break|break;
case|case
name|LEU
case|:
if|if
condition|(
name|uconst_val
operator|<
name|max_val
condition|)
name|code
operator|=
name|LTU
operator|,
name|op1
operator|=
name|gen_int_mode
argument_list|(
name|uconst_val
operator|+
literal|1
argument_list|,
name|mode
argument_list|)
expr_stmt|;
break|break;
case|case
name|GEU
case|:
if|if
condition|(
name|uconst_val
operator|!=
literal|0
condition|)
name|code
operator|=
name|GTU
operator|,
name|op1
operator|=
name|gen_int_mode
argument_list|(
name|uconst_val
operator|-
literal|1
argument_list|,
name|mode
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|op0
operator|!=
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
operator|||
name|op1
operator|!=
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
operator|||
name|code
operator|!=
name|GET_CODE
argument_list|(
name|cond
argument_list|)
operator|||
name|GET_MODE
argument_list|(
name|cond
argument_list|)
operator|!=
name|SImode
condition|)
name|cond
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|SImode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
return|return
name|cond
return|;
block|}
end_function

begin_comment
comment|/* Tries to use the fact that COND holds to simplify EXPR.  ALTERED is the    set of altered regs.  */
end_comment

begin_function
name|void
name|simplify_using_condition
parameter_list|(
name|rtx
name|cond
parameter_list|,
name|rtx
modifier|*
name|expr
parameter_list|,
name|regset
name|altered
parameter_list|)
block|{
name|rtx
name|rev
decl_stmt|,
name|reve
decl_stmt|,
name|exp
init|=
operator|*
name|expr
decl_stmt|;
if|if
condition|(
operator|!
name|COMPARISON_P
argument_list|(
name|exp
argument_list|)
condition|)
return|return;
comment|/* If some register gets altered later, we do not really speak about its      value at the time of comparison.  */
if|if
condition|(
name|altered
operator|&&
name|for_each_rtx
argument_list|(
operator|&
name|cond
argument_list|,
name|altered_reg_used
argument_list|,
name|altered
argument_list|)
condition|)
return|return;
name|rev
operator|=
name|reversed_condition
argument_list|(
name|cond
argument_list|)
expr_stmt|;
name|reve
operator|=
name|reversed_condition
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|cond
operator|=
name|canon_condition
argument_list|(
name|cond
argument_list|)
expr_stmt|;
name|exp
operator|=
name|canon_condition
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rev
condition|)
name|rev
operator|=
name|canon_condition
argument_list|(
name|rev
argument_list|)
expr_stmt|;
if|if
condition|(
name|reve
condition|)
name|reve
operator|=
name|canon_condition
argument_list|(
name|reve
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|exp
argument_list|,
name|cond
argument_list|)
condition|)
block|{
operator|*
name|expr
operator|=
name|const_true_rtx
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rev
operator|&&
name|rtx_equal_p
argument_list|(
name|exp
argument_list|,
name|rev
argument_list|)
condition|)
block|{
operator|*
name|expr
operator|=
name|const0_rtx
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|implies_p
argument_list|(
name|cond
argument_list|,
name|exp
argument_list|)
condition|)
block|{
operator|*
name|expr
operator|=
name|const_true_rtx
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|reve
operator|&&
name|implies_p
argument_list|(
name|cond
argument_list|,
name|reve
argument_list|)
condition|)
block|{
operator|*
name|expr
operator|=
name|const0_rtx
expr_stmt|;
return|return;
block|}
comment|/* A proof by contradiction.  If *EXPR implies (not cond), *EXPR must      be false.  */
if|if
condition|(
name|rev
operator|&&
name|implies_p
argument_list|(
name|exp
argument_list|,
name|rev
argument_list|)
condition|)
block|{
operator|*
name|expr
operator|=
name|const0_rtx
expr_stmt|;
return|return;
block|}
comment|/* Similarly, If (not *EXPR) implies (not cond), *EXPR must be true.  */
if|if
condition|(
name|rev
operator|&&
name|reve
operator|&&
name|implies_p
argument_list|(
name|reve
argument_list|,
name|rev
argument_list|)
condition|)
block|{
operator|*
name|expr
operator|=
name|const_true_rtx
expr_stmt|;
return|return;
block|}
comment|/* We would like to have some other tests here.  TODO.  */
return|return;
block|}
end_function

begin_comment
comment|/* Use relationship between A and *B to eventually eliminate *B.    OP is the operation we consider.  */
end_comment

begin_function
specifier|static
name|void
name|eliminate_implied_condition
parameter_list|(
name|enum
name|rtx_code
name|op
parameter_list|,
name|rtx
name|a
parameter_list|,
name|rtx
modifier|*
name|b
parameter_list|)
block|{
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|AND
case|:
comment|/* If A implies *B, we may replace *B by true.  */
if|if
condition|(
name|implies_p
argument_list|(
name|a
argument_list|,
operator|*
name|b
argument_list|)
condition|)
operator|*
name|b
operator|=
name|const_true_rtx
expr_stmt|;
break|break;
case|case
name|IOR
case|:
comment|/* If *B implies A, we may replace *B by false.  */
if|if
condition|(
name|implies_p
argument_list|(
operator|*
name|b
argument_list|,
name|a
argument_list|)
condition|)
operator|*
name|b
operator|=
name|const0_rtx
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Eliminates the conditions in TAIL that are implied by HEAD.  OP is the    operation we consider.  */
end_comment

begin_function
specifier|static
name|void
name|eliminate_implied_conditions
parameter_list|(
name|enum
name|rtx_code
name|op
parameter_list|,
name|rtx
modifier|*
name|head
parameter_list|,
name|rtx
name|tail
parameter_list|)
block|{
name|rtx
name|elt
decl_stmt|;
for|for
control|(
name|elt
operator|=
name|tail
init|;
name|elt
condition|;
name|elt
operator|=
name|XEXP
argument_list|(
name|elt
argument_list|,
literal|1
argument_list|)
control|)
name|eliminate_implied_condition
argument_list|(
name|op
argument_list|,
operator|*
name|head
argument_list|,
operator|&
name|XEXP
argument_list|(
name|elt
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|elt
operator|=
name|tail
init|;
name|elt
condition|;
name|elt
operator|=
name|XEXP
argument_list|(
name|elt
argument_list|,
literal|1
argument_list|)
control|)
name|eliminate_implied_condition
argument_list|(
name|op
argument_list|,
name|XEXP
argument_list|(
name|elt
argument_list|,
literal|0
argument_list|)
argument_list|,
name|head
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Simplifies *EXPR using initial values at the start of the LOOP.  If *EXPR    is a list, its elements are assumed to be combined using OP.  */
end_comment

begin_function
specifier|static
name|void
name|simplify_using_initial_values
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|enum
name|rtx_code
name|op
parameter_list|,
name|rtx
modifier|*
name|expr
parameter_list|)
block|{
name|rtx
name|head
decl_stmt|,
name|tail
decl_stmt|,
name|insn
decl_stmt|;
name|rtx
name|neutral
decl_stmt|,
name|aggr
decl_stmt|;
name|regset
name|altered
decl_stmt|;
name|edge
name|e
decl_stmt|;
if|if
condition|(
operator|!
operator|*
name|expr
condition|)
return|return;
if|if
condition|(
name|CONSTANT_P
argument_list|(
operator|*
name|expr
argument_list|)
condition|)
return|return;
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|expr
argument_list|)
operator|==
name|EXPR_LIST
condition|)
block|{
name|head
operator|=
name|XEXP
argument_list|(
operator|*
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tail
operator|=
name|XEXP
argument_list|(
operator|*
name|expr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|eliminate_implied_conditions
argument_list|(
name|op
argument_list|,
operator|&
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|AND
case|:
name|neutral
operator|=
name|const_true_rtx
expr_stmt|;
name|aggr
operator|=
name|const0_rtx
expr_stmt|;
break|break;
case|case
name|IOR
case|:
name|neutral
operator|=
name|const0_rtx
expr_stmt|;
name|aggr
operator|=
name|const_true_rtx
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|simplify_using_initial_values
argument_list|(
name|loop
argument_list|,
name|UNKNOWN
argument_list|,
operator|&
name|head
argument_list|)
expr_stmt|;
if|if
condition|(
name|head
operator|==
name|aggr
condition|)
block|{
name|XEXP
argument_list|(
operator|*
name|expr
argument_list|,
literal|0
argument_list|)
operator|=
name|aggr
expr_stmt|;
name|XEXP
argument_list|(
operator|*
name|expr
argument_list|,
literal|1
argument_list|)
operator|=
name|NULL_RTX
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|head
operator|==
name|neutral
condition|)
block|{
operator|*
name|expr
operator|=
name|tail
expr_stmt|;
name|simplify_using_initial_values
argument_list|(
name|loop
argument_list|,
name|op
argument_list|,
name|expr
argument_list|)
expr_stmt|;
return|return;
block|}
name|simplify_using_initial_values
argument_list|(
name|loop
argument_list|,
name|op
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|tail
operator|&&
name|XEXP
argument_list|(
name|tail
argument_list|,
literal|0
argument_list|)
operator|==
name|aggr
condition|)
block|{
operator|*
name|expr
operator|=
name|tail
expr_stmt|;
return|return;
block|}
name|XEXP
argument_list|(
operator|*
name|expr
argument_list|,
literal|0
argument_list|)
operator|=
name|head
expr_stmt|;
name|XEXP
argument_list|(
operator|*
name|expr
argument_list|,
literal|1
argument_list|)
operator|=
name|tail
expr_stmt|;
return|return;
block|}
name|gcc_assert
argument_list|(
name|op
operator|==
name|UNKNOWN
argument_list|)
expr_stmt|;
name|e
operator|=
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|src
operator|==
name|ENTRY_BLOCK_PTR
condition|)
return|return;
name|altered
operator|=
name|ALLOC_REG_SET
argument_list|(
operator|&
name|reg_obstack
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|insn
operator|=
name|BB_END
argument_list|(
name|e
operator|->
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|any_condjump_p
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|cond
init|=
name|get_condition
argument_list|(
name|BB_END
argument_list|(
name|e
operator|->
name|src
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|cond
operator|&&
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
operator|)
condition|)
name|cond
operator|=
name|reversed_condition
argument_list|(
name|cond
argument_list|)
expr_stmt|;
if|if
condition|(
name|cond
condition|)
block|{
name|simplify_using_condition
argument_list|(
name|cond
argument_list|,
name|expr
argument_list|,
name|altered
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
operator|*
name|expr
argument_list|)
condition|)
block|{
name|FREE_REG_SET
argument_list|(
name|altered
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
name|FOR_BB_INSNS_REVERSE
argument_list|(
argument|e->src
argument_list|,
argument|insn
argument_list|)
block|{
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
name|simplify_using_assignment
argument_list|(
name|insn
argument_list|,
name|expr
argument_list|,
name|altered
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
operator|*
name|expr
argument_list|)
condition|)
block|{
name|FREE_REG_SET
argument_list|(
name|altered
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
operator|!
name|single_pred_p
argument_list|(
name|e
operator|->
name|src
argument_list|)
operator|||
name|single_pred
argument_list|(
name|e
operator|->
name|src
argument_list|)
operator|==
name|ENTRY_BLOCK_PTR
condition|)
break|break;
name|e
operator|=
name|single_pred_edge
argument_list|(
name|e
operator|->
name|src
argument_list|)
expr_stmt|;
block|}
name|FREE_REG_SET
argument_list|(
name|altered
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Transforms invariant IV into MODE.  Adds assumptions based on the fact    that IV occurs as left operands of comparison COND and its signedness    is SIGNED_P to DESC.  */
end_comment

begin_function
specifier|static
name|void
name|shorten_into_mode
parameter_list|(
name|struct
name|rtx_iv
modifier|*
name|iv
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|enum
name|rtx_code
name|cond
parameter_list|,
name|bool
name|signed_p
parameter_list|,
name|struct
name|niter_desc
modifier|*
name|desc
parameter_list|)
block|{
name|rtx
name|mmin
decl_stmt|,
name|mmax
decl_stmt|,
name|cond_over
decl_stmt|,
name|cond_under
decl_stmt|;
name|get_mode_bounds
argument_list|(
name|mode
argument_list|,
name|signed_p
argument_list|,
name|iv
operator|->
name|extend_mode
argument_list|,
operator|&
name|mmin
argument_list|,
operator|&
name|mmax
argument_list|)
expr_stmt|;
name|cond_under
operator|=
name|simplify_gen_relational
argument_list|(
name|LT
argument_list|,
name|SImode
argument_list|,
name|iv
operator|->
name|extend_mode
argument_list|,
name|iv
operator|->
name|base
argument_list|,
name|mmin
argument_list|)
expr_stmt|;
name|cond_over
operator|=
name|simplify_gen_relational
argument_list|(
name|GT
argument_list|,
name|SImode
argument_list|,
name|iv
operator|->
name|extend_mode
argument_list|,
name|iv
operator|->
name|base
argument_list|,
name|mmax
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cond
condition|)
block|{
case|case
name|LE
case|:
case|case
name|LT
case|:
case|case
name|LEU
case|:
case|case
name|LTU
case|:
if|if
condition|(
name|cond_under
operator|!=
name|const0_rtx
condition|)
name|desc
operator|->
name|infinite
operator|=
name|alloc_EXPR_LIST
argument_list|(
literal|0
argument_list|,
name|cond_under
argument_list|,
name|desc
operator|->
name|infinite
argument_list|)
expr_stmt|;
if|if
condition|(
name|cond_over
operator|!=
name|const0_rtx
condition|)
name|desc
operator|->
name|noloop_assumptions
operator|=
name|alloc_EXPR_LIST
argument_list|(
literal|0
argument_list|,
name|cond_over
argument_list|,
name|desc
operator|->
name|noloop_assumptions
argument_list|)
expr_stmt|;
break|break;
case|case
name|GE
case|:
case|case
name|GT
case|:
case|case
name|GEU
case|:
case|case
name|GTU
case|:
if|if
condition|(
name|cond_over
operator|!=
name|const0_rtx
condition|)
name|desc
operator|->
name|infinite
operator|=
name|alloc_EXPR_LIST
argument_list|(
literal|0
argument_list|,
name|cond_over
argument_list|,
name|desc
operator|->
name|infinite
argument_list|)
expr_stmt|;
if|if
condition|(
name|cond_under
operator|!=
name|const0_rtx
condition|)
name|desc
operator|->
name|noloop_assumptions
operator|=
name|alloc_EXPR_LIST
argument_list|(
literal|0
argument_list|,
name|cond_under
argument_list|,
name|desc
operator|->
name|noloop_assumptions
argument_list|)
expr_stmt|;
break|break;
case|case
name|NE
case|:
if|if
condition|(
name|cond_over
operator|!=
name|const0_rtx
condition|)
name|desc
operator|->
name|infinite
operator|=
name|alloc_EXPR_LIST
argument_list|(
literal|0
argument_list|,
name|cond_over
argument_list|,
name|desc
operator|->
name|infinite
argument_list|)
expr_stmt|;
if|if
condition|(
name|cond_under
operator|!=
name|const0_rtx
condition|)
name|desc
operator|->
name|infinite
operator|=
name|alloc_EXPR_LIST
argument_list|(
literal|0
argument_list|,
name|cond_under
argument_list|,
name|desc
operator|->
name|infinite
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|iv
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
name|iv
operator|->
name|extend
operator|=
name|signed_p
condition|?
name|SIGN_EXTEND
else|:
name|ZERO_EXTEND
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Transforms IV0 and IV1 compared by COND so that they are both compared as    subregs of the same mode if possible (sometimes it is necessary to add    some assumptions to DESC).  */
end_comment

begin_function
specifier|static
name|bool
name|canonicalize_iv_subregs
parameter_list|(
name|struct
name|rtx_iv
modifier|*
name|iv0
parameter_list|,
name|struct
name|rtx_iv
modifier|*
name|iv1
parameter_list|,
name|enum
name|rtx_code
name|cond
parameter_list|,
name|struct
name|niter_desc
modifier|*
name|desc
parameter_list|)
block|{
name|enum
name|machine_mode
name|comp_mode
decl_stmt|;
name|bool
name|signed_p
decl_stmt|;
comment|/* If the ivs behave specially in the first iteration, or are      added/multiplied after extending, we ignore them.  */
if|if
condition|(
name|iv0
operator|->
name|first_special
operator|||
name|iv0
operator|->
name|mult
operator|!=
name|const1_rtx
operator|||
name|iv0
operator|->
name|delta
operator|!=
name|const0_rtx
condition|)
return|return
name|false
return|;
if|if
condition|(
name|iv1
operator|->
name|first_special
operator|||
name|iv1
operator|->
name|mult
operator|!=
name|const1_rtx
operator|||
name|iv1
operator|->
name|delta
operator|!=
name|const0_rtx
condition|)
return|return
name|false
return|;
comment|/* If there is some extend, it must match signedness of the comparison.  */
switch|switch
condition|(
name|cond
condition|)
block|{
case|case
name|LE
case|:
case|case
name|LT
case|:
if|if
condition|(
name|iv0
operator|->
name|extend
operator|==
name|ZERO_EXTEND
operator|||
name|iv1
operator|->
name|extend
operator|==
name|ZERO_EXTEND
condition|)
return|return
name|false
return|;
name|signed_p
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|LEU
case|:
case|case
name|LTU
case|:
if|if
condition|(
name|iv0
operator|->
name|extend
operator|==
name|SIGN_EXTEND
operator|||
name|iv1
operator|->
name|extend
operator|==
name|SIGN_EXTEND
condition|)
return|return
name|false
return|;
name|signed_p
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|NE
case|:
if|if
condition|(
name|iv0
operator|->
name|extend
operator|!=
name|UNKNOWN
operator|&&
name|iv1
operator|->
name|extend
operator|!=
name|UNKNOWN
operator|&&
name|iv0
operator|->
name|extend
operator|!=
name|iv1
operator|->
name|extend
condition|)
return|return
name|false
return|;
name|signed_p
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|iv0
operator|->
name|extend
operator|!=
name|UNKNOWN
condition|)
name|signed_p
operator|=
name|iv0
operator|->
name|extend
operator|==
name|SIGN_EXTEND
expr_stmt|;
if|if
condition|(
name|iv1
operator|->
name|extend
operator|!=
name|UNKNOWN
condition|)
name|signed_p
operator|=
name|iv1
operator|->
name|extend
operator|==
name|SIGN_EXTEND
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
comment|/* Values of both variables should be computed in the same mode.  These      might indeed be different, if we have comparison like       (compare (subreg:SI (iv0)) (subreg:SI (iv1)))       and iv0 and iv1 are both ivs iterating in SI mode, but calculated      in different modes.  This does not seem impossible to handle, but      it hardly ever occurs in practice.            The only exception is the case when one of operands is invariant.      For example pentium 3 generates comparisons like      (lt (subreg:HI (reg:SI)) 100).  Here we assign HImode to 100, but we      definitely do not want this prevent the optimization.  */
name|comp_mode
operator|=
name|iv0
operator|->
name|extend_mode
expr_stmt|;
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|comp_mode
argument_list|)
operator|<
name|GET_MODE_BITSIZE
argument_list|(
name|iv1
operator|->
name|extend_mode
argument_list|)
condition|)
name|comp_mode
operator|=
name|iv1
operator|->
name|extend_mode
expr_stmt|;
if|if
condition|(
name|iv0
operator|->
name|extend_mode
operator|!=
name|comp_mode
condition|)
block|{
if|if
condition|(
name|iv0
operator|->
name|mode
operator|!=
name|iv0
operator|->
name|extend_mode
operator|||
name|iv0
operator|->
name|step
operator|!=
name|const0_rtx
condition|)
return|return
name|false
return|;
name|iv0
operator|->
name|base
operator|=
name|simplify_gen_unary
argument_list|(
name|signed_p
condition|?
name|SIGN_EXTEND
else|:
name|ZERO_EXTEND
argument_list|,
name|comp_mode
argument_list|,
name|iv0
operator|->
name|base
argument_list|,
name|iv0
operator|->
name|mode
argument_list|)
expr_stmt|;
name|iv0
operator|->
name|extend_mode
operator|=
name|comp_mode
expr_stmt|;
block|}
if|if
condition|(
name|iv1
operator|->
name|extend_mode
operator|!=
name|comp_mode
condition|)
block|{
if|if
condition|(
name|iv1
operator|->
name|mode
operator|!=
name|iv1
operator|->
name|extend_mode
operator|||
name|iv1
operator|->
name|step
operator|!=
name|const0_rtx
condition|)
return|return
name|false
return|;
name|iv1
operator|->
name|base
operator|=
name|simplify_gen_unary
argument_list|(
name|signed_p
condition|?
name|SIGN_EXTEND
else|:
name|ZERO_EXTEND
argument_list|,
name|comp_mode
argument_list|,
name|iv1
operator|->
name|base
argument_list|,
name|iv1
operator|->
name|mode
argument_list|)
expr_stmt|;
name|iv1
operator|->
name|extend_mode
operator|=
name|comp_mode
expr_stmt|;
block|}
comment|/* Check that both ivs belong to a range of a single mode.  If one of the      operands is an invariant, we may need to shorten it into the common      mode.  */
if|if
condition|(
name|iv0
operator|->
name|mode
operator|==
name|iv0
operator|->
name|extend_mode
operator|&&
name|iv0
operator|->
name|step
operator|==
name|const0_rtx
operator|&&
name|iv0
operator|->
name|mode
operator|!=
name|iv1
operator|->
name|mode
condition|)
name|shorten_into_mode
argument_list|(
name|iv0
argument_list|,
name|iv1
operator|->
name|mode
argument_list|,
name|cond
argument_list|,
name|signed_p
argument_list|,
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|iv1
operator|->
name|mode
operator|==
name|iv1
operator|->
name|extend_mode
operator|&&
name|iv1
operator|->
name|step
operator|==
name|const0_rtx
operator|&&
name|iv0
operator|->
name|mode
operator|!=
name|iv1
operator|->
name|mode
condition|)
name|shorten_into_mode
argument_list|(
name|iv1
argument_list|,
name|iv0
operator|->
name|mode
argument_list|,
name|swap_condition
argument_list|(
name|cond
argument_list|)
argument_list|,
name|signed_p
argument_list|,
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|iv0
operator|->
name|mode
operator|!=
name|iv1
operator|->
name|mode
condition|)
return|return
name|false
return|;
name|desc
operator|->
name|mode
operator|=
name|iv0
operator|->
name|mode
expr_stmt|;
name|desc
operator|->
name|signed_p
operator|=
name|signed_p
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Computes number of iterations of the CONDITION in INSN in LOOP and stores    the result into DESC.  Very similar to determine_number_of_iterations    (basically its rtl version), complicated by things like subregs.  */
end_comment

begin_function
specifier|static
name|void
name|iv_number_of_iterations
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|rtx
name|insn
parameter_list|,
name|rtx
name|condition
parameter_list|,
name|struct
name|niter_desc
modifier|*
name|desc
parameter_list|)
block|{
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|,
name|delta
decl_stmt|,
name|step
decl_stmt|,
name|bound
decl_stmt|,
name|may_xform
decl_stmt|,
name|tmp
decl_stmt|,
name|tmp0
decl_stmt|,
name|tmp1
decl_stmt|;
name|struct
name|rtx_iv
name|iv0
decl_stmt|,
name|iv1
decl_stmt|,
name|tmp_iv
decl_stmt|;
name|rtx
name|assumption
decl_stmt|,
name|may_not_xform
decl_stmt|;
name|enum
name|rtx_code
name|cond
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|,
name|comp_mode
decl_stmt|;
name|rtx
name|mmin
decl_stmt|,
name|mmax
decl_stmt|,
name|mode_mmin
decl_stmt|,
name|mode_mmax
decl_stmt|;
name|unsigned
name|HOST_WIDEST_INT
name|s
decl_stmt|,
name|size
decl_stmt|,
name|d
decl_stmt|,
name|inv
decl_stmt|;
name|HOST_WIDEST_INT
name|up
decl_stmt|,
name|down
decl_stmt|,
name|inc
decl_stmt|,
name|step_val
decl_stmt|;
name|int
name|was_sharp
init|=
name|false
decl_stmt|;
name|rtx
name|old_niter
decl_stmt|;
name|bool
name|step_is_pow2
decl_stmt|;
comment|/* The meaning of these assumptions is this:      if !assumptions        then the rest of information does not have to be valid      if noloop_assumptions then the loop does not roll      if infinite then this exit is never used */
name|desc
operator|->
name|assumptions
operator|=
name|NULL_RTX
expr_stmt|;
name|desc
operator|->
name|noloop_assumptions
operator|=
name|NULL_RTX
expr_stmt|;
name|desc
operator|->
name|infinite
operator|=
name|NULL_RTX
expr_stmt|;
name|desc
operator|->
name|simple_p
operator|=
name|true
expr_stmt|;
name|desc
operator|->
name|const_iter
operator|=
name|false
expr_stmt|;
name|desc
operator|->
name|niter_expr
operator|=
name|NULL_RTX
expr_stmt|;
name|desc
operator|->
name|niter_max
operator|=
literal|0
expr_stmt|;
name|cond
operator|=
name|GET_CODE
argument_list|(
name|condition
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|COMPARISON_P
argument_list|(
name|condition
argument_list|)
argument_list|)
expr_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|condition
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|mode
operator|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|condition
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The constant comparisons should be folded.  */
name|gcc_assert
argument_list|(
name|mode
operator|!=
name|VOIDmode
argument_list|)
expr_stmt|;
comment|/* We only handle integers or pointers.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_INT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_PARTIAL_INT
condition|)
goto|goto
name|fail
goto|;
name|op0
operator|=
name|XEXP
argument_list|(
name|condition
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iv_analyze
argument_list|(
name|insn
argument_list|,
name|op0
argument_list|,
operator|&
name|iv0
argument_list|)
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|iv0
operator|.
name|extend_mode
operator|==
name|VOIDmode
condition|)
name|iv0
operator|.
name|mode
operator|=
name|iv0
operator|.
name|extend_mode
operator|=
name|mode
expr_stmt|;
name|op1
operator|=
name|XEXP
argument_list|(
name|condition
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iv_analyze
argument_list|(
name|insn
argument_list|,
name|op1
argument_list|,
operator|&
name|iv1
argument_list|)
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|iv1
operator|.
name|extend_mode
operator|==
name|VOIDmode
condition|)
name|iv1
operator|.
name|mode
operator|=
name|iv1
operator|.
name|extend_mode
operator|=
name|mode
expr_stmt|;
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|iv0
operator|.
name|extend_mode
argument_list|)
operator|>
name|HOST_BITS_PER_WIDE_INT
operator|||
name|GET_MODE_BITSIZE
argument_list|(
name|iv1
operator|.
name|extend_mode
argument_list|)
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
goto|goto
name|fail
goto|;
comment|/* Check condition and normalize it.  */
switch|switch
condition|(
name|cond
condition|)
block|{
case|case
name|GE
case|:
case|case
name|GT
case|:
case|case
name|GEU
case|:
case|case
name|GTU
case|:
name|tmp_iv
operator|=
name|iv0
expr_stmt|;
name|iv0
operator|=
name|iv1
expr_stmt|;
name|iv1
operator|=
name|tmp_iv
expr_stmt|;
name|cond
operator|=
name|swap_condition
argument_list|(
name|cond
argument_list|)
expr_stmt|;
break|break;
case|case
name|NE
case|:
case|case
name|LE
case|:
case|case
name|LEU
case|:
case|case
name|LT
case|:
case|case
name|LTU
case|:
break|break;
default|default:
goto|goto
name|fail
goto|;
block|}
comment|/* Handle extends.  This is relatively nontrivial, so we only try in some      easy cases, when we can canonicalize the ivs (possibly by adding some      assumptions) to shape subreg (base + i * step).  This function also fills      in desc->mode and desc->signed_p.  */
if|if
condition|(
operator|!
name|canonicalize_iv_subregs
argument_list|(
operator|&
name|iv0
argument_list|,
operator|&
name|iv1
argument_list|,
name|cond
argument_list|,
name|desc
argument_list|)
condition|)
goto|goto
name|fail
goto|;
name|comp_mode
operator|=
name|iv0
operator|.
name|extend_mode
expr_stmt|;
name|mode
operator|=
name|iv0
operator|.
name|mode
expr_stmt|;
name|size
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|get_mode_bounds
argument_list|(
name|mode
argument_list|,
operator|(
name|cond
operator|==
name|LE
operator|||
name|cond
operator|==
name|LT
operator|)
argument_list|,
name|comp_mode
argument_list|,
operator|&
name|mmin
argument_list|,
operator|&
name|mmax
argument_list|)
expr_stmt|;
name|mode_mmin
operator|=
name|lowpart_subreg
argument_list|(
name|mode
argument_list|,
name|mmin
argument_list|,
name|comp_mode
argument_list|)
expr_stmt|;
name|mode_mmax
operator|=
name|lowpart_subreg
argument_list|(
name|mode
argument_list|,
name|mmax
argument_list|,
name|comp_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|iv0
operator|.
name|step
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|iv1
operator|.
name|step
argument_list|)
operator|!=
name|CONST_INT
condition|)
goto|goto
name|fail
goto|;
comment|/* We can take care of the case of two induction variables chasing each other      if the test is NE. I have never seen a loop using it, but still it is      cool.  */
if|if
condition|(
name|iv0
operator|.
name|step
operator|!=
name|const0_rtx
operator|&&
name|iv1
operator|.
name|step
operator|!=
name|const0_rtx
condition|)
block|{
if|if
condition|(
name|cond
operator|!=
name|NE
condition|)
goto|goto
name|fail
goto|;
name|iv0
operator|.
name|step
operator|=
name|simplify_gen_binary
argument_list|(
name|MINUS
argument_list|,
name|comp_mode
argument_list|,
name|iv0
operator|.
name|step
argument_list|,
name|iv1
operator|.
name|step
argument_list|)
expr_stmt|;
name|iv1
operator|.
name|step
operator|=
name|const0_rtx
expr_stmt|;
block|}
comment|/* This is either infinite loop or the one that ends immediately, depending      on initial values.  Unswitching should remove this kind of conditions.  */
if|if
condition|(
name|iv0
operator|.
name|step
operator|==
name|const0_rtx
operator|&&
name|iv1
operator|.
name|step
operator|==
name|const0_rtx
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|cond
operator|!=
name|NE
condition|)
block|{
if|if
condition|(
name|iv0
operator|.
name|step
operator|==
name|const0_rtx
condition|)
name|step_val
operator|=
operator|-
name|INTVAL
argument_list|(
name|iv1
operator|.
name|step
argument_list|)
expr_stmt|;
else|else
name|step_val
operator|=
name|INTVAL
argument_list|(
name|iv0
operator|.
name|step
argument_list|)
expr_stmt|;
comment|/* Ignore loops of while (i--< 10) type.  */
if|if
condition|(
name|step_val
operator|<
literal|0
condition|)
goto|goto
name|fail
goto|;
name|step_is_pow2
operator|=
operator|!
operator|(
name|step_val
operator|&
operator|(
name|step_val
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We do not care about whether the step is power of two in this 	 case.  */
name|step_is_pow2
operator|=
name|false
expr_stmt|;
name|step_val
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Some more condition normalization.  We must record some assumptions      due to overflows.  */
switch|switch
condition|(
name|cond
condition|)
block|{
case|case
name|LT
case|:
case|case
name|LTU
case|:
comment|/* We want to take care only of non-sharp relationals; this is easy, 	   as in cases the overflow would make the transformation unsafe 	   the loop does not roll.  Seemingly it would make more sense to want 	   to take care of sharp relationals instead, as NE is more similar to 	   them, but the problem is that here the transformation would be more 	   difficult due to possibly infinite loops.  */
if|if
condition|(
name|iv0
operator|.
name|step
operator|==
name|const0_rtx
condition|)
block|{
name|tmp
operator|=
name|lowpart_subreg
argument_list|(
name|mode
argument_list|,
name|iv0
operator|.
name|base
argument_list|,
name|comp_mode
argument_list|)
expr_stmt|;
name|assumption
operator|=
name|simplify_gen_relational
argument_list|(
name|EQ
argument_list|,
name|SImode
argument_list|,
name|mode
argument_list|,
name|tmp
argument_list|,
name|mode_mmax
argument_list|)
expr_stmt|;
if|if
condition|(
name|assumption
operator|==
name|const_true_rtx
condition|)
goto|goto
name|zero_iter_simplify
goto|;
name|iv0
operator|.
name|base
operator|=
name|simplify_gen_binary
argument_list|(
name|PLUS
argument_list|,
name|comp_mode
argument_list|,
name|iv0
operator|.
name|base
argument_list|,
name|const1_rtx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|=
name|lowpart_subreg
argument_list|(
name|mode
argument_list|,
name|iv1
operator|.
name|base
argument_list|,
name|comp_mode
argument_list|)
expr_stmt|;
name|assumption
operator|=
name|simplify_gen_relational
argument_list|(
name|EQ
argument_list|,
name|SImode
argument_list|,
name|mode
argument_list|,
name|tmp
argument_list|,
name|mode_mmin
argument_list|)
expr_stmt|;
if|if
condition|(
name|assumption
operator|==
name|const_true_rtx
condition|)
goto|goto
name|zero_iter_simplify
goto|;
name|iv1
operator|.
name|base
operator|=
name|simplify_gen_binary
argument_list|(
name|PLUS
argument_list|,
name|comp_mode
argument_list|,
name|iv1
operator|.
name|base
argument_list|,
name|constm1_rtx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|assumption
operator|!=
name|const0_rtx
condition|)
name|desc
operator|->
name|noloop_assumptions
operator|=
name|alloc_EXPR_LIST
argument_list|(
literal|0
argument_list|,
name|assumption
argument_list|,
name|desc
operator|->
name|noloop_assumptions
argument_list|)
expr_stmt|;
name|cond
operator|=
operator|(
name|cond
operator|==
name|LT
operator|)
condition|?
name|LE
else|:
name|LEU
expr_stmt|;
comment|/* It will be useful to be able to tell the difference once more in 	   LE -> NE reduction.  */
name|was_sharp
operator|=
name|true
expr_stmt|;
break|break;
default|default:
empty_stmt|;
block|}
comment|/* Take care of trivially infinite loops.  */
if|if
condition|(
name|cond
operator|!=
name|NE
condition|)
block|{
if|if
condition|(
name|iv0
operator|.
name|step
operator|==
name|const0_rtx
condition|)
block|{
name|tmp
operator|=
name|lowpart_subreg
argument_list|(
name|mode
argument_list|,
name|iv0
operator|.
name|base
argument_list|,
name|comp_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|tmp
argument_list|,
name|mode_mmin
argument_list|)
condition|)
block|{
name|desc
operator|->
name|infinite
operator|=
name|alloc_EXPR_LIST
argument_list|(
literal|0
argument_list|,
name|const_true_rtx
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
comment|/* Fill in the remaining fields somehow.  */
goto|goto
name|zero_iter_simplify
goto|;
block|}
block|}
else|else
block|{
name|tmp
operator|=
name|lowpart_subreg
argument_list|(
name|mode
argument_list|,
name|iv1
operator|.
name|base
argument_list|,
name|comp_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|tmp
argument_list|,
name|mode_mmax
argument_list|)
condition|)
block|{
name|desc
operator|->
name|infinite
operator|=
name|alloc_EXPR_LIST
argument_list|(
literal|0
argument_list|,
name|const_true_rtx
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
comment|/* Fill in the remaining fields somehow.  */
goto|goto
name|zero_iter_simplify
goto|;
block|}
block|}
block|}
comment|/* If we can we want to take care of NE conditions instead of size      comparisons, as they are much more friendly (most importantly      this takes care of special handling of loops with step 1).  We can      do it if we first check that upper bound is greater or equal to      lower bound, their difference is constant c modulo step and that      there is not an overflow.  */
if|if
condition|(
name|cond
operator|!=
name|NE
condition|)
block|{
if|if
condition|(
name|iv0
operator|.
name|step
operator|==
name|const0_rtx
condition|)
name|step
operator|=
name|simplify_gen_unary
argument_list|(
name|NEG
argument_list|,
name|comp_mode
argument_list|,
name|iv1
operator|.
name|step
argument_list|,
name|comp_mode
argument_list|)
expr_stmt|;
else|else
name|step
operator|=
name|iv0
operator|.
name|step
expr_stmt|;
name|delta
operator|=
name|simplify_gen_binary
argument_list|(
name|MINUS
argument_list|,
name|comp_mode
argument_list|,
name|iv1
operator|.
name|base
argument_list|,
name|iv0
operator|.
name|base
argument_list|)
expr_stmt|;
name|delta
operator|=
name|lowpart_subreg
argument_list|(
name|mode
argument_list|,
name|delta
argument_list|,
name|comp_mode
argument_list|)
expr_stmt|;
name|delta
operator|=
name|simplify_gen_binary
argument_list|(
name|UMOD
argument_list|,
name|mode
argument_list|,
name|delta
argument_list|,
name|step
argument_list|)
expr_stmt|;
name|may_xform
operator|=
name|const0_rtx
expr_stmt|;
name|may_not_xform
operator|=
name|const_true_rtx
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|delta
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|was_sharp
operator|&&
name|INTVAL
argument_list|(
name|delta
argument_list|)
operator|==
name|INTVAL
argument_list|(
name|step
argument_list|)
operator|-
literal|1
condition|)
block|{
comment|/* A special case.  We have transformed condition of type 		 for (i = 0; i< 4; i += 4) 		 into 		 for (i = 0; i<= 3; i += 4) 		 obviously if the test for overflow during that transformation 		 passed, we cannot overflow here.  Most importantly any 		 loop with sharp end condition and step 1 falls into this 		 category, so handling this case specially is definitely 		 worth the troubles.  */
name|may_xform
operator|=
name|const_true_rtx
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|iv0
operator|.
name|step
operator|==
name|const0_rtx
condition|)
block|{
name|bound
operator|=
name|simplify_gen_binary
argument_list|(
name|PLUS
argument_list|,
name|comp_mode
argument_list|,
name|mmin
argument_list|,
name|step
argument_list|)
expr_stmt|;
name|bound
operator|=
name|simplify_gen_binary
argument_list|(
name|MINUS
argument_list|,
name|comp_mode
argument_list|,
name|bound
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|bound
operator|=
name|lowpart_subreg
argument_list|(
name|mode
argument_list|,
name|bound
argument_list|,
name|comp_mode
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|lowpart_subreg
argument_list|(
name|mode
argument_list|,
name|iv0
operator|.
name|base
argument_list|,
name|comp_mode
argument_list|)
expr_stmt|;
name|may_xform
operator|=
name|simplify_gen_relational
argument_list|(
name|cond
argument_list|,
name|SImode
argument_list|,
name|mode
argument_list|,
name|bound
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|may_not_xform
operator|=
name|simplify_gen_relational
argument_list|(
name|reverse_condition
argument_list|(
name|cond
argument_list|)
argument_list|,
name|SImode
argument_list|,
name|mode
argument_list|,
name|bound
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bound
operator|=
name|simplify_gen_binary
argument_list|(
name|MINUS
argument_list|,
name|comp_mode
argument_list|,
name|mmax
argument_list|,
name|step
argument_list|)
expr_stmt|;
name|bound
operator|=
name|simplify_gen_binary
argument_list|(
name|PLUS
argument_list|,
name|comp_mode
argument_list|,
name|bound
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|bound
operator|=
name|lowpart_subreg
argument_list|(
name|mode
argument_list|,
name|bound
argument_list|,
name|comp_mode
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|lowpart_subreg
argument_list|(
name|mode
argument_list|,
name|iv1
operator|.
name|base
argument_list|,
name|comp_mode
argument_list|)
expr_stmt|;
name|may_xform
operator|=
name|simplify_gen_relational
argument_list|(
name|cond
argument_list|,
name|SImode
argument_list|,
name|mode
argument_list|,
name|tmp
argument_list|,
name|bound
argument_list|)
expr_stmt|;
name|may_not_xform
operator|=
name|simplify_gen_relational
argument_list|(
name|reverse_condition
argument_list|(
name|cond
argument_list|)
argument_list|,
name|SImode
argument_list|,
name|mode
argument_list|,
name|tmp
argument_list|,
name|bound
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|may_xform
operator|!=
name|const0_rtx
condition|)
block|{
comment|/* We perform the transformation always provided that it is not 	     completely senseless.  This is OK, as we would need this assumption 	     to determine the number of iterations anyway.  */
if|if
condition|(
name|may_xform
operator|!=
name|const_true_rtx
condition|)
block|{
comment|/* If the step is a power of two and the final value we have 		 computed overflows, the cycle is infinite.  Otherwise it 		 is nontrivial to compute the number of iterations.  */
if|if
condition|(
name|step_is_pow2
condition|)
name|desc
operator|->
name|infinite
operator|=
name|alloc_EXPR_LIST
argument_list|(
literal|0
argument_list|,
name|may_not_xform
argument_list|,
name|desc
operator|->
name|infinite
argument_list|)
expr_stmt|;
else|else
name|desc
operator|->
name|assumptions
operator|=
name|alloc_EXPR_LIST
argument_list|(
literal|0
argument_list|,
name|may_xform
argument_list|,
name|desc
operator|->
name|assumptions
argument_list|)
expr_stmt|;
block|}
comment|/* We are going to lose some information about upper bound on 	     number of iterations in this step, so record the information 	     here.  */
name|inc
operator|=
name|INTVAL
argument_list|(
name|iv0
operator|.
name|step
argument_list|)
operator|-
name|INTVAL
argument_list|(
name|iv1
operator|.
name|step
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|iv1
operator|.
name|base
argument_list|)
operator|==
name|CONST_INT
condition|)
name|up
operator|=
name|INTVAL
argument_list|(
name|iv1
operator|.
name|base
argument_list|)
expr_stmt|;
else|else
name|up
operator|=
name|INTVAL
argument_list|(
name|mode_mmax
argument_list|)
operator|-
name|inc
expr_stmt|;
name|down
operator|=
name|INTVAL
argument_list|(
name|GET_CODE
argument_list|(
name|iv0
operator|.
name|base
argument_list|)
operator|==
name|CONST_INT
condition|?
name|iv0
operator|.
name|base
else|:
name|mode_mmin
argument_list|)
expr_stmt|;
name|desc
operator|->
name|niter_max
operator|=
operator|(
name|up
operator|-
name|down
operator|)
operator|/
name|inc
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|iv0
operator|.
name|step
operator|==
name|const0_rtx
condition|)
block|{
name|iv0
operator|.
name|base
operator|=
name|simplify_gen_binary
argument_list|(
name|PLUS
argument_list|,
name|comp_mode
argument_list|,
name|iv0
operator|.
name|base
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|iv0
operator|.
name|base
operator|=
name|simplify_gen_binary
argument_list|(
name|MINUS
argument_list|,
name|comp_mode
argument_list|,
name|iv0
operator|.
name|base
argument_list|,
name|step
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|iv1
operator|.
name|base
operator|=
name|simplify_gen_binary
argument_list|(
name|MINUS
argument_list|,
name|comp_mode
argument_list|,
name|iv1
operator|.
name|base
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|iv1
operator|.
name|base
operator|=
name|simplify_gen_binary
argument_list|(
name|PLUS
argument_list|,
name|comp_mode
argument_list|,
name|iv1
operator|.
name|base
argument_list|,
name|step
argument_list|)
expr_stmt|;
block|}
name|tmp0
operator|=
name|lowpart_subreg
argument_list|(
name|mode
argument_list|,
name|iv0
operator|.
name|base
argument_list|,
name|comp_mode
argument_list|)
expr_stmt|;
name|tmp1
operator|=
name|lowpart_subreg
argument_list|(
name|mode
argument_list|,
name|iv1
operator|.
name|base
argument_list|,
name|comp_mode
argument_list|)
expr_stmt|;
name|assumption
operator|=
name|simplify_gen_relational
argument_list|(
name|reverse_condition
argument_list|(
name|cond
argument_list|)
argument_list|,
name|SImode
argument_list|,
name|mode
argument_list|,
name|tmp0
argument_list|,
name|tmp1
argument_list|)
expr_stmt|;
if|if
condition|(
name|assumption
operator|==
name|const_true_rtx
condition|)
goto|goto
name|zero_iter_simplify
goto|;
elseif|else
if|if
condition|(
name|assumption
operator|!=
name|const0_rtx
condition|)
name|desc
operator|->
name|noloop_assumptions
operator|=
name|alloc_EXPR_LIST
argument_list|(
literal|0
argument_list|,
name|assumption
argument_list|,
name|desc
operator|->
name|noloop_assumptions
argument_list|)
expr_stmt|;
name|cond
operator|=
name|NE
expr_stmt|;
block|}
block|}
comment|/* Count the number of iterations.  */
if|if
condition|(
name|cond
operator|==
name|NE
condition|)
block|{
comment|/* Everything we do here is just arithmetics modulo size of mode.  This 	 makes us able to do more involved computations of number of iterations 	 than in other cases.  First transform the condition into shape 	 s * i<> c, with s positive.  */
name|iv1
operator|.
name|base
operator|=
name|simplify_gen_binary
argument_list|(
name|MINUS
argument_list|,
name|comp_mode
argument_list|,
name|iv1
operator|.
name|base
argument_list|,
name|iv0
operator|.
name|base
argument_list|)
expr_stmt|;
name|iv0
operator|.
name|base
operator|=
name|const0_rtx
expr_stmt|;
name|iv0
operator|.
name|step
operator|=
name|simplify_gen_binary
argument_list|(
name|MINUS
argument_list|,
name|comp_mode
argument_list|,
name|iv0
operator|.
name|step
argument_list|,
name|iv1
operator|.
name|step
argument_list|)
expr_stmt|;
name|iv1
operator|.
name|step
operator|=
name|const0_rtx
expr_stmt|;
if|if
condition|(
name|INTVAL
argument_list|(
name|iv0
operator|.
name|step
argument_list|)
operator|<
literal|0
condition|)
block|{
name|iv0
operator|.
name|step
operator|=
name|simplify_gen_unary
argument_list|(
name|NEG
argument_list|,
name|comp_mode
argument_list|,
name|iv0
operator|.
name|step
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|iv1
operator|.
name|base
operator|=
name|simplify_gen_unary
argument_list|(
name|NEG
argument_list|,
name|comp_mode
argument_list|,
name|iv1
operator|.
name|base
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
name|iv0
operator|.
name|step
operator|=
name|lowpart_subreg
argument_list|(
name|mode
argument_list|,
name|iv0
operator|.
name|step
argument_list|,
name|comp_mode
argument_list|)
expr_stmt|;
comment|/* Let nsd (s, size of mode) = d.  If d does not divide c, the loop 	 is infinite.  Otherwise, the number of iterations is 	 (inverse(s/d) * (c/d)) mod (size of mode/d).  */
name|s
operator|=
name|INTVAL
argument_list|(
name|iv0
operator|.
name|step
argument_list|)
expr_stmt|;
name|d
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|s
operator|%
literal|2
operator|!=
literal|1
condition|)
block|{
name|s
operator|/=
literal|2
expr_stmt|;
name|d
operator|*=
literal|2
expr_stmt|;
name|size
operator|--
expr_stmt|;
block|}
name|bound
operator|=
name|GEN_INT
argument_list|(
operator|(
operator|(
name|unsigned
name|HOST_WIDEST_INT
operator|)
literal|1
operator|<<
operator|(
name|size
operator|-
literal|1
operator|)
operator|<<
literal|1
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|tmp1
operator|=
name|lowpart_subreg
argument_list|(
name|mode
argument_list|,
name|iv1
operator|.
name|base
argument_list|,
name|comp_mode
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|simplify_gen_binary
argument_list|(
name|UMOD
argument_list|,
name|mode
argument_list|,
name|tmp1
argument_list|,
name|GEN_INT
argument_list|(
name|d
argument_list|)
argument_list|)
expr_stmt|;
name|assumption
operator|=
name|simplify_gen_relational
argument_list|(
name|NE
argument_list|,
name|SImode
argument_list|,
name|mode
argument_list|,
name|tmp
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|desc
operator|->
name|infinite
operator|=
name|alloc_EXPR_LIST
argument_list|(
literal|0
argument_list|,
name|assumption
argument_list|,
name|desc
operator|->
name|infinite
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|simplify_gen_binary
argument_list|(
name|UDIV
argument_list|,
name|mode
argument_list|,
name|tmp1
argument_list|,
name|GEN_INT
argument_list|(
name|d
argument_list|)
argument_list|)
expr_stmt|;
name|inv
operator|=
name|inverse
argument_list|(
name|s
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|simplify_gen_binary
argument_list|(
name|MULT
argument_list|,
name|mode
argument_list|,
name|tmp
argument_list|,
name|gen_int_mode
argument_list|(
name|inv
argument_list|,
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|desc
operator|->
name|niter_expr
operator|=
name|simplify_gen_binary
argument_list|(
name|AND
argument_list|,
name|mode
argument_list|,
name|tmp
argument_list|,
name|bound
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|iv1
operator|.
name|step
operator|==
name|const0_rtx
condition|)
comment|/* Condition in shape a + s * i<= b 	   We must know that b + s does not overflow and a<= b + s and then we 	   can compute number of iterations as (b + s - a) / s.  (It might 	   seem that we in fact could be more clever about testing the b + s 	   overflow condition using some information about b - a mod s, 	   but it was already taken into account during LE -> NE transform).  */
block|{
name|step
operator|=
name|iv0
operator|.
name|step
expr_stmt|;
name|tmp0
operator|=
name|lowpart_subreg
argument_list|(
name|mode
argument_list|,
name|iv0
operator|.
name|base
argument_list|,
name|comp_mode
argument_list|)
expr_stmt|;
name|tmp1
operator|=
name|lowpart_subreg
argument_list|(
name|mode
argument_list|,
name|iv1
operator|.
name|base
argument_list|,
name|comp_mode
argument_list|)
expr_stmt|;
name|bound
operator|=
name|simplify_gen_binary
argument_list|(
name|MINUS
argument_list|,
name|mode
argument_list|,
name|mode_mmax
argument_list|,
name|lowpart_subreg
argument_list|(
name|mode
argument_list|,
name|step
argument_list|,
name|comp_mode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|step_is_pow2
condition|)
block|{
name|rtx
name|t0
decl_stmt|,
name|t1
decl_stmt|;
comment|/* If s is power of 2, we know that the loop is infinite if 		 a % s<= b % s and b + s overflows.  */
name|assumption
operator|=
name|simplify_gen_relational
argument_list|(
name|reverse_condition
argument_list|(
name|cond
argument_list|)
argument_list|,
name|SImode
argument_list|,
name|mode
argument_list|,
name|tmp1
argument_list|,
name|bound
argument_list|)
expr_stmt|;
name|t0
operator|=
name|simplify_gen_binary
argument_list|(
name|UMOD
argument_list|,
name|mode
argument_list|,
name|copy_rtx
argument_list|(
name|tmp0
argument_list|)
argument_list|,
name|step
argument_list|)
expr_stmt|;
name|t1
operator|=
name|simplify_gen_binary
argument_list|(
name|UMOD
argument_list|,
name|mode
argument_list|,
name|copy_rtx
argument_list|(
name|tmp1
argument_list|)
argument_list|,
name|step
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|simplify_gen_relational
argument_list|(
name|cond
argument_list|,
name|SImode
argument_list|,
name|mode
argument_list|,
name|t0
argument_list|,
name|t1
argument_list|)
expr_stmt|;
name|assumption
operator|=
name|simplify_gen_binary
argument_list|(
name|AND
argument_list|,
name|SImode
argument_list|,
name|assumption
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|desc
operator|->
name|infinite
operator|=
name|alloc_EXPR_LIST
argument_list|(
literal|0
argument_list|,
name|assumption
argument_list|,
name|desc
operator|->
name|infinite
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assumption
operator|=
name|simplify_gen_relational
argument_list|(
name|cond
argument_list|,
name|SImode
argument_list|,
name|mode
argument_list|,
name|tmp1
argument_list|,
name|bound
argument_list|)
expr_stmt|;
name|desc
operator|->
name|assumptions
operator|=
name|alloc_EXPR_LIST
argument_list|(
literal|0
argument_list|,
name|assumption
argument_list|,
name|desc
operator|->
name|assumptions
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|=
name|simplify_gen_binary
argument_list|(
name|PLUS
argument_list|,
name|comp_mode
argument_list|,
name|iv1
operator|.
name|base
argument_list|,
name|iv0
operator|.
name|step
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|lowpart_subreg
argument_list|(
name|mode
argument_list|,
name|tmp
argument_list|,
name|comp_mode
argument_list|)
expr_stmt|;
name|assumption
operator|=
name|simplify_gen_relational
argument_list|(
name|reverse_condition
argument_list|(
name|cond
argument_list|)
argument_list|,
name|SImode
argument_list|,
name|mode
argument_list|,
name|tmp0
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|delta
operator|=
name|simplify_gen_binary
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|tmp1
argument_list|,
name|step
argument_list|)
expr_stmt|;
name|delta
operator|=
name|simplify_gen_binary
argument_list|(
name|MINUS
argument_list|,
name|mode
argument_list|,
name|delta
argument_list|,
name|tmp0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Condition in shape a<= b - s * i 	     We must know that a - s does not overflow and a - s<= b and then 	     we can again compute number of iterations as (b - (a - s)) / s.  */
name|step
operator|=
name|simplify_gen_unary
argument_list|(
name|NEG
argument_list|,
name|mode
argument_list|,
name|iv1
operator|.
name|step
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|tmp0
operator|=
name|lowpart_subreg
argument_list|(
name|mode
argument_list|,
name|iv0
operator|.
name|base
argument_list|,
name|comp_mode
argument_list|)
expr_stmt|;
name|tmp1
operator|=
name|lowpart_subreg
argument_list|(
name|mode
argument_list|,
name|iv1
operator|.
name|base
argument_list|,
name|comp_mode
argument_list|)
expr_stmt|;
name|bound
operator|=
name|simplify_gen_binary
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|mode_mmin
argument_list|,
name|lowpart_subreg
argument_list|(
name|mode
argument_list|,
name|step
argument_list|,
name|comp_mode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|step_is_pow2
condition|)
block|{
name|rtx
name|t0
decl_stmt|,
name|t1
decl_stmt|;
comment|/* If s is power of 2, we know that the loop is infinite if 		 a % s<= b % s and a - s overflows.  */
name|assumption
operator|=
name|simplify_gen_relational
argument_list|(
name|reverse_condition
argument_list|(
name|cond
argument_list|)
argument_list|,
name|SImode
argument_list|,
name|mode
argument_list|,
name|bound
argument_list|,
name|tmp0
argument_list|)
expr_stmt|;
name|t0
operator|=
name|simplify_gen_binary
argument_list|(
name|UMOD
argument_list|,
name|mode
argument_list|,
name|copy_rtx
argument_list|(
name|tmp0
argument_list|)
argument_list|,
name|step
argument_list|)
expr_stmt|;
name|t1
operator|=
name|simplify_gen_binary
argument_list|(
name|UMOD
argument_list|,
name|mode
argument_list|,
name|copy_rtx
argument_list|(
name|tmp1
argument_list|)
argument_list|,
name|step
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|simplify_gen_relational
argument_list|(
name|cond
argument_list|,
name|SImode
argument_list|,
name|mode
argument_list|,
name|t0
argument_list|,
name|t1
argument_list|)
expr_stmt|;
name|assumption
operator|=
name|simplify_gen_binary
argument_list|(
name|AND
argument_list|,
name|SImode
argument_list|,
name|assumption
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|desc
operator|->
name|infinite
operator|=
name|alloc_EXPR_LIST
argument_list|(
literal|0
argument_list|,
name|assumption
argument_list|,
name|desc
operator|->
name|infinite
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assumption
operator|=
name|simplify_gen_relational
argument_list|(
name|cond
argument_list|,
name|SImode
argument_list|,
name|mode
argument_list|,
name|bound
argument_list|,
name|tmp0
argument_list|)
expr_stmt|;
name|desc
operator|->
name|assumptions
operator|=
name|alloc_EXPR_LIST
argument_list|(
literal|0
argument_list|,
name|assumption
argument_list|,
name|desc
operator|->
name|assumptions
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|=
name|simplify_gen_binary
argument_list|(
name|PLUS
argument_list|,
name|comp_mode
argument_list|,
name|iv0
operator|.
name|base
argument_list|,
name|iv1
operator|.
name|step
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|lowpart_subreg
argument_list|(
name|mode
argument_list|,
name|tmp
argument_list|,
name|comp_mode
argument_list|)
expr_stmt|;
name|assumption
operator|=
name|simplify_gen_relational
argument_list|(
name|reverse_condition
argument_list|(
name|cond
argument_list|)
argument_list|,
name|SImode
argument_list|,
name|mode
argument_list|,
name|tmp
argument_list|,
name|tmp1
argument_list|)
expr_stmt|;
name|delta
operator|=
name|simplify_gen_binary
argument_list|(
name|MINUS
argument_list|,
name|mode
argument_list|,
name|tmp0
argument_list|,
name|step
argument_list|)
expr_stmt|;
name|delta
operator|=
name|simplify_gen_binary
argument_list|(
name|MINUS
argument_list|,
name|mode
argument_list|,
name|tmp1
argument_list|,
name|delta
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|assumption
operator|==
name|const_true_rtx
condition|)
goto|goto
name|zero_iter_simplify
goto|;
elseif|else
if|if
condition|(
name|assumption
operator|!=
name|const0_rtx
condition|)
name|desc
operator|->
name|noloop_assumptions
operator|=
name|alloc_EXPR_LIST
argument_list|(
literal|0
argument_list|,
name|assumption
argument_list|,
name|desc
operator|->
name|noloop_assumptions
argument_list|)
expr_stmt|;
name|delta
operator|=
name|simplify_gen_binary
argument_list|(
name|UDIV
argument_list|,
name|mode
argument_list|,
name|delta
argument_list|,
name|step
argument_list|)
expr_stmt|;
name|desc
operator|->
name|niter_expr
operator|=
name|delta
expr_stmt|;
block|}
name|old_niter
operator|=
name|desc
operator|->
name|niter_expr
expr_stmt|;
name|simplify_using_initial_values
argument_list|(
name|loop
argument_list|,
name|AND
argument_list|,
operator|&
name|desc
operator|->
name|assumptions
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|->
name|assumptions
operator|&&
name|XEXP
argument_list|(
name|desc
operator|->
name|assumptions
argument_list|,
literal|0
argument_list|)
operator|==
name|const0_rtx
condition|)
goto|goto
name|fail
goto|;
name|simplify_using_initial_values
argument_list|(
name|loop
argument_list|,
name|IOR
argument_list|,
operator|&
name|desc
operator|->
name|noloop_assumptions
argument_list|)
expr_stmt|;
name|simplify_using_initial_values
argument_list|(
name|loop
argument_list|,
name|IOR
argument_list|,
operator|&
name|desc
operator|->
name|infinite
argument_list|)
expr_stmt|;
name|simplify_using_initial_values
argument_list|(
name|loop
argument_list|,
name|UNKNOWN
argument_list|,
operator|&
name|desc
operator|->
name|niter_expr
argument_list|)
expr_stmt|;
comment|/* Rerun the simplification.  Consider code (created by copying loop headers)       i = 0;       if (0< n)        {          do 	   { 	     i++; 	   } while (i< n);        }      The first pass determines that i = 0, the second pass uses it to eliminate     noloop assumption.  */
name|simplify_using_initial_values
argument_list|(
name|loop
argument_list|,
name|AND
argument_list|,
operator|&
name|desc
operator|->
name|assumptions
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|->
name|assumptions
operator|&&
name|XEXP
argument_list|(
name|desc
operator|->
name|assumptions
argument_list|,
literal|0
argument_list|)
operator|==
name|const0_rtx
condition|)
goto|goto
name|fail
goto|;
name|simplify_using_initial_values
argument_list|(
name|loop
argument_list|,
name|IOR
argument_list|,
operator|&
name|desc
operator|->
name|noloop_assumptions
argument_list|)
expr_stmt|;
name|simplify_using_initial_values
argument_list|(
name|loop
argument_list|,
name|IOR
argument_list|,
operator|&
name|desc
operator|->
name|infinite
argument_list|)
expr_stmt|;
name|simplify_using_initial_values
argument_list|(
name|loop
argument_list|,
name|UNKNOWN
argument_list|,
operator|&
name|desc
operator|->
name|niter_expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|->
name|noloop_assumptions
operator|&&
name|XEXP
argument_list|(
name|desc
operator|->
name|noloop_assumptions
argument_list|,
literal|0
argument_list|)
operator|==
name|const_true_rtx
condition|)
goto|goto
name|zero_iter
goto|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|desc
operator|->
name|niter_expr
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|unsigned
name|HOST_WIDEST_INT
name|val
init|=
name|INTVAL
argument_list|(
name|desc
operator|->
name|niter_expr
argument_list|)
decl_stmt|;
name|desc
operator|->
name|const_iter
operator|=
name|true
expr_stmt|;
name|desc
operator|->
name|niter_max
operator|=
name|desc
operator|->
name|niter
operator|=
name|val
operator|&
name|GET_MODE_MASK
argument_list|(
name|desc
operator|->
name|mode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|desc
operator|->
name|niter_max
condition|)
name|desc
operator|->
name|niter_max
operator|=
name|determine_max_iter
argument_list|(
name|desc
argument_list|)
expr_stmt|;
comment|/* simplify_using_initial_values does a copy propagation on the registers 	 in the expression for the number of iterations.  This prolongs life 	 ranges of registers and increases register pressure, and usually 	 brings no gain (and if it happens to do, the cse pass will take care 	 of it anyway).  So prevent this behavior, unless it enabled us to 	 derive that the number of iterations is a constant.  */
name|desc
operator|->
name|niter_expr
operator|=
name|old_niter
expr_stmt|;
block|}
return|return;
name|zero_iter_simplify
label|:
comment|/* Simplify the assumptions.  */
name|simplify_using_initial_values
argument_list|(
name|loop
argument_list|,
name|AND
argument_list|,
operator|&
name|desc
operator|->
name|assumptions
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|->
name|assumptions
operator|&&
name|XEXP
argument_list|(
name|desc
operator|->
name|assumptions
argument_list|,
literal|0
argument_list|)
operator|==
name|const0_rtx
condition|)
goto|goto
name|fail
goto|;
name|simplify_using_initial_values
argument_list|(
name|loop
argument_list|,
name|IOR
argument_list|,
operator|&
name|desc
operator|->
name|infinite
argument_list|)
expr_stmt|;
comment|/* Fallthru.  */
name|zero_iter
label|:
name|desc
operator|->
name|const_iter
operator|=
name|true
expr_stmt|;
name|desc
operator|->
name|niter
operator|=
literal|0
expr_stmt|;
name|desc
operator|->
name|niter_max
operator|=
literal|0
expr_stmt|;
name|desc
operator|->
name|noloop_assumptions
operator|=
name|NULL_RTX
expr_stmt|;
name|desc
operator|->
name|niter_expr
operator|=
name|const0_rtx
expr_stmt|;
return|return;
name|fail
label|:
name|desc
operator|->
name|simple_p
operator|=
name|false
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Checks whether E is a simple exit from LOOP and stores its description    into DESC.  */
end_comment

begin_function
specifier|static
name|void
name|check_simple_exit
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|edge
name|e
parameter_list|,
name|struct
name|niter_desc
modifier|*
name|desc
parameter_list|)
block|{
name|basic_block
name|exit_bb
decl_stmt|;
name|rtx
name|condition
decl_stmt|,
name|at
decl_stmt|;
name|edge
name|ein
decl_stmt|;
name|exit_bb
operator|=
name|e
operator|->
name|src
expr_stmt|;
name|desc
operator|->
name|simple_p
operator|=
name|false
expr_stmt|;
comment|/* It must belong directly to the loop.  */
if|if
condition|(
name|exit_bb
operator|->
name|loop_father
operator|!=
name|loop
condition|)
return|return;
comment|/* It must be tested (at least) once during any iteration.  */
if|if
condition|(
operator|!
name|dominated_by_p
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|loop
operator|->
name|latch
argument_list|,
name|exit_bb
argument_list|)
condition|)
return|return;
comment|/* It must end in a simple conditional jump.  */
if|if
condition|(
operator|!
name|any_condjump_p
argument_list|(
name|BB_END
argument_list|(
name|exit_bb
argument_list|)
argument_list|)
condition|)
return|return;
name|ein
operator|=
name|EDGE_SUCC
argument_list|(
name|exit_bb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ein
operator|==
name|e
condition|)
name|ein
operator|=
name|EDGE_SUCC
argument_list|(
name|exit_bb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|desc
operator|->
name|out_edge
operator|=
name|e
expr_stmt|;
name|desc
operator|->
name|in_edge
operator|=
name|ein
expr_stmt|;
comment|/* Test whether the condition is suitable.  */
if|if
condition|(
operator|!
operator|(
name|condition
operator|=
name|get_condition
argument_list|(
name|BB_END
argument_list|(
name|ein
operator|->
name|src
argument_list|)
argument_list|,
operator|&
name|at
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
operator|)
condition|)
return|return;
if|if
condition|(
name|ein
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
block|{
name|condition
operator|=
name|reversed_condition
argument_list|(
name|condition
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|condition
condition|)
return|return;
block|}
comment|/* Check that we are able to determine number of iterations and fill      in information about it.  */
name|iv_number_of_iterations
argument_list|(
name|loop
argument_list|,
name|at
argument_list|,
name|condition
argument_list|,
name|desc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finds a simple exit of LOOP and stores its description into DESC.  */
end_comment

begin_function
name|void
name|find_simple_exit
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|struct
name|niter_desc
modifier|*
name|desc
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|basic_block
modifier|*
name|body
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|struct
name|niter_desc
name|act
decl_stmt|;
name|bool
name|any
init|=
name|false
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|desc
operator|->
name|simple_p
operator|=
name|false
expr_stmt|;
name|body
operator|=
name|get_loop_body
argument_list|(
name|loop
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loop
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
block|{
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|body[i]->succs
argument_list|)
block|{
if|if
condition|(
name|flow_bb_inside_loop_p
argument_list|(
name|loop
argument_list|,
name|e
operator|->
name|dest
argument_list|)
condition|)
continue|continue;
name|check_simple_exit
argument_list|(
name|loop
argument_list|,
name|e
argument_list|,
operator|&
name|act
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|act
operator|.
name|simple_p
condition|)
continue|continue;
if|if
condition|(
operator|!
name|any
condition|)
name|any
operator|=
name|true
expr_stmt|;
else|else
block|{
comment|/* Prefer constant iterations; the less the better.  */
if|if
condition|(
operator|!
name|act
operator|.
name|const_iter
operator|||
operator|(
name|desc
operator|->
name|const_iter
operator|&&
name|act
operator|.
name|niter
operator|>=
name|desc
operator|->
name|niter
operator|)
condition|)
continue|continue;
comment|/* Also if the actual exit may be infinite, while the old one 		 not, prefer the old one.  */
if|if
condition|(
name|act
operator|.
name|infinite
operator|&&
operator|!
name|desc
operator|->
name|infinite
condition|)
continue|continue;
block|}
operator|*
name|desc
operator|=
name|act
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dump_file
condition|)
block|{
if|if
condition|(
name|desc
operator|->
name|simple_p
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Loop %d is simple:\n"
argument_list|,
name|loop
operator|->
name|num
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  simple exit %d -> %d\n"
argument_list|,
name|desc
operator|->
name|out_edge
operator|->
name|src
operator|->
name|index
argument_list|,
name|desc
operator|->
name|out_edge
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|->
name|assumptions
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  assumptions: "
argument_list|)
expr_stmt|;
name|print_rtl
argument_list|(
name|dump_file
argument_list|,
name|desc
operator|->
name|assumptions
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|desc
operator|->
name|noloop_assumptions
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  does not roll if: "
argument_list|)
expr_stmt|;
name|print_rtl
argument_list|(
name|dump_file
argument_list|,
name|desc
operator|->
name|noloop_assumptions
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|desc
operator|->
name|infinite
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  infinite if: "
argument_list|)
expr_stmt|;
name|print_rtl
argument_list|(
name|dump_file
argument_list|,
name|desc
operator|->
name|infinite
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  number of iterations: "
argument_list|)
expr_stmt|;
name|print_rtl
argument_list|(
name|dump_file
argument_list|,
name|desc
operator|->
name|niter_expr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  upper bound: "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
name|HOST_WIDEST_INT_PRINT_DEC
argument_list|,
name|desc
operator|->
name|niter_max
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Loop %d is not simple.\n"
argument_list|,
name|loop
operator|->
name|num
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|body
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Creates a simple loop description of LOOP if it was not computed    already.  */
end_comment

begin_function
name|struct
name|niter_desc
modifier|*
name|get_simple_loop_desc
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|struct
name|niter_desc
modifier|*
name|desc
init|=
name|simple_loop_desc
argument_list|(
name|loop
argument_list|)
decl_stmt|;
if|if
condition|(
name|desc
condition|)
return|return
name|desc
return|;
name|desc
operator|=
name|XNEW
argument_list|(
expr|struct
name|niter_desc
argument_list|)
expr_stmt|;
name|iv_analysis_loop_init
argument_list|(
name|loop
argument_list|)
expr_stmt|;
name|find_simple_exit
argument_list|(
name|loop
argument_list|,
name|desc
argument_list|)
expr_stmt|;
name|loop
operator|->
name|aux
operator|=
name|desc
expr_stmt|;
if|if
condition|(
name|desc
operator|->
name|simple_p
operator|&&
operator|(
name|desc
operator|->
name|assumptions
operator|||
name|desc
operator|->
name|infinite
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|wording
decl_stmt|;
comment|/* Assume that no overflow happens and that the loop is finite.   	 We already warned at the tree level if we ran optimizations there.  */
if|if
condition|(
operator|!
name|flag_tree_loop_optimize
operator|&&
name|warn_unsafe_loop_optimizations
condition|)
block|{
if|if
condition|(
name|desc
operator|->
name|infinite
condition|)
block|{
name|wording
operator|=
name|flag_unsafe_loop_optimizations
condition|?
name|N_
argument_list|(
literal|"assuming that the loop is not infinite"
argument_list|)
else|:
name|N_
argument_list|(
literal|"cannot optimize possibly infinite loops"
argument_list|)
expr_stmt|;
name|warning
argument_list|(
name|OPT_Wunsafe_loop_optimizations
argument_list|,
literal|"%s"
argument_list|,
name|gettext
argument_list|(
name|wording
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|desc
operator|->
name|assumptions
condition|)
block|{
name|wording
operator|=
name|flag_unsafe_loop_optimizations
condition|?
name|N_
argument_list|(
literal|"assuming that the loop counter does not overflow"
argument_list|)
else|:
name|N_
argument_list|(
literal|"cannot optimize loop, the loop counter may overflow"
argument_list|)
expr_stmt|;
name|warning
argument_list|(
name|OPT_Wunsafe_loop_optimizations
argument_list|,
literal|"%s"
argument_list|,
name|gettext
argument_list|(
name|wording
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|flag_unsafe_loop_optimizations
condition|)
block|{
name|desc
operator|->
name|assumptions
operator|=
name|NULL_RTX
expr_stmt|;
name|desc
operator|->
name|infinite
operator|=
name|NULL_RTX
expr_stmt|;
block|}
block|}
return|return
name|desc
return|;
block|}
end_function

begin_comment
comment|/* Releases simple loop description for LOOP.  */
end_comment

begin_function
name|void
name|free_simple_loop_desc
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|struct
name|niter_desc
modifier|*
name|desc
init|=
name|simple_loop_desc
argument_list|(
name|loop
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|desc
condition|)
return|return;
name|free
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|loop
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
block|}
end_function

end_unit

