begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Simple garbage collection for the GNU compiler.    Copyright (C) 1999, 2000, 2001, 2002 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Generic garbage collection (GC) functions and data, not specific to    any particular GC implementation.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"hash.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"varray.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_comment
comment|/* Statistics about the allocation.  */
end_comment

begin_decl_stmt
specifier|static
name|ggc_statistics
modifier|*
name|ggc_stats
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The FALSE_LABEL_STACK, declared in except.h, has language-dependent    semantics.  If a front-end needs to mark the false label stack, it    should set this pointer to a non-NULL value.  Otherwise, no marking    will be done.  */
end_comment

begin_macro
name|void
argument_list|(
argument|*lang_mark_false_label_stack
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
expr|struct
name|label_node
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Trees that have been marked, but whose children still need marking.  */
end_comment

begin_decl_stmt
name|varray_type
name|ggc_pending_trees
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ggc_mark_rtx_ptr
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ggc_mark_tree_ptr
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ggc_mark_rtx_varray_ptr
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ggc_mark_tree_varray_ptr
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ggc_mark_tree_hash_table_ptr
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ggc_htab_delete
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ggc_mark_trees
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|ggc_mark_tree_hash_table_entry
name|PARAMS
argument_list|(
operator|(
expr|struct
name|hash_entry
operator|*
operator|,
name|hash_table_key
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maintain global roots that are preserved during GC.  */
end_comment

begin_comment
comment|/* Global roots that are preserved during calls to gc.  */
end_comment

begin_struct
struct|struct
name|ggc_root
block|{
name|struct
name|ggc_root
modifier|*
name|next
decl_stmt|;
name|void
modifier|*
name|base
decl_stmt|;
name|int
name|nelt
decl_stmt|;
name|int
name|size
decl_stmt|;
name|void
argument_list|(
argument|*cb
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
expr_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|ggc_root
modifier|*
name|roots
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Add BASE as a new garbage collection root.  It is an array of    length NELT with each element SIZE bytes long.  CB is a     function that will be called with a pointer to each element    of the array; it is the intention that CB call the appropriate    routine to mark gc-able memory for that element.  */
end_comment

begin_function_decl
name|void
name|ggc_add_root
parameter_list|(
name|base
parameter_list|,
name|nelt
parameter_list|,
name|size
parameter_list|,
name|cb
parameter_list|)
name|void
modifier|*
name|base
decl_stmt|;
name|int
name|nelt
decl_stmt|,
name|size
decl_stmt|;
function_decl|void
parameter_list|(
function_decl|*cb
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|ggc_root
modifier|*
name|x
init|=
operator|(
expr|struct
name|ggc_root
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|x
argument_list|)
argument_list|)
decl_stmt|;
name|x
operator|->
name|next
operator|=
name|roots
expr_stmt|;
name|x
operator|->
name|base
operator|=
name|base
expr_stmt|;
name|x
operator|->
name|nelt
operator|=
name|nelt
expr_stmt|;
name|x
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|x
operator|->
name|cb
operator|=
name|cb
expr_stmt|;
name|roots
operator|=
name|x
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Register an array of rtx as a GC root.  */
end_comment

begin_function
name|void
name|ggc_add_rtx_root
parameter_list|(
name|base
parameter_list|,
name|nelt
parameter_list|)
name|rtx
modifier|*
name|base
decl_stmt|;
name|int
name|nelt
decl_stmt|;
block|{
name|ggc_add_root
argument_list|(
name|base
argument_list|,
name|nelt
argument_list|,
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|,
name|ggc_mark_rtx_ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Register an array of trees as a GC root.  */
end_comment

begin_function
name|void
name|ggc_add_tree_root
parameter_list|(
name|base
parameter_list|,
name|nelt
parameter_list|)
name|tree
modifier|*
name|base
decl_stmt|;
name|int
name|nelt
decl_stmt|;
block|{
name|ggc_add_root
argument_list|(
name|base
argument_list|,
name|nelt
argument_list|,
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|,
name|ggc_mark_tree_ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Register a varray of rtxs as a GC root.  */
end_comment

begin_function
name|void
name|ggc_add_rtx_varray_root
parameter_list|(
name|base
parameter_list|,
name|nelt
parameter_list|)
name|varray_type
modifier|*
name|base
decl_stmt|;
name|int
name|nelt
decl_stmt|;
block|{
name|ggc_add_root
argument_list|(
name|base
argument_list|,
name|nelt
argument_list|,
sizeof|sizeof
argument_list|(
name|varray_type
argument_list|)
argument_list|,
name|ggc_mark_rtx_varray_ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Register a varray of trees as a GC root.  */
end_comment

begin_function
name|void
name|ggc_add_tree_varray_root
parameter_list|(
name|base
parameter_list|,
name|nelt
parameter_list|)
name|varray_type
modifier|*
name|base
decl_stmt|;
name|int
name|nelt
decl_stmt|;
block|{
name|ggc_add_root
argument_list|(
name|base
argument_list|,
name|nelt
argument_list|,
sizeof|sizeof
argument_list|(
name|varray_type
argument_list|)
argument_list|,
name|ggc_mark_tree_varray_ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Register a hash table of trees as a GC root.  */
end_comment

begin_function
name|void
name|ggc_add_tree_hash_table_root
parameter_list|(
name|base
parameter_list|,
name|nelt
parameter_list|)
name|struct
name|hash_table
modifier|*
modifier|*
name|base
decl_stmt|;
name|int
name|nelt
decl_stmt|;
block|{
name|ggc_add_root
argument_list|(
name|base
argument_list|,
name|nelt
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hash_table
operator|*
argument_list|)
argument_list|,
name|ggc_mark_tree_hash_table_ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove the previously registered GC root at BASE.  */
end_comment

begin_function
name|void
name|ggc_del_root
parameter_list|(
name|base
parameter_list|)
name|void
modifier|*
name|base
decl_stmt|;
block|{
name|struct
name|ggc_root
modifier|*
name|x
decl_stmt|,
modifier|*
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|&
name|roots
operator|,
name|x
operator|=
name|roots
expr_stmt|;
while|while
condition|(
name|x
condition|)
block|{
if|if
condition|(
name|x
operator|->
name|base
operator|==
name|base
condition|)
block|{
operator|*
name|p
operator|=
name|x
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return;
block|}
name|p
operator|=
operator|&
name|x
operator|->
name|next
expr_stmt|;
name|x
operator|=
name|x
operator|->
name|next
expr_stmt|;
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a hash table to be scanned when all roots have been processed.  We    delete any entry in the table that has not been marked.  */
end_comment

begin_struct
struct|struct
name|d_htab_root
block|{
name|struct
name|d_htab_root
modifier|*
name|next
decl_stmt|;
name|htab_t
name|htab
decl_stmt|;
name|ggc_htab_marked_p
name|marked_p
decl_stmt|;
name|ggc_htab_mark
name|mark
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|d_htab_root
modifier|*
name|d_htab_roots
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Add X, an htab, to a list of htabs that contain objects which are allocated    from GC memory.  Once all other roots are marked, we check each object in    the htab to see if it has already been marked.  If not, it is deleted.     MARKED_P, if specified, is a function that returns 1 if the entry is to    be considered as "marked".  If not present, the data structure pointed to    by the htab slot is tested.  This function should be supplied if some    other object (such as something pointed to by that object) should be tested    in which case the function tests whether that object (or objects) are    marked (using ggc_marked_p) and returns nonzero if it is.     MARK, if specified, is a function that is passed the contents of a slot    that has been determined to have been "marked" (via the above function)    and marks any other objects pointed to by that object.  For example,    we might have a hash table of memory attribute blocks, which are pointed    to by a MEM RTL but have a pointer to a DECL.  MARKED_P in that case will    not be specified because we want to know if the attribute block is pointed    to by the MEM, but MARK must be specified because if the block has been    marked, we need to mark the DECL.  */
end_comment

begin_function
name|void
name|ggc_add_deletable_htab
parameter_list|(
name|x
parameter_list|,
name|marked_p
parameter_list|,
name|mark
parameter_list|)
name|PTR
name|x
decl_stmt|;
name|ggc_htab_marked_p
name|marked_p
decl_stmt|;
name|ggc_htab_mark
name|mark
decl_stmt|;
block|{
name|struct
name|d_htab_root
modifier|*
name|r
init|=
operator|(
expr|struct
name|d_htab_root
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|d_htab_root
argument_list|)
argument_list|)
decl_stmt|;
name|r
operator|->
name|next
operator|=
name|d_htab_roots
expr_stmt|;
name|r
operator|->
name|htab
operator|=
operator|(
name|htab_t
operator|)
name|x
expr_stmt|;
name|r
operator|->
name|marked_p
operator|=
name|marked_p
condition|?
name|marked_p
else|:
name|ggc_marked_p
expr_stmt|;
name|r
operator|->
name|mark
operator|=
name|mark
expr_stmt|;
name|d_htab_roots
operator|=
name|r
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process a slot of an htab by deleting it if it has not been marked.  */
end_comment

begin_function
specifier|static
name|int
name|ggc_htab_delete
parameter_list|(
name|slot
parameter_list|,
name|info
parameter_list|)
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
name|void
modifier|*
name|info
decl_stmt|;
block|{
name|struct
name|d_htab_root
modifier|*
name|r
init|=
operator|(
expr|struct
name|d_htab_root
operator|*
operator|)
name|info
decl_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|r
operator|->
name|marked_p
call|)
argument_list|(
operator|*
name|slot
argument_list|)
condition|)
name|htab_clear_slot
argument_list|(
name|r
operator|->
name|htab
argument_list|,
name|slot
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|mark
condition|)
call|(
modifier|*
name|r
operator|->
name|mark
call|)
argument_list|(
operator|*
name|slot
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Iterate through all registered roots and mark each element.  */
end_comment

begin_function
name|void
name|ggc_mark_roots
parameter_list|()
block|{
name|struct
name|ggc_root
modifier|*
name|x
decl_stmt|;
name|struct
name|d_htab_root
modifier|*
name|y
decl_stmt|;
name|VARRAY_TREE_INIT
argument_list|(
name|ggc_pending_trees
argument_list|,
literal|4096
argument_list|,
literal|"ggc_pending_trees"
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
name|roots
init|;
name|x
operator|!=
name|NULL
condition|;
name|x
operator|=
name|x
operator|->
name|next
control|)
block|{
name|char
modifier|*
name|elt
init|=
name|x
operator|->
name|base
decl_stmt|;
name|int
name|s
init|=
name|x
operator|->
name|size
decl_stmt|,
name|n
init|=
name|x
operator|->
name|nelt
decl_stmt|;
name|void
argument_list|(
argument|*cb
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
operator|=
name|x
operator|->
name|cb
expr_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
operator|,
name|elt
operator|+=
name|s
control|)
call|(
modifier|*
name|cb
call|)
argument_list|(
name|elt
argument_list|)
expr_stmt|;
block|}
comment|/* Mark all the queued up trees, and their children.  */
name|ggc_mark_trees
argument_list|()
expr_stmt|;
name|VARRAY_FREE
argument_list|(
name|ggc_pending_trees
argument_list|)
expr_stmt|;
comment|/* Now scan all hash tables that have objects which are to be deleted if      they are not already marked.  Since these may mark more trees, we need      to reinitialize that varray.  */
name|VARRAY_TREE_INIT
argument_list|(
name|ggc_pending_trees
argument_list|,
literal|1024
argument_list|,
literal|"ggc_pending_trees"
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
name|d_htab_roots
init|;
name|y
operator|!=
name|NULL
condition|;
name|y
operator|=
name|y
operator|->
name|next
control|)
name|htab_traverse
argument_list|(
name|y
operator|->
name|htab
argument_list|,
name|ggc_htab_delete
argument_list|,
operator|(
name|PTR
operator|)
name|y
argument_list|)
expr_stmt|;
name|ggc_mark_trees
argument_list|()
expr_stmt|;
name|VARRAY_FREE
argument_list|(
name|ggc_pending_trees
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* R had not been previously marked, but has now been marked via    ggc_set_mark.  Now recurse and process the children.  */
end_comment

begin_function
name|void
name|ggc_mark_rtx_children
parameter_list|(
name|r
parameter_list|)
name|rtx
name|r
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rtx
name|next_rtx
decl_stmt|;
do|do
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|r
argument_list|)
decl_stmt|;
comment|/* This gets set to a child rtx to eliminate tail recursion.  */
name|next_rtx
operator|=
name|NULL
expr_stmt|;
comment|/* Collect statistics, if appropriate.  */
if|if
condition|(
name|ggc_stats
condition|)
block|{
operator|++
name|ggc_stats
operator|->
name|num_rtxs
index|[
operator|(
name|int
operator|)
name|code
index|]
expr_stmt|;
name|ggc_stats
operator|->
name|size_rtxs
index|[
operator|(
name|int
operator|)
name|code
index|]
operator|+=
name|ggc_get_size
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
comment|/* ??? If (some of) these are really pass-dependent info, do we 	 have any right poking our noses in?  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|MEM
case|:
name|ggc_mark
argument_list|(
name|MEM_ATTRS
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|JUMP_INSN
case|:
name|ggc_mark_rtx
argument_list|(
name|JUMP_LABEL
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CODE_LABEL
case|:
name|ggc_mark_rtx
argument_list|(
name|LABEL_REFS
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LABEL_REF
case|:
name|ggc_mark_rtx
argument_list|(
name|LABEL_NEXTREF
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
name|ggc_mark_rtx
argument_list|(
name|CONTAINING_INSN
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ADDRESSOF
case|:
name|ggc_mark_tree
argument_list|(
name|ADDRESSOF_DECL
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_DOUBLE
case|:
name|ggc_mark_rtx
argument_list|(
name|CONST_DOUBLE_CHAIN
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NOTE
case|:
switch|switch
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|r
argument_list|)
condition|)
block|{
case|case
name|NOTE_INSN_RANGE_BEG
case|:
case|case
name|NOTE_INSN_RANGE_END
case|:
case|case
name|NOTE_INSN_LIVE
case|:
case|case
name|NOTE_INSN_EXPECTED_VALUE
case|:
name|ggc_mark_rtx
argument_list|(
name|NOTE_RANGE_INFO
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NOTE_INSN_BLOCK_BEG
case|:
case|case
name|NOTE_INSN_BLOCK_END
case|:
name|ggc_mark_tree
argument_list|(
name|NOTE_BLOCK
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
default|default:
break|break;
block|}
for|for
control|(
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|r
argument_list|)
argument_list|)
operator|,
name|i
operator|=
literal|0
init|;
operator|*
name|fmt
condition|;
operator|++
name|fmt
operator|,
operator|++
name|i
control|)
block|{
name|rtx
name|exp
decl_stmt|;
switch|switch
condition|(
operator|*
name|fmt
condition|)
block|{
case|case
literal|'e'
case|:
case|case
literal|'u'
case|:
name|exp
operator|=
name|XEXP
argument_list|(
name|r
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|ggc_test_and_set_mark
argument_list|(
name|exp
argument_list|)
condition|)
block|{
if|if
condition|(
name|next_rtx
operator|==
name|NULL
condition|)
name|next_rtx
operator|=
name|exp
expr_stmt|;
else|else
name|ggc_mark_rtx_children
argument_list|(
name|exp
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'V'
case|:
case|case
literal|'E'
case|:
name|ggc_mark_rtvec
argument_list|(
name|XVEC
argument_list|(
name|r
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
do|while
condition|(
operator|(
name|r
operator|=
name|next_rtx
operator|)
operator|!=
name|NULL
condition|)
do|;
block|}
end_function

begin_comment
comment|/* V had not been previously marked, but has now been marked via    ggc_set_mark.  Now recurse and process the children.  */
end_comment

begin_function
name|void
name|ggc_mark_rtvec_children
parameter_list|(
name|v
parameter_list|)
name|rtvec
name|v
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|i
operator|=
name|GET_NUM_ELEM
argument_list|(
name|v
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
name|ggc_mark_rtx
argument_list|(
name|RTVEC_ELT
argument_list|(
name|v
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Recursively set marks on all of the children of the    GCC_PENDING_TREES.  */
end_comment

begin_function
specifier|static
name|void
name|ggc_mark_trees
parameter_list|()
block|{
while|while
condition|(
name|ggc_pending_trees
operator|->
name|elements_used
condition|)
block|{
name|tree
name|t
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
name|t
operator|=
name|VARRAY_TOP_TREE
argument_list|(
name|ggc_pending_trees
argument_list|)
expr_stmt|;
name|VARRAY_POP
argument_list|(
name|ggc_pending_trees
argument_list|)
expr_stmt|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Collect statistics, if appropriate.  */
if|if
condition|(
name|ggc_stats
condition|)
block|{
operator|++
name|ggc_stats
operator|->
name|num_trees
index|[
operator|(
name|int
operator|)
name|code
index|]
expr_stmt|;
name|ggc_stats
operator|->
name|size_trees
index|[
operator|(
name|int
operator|)
name|code
index|]
operator|+=
name|ggc_get_size
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
comment|/* Bits from common.  */
name|ggc_mark_tree
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Some nodes require special handling.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|TREE_LIST
case|:
name|ggc_mark_tree
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|TREE_VEC
case|:
block|{
name|int
name|i
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|t
argument_list|)
decl_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
name|ggc_mark_tree
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
case|case
name|COMPLEX_CST
case|:
name|ggc_mark_tree
argument_list|(
name|TREE_REALPART
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|TREE_IMAGPART
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARM_DECL
case|:
name|ggc_mark_rtx
argument_list|(
name|DECL_INCOMING_RTL
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FIELD_DECL
case|:
name|ggc_mark_tree
argument_list|(
name|DECL_FIELD_BIT_OFFSET
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|IDENTIFIER_NODE
case|:
name|lang_mark_tree
argument_list|(
name|t
argument_list|)
expr_stmt|;
continue|continue;
default|default:
break|break;
block|}
comment|/* But in general we can handle them by class.  */
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
literal|'d'
case|:
comment|/* A decl node.  */
name|ggc_mark_tree
argument_list|(
name|DECL_SIZE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|DECL_SIZE_UNIT
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|DECL_RESULT_FLD
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|DECL_SECTION_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|DECL_ATTRIBUTES
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_RTL_SET_P
argument_list|(
name|t
argument_list|)
condition|)
name|ggc_mark_rtx
argument_list|(
name|DECL_RTL
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ggc_mark_rtx
argument_list|(
name|DECL_LIVE_RANGE_RTL
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|DECL_VINDEX
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_ASSEMBLER_NAME_SET_P
argument_list|(
name|t
argument_list|)
condition|)
name|ggc_mark_tree
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|ggc_mark_tree
argument_list|(
name|DECL_SAVED_TREE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|DECL_INLINED_FNS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_SAVED_INSNS
argument_list|(
name|t
argument_list|)
condition|)
name|ggc_mark_struct_function
argument_list|(
name|DECL_SAVED_INSNS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|lang_mark_tree
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* A type node.  */
name|ggc_mark_tree
argument_list|(
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|TYPE_ATTRIBUTES
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|TYPE_VALUES
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|TYPE_POINTER_TO
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|TYPE_REFERENCE_TO
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|TYPE_NEXT_VARIANT
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|lang_mark_tree
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
comment|/* A lexical block.  */
name|ggc_mark_tree
argument_list|(
name|BLOCK_VARS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|BLOCK_SUBBLOCKS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|BLOCK_SUPERCONTEXT
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|BLOCK_ABSTRACT_ORIGIN
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* A constant.  */
name|ggc_mark_rtx
argument_list|(
name|TREE_CST_RTL
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
case|case
literal|'<'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'e'
case|:
case|case
literal|'s'
case|:
comment|/* Expressions.  */
block|{
name|int
name|i
init|=
name|TREE_CODE_LENGTH
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|first_rtl
init|=
name|first_rtl_op
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|>=
name|first_rtl
condition|)
name|ggc_mark_rtx
argument_list|(
operator|(
name|rtx
operator|)
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|ggc_mark_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|'x'
case|:
name|lang_mark_tree
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Mark all the elements of the varray V, which contains rtxs.  */
end_comment

begin_function
name|void
name|ggc_mark_rtx_varray
parameter_list|(
name|v
parameter_list|)
name|varray_type
name|v
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|v
condition|)
for|for
control|(
name|i
operator|=
name|v
operator|->
name|num_elements
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
name|ggc_mark_rtx
argument_list|(
name|VARRAY_RTX
argument_list|(
name|v
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Mark all the elements of the varray V, which contains trees.  */
end_comment

begin_function
name|void
name|ggc_mark_tree_varray
parameter_list|(
name|v
parameter_list|)
name|varray_type
name|v
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|v
condition|)
for|for
control|(
name|i
operator|=
name|v
operator|->
name|num_elements
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
name|ggc_mark_tree
argument_list|(
name|VARRAY_TREE
argument_list|(
name|v
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Mark the hash table-entry HE.  Its key field is really a tree.  */
end_comment

begin_function
specifier|static
name|bool
name|ggc_mark_tree_hash_table_entry
parameter_list|(
name|he
parameter_list|,
name|k
parameter_list|)
name|struct
name|hash_entry
modifier|*
name|he
decl_stmt|;
name|hash_table_key
name|k
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|ggc_mark_tree
argument_list|(
operator|(
name|tree
operator|)
name|he
operator|->
name|key
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Mark all the elements of the hash-table H, which contains trees.  */
end_comment

begin_function
name|void
name|ggc_mark_tree_hash_table
parameter_list|(
name|ht
parameter_list|)
name|struct
name|hash_table
modifier|*
name|ht
decl_stmt|;
block|{
name|hash_traverse
argument_list|(
name|ht
argument_list|,
name|ggc_mark_tree_hash_table_entry
argument_list|,
comment|/*info=*/
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Type-correct function to pass to ggc_add_root.  It just forwards    *ELT (which is an rtx) to ggc_mark_rtx.  */
end_comment

begin_function
specifier|static
name|void
name|ggc_mark_rtx_ptr
parameter_list|(
name|elt
parameter_list|)
name|void
modifier|*
name|elt
decl_stmt|;
block|{
name|ggc_mark_rtx
argument_list|(
operator|*
operator|(
name|rtx
operator|*
operator|)
name|elt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Type-correct function to pass to ggc_add_root.  It just forwards    *ELT (which is a tree) to ggc_mark_tree.  */
end_comment

begin_function
specifier|static
name|void
name|ggc_mark_tree_ptr
parameter_list|(
name|elt
parameter_list|)
name|void
modifier|*
name|elt
decl_stmt|;
block|{
name|ggc_mark_tree
argument_list|(
operator|*
operator|(
name|tree
operator|*
operator|)
name|elt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Type-correct function to pass to ggc_add_root.  It just forwards    ELT (which is really a varray_type *) to ggc_mark_rtx_varray.  */
end_comment

begin_function
specifier|static
name|void
name|ggc_mark_rtx_varray_ptr
parameter_list|(
name|elt
parameter_list|)
name|void
modifier|*
name|elt
decl_stmt|;
block|{
name|ggc_mark_rtx_varray
argument_list|(
operator|*
operator|(
name|varray_type
operator|*
operator|)
name|elt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Type-correct function to pass to ggc_add_root.  It just forwards    ELT (which is really a varray_type *) to ggc_mark_tree_varray.  */
end_comment

begin_function
specifier|static
name|void
name|ggc_mark_tree_varray_ptr
parameter_list|(
name|elt
parameter_list|)
name|void
modifier|*
name|elt
decl_stmt|;
block|{
name|ggc_mark_tree_varray
argument_list|(
operator|*
operator|(
name|varray_type
operator|*
operator|)
name|elt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Type-correct function to pass to ggc_add_root.  It just forwards    ELT (which is really a struct hash_table **) to    ggc_mark_tree_hash_table.  */
end_comment

begin_function
specifier|static
name|void
name|ggc_mark_tree_hash_table_ptr
parameter_list|(
name|elt
parameter_list|)
name|void
modifier|*
name|elt
decl_stmt|;
block|{
name|ggc_mark_tree_hash_table
argument_list|(
operator|*
operator|(
expr|struct
name|hash_table
operator|*
operator|*
operator|)
name|elt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocate a block of memory, then clear it.  */
end_comment

begin_function
name|void
modifier|*
name|ggc_alloc_cleared
parameter_list|(
name|size
parameter_list|)
name|size_t
name|size
decl_stmt|;
block|{
name|void
modifier|*
name|buf
init|=
name|ggc_alloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/* Print statistics that are independent of the collector in use.  */
end_comment

begin_define
define|#
directive|define
name|SCALE
parameter_list|(
name|x
parameter_list|)
value|((unsigned long) ((x)< 1024*10 \ 		  ? (x) \ 		  : ((x)< 1024*1024*10 \ 		     ? (x) / 1024 \ 		     : (x) / (1024*1024))))
end_define

begin_define
define|#
directive|define
name|LABEL
parameter_list|(
name|x
parameter_list|)
value|((x)< 1024*10 ? ' ' : ((x)< 1024*1024*10 ? 'k' : 'M'))
end_define

begin_function
name|void
name|ggc_print_common_statistics
parameter_list|(
name|stream
parameter_list|,
name|stats
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|ggc_statistics
modifier|*
name|stats
decl_stmt|;
block|{
name|int
name|code
decl_stmt|;
comment|/* Set the pointer so that during collection we will actually gather      the statistics.  */
name|ggc_stats
operator|=
name|stats
expr_stmt|;
comment|/* Then do one collection to fill in the statistics.  */
name|ggc_collect
argument_list|()
expr_stmt|;
comment|/* Total the statistics.  */
for|for
control|(
name|code
operator|=
literal|0
init|;
name|code
operator|<
name|MAX_TREE_CODES
condition|;
operator|++
name|code
control|)
block|{
name|stats
operator|->
name|total_num_trees
operator|+=
name|stats
operator|->
name|num_trees
index|[
name|code
index|]
expr_stmt|;
name|stats
operator|->
name|total_size_trees
operator|+=
name|stats
operator|->
name|size_trees
index|[
name|code
index|]
expr_stmt|;
block|}
for|for
control|(
name|code
operator|=
literal|0
init|;
name|code
operator|<
name|NUM_RTX_CODE
condition|;
operator|++
name|code
control|)
block|{
name|stats
operator|->
name|total_num_rtxs
operator|+=
name|stats
operator|->
name|num_rtxs
index|[
name|code
index|]
expr_stmt|;
name|stats
operator|->
name|total_size_rtxs
operator|+=
name|stats
operator|->
name|size_rtxs
index|[
name|code
index|]
expr_stmt|;
block|}
comment|/* Print the statistics for trees.  */
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\n%-17s%10s %16s %10s\n"
argument_list|,
literal|"Tree"
argument_list|,
literal|"Number"
argument_list|,
literal|"Bytes"
argument_list|,
literal|"% Total"
argument_list|)
expr_stmt|;
for|for
control|(
name|code
operator|=
literal|0
init|;
name|code
operator|<
name|MAX_TREE_CODES
condition|;
operator|++
name|code
control|)
if|if
condition|(
name|ggc_stats
operator|->
name|num_trees
index|[
name|code
index|]
condition|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%-17s%10u%16ld%c %10.3f\n"
argument_list|,
name|tree_code_name
index|[
name|code
index|]
argument_list|,
name|ggc_stats
operator|->
name|num_trees
index|[
name|code
index|]
argument_list|,
name|SCALE
argument_list|(
name|ggc_stats
operator|->
name|size_trees
index|[
name|code
index|]
argument_list|)
argument_list|,
name|LABEL
argument_list|(
name|ggc_stats
operator|->
name|size_trees
index|[
name|code
index|]
argument_list|)
argument_list|,
operator|(
literal|100
operator|*
operator|(
operator|(
name|double
operator|)
name|ggc_stats
operator|->
name|size_trees
index|[
name|code
index|]
operator|)
operator|/
name|ggc_stats
operator|->
name|total_size_trees
operator|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%-17s%10u%16ld%c\n"
argument_list|,
literal|"Total"
argument_list|,
name|ggc_stats
operator|->
name|total_num_trees
argument_list|,
name|SCALE
argument_list|(
name|ggc_stats
operator|->
name|total_size_trees
argument_list|)
argument_list|,
name|LABEL
argument_list|(
name|ggc_stats
operator|->
name|total_size_trees
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Print the statistics for RTL.  */
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\n%-17s%10s %16s %10s\n"
argument_list|,
literal|"RTX"
argument_list|,
literal|"Number"
argument_list|,
literal|"Bytes"
argument_list|,
literal|"% Total"
argument_list|)
expr_stmt|;
for|for
control|(
name|code
operator|=
literal|0
init|;
name|code
operator|<
name|NUM_RTX_CODE
condition|;
operator|++
name|code
control|)
if|if
condition|(
name|ggc_stats
operator|->
name|num_rtxs
index|[
name|code
index|]
condition|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%-17s%10u%16ld%c %10.3f\n"
argument_list|,
name|rtx_name
index|[
name|code
index|]
argument_list|,
name|ggc_stats
operator|->
name|num_rtxs
index|[
name|code
index|]
argument_list|,
name|SCALE
argument_list|(
name|ggc_stats
operator|->
name|size_rtxs
index|[
name|code
index|]
argument_list|)
argument_list|,
name|LABEL
argument_list|(
name|ggc_stats
operator|->
name|size_rtxs
index|[
name|code
index|]
argument_list|)
argument_list|,
operator|(
literal|100
operator|*
operator|(
operator|(
name|double
operator|)
name|ggc_stats
operator|->
name|size_rtxs
index|[
name|code
index|]
operator|)
operator|/
name|ggc_stats
operator|->
name|total_size_rtxs
operator|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%-17s%10u%16ld%c\n"
argument_list|,
literal|"Total"
argument_list|,
name|ggc_stats
operator|->
name|total_num_rtxs
argument_list|,
name|SCALE
argument_list|(
name|ggc_stats
operator|->
name|total_size_rtxs
argument_list|)
argument_list|,
name|LABEL
argument_list|(
name|ggc_stats
operator|->
name|total_size_rtxs
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Don't gather statistics any more.  */
name|ggc_stats
operator|=
name|NULL
expr_stmt|;
block|}
end_function

end_unit

