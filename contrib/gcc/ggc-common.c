begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Simple garbage collection for the GNU compiler.    Copyright (C) 1999, 2000, 2001, 2002, 2003    Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Generic garbage collection (GC) functions and data, not specific to    any particular GC implementation.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_include
include|#
directive|include
file|"hosthooks.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_RESOURCE_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_MMAP_FILE
end_ifdef

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_MINCORE
end_ifdef

begin_comment
comment|/* This is on Solaris.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MAP_FAILED
end_ifndef

begin_define
define|#
directive|define
name|MAP_FAILED
value|((void *)-1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ENABLE_VALGRIND_CHECKING
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_VALGRIND_MEMCHECK_H
end_ifdef

begin_include
include|#
directive|include
file|<valgrind/memcheck.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
name|HAVE_MEMCHECK_H
end_elif

begin_include
include|#
directive|include
file|<memcheck.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<valgrind.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Avoid #ifdef:s when we can help it.  */
end_comment

begin_define
define|#
directive|define
name|VALGRIND_DISCARD
parameter_list|(
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Statistics about the allocation.  */
end_comment

begin_decl_stmt
specifier|static
name|ggc_statistics
modifier|*
name|ggc_stats
decl_stmt|;
end_decl_stmt

begin_struct_decl
struct_decl|struct
name|traversal_state
struct_decl|;
end_struct_decl

begin_function_decl
specifier|static
name|int
name|ggc_htab_delete
parameter_list|(
name|void
modifier|*
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|hashval_t
name|saving_htab_hash
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|saving_htab_eq
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|call_count
parameter_list|(
name|void
modifier|*
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|call_alloc
parameter_list|(
name|void
modifier|*
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|compare_ptr_data
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|relocate_ptrs
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_pch_globals
parameter_list|(
specifier|const
name|struct
name|ggc_root_tab
modifier|*
specifier|const
modifier|*
name|tab
parameter_list|,
name|struct
name|traversal_state
modifier|*
name|state
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|double
name|ggc_rlimit_bound
parameter_list|(
name|double
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Maintain global roots that are preserved during GC.  */
end_comment

begin_comment
comment|/* Process a slot of an htab by deleting it if it has not been marked.  */
end_comment

begin_function
specifier|static
name|int
name|ggc_htab_delete
parameter_list|(
name|void
modifier|*
modifier|*
name|slot
parameter_list|,
name|void
modifier|*
name|info
parameter_list|)
block|{
specifier|const
name|struct
name|ggc_cache_tab
modifier|*
name|r
init|=
operator|(
specifier|const
expr|struct
name|ggc_cache_tab
operator|*
operator|)
name|info
decl_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|r
operator|->
name|marked_p
call|)
argument_list|(
operator|*
name|slot
argument_list|)
condition|)
name|htab_clear_slot
argument_list|(
operator|*
name|r
operator|->
name|base
argument_list|,
name|slot
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|r
operator|->
name|cb
call|)
argument_list|(
operator|*
name|slot
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Iterate through all registered roots and mark each element.  */
end_comment

begin_function
name|void
name|ggc_mark_roots
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|struct
name|ggc_root_tab
modifier|*
specifier|const
modifier|*
name|rt
decl_stmt|;
specifier|const
name|struct
name|ggc_root_tab
modifier|*
name|rti
decl_stmt|;
specifier|const
name|struct
name|ggc_cache_tab
modifier|*
specifier|const
modifier|*
name|ct
decl_stmt|;
specifier|const
name|struct
name|ggc_cache_tab
modifier|*
name|cti
decl_stmt|;
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|rt
operator|=
name|gt_ggc_deletable_rtab
init|;
operator|*
name|rt
condition|;
name|rt
operator|++
control|)
for|for
control|(
name|rti
operator|=
operator|*
name|rt
init|;
name|rti
operator|->
name|base
operator|!=
name|NULL
condition|;
name|rti
operator|++
control|)
name|memset
argument_list|(
name|rti
operator|->
name|base
argument_list|,
literal|0
argument_list|,
name|rti
operator|->
name|stride
argument_list|)
expr_stmt|;
for|for
control|(
name|rt
operator|=
name|gt_ggc_rtab
init|;
operator|*
name|rt
condition|;
name|rt
operator|++
control|)
for|for
control|(
name|rti
operator|=
operator|*
name|rt
init|;
name|rti
operator|->
name|base
operator|!=
name|NULL
condition|;
name|rti
operator|++
control|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rti
operator|->
name|nelt
condition|;
name|i
operator|++
control|)
call|(
modifier|*
name|rti
operator|->
name|cb
call|)
argument_list|(
operator|*
operator|(
name|void
operator|*
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|rti
operator|->
name|base
operator|+
name|rti
operator|->
name|stride
operator|*
name|i
operator|)
argument_list|)
expr_stmt|;
name|ggc_mark_stringpool
argument_list|()
expr_stmt|;
comment|/* Now scan all hash tables that have objects which are to be deleted if      they are not already marked.  */
for|for
control|(
name|ct
operator|=
name|gt_ggc_cache_rtab
init|;
operator|*
name|ct
condition|;
name|ct
operator|++
control|)
for|for
control|(
name|cti
operator|=
operator|*
name|ct
init|;
name|cti
operator|->
name|base
operator|!=
name|NULL
condition|;
name|cti
operator|++
control|)
if|if
condition|(
operator|*
name|cti
operator|->
name|base
condition|)
block|{
name|ggc_set_mark
argument_list|(
operator|*
name|cti
operator|->
name|base
argument_list|)
expr_stmt|;
name|htab_traverse_noresize
argument_list|(
operator|*
name|cti
operator|->
name|base
argument_list|,
name|ggc_htab_delete
argument_list|,
operator|(
name|void
operator|*
operator|)
name|cti
argument_list|)
expr_stmt|;
name|ggc_set_mark
argument_list|(
operator|(
operator|*
name|cti
operator|->
name|base
operator|)
operator|->
name|entries
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Allocate a block of memory, then clear it.  */
end_comment

begin_function
name|void
modifier|*
name|ggc_alloc_cleared
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|buf
init|=
name|ggc_alloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/* Resize a block of memory, possibly re-allocating it.  */
end_comment

begin_function
name|void
modifier|*
name|ggc_realloc
parameter_list|(
name|void
modifier|*
name|x
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|r
decl_stmt|;
name|size_t
name|old_size
decl_stmt|;
if|if
condition|(
name|x
operator|==
name|NULL
condition|)
return|return
name|ggc_alloc
argument_list|(
name|size
argument_list|)
return|;
name|old_size
operator|=
name|ggc_get_size
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<=
name|old_size
condition|)
block|{
comment|/* Mark the unwanted memory as unaccessible.  We also need to make 	 the "new" size accessible, since ggc_get_size returns the size of 	 the pool, not the size of the individually allocated object, the 	 size which was previously made accessible.  Unfortunately, we 	 don't know that previously allocated size.  Without that 	 knowledge we have to lose some initialization-tracking for the 	 old parts of the object.  An alternative is to mark the whole 	 old_size as reachable, but that would lose tracking of writes 	 after the end of the object (by small offsets).  Discard the 	 handle to avoid handle leak.  */
name|VALGRIND_DISCARD
argument_list|(
name|VALGRIND_MAKE_NOACCESS
argument_list|(
operator|(
name|char
operator|*
operator|)
name|x
operator|+
name|size
argument_list|,
name|old_size
operator|-
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|VALGRIND_DISCARD
argument_list|(
name|VALGRIND_MAKE_READABLE
argument_list|(
name|x
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
name|r
operator|=
name|ggc_alloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
comment|/* Since ggc_get_size returns the size of the pool, not the size of the      individually allocated object, we'd access parts of the old object      that were marked invalid with the memcpy below.  We lose a bit of the      initialization-tracking since some of it may be uninitialized.  */
name|VALGRIND_DISCARD
argument_list|(
name|VALGRIND_MAKE_READABLE
argument_list|(
name|x
argument_list|,
name|old_size
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|r
argument_list|,
name|x
argument_list|,
name|old_size
argument_list|)
expr_stmt|;
comment|/* The old object is not supposed to be used anymore.  */
name|VALGRIND_DISCARD
argument_list|(
name|VALGRIND_MAKE_NOACCESS
argument_list|(
name|x
argument_list|,
name|old_size
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Like ggc_alloc_cleared, but performs a multiplication.  */
end_comment

begin_function
name|void
modifier|*
name|ggc_calloc
parameter_list|(
name|size_t
name|s1
parameter_list|,
name|size_t
name|s2
parameter_list|)
block|{
return|return
name|ggc_alloc_cleared
argument_list|(
name|s1
operator|*
name|s2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* These are for splay_tree_new_ggc.  */
end_comment

begin_function
name|void
modifier|*
name|ggc_splay_alloc
parameter_list|(
name|int
name|sz
parameter_list|,
name|void
modifier|*
name|nl
parameter_list|)
block|{
if|if
condition|(
name|nl
operator|!=
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|ggc_alloc
argument_list|(
name|sz
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|ggc_splay_dont_free
parameter_list|(
name|void
modifier|*
name|x
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|nl
parameter_list|)
block|{
if|if
condition|(
name|nl
operator|!=
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print statistics that are independent of the collector in use.  */
end_comment

begin_define
define|#
directive|define
name|SCALE
parameter_list|(
name|x
parameter_list|)
value|((unsigned long) ((x)< 1024*10 \ 		  ? (x) \ 		  : ((x)< 1024*1024*10 \ 		     ? (x) / 1024 \ 		     : (x) / (1024*1024))))
end_define

begin_define
define|#
directive|define
name|LABEL
parameter_list|(
name|x
parameter_list|)
value|((x)< 1024*10 ? ' ' : ((x)< 1024*1024*10 ? 'k' : 'M'))
end_define

begin_function
name|void
name|ggc_print_common_statistics
parameter_list|(
name|FILE
modifier|*
name|stream
name|ATTRIBUTE_UNUSED
parameter_list|,
name|ggc_statistics
modifier|*
name|stats
parameter_list|)
block|{
comment|/* Set the pointer so that during collection we will actually gather      the statistics.  */
name|ggc_stats
operator|=
name|stats
expr_stmt|;
comment|/* Then do one collection to fill in the statistics.  */
name|ggc_collect
argument_list|()
expr_stmt|;
comment|/* At present, we don't really gather any interesting statistics.  */
comment|/* Don't gather statistics any more.  */
name|ggc_stats
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Functions for saving and restoring GCable memory to disk.  */
end_comment

begin_decl_stmt
specifier|static
name|htab_t
name|saving_htab
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|ptr_data
block|{
name|void
modifier|*
name|obj
decl_stmt|;
name|void
modifier|*
name|note_ptr_cookie
decl_stmt|;
name|gt_note_pointers
name|note_ptr_fn
decl_stmt|;
name|gt_handle_reorder
name|reorder_fn
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|void
modifier|*
name|new_addr
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|POINTER_HASH
parameter_list|(
name|x
parameter_list|)
value|(hashval_t)((long)x>> 3)
end_define

begin_comment
comment|/* Register an object in the hash table.  */
end_comment

begin_function
name|int
name|gt_pch_note_object
parameter_list|(
name|void
modifier|*
name|obj
parameter_list|,
name|void
modifier|*
name|note_ptr_cookie
parameter_list|,
name|gt_note_pointers
name|note_ptr_fn
parameter_list|)
block|{
name|struct
name|ptr_data
modifier|*
modifier|*
name|slot
decl_stmt|;
if|if
condition|(
name|obj
operator|==
name|NULL
operator|||
name|obj
operator|==
operator|(
name|void
operator|*
operator|)
literal|1
condition|)
return|return
literal|0
return|;
name|slot
operator|=
operator|(
expr|struct
name|ptr_data
operator|*
operator|*
operator|)
name|htab_find_slot_with_hash
argument_list|(
name|saving_htab
argument_list|,
name|obj
argument_list|,
name|POINTER_HASH
argument_list|(
name|obj
argument_list|)
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|slot
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|slot
operator|)
operator|->
name|note_ptr_fn
operator|!=
name|note_ptr_fn
operator|||
operator|(
operator|*
name|slot
operator|)
operator|->
name|note_ptr_cookie
operator|!=
name|note_ptr_cookie
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|slot
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ptr_data
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
operator|*
name|slot
operator|)
operator|->
name|obj
operator|=
name|obj
expr_stmt|;
operator|(
operator|*
name|slot
operator|)
operator|->
name|note_ptr_fn
operator|=
name|note_ptr_fn
expr_stmt|;
operator|(
operator|*
name|slot
operator|)
operator|->
name|note_ptr_cookie
operator|=
name|note_ptr_cookie
expr_stmt|;
if|if
condition|(
name|note_ptr_fn
operator|==
name|gt_pch_p_S
condition|)
operator|(
operator|*
name|slot
operator|)
operator|->
name|size
operator|=
name|strlen
argument_list|(
name|obj
argument_list|)
operator|+
literal|1
expr_stmt|;
else|else
operator|(
operator|*
name|slot
operator|)
operator|->
name|size
operator|=
name|ggc_get_size
argument_list|(
name|obj
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Register an object in the hash table.  */
end_comment

begin_function
name|void
name|gt_pch_note_reorder
parameter_list|(
name|void
modifier|*
name|obj
parameter_list|,
name|void
modifier|*
name|note_ptr_cookie
parameter_list|,
name|gt_handle_reorder
name|reorder_fn
parameter_list|)
block|{
name|struct
name|ptr_data
modifier|*
name|data
decl_stmt|;
if|if
condition|(
name|obj
operator|==
name|NULL
operator|||
name|obj
operator|==
operator|(
name|void
operator|*
operator|)
literal|1
condition|)
return|return;
name|data
operator|=
name|htab_find_with_hash
argument_list|(
name|saving_htab
argument_list|,
name|obj
argument_list|,
name|POINTER_HASH
argument_list|(
name|obj
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
operator|||
name|data
operator|->
name|note_ptr_cookie
operator|!=
name|note_ptr_cookie
condition|)
name|abort
argument_list|()
expr_stmt|;
name|data
operator|->
name|reorder_fn
operator|=
name|reorder_fn
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Hash and equality functions for saving_htab, callbacks for htab_create.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|saving_htab_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
return|return
name|POINTER_HASH
argument_list|(
operator|(
operator|(
expr|struct
name|ptr_data
operator|*
operator|)
name|p
operator|)
operator|->
name|obj
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|saving_htab_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|p1
parameter_list|,
specifier|const
name|void
modifier|*
name|p2
parameter_list|)
block|{
return|return
operator|(
operator|(
expr|struct
name|ptr_data
operator|*
operator|)
name|p1
operator|)
operator|->
name|obj
operator|==
name|p2
return|;
block|}
end_function

begin_comment
comment|/* Handy state for the traversal functions.  */
end_comment

begin_struct
struct|struct
name|traversal_state
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|struct
name|ggc_pch_data
modifier|*
name|d
decl_stmt|;
name|size_t
name|count
decl_stmt|;
name|struct
name|ptr_data
modifier|*
modifier|*
name|ptrs
decl_stmt|;
name|size_t
name|ptrs_i
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Callbacks for htab_traverse.  */
end_comment

begin_function
specifier|static
name|int
name|call_count
parameter_list|(
name|void
modifier|*
modifier|*
name|slot
parameter_list|,
name|void
modifier|*
name|state_p
parameter_list|)
block|{
name|struct
name|ptr_data
modifier|*
name|d
init|=
operator|(
expr|struct
name|ptr_data
operator|*
operator|)
operator|*
name|slot
decl_stmt|;
name|struct
name|traversal_state
modifier|*
name|state
init|=
operator|(
expr|struct
name|traversal_state
operator|*
operator|)
name|state_p
decl_stmt|;
name|ggc_pch_count_object
argument_list|(
name|state
operator|->
name|d
argument_list|,
name|d
operator|->
name|obj
argument_list|,
name|d
operator|->
name|size
argument_list|,
name|d
operator|->
name|note_ptr_fn
operator|==
name|gt_pch_p_S
argument_list|)
expr_stmt|;
name|state
operator|->
name|count
operator|++
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|call_alloc
parameter_list|(
name|void
modifier|*
modifier|*
name|slot
parameter_list|,
name|void
modifier|*
name|state_p
parameter_list|)
block|{
name|struct
name|ptr_data
modifier|*
name|d
init|=
operator|(
expr|struct
name|ptr_data
operator|*
operator|)
operator|*
name|slot
decl_stmt|;
name|struct
name|traversal_state
modifier|*
name|state
init|=
operator|(
expr|struct
name|traversal_state
operator|*
operator|)
name|state_p
decl_stmt|;
name|d
operator|->
name|new_addr
operator|=
name|ggc_pch_alloc_object
argument_list|(
name|state
operator|->
name|d
argument_list|,
name|d
operator|->
name|obj
argument_list|,
name|d
operator|->
name|size
argument_list|,
name|d
operator|->
name|note_ptr_fn
operator|==
name|gt_pch_p_S
argument_list|)
expr_stmt|;
name|state
operator|->
name|ptrs
index|[
name|state
operator|->
name|ptrs_i
operator|++
index|]
operator|=
name|d
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Callback for qsort.  */
end_comment

begin_function
specifier|static
name|int
name|compare_ptr_data
parameter_list|(
specifier|const
name|void
modifier|*
name|p1_p
parameter_list|,
specifier|const
name|void
modifier|*
name|p2_p
parameter_list|)
block|{
name|struct
name|ptr_data
modifier|*
name|p1
init|=
operator|*
operator|(
expr|struct
name|ptr_data
operator|*
specifier|const
operator|*
operator|)
name|p1_p
decl_stmt|;
name|struct
name|ptr_data
modifier|*
name|p2
init|=
operator|*
operator|(
expr|struct
name|ptr_data
operator|*
specifier|const
operator|*
operator|)
name|p2_p
decl_stmt|;
return|return
operator|(
operator|(
operator|(
name|size_t
operator|)
name|p1
operator|->
name|new_addr
operator|>
operator|(
name|size_t
operator|)
name|p2
operator|->
name|new_addr
operator|)
operator|-
operator|(
operator|(
name|size_t
operator|)
name|p1
operator|->
name|new_addr
operator|<
operator|(
name|size_t
operator|)
name|p2
operator|->
name|new_addr
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Callbacks for note_ptr_fn.  */
end_comment

begin_function
specifier|static
name|void
name|relocate_ptrs
parameter_list|(
name|void
modifier|*
name|ptr_p
parameter_list|,
name|void
modifier|*
name|state_p
parameter_list|)
block|{
name|void
modifier|*
modifier|*
name|ptr
init|=
operator|(
name|void
operator|*
operator|*
operator|)
name|ptr_p
decl_stmt|;
name|struct
name|traversal_state
modifier|*
name|state
name|ATTRIBUTE_UNUSED
init|=
operator|(
expr|struct
name|traversal_state
operator|*
operator|)
name|state_p
decl_stmt|;
name|struct
name|ptr_data
modifier|*
name|result
decl_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|==
name|NULL
operator|||
operator|*
name|ptr
operator|==
operator|(
name|void
operator|*
operator|)
literal|1
condition|)
return|return;
name|result
operator|=
name|htab_find_with_hash
argument_list|(
name|saving_htab
argument_list|,
operator|*
name|ptr
argument_list|,
name|POINTER_HASH
argument_list|(
operator|*
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
operator|*
name|ptr
operator|=
name|result
operator|->
name|new_addr
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write out, after relocation, the pointers in TAB.  */
end_comment

begin_function
specifier|static
name|void
name|write_pch_globals
parameter_list|(
specifier|const
name|struct
name|ggc_root_tab
modifier|*
specifier|const
modifier|*
name|tab
parameter_list|,
name|struct
name|traversal_state
modifier|*
name|state
parameter_list|)
block|{
specifier|const
name|struct
name|ggc_root_tab
modifier|*
specifier|const
modifier|*
name|rt
decl_stmt|;
specifier|const
name|struct
name|ggc_root_tab
modifier|*
name|rti
decl_stmt|;
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|rt
operator|=
name|tab
init|;
operator|*
name|rt
condition|;
name|rt
operator|++
control|)
for|for
control|(
name|rti
operator|=
operator|*
name|rt
init|;
name|rti
operator|->
name|base
operator|!=
name|NULL
condition|;
name|rti
operator|++
control|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rti
operator|->
name|nelt
condition|;
name|i
operator|++
control|)
block|{
name|void
modifier|*
name|ptr
init|=
operator|*
operator|(
name|void
operator|*
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|rti
operator|->
name|base
operator|+
name|rti
operator|->
name|stride
operator|*
name|i
operator|)
decl_stmt|;
name|struct
name|ptr_data
modifier|*
name|new_ptr
decl_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
operator|||
name|ptr
operator|==
operator|(
name|void
operator|*
operator|)
literal|1
condition|)
block|{
if|if
condition|(
name|fwrite
argument_list|(
operator|&
name|ptr
argument_list|,
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|,
literal|1
argument_list|,
name|state
operator|->
name|f
argument_list|)
operator|!=
literal|1
condition|)
name|fatal_error
argument_list|(
literal|"can't write PCH file: %m"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|new_ptr
operator|=
name|htab_find_with_hash
argument_list|(
name|saving_htab
argument_list|,
name|ptr
argument_list|,
name|POINTER_HASH
argument_list|(
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fwrite
argument_list|(
operator|&
name|new_ptr
operator|->
name|new_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|,
literal|1
argument_list|,
name|state
operator|->
name|f
argument_list|)
operator|!=
literal|1
condition|)
name|fatal_error
argument_list|(
literal|"can't write PCH file: %m"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Hold the information we need to mmap the file back in.  */
end_comment

begin_struct
struct|struct
name|mmap_info
block|{
name|size_t
name|offset
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|void
modifier|*
name|preferred_base
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Write out the state of the compiler to F.  */
end_comment

begin_function
name|void
name|gt_pch_save
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|)
block|{
specifier|const
name|struct
name|ggc_root_tab
modifier|*
specifier|const
modifier|*
name|rt
decl_stmt|;
specifier|const
name|struct
name|ggc_root_tab
modifier|*
name|rti
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|struct
name|traversal_state
name|state
decl_stmt|;
name|char
modifier|*
name|this_object
init|=
name|NULL
decl_stmt|;
name|size_t
name|this_object_size
init|=
literal|0
decl_stmt|;
name|struct
name|mmap_info
name|mmi
decl_stmt|;
name|size_t
name|page_size
init|=
name|getpagesize
argument_list|()
decl_stmt|;
name|gt_pch_save_stringpool
argument_list|()
expr_stmt|;
name|saving_htab
operator|=
name|htab_create
argument_list|(
literal|50000
argument_list|,
name|saving_htab_hash
argument_list|,
name|saving_htab_eq
argument_list|,
name|free
argument_list|)
expr_stmt|;
for|for
control|(
name|rt
operator|=
name|gt_ggc_rtab
init|;
operator|*
name|rt
condition|;
name|rt
operator|++
control|)
for|for
control|(
name|rti
operator|=
operator|*
name|rt
init|;
name|rti
operator|->
name|base
operator|!=
name|NULL
condition|;
name|rti
operator|++
control|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rti
operator|->
name|nelt
condition|;
name|i
operator|++
control|)
call|(
modifier|*
name|rti
operator|->
name|pchw
call|)
argument_list|(
operator|*
operator|(
name|void
operator|*
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|rti
operator|->
name|base
operator|+
name|rti
operator|->
name|stride
operator|*
name|i
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|rt
operator|=
name|gt_pch_cache_rtab
init|;
operator|*
name|rt
condition|;
name|rt
operator|++
control|)
for|for
control|(
name|rti
operator|=
operator|*
name|rt
init|;
name|rti
operator|->
name|base
operator|!=
name|NULL
condition|;
name|rti
operator|++
control|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rti
operator|->
name|nelt
condition|;
name|i
operator|++
control|)
call|(
modifier|*
name|rti
operator|->
name|pchw
call|)
argument_list|(
operator|*
operator|(
name|void
operator|*
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|rti
operator|->
name|base
operator|+
name|rti
operator|->
name|stride
operator|*
name|i
operator|)
argument_list|)
expr_stmt|;
comment|/* Prepare the objects for writing, determine addresses and such.  */
name|state
operator|.
name|f
operator|=
name|f
expr_stmt|;
name|state
operator|.
name|d
operator|=
name|init_ggc_pch
argument_list|()
expr_stmt|;
name|state
operator|.
name|count
operator|=
literal|0
expr_stmt|;
name|htab_traverse
argument_list|(
name|saving_htab
argument_list|,
name|call_count
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
name|mmi
operator|.
name|size
operator|=
name|ggc_pch_total_size
argument_list|(
name|state
operator|.
name|d
argument_list|)
expr_stmt|;
comment|/* Try to arrange things so that no relocation is necessary, but      don't try very hard.  On most platforms, this will always work,      and on the rest it's a lot of work to do better.        (The extra work goes in HOST_HOOKS_GT_PCH_GET_ADDRESS and      HOST_HOOKS_GT_PCH_USE_ADDRESS.)  */
name|mmi
operator|.
name|preferred_base
operator|=
name|host_hooks
operator|.
name|gt_pch_get_address
argument_list|(
name|mmi
operator|.
name|size
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_MMAP_FILE
if|if
condition|(
name|mmi
operator|.
name|preferred_base
operator|==
name|NULL
condition|)
block|{
name|mmi
operator|.
name|preferred_base
operator|=
name|mmap
argument_list|(
name|NULL
argument_list|,
name|mmi
operator|.
name|size
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_PRIVATE
argument_list|,
name|fileno
argument_list|(
name|state
operator|.
name|f
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mmi
operator|.
name|preferred_base
operator|==
operator|(
name|void
operator|*
operator|)
name|MAP_FAILED
condition|)
name|mmi
operator|.
name|preferred_base
operator|=
name|NULL
expr_stmt|;
else|else
name|munmap
argument_list|(
name|mmi
operator|.
name|preferred_base
argument_list|,
name|mmi
operator|.
name|size
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAVE_MMAP_FILE */
name|ggc_pch_this_base
argument_list|(
name|state
operator|.
name|d
argument_list|,
name|mmi
operator|.
name|preferred_base
argument_list|)
expr_stmt|;
name|state
operator|.
name|ptrs
operator|=
name|xmalloc
argument_list|(
name|state
operator|.
name|count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|state
operator|.
name|ptrs
argument_list|)
argument_list|)
expr_stmt|;
name|state
operator|.
name|ptrs_i
operator|=
literal|0
expr_stmt|;
name|htab_traverse
argument_list|(
name|saving_htab
argument_list|,
name|call_alloc
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|state
operator|.
name|ptrs
argument_list|,
name|state
operator|.
name|count
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|state
operator|.
name|ptrs
argument_list|)
argument_list|,
name|compare_ptr_data
argument_list|)
expr_stmt|;
comment|/* Write out all the scalar variables.  */
for|for
control|(
name|rt
operator|=
name|gt_pch_scalar_rtab
init|;
operator|*
name|rt
condition|;
name|rt
operator|++
control|)
for|for
control|(
name|rti
operator|=
operator|*
name|rt
init|;
name|rti
operator|->
name|base
operator|!=
name|NULL
condition|;
name|rti
operator|++
control|)
if|if
condition|(
name|fwrite
argument_list|(
name|rti
operator|->
name|base
argument_list|,
name|rti
operator|->
name|stride
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|!=
literal|1
condition|)
name|fatal_error
argument_list|(
literal|"can't write PCH file: %m"
argument_list|)
expr_stmt|;
comment|/* Write out all the global pointers, after translation.  */
name|write_pch_globals
argument_list|(
name|gt_ggc_rtab
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
name|write_pch_globals
argument_list|(
name|gt_pch_cache_rtab
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
name|ggc_pch_prepare_write
argument_list|(
name|state
operator|.
name|d
argument_list|,
name|state
operator|.
name|f
argument_list|)
expr_stmt|;
comment|/* Pad the PCH file so that the mmapped area starts on a page boundary.  */
block|{
name|long
name|o
decl_stmt|;
name|o
operator|=
name|ftell
argument_list|(
name|state
operator|.
name|f
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|mmi
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|==
operator|-
literal|1
condition|)
name|fatal_error
argument_list|(
literal|"can't get position in PCH file: %m"
argument_list|)
expr_stmt|;
name|mmi
operator|.
name|offset
operator|=
name|page_size
operator|-
name|o
operator|%
name|page_size
expr_stmt|;
if|if
condition|(
name|mmi
operator|.
name|offset
operator|==
name|page_size
condition|)
name|mmi
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|mmi
operator|.
name|offset
operator|+=
name|o
expr_stmt|;
block|}
if|if
condition|(
name|fwrite
argument_list|(
operator|&
name|mmi
argument_list|,
sizeof|sizeof
argument_list|(
name|mmi
argument_list|)
argument_list|,
literal|1
argument_list|,
name|state
operator|.
name|f
argument_list|)
operator|!=
literal|1
condition|)
name|fatal_error
argument_list|(
literal|"can't write PCH file: %m"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mmi
operator|.
name|offset
operator|!=
literal|0
operator|&&
name|fseek
argument_list|(
name|state
operator|.
name|f
argument_list|,
name|mmi
operator|.
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
name|fatal_error
argument_list|(
literal|"can't write padding to PCH file: %m"
argument_list|)
expr_stmt|;
comment|/* Actually write out the objects.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|state
operator|.
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|this_object_size
operator|<
name|state
operator|.
name|ptrs
index|[
name|i
index|]
operator|->
name|size
condition|)
block|{
name|this_object_size
operator|=
name|state
operator|.
name|ptrs
index|[
name|i
index|]
operator|->
name|size
expr_stmt|;
name|this_object
operator|=
name|xrealloc
argument_list|(
name|this_object
argument_list|,
name|this_object_size
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|this_object
argument_list|,
name|state
operator|.
name|ptrs
index|[
name|i
index|]
operator|->
name|obj
argument_list|,
name|state
operator|.
name|ptrs
index|[
name|i
index|]
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|.
name|ptrs
index|[
name|i
index|]
operator|->
name|reorder_fn
operator|!=
name|NULL
condition|)
name|state
operator|.
name|ptrs
index|[
name|i
index|]
operator|->
name|reorder_fn
argument_list|(
name|state
operator|.
name|ptrs
index|[
name|i
index|]
operator|->
name|obj
argument_list|,
name|state
operator|.
name|ptrs
index|[
name|i
index|]
operator|->
name|note_ptr_cookie
argument_list|,
name|relocate_ptrs
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
name|state
operator|.
name|ptrs
index|[
name|i
index|]
operator|->
name|note_ptr_fn
argument_list|(
name|state
operator|.
name|ptrs
index|[
name|i
index|]
operator|->
name|obj
argument_list|,
name|state
operator|.
name|ptrs
index|[
name|i
index|]
operator|->
name|note_ptr_cookie
argument_list|,
name|relocate_ptrs
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
name|ggc_pch_write_object
argument_list|(
name|state
operator|.
name|d
argument_list|,
name|state
operator|.
name|f
argument_list|,
name|state
operator|.
name|ptrs
index|[
name|i
index|]
operator|->
name|obj
argument_list|,
name|state
operator|.
name|ptrs
index|[
name|i
index|]
operator|->
name|new_addr
argument_list|,
name|state
operator|.
name|ptrs
index|[
name|i
index|]
operator|->
name|size
argument_list|,
name|state
operator|.
name|ptrs
index|[
name|i
index|]
operator|->
name|note_ptr_fn
operator|==
name|gt_pch_p_S
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|.
name|ptrs
index|[
name|i
index|]
operator|->
name|note_ptr_fn
operator|!=
name|gt_pch_p_S
condition|)
name|memcpy
argument_list|(
name|state
operator|.
name|ptrs
index|[
name|i
index|]
operator|->
name|obj
argument_list|,
name|this_object
argument_list|,
name|state
operator|.
name|ptrs
index|[
name|i
index|]
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
name|ggc_pch_finish
argument_list|(
name|state
operator|.
name|d
argument_list|,
name|state
operator|.
name|f
argument_list|)
expr_stmt|;
name|gt_pch_fixup_stringpool
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|state
operator|.
name|ptrs
argument_list|)
expr_stmt|;
name|htab_delete
argument_list|(
name|saving_htab
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read the state of the compiler back in from F.  */
end_comment

begin_function
name|void
name|gt_pch_restore
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|)
block|{
specifier|const
name|struct
name|ggc_root_tab
modifier|*
specifier|const
modifier|*
name|rt
decl_stmt|;
specifier|const
name|struct
name|ggc_root_tab
modifier|*
name|rti
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|struct
name|mmap_info
name|mmi
decl_stmt|;
name|void
modifier|*
name|addr
decl_stmt|;
name|bool
name|needs_read
decl_stmt|;
comment|/* Delete any deletable objects.  This makes ggc_pch_read much      faster, as it can be sure that no GCable objects remain other      than the ones just read in.  */
for|for
control|(
name|rt
operator|=
name|gt_ggc_deletable_rtab
init|;
operator|*
name|rt
condition|;
name|rt
operator|++
control|)
for|for
control|(
name|rti
operator|=
operator|*
name|rt
init|;
name|rti
operator|->
name|base
operator|!=
name|NULL
condition|;
name|rti
operator|++
control|)
name|memset
argument_list|(
name|rti
operator|->
name|base
argument_list|,
literal|0
argument_list|,
name|rti
operator|->
name|stride
argument_list|)
expr_stmt|;
comment|/* Read in all the scalar variables.  */
for|for
control|(
name|rt
operator|=
name|gt_pch_scalar_rtab
init|;
operator|*
name|rt
condition|;
name|rt
operator|++
control|)
for|for
control|(
name|rti
operator|=
operator|*
name|rt
init|;
name|rti
operator|->
name|base
operator|!=
name|NULL
condition|;
name|rti
operator|++
control|)
if|if
condition|(
name|fread
argument_list|(
name|rti
operator|->
name|base
argument_list|,
name|rti
operator|->
name|stride
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|!=
literal|1
condition|)
name|fatal_error
argument_list|(
literal|"can't read PCH file: %m"
argument_list|)
expr_stmt|;
comment|/* Read in all the global pointers, in 6 easy loops.  */
for|for
control|(
name|rt
operator|=
name|gt_ggc_rtab
init|;
operator|*
name|rt
condition|;
name|rt
operator|++
control|)
for|for
control|(
name|rti
operator|=
operator|*
name|rt
init|;
name|rti
operator|->
name|base
operator|!=
name|NULL
condition|;
name|rti
operator|++
control|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rti
operator|->
name|nelt
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rti
operator|->
name|base
operator|+
name|rti
operator|->
name|stride
operator|*
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|!=
literal|1
condition|)
name|fatal_error
argument_list|(
literal|"can't read PCH file: %m"
argument_list|)
expr_stmt|;
for|for
control|(
name|rt
operator|=
name|gt_pch_cache_rtab
init|;
operator|*
name|rt
condition|;
name|rt
operator|++
control|)
for|for
control|(
name|rti
operator|=
operator|*
name|rt
init|;
name|rti
operator|->
name|base
operator|!=
name|NULL
condition|;
name|rti
operator|++
control|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rti
operator|->
name|nelt
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rti
operator|->
name|base
operator|+
name|rti
operator|->
name|stride
operator|*
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|!=
literal|1
condition|)
name|fatal_error
argument_list|(
literal|"can't read PCH file: %m"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fread
argument_list|(
operator|&
name|mmi
argument_list|,
sizeof|sizeof
argument_list|(
name|mmi
argument_list|)
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|!=
literal|1
condition|)
name|fatal_error
argument_list|(
literal|"can't read PCH file: %m"
argument_list|)
expr_stmt|;
if|if
condition|(
name|host_hooks
operator|.
name|gt_pch_use_address
argument_list|(
name|mmi
operator|.
name|preferred_base
argument_list|,
name|mmi
operator|.
name|size
argument_list|)
condition|)
block|{
if|#
directive|if
name|HAVE_MMAP_FILE
name|void
modifier|*
name|mmap_result
decl_stmt|;
name|mmap_result
operator|=
name|mmap
argument_list|(
name|mmi
operator|.
name|preferred_base
argument_list|,
name|mmi
operator|.
name|size
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_PRIVATE
operator||
name|MAP_FIXED
argument_list|,
name|fileno
argument_list|(
name|f
argument_list|)
argument_list|,
name|mmi
operator|.
name|offset
argument_list|)
expr_stmt|;
comment|/* The file might not be mmap-able.  */
name|needs_read
operator|=
name|mmap_result
operator|==
operator|(
name|void
operator|*
operator|)
name|MAP_FAILED
expr_stmt|;
comment|/* Sanity check for broken MAP_FIXED.  */
if|if
condition|(
operator|!
name|needs_read
operator|&&
name|mmap_result
operator|!=
name|mmi
operator|.
name|preferred_base
condition|)
name|abort
argument_list|()
expr_stmt|;
else|#
directive|else
name|needs_read
operator|=
name|true
expr_stmt|;
endif|#
directive|endif
name|addr
operator|=
name|mmi
operator|.
name|preferred_base
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
name|HAVE_MMAP_FILE
name|addr
operator|=
name|mmap
argument_list|(
name|mmi
operator|.
name|preferred_base
argument_list|,
name|mmi
operator|.
name|size
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_PRIVATE
argument_list|,
name|fileno
argument_list|(
name|f
argument_list|)
argument_list|,
name|mmi
operator|.
name|offset
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_MINCORE
if|if
condition|(
name|addr
operator|!=
name|mmi
operator|.
name|preferred_base
condition|)
block|{
name|size_t
name|page_size
init|=
name|getpagesize
argument_list|()
decl_stmt|;
name|char
name|one_byte
decl_stmt|;
if|if
condition|(
name|addr
operator|!=
operator|(
name|void
operator|*
operator|)
name|MAP_FAILED
condition|)
name|munmap
argument_list|(
name|addr
argument_list|,
name|mmi
operator|.
name|size
argument_list|)
expr_stmt|;
comment|/* We really want to be mapped at mmi.preferred_base 	     so we're going to resort to MAP_FIXED.  But before, 	     make sure that we can do so without destroying a 	     previously mapped area, by looping over all pages 	     that would be affected by the fixed mapping.  */
name|errno
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mmi
operator|.
name|size
condition|;
name|i
operator|+=
name|page_size
control|)
if|if
condition|(
name|mincore
argument_list|(
operator|(
name|char
operator|*
operator|)
name|mmi
operator|.
name|preferred_base
operator|+
name|i
argument_list|,
name|page_size
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|one_byte
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|ENOMEM
condition|)
continue|continue;
comment|/* The page is not mapped.  */
else|else
break|break;
if|if
condition|(
name|i
operator|>=
name|mmi
operator|.
name|size
condition|)
name|addr
operator|=
name|mmap
argument_list|(
name|mmi
operator|.
name|preferred_base
argument_list|,
name|mmi
operator|.
name|size
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_PRIVATE
operator||
name|MAP_FIXED
argument_list|,
name|fileno
argument_list|(
name|f
argument_list|)
argument_list|,
name|mmi
operator|.
name|offset
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAVE_MINCORE */
name|needs_read
operator|=
name|addr
operator|==
operator|(
name|void
operator|*
operator|)
name|MAP_FAILED
expr_stmt|;
else|#
directive|else
comment|/* HAVE_MMAP_FILE */
name|needs_read
operator|=
name|true
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_MMAP_FILE */
if|if
condition|(
name|needs_read
condition|)
name|addr
operator|=
name|xmalloc
argument_list|(
name|mmi
operator|.
name|size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|needs_read
condition|)
block|{
if|if
condition|(
name|fseek
argument_list|(
name|f
argument_list|,
name|mmi
operator|.
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|fread
argument_list|(
operator|&
name|mmi
argument_list|,
name|mmi
operator|.
name|size
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|!=
literal|1
condition|)
name|fatal_error
argument_list|(
literal|"can't read PCH file: %m"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fseek
argument_list|(
name|f
argument_list|,
name|mmi
operator|.
name|offset
operator|+
name|mmi
operator|.
name|size
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
name|fatal_error
argument_list|(
literal|"can't read PCH file: %m"
argument_list|)
expr_stmt|;
name|ggc_pch_read
argument_list|(
name|f
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|!=
name|mmi
operator|.
name|preferred_base
condition|)
block|{
for|for
control|(
name|rt
operator|=
name|gt_ggc_rtab
init|;
operator|*
name|rt
condition|;
name|rt
operator|++
control|)
for|for
control|(
name|rti
operator|=
operator|*
name|rt
init|;
name|rti
operator|->
name|base
operator|!=
name|NULL
condition|;
name|rti
operator|++
control|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rti
operator|->
name|nelt
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
modifier|*
name|ptr
init|=
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|rti
operator|->
name|base
operator|+
name|rti
operator|->
name|stride
operator|*
name|i
operator|)
decl_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|!=
name|NULL
condition|)
operator|*
name|ptr
operator|+=
operator|(
name|size_t
operator|)
name|addr
operator|-
operator|(
name|size_t
operator|)
name|mmi
operator|.
name|preferred_base
expr_stmt|;
block|}
for|for
control|(
name|rt
operator|=
name|gt_pch_cache_rtab
init|;
operator|*
name|rt
condition|;
name|rt
operator|++
control|)
for|for
control|(
name|rti
operator|=
operator|*
name|rt
init|;
name|rti
operator|->
name|base
operator|!=
name|NULL
condition|;
name|rti
operator|++
control|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rti
operator|->
name|nelt
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
modifier|*
name|ptr
init|=
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|rti
operator|->
name|base
operator|+
name|rti
operator|->
name|stride
operator|*
name|i
operator|)
decl_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|!=
name|NULL
condition|)
operator|*
name|ptr
operator|+=
operator|(
name|size_t
operator|)
name|addr
operator|-
operator|(
name|size_t
operator|)
name|mmi
operator|.
name|preferred_base
expr_stmt|;
block|}
name|sorry
argument_list|(
literal|"had to relocate PCH"
argument_list|)
expr_stmt|;
block|}
name|gt_pch_restore_stringpool
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Modify the bound based on rlimits.  Keep the smallest number found.  */
end_comment

begin_function
specifier|static
name|double
name|ggc_rlimit_bound
parameter_list|(
name|double
name|limit
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|HAVE_GETRLIMIT
argument_list|)
name|struct
name|rlimit
name|rlim
decl_stmt|;
ifdef|#
directive|ifdef
name|RLIMIT_RSS
if|if
condition|(
name|getrlimit
argument_list|(
name|RLIMIT_RSS
argument_list|,
operator|&
name|rlim
argument_list|)
operator|==
literal|0
operator|&&
name|rlim
operator|.
name|rlim_cur
operator|!=
operator|(
name|rlim_t
operator|)
name|RLIM_INFINITY
operator|&&
name|rlim
operator|.
name|rlim_cur
operator|<
name|limit
condition|)
name|limit
operator|=
name|rlim
operator|.
name|rlim_cur
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RLIMIT_DATA
if|if
condition|(
name|getrlimit
argument_list|(
name|RLIMIT_DATA
argument_list|,
operator|&
name|rlim
argument_list|)
operator|==
literal|0
operator|&&
name|rlim
operator|.
name|rlim_cur
operator|!=
operator|(
name|rlim_t
operator|)
name|RLIM_INFINITY
operator|&&
name|rlim
operator|.
name|rlim_cur
operator|<
name|limit
condition|)
name|limit
operator|=
name|rlim
operator|.
name|rlim_cur
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RLIMIT_AS
if|if
condition|(
name|getrlimit
argument_list|(
name|RLIMIT_AS
argument_list|,
operator|&
name|rlim
argument_list|)
operator|==
literal|0
operator|&&
name|rlim
operator|.
name|rlim_cur
operator|!=
operator|(
name|rlim_t
operator|)
name|RLIM_INFINITY
operator|&&
name|rlim
operator|.
name|rlim_cur
operator|<
name|limit
condition|)
name|limit
operator|=
name|rlim
operator|.
name|rlim_cur
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* HAVE_GETRLIMIT */
return|return
name|limit
return|;
block|}
end_function

begin_comment
comment|/* Heuristic to set a default for GGC_MIN_EXPAND.  */
end_comment

begin_function
name|int
name|ggc_min_expand_heuristic
parameter_list|(
name|void
parameter_list|)
block|{
name|double
name|min_expand
init|=
name|physmem_total
argument_list|()
decl_stmt|;
comment|/* Adjust for rlimits.  */
name|min_expand
operator|=
name|ggc_rlimit_bound
argument_list|(
name|min_expand
argument_list|)
expr_stmt|;
comment|/* The heuristic is a percentage equal to 30% + 70%*(RAM/1GB), yielding      a lower bound of 30% and an upper bound of 100% (when RAM>= 1GB).  */
name|min_expand
operator|/=
literal|1024
operator|*
literal|1024
operator|*
literal|1024
expr_stmt|;
name|min_expand
operator|*=
literal|70
expr_stmt|;
name|min_expand
operator|=
name|MIN
argument_list|(
name|min_expand
argument_list|,
literal|70
argument_list|)
expr_stmt|;
name|min_expand
operator|+=
literal|30
expr_stmt|;
return|return
name|min_expand
return|;
block|}
end_function

begin_comment
comment|/* Heuristic to set a default for GGC_MIN_HEAPSIZE.  */
end_comment

begin_function
name|int
name|ggc_min_heapsize_heuristic
parameter_list|(
name|void
parameter_list|)
block|{
name|double
name|min_heap_kbytes
init|=
name|physmem_total
argument_list|()
decl_stmt|;
comment|/* Adjust for rlimits.  */
name|min_heap_kbytes
operator|=
name|ggc_rlimit_bound
argument_list|(
name|min_heap_kbytes
argument_list|)
expr_stmt|;
name|min_heap_kbytes
operator|/=
literal|1024
expr_stmt|;
comment|/* Convert to Kbytes.  */
comment|/* The heuristic is RAM/8, with a lower bound of 4M and an upper      bound of 128M (when RAM>= 1GB).  */
name|min_heap_kbytes
operator|/=
literal|8
expr_stmt|;
name|min_heap_kbytes
operator|=
name|MAX
argument_list|(
name|min_heap_kbytes
argument_list|,
literal|4
operator|*
literal|1024
argument_list|)
expr_stmt|;
name|min_heap_kbytes
operator|=
name|MIN
argument_list|(
name|min_heap_kbytes
argument_list|,
literal|128
operator|*
literal|1024
argument_list|)
expr_stmt|;
return|return
name|min_heap_kbytes
return|;
block|}
end_function

begin_function
name|void
name|init_ggc_heuristics
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
name|ENABLE_GC_CHECKING
operator|&&
operator|!
name|defined
name|ENABLE_GC_ALWAYS_COLLECT
name|set_param_value
argument_list|(
literal|"ggc-min-expand"
argument_list|,
name|ggc_min_expand_heuristic
argument_list|()
argument_list|)
expr_stmt|;
name|set_param_value
argument_list|(
literal|"ggc-min-heapsize"
argument_list|,
name|ggc_min_heapsize_heuristic
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

end_unit

