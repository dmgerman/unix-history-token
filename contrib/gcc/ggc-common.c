begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Simple garbage collection for the GNU compiler.    Copyright (C) 1999, 2000, 2001, 2002 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Generic garbage collection (GC) functions and data, not specific to    any particular GC implementation.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"varray.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_RESOURCE_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ENABLE_VALGRIND_CHECKING
end_ifdef

begin_include
include|#
directive|include
file|<valgrind.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Avoid #ifdef:s when we can help it.  */
end_comment

begin_define
define|#
directive|define
name|VALGRIND_DISCARD
parameter_list|(
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Statistics about the allocation.  */
end_comment

begin_decl_stmt
specifier|static
name|ggc_statistics
modifier|*
name|ggc_stats
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ggc_htab_delete
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|double
name|ggc_rlimit_bound
name|PARAMS
argument_list|(
operator|(
name|double
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maintain global roots that are preserved during GC.  */
end_comment

begin_comment
comment|/* Global roots that are preserved during calls to gc.  */
end_comment

begin_struct
struct|struct
name|ggc_root
block|{
name|struct
name|ggc_root
modifier|*
name|next
decl_stmt|;
name|void
modifier|*
name|base
decl_stmt|;
name|int
name|nelt
decl_stmt|;
name|int
name|size
decl_stmt|;
name|void
argument_list|(
argument|*cb
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
expr_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|ggc_root
modifier|*
name|roots
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Add BASE as a new garbage collection root.  It is an array of    length NELT with each element SIZE bytes long.  CB is a    function that will be called with a pointer to each element    of the array; it is the intention that CB call the appropriate    routine to mark gc-able memory for that element.  */
end_comment

begin_function_decl
name|void
name|ggc_add_root
parameter_list|(
name|base
parameter_list|,
name|nelt
parameter_list|,
name|size
parameter_list|,
name|cb
parameter_list|)
name|void
modifier|*
name|base
decl_stmt|;
name|int
name|nelt
decl_stmt|,
name|size
decl_stmt|;
function_decl|void
parameter_list|(
function_decl|*cb
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|ggc_root
modifier|*
name|x
init|=
operator|(
expr|struct
name|ggc_root
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|x
argument_list|)
argument_list|)
decl_stmt|;
name|x
operator|->
name|next
operator|=
name|roots
expr_stmt|;
name|x
operator|->
name|base
operator|=
name|base
expr_stmt|;
name|x
operator|->
name|nelt
operator|=
name|nelt
expr_stmt|;
name|x
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|x
operator|->
name|cb
operator|=
name|cb
expr_stmt|;
name|roots
operator|=
name|x
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Process a slot of an htab by deleting it if it has not been marked.  */
end_comment

begin_function
specifier|static
name|int
name|ggc_htab_delete
parameter_list|(
name|slot
parameter_list|,
name|info
parameter_list|)
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
name|void
modifier|*
name|info
decl_stmt|;
block|{
specifier|const
name|struct
name|ggc_cache_tab
modifier|*
name|r
init|=
operator|(
specifier|const
expr|struct
name|ggc_cache_tab
operator|*
operator|)
name|info
decl_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|r
operator|->
name|marked_p
call|)
argument_list|(
operator|*
name|slot
argument_list|)
condition|)
name|htab_clear_slot
argument_list|(
operator|*
name|r
operator|->
name|base
argument_list|,
name|slot
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|r
operator|->
name|cb
call|)
argument_list|(
operator|*
name|slot
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Iterate through all registered roots and mark each element.  */
end_comment

begin_function
name|void
name|ggc_mark_roots
parameter_list|()
block|{
name|struct
name|ggc_root
modifier|*
name|x
decl_stmt|;
specifier|const
name|struct
name|ggc_root_tab
modifier|*
specifier|const
modifier|*
name|rt
decl_stmt|;
specifier|const
name|struct
name|ggc_root_tab
modifier|*
name|rti
decl_stmt|;
specifier|const
name|struct
name|ggc_cache_tab
modifier|*
specifier|const
modifier|*
name|ct
decl_stmt|;
specifier|const
name|struct
name|ggc_cache_tab
modifier|*
name|cti
decl_stmt|;
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|rt
operator|=
name|gt_ggc_deletable_rtab
init|;
operator|*
name|rt
condition|;
name|rt
operator|++
control|)
for|for
control|(
name|rti
operator|=
operator|*
name|rt
init|;
name|rti
operator|->
name|base
operator|!=
name|NULL
condition|;
name|rti
operator|++
control|)
name|memset
argument_list|(
name|rti
operator|->
name|base
argument_list|,
literal|0
argument_list|,
name|rti
operator|->
name|stride
argument_list|)
expr_stmt|;
for|for
control|(
name|rt
operator|=
name|gt_ggc_rtab
init|;
operator|*
name|rt
condition|;
name|rt
operator|++
control|)
for|for
control|(
name|rti
operator|=
operator|*
name|rt
init|;
name|rti
operator|->
name|base
operator|!=
name|NULL
condition|;
name|rti
operator|++
control|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rti
operator|->
name|nelt
condition|;
name|i
operator|++
control|)
call|(
modifier|*
name|rti
operator|->
name|cb
call|)
argument_list|(
operator|*
operator|(
name|void
operator|*
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|rti
operator|->
name|base
operator|+
name|rti
operator|->
name|stride
operator|*
name|i
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
name|roots
init|;
name|x
operator|!=
name|NULL
condition|;
name|x
operator|=
name|x
operator|->
name|next
control|)
block|{
name|char
modifier|*
name|elt
init|=
name|x
operator|->
name|base
decl_stmt|;
name|int
name|s
init|=
name|x
operator|->
name|size
decl_stmt|,
name|n
init|=
name|x
operator|->
name|nelt
decl_stmt|;
name|void
argument_list|(
argument|*cb
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
operator|=
name|x
operator|->
name|cb
expr_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
operator|,
name|elt
operator|+=
name|s
control|)
call|(
modifier|*
name|cb
call|)
argument_list|(
name|elt
argument_list|)
expr_stmt|;
block|}
comment|/* Now scan all hash tables that have objects which are to be deleted if      they are not already marked.  */
for|for
control|(
name|ct
operator|=
name|gt_ggc_cache_rtab
init|;
operator|*
name|ct
condition|;
name|ct
operator|++
control|)
for|for
control|(
name|cti
operator|=
operator|*
name|ct
init|;
name|cti
operator|->
name|base
operator|!=
name|NULL
condition|;
name|cti
operator|++
control|)
if|if
condition|(
operator|*
name|cti
operator|->
name|base
condition|)
name|htab_traverse
argument_list|(
operator|*
name|cti
operator|->
name|base
argument_list|,
name|ggc_htab_delete
argument_list|,
operator|(
name|PTR
operator|)
name|cti
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocate a block of memory, then clear it.  */
end_comment

begin_function
name|void
modifier|*
name|ggc_alloc_cleared
parameter_list|(
name|size
parameter_list|)
name|size_t
name|size
decl_stmt|;
block|{
name|void
modifier|*
name|buf
init|=
name|ggc_alloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/* Resize a block of memory, possibly re-allocating it.  */
end_comment

begin_function
name|void
modifier|*
name|ggc_realloc
parameter_list|(
name|x
parameter_list|,
name|size
parameter_list|)
name|void
modifier|*
name|x
decl_stmt|;
name|size_t
name|size
decl_stmt|;
block|{
name|void
modifier|*
name|r
decl_stmt|;
name|size_t
name|old_size
decl_stmt|;
if|if
condition|(
name|x
operator|==
name|NULL
condition|)
return|return
name|ggc_alloc
argument_list|(
name|size
argument_list|)
return|;
name|old_size
operator|=
name|ggc_get_size
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<=
name|old_size
condition|)
block|{
comment|/* Mark the unwanted memory as unaccessible.  We also need to make 	 the "new" size accessible, since ggc_get_size returns the size of 	 the pool, not the size of the individually allocated object, the 	 size which was previously made accessible.  Unfortunately, we 	 don't know that previously allocated size.  Without that 	 knowledge we have to lose some initialization-tracking for the 	 old parts of the object.  An alternative is to mark the whole 	 old_size as reachable, but that would lose tracking of writes  	 after the end of the object (by small offsets).  Discard the 	 handle to avoid handle leak.  */
name|VALGRIND_DISCARD
argument_list|(
name|VALGRIND_MAKE_NOACCESS
argument_list|(
operator|(
name|char
operator|*
operator|)
name|x
operator|+
name|size
argument_list|,
name|old_size
operator|-
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|VALGRIND_DISCARD
argument_list|(
name|VALGRIND_MAKE_READABLE
argument_list|(
name|x
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
name|r
operator|=
name|ggc_alloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
comment|/* Since ggc_get_size returns the size of the pool, not the size of the      individually allocated object, we'd access parts of the old object      that were marked invalid with the memcpy below.  We lose a bit of the      initialization-tracking since some of it may be uninitialized.  */
name|VALGRIND_DISCARD
argument_list|(
name|VALGRIND_MAKE_READABLE
argument_list|(
name|x
argument_list|,
name|old_size
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|r
argument_list|,
name|x
argument_list|,
name|old_size
argument_list|)
expr_stmt|;
comment|/* The old object is not supposed to be used anymore.  */
name|VALGRIND_DISCARD
argument_list|(
name|VALGRIND_MAKE_NOACCESS
argument_list|(
name|x
argument_list|,
name|old_size
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Like ggc_alloc_cleared, but performs a multiplication.  */
end_comment

begin_function
name|void
modifier|*
name|ggc_calloc
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
name|size_t
name|s1
decl_stmt|,
name|s2
decl_stmt|;
block|{
return|return
name|ggc_alloc_cleared
argument_list|(
name|s1
operator|*
name|s2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Print statistics that are independent of the collector in use.  */
end_comment

begin_define
define|#
directive|define
name|SCALE
parameter_list|(
name|x
parameter_list|)
value|((unsigned long) ((x)< 1024*10 \ 		  ? (x) \ 		  : ((x)< 1024*1024*10 \ 		     ? (x) / 1024 \ 		     : (x) / (1024*1024))))
end_define

begin_define
define|#
directive|define
name|LABEL
parameter_list|(
name|x
parameter_list|)
value|((x)< 1024*10 ? ' ' : ((x)< 1024*1024*10 ? 'k' : 'M'))
end_define

begin_function
name|void
name|ggc_print_common_statistics
parameter_list|(
name|stream
parameter_list|,
name|stats
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|ggc_statistics
modifier|*
name|stats
decl_stmt|;
block|{
name|int
name|code
decl_stmt|;
comment|/* Set the pointer so that during collection we will actually gather      the statistics.  */
name|ggc_stats
operator|=
name|stats
expr_stmt|;
comment|/* Then do one collection to fill in the statistics.  */
name|ggc_collect
argument_list|()
expr_stmt|;
comment|/* Total the statistics.  */
for|for
control|(
name|code
operator|=
literal|0
init|;
name|code
operator|<
name|MAX_TREE_CODES
condition|;
operator|++
name|code
control|)
block|{
name|stats
operator|->
name|total_num_trees
operator|+=
name|stats
operator|->
name|num_trees
index|[
name|code
index|]
expr_stmt|;
name|stats
operator|->
name|total_size_trees
operator|+=
name|stats
operator|->
name|size_trees
index|[
name|code
index|]
expr_stmt|;
block|}
for|for
control|(
name|code
operator|=
literal|0
init|;
name|code
operator|<
name|NUM_RTX_CODE
condition|;
operator|++
name|code
control|)
block|{
name|stats
operator|->
name|total_num_rtxs
operator|+=
name|stats
operator|->
name|num_rtxs
index|[
name|code
index|]
expr_stmt|;
name|stats
operator|->
name|total_size_rtxs
operator|+=
name|stats
operator|->
name|size_rtxs
index|[
name|code
index|]
expr_stmt|;
block|}
comment|/* Print the statistics for trees.  */
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\n%-17s%10s %16s %10s\n"
argument_list|,
literal|"Tree"
argument_list|,
literal|"Number"
argument_list|,
literal|"Bytes"
argument_list|,
literal|"% Total"
argument_list|)
expr_stmt|;
for|for
control|(
name|code
operator|=
literal|0
init|;
name|code
operator|<
name|MAX_TREE_CODES
condition|;
operator|++
name|code
control|)
if|if
condition|(
name|ggc_stats
operator|->
name|num_trees
index|[
name|code
index|]
condition|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%-17s%10u%16ld%c %10.3f\n"
argument_list|,
name|tree_code_name
index|[
name|code
index|]
argument_list|,
name|ggc_stats
operator|->
name|num_trees
index|[
name|code
index|]
argument_list|,
name|SCALE
argument_list|(
name|ggc_stats
operator|->
name|size_trees
index|[
name|code
index|]
argument_list|)
argument_list|,
name|LABEL
argument_list|(
name|ggc_stats
operator|->
name|size_trees
index|[
name|code
index|]
argument_list|)
argument_list|,
operator|(
literal|100
operator|*
operator|(
operator|(
name|double
operator|)
name|ggc_stats
operator|->
name|size_trees
index|[
name|code
index|]
operator|)
operator|/
name|ggc_stats
operator|->
name|total_size_trees
operator|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%-17s%10u%16ld%c\n"
argument_list|,
literal|"Total"
argument_list|,
name|ggc_stats
operator|->
name|total_num_trees
argument_list|,
name|SCALE
argument_list|(
name|ggc_stats
operator|->
name|total_size_trees
argument_list|)
argument_list|,
name|LABEL
argument_list|(
name|ggc_stats
operator|->
name|total_size_trees
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Print the statistics for RTL.  */
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\n%-17s%10s %16s %10s\n"
argument_list|,
literal|"RTX"
argument_list|,
literal|"Number"
argument_list|,
literal|"Bytes"
argument_list|,
literal|"% Total"
argument_list|)
expr_stmt|;
for|for
control|(
name|code
operator|=
literal|0
init|;
name|code
operator|<
name|NUM_RTX_CODE
condition|;
operator|++
name|code
control|)
if|if
condition|(
name|ggc_stats
operator|->
name|num_rtxs
index|[
name|code
index|]
condition|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%-17s%10u%16ld%c %10.3f\n"
argument_list|,
name|rtx_name
index|[
name|code
index|]
argument_list|,
name|ggc_stats
operator|->
name|num_rtxs
index|[
name|code
index|]
argument_list|,
name|SCALE
argument_list|(
name|ggc_stats
operator|->
name|size_rtxs
index|[
name|code
index|]
argument_list|)
argument_list|,
name|LABEL
argument_list|(
name|ggc_stats
operator|->
name|size_rtxs
index|[
name|code
index|]
argument_list|)
argument_list|,
operator|(
literal|100
operator|*
operator|(
operator|(
name|double
operator|)
name|ggc_stats
operator|->
name|size_rtxs
index|[
name|code
index|]
operator|)
operator|/
name|ggc_stats
operator|->
name|total_size_rtxs
operator|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%-17s%10u%16ld%c\n"
argument_list|,
literal|"Total"
argument_list|,
name|ggc_stats
operator|->
name|total_num_rtxs
argument_list|,
name|SCALE
argument_list|(
name|ggc_stats
operator|->
name|total_size_rtxs
argument_list|)
argument_list|,
name|LABEL
argument_list|(
name|ggc_stats
operator|->
name|total_size_rtxs
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Don't gather statistics any more.  */
name|ggc_stats
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Modify the bound based on rlimits.  Keep the smallest number found.  */
end_comment

begin_function
specifier|static
name|double
name|ggc_rlimit_bound
parameter_list|(
name|limit
parameter_list|)
name|double
name|limit
decl_stmt|;
block|{
if|#
directive|if
name|defined
argument_list|(
name|HAVE_GETRLIMIT
argument_list|)
name|struct
name|rlimit
name|rlim
decl_stmt|;
ifdef|#
directive|ifdef
name|RLIMIT_RSS
if|if
condition|(
name|getrlimit
argument_list|(
name|RLIMIT_RSS
argument_list|,
operator|&
name|rlim
argument_list|)
operator|==
literal|0
operator|&&
name|rlim
operator|.
name|rlim_cur
operator|!=
operator|(
name|rlim_t
operator|)
name|RLIM_INFINITY
operator|&&
name|rlim
operator|.
name|rlim_cur
operator|<
name|limit
condition|)
name|limit
operator|=
name|rlim
operator|.
name|rlim_cur
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RLIMIT_DATA
if|if
condition|(
name|getrlimit
argument_list|(
name|RLIMIT_DATA
argument_list|,
operator|&
name|rlim
argument_list|)
operator|==
literal|0
operator|&&
name|rlim
operator|.
name|rlim_cur
operator|!=
operator|(
name|rlim_t
operator|)
name|RLIM_INFINITY
operator|&&
name|rlim
operator|.
name|rlim_cur
operator|<
name|limit
condition|)
name|limit
operator|=
name|rlim
operator|.
name|rlim_cur
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RLIMIT_AS
if|if
condition|(
name|getrlimit
argument_list|(
name|RLIMIT_AS
argument_list|,
operator|&
name|rlim
argument_list|)
operator|==
literal|0
operator|&&
name|rlim
operator|.
name|rlim_cur
operator|!=
operator|(
name|rlim_t
operator|)
name|RLIM_INFINITY
operator|&&
name|rlim
operator|.
name|rlim_cur
operator|<
name|limit
condition|)
name|limit
operator|=
name|rlim
operator|.
name|rlim_cur
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* HAVE_GETRLIMIT */
return|return
name|limit
return|;
block|}
end_function

begin_comment
comment|/* Heuristic to set a default for GGC_MIN_EXPAND.  */
end_comment

begin_function
name|int
name|ggc_min_expand_heuristic
parameter_list|()
block|{
name|double
name|min_expand
init|=
name|physmem_total
argument_list|()
decl_stmt|;
comment|/* Adjust for rlimits.  */
name|min_expand
operator|=
name|ggc_rlimit_bound
argument_list|(
name|min_expand
argument_list|)
expr_stmt|;
comment|/* The heuristic is a percentage equal to 30% + 70%*(RAM/1GB), yielding      a lower bound of 30% and an upper bound of 100% (when RAM>= 1GB).  */
name|min_expand
operator|/=
literal|1024
operator|*
literal|1024
operator|*
literal|1024
expr_stmt|;
name|min_expand
operator|*=
literal|70
expr_stmt|;
name|min_expand
operator|=
name|MIN
argument_list|(
name|min_expand
argument_list|,
literal|70
argument_list|)
expr_stmt|;
name|min_expand
operator|+=
literal|30
expr_stmt|;
return|return
name|min_expand
return|;
block|}
end_function

begin_comment
comment|/* Heuristic to set a default for GGC_MIN_HEAPSIZE.  */
end_comment

begin_function
name|int
name|ggc_min_heapsize_heuristic
parameter_list|()
block|{
name|double
name|min_heap_kbytes
init|=
name|physmem_total
argument_list|()
decl_stmt|;
comment|/* Adjust for rlimits.  */
name|min_heap_kbytes
operator|=
name|ggc_rlimit_bound
argument_list|(
name|min_heap_kbytes
argument_list|)
expr_stmt|;
name|min_heap_kbytes
operator|/=
literal|1024
expr_stmt|;
comment|/* convert to Kbytes. */
comment|/* The heuristic is RAM/8, with a lower bound of 4M and an upper      bound of 128M (when RAM>= 1GB).  */
name|min_heap_kbytes
operator|/=
literal|8
expr_stmt|;
name|min_heap_kbytes
operator|=
name|MAX
argument_list|(
name|min_heap_kbytes
argument_list|,
literal|4
operator|*
literal|1024
argument_list|)
expr_stmt|;
name|min_heap_kbytes
operator|=
name|MIN
argument_list|(
name|min_heap_kbytes
argument_list|,
literal|128
operator|*
literal|1024
argument_list|)
expr_stmt|;
return|return
name|min_heap_kbytes
return|;
block|}
end_function

begin_function
name|void
name|init_ggc_heuristics
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|ENABLE_GC_ALWAYS_COLLECT
name|set_param_value
argument_list|(
literal|"ggc-min-expand"
argument_list|,
name|ggc_min_expand_heuristic
argument_list|()
argument_list|)
expr_stmt|;
name|set_param_value
argument_list|(
literal|"ggc-min-heapsize"
argument_list|,
name|ggc_min_heapsize_heuristic
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

end_unit

