begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Pipeline hazard description translator.    Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005    Free Software Foundation, Inc.     Written by Vladimir Makarov<vmakarov@redhat.com>  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* References:     1. Detecting pipeline structural hazards quickly. T. Proebsting,       C. Fraser. Proceedings of ACM SIGPLAN-SIGACT Symposium on       Principles of Programming Languages, pages 280--286, 1994.        This article is a good start point to understand usage of finite       state automata for pipeline hazard recognizers.  But I'd       recommend the 2nd article for more deep understanding.     2. Efficient Instruction Scheduling Using Finite State Automata:       V. Bala and N. Rubin, Proceedings of MICRO-28.  This is the best       article about usage of finite state automata for pipeline hazard       recognizers.     The current implementation is different from the 2nd article in the    following:     1. New operator `|' (alternative) is permitted in functional unit       reservation which can be treated deterministically and       non-deterministically.     2. Possibility of usage of nondeterministic automata too.     3. Possibility to query functional unit reservations for given       automaton state.     4. Several constructions to describe impossible reservations       (`exclusion_set', `presence_set', `final_presence_set',       `absence_set', and `final_absence_set').     5. No reverse automata are generated.  Trace instruction scheduling       requires this.  It can be easily added in the future if we       really need this.     6. Union of automaton states are not generated yet.  It is planned       to be implemented.  Such feature is needed to make more accurate       interlock insn scheduling to get state describing functional       unit reservation in a joint CFG point.  */
end_comment

begin_comment
comment|/* This file code processes constructions of machine description file    which describes automaton used for recognition of processor pipeline    hazards by insn scheduler and can be used for other tasks (such as    VLIW insn packing.     The translator functions `gen_cpu_unit', `gen_query_cpu_unit',    `gen_bypass', `gen_excl_set', `gen_presence_set',    `gen_final_presence_set', `gen_absence_set',    `gen_final_absence_set', `gen_automaton', `gen_automata_option',    `gen_reserv', `gen_insn_reserv' are called from file    `genattrtab.c'.  They transform RTL constructions describing    automata in .md file into internal representation convenient for    further processing.     The translator major function `expand_automata' processes the    description internal representation into finite state automaton.    It can be divided on:       o checking correctness of the automaton pipeline description        (major function is `check_all_description').       o generating automaton (automata) from the description (major        function is `make_automaton').       o optional transformation of nondeterministic finite state        automata into deterministic ones if the alternative operator        `|' is treated nondeterministically in the description (major        function is NDFA_to_DFA).       o optional minimization of the finite state automata by merging        equivalent automaton states (major function is `minimize_DFA').       o forming tables (some as comb vectors) and attributes        representing the automata (functions output_..._table).     Function `write_automata' outputs the created finite state    automaton as different tables and functions which works with the    automata to inquire automaton state and to change its state.  These    function are used by gcc instruction scheduler and may be some    other gcc code.  */
end_comment

begin_include
include|#
directive|include
file|"bconfig.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"errors.h"
end_include

begin_include
include|#
directive|include
file|"gensupport.h"
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"vec.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|CHAR_BIT
end_ifndef

begin_define
define|#
directive|define
name|CHAR_BIT
value|8
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Positions in machine description file.  Now they are not used.  But    they could be used in the future for better diagnostic messages.  */
end_comment

begin_typedef
typedef|typedef
name|int
name|pos_t
typedef|;
end_typedef

begin_comment
comment|/* The following is element of vector of current (and planned in the    future) functional unit reservations.  */
end_comment

begin_typedef
typedef|typedef
name|unsigned
name|HOST_WIDE_INT
name|set_el_t
typedef|;
end_typedef

begin_comment
comment|/* Reservations of function units are represented by value of the following    type.  */
end_comment

begin_typedef
typedef|typedef
name|set_el_t
modifier|*
name|reserv_sets_t
typedef|;
end_typedef

begin_comment
comment|/* The following structure describes a ticker.  */
end_comment

begin_struct
struct|struct
name|ticker
block|{
comment|/* The following member value is time of the ticker creation with      taking into account time when the ticker is off.  Active time of      the ticker is current time minus the value.  */
name|int
name|modified_creation_time
decl_stmt|;
comment|/* The following member value is time (incremented by one) when the      ticker was off.  Zero value means that now the ticker is on.  */
name|int
name|incremented_off_time
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The ticker is represented by the following type.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|ticker
name|ticker_t
typedef|;
end_typedef

begin_comment
comment|/* The following type describes elements of output vectors.  */
end_comment

begin_typedef
typedef|typedef
name|HOST_WIDE_INT
name|vect_el_t
typedef|;
end_typedef

begin_comment
comment|/* Forward declaration of structures of internal representation of    pipeline description based on NDFA.  */
end_comment

begin_struct_decl
struct_decl|struct
name|unit_decl
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|bypass_decl
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|result_decl
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|automaton_decl
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|unit_pattern_rel_decl
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|reserv_decl
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|insn_reserv_decl
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|decl
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|unit_regexp
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|result_regexp
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|reserv_regexp
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|nothing_regexp
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|sequence_regexp
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|repeat_regexp
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|allof_regexp
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|oneof_regexp
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|regexp
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|description
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|unit_set_el
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|pattern_set_el
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|pattern_reserv
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|state
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|alt_state
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|arc
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|ainsn
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|automaton
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|state_ainsn_table
struct_decl|;
end_struct_decl

begin_comment
comment|/* The following typedefs are for brevity.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|unit_decl
modifier|*
name|unit_decl_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|decl
modifier|*
name|decl_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|regexp
modifier|*
name|regexp_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|unit_set_el
modifier|*
name|unit_set_el_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|pattern_set_el
modifier|*
name|pattern_set_el_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|pattern_reserv
modifier|*
name|pattern_reserv_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|alt_state
modifier|*
name|alt_state_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|state
modifier|*
name|state_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|arc
modifier|*
name|arc_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|ainsn
modifier|*
name|ainsn_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|automaton
modifier|*
name|automaton_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|automata_list_el
modifier|*
name|automata_list_el_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|state_ainsn_table
modifier|*
name|state_ainsn_table_t
typedef|;
end_typedef

begin_comment
comment|/* Undefined position.  */
end_comment

begin_decl_stmt
specifier|static
name|pos_t
name|no_pos
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* All IR is stored in the following obstack.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|irp
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Declare vector types for various data structures: */
end_comment

begin_expr_stmt
name|DEF_VEC_P
argument_list|(
name|alt_state_t
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEF_VEC_ALLOC_P
argument_list|(
name|alt_state_t
argument_list|,
name|heap
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEF_VEC_P
argument_list|(
name|ainsn_t
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEF_VEC_ALLOC_P
argument_list|(
name|ainsn_t
argument_list|,
name|heap
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEF_VEC_P
argument_list|(
name|state_t
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEF_VEC_ALLOC_P
argument_list|(
name|state_t
argument_list|,
name|heap
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEF_VEC_P
argument_list|(
name|decl_t
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEF_VEC_ALLOC_P
argument_list|(
name|decl_t
argument_list|,
name|heap
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEF_VEC_P
argument_list|(
name|reserv_sets_t
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEF_VEC_ALLOC_P
argument_list|(
name|reserv_sets_t
argument_list|,
name|heap
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEF_VEC_I
argument_list|(
name|vect_el_t
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEF_VEC_ALLOC_I
argument_list|(
name|vect_el_t
argument_list|,
name|heap
argument_list|)
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|VEC
argument_list|(
name|vect_el_t
argument_list|,
name|heap
argument_list|)
operator|*
name|vla_hwint_t
expr_stmt|;
end_typedef

begin_escape
end_escape

begin_comment
comment|/* Forward declarations of functions used before their definitions, only.  */
end_comment

begin_function_decl
specifier|static
name|regexp_t
name|gen_regexp_sequence
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|reserv_sets_or
parameter_list|(
name|reserv_sets_t
parameter_list|,
name|reserv_sets_t
parameter_list|,
name|reserv_sets_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|reserv_sets_t
name|get_excl_set
parameter_list|(
name|reserv_sets_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|check_presence_pattern_sets
parameter_list|(
name|reserv_sets_t
parameter_list|,
name|reserv_sets_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|check_absence_pattern_sets
parameter_list|(
name|reserv_sets_t
parameter_list|,
name|reserv_sets_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|arc_t
name|first_out_arc
parameter_list|(
name|state_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|arc_t
name|next_out_arc
parameter_list|(
name|arc_t
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Options with the following names can be set up in automata_option    construction.  Because the strings occur more one time we use the    macros.  */
end_comment

begin_define
define|#
directive|define
name|NO_MINIMIZATION_OPTION
value|"-no-minimization"
end_define

begin_define
define|#
directive|define
name|TIME_OPTION
value|"-time"
end_define

begin_define
define|#
directive|define
name|V_OPTION
value|"-v"
end_define

begin_define
define|#
directive|define
name|W_OPTION
value|"-w"
end_define

begin_define
define|#
directive|define
name|NDFA_OPTION
value|"-ndfa"
end_define

begin_define
define|#
directive|define
name|PROGRESS_OPTION
value|"-progress"
end_define

begin_comment
comment|/* The following flags are set up by function `initiate_automaton_gen'.  */
end_comment

begin_comment
comment|/* Make automata with nondeterministic reservation by insns (`-ndfa').  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ndfa_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Do not make minimization of DFA (`-no-minimization').  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|no_minimization_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Value of this variable is number of automata being generated.  The    actual number of automata may be less this value if there is not    sufficient number of units.  This value is defined by argument of    option `-split' or by constructions automaton if the value is zero    (it is default value of the argument).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|split_argument
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag of output time statistics (`-time').  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|time_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag of creation of description file which contains description of    result automaton and statistics information (`-v').  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|v_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag of output of a progress bar showing how many states were    generated so far for automaton being processed (`-progress').  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|progress_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag of generating warning instead of error for non-critical errors    (`-w').  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|w_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Output file for pipeline hazard recognizer (PHR) being generated.    The value is NULL if the file is not defined.  */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|output_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Description file of PHR.  The value is NULL if the file is not    created.  */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|output_description_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* PHR description file name.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|output_description_file_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Value of the following variable is node representing description    being processed.  This is start point of IR.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|description
modifier|*
name|description
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* This page contains description of IR structure (nodes).  */
end_comment

begin_enum
enum|enum
name|decl_mode
block|{
name|dm_unit
block|,
name|dm_bypass
block|,
name|dm_automaton
block|,
name|dm_excl
block|,
name|dm_presence
block|,
name|dm_absence
block|,
name|dm_reserv
block|,
name|dm_insn_reserv
block|}
enum|;
end_enum

begin_comment
comment|/* This describes define_cpu_unit and define_query_cpu_unit (see file    rtl.def).  */
end_comment

begin_struct
struct|struct
name|unit_decl
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* NULL if the automaton name is absent.  */
specifier|const
name|char
modifier|*
name|automaton_name
decl_stmt|;
comment|/* If the following value is not zero, the cpu unit reservation is      described in define_query_cpu_unit.  */
name|char
name|query_p
decl_stmt|;
comment|/* The following fields are defined by checker.  */
comment|/* The following field value is nonzero if the unit is used in an      regexp.  */
name|char
name|unit_is_used
decl_stmt|;
comment|/* The following field value is order number (0, 1, ...) of given      unit.  */
name|int
name|unit_num
decl_stmt|;
comment|/* The following field value is corresponding declaration of      automaton which was given in description.  If the field value is      NULL then automaton in the unit declaration was absent.  */
name|struct
name|automaton_decl
modifier|*
name|automaton_decl
decl_stmt|;
comment|/* The following field value is maximal cycle number (1, ...) on      which given unit occurs in insns.  Zero value means that given      unit is not used in insns.  */
name|int
name|max_occ_cycle_num
decl_stmt|;
comment|/* The following field value is minimal cycle number (0, ...) on      which given unit occurs in insns.  -1 value means that given      unit is not used in insns.  */
name|int
name|min_occ_cycle_num
decl_stmt|;
comment|/* The following list contains units which conflict with given      unit.  */
name|unit_set_el_t
name|excl_list
decl_stmt|;
comment|/* The following list contains patterns which are required to      reservation of given unit.  */
name|pattern_set_el_t
name|presence_list
decl_stmt|;
name|pattern_set_el_t
name|final_presence_list
decl_stmt|;
comment|/* The following list contains patterns which should be not present      in reservation for given unit.  */
name|pattern_set_el_t
name|absence_list
decl_stmt|;
name|pattern_set_el_t
name|final_absence_list
decl_stmt|;
comment|/* The following is used only when `query_p' has nonzero value.      This is query number for the unit.  */
name|int
name|query_num
decl_stmt|;
comment|/* The following is the last cycle on which the unit was checked for      correct distributions of units to automata in a regexp.  */
name|int
name|last_distribution_check_cycle
decl_stmt|;
comment|/* The following fields are defined by automaton generator.  */
comment|/* The following field value is number of the automaton to which      given unit belongs.  */
name|int
name|corresponding_automaton_num
decl_stmt|;
comment|/* If the following value is not zero, the cpu unit is present in a      `exclusion_set' or in right part of a `presence_set',      `final_presence_set', `absence_set', and      `final_absence_set'define_query_cpu_unit.  */
name|char
name|in_set_p
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This describes define_bypass (see file rtl.def).  */
end_comment

begin_struct
struct|struct
name|bypass_decl
block|{
name|int
name|latency
decl_stmt|;
specifier|const
name|char
modifier|*
name|out_insn_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|in_insn_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|bypass_guard_name
decl_stmt|;
comment|/* The following fields are defined by checker.  */
comment|/* output and input insns of given bypass.  */
name|struct
name|insn_reserv_decl
modifier|*
name|out_insn_reserv
decl_stmt|;
name|struct
name|insn_reserv_decl
modifier|*
name|in_insn_reserv
decl_stmt|;
comment|/* The next bypass for given output insn.  */
name|struct
name|bypass_decl
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This describes define_automaton (see file rtl.def).  */
end_comment

begin_struct
struct|struct
name|automaton_decl
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* The following fields are defined by automaton generator.  */
comment|/* The following field value is nonzero if the automaton is used in      an regexp definition.  */
name|char
name|automaton_is_used
decl_stmt|;
comment|/* The following fields are defined by checker.  */
comment|/* The following field value is the corresponding automaton.  This      field is not NULL only if the automaton is present in unit      declarations and the automatic partition on automata is not      used.  */
name|automaton_t
name|corresponding_automaton
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This describes exclusion relations: exclusion_set (see file    rtl.def).  */
end_comment

begin_struct
struct|struct
name|excl_rel_decl
block|{
name|int
name|all_names_num
decl_stmt|;
name|int
name|first_list_length
decl_stmt|;
name|char
modifier|*
name|names
index|[
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This describes unit relations: [final_]presence_set or    [final_]absence_set (see file rtl.def).  */
end_comment

begin_struct
struct|struct
name|unit_pattern_rel_decl
block|{
name|int
name|final_p
decl_stmt|;
name|int
name|names_num
decl_stmt|;
name|int
name|patterns_num
decl_stmt|;
name|char
modifier|*
modifier|*
name|names
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|patterns
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This describes define_reservation (see file rtl.def).  */
end_comment

begin_struct
struct|struct
name|reserv_decl
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|regexp_t
name|regexp
decl_stmt|;
comment|/* The following fields are defined by checker.  */
comment|/* The following field value is nonzero if the unit is used in an      regexp.  */
name|char
name|reserv_is_used
decl_stmt|;
comment|/* The following field is used to check up cycle in expression      definition.  */
name|int
name|loop_pass_num
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This describes define_insn_reservation (see file rtl.def).  */
end_comment

begin_struct
struct|struct
name|insn_reserv_decl
block|{
name|rtx
name|condexp
decl_stmt|;
name|int
name|default_latency
decl_stmt|;
name|regexp_t
name|regexp
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* The following fields are defined by checker.  */
comment|/* The following field value is order number (0, 1, ...) of given      insn.  */
name|int
name|insn_num
decl_stmt|;
comment|/* The following field value is list of bypasses in which given insn      is output insn.  */
name|struct
name|bypass_decl
modifier|*
name|bypass_list
decl_stmt|;
comment|/* The following fields are defined by automaton generator.  */
comment|/* The following field is the insn regexp transformed that      the regexp has not optional regexp, repetition regexp, and an      reservation name (i.e. reservation identifiers are changed by the      corresponding regexp) and all alternations are the topest level      of the regexp.  The value can be NULL only if it is special      insn `cycle advancing'.  */
name|regexp_t
name|transformed_regexp
decl_stmt|;
comment|/* The following field value is list of arcs marked given      insn.  The field is used in transformation NDFA -> DFA.  */
name|arc_t
name|arcs_marked_by_insn
decl_stmt|;
comment|/* The two following fields are used during minimization of a finite state      automaton.  */
comment|/* The field value is number of equivalence class of state into      which arc marked by given insn enters from a state (fixed during      an automaton minimization).  */
name|int
name|equiv_class_num
decl_stmt|;
comment|/* The following member value is the list to automata which can be      changed by the insn issue.  */
name|automata_list_el_t
name|important_automata_list
decl_stmt|;
comment|/* The following member is used to process insn once for output.  */
name|int
name|processed_p
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This contains a declaration mentioned above.  */
end_comment

begin_struct
struct|struct
name|decl
block|{
comment|/* What node in the union? */
name|enum
name|decl_mode
name|mode
decl_stmt|;
name|pos_t
name|pos
decl_stmt|;
union|union
block|{
name|struct
name|unit_decl
name|unit
decl_stmt|;
name|struct
name|bypass_decl
name|bypass
decl_stmt|;
name|struct
name|automaton_decl
name|automaton
decl_stmt|;
name|struct
name|excl_rel_decl
name|excl
decl_stmt|;
name|struct
name|unit_pattern_rel_decl
name|presence
decl_stmt|;
name|struct
name|unit_pattern_rel_decl
name|absence
decl_stmt|;
name|struct
name|reserv_decl
name|reserv
decl_stmt|;
name|struct
name|insn_reserv_decl
name|insn_reserv
decl_stmt|;
block|}
name|decl
union|;
block|}
struct|;
end_struct

begin_comment
comment|/* The following structures represent parsed reservation strings.  */
end_comment

begin_enum
enum|enum
name|regexp_mode
block|{
name|rm_unit
block|,
name|rm_reserv
block|,
name|rm_nothing
block|,
name|rm_sequence
block|,
name|rm_repeat
block|,
name|rm_allof
block|,
name|rm_oneof
block|}
enum|;
end_enum

begin_comment
comment|/* Cpu unit in reservation.  */
end_comment

begin_struct
struct|struct
name|unit_regexp
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unit_decl_t
name|unit_decl
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Define_reservation in a reservation.  */
end_comment

begin_struct
struct|struct
name|reserv_regexp
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|reserv_decl
modifier|*
name|reserv_decl
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Absence of reservation (represented by string `nothing').  */
end_comment

begin_struct
struct|struct
name|nothing_regexp
block|{
comment|/* This used to be empty but ISO C doesn't allow that.  */
name|char
name|unused
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Representation of reservations separated by ',' (see file    rtl.def).  */
end_comment

begin_struct
struct|struct
name|sequence_regexp
block|{
name|int
name|regexps_num
decl_stmt|;
name|regexp_t
name|regexps
index|[
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Representation of construction `repeat' (see file rtl.def).  */
end_comment

begin_struct
struct|struct
name|repeat_regexp
block|{
name|int
name|repeat_num
decl_stmt|;
name|regexp_t
name|regexp
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Representation of reservations separated by '+' (see file    rtl.def).  */
end_comment

begin_struct
struct|struct
name|allof_regexp
block|{
name|int
name|regexps_num
decl_stmt|;
name|regexp_t
name|regexps
index|[
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Representation of reservations separated by '|' (see file    rtl.def).  */
end_comment

begin_struct
struct|struct
name|oneof_regexp
block|{
name|int
name|regexps_num
decl_stmt|;
name|regexp_t
name|regexps
index|[
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Representation of a reservation string.  */
end_comment

begin_struct
struct|struct
name|regexp
block|{
comment|/* What node in the union? */
name|enum
name|regexp_mode
name|mode
decl_stmt|;
name|pos_t
name|pos
decl_stmt|;
union|union
block|{
name|struct
name|unit_regexp
name|unit
decl_stmt|;
name|struct
name|reserv_regexp
name|reserv
decl_stmt|;
name|struct
name|nothing_regexp
name|nothing
decl_stmt|;
name|struct
name|sequence_regexp
name|sequence
decl_stmt|;
name|struct
name|repeat_regexp
name|repeat
decl_stmt|;
name|struct
name|allof_regexp
name|allof
decl_stmt|;
name|struct
name|oneof_regexp
name|oneof
decl_stmt|;
block|}
name|regexp
union|;
block|}
struct|;
end_struct

begin_comment
comment|/* Represents description of pipeline hazard description based on    NDFA.  */
end_comment

begin_struct
struct|struct
name|description
block|{
name|int
name|decls_num
decl_stmt|;
comment|/* The following fields are defined by checker.  */
comment|/* The following fields values are correspondingly number of all      units, query units, and insns in the description.  */
name|int
name|units_num
decl_stmt|;
name|int
name|query_units_num
decl_stmt|;
name|int
name|insns_num
decl_stmt|;
comment|/* The following field value is max length (in cycles) of      reservations of insns.  The field value is defined only for      correct programs.  */
name|int
name|max_insn_reserv_cycles
decl_stmt|;
comment|/* The following fields are defined by automaton generator.  */
comment|/* The following field value is the first automaton.  */
name|automaton_t
name|first_automaton
decl_stmt|;
comment|/* The following field is created by pipeline hazard parser and      contains all declarations.  We allocate additional entry for      special insn "cycle advancing" which is added by the automaton      generator.  */
name|decl_t
name|decls
index|[
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The following nodes are created in automaton checker.  */
end_comment

begin_comment
comment|/* The following nodes represent exclusion set for cpu units.  Each    element is accessed through only one excl_list.  */
end_comment

begin_struct
struct|struct
name|unit_set_el
block|{
name|unit_decl_t
name|unit_decl
decl_stmt|;
name|unit_set_el_t
name|next_unit_set_el
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The following nodes represent presence or absence pattern for cpu    units.  Each element is accessed through only one presence_list or    absence_list.  */
end_comment

begin_struct
struct|struct
name|pattern_set_el
block|{
comment|/* The number of units in unit_decls.  */
name|int
name|units_num
decl_stmt|;
comment|/* The units forming the pattern.  */
name|struct
name|unit_decl
modifier|*
modifier|*
name|unit_decls
decl_stmt|;
name|pattern_set_el_t
name|next_pattern_set_el
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The following nodes are created in automaton generator.  */
end_comment

begin_comment
comment|/* The following nodes represent presence or absence pattern for cpu    units.  Each element is accessed through only one element of    unit_presence_set_table or unit_absence_set_table.  */
end_comment

begin_struct
struct|struct
name|pattern_reserv
block|{
name|reserv_sets_t
name|reserv
decl_stmt|;
name|pattern_reserv_t
name|next_pattern_reserv
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The following node type describes state automaton.  The state may    be deterministic or non-deterministic.  Non-deterministic state has    several component states which represent alternative cpu units    reservations.  The state also is used for describing a    deterministic reservation of automaton insn.  */
end_comment

begin_struct
struct|struct
name|state
block|{
comment|/* The following member value is nonzero if there is a transition by      cycle advancing.  */
name|int
name|new_cycle_p
decl_stmt|;
comment|/* The following field is list of processor unit reservations on      each cycle.  */
name|reserv_sets_t
name|reservs
decl_stmt|;
comment|/* The following field is unique number of given state between other      states.  */
name|int
name|unique_num
decl_stmt|;
comment|/* The following field value is automaton to which given state      belongs.  */
name|automaton_t
name|automaton
decl_stmt|;
comment|/* The following field value is the first arc output from given      state.  */
name|arc_t
name|first_out_arc
decl_stmt|;
name|unsigned
name|int
name|num_out_arcs
decl_stmt|;
comment|/* The following field is used to form NDFA.  */
name|char
name|it_was_placed_in_stack_for_NDFA_forming
decl_stmt|;
comment|/* The following field is used to form DFA.  */
name|char
name|it_was_placed_in_stack_for_DFA_forming
decl_stmt|;
comment|/* The following field is used to transform NDFA to DFA and DFA      minimization.  The field value is not NULL if the state is a      compound state.  In this case the value of field `unit_sets_list'      is NULL.  All states in the list are in the hash table.  The list      is formed through field `next_sorted_alt_state'.  We should      support only one level of nesting state.  */
name|alt_state_t
name|component_states
decl_stmt|;
comment|/* The following field is used for passing graph of states.  */
name|int
name|pass_num
decl_stmt|;
comment|/* The list of states belonging to one equivalence class is formed      with the aid of the following field.  */
name|state_t
name|next_equiv_class_state
decl_stmt|;
comment|/* The two following fields are used during minimization of a finite      state automaton.  */
name|int
name|equiv_class_num_1
decl_stmt|,
name|equiv_class_num_2
decl_stmt|;
comment|/* The following field is used during minimization of a finite state      automaton.  The field value is state corresponding to equivalence      class to which given state belongs.  */
name|state_t
name|equiv_class_state
decl_stmt|;
name|unsigned
name|int
modifier|*
name|presence_signature
decl_stmt|;
comment|/* The following field value is the order number of given state.      The states in final DFA is enumerated with the aid of the      following field.  */
name|int
name|order_state_num
decl_stmt|;
comment|/* This member is used for passing states for searching minimal      delay time.  */
name|int
name|state_pass_num
decl_stmt|;
comment|/* The following member is used to evaluate min issue delay of insn      for a state.  */
name|int
name|min_insn_issue_delay
decl_stmt|;
comment|/* The following member is used to evaluate max issue rate of the      processor.  The value of the member is maximal length of the path      from given state no containing arcs marked by special insn `cycle      advancing'.  */
name|int
name|longest_path_length
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The following macro is an initial value of member    `longest_path_length' of a state.  */
end_comment

begin_define
define|#
directive|define
name|UNDEFINED_LONGEST_PATH_LENGTH
value|-1
end_define

begin_comment
comment|/* Automaton arc.  */
end_comment

begin_struct
struct|struct
name|arc
block|{
comment|/* The following field refers for the state into which given arc      enters.  */
name|state_t
name|to_state
decl_stmt|;
comment|/* The following field describes that the insn issue (with cycle      advancing for special insn `cycle advancing' and without cycle      advancing for others) makes transition from given state to      another given state.  */
name|ainsn_t
name|insn
decl_stmt|;
comment|/* The following field value is the next arc output from the same      state.  */
name|arc_t
name|next_out_arc
decl_stmt|;
comment|/* List of arcs marked given insn is formed with the following      field.  The field is used in transformation NDFA -> DFA.  */
name|arc_t
name|next_arc_marked_by_insn
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The following node type describes a deterministic alternative in    non-deterministic state which characterizes cpu unit reservations    of automaton insn or which is part of NDFA.  */
end_comment

begin_struct
struct|struct
name|alt_state
block|{
comment|/* The following field is a deterministic state which characterizes      unit reservations of the instruction.  */
name|state_t
name|state
decl_stmt|;
comment|/* The following field refers to the next state which characterizes      unit reservations of the instruction.  */
name|alt_state_t
name|next_alt_state
decl_stmt|;
comment|/* The following field refers to the next state in sorted list.  */
name|alt_state_t
name|next_sorted_alt_state
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The following node type describes insn of automaton.  They are    labels of FA arcs.  */
end_comment

begin_struct
struct|struct
name|ainsn
block|{
comment|/* The following field value is the corresponding insn declaration      of description.  */
name|struct
name|insn_reserv_decl
modifier|*
name|insn_reserv_decl
decl_stmt|;
comment|/* The following field value is the next insn declaration for an      automaton.  */
name|ainsn_t
name|next_ainsn
decl_stmt|;
comment|/* The following field is states which characterize automaton unit      reservations of the instruction.  The value can be NULL only if it      is special insn `cycle advancing'.  */
name|alt_state_t
name|alt_states
decl_stmt|;
comment|/* The following field is sorted list of states which characterize      automaton unit reservations of the instruction.  The value can be      NULL only if it is special insn `cycle advancing'.  */
name|alt_state_t
name|sorted_alt_states
decl_stmt|;
comment|/* The following field refers the next automaton insn with      the same reservations.  */
name|ainsn_t
name|next_same_reservs_insn
decl_stmt|;
comment|/* The following field is flag of the first automaton insn with the      same reservations in the declaration list.  Only arcs marked such      insn is present in the automaton.  This significantly decreases      memory requirements especially when several automata are      formed.  */
name|char
name|first_insn_with_same_reservs
decl_stmt|;
comment|/* The following member has nonzero value if there is arc from state of      the automaton marked by the ainsn.  */
name|char
name|arc_exists_p
decl_stmt|;
comment|/* Cyclic list of insns of an equivalence class is formed with the      aid of the following field.  */
name|ainsn_t
name|next_equiv_class_insn
decl_stmt|;
comment|/* The following field value is nonzero if the insn declaration is      the first insn declaration with given equivalence number.  */
name|char
name|first_ainsn_with_given_equivalence_num
decl_stmt|;
comment|/* The following field is number of class of equivalence of insns.      It is necessary because many insns may be equivalent with the      point of view of pipeline hazards.  */
name|int
name|insn_equiv_class_num
decl_stmt|;
comment|/* The following member value is TRUE if there is an arc in the      automaton marked by the insn into another state.  In other      words, the insn can change the state of the automaton.  */
name|int
name|important_p
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The following describes an automaton for PHR.  */
end_comment

begin_struct
struct|struct
name|automaton
block|{
comment|/* The following field value is the list of insn declarations for      given automaton.  */
name|ainsn_t
name|ainsn_list
decl_stmt|;
comment|/* The following field value is the corresponding automaton      declaration.  This field is not NULL only if the automatic      partition on automata is not used.  */
name|struct
name|automaton_decl
modifier|*
name|corresponding_automaton_decl
decl_stmt|;
comment|/* The following field value is the next automaton.  */
name|automaton_t
name|next_automaton
decl_stmt|;
comment|/* The following field is start state of FA.  There are not unit      reservations in the state.  */
name|state_t
name|start_state
decl_stmt|;
comment|/* The following field value is number of equivalence classes of      insns (see field `insn_equiv_class_num' in      `insn_reserv_decl').  */
name|int
name|insn_equiv_classes_num
decl_stmt|;
comment|/* The following field value is number of states of final DFA.  */
name|int
name|achieved_states_num
decl_stmt|;
comment|/* The following field value is the order number (0, 1, ...) of      given automaton.  */
name|int
name|automaton_order_num
decl_stmt|;
comment|/* The following fields contain statistics information about      building automaton.  */
name|int
name|NDFA_states_num
decl_stmt|,
name|DFA_states_num
decl_stmt|;
comment|/* The following field value is defined only if minimization of DFA      is used.  */
name|int
name|minimal_DFA_states_num
decl_stmt|;
name|int
name|NDFA_arcs_num
decl_stmt|,
name|DFA_arcs_num
decl_stmt|;
comment|/* The following field value is defined only if minimization of DFA      is used.  */
name|int
name|minimal_DFA_arcs_num
decl_stmt|;
comment|/* The following member refers for two table state x ainsn -> int.      ??? Above sentence is incomprehensible.  */
name|state_ainsn_table_t
name|trans_table
decl_stmt|;
comment|/* The following member value is maximal value of min issue delay      for insns of the automaton.  */
name|int
name|max_min_delay
decl_stmt|;
comment|/* Usually min issue delay is small and we can place several (2, 4,      8) elements in one vector element.  So the compression factor can      be 1 (no compression), 2, 4, 8.  */
name|int
name|min_issue_delay_table_compression_factor
decl_stmt|;
comment|/* Total number of locked states in this automaton.  */
name|int
name|locked_states
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The following is the element of the list of automata.  */
end_comment

begin_struct
struct|struct
name|automata_list_el
block|{
comment|/* The automaton itself.  */
name|automaton_t
name|automaton
decl_stmt|;
comment|/* The next automata set element.  */
name|automata_list_el_t
name|next_automata_list_el
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The following structure describes a table state X ainsn -> int(>= 0).  */
end_comment

begin_struct
struct|struct
name|state_ainsn_table
block|{
comment|/* Automaton to which given table belongs.  */
name|automaton_t
name|automaton
decl_stmt|;
comment|/* The following tree vectors for comb vector implementation of the      table.  */
name|vla_hwint_t
name|comb_vect
decl_stmt|;
name|vla_hwint_t
name|check_vect
decl_stmt|;
name|vla_hwint_t
name|base_vect
decl_stmt|;
comment|/* This is simple implementation of the table.  */
name|vla_hwint_t
name|full_vect
decl_stmt|;
comment|/* Minimal and maximal values of the previous vectors.  */
name|int
name|min_comb_vect_el_value
decl_stmt|,
name|max_comb_vect_el_value
decl_stmt|;
name|int
name|min_base_vect_el_value
decl_stmt|,
name|max_base_vect_el_value
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Macros to access members of unions.  Use only them for access to    union members of declarations and regexps.  */
end_comment

begin_if
if|#
directive|if
name|defined
name|ENABLE_CHECKING
operator|&&
operator|(
name|GCC_VERSION
operator|>=
literal|2007
operator|)
end_if

begin_define
define|#
directive|define
name|DECL_UNIT
parameter_list|(
name|d
parameter_list|)
value|__extension__					\ (({ struct decl *const _decl = (d);					\      if (_decl->mode != dm_unit)					\        decl_mode_check_failed (_decl->mode, "dm_unit",			\ 			       __FILE__, __LINE__, __FUNCTION__);	\&(_decl)->decl.unit; }))
end_define

begin_define
define|#
directive|define
name|DECL_BYPASS
parameter_list|(
name|d
parameter_list|)
value|__extension__					\ (({ struct decl *const _decl = (d);					\      if (_decl->mode != dm_bypass)					\        decl_mode_check_failed (_decl->mode, "dm_bypass",		\ 			       __FILE__, __LINE__, __FUNCTION__);	\&(_decl)->decl.bypass; }))
end_define

begin_define
define|#
directive|define
name|DECL_AUTOMATON
parameter_list|(
name|d
parameter_list|)
value|__extension__					\ (({ struct decl *const _decl = (d);					\      if (_decl->mode != dm_automaton)					\        decl_mode_check_failed (_decl->mode, "dm_automaton",		\ 			       __FILE__, __LINE__, __FUNCTION__);	\&(_decl)->decl.automaton; }))
end_define

begin_define
define|#
directive|define
name|DECL_EXCL
parameter_list|(
name|d
parameter_list|)
value|__extension__					\ (({ struct decl *const _decl = (d);					\      if (_decl->mode != dm_excl)					\        decl_mode_check_failed (_decl->mode, "dm_excl",			\ 			       __FILE__, __LINE__, __FUNCTION__);	\&(_decl)->decl.excl; }))
end_define

begin_define
define|#
directive|define
name|DECL_PRESENCE
parameter_list|(
name|d
parameter_list|)
value|__extension__					\ (({ struct decl *const _decl = (d);					\      if (_decl->mode != dm_presence)					\        decl_mode_check_failed (_decl->mode, "dm_presence",		\ 			       __FILE__, __LINE__, __FUNCTION__);	\&(_decl)->decl.presence; }))
end_define

begin_define
define|#
directive|define
name|DECL_ABSENCE
parameter_list|(
name|d
parameter_list|)
value|__extension__					\ (({ struct decl *const _decl = (d);					\      if (_decl->mode != dm_absence)					\        decl_mode_check_failed (_decl->mode, "dm_absence",		\ 			       __FILE__, __LINE__, __FUNCTION__);	\&(_decl)->decl.absence; }))
end_define

begin_define
define|#
directive|define
name|DECL_RESERV
parameter_list|(
name|d
parameter_list|)
value|__extension__					\ (({ struct decl *const _decl = (d);					\      if (_decl->mode != dm_reserv)					\        decl_mode_check_failed (_decl->mode, "dm_reserv",		\ 			       __FILE__, __LINE__, __FUNCTION__);	\&(_decl)->decl.reserv; }))
end_define

begin_define
define|#
directive|define
name|DECL_INSN_RESERV
parameter_list|(
name|d
parameter_list|)
value|__extension__				\ (({ struct decl *const _decl = (d);					\      if (_decl->mode != dm_insn_reserv)					\        decl_mode_check_failed (_decl->mode, "dm_insn_reserv",		\ 			       __FILE__, __LINE__, __FUNCTION__);	\&(_decl)->decl.insn_reserv; }))
end_define

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|decl_name
parameter_list|(
name|enum
name|decl_mode
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|decl_mode_check_failed
argument_list|(
expr|enum
name|decl_mode
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|int
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
name|ATTRIBUTE_NORETURN
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return string representation of declaration mode MODE.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|decl_name
parameter_list|(
name|enum
name|decl_mode
name|mode
parameter_list|)
block|{
specifier|static
name|char
name|str
index|[
literal|100
index|]
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|dm_unit
condition|)
return|return
literal|"dm_unit"
return|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|dm_bypass
condition|)
return|return
literal|"dm_bypass"
return|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|dm_automaton
condition|)
return|return
literal|"dm_automaton"
return|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|dm_excl
condition|)
return|return
literal|"dm_excl"
return|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|dm_presence
condition|)
return|return
literal|"dm_presence"
return|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|dm_absence
condition|)
return|return
literal|"dm_absence"
return|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|dm_reserv
condition|)
return|return
literal|"dm_reserv"
return|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|dm_insn_reserv
condition|)
return|return
literal|"dm_insn_reserv"
return|;
else|else
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"unknown (%d)"
argument_list|,
operator|(
name|int
operator|)
name|mode
argument_list|)
expr_stmt|;
return|return
name|str
return|;
block|}
end_function

begin_comment
comment|/* The function prints message about unexpected declaration and finish    the program.  */
end_comment

begin_function
specifier|static
name|void
name|decl_mode_check_failed
parameter_list|(
name|enum
name|decl_mode
name|mode
parameter_list|,
specifier|const
name|char
modifier|*
name|expected_mode_str
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|func
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n%s: %d: error in %s: DECL check: expected decl %s, have %s\n"
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|func
argument_list|,
name|expected_mode_str
argument_list|,
name|decl_name
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|REGEXP_UNIT
parameter_list|(
name|r
parameter_list|)
value|__extension__					\ (({ struct regexp *const _regexp = (r);					\      if (_regexp->mode != rm_unit)					\        regexp_mode_check_failed (_regexp->mode, "rm_unit",		\ 			       __FILE__, __LINE__, __FUNCTION__);	\&(_regexp)->regexp.unit; }))
end_define

begin_define
define|#
directive|define
name|REGEXP_RESERV
parameter_list|(
name|r
parameter_list|)
value|__extension__					\ (({ struct regexp *const _regexp = (r);					\      if (_regexp->mode != rm_reserv)					\        regexp_mode_check_failed (_regexp->mode, "rm_reserv",		\ 			       __FILE__, __LINE__, __FUNCTION__);	\&(_regexp)->regexp.reserv; }))
end_define

begin_define
define|#
directive|define
name|REGEXP_SEQUENCE
parameter_list|(
name|r
parameter_list|)
value|__extension__				\ (({ struct regexp *const _regexp = (r);					\      if (_regexp->mode != rm_sequence)					\        regexp_mode_check_failed (_regexp->mode, "rm_sequence",		\ 			       __FILE__, __LINE__, __FUNCTION__);	\&(_regexp)->regexp.sequence; }))
end_define

begin_define
define|#
directive|define
name|REGEXP_REPEAT
parameter_list|(
name|r
parameter_list|)
value|__extension__					\ (({ struct regexp *const _regexp = (r);					\      if (_regexp->mode != rm_repeat)					\        regexp_mode_check_failed (_regexp->mode, "rm_repeat",		\ 			       __FILE__, __LINE__, __FUNCTION__);	\&(_regexp)->regexp.repeat; }))
end_define

begin_define
define|#
directive|define
name|REGEXP_ALLOF
parameter_list|(
name|r
parameter_list|)
value|__extension__					\ (({ struct regexp *const _regexp = (r);					\      if (_regexp->mode != rm_allof)					\        regexp_mode_check_failed (_regexp->mode, "rm_allof",		\ 			       __FILE__, __LINE__, __FUNCTION__);	\&(_regexp)->regexp.allof; }))
end_define

begin_define
define|#
directive|define
name|REGEXP_ONEOF
parameter_list|(
name|r
parameter_list|)
value|__extension__					\ (({ struct regexp *const _regexp = (r);					\      if (_regexp->mode != rm_oneof)					\        regexp_mode_check_failed (_regexp->mode, "rm_oneof",		\ 			       __FILE__, __LINE__, __FUNCTION__);	\&(_regexp)->regexp.oneof; }))
end_define

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|regexp_name
parameter_list|(
name|enum
name|regexp_mode
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|regexp_mode_check_failed
argument_list|(
expr|enum
name|regexp_mode
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|int
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
name|ATTRIBUTE_NORETURN
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return string representation of regexp mode MODE.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|regexp_name
parameter_list|(
name|enum
name|regexp_mode
name|mode
parameter_list|)
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|rm_unit
case|:
return|return
literal|"rm_unit"
return|;
case|case
name|rm_reserv
case|:
return|return
literal|"rm_reserv"
return|;
case|case
name|rm_nothing
case|:
return|return
literal|"rm_nothing"
return|;
case|case
name|rm_sequence
case|:
return|return
literal|"rm_sequence"
return|;
case|case
name|rm_repeat
case|:
return|return
literal|"rm_repeat"
return|;
case|case
name|rm_allof
case|:
return|return
literal|"rm_allof"
return|;
case|case
name|rm_oneof
case|:
return|return
literal|"rm_oneof"
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The function prints message about unexpected regexp and finish the    program.  */
end_comment

begin_function
specifier|static
name|void
name|regexp_mode_check_failed
parameter_list|(
name|enum
name|regexp_mode
name|mode
parameter_list|,
specifier|const
name|char
modifier|*
name|expected_mode_str
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|func
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n%s: %d: error in %s: REGEXP check: expected decl %s, have %s\n"
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|func
argument_list|,
name|expected_mode_str
argument_list|,
name|regexp_name
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* #if defined ENABLE_RTL_CHECKING&& (GCC_VERSION>= 2007) */
end_comment

begin_define
define|#
directive|define
name|DECL_UNIT
parameter_list|(
name|d
parameter_list|)
value|(&(d)->decl.unit)
end_define

begin_define
define|#
directive|define
name|DECL_BYPASS
parameter_list|(
name|d
parameter_list|)
value|(&(d)->decl.bypass)
end_define

begin_define
define|#
directive|define
name|DECL_AUTOMATON
parameter_list|(
name|d
parameter_list|)
value|(&(d)->decl.automaton)
end_define

begin_define
define|#
directive|define
name|DECL_EXCL
parameter_list|(
name|d
parameter_list|)
value|(&(d)->decl.excl)
end_define

begin_define
define|#
directive|define
name|DECL_PRESENCE
parameter_list|(
name|d
parameter_list|)
value|(&(d)->decl.presence)
end_define

begin_define
define|#
directive|define
name|DECL_ABSENCE
parameter_list|(
name|d
parameter_list|)
value|(&(d)->decl.absence)
end_define

begin_define
define|#
directive|define
name|DECL_RESERV
parameter_list|(
name|d
parameter_list|)
value|(&(d)->decl.reserv)
end_define

begin_define
define|#
directive|define
name|DECL_INSN_RESERV
parameter_list|(
name|d
parameter_list|)
value|(&(d)->decl.insn_reserv)
end_define

begin_define
define|#
directive|define
name|REGEXP_UNIT
parameter_list|(
name|r
parameter_list|)
value|(&(r)->regexp.unit)
end_define

begin_define
define|#
directive|define
name|REGEXP_RESERV
parameter_list|(
name|r
parameter_list|)
value|(&(r)->regexp.reserv)
end_define

begin_define
define|#
directive|define
name|REGEXP_SEQUENCE
parameter_list|(
name|r
parameter_list|)
value|(&(r)->regexp.sequence)
end_define

begin_define
define|#
directive|define
name|REGEXP_REPEAT
parameter_list|(
name|r
parameter_list|)
value|(&(r)->regexp.repeat)
end_define

begin_define
define|#
directive|define
name|REGEXP_ALLOF
parameter_list|(
name|r
parameter_list|)
value|(&(r)->regexp.allof)
end_define

begin_define
define|#
directive|define
name|REGEXP_ONEOF
parameter_list|(
name|r
parameter_list|)
value|(&(r)->regexp.oneof)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* #if defined ENABLE_RTL_CHECKING&& (GCC_VERSION>= 2007) */
end_comment

begin_comment
comment|/* Create IR structure (node).  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|create_node
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|result
decl_stmt|;
name|obstack_blank
argument_list|(
operator|&
name|irp
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|result
operator|=
name|obstack_base
argument_list|(
operator|&
name|irp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|obstack_finish
argument_list|(
operator|&
name|irp
argument_list|)
expr_stmt|;
comment|/* Default values of members are NULL and zero.  */
name|memset
argument_list|(
name|result
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Copy IR structure (node).  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|copy_node
parameter_list|(
specifier|const
name|void
modifier|*
name|from
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
specifier|const
name|result
init|=
name|create_node
argument_list|(
name|size
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|result
argument_list|,
name|from
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* The function checks that NAME does not contain quotes (`"').  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|check_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|pos_t
name|pos
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
for|for
control|(
name|str
operator|=
name|name
init|;
operator|*
name|str
operator|!=
literal|'\0'
condition|;
name|str
operator|++
control|)
if|if
condition|(
operator|*
name|str
operator|==
literal|'\"'
condition|)
name|error
argument_list|(
literal|"Name `%s' contains quotes"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|name
return|;
block|}
end_function

begin_comment
comment|/* Pointers to all declarations during IR generation are stored in the    following.  */
end_comment

begin_expr_stmt
specifier|static
name|VEC
argument_list|(
name|decl_t
argument_list|,
name|heap
argument_list|)
operator|*
name|decls
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Given a pointer to a (char *) and a separator, return an alloc'ed    string containing the next separated element, taking parentheses    into account if PAR_FLAG has nonzero value.  Advance the pointer to    after the string scanned, or the end-of-string.  Return NULL if at    end of string.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|next_sep_el
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|pstr
parameter_list|,
name|int
name|sep
parameter_list|,
name|int
name|par_flag
parameter_list|)
block|{
name|char
modifier|*
name|out_str
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|pars_num
decl_stmt|;
name|int
name|n_spaces
decl_stmt|;
comment|/* Remove leading whitespaces.  */
while|while
condition|(
name|ISSPACE
argument_list|(
operator|(
name|int
operator|)
operator|*
operator|*
name|pstr
argument_list|)
condition|)
operator|(
operator|*
name|pstr
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pstr
operator|==
literal|'\0'
condition|)
return|return
name|NULL
return|;
name|n_spaces
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|pars_num
operator|=
literal|0
operator|,
name|p
operator|=
operator|*
name|pstr
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|par_flag
operator|&&
operator|*
name|p
operator|==
literal|'('
condition|)
name|pars_num
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|par_flag
operator|&&
operator|*
name|p
operator|==
literal|')'
condition|)
name|pars_num
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
name|pars_num
operator|==
literal|0
operator|&&
operator|*
name|p
operator|==
name|sep
condition|)
break|break;
if|if
condition|(
name|pars_num
operator|==
literal|0
operator|&&
name|ISSPACE
argument_list|(
operator|(
name|int
operator|)
operator|*
name|p
argument_list|)
condition|)
name|n_spaces
operator|++
expr_stmt|;
else|else
block|{
for|for
control|(
init|;
name|n_spaces
operator|!=
literal|0
condition|;
name|n_spaces
operator|--
control|)
name|obstack_1grow
argument_list|(
operator|&
name|irp
argument_list|,
name|p
index|[
operator|-
name|n_spaces
index|]
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|irp
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
block|}
name|obstack_1grow
argument_list|(
operator|&
name|irp
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
name|out_str
operator|=
name|obstack_base
argument_list|(
operator|&
name|irp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|obstack_finish
argument_list|(
operator|&
name|irp
argument_list|)
expr_stmt|;
operator|*
name|pstr
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pstr
operator|==
name|sep
condition|)
operator|(
operator|*
name|pstr
operator|)
operator|++
expr_stmt|;
return|return
name|out_str
return|;
block|}
end_function

begin_comment
comment|/* Given a string and a separator, return the number of separated    elements in it, taking parentheses into account if PAR_FLAG has    nonzero value.  Return 0 for the null string, -1 if parentheses is    not balanced.  */
end_comment

begin_function
specifier|static
name|int
name|n_sep_els
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
name|sep
parameter_list|,
name|int
name|par_flag
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|int
name|pars_num
decl_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
for|for
control|(
name|pars_num
operator|=
literal|0
operator|,
name|n
operator|=
literal|1
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
if|if
condition|(
name|par_flag
operator|&&
operator|*
name|s
operator|==
literal|'('
condition|)
name|pars_num
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|par_flag
operator|&&
operator|*
name|s
operator|==
literal|')'
condition|)
name|pars_num
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
name|pars_num
operator|==
literal|0
operator|&&
operator|*
name|s
operator|==
name|sep
condition|)
name|n
operator|++
expr_stmt|;
return|return
operator|(
name|pars_num
operator|!=
literal|0
condition|?
operator|-
literal|1
else|:
name|n
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Given a string and a separator, return vector of strings which are    elements in the string and number of elements through els_num.    Take parentheses into account if PAREN_P has nonzero value.  The    function also inserts the end marker NULL at the end of vector.    Return 0 for the null string, -1 if parentheses are not balanced.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
modifier|*
name|get_str_vect
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
modifier|*
name|els_num
parameter_list|,
name|int
name|sep
parameter_list|,
name|int
name|paren_p
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
modifier|*
name|vect
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|pstr
decl_stmt|;
name|char
modifier|*
name|trail
decl_stmt|;
operator|*
name|els_num
operator|=
name|n_sep_els
argument_list|(
name|str
argument_list|,
name|sep
argument_list|,
name|paren_p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|els_num
operator|<=
literal|0
condition|)
return|return
name|NULL
return|;
name|obstack_blank
argument_list|(
operator|&
name|irp
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
operator|*
name|els_num
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|vect
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|obstack_base
argument_list|(
operator|&
name|irp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|obstack_finish
argument_list|(
operator|&
name|irp
argument_list|)
expr_stmt|;
name|pstr
operator|=
operator|&
name|str
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|*
name|els_num
condition|;
name|i
operator|++
control|)
name|vect
index|[
name|i
index|]
operator|=
name|next_sep_el
argument_list|(
name|pstr
argument_list|,
name|sep
argument_list|,
name|paren_p
argument_list|)
expr_stmt|;
name|trail
operator|=
name|next_sep_el
argument_list|(
name|pstr
argument_list|,
name|sep
argument_list|,
name|paren_p
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|trail
argument_list|)
expr_stmt|;
name|vect
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|vect
return|;
block|}
end_function

begin_comment
comment|/* Process a DEFINE_CPU_UNIT.     This gives information about a unit contained in CPU.  We fill a    struct unit_decl with information used later by `expand_automata'.  */
end_comment

begin_function
specifier|static
name|void
name|gen_cpu_unit
parameter_list|(
name|rtx
name|def
parameter_list|)
block|{
name|decl_t
name|decl
decl_stmt|;
name|char
modifier|*
modifier|*
name|str_cpu_units
decl_stmt|;
name|int
name|vect_length
decl_stmt|;
name|int
name|i
decl_stmt|;
name|str_cpu_units
operator|=
name|get_str_vect
argument_list|(
name|XSTR
argument_list|(
name|def
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|vect_length
argument_list|,
literal|','
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|str_cpu_units
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"invalid string `%s' in define_cpu_unit"
argument_list|,
name|XSTR
argument_list|(
name|def
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vect_length
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|decl
operator|->
name|mode
operator|=
name|dm_unit
expr_stmt|;
name|decl
operator|->
name|pos
operator|=
literal|0
expr_stmt|;
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|name
operator|=
name|check_name
argument_list|(
name|str_cpu_units
index|[
name|i
index|]
argument_list|,
name|decl
operator|->
name|pos
argument_list|)
expr_stmt|;
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|automaton_name
operator|=
name|XSTR
argument_list|(
name|def
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|query_p
operator|=
literal|0
expr_stmt|;
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|min_occ_cycle_num
operator|=
operator|-
literal|1
expr_stmt|;
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|in_set_p
operator|=
literal|0
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|decl_t
argument_list|,
name|heap
argument_list|,
name|decls
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Process a DEFINE_QUERY_CPU_UNIT.     This gives information about a unit contained in CPU.  We fill a    struct unit_decl with information used later by `expand_automata'.  */
end_comment

begin_function
specifier|static
name|void
name|gen_query_cpu_unit
parameter_list|(
name|rtx
name|def
parameter_list|)
block|{
name|decl_t
name|decl
decl_stmt|;
name|char
modifier|*
modifier|*
name|str_cpu_units
decl_stmt|;
name|int
name|vect_length
decl_stmt|;
name|int
name|i
decl_stmt|;
name|str_cpu_units
operator|=
name|get_str_vect
argument_list|(
name|XSTR
argument_list|(
name|def
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|vect_length
argument_list|,
literal|','
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|str_cpu_units
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"invalid string `%s' in define_query_cpu_unit"
argument_list|,
name|XSTR
argument_list|(
name|def
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vect_length
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|decl
operator|->
name|mode
operator|=
name|dm_unit
expr_stmt|;
name|decl
operator|->
name|pos
operator|=
literal|0
expr_stmt|;
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|name
operator|=
name|check_name
argument_list|(
name|str_cpu_units
index|[
name|i
index|]
argument_list|,
name|decl
operator|->
name|pos
argument_list|)
expr_stmt|;
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|automaton_name
operator|=
name|XSTR
argument_list|(
name|def
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|query_p
operator|=
literal|1
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|decl_t
argument_list|,
name|heap
argument_list|,
name|decls
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Process a DEFINE_BYPASS.     This gives information about a unit contained in the CPU.  We fill    in a struct bypass_decl with information used later by    `expand_automata'.  */
end_comment

begin_function
specifier|static
name|void
name|gen_bypass
parameter_list|(
name|rtx
name|def
parameter_list|)
block|{
name|decl_t
name|decl
decl_stmt|;
name|char
modifier|*
modifier|*
name|out_insns
decl_stmt|;
name|int
name|out_length
decl_stmt|;
name|char
modifier|*
modifier|*
name|in_insns
decl_stmt|;
name|int
name|in_length
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|out_insns
operator|=
name|get_str_vect
argument_list|(
name|XSTR
argument_list|(
name|def
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|&
name|out_length
argument_list|,
literal|','
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|out_insns
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"invalid string `%s' in define_bypass"
argument_list|,
name|XSTR
argument_list|(
name|def
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|in_insns
operator|=
name|get_str_vect
argument_list|(
name|XSTR
argument_list|(
name|def
argument_list|,
literal|2
argument_list|)
argument_list|,
operator|&
name|in_length
argument_list|,
literal|','
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_insns
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"invalid string `%s' in define_bypass"
argument_list|,
name|XSTR
argument_list|(
name|def
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|out_length
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|in_length
condition|;
name|j
operator|++
control|)
block|{
name|decl
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|decl
operator|->
name|mode
operator|=
name|dm_bypass
expr_stmt|;
name|decl
operator|->
name|pos
operator|=
literal|0
expr_stmt|;
name|DECL_BYPASS
argument_list|(
name|decl
argument_list|)
operator|->
name|latency
operator|=
name|XINT
argument_list|(
name|def
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DECL_BYPASS
argument_list|(
name|decl
argument_list|)
operator|->
name|out_insn_name
operator|=
name|out_insns
index|[
name|i
index|]
expr_stmt|;
name|DECL_BYPASS
argument_list|(
name|decl
argument_list|)
operator|->
name|in_insn_name
operator|=
name|in_insns
index|[
name|j
index|]
expr_stmt|;
name|DECL_BYPASS
argument_list|(
name|decl
argument_list|)
operator|->
name|bypass_guard_name
operator|=
name|XSTR
argument_list|(
name|def
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|decl_t
argument_list|,
name|heap
argument_list|,
name|decls
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Process an EXCLUSION_SET.     This gives information about a cpu unit conflicts.  We fill a    struct excl_rel_decl (excl) with information used later by    `expand_automata'.  */
end_comment

begin_function
specifier|static
name|void
name|gen_excl_set
parameter_list|(
name|rtx
name|def
parameter_list|)
block|{
name|decl_t
name|decl
decl_stmt|;
name|char
modifier|*
modifier|*
name|first_str_cpu_units
decl_stmt|;
name|char
modifier|*
modifier|*
name|second_str_cpu_units
decl_stmt|;
name|int
name|first_vect_length
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|i
decl_stmt|;
name|first_str_cpu_units
operator|=
name|get_str_vect
argument_list|(
name|XSTR
argument_list|(
name|def
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|first_vect_length
argument_list|,
literal|','
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_str_cpu_units
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"invalid first string `%s' in exclusion_set"
argument_list|,
name|XSTR
argument_list|(
name|def
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|second_str_cpu_units
operator|=
name|get_str_vect
argument_list|(
name|XSTR
argument_list|(
name|def
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|&
name|length
argument_list|,
literal|','
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|second_str_cpu_units
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"invalid second string `%s' in exclusion_set"
argument_list|,
name|XSTR
argument_list|(
name|def
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|length
operator|+=
name|first_vect_length
expr_stmt|;
name|decl
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|decl
argument_list|)
operator|+
operator|(
name|length
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|decl
operator|->
name|mode
operator|=
name|dm_excl
expr_stmt|;
name|decl
operator|->
name|pos
operator|=
literal|0
expr_stmt|;
name|DECL_EXCL
argument_list|(
name|decl
argument_list|)
operator|->
name|all_names_num
operator|=
name|length
expr_stmt|;
name|DECL_EXCL
argument_list|(
name|decl
argument_list|)
operator|->
name|first_list_length
operator|=
name|first_vect_length
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|i
operator|<
name|first_vect_length
condition|)
name|DECL_EXCL
argument_list|(
name|decl
argument_list|)
operator|->
name|names
index|[
name|i
index|]
operator|=
name|first_str_cpu_units
index|[
name|i
index|]
expr_stmt|;
else|else
name|DECL_EXCL
argument_list|(
name|decl
argument_list|)
operator|->
name|names
index|[
name|i
index|]
operator|=
name|second_str_cpu_units
index|[
name|i
operator|-
name|first_vect_length
index|]
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|decl_t
argument_list|,
name|heap
argument_list|,
name|decls
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process a PRESENCE_SET, a FINAL_PRESENCE_SET, an ABSENCE_SET,    FINAL_ABSENCE_SET (it is depended on PRESENCE_P and FINAL_P).     This gives information about a cpu unit reservation requirements.    We fill a struct unit_pattern_rel_decl with information used later    by `expand_automata'.  */
end_comment

begin_function
specifier|static
name|void
name|gen_presence_absence_set
parameter_list|(
name|rtx
name|def
parameter_list|,
name|int
name|presence_p
parameter_list|,
name|int
name|final_p
parameter_list|)
block|{
name|decl_t
name|decl
decl_stmt|;
name|char
modifier|*
modifier|*
name|str_cpu_units
decl_stmt|;
name|char
modifier|*
modifier|*
name|str_pattern_lists
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|str_patterns
decl_stmt|;
name|int
name|cpu_units_length
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|patterns_length
decl_stmt|;
name|int
name|i
decl_stmt|;
name|str_cpu_units
operator|=
name|get_str_vect
argument_list|(
name|XSTR
argument_list|(
name|def
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|cpu_units_length
argument_list|,
literal|','
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|str_cpu_units
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
operator|(
name|presence_p
condition|?
operator|(
name|final_p
condition|?
literal|"invalid first string `%s' in final_presence_set"
else|:
literal|"invalid first string `%s' in presence_set"
operator|)
else|:
operator|(
name|final_p
condition|?
literal|"invalid first string `%s' in final_absence_set"
else|:
literal|"invalid first string `%s' in absence_set"
operator|)
operator|)
argument_list|,
name|XSTR
argument_list|(
name|def
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|str_pattern_lists
operator|=
name|get_str_vect
argument_list|(
name|XSTR
argument_list|(
name|def
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|&
name|patterns_length
argument_list|,
literal|','
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|str_pattern_lists
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
operator|(
name|presence_p
condition|?
operator|(
name|final_p
condition|?
literal|"invalid second string `%s' in final_presence_set"
else|:
literal|"invalid second string `%s' in presence_set"
operator|)
else|:
operator|(
name|final_p
condition|?
literal|"invalid second string `%s' in final_absence_set"
else|:
literal|"invalid second string `%s' in absence_set"
operator|)
operator|)
argument_list|,
name|XSTR
argument_list|(
name|def
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|str_patterns
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|irp
argument_list|,
name|patterns_length
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|patterns_length
condition|;
name|i
operator|++
control|)
block|{
name|str_patterns
index|[
name|i
index|]
operator|=
name|get_str_vect
argument_list|(
name|str_pattern_lists
index|[
name|i
index|]
argument_list|,
operator|&
name|length
argument_list|,
literal|' '
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|str_patterns
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|decl
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|decl
operator|->
name|pos
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|presence_p
condition|)
block|{
name|decl
operator|->
name|mode
operator|=
name|dm_presence
expr_stmt|;
name|DECL_PRESENCE
argument_list|(
name|decl
argument_list|)
operator|->
name|names_num
operator|=
name|cpu_units_length
expr_stmt|;
name|DECL_PRESENCE
argument_list|(
name|decl
argument_list|)
operator|->
name|names
operator|=
name|str_cpu_units
expr_stmt|;
name|DECL_PRESENCE
argument_list|(
name|decl
argument_list|)
operator|->
name|patterns
operator|=
name|str_patterns
expr_stmt|;
name|DECL_PRESENCE
argument_list|(
name|decl
argument_list|)
operator|->
name|patterns_num
operator|=
name|patterns_length
expr_stmt|;
name|DECL_PRESENCE
argument_list|(
name|decl
argument_list|)
operator|->
name|final_p
operator|=
name|final_p
expr_stmt|;
block|}
else|else
block|{
name|decl
operator|->
name|mode
operator|=
name|dm_absence
expr_stmt|;
name|DECL_ABSENCE
argument_list|(
name|decl
argument_list|)
operator|->
name|names_num
operator|=
name|cpu_units_length
expr_stmt|;
name|DECL_ABSENCE
argument_list|(
name|decl
argument_list|)
operator|->
name|names
operator|=
name|str_cpu_units
expr_stmt|;
name|DECL_ABSENCE
argument_list|(
name|decl
argument_list|)
operator|->
name|patterns
operator|=
name|str_patterns
expr_stmt|;
name|DECL_ABSENCE
argument_list|(
name|decl
argument_list|)
operator|->
name|patterns_num
operator|=
name|patterns_length
expr_stmt|;
name|DECL_ABSENCE
argument_list|(
name|decl
argument_list|)
operator|->
name|final_p
operator|=
name|final_p
expr_stmt|;
block|}
name|VEC_safe_push
argument_list|(
name|decl_t
argument_list|,
name|heap
argument_list|,
name|decls
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process a PRESENCE_SET.      This gives information about a cpu unit reservation requirements.    We fill a struct unit_pattern_rel_decl (presence) with information    used later by `expand_automata'.  */
end_comment

begin_function
specifier|static
name|void
name|gen_presence_set
parameter_list|(
name|rtx
name|def
parameter_list|)
block|{
name|gen_presence_absence_set
argument_list|(
name|def
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process a FINAL_PRESENCE_SET.     This gives information about a cpu unit reservation requirements.    We fill a struct unit_pattern_rel_decl (presence) with information    used later by `expand_automata'.  */
end_comment

begin_function
specifier|static
name|void
name|gen_final_presence_set
parameter_list|(
name|rtx
name|def
parameter_list|)
block|{
name|gen_presence_absence_set
argument_list|(
name|def
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process an ABSENCE_SET.     This gives information about a cpu unit reservation requirements.    We fill a struct unit_pattern_rel_decl (absence) with information    used later by `expand_automata'.  */
end_comment

begin_function
specifier|static
name|void
name|gen_absence_set
parameter_list|(
name|rtx
name|def
parameter_list|)
block|{
name|gen_presence_absence_set
argument_list|(
name|def
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process a FINAL_ABSENCE_SET.     This gives information about a cpu unit reservation requirements.    We fill a struct unit_pattern_rel_decl (absence) with information    used later by `expand_automata'.  */
end_comment

begin_function
specifier|static
name|void
name|gen_final_absence_set
parameter_list|(
name|rtx
name|def
parameter_list|)
block|{
name|gen_presence_absence_set
argument_list|(
name|def
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process a DEFINE_AUTOMATON.     This gives information about a finite state automaton used for    recognizing pipeline hazards.  We fill a struct automaton_decl    with information used later by `expand_automata'.  */
end_comment

begin_function
specifier|static
name|void
name|gen_automaton
parameter_list|(
name|rtx
name|def
parameter_list|)
block|{
name|decl_t
name|decl
decl_stmt|;
name|char
modifier|*
modifier|*
name|str_automata
decl_stmt|;
name|int
name|vect_length
decl_stmt|;
name|int
name|i
decl_stmt|;
name|str_automata
operator|=
name|get_str_vect
argument_list|(
name|XSTR
argument_list|(
name|def
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|vect_length
argument_list|,
literal|','
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|str_automata
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"invalid string `%s' in define_automaton"
argument_list|,
name|XSTR
argument_list|(
name|def
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vect_length
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|decl
operator|->
name|mode
operator|=
name|dm_automaton
expr_stmt|;
name|decl
operator|->
name|pos
operator|=
literal|0
expr_stmt|;
name|DECL_AUTOMATON
argument_list|(
name|decl
argument_list|)
operator|->
name|name
operator|=
name|check_name
argument_list|(
name|str_automata
index|[
name|i
index|]
argument_list|,
name|decl
operator|->
name|pos
argument_list|)
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|decl_t
argument_list|,
name|heap
argument_list|,
name|decls
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Process an AUTOMATA_OPTION.     This gives information how to generate finite state automaton used    for recognizing pipeline hazards.  */
end_comment

begin_function
specifier|static
name|void
name|gen_automata_option
parameter_list|(
name|rtx
name|def
parameter_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|def
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NO_MINIMIZATION_OPTION
operator|+
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|no_minimization_flag
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|def
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TIME_OPTION
operator|+
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|time_flag
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|def
argument_list|,
literal|0
argument_list|)
argument_list|,
name|V_OPTION
operator|+
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|v_flag
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|def
argument_list|,
literal|0
argument_list|)
argument_list|,
name|W_OPTION
operator|+
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|w_flag
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|def
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NDFA_OPTION
operator|+
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|ndfa_flag
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|def
argument_list|,
literal|0
argument_list|)
argument_list|,
name|PROGRESS_OPTION
operator|+
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|progress_flag
operator|=
literal|1
expr_stmt|;
else|else
name|fatal
argument_list|(
literal|"invalid option `%s' in automata_option"
argument_list|,
name|XSTR
argument_list|(
name|def
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Name in reservation to denote absence reservation.  */
end_comment

begin_define
define|#
directive|define
name|NOTHING_NAME
value|"nothing"
end_define

begin_comment
comment|/* The following string contains original reservation string being    parsed.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|reserv_str
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parse an element in STR.  */
end_comment

begin_function
specifier|static
name|regexp_t
name|gen_regexp_el
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|regexp_t
name|regexp
decl_stmt|;
name|char
modifier|*
name|dstr
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|'('
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
index|[
name|len
operator|-
literal|1
index|]
operator|!=
literal|')'
condition|)
name|fatal
argument_list|(
literal|"garbage after ) in reservation `%s'"
argument_list|,
name|reserv_str
argument_list|)
expr_stmt|;
name|dstr
operator|=
name|alloca
argument_list|(
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dstr
argument_list|,
name|str
operator|+
literal|1
argument_list|,
name|len
operator|-
literal|2
argument_list|)
expr_stmt|;
name|dstr
index|[
name|len
operator|-
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|regexp
operator|=
name|gen_regexp_sequence
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
name|NOTHING_NAME
argument_list|)
operator|==
literal|0
condition|)
block|{
name|regexp
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|regexp
operator|->
name|mode
operator|=
name|rm_nothing
expr_stmt|;
block|}
else|else
block|{
name|regexp
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|regexp
operator|->
name|mode
operator|=
name|rm_unit
expr_stmt|;
name|REGEXP_UNIT
argument_list|(
name|regexp
argument_list|)
operator|->
name|name
operator|=
name|str
expr_stmt|;
block|}
return|return
name|regexp
return|;
block|}
end_function

begin_comment
comment|/* Parse construction `repeat' in STR.  */
end_comment

begin_function
specifier|static
name|regexp_t
name|gen_regexp_repeat
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|regexp_t
name|regexp
decl_stmt|;
name|regexp_t
name|repeat
decl_stmt|;
name|char
modifier|*
modifier|*
name|repeat_vect
decl_stmt|;
name|int
name|els_num
decl_stmt|;
name|int
name|i
decl_stmt|;
name|repeat_vect
operator|=
name|get_str_vect
argument_list|(
name|str
argument_list|,
operator|&
name|els_num
argument_list|,
literal|'*'
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|repeat_vect
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"invalid `%s' in reservation `%s'"
argument_list|,
name|str
argument_list|,
name|reserv_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|els_num
operator|>
literal|1
condition|)
block|{
name|regexp
operator|=
name|gen_regexp_el
argument_list|(
name|repeat_vect
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|els_num
condition|;
name|i
operator|++
control|)
block|{
name|repeat
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|regexp
argument_list|)
argument_list|)
expr_stmt|;
name|repeat
operator|->
name|mode
operator|=
name|rm_repeat
expr_stmt|;
name|REGEXP_REPEAT
argument_list|(
name|repeat
argument_list|)
operator|->
name|regexp
operator|=
name|regexp
expr_stmt|;
name|REGEXP_REPEAT
argument_list|(
name|repeat
argument_list|)
operator|->
name|repeat_num
operator|=
name|atoi
argument_list|(
name|repeat_vect
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|REGEXP_REPEAT
argument_list|(
name|repeat
argument_list|)
operator|->
name|repeat_num
operator|<=
literal|1
condition|)
name|fatal
argument_list|(
literal|"repetition `%s'<= 1 in reservation `%s'"
argument_list|,
name|str
argument_list|,
name|reserv_str
argument_list|)
expr_stmt|;
name|regexp
operator|=
name|repeat
expr_stmt|;
block|}
return|return
name|regexp
return|;
block|}
else|else
return|return
name|gen_regexp_el
argument_list|(
name|str
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse reservation STR which possibly contains separator '+'.  */
end_comment

begin_function
specifier|static
name|regexp_t
name|gen_regexp_allof
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|regexp_t
name|allof
decl_stmt|;
name|char
modifier|*
modifier|*
name|allof_vect
decl_stmt|;
name|int
name|els_num
decl_stmt|;
name|int
name|i
decl_stmt|;
name|allof_vect
operator|=
name|get_str_vect
argument_list|(
name|str
argument_list|,
operator|&
name|els_num
argument_list|,
literal|'+'
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|allof_vect
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"invalid `%s' in reservation `%s'"
argument_list|,
name|str
argument_list|,
name|reserv_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|els_num
operator|>
literal|1
condition|)
block|{
name|allof
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|regexp
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|regexp_t
argument_list|)
operator|*
operator|(
name|els_num
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|allof
operator|->
name|mode
operator|=
name|rm_allof
expr_stmt|;
name|REGEXP_ALLOF
argument_list|(
name|allof
argument_list|)
operator|->
name|regexps_num
operator|=
name|els_num
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|els_num
condition|;
name|i
operator|++
control|)
name|REGEXP_ALLOF
argument_list|(
name|allof
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
operator|=
name|gen_regexp_repeat
argument_list|(
name|allof_vect
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
name|allof
return|;
block|}
else|else
return|return
name|gen_regexp_repeat
argument_list|(
name|str
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse reservation STR which possibly contains separator '|'.  */
end_comment

begin_function
specifier|static
name|regexp_t
name|gen_regexp_oneof
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|regexp_t
name|oneof
decl_stmt|;
name|char
modifier|*
modifier|*
name|oneof_vect
decl_stmt|;
name|int
name|els_num
decl_stmt|;
name|int
name|i
decl_stmt|;
name|oneof_vect
operator|=
name|get_str_vect
argument_list|(
name|str
argument_list|,
operator|&
name|els_num
argument_list|,
literal|'|'
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|oneof_vect
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"invalid `%s' in reservation `%s'"
argument_list|,
name|str
argument_list|,
name|reserv_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|els_num
operator|>
literal|1
condition|)
block|{
name|oneof
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|regexp
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|regexp_t
argument_list|)
operator|*
operator|(
name|els_num
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|oneof
operator|->
name|mode
operator|=
name|rm_oneof
expr_stmt|;
name|REGEXP_ONEOF
argument_list|(
name|oneof
argument_list|)
operator|->
name|regexps_num
operator|=
name|els_num
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|els_num
condition|;
name|i
operator|++
control|)
name|REGEXP_ONEOF
argument_list|(
name|oneof
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
operator|=
name|gen_regexp_allof
argument_list|(
name|oneof_vect
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
name|oneof
return|;
block|}
else|else
return|return
name|gen_regexp_allof
argument_list|(
name|str
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse reservation STR which possibly contains separator ','.  */
end_comment

begin_function
specifier|static
name|regexp_t
name|gen_regexp_sequence
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|regexp_t
name|sequence
decl_stmt|;
name|char
modifier|*
modifier|*
name|sequence_vect
decl_stmt|;
name|int
name|els_num
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sequence_vect
operator|=
name|get_str_vect
argument_list|(
name|str
argument_list|,
operator|&
name|els_num
argument_list|,
literal|','
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|els_num
operator|>
literal|1
condition|)
block|{
name|sequence
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|regexp
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|regexp_t
argument_list|)
operator|*
operator|(
name|els_num
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|sequence
operator|->
name|mode
operator|=
name|rm_sequence
expr_stmt|;
name|REGEXP_SEQUENCE
argument_list|(
name|sequence
argument_list|)
operator|->
name|regexps_num
operator|=
name|els_num
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|els_num
condition|;
name|i
operator|++
control|)
name|REGEXP_SEQUENCE
argument_list|(
name|sequence
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
operator|=
name|gen_regexp_oneof
argument_list|(
name|sequence_vect
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
name|sequence
return|;
block|}
else|else
return|return
name|gen_regexp_oneof
argument_list|(
name|str
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse construction reservation STR.  */
end_comment

begin_function
specifier|static
name|regexp_t
name|gen_regexp
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|reserv_str
operator|=
name|str
expr_stmt|;
return|return
name|gen_regexp_sequence
argument_list|(
name|str
argument_list|)
return|;
empty_stmt|;
block|}
end_function

begin_comment
comment|/* Process a DEFINE_RESERVATION.     This gives information about a reservation of cpu units.  We fill    in a struct reserv_decl with information used later by    `expand_automata'.  */
end_comment

begin_function
specifier|static
name|void
name|gen_reserv
parameter_list|(
name|rtx
name|def
parameter_list|)
block|{
name|decl_t
name|decl
decl_stmt|;
name|decl
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|decl
operator|->
name|mode
operator|=
name|dm_reserv
expr_stmt|;
name|decl
operator|->
name|pos
operator|=
literal|0
expr_stmt|;
name|DECL_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|name
operator|=
name|check_name
argument_list|(
name|XSTR
argument_list|(
name|def
argument_list|,
literal|0
argument_list|)
argument_list|,
name|decl
operator|->
name|pos
argument_list|)
expr_stmt|;
name|DECL_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|regexp
operator|=
name|gen_regexp
argument_list|(
name|XSTR
argument_list|(
name|def
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|decl_t
argument_list|,
name|heap
argument_list|,
name|decls
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process a DEFINE_INSN_RESERVATION.     This gives information about the reservation of cpu units by an    insn.  We fill a struct insn_reserv_decl with information used    later by `expand_automata'.  */
end_comment

begin_function
specifier|static
name|void
name|gen_insn_reserv
parameter_list|(
name|rtx
name|def
parameter_list|)
block|{
name|decl_t
name|decl
decl_stmt|;
name|decl
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|decl
operator|->
name|mode
operator|=
name|dm_insn_reserv
expr_stmt|;
name|decl
operator|->
name|pos
operator|=
literal|0
expr_stmt|;
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|name
operator|=
name|check_name
argument_list|(
name|XSTR
argument_list|(
name|def
argument_list|,
literal|0
argument_list|)
argument_list|,
name|decl
operator|->
name|pos
argument_list|)
expr_stmt|;
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|default_latency
operator|=
name|XINT
argument_list|(
name|def
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|condexp
operator|=
name|XEXP
argument_list|(
name|def
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|regexp
operator|=
name|gen_regexp
argument_list|(
name|XSTR
argument_list|(
name|def
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|decl_t
argument_list|,
name|heap
argument_list|,
name|decls
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The function evaluates hash value (0..UINT_MAX) of string.  */
end_comment

begin_function
specifier|static
name|unsigned
name|string_hash
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|unsigned
name|result
decl_stmt|,
name|i
decl_stmt|;
for|for
control|(
name|result
operator|=
name|i
operator|=
literal|0
init|;
operator|*
name|string
operator|++
operator|!=
literal|'\0'
condition|;
name|i
operator|++
control|)
name|result
operator|+=
operator|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|string
operator|<<
operator|(
name|i
operator|%
name|CHAR_BIT
operator|)
operator|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This page contains abstract data `table of automaton declarations'.    Elements of the table is nodes representing automaton declarations.    Key of the table elements is name of given automaton.  Remember    that automaton names have own space.  */
end_comment

begin_comment
comment|/* The function evaluates hash value of an automaton declaration.  The    function is used by abstract data `hashtab'.  The function returns    hash value (0..UINT_MAX) of given automaton declaration.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|automaton_decl_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|automaton_decl
parameter_list|)
block|{
specifier|const
name|decl_t
name|decl
init|=
operator|(
name|decl_t
operator|)
name|automaton_decl
decl_stmt|;
name|gcc_assert
argument_list|(
name|decl
operator|->
name|mode
operator|!=
name|dm_automaton
operator|||
name|DECL_AUTOMATON
argument_list|(
name|decl
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|string_hash
argument_list|(
name|DECL_AUTOMATON
argument_list|(
name|decl
argument_list|)
operator|->
name|name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The function tests automaton declarations on equality of their    keys.  The function is used by abstract data `hashtab'.  The    function returns 1 if the declarations have the same key, 0    otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|automaton_decl_eq_p
parameter_list|(
specifier|const
name|void
modifier|*
name|automaton_decl_1
parameter_list|,
specifier|const
name|void
modifier|*
name|automaton_decl_2
parameter_list|)
block|{
specifier|const
name|decl_t
name|decl1
init|=
operator|(
name|decl_t
operator|)
name|automaton_decl_1
decl_stmt|;
specifier|const
name|decl_t
name|decl2
init|=
operator|(
name|decl_t
operator|)
name|automaton_decl_2
decl_stmt|;
name|gcc_assert
argument_list|(
name|decl1
operator|->
name|mode
operator|==
name|dm_automaton
operator|&&
name|DECL_AUTOMATON
argument_list|(
name|decl1
argument_list|)
operator|->
name|name
operator|&&
name|decl2
operator|->
name|mode
operator|==
name|dm_automaton
operator|&&
name|DECL_AUTOMATON
argument_list|(
name|decl2
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|strcmp
argument_list|(
name|DECL_AUTOMATON
argument_list|(
name|decl1
argument_list|)
operator|->
name|name
argument_list|,
name|DECL_AUTOMATON
argument_list|(
name|decl2
argument_list|)
operator|->
name|name
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* The automaton declaration table itself is represented by the    following variable.  */
end_comment

begin_decl_stmt
specifier|static
name|htab_t
name|automaton_decl_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The function inserts automaton declaration into the table.  The    function does nothing if an automaton declaration with the same key    exists already in the table.  The function returns automaton    declaration node in the table with the same key as given automaton    declaration node.  */
end_comment

begin_function
specifier|static
name|decl_t
name|insert_automaton_decl
parameter_list|(
name|decl_t
name|automaton_decl
parameter_list|)
block|{
name|void
modifier|*
modifier|*
name|entry_ptr
decl_stmt|;
name|entry_ptr
operator|=
name|htab_find_slot
argument_list|(
name|automaton_decl_table
argument_list|,
name|automaton_decl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|entry_ptr
operator|==
name|NULL
condition|)
operator|*
name|entry_ptr
operator|=
operator|(
name|void
operator|*
operator|)
name|automaton_decl
expr_stmt|;
return|return
operator|(
name|decl_t
operator|)
operator|*
name|entry_ptr
return|;
block|}
end_function

begin_comment
comment|/* The following variable value is node representing automaton    declaration.  The node used for searching automaton declaration    with given name.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|decl
name|work_automaton_decl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The function searches for automaton declaration in the table with    the same key as node representing name of the automaton    declaration.  The function returns node found in the table, NULL if    such node does not exist in the table.  */
end_comment

begin_function
specifier|static
name|decl_t
name|find_automaton_decl
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|void
modifier|*
name|entry
decl_stmt|;
name|work_automaton_decl
operator|.
name|mode
operator|=
name|dm_automaton
expr_stmt|;
name|DECL_AUTOMATON
argument_list|(
operator|&
name|work_automaton_decl
argument_list|)
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|entry
operator|=
name|htab_find
argument_list|(
name|automaton_decl_table
argument_list|,
operator|&
name|work_automaton_decl
argument_list|)
expr_stmt|;
return|return
operator|(
name|decl_t
operator|)
name|entry
return|;
block|}
end_function

begin_comment
comment|/* The function creates empty automaton declaration table and node    representing automaton declaration and used for searching automaton    declaration with given name.  The function must be called only once    before any work with the automaton declaration table.  */
end_comment

begin_function
specifier|static
name|void
name|initiate_automaton_decl_table
parameter_list|(
name|void
parameter_list|)
block|{
name|work_automaton_decl
operator|.
name|mode
operator|=
name|dm_automaton
expr_stmt|;
name|automaton_decl_table
operator|=
name|htab_create
argument_list|(
literal|10
argument_list|,
name|automaton_decl_hash
argument_list|,
name|automaton_decl_eq_p
argument_list|,
operator|(
name|htab_del
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function deletes the automaton declaration table.  Only call of    function `initiate_automaton_decl_table' is possible immediately    after this function call.  */
end_comment

begin_function
specifier|static
name|void
name|finish_automaton_decl_table
parameter_list|(
name|void
parameter_list|)
block|{
name|htab_delete
argument_list|(
name|automaton_decl_table
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This page contains abstract data `table of insn declarations'.    Elements of the table is nodes representing insn declarations.  Key    of the table elements is name of given insn (in corresponding    define_insn_reservation).  Remember that insn names have own    space.  */
end_comment

begin_comment
comment|/* The function evaluates hash value of an insn declaration.  The    function is used by abstract data `hashtab'.  The function returns    hash value (0..UINT_MAX) of given insn declaration.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|insn_decl_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|insn_decl
parameter_list|)
block|{
specifier|const
name|decl_t
name|decl
init|=
operator|(
name|decl_t
operator|)
name|insn_decl
decl_stmt|;
name|gcc_assert
argument_list|(
name|decl
operator|->
name|mode
operator|==
name|dm_insn_reserv
operator|&&
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|string_hash
argument_list|(
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The function tests insn declarations on equality of their keys.    The function is used by abstract data `hashtab'.  The function    returns 1 if declarations have the same key, 0 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|insn_decl_eq_p
parameter_list|(
specifier|const
name|void
modifier|*
name|insn_decl_1
parameter_list|,
specifier|const
name|void
modifier|*
name|insn_decl_2
parameter_list|)
block|{
specifier|const
name|decl_t
name|decl1
init|=
operator|(
name|decl_t
operator|)
name|insn_decl_1
decl_stmt|;
specifier|const
name|decl_t
name|decl2
init|=
operator|(
name|decl_t
operator|)
name|insn_decl_2
decl_stmt|;
name|gcc_assert
argument_list|(
name|decl1
operator|->
name|mode
operator|==
name|dm_insn_reserv
operator|&&
name|DECL_INSN_RESERV
argument_list|(
name|decl1
argument_list|)
operator|->
name|name
operator|&&
name|decl2
operator|->
name|mode
operator|==
name|dm_insn_reserv
operator|&&
name|DECL_INSN_RESERV
argument_list|(
name|decl2
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|strcmp
argument_list|(
name|DECL_INSN_RESERV
argument_list|(
name|decl1
argument_list|)
operator|->
name|name
argument_list|,
name|DECL_INSN_RESERV
argument_list|(
name|decl2
argument_list|)
operator|->
name|name
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* The insn declaration table itself is represented by the following    variable.  The table does not contain insn reservation    declarations.  */
end_comment

begin_decl_stmt
specifier|static
name|htab_t
name|insn_decl_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The function inserts insn declaration into the table.  The function    does nothing if an insn declaration with the same key exists    already in the table.  The function returns insn declaration node    in the table with the same key as given insn declaration node.  */
end_comment

begin_function
specifier|static
name|decl_t
name|insert_insn_decl
parameter_list|(
name|decl_t
name|insn_decl
parameter_list|)
block|{
name|void
modifier|*
modifier|*
name|entry_ptr
decl_stmt|;
name|entry_ptr
operator|=
name|htab_find_slot
argument_list|(
name|insn_decl_table
argument_list|,
name|insn_decl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|entry_ptr
operator|==
name|NULL
condition|)
operator|*
name|entry_ptr
operator|=
operator|(
name|void
operator|*
operator|)
name|insn_decl
expr_stmt|;
return|return
operator|(
name|decl_t
operator|)
operator|*
name|entry_ptr
return|;
block|}
end_function

begin_comment
comment|/* The following variable value is node representing insn reservation    declaration.  The node used for searching insn reservation    declaration with given name.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|decl
name|work_insn_decl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The function searches for insn reservation declaration in the table    with the same key as node representing name of the insn reservation    declaration.  The function returns node found in the table, NULL if    such node does not exist in the table.  */
end_comment

begin_function
specifier|static
name|decl_t
name|find_insn_decl
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|void
modifier|*
name|entry
decl_stmt|;
name|work_insn_decl
operator|.
name|mode
operator|=
name|dm_insn_reserv
expr_stmt|;
name|DECL_INSN_RESERV
argument_list|(
operator|&
name|work_insn_decl
argument_list|)
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|entry
operator|=
name|htab_find
argument_list|(
name|insn_decl_table
argument_list|,
operator|&
name|work_insn_decl
argument_list|)
expr_stmt|;
return|return
operator|(
name|decl_t
operator|)
name|entry
return|;
block|}
end_function

begin_comment
comment|/* The function creates empty insn declaration table and node    representing insn declaration and used for searching insn    declaration with given name.  The function must be called only once    before any work with the insn declaration table.  */
end_comment

begin_function
specifier|static
name|void
name|initiate_insn_decl_table
parameter_list|(
name|void
parameter_list|)
block|{
name|work_insn_decl
operator|.
name|mode
operator|=
name|dm_insn_reserv
expr_stmt|;
name|insn_decl_table
operator|=
name|htab_create
argument_list|(
literal|10
argument_list|,
name|insn_decl_hash
argument_list|,
name|insn_decl_eq_p
argument_list|,
operator|(
name|htab_del
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function deletes the insn declaration table.  Only call of    function `initiate_insn_decl_table' is possible immediately after    this function call.  */
end_comment

begin_function
specifier|static
name|void
name|finish_insn_decl_table
parameter_list|(
name|void
parameter_list|)
block|{
name|htab_delete
argument_list|(
name|insn_decl_table
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This page contains abstract data `table of declarations'.  Elements    of the table is nodes representing declarations (of units and    reservations).  Key of the table elements is names of given    declarations.  */
end_comment

begin_comment
comment|/* The function evaluates hash value of a declaration.  The function    is used by abstract data `hashtab'.  The function returns hash    value (0..UINT_MAX) of given declaration.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|decl_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|decl
parameter_list|)
block|{
specifier|const
name|decl_t
name|d
init|=
operator|(
specifier|const
name|decl_t
operator|)
name|decl
decl_stmt|;
name|gcc_assert
argument_list|(
operator|(
name|d
operator|->
name|mode
operator|==
name|dm_unit
operator|&&
name|DECL_UNIT
argument_list|(
name|d
argument_list|)
operator|->
name|name
operator|)
operator|||
operator|(
name|d
operator|->
name|mode
operator|==
name|dm_reserv
operator|&&
name|DECL_RESERV
argument_list|(
name|d
argument_list|)
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
return|return
name|string_hash
argument_list|(
name|d
operator|->
name|mode
operator|==
name|dm_unit
condition|?
name|DECL_UNIT
argument_list|(
name|d
argument_list|)
operator|->
name|name
else|:
name|DECL_RESERV
argument_list|(
name|d
argument_list|)
operator|->
name|name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The function tests declarations on equality of their keys.  The    function is used by abstract data 'hashtab'.  The function    returns 1 if the declarations have the same key, 0 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|decl_eq_p
parameter_list|(
specifier|const
name|void
modifier|*
name|decl_1
parameter_list|,
specifier|const
name|void
modifier|*
name|decl_2
parameter_list|)
block|{
specifier|const
name|decl_t
name|d1
init|=
operator|(
specifier|const
name|decl_t
operator|)
name|decl_1
decl_stmt|;
specifier|const
name|decl_t
name|d2
init|=
operator|(
specifier|const
name|decl_t
operator|)
name|decl_2
decl_stmt|;
name|gcc_assert
argument_list|(
operator|(
name|d1
operator|->
name|mode
operator|==
name|dm_unit
operator|&&
name|DECL_UNIT
argument_list|(
name|d1
argument_list|)
operator|->
name|name
operator|)
operator|||
operator|(
name|d1
operator|->
name|mode
operator|==
name|dm_reserv
operator|&&
name|DECL_RESERV
argument_list|(
name|d1
argument_list|)
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|(
name|d2
operator|->
name|mode
operator|==
name|dm_unit
operator|&&
name|DECL_UNIT
argument_list|(
name|d2
argument_list|)
operator|->
name|name
operator|)
operator|||
operator|(
name|d2
operator|->
name|mode
operator|==
name|dm_reserv
operator|&&
name|DECL_RESERV
argument_list|(
name|d2
argument_list|)
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
return|return
name|strcmp
argument_list|(
operator|(
name|d1
operator|->
name|mode
operator|==
name|dm_unit
condition|?
name|DECL_UNIT
argument_list|(
name|d1
argument_list|)
operator|->
name|name
else|:
name|DECL_RESERV
argument_list|(
name|d1
argument_list|)
operator|->
name|name
operator|)
argument_list|,
operator|(
name|d2
operator|->
name|mode
operator|==
name|dm_unit
condition|?
name|DECL_UNIT
argument_list|(
name|d2
argument_list|)
operator|->
name|name
else|:
name|DECL_RESERV
argument_list|(
name|d2
argument_list|)
operator|->
name|name
operator|)
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* The declaration table itself is represented by the following    variable.  */
end_comment

begin_decl_stmt
specifier|static
name|htab_t
name|decl_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The function inserts declaration into the table.  The function does    nothing if a declaration with the same key exists already in the    table.  The function returns declaration node in the table with the    same key as given declaration node.  */
end_comment

begin_function
specifier|static
name|decl_t
name|insert_decl
parameter_list|(
name|decl_t
name|decl
parameter_list|)
block|{
name|void
modifier|*
modifier|*
name|entry_ptr
decl_stmt|;
name|entry_ptr
operator|=
name|htab_find_slot
argument_list|(
name|decl_table
argument_list|,
name|decl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|entry_ptr
operator|==
name|NULL
condition|)
operator|*
name|entry_ptr
operator|=
operator|(
name|void
operator|*
operator|)
name|decl
expr_stmt|;
return|return
operator|(
name|decl_t
operator|)
operator|*
name|entry_ptr
return|;
block|}
end_function

begin_comment
comment|/* The following variable value is node representing declaration.  The    node used for searching declaration with given name.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|decl
name|work_decl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The function searches for declaration in the table with the same    key as node representing name of the declaration.  The function    returns node found in the table, NULL if such node does not exist    in the table.  */
end_comment

begin_function
specifier|static
name|decl_t
name|find_decl
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|void
modifier|*
name|entry
decl_stmt|;
name|work_decl
operator|.
name|mode
operator|=
name|dm_unit
expr_stmt|;
name|DECL_UNIT
argument_list|(
operator|&
name|work_decl
argument_list|)
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|entry
operator|=
name|htab_find
argument_list|(
name|decl_table
argument_list|,
operator|&
name|work_decl
argument_list|)
expr_stmt|;
return|return
operator|(
name|decl_t
operator|)
name|entry
return|;
block|}
end_function

begin_comment
comment|/* The function creates empty declaration table and node representing    declaration and used for searching declaration with given name.    The function must be called only once before any work with the    declaration table.  */
end_comment

begin_function
specifier|static
name|void
name|initiate_decl_table
parameter_list|(
name|void
parameter_list|)
block|{
name|work_decl
operator|.
name|mode
operator|=
name|dm_unit
expr_stmt|;
name|decl_table
operator|=
name|htab_create
argument_list|(
literal|10
argument_list|,
name|decl_hash
argument_list|,
name|decl_eq_p
argument_list|,
operator|(
name|htab_del
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function deletes the declaration table.  Only call of function    `initiate_declaration_table' is possible immediately after this    function call.  */
end_comment

begin_function
specifier|static
name|void
name|finish_decl_table
parameter_list|(
name|void
parameter_list|)
block|{
name|htab_delete
argument_list|(
name|decl_table
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This page contains checker of pipeline hazard description.  */
end_comment

begin_comment
comment|/* Checking NAMES in an exclusion clause vector and returning formed    unit_set_el_list.  */
end_comment

begin_function
specifier|static
name|unit_set_el_t
name|process_excls
parameter_list|(
name|char
modifier|*
modifier|*
name|names
parameter_list|,
name|int
name|num
parameter_list|,
name|pos_t
name|excl_pos
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|unit_set_el_t
name|el_list
decl_stmt|;
name|unit_set_el_t
name|last_el
decl_stmt|;
name|unit_set_el_t
name|new_el
decl_stmt|;
name|decl_t
name|decl_in_table
decl_stmt|;
name|int
name|i
decl_stmt|;
name|el_list
operator|=
name|NULL
expr_stmt|;
name|last_el
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|decl_in_table
operator|=
name|find_decl
argument_list|(
name|names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl_in_table
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"unit `%s' in exclusion is not declared"
argument_list|,
name|names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|decl_in_table
operator|->
name|mode
operator|!=
name|dm_unit
condition|)
name|error
argument_list|(
literal|"`%s' in exclusion is not unit"
argument_list|,
name|names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|new_el
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|unit_set_el
argument_list|)
argument_list|)
expr_stmt|;
name|new_el
operator|->
name|unit_decl
operator|=
name|DECL_UNIT
argument_list|(
name|decl_in_table
argument_list|)
expr_stmt|;
name|new_el
operator|->
name|next_unit_set_el
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|last_el
operator|==
name|NULL
condition|)
name|el_list
operator|=
name|last_el
operator|=
name|new_el
expr_stmt|;
else|else
block|{
name|last_el
operator|->
name|next_unit_set_el
operator|=
name|new_el
expr_stmt|;
name|last_el
operator|=
name|last_el
operator|->
name|next_unit_set_el
expr_stmt|;
block|}
block|}
block|}
return|return
name|el_list
return|;
block|}
end_function

begin_comment
comment|/* The function adds each element from SOURCE_LIST to the exclusion    list of the each element from DEST_LIST.  Checking situation "unit    excludes itself".  */
end_comment

begin_function
specifier|static
name|void
name|add_excls
parameter_list|(
name|unit_set_el_t
name|dest_list
parameter_list|,
name|unit_set_el_t
name|source_list
parameter_list|,
name|pos_t
name|excl_pos
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|unit_set_el_t
name|dst
decl_stmt|;
name|unit_set_el_t
name|src
decl_stmt|;
name|unit_set_el_t
name|curr_el
decl_stmt|;
name|unit_set_el_t
name|prev_el
decl_stmt|;
name|unit_set_el_t
name|copy
decl_stmt|;
for|for
control|(
name|dst
operator|=
name|dest_list
init|;
name|dst
operator|!=
name|NULL
condition|;
name|dst
operator|=
name|dst
operator|->
name|next_unit_set_el
control|)
for|for
control|(
name|src
operator|=
name|source_list
init|;
name|src
operator|!=
name|NULL
condition|;
name|src
operator|=
name|src
operator|->
name|next_unit_set_el
control|)
block|{
if|if
condition|(
name|dst
operator|->
name|unit_decl
operator|==
name|src
operator|->
name|unit_decl
condition|)
block|{
name|error
argument_list|(
literal|"unit `%s' excludes itself"
argument_list|,
name|src
operator|->
name|unit_decl
operator|->
name|name
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|dst
operator|->
name|unit_decl
operator|->
name|automaton_name
operator|!=
name|NULL
operator|&&
name|src
operator|->
name|unit_decl
operator|->
name|automaton_name
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|dst
operator|->
name|unit_decl
operator|->
name|automaton_name
argument_list|,
name|src
operator|->
name|unit_decl
operator|->
name|automaton_name
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"units `%s' and `%s' in exclusion set belong to different automata"
argument_list|,
name|src
operator|->
name|unit_decl
operator|->
name|name
argument_list|,
name|dst
operator|->
name|unit_decl
operator|->
name|name
argument_list|)
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|curr_el
operator|=
name|dst
operator|->
name|unit_decl
operator|->
name|excl_list
operator|,
name|prev_el
operator|=
name|NULL
init|;
name|curr_el
operator|!=
name|NULL
condition|;
name|prev_el
operator|=
name|curr_el
operator|,
name|curr_el
operator|=
name|curr_el
operator|->
name|next_unit_set_el
control|)
if|if
condition|(
name|curr_el
operator|->
name|unit_decl
operator|==
name|src
operator|->
name|unit_decl
condition|)
break|break;
if|if
condition|(
name|curr_el
operator|==
name|NULL
condition|)
block|{
comment|/* Element not found - insert.  */
name|copy
operator|=
name|copy_node
argument_list|(
name|src
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|copy
operator|->
name|next_unit_set_el
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|prev_el
operator|==
name|NULL
condition|)
name|dst
operator|->
name|unit_decl
operator|->
name|excl_list
operator|=
name|copy
expr_stmt|;
else|else
name|prev_el
operator|->
name|next_unit_set_el
operator|=
name|copy
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Checking NAMES in presence/absence clause and returning the    formed unit_set_el_list.  The function is called only after    processing all exclusion sets.  */
end_comment

begin_function
specifier|static
name|unit_set_el_t
name|process_presence_absence_names
parameter_list|(
name|char
modifier|*
modifier|*
name|names
parameter_list|,
name|int
name|num
parameter_list|,
name|pos_t
name|req_pos
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|presence_p
parameter_list|,
name|int
name|final_p
parameter_list|)
block|{
name|unit_set_el_t
name|el_list
decl_stmt|;
name|unit_set_el_t
name|last_el
decl_stmt|;
name|unit_set_el_t
name|new_el
decl_stmt|;
name|decl_t
name|decl_in_table
decl_stmt|;
name|int
name|i
decl_stmt|;
name|el_list
operator|=
name|NULL
expr_stmt|;
name|last_el
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|decl_in_table
operator|=
name|find_decl
argument_list|(
name|names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl_in_table
operator|==
name|NULL
condition|)
name|error
argument_list|(
operator|(
name|presence_p
condition|?
operator|(
name|final_p
condition|?
literal|"unit `%s' in final presence set is not declared"
else|:
literal|"unit `%s' in presence set is not declared"
operator|)
else|:
operator|(
name|final_p
condition|?
literal|"unit `%s' in final absence set is not declared"
else|:
literal|"unit `%s' in absence set is not declared"
operator|)
operator|)
argument_list|,
name|names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|decl_in_table
operator|->
name|mode
operator|!=
name|dm_unit
condition|)
name|error
argument_list|(
operator|(
name|presence_p
condition|?
operator|(
name|final_p
condition|?
literal|"`%s' in final presence set is not unit"
else|:
literal|"`%s' in presence set is not unit"
operator|)
else|:
operator|(
name|final_p
condition|?
literal|"`%s' in final absence set is not unit"
else|:
literal|"`%s' in absence set is not unit"
operator|)
operator|)
argument_list|,
name|names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|new_el
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|unit_set_el
argument_list|)
argument_list|)
expr_stmt|;
name|new_el
operator|->
name|unit_decl
operator|=
name|DECL_UNIT
argument_list|(
name|decl_in_table
argument_list|)
expr_stmt|;
name|new_el
operator|->
name|next_unit_set_el
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|last_el
operator|==
name|NULL
condition|)
name|el_list
operator|=
name|last_el
operator|=
name|new_el
expr_stmt|;
else|else
block|{
name|last_el
operator|->
name|next_unit_set_el
operator|=
name|new_el
expr_stmt|;
name|last_el
operator|=
name|last_el
operator|->
name|next_unit_set_el
expr_stmt|;
block|}
block|}
block|}
return|return
name|el_list
return|;
block|}
end_function

begin_comment
comment|/* Checking NAMES in patterns of a presence/absence clause and    returning the formed pattern_set_el_list.  The function is called    only after processing all exclusion sets.  */
end_comment

begin_function
specifier|static
name|pattern_set_el_t
name|process_presence_absence_patterns
parameter_list|(
name|char
modifier|*
modifier|*
modifier|*
name|patterns
parameter_list|,
name|int
name|num
parameter_list|,
name|pos_t
name|req_pos
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|presence_p
parameter_list|,
name|int
name|final_p
parameter_list|)
block|{
name|pattern_set_el_t
name|el_list
decl_stmt|;
name|pattern_set_el_t
name|last_el
decl_stmt|;
name|pattern_set_el_t
name|new_el
decl_stmt|;
name|decl_t
name|decl_in_table
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|el_list
operator|=
name|NULL
expr_stmt|;
name|last_el
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|patterns
index|[
name|i
index|]
index|[
name|j
index|]
operator|!=
name|NULL
condition|;
name|j
operator|++
control|)
empty_stmt|;
name|new_el
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pattern_set_el
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|unit_decl
operator|*
argument_list|)
operator|*
name|j
argument_list|)
expr_stmt|;
name|new_el
operator|->
name|unit_decls
operator|=
operator|(
expr|struct
name|unit_decl
operator|*
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|new_el
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|pattern_set_el
argument_list|)
operator|)
expr_stmt|;
name|new_el
operator|->
name|next_pattern_set_el
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|last_el
operator|==
name|NULL
condition|)
name|el_list
operator|=
name|last_el
operator|=
name|new_el
expr_stmt|;
else|else
block|{
name|last_el
operator|->
name|next_pattern_set_el
operator|=
name|new_el
expr_stmt|;
name|last_el
operator|=
name|last_el
operator|->
name|next_pattern_set_el
expr_stmt|;
block|}
name|new_el
operator|->
name|units_num
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|patterns
index|[
name|i
index|]
index|[
name|j
index|]
operator|!=
name|NULL
condition|;
name|j
operator|++
control|)
block|{
name|decl_in_table
operator|=
name|find_decl
argument_list|(
name|patterns
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl_in_table
operator|==
name|NULL
condition|)
name|error
argument_list|(
operator|(
name|presence_p
condition|?
operator|(
name|final_p
condition|?
literal|"unit `%s' in final presence set is not declared"
else|:
literal|"unit `%s' in presence set is not declared"
operator|)
else|:
operator|(
name|final_p
condition|?
literal|"unit `%s' in final absence set is not declared"
else|:
literal|"unit `%s' in absence set is not declared"
operator|)
operator|)
argument_list|,
name|patterns
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|decl_in_table
operator|->
name|mode
operator|!=
name|dm_unit
condition|)
name|error
argument_list|(
operator|(
name|presence_p
condition|?
operator|(
name|final_p
condition|?
literal|"`%s' in final presence set is not unit"
else|:
literal|"`%s' in presence set is not unit"
operator|)
else|:
operator|(
name|final_p
condition|?
literal|"`%s' in final absence set is not unit"
else|:
literal|"`%s' in absence set is not unit"
operator|)
operator|)
argument_list|,
name|patterns
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|new_el
operator|->
name|unit_decls
index|[
name|new_el
operator|->
name|units_num
index|]
operator|=
name|DECL_UNIT
argument_list|(
name|decl_in_table
argument_list|)
expr_stmt|;
name|new_el
operator|->
name|units_num
operator|++
expr_stmt|;
block|}
block|}
block|}
return|return
name|el_list
return|;
block|}
end_function

begin_comment
comment|/* The function adds each element from PATTERN_LIST to presence (if    PRESENCE_P) or absence list of the each element from DEST_LIST.    Checking situations "unit requires own absence", and "unit excludes    and requires presence of ...", "unit requires absence and presence    of ...", "units in (final) presence set belong to different    automata", and "units in (final) absence set belong to different    automata".  Remember that we process absence sets only after all    presence sets.  */
end_comment

begin_function
specifier|static
name|void
name|add_presence_absence
parameter_list|(
name|unit_set_el_t
name|dest_list
parameter_list|,
name|pattern_set_el_t
name|pattern_list
parameter_list|,
name|pos_t
name|req_pos
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|presence_p
parameter_list|,
name|int
name|final_p
parameter_list|)
block|{
name|unit_set_el_t
name|dst
decl_stmt|;
name|pattern_set_el_t
name|pat
decl_stmt|;
name|struct
name|unit_decl
modifier|*
name|unit
decl_stmt|;
name|unit_set_el_t
name|curr_excl_el
decl_stmt|;
name|pattern_set_el_t
name|curr_pat_el
decl_stmt|;
name|pattern_set_el_t
name|prev_el
decl_stmt|;
name|pattern_set_el_t
name|copy
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|no_error_flag
decl_stmt|;
for|for
control|(
name|dst
operator|=
name|dest_list
init|;
name|dst
operator|!=
name|NULL
condition|;
name|dst
operator|=
name|dst
operator|->
name|next_unit_set_el
control|)
for|for
control|(
name|pat
operator|=
name|pattern_list
init|;
name|pat
operator|!=
name|NULL
condition|;
name|pat
operator|=
name|pat
operator|->
name|next_pattern_set_el
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pat
operator|->
name|units_num
condition|;
name|i
operator|++
control|)
block|{
name|unit
operator|=
name|pat
operator|->
name|unit_decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|dst
operator|->
name|unit_decl
operator|==
name|unit
operator|&&
name|pat
operator|->
name|units_num
operator|==
literal|1
operator|&&
operator|!
name|presence_p
condition|)
block|{
name|error
argument_list|(
literal|"unit `%s' requires own absence"
argument_list|,
name|unit
operator|->
name|name
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|dst
operator|->
name|unit_decl
operator|->
name|automaton_name
operator|!=
name|NULL
operator|&&
name|unit
operator|->
name|automaton_name
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|dst
operator|->
name|unit_decl
operator|->
name|automaton_name
argument_list|,
name|unit
operator|->
name|automaton_name
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
operator|(
name|presence_p
condition|?
operator|(
name|final_p
condition|?
literal|"units `%s' and `%s' in final presence set belong to different automata"
else|:
literal|"units `%s' and `%s' in presence set belong to different automata"
operator|)
else|:
operator|(
name|final_p
condition|?
literal|"units `%s' and `%s' in final absence set belong to different automata"
else|:
literal|"units `%s' and `%s' in absence set belong to different automata"
operator|)
operator|)
argument_list|,
name|unit
operator|->
name|name
argument_list|,
name|dst
operator|->
name|unit_decl
operator|->
name|name
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|no_error_flag
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|presence_p
condition|)
for|for
control|(
name|curr_excl_el
operator|=
name|dst
operator|->
name|unit_decl
operator|->
name|excl_list
init|;
name|curr_excl_el
operator|!=
name|NULL
condition|;
name|curr_excl_el
operator|=
name|curr_excl_el
operator|->
name|next_unit_set_el
control|)
block|{
if|if
condition|(
name|unit
operator|==
name|curr_excl_el
operator|->
name|unit_decl
operator|&&
name|pat
operator|->
name|units_num
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|w_flag
condition|)
block|{
name|error
argument_list|(
literal|"unit `%s' excludes and requires presence of `%s'"
argument_list|,
name|dst
operator|->
name|unit_decl
operator|->
name|name
argument_list|,
name|unit
operator|->
name|name
argument_list|)
expr_stmt|;
name|no_error_flag
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|warning
argument_list|(
literal|0
argument_list|,
literal|"unit `%s' excludes and requires presence of `%s'"
argument_list|,
name|dst
operator|->
name|unit_decl
operator|->
name|name
argument_list|,
name|unit
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|pat
operator|->
name|units_num
operator|==
literal|1
condition|)
for|for
control|(
name|curr_pat_el
operator|=
name|dst
operator|->
name|unit_decl
operator|->
name|presence_list
init|;
name|curr_pat_el
operator|!=
name|NULL
condition|;
name|curr_pat_el
operator|=
name|curr_pat_el
operator|->
name|next_pattern_set_el
control|)
if|if
condition|(
name|curr_pat_el
operator|->
name|units_num
operator|==
literal|1
operator|&&
name|unit
operator|==
name|curr_pat_el
operator|->
name|unit_decls
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
operator|!
name|w_flag
condition|)
block|{
name|error
argument_list|(
literal|"unit `%s' requires absence and presence of `%s'"
argument_list|,
name|dst
operator|->
name|unit_decl
operator|->
name|name
argument_list|,
name|unit
operator|->
name|name
argument_list|)
expr_stmt|;
name|no_error_flag
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|warning
argument_list|(
literal|0
argument_list|,
literal|"unit `%s' requires absence and presence of `%s'"
argument_list|,
name|dst
operator|->
name|unit_decl
operator|->
name|name
argument_list|,
name|unit
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|no_error_flag
condition|)
block|{
for|for
control|(
name|prev_el
operator|=
operator|(
name|presence_p
condition|?
operator|(
name|final_p
condition|?
name|dst
operator|->
name|unit_decl
operator|->
name|final_presence_list
else|:
name|dst
operator|->
name|unit_decl
operator|->
name|final_presence_list
operator|)
else|:
operator|(
name|final_p
condition|?
name|dst
operator|->
name|unit_decl
operator|->
name|final_absence_list
else|:
name|dst
operator|->
name|unit_decl
operator|->
name|absence_list
operator|)
operator|)
init|;
name|prev_el
operator|!=
name|NULL
operator|&&
name|prev_el
operator|->
name|next_pattern_set_el
operator|!=
name|NULL
condition|;
name|prev_el
operator|=
name|prev_el
operator|->
name|next_pattern_set_el
control|)
empty_stmt|;
name|copy
operator|=
name|copy_node
argument_list|(
name|pat
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pat
argument_list|)
argument_list|)
expr_stmt|;
name|copy
operator|->
name|next_pattern_set_el
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|prev_el
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|presence_p
condition|)
block|{
if|if
condition|(
name|final_p
condition|)
name|dst
operator|->
name|unit_decl
operator|->
name|final_presence_list
operator|=
name|copy
expr_stmt|;
else|else
name|dst
operator|->
name|unit_decl
operator|->
name|presence_list
operator|=
name|copy
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|final_p
condition|)
name|dst
operator|->
name|unit_decl
operator|->
name|final_absence_list
operator|=
name|copy
expr_stmt|;
else|else
name|dst
operator|->
name|unit_decl
operator|->
name|absence_list
operator|=
name|copy
expr_stmt|;
block|}
else|else
name|prev_el
operator|->
name|next_pattern_set_el
operator|=
name|copy
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* The function searches for bypass with given IN_INSN_RESERV in given    BYPASS_LIST.  */
end_comment

begin_function
specifier|static
name|struct
name|bypass_decl
modifier|*
name|find_bypass
parameter_list|(
name|struct
name|bypass_decl
modifier|*
name|bypass_list
parameter_list|,
name|struct
name|insn_reserv_decl
modifier|*
name|in_insn_reserv
parameter_list|)
block|{
name|struct
name|bypass_decl
modifier|*
name|bypass
decl_stmt|;
for|for
control|(
name|bypass
operator|=
name|bypass_list
init|;
name|bypass
operator|!=
name|NULL
condition|;
name|bypass
operator|=
name|bypass
operator|->
name|next
control|)
if|if
condition|(
name|bypass
operator|->
name|in_insn_reserv
operator|==
name|in_insn_reserv
condition|)
break|break;
return|return
name|bypass
return|;
block|}
end_function

begin_comment
comment|/* The function processes pipeline description declarations, checks    their correctness, and forms exclusion/presence/absence sets.  */
end_comment

begin_function
specifier|static
name|void
name|process_decls
parameter_list|(
name|void
parameter_list|)
block|{
name|decl_t
name|decl
decl_stmt|;
name|decl_t
name|automaton_decl
decl_stmt|;
name|decl_t
name|decl_in_table
decl_stmt|;
name|decl_t
name|out_insn_reserv
decl_stmt|;
name|decl_t
name|in_insn_reserv
decl_stmt|;
name|struct
name|bypass_decl
modifier|*
name|bypass
decl_stmt|;
name|int
name|automaton_presence
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Checking repeated automata declarations.  */
name|automaton_presence
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_automaton
condition|)
block|{
name|automaton_presence
operator|=
literal|1
expr_stmt|;
name|decl_in_table
operator|=
name|insert_automaton_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl_in_table
operator|!=
name|decl
condition|)
block|{
if|if
condition|(
operator|!
name|w_flag
condition|)
name|error
argument_list|(
literal|"repeated declaration of automaton `%s'"
argument_list|,
name|DECL_AUTOMATON
argument_list|(
name|decl
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|0
argument_list|,
literal|"repeated declaration of automaton `%s'"
argument_list|,
name|DECL_AUTOMATON
argument_list|(
name|decl
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Checking undeclared automata, repeated declarations (except for      automata) and correctness of their attributes (insn latency times      etc.).  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_insn_reserv
condition|)
block|{
if|if
condition|(
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|default_latency
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"define_insn_reservation `%s' has negative latency time"
argument_list|,
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|insn_num
operator|=
name|description
operator|->
name|insns_num
expr_stmt|;
name|description
operator|->
name|insns_num
operator|++
expr_stmt|;
name|decl_in_table
operator|=
name|insert_insn_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl_in_table
operator|!=
name|decl
condition|)
name|error
argument_list|(
literal|"`%s' is already used as insn reservation name"
argument_list|,
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_bypass
condition|)
block|{
if|if
condition|(
name|DECL_BYPASS
argument_list|(
name|decl
argument_list|)
operator|->
name|latency
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"define_bypass `%s - %s' has negative latency time"
argument_list|,
name|DECL_BYPASS
argument_list|(
name|decl
argument_list|)
operator|->
name|out_insn_name
argument_list|,
name|DECL_BYPASS
argument_list|(
name|decl
argument_list|)
operator|->
name|in_insn_name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_unit
operator|||
name|decl
operator|->
name|mode
operator|==
name|dm_reserv
condition|)
block|{
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_unit
condition|)
block|{
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|automaton_decl
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|automaton_name
operator|!=
name|NULL
condition|)
block|{
name|automaton_decl
operator|=
name|find_automaton_decl
argument_list|(
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|automaton_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|automaton_decl
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"automaton `%s' is not declared"
argument_list|,
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|automaton_name
argument_list|)
expr_stmt|;
else|else
block|{
name|DECL_AUTOMATON
argument_list|(
name|automaton_decl
argument_list|)
operator|->
name|automaton_is_used
operator|=
literal|1
expr_stmt|;
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|automaton_decl
operator|=
name|DECL_AUTOMATON
argument_list|(
name|automaton_decl
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|automaton_presence
condition|)
name|error
argument_list|(
literal|"define_unit `%s' without automaton when one defined"
argument_list|,
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|unit_num
operator|=
name|description
operator|->
name|units_num
expr_stmt|;
name|description
operator|->
name|units_num
operator|++
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|name
argument_list|,
name|NOTHING_NAME
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"`%s' is declared as cpu unit"
argument_list|,
name|NOTHING_NAME
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|decl_in_table
operator|=
name|find_decl
argument_list|(
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|DECL_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|name
argument_list|,
name|NOTHING_NAME
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"`%s' is declared as cpu reservation"
argument_list|,
name|NOTHING_NAME
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|decl_in_table
operator|=
name|find_decl
argument_list|(
name|DECL_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|decl_in_table
operator|==
name|NULL
condition|)
name|decl_in_table
operator|=
name|insert_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_unit
condition|)
name|error
argument_list|(
literal|"repeated declaration of unit `%s'"
argument_list|,
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"repeated declaration of reservation `%s'"
argument_list|,
name|DECL_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Check bypasses and form list of bypasses for each (output)      insn.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_bypass
condition|)
block|{
name|out_insn_reserv
operator|=
name|find_insn_decl
argument_list|(
name|DECL_BYPASS
argument_list|(
name|decl
argument_list|)
operator|->
name|out_insn_name
argument_list|)
expr_stmt|;
name|in_insn_reserv
operator|=
name|find_insn_decl
argument_list|(
name|DECL_BYPASS
argument_list|(
name|decl
argument_list|)
operator|->
name|in_insn_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|out_insn_reserv
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"there is no insn reservation `%s'"
argument_list|,
name|DECL_BYPASS
argument_list|(
name|decl
argument_list|)
operator|->
name|out_insn_name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|in_insn_reserv
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"there is no insn reservation `%s'"
argument_list|,
name|DECL_BYPASS
argument_list|(
name|decl
argument_list|)
operator|->
name|in_insn_name
argument_list|)
expr_stmt|;
else|else
block|{
name|DECL_BYPASS
argument_list|(
name|decl
argument_list|)
operator|->
name|out_insn_reserv
operator|=
name|DECL_INSN_RESERV
argument_list|(
name|out_insn_reserv
argument_list|)
expr_stmt|;
name|DECL_BYPASS
argument_list|(
name|decl
argument_list|)
operator|->
name|in_insn_reserv
operator|=
name|DECL_INSN_RESERV
argument_list|(
name|in_insn_reserv
argument_list|)
expr_stmt|;
name|bypass
operator|=
name|find_bypass
argument_list|(
name|DECL_INSN_RESERV
argument_list|(
name|out_insn_reserv
argument_list|)
operator|->
name|bypass_list
argument_list|,
name|DECL_BYPASS
argument_list|(
name|decl
argument_list|)
operator|->
name|in_insn_reserv
argument_list|)
expr_stmt|;
if|if
condition|(
name|bypass
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|DECL_BYPASS
argument_list|(
name|decl
argument_list|)
operator|->
name|latency
operator|==
name|bypass
operator|->
name|latency
condition|)
block|{
if|if
condition|(
operator|!
name|w_flag
condition|)
name|error
argument_list|(
literal|"the same bypass `%s - %s' is already defined"
argument_list|,
name|DECL_BYPASS
argument_list|(
name|decl
argument_list|)
operator|->
name|out_insn_name
argument_list|,
name|DECL_BYPASS
argument_list|(
name|decl
argument_list|)
operator|->
name|in_insn_name
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|0
argument_list|,
literal|"the same bypass `%s - %s' is already defined"
argument_list|,
name|DECL_BYPASS
argument_list|(
name|decl
argument_list|)
operator|->
name|out_insn_name
argument_list|,
name|DECL_BYPASS
argument_list|(
name|decl
argument_list|)
operator|->
name|in_insn_name
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"bypass `%s - %s' is already defined"
argument_list|,
name|DECL_BYPASS
argument_list|(
name|decl
argument_list|)
operator|->
name|out_insn_name
argument_list|,
name|DECL_BYPASS
argument_list|(
name|decl
argument_list|)
operator|->
name|in_insn_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DECL_BYPASS
argument_list|(
name|decl
argument_list|)
operator|->
name|next
operator|=
name|DECL_INSN_RESERV
argument_list|(
name|out_insn_reserv
argument_list|)
operator|->
name|bypass_list
expr_stmt|;
name|DECL_INSN_RESERV
argument_list|(
name|out_insn_reserv
argument_list|)
operator|->
name|bypass_list
operator|=
name|DECL_BYPASS
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Check exclusion set declarations and form exclusion sets.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_excl
condition|)
block|{
name|unit_set_el_t
name|unit_set_el_list
decl_stmt|;
name|unit_set_el_t
name|unit_set_el_list_2
decl_stmt|;
name|unit_set_el_list
operator|=
name|process_excls
argument_list|(
name|DECL_EXCL
argument_list|(
name|decl
argument_list|)
operator|->
name|names
argument_list|,
name|DECL_EXCL
argument_list|(
name|decl
argument_list|)
operator|->
name|first_list_length
argument_list|,
name|decl
operator|->
name|pos
argument_list|)
expr_stmt|;
name|unit_set_el_list_2
operator|=
name|process_excls
argument_list|(
operator|&
name|DECL_EXCL
argument_list|(
name|decl
argument_list|)
operator|->
name|names
index|[
name|DECL_EXCL
argument_list|(
name|decl
argument_list|)
operator|->
name|first_list_length
index|]
argument_list|,
name|DECL_EXCL
argument_list|(
name|decl
argument_list|)
operator|->
name|all_names_num
operator|-
name|DECL_EXCL
argument_list|(
name|decl
argument_list|)
operator|->
name|first_list_length
argument_list|,
name|decl
operator|->
name|pos
argument_list|)
expr_stmt|;
name|add_excls
argument_list|(
name|unit_set_el_list
argument_list|,
name|unit_set_el_list_2
argument_list|,
name|decl
operator|->
name|pos
argument_list|)
expr_stmt|;
name|add_excls
argument_list|(
name|unit_set_el_list_2
argument_list|,
name|unit_set_el_list
argument_list|,
name|decl
operator|->
name|pos
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Check presence set declarations and form presence sets.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_presence
condition|)
block|{
name|unit_set_el_t
name|unit_set_el_list
decl_stmt|;
name|pattern_set_el_t
name|pattern_set_el_list
decl_stmt|;
name|unit_set_el_list
operator|=
name|process_presence_absence_names
argument_list|(
name|DECL_PRESENCE
argument_list|(
name|decl
argument_list|)
operator|->
name|names
argument_list|,
name|DECL_PRESENCE
argument_list|(
name|decl
argument_list|)
operator|->
name|names_num
argument_list|,
name|decl
operator|->
name|pos
argument_list|,
name|TRUE
argument_list|,
name|DECL_PRESENCE
argument_list|(
name|decl
argument_list|)
operator|->
name|final_p
argument_list|)
expr_stmt|;
name|pattern_set_el_list
operator|=
name|process_presence_absence_patterns
argument_list|(
name|DECL_PRESENCE
argument_list|(
name|decl
argument_list|)
operator|->
name|patterns
argument_list|,
name|DECL_PRESENCE
argument_list|(
name|decl
argument_list|)
operator|->
name|patterns_num
argument_list|,
name|decl
operator|->
name|pos
argument_list|,
name|TRUE
argument_list|,
name|DECL_PRESENCE
argument_list|(
name|decl
argument_list|)
operator|->
name|final_p
argument_list|)
expr_stmt|;
name|add_presence_absence
argument_list|(
name|unit_set_el_list
argument_list|,
name|pattern_set_el_list
argument_list|,
name|decl
operator|->
name|pos
argument_list|,
name|TRUE
argument_list|,
name|DECL_PRESENCE
argument_list|(
name|decl
argument_list|)
operator|->
name|final_p
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Check absence set declarations and form absence sets.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_absence
condition|)
block|{
name|unit_set_el_t
name|unit_set_el_list
decl_stmt|;
name|pattern_set_el_t
name|pattern_set_el_list
decl_stmt|;
name|unit_set_el_list
operator|=
name|process_presence_absence_names
argument_list|(
name|DECL_ABSENCE
argument_list|(
name|decl
argument_list|)
operator|->
name|names
argument_list|,
name|DECL_ABSENCE
argument_list|(
name|decl
argument_list|)
operator|->
name|names_num
argument_list|,
name|decl
operator|->
name|pos
argument_list|,
name|FALSE
argument_list|,
name|DECL_ABSENCE
argument_list|(
name|decl
argument_list|)
operator|->
name|final_p
argument_list|)
expr_stmt|;
name|pattern_set_el_list
operator|=
name|process_presence_absence_patterns
argument_list|(
name|DECL_ABSENCE
argument_list|(
name|decl
argument_list|)
operator|->
name|patterns
argument_list|,
name|DECL_ABSENCE
argument_list|(
name|decl
argument_list|)
operator|->
name|patterns_num
argument_list|,
name|decl
operator|->
name|pos
argument_list|,
name|FALSE
argument_list|,
name|DECL_ABSENCE
argument_list|(
name|decl
argument_list|)
operator|->
name|final_p
argument_list|)
expr_stmt|;
name|add_presence_absence
argument_list|(
name|unit_set_el_list
argument_list|,
name|pattern_set_el_list
argument_list|,
name|decl
operator|->
name|pos
argument_list|,
name|FALSE
argument_list|,
name|DECL_ABSENCE
argument_list|(
name|decl
argument_list|)
operator|->
name|final_p
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* The following function checks that declared automaton is used.  If    the automaton is not used, the function fixes error/warning.  The    following function must be called only after `process_decls'.  */
end_comment

begin_function
specifier|static
name|void
name|check_automaton_usage
parameter_list|(
name|void
parameter_list|)
block|{
name|decl_t
name|decl
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_automaton
operator|&&
operator|!
name|DECL_AUTOMATON
argument_list|(
name|decl
argument_list|)
operator|->
name|automaton_is_used
condition|)
block|{
if|if
condition|(
operator|!
name|w_flag
condition|)
name|error
argument_list|(
literal|"automaton `%s' is not used"
argument_list|,
name|DECL_AUTOMATON
argument_list|(
name|decl
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|0
argument_list|,
literal|"automaton `%s' is not used"
argument_list|,
name|DECL_AUTOMATON
argument_list|(
name|decl
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* The following recursive function processes all regexp in order to    fix usage of units or reservations and to fix errors of undeclared    name.  The function may change unit_regexp onto reserv_regexp.    Remember that reserv_regexp does not exist before the function    call.  */
end_comment

begin_function
specifier|static
name|regexp_t
name|process_regexp
parameter_list|(
name|regexp_t
name|regexp
parameter_list|)
block|{
name|decl_t
name|decl_in_table
decl_stmt|;
name|regexp_t
name|new_regexp
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|regexp
operator|->
name|mode
condition|)
block|{
case|case
name|rm_unit
case|:
name|decl_in_table
operator|=
name|find_decl
argument_list|(
name|REGEXP_UNIT
argument_list|(
name|regexp
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl_in_table
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"undeclared unit or reservation `%s'"
argument_list|,
name|REGEXP_UNIT
argument_list|(
name|regexp
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
switch|switch
condition|(
name|decl_in_table
operator|->
name|mode
condition|)
block|{
case|case
name|dm_unit
case|:
name|DECL_UNIT
argument_list|(
name|decl_in_table
argument_list|)
operator|->
name|unit_is_used
operator|=
literal|1
expr_stmt|;
name|REGEXP_UNIT
argument_list|(
name|regexp
argument_list|)
operator|->
name|unit_decl
operator|=
name|DECL_UNIT
argument_list|(
name|decl_in_table
argument_list|)
expr_stmt|;
break|break;
case|case
name|dm_reserv
case|:
name|DECL_RESERV
argument_list|(
name|decl_in_table
argument_list|)
operator|->
name|reserv_is_used
operator|=
literal|1
expr_stmt|;
name|new_regexp
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|regexp
argument_list|)
argument_list|)
expr_stmt|;
name|new_regexp
operator|->
name|mode
operator|=
name|rm_reserv
expr_stmt|;
name|new_regexp
operator|->
name|pos
operator|=
name|regexp
operator|->
name|pos
expr_stmt|;
name|REGEXP_RESERV
argument_list|(
name|new_regexp
argument_list|)
operator|->
name|name
operator|=
name|REGEXP_UNIT
argument_list|(
name|regexp
argument_list|)
operator|->
name|name
expr_stmt|;
name|REGEXP_RESERV
argument_list|(
name|new_regexp
argument_list|)
operator|->
name|reserv_decl
operator|=
name|DECL_RESERV
argument_list|(
name|decl_in_table
argument_list|)
expr_stmt|;
name|regexp
operator|=
name|new_regexp
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|rm_sequence
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|;
name|i
operator|++
control|)
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
operator|=
name|process_regexp
argument_list|(
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|rm_allof
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|;
name|i
operator|++
control|)
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
operator|=
name|process_regexp
argument_list|(
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|rm_oneof
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|;
name|i
operator|++
control|)
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
operator|=
name|process_regexp
argument_list|(
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|rm_repeat
case|:
name|REGEXP_REPEAT
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexp
operator|=
name|process_regexp
argument_list|(
name|REGEXP_REPEAT
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexp
argument_list|)
expr_stmt|;
break|break;
case|case
name|rm_nothing
case|:
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
return|return
name|regexp
return|;
block|}
end_function

begin_comment
comment|/* The following function processes regexp of define_reservation and    define_insn_reservation with the aid of function    `process_regexp'.  */
end_comment

begin_function
specifier|static
name|void
name|process_regexp_decls
parameter_list|(
name|void
parameter_list|)
block|{
name|decl_t
name|decl
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_reserv
condition|)
name|DECL_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|regexp
operator|=
name|process_regexp
argument_list|(
name|DECL_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|regexp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_insn_reserv
condition|)
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|regexp
operator|=
name|process_regexp
argument_list|(
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|regexp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The following function checks that declared unit is used.  If the    unit is not used, the function fixes errors/warnings.  The    following function must be called only after `process_decls',    `process_regexp_decls'.  */
end_comment

begin_function
specifier|static
name|void
name|check_usage
parameter_list|(
name|void
parameter_list|)
block|{
name|decl_t
name|decl
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_unit
operator|&&
operator|!
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|unit_is_used
condition|)
block|{
if|if
condition|(
operator|!
name|w_flag
condition|)
name|error
argument_list|(
literal|"unit `%s' is not used"
argument_list|,
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|0
argument_list|,
literal|"unit `%s' is not used"
argument_list|,
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_reserv
operator|&&
operator|!
name|DECL_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|reserv_is_used
condition|)
block|{
if|if
condition|(
operator|!
name|w_flag
condition|)
name|error
argument_list|(
literal|"reservation `%s' is not used"
argument_list|,
name|DECL_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|0
argument_list|,
literal|"reservation `%s' is not used"
argument_list|,
name|DECL_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* The following variable value is number of reservation being    processed on loop recognition.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|curr_loop_pass_num
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following recursive function returns nonzero value if REGEXP    contains given decl or reservations in given regexp refers for    given decl.  */
end_comment

begin_function
specifier|static
name|int
name|loop_in_regexp
parameter_list|(
name|regexp_t
name|regexp
parameter_list|,
name|decl_t
name|start_decl
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|regexp
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|regexp
operator|->
name|mode
condition|)
block|{
case|case
name|rm_unit
case|:
return|return
literal|0
return|;
case|case
name|rm_reserv
case|:
if|if
condition|(
name|start_decl
operator|->
name|mode
operator|==
name|dm_reserv
operator|&&
name|REGEXP_RESERV
argument_list|(
name|regexp
argument_list|)
operator|->
name|reserv_decl
operator|==
name|DECL_RESERV
argument_list|(
name|start_decl
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|REGEXP_RESERV
argument_list|(
name|regexp
argument_list|)
operator|->
name|reserv_decl
operator|->
name|loop_pass_num
operator|==
name|curr_loop_pass_num
condition|)
comment|/* declaration has been processed.  */
return|return
literal|0
return|;
else|else
block|{
name|REGEXP_RESERV
argument_list|(
name|regexp
argument_list|)
operator|->
name|reserv_decl
operator|->
name|loop_pass_num
operator|=
name|curr_loop_pass_num
expr_stmt|;
return|return
name|loop_in_regexp
argument_list|(
name|REGEXP_RESERV
argument_list|(
name|regexp
argument_list|)
operator|->
name|reserv_decl
operator|->
name|regexp
argument_list|,
name|start_decl
argument_list|)
return|;
block|}
case|case
name|rm_sequence
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|loop_in_regexp
argument_list|(
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
argument_list|,
name|start_decl
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
case|case
name|rm_allof
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|loop_in_regexp
argument_list|(
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
argument_list|,
name|start_decl
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
case|case
name|rm_oneof
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|loop_in_regexp
argument_list|(
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
argument_list|,
name|start_decl
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
case|case
name|rm_repeat
case|:
return|return
name|loop_in_regexp
argument_list|(
name|REGEXP_REPEAT
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexp
argument_list|,
name|start_decl
argument_list|)
return|;
case|case
name|rm_nothing
case|:
return|return
literal|0
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The following function fixes errors "cycle in definition ...".  The    function uses function `loop_in_regexp' for that.  */
end_comment

begin_function
specifier|static
name|void
name|check_loops_in_regexps
parameter_list|(
name|void
parameter_list|)
block|{
name|decl_t
name|decl
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_reserv
condition|)
name|DECL_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|loop_pass_num
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
name|curr_loop_pass_num
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_reserv
condition|)
block|{
name|DECL_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|loop_pass_num
operator|=
name|curr_loop_pass_num
expr_stmt|;
if|if
condition|(
name|loop_in_regexp
argument_list|(
name|DECL_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|regexp
argument_list|,
name|decl
argument_list|)
condition|)
block|{
name|gcc_assert
argument_list|(
name|DECL_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|regexp
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"cycle in definition of reservation `%s'"
argument_list|,
name|DECL_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* The function recursively processes IR of reservation and defines    max and min cycle for reservation of unit.  */
end_comment

begin_function
specifier|static
name|void
name|process_regexp_cycles
parameter_list|(
name|regexp_t
name|regexp
parameter_list|,
name|int
name|max_start_cycle
parameter_list|,
name|int
name|min_start_cycle
parameter_list|,
name|int
modifier|*
name|max_finish_cycle
parameter_list|,
name|int
modifier|*
name|min_finish_cycle
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|regexp
operator|->
name|mode
condition|)
block|{
case|case
name|rm_unit
case|:
if|if
condition|(
name|REGEXP_UNIT
argument_list|(
name|regexp
argument_list|)
operator|->
name|unit_decl
operator|->
name|max_occ_cycle_num
operator|<
name|max_start_cycle
condition|)
name|REGEXP_UNIT
argument_list|(
name|regexp
argument_list|)
operator|->
name|unit_decl
operator|->
name|max_occ_cycle_num
operator|=
name|max_start_cycle
expr_stmt|;
if|if
condition|(
name|REGEXP_UNIT
argument_list|(
name|regexp
argument_list|)
operator|->
name|unit_decl
operator|->
name|min_occ_cycle_num
operator|>
name|min_start_cycle
operator|||
name|REGEXP_UNIT
argument_list|(
name|regexp
argument_list|)
operator|->
name|unit_decl
operator|->
name|min_occ_cycle_num
operator|==
operator|-
literal|1
condition|)
name|REGEXP_UNIT
argument_list|(
name|regexp
argument_list|)
operator|->
name|unit_decl
operator|->
name|min_occ_cycle_num
operator|=
name|min_start_cycle
expr_stmt|;
operator|*
name|max_finish_cycle
operator|=
name|max_start_cycle
expr_stmt|;
operator|*
name|min_finish_cycle
operator|=
name|min_start_cycle
expr_stmt|;
break|break;
case|case
name|rm_reserv
case|:
name|process_regexp_cycles
argument_list|(
name|REGEXP_RESERV
argument_list|(
name|regexp
argument_list|)
operator|->
name|reserv_decl
operator|->
name|regexp
argument_list|,
name|max_start_cycle
argument_list|,
name|min_start_cycle
argument_list|,
name|max_finish_cycle
argument_list|,
name|min_finish_cycle
argument_list|)
expr_stmt|;
break|break;
case|case
name|rm_repeat
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGEXP_REPEAT
argument_list|(
name|regexp
argument_list|)
operator|->
name|repeat_num
condition|;
name|i
operator|++
control|)
block|{
name|process_regexp_cycles
argument_list|(
name|REGEXP_REPEAT
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexp
argument_list|,
name|max_start_cycle
argument_list|,
name|min_start_cycle
argument_list|,
name|max_finish_cycle
argument_list|,
name|min_finish_cycle
argument_list|)
expr_stmt|;
name|max_start_cycle
operator|=
operator|*
name|max_finish_cycle
operator|+
literal|1
expr_stmt|;
name|min_start_cycle
operator|=
operator|*
name|min_finish_cycle
operator|+
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|rm_sequence
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|;
name|i
operator|++
control|)
block|{
name|process_regexp_cycles
argument_list|(
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
argument_list|,
name|max_start_cycle
argument_list|,
name|min_start_cycle
argument_list|,
name|max_finish_cycle
argument_list|,
name|min_finish_cycle
argument_list|)
expr_stmt|;
name|max_start_cycle
operator|=
operator|*
name|max_finish_cycle
operator|+
literal|1
expr_stmt|;
name|min_start_cycle
operator|=
operator|*
name|min_finish_cycle
operator|+
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|rm_allof
case|:
block|{
name|int
name|max_cycle
init|=
literal|0
decl_stmt|;
name|int
name|min_cycle
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|;
name|i
operator|++
control|)
block|{
name|process_regexp_cycles
argument_list|(
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
argument_list|,
name|max_start_cycle
argument_list|,
name|min_start_cycle
argument_list|,
name|max_finish_cycle
argument_list|,
name|min_finish_cycle
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_cycle
operator|<
operator|*
name|max_finish_cycle
condition|)
name|max_cycle
operator|=
operator|*
name|max_finish_cycle
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
operator|||
name|min_cycle
operator|>
operator|*
name|min_finish_cycle
condition|)
name|min_cycle
operator|=
operator|*
name|min_finish_cycle
expr_stmt|;
block|}
operator|*
name|max_finish_cycle
operator|=
name|max_cycle
expr_stmt|;
operator|*
name|min_finish_cycle
operator|=
name|min_cycle
expr_stmt|;
block|}
break|break;
case|case
name|rm_oneof
case|:
block|{
name|int
name|max_cycle
init|=
literal|0
decl_stmt|;
name|int
name|min_cycle
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|;
name|i
operator|++
control|)
block|{
name|process_regexp_cycles
argument_list|(
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
argument_list|,
name|max_start_cycle
argument_list|,
name|min_start_cycle
argument_list|,
name|max_finish_cycle
argument_list|,
name|min_finish_cycle
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_cycle
operator|<
operator|*
name|max_finish_cycle
condition|)
name|max_cycle
operator|=
operator|*
name|max_finish_cycle
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
operator|||
name|min_cycle
operator|>
operator|*
name|min_finish_cycle
condition|)
name|min_cycle
operator|=
operator|*
name|min_finish_cycle
expr_stmt|;
block|}
operator|*
name|max_finish_cycle
operator|=
name|max_cycle
expr_stmt|;
operator|*
name|min_finish_cycle
operator|=
name|min_cycle
expr_stmt|;
block|}
break|break;
case|case
name|rm_nothing
case|:
operator|*
name|max_finish_cycle
operator|=
name|max_start_cycle
expr_stmt|;
operator|*
name|min_finish_cycle
operator|=
name|min_start_cycle
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The following function is called only for correct program.  The    function defines max reservation of insns in cycles.  */
end_comment

begin_function
specifier|static
name|void
name|evaluate_max_reserv_cycles
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|max_insn_cycles_num
decl_stmt|;
name|int
name|min_insn_cycles_num
decl_stmt|;
name|decl_t
name|decl
decl_stmt|;
name|int
name|i
decl_stmt|;
name|description
operator|->
name|max_insn_reserv_cycles
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_insn_reserv
condition|)
block|{
name|process_regexp_cycles
argument_list|(
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|regexp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|max_insn_cycles_num
argument_list|,
operator|&
name|min_insn_cycles_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|description
operator|->
name|max_insn_reserv_cycles
operator|<
name|max_insn_cycles_num
condition|)
name|description
operator|->
name|max_insn_reserv_cycles
operator|=
name|max_insn_cycles_num
expr_stmt|;
block|}
block|}
name|description
operator|->
name|max_insn_reserv_cycles
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The following function calls functions for checking all    description.  */
end_comment

begin_function
specifier|static
name|void
name|check_all_description
parameter_list|(
name|void
parameter_list|)
block|{
name|process_decls
argument_list|()
expr_stmt|;
name|check_automaton_usage
argument_list|()
expr_stmt|;
name|process_regexp_decls
argument_list|()
expr_stmt|;
name|check_usage
argument_list|()
expr_stmt|;
name|check_loops_in_regexps
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|have_error
condition|)
name|evaluate_max_reserv_cycles
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The page contains abstract data `ticker'.  This data is used to    report time of different phases of building automata.  It is    possibly to write a description for which automata will be built    during several minutes even on fast machine.  */
end_comment

begin_comment
comment|/* The following function creates ticker and makes it active.  */
end_comment

begin_function
specifier|static
name|ticker_t
name|create_ticker
parameter_list|(
name|void
parameter_list|)
block|{
name|ticker_t
name|ticker
decl_stmt|;
name|ticker
operator|.
name|modified_creation_time
operator|=
name|get_run_time
argument_list|()
expr_stmt|;
name|ticker
operator|.
name|incremented_off_time
operator|=
literal|0
expr_stmt|;
return|return
name|ticker
return|;
block|}
end_function

begin_comment
comment|/* The following function switches off given ticker.  */
end_comment

begin_function
specifier|static
name|void
name|ticker_off
parameter_list|(
name|ticker_t
modifier|*
name|ticker
parameter_list|)
block|{
if|if
condition|(
name|ticker
operator|->
name|incremented_off_time
operator|==
literal|0
condition|)
name|ticker
operator|->
name|incremented_off_time
operator|=
name|get_run_time
argument_list|()
operator|+
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The following function switches on given ticker.  */
end_comment

begin_function
specifier|static
name|void
name|ticker_on
parameter_list|(
name|ticker_t
modifier|*
name|ticker
parameter_list|)
block|{
if|if
condition|(
name|ticker
operator|->
name|incremented_off_time
operator|!=
literal|0
condition|)
block|{
name|ticker
operator|->
name|modified_creation_time
operator|+=
name|get_run_time
argument_list|()
operator|-
name|ticker
operator|->
name|incremented_off_time
operator|+
literal|1
expr_stmt|;
name|ticker
operator|->
name|incremented_off_time
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The following function returns current time in milliseconds since    the moment when given ticker was created.  */
end_comment

begin_function
specifier|static
name|int
name|active_time
parameter_list|(
name|ticker_t
name|ticker
parameter_list|)
block|{
if|if
condition|(
name|ticker
operator|.
name|incremented_off_time
operator|!=
literal|0
condition|)
return|return
name|ticker
operator|.
name|incremented_off_time
operator|-
literal|1
operator|-
name|ticker
operator|.
name|modified_creation_time
return|;
else|else
return|return
name|get_run_time
argument_list|()
operator|-
name|ticker
operator|.
name|modified_creation_time
return|;
block|}
end_function

begin_comment
comment|/* The following function returns string representation of active time    of given ticker.  The result is string representation of seconds    with accuracy of 1/100 second.  Only result of the last call of the    function exists.  Therefore the following code is not correct        printf ("parser time: %s\ngeneration time: %s\n",               active_time_string (parser_ticker),               active_time_string (generation_ticker));     Correct code has to be the following        printf ("parser time: %s\n", active_time_string (parser_ticker));       printf ("generation time: %s\n",               active_time_string (generation_ticker));  */
end_comment

begin_function
specifier|static
name|void
name|print_active_time
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|ticker_t
name|ticker
parameter_list|)
block|{
name|int
name|msecs
decl_stmt|;
name|msecs
operator|=
name|active_time
argument_list|(
name|ticker
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%d.%06d"
argument_list|,
name|msecs
operator|/
literal|1000000
argument_list|,
name|msecs
operator|%
literal|1000000
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The following variable value is number of automaton which are    really being created.  This value is defined on the base of    argument of option `-split'.  If the variable has zero value the    number of automata is defined by the constructions `%automaton'.    This case occurs when option `-split' is absent or has zero    argument.  If constructions `define_automaton' is absent only one    automaton is created.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|automata_num
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following variable values are times of        o transformation of regular expressions        o building NDFA (DFA if !ndfa_flag)        o NDFA -> DFA   (simply the same automaton if !ndfa_flag)        o DFA minimization        o building insn equivalence classes        o all previous ones        o code output */
end_comment

begin_decl_stmt
specifier|static
name|ticker_t
name|transform_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ticker_t
name|NDFA_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ticker_t
name|NDFA_to_DFA_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ticker_t
name|minimize_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ticker_t
name|equiv_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ticker_t
name|automaton_generation_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ticker_t
name|output_time
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following variable values are times of        all checking        all generation        all pipeline hazard translator work */
end_comment

begin_decl_stmt
specifier|static
name|ticker_t
name|check_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ticker_t
name|generation_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ticker_t
name|all_time
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Pseudo insn decl which denotes advancing cycle.  */
end_comment

begin_decl_stmt
specifier|static
name|decl_t
name|advance_cycle_insn_decl
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|add_advance_cycle_insn_decl
parameter_list|(
name|void
parameter_list|)
block|{
name|advance_cycle_insn_decl
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|advance_cycle_insn_decl
operator|->
name|mode
operator|=
name|dm_insn_reserv
expr_stmt|;
name|advance_cycle_insn_decl
operator|->
name|pos
operator|=
name|no_pos
expr_stmt|;
name|DECL_INSN_RESERV
argument_list|(
name|advance_cycle_insn_decl
argument_list|)
operator|->
name|regexp
operator|=
name|NULL
expr_stmt|;
name|DECL_INSN_RESERV
argument_list|(
name|advance_cycle_insn_decl
argument_list|)
operator|->
name|name
operator|=
literal|"$advance_cycle"
expr_stmt|;
name|DECL_INSN_RESERV
argument_list|(
name|advance_cycle_insn_decl
argument_list|)
operator|->
name|insn_num
operator|=
name|description
operator|->
name|insns_num
expr_stmt|;
name|description
operator|->
name|decls
index|[
name|description
operator|->
name|decls_num
index|]
operator|=
name|advance_cycle_insn_decl
expr_stmt|;
name|description
operator|->
name|decls_num
operator|++
expr_stmt|;
name|description
operator|->
name|insns_num
operator|++
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Abstract data `alternative states' which represents    nondeterministic nature of the description (see comments for    structures alt_state and state).  */
end_comment

begin_comment
comment|/* List of free states.  */
end_comment

begin_decl_stmt
specifier|static
name|alt_state_t
name|first_free_alt_state
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|NDEBUG
end_ifndef

begin_comment
comment|/* The following variables is maximal number of allocated nodes    alt_state.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|allocated_alt_states_num
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The following function returns free node alt_state.  It may be new    allocated node or node freed earlier.  */
end_comment

begin_function
specifier|static
name|alt_state_t
name|get_free_alt_state
parameter_list|(
name|void
parameter_list|)
block|{
name|alt_state_t
name|result
decl_stmt|;
if|if
condition|(
name|first_free_alt_state
operator|!=
name|NULL
condition|)
block|{
name|result
operator|=
name|first_free_alt_state
expr_stmt|;
name|first_free_alt_state
operator|=
name|first_free_alt_state
operator|->
name|next_alt_state
expr_stmt|;
block|}
else|else
block|{
ifndef|#
directive|ifndef
name|NDEBUG
name|allocated_alt_states_num
operator|++
expr_stmt|;
endif|#
directive|endif
name|result
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|alt_state
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|result
operator|->
name|state
operator|=
name|NULL
expr_stmt|;
name|result
operator|->
name|next_alt_state
operator|=
name|NULL
expr_stmt|;
name|result
operator|->
name|next_sorted_alt_state
operator|=
name|NULL
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* The function frees node ALT_STATE.  */
end_comment

begin_function
specifier|static
name|void
name|free_alt_state
parameter_list|(
name|alt_state_t
name|alt_state
parameter_list|)
block|{
if|if
condition|(
name|alt_state
operator|==
name|NULL
condition|)
return|return;
name|alt_state
operator|->
name|next_alt_state
operator|=
name|first_free_alt_state
expr_stmt|;
name|first_free_alt_state
operator|=
name|alt_state
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function frees list started with node ALT_STATE_LIST.  */
end_comment

begin_function
specifier|static
name|void
name|free_alt_states
parameter_list|(
name|alt_state_t
name|alt_states_list
parameter_list|)
block|{
name|alt_state_t
name|curr_alt_state
decl_stmt|;
name|alt_state_t
name|next_alt_state
decl_stmt|;
for|for
control|(
name|curr_alt_state
operator|=
name|alt_states_list
init|;
name|curr_alt_state
operator|!=
name|NULL
condition|;
name|curr_alt_state
operator|=
name|next_alt_state
control|)
block|{
name|next_alt_state
operator|=
name|curr_alt_state
operator|->
name|next_alt_state
expr_stmt|;
name|free_alt_state
argument_list|(
name|curr_alt_state
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The function compares unique numbers of alt states.  */
end_comment

begin_function
specifier|static
name|int
name|alt_state_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|alt_state_ptr_1
parameter_list|,
specifier|const
name|void
modifier|*
name|alt_state_ptr_2
parameter_list|)
block|{
if|if
condition|(
operator|(
operator|*
operator|(
name|alt_state_t
operator|*
operator|)
name|alt_state_ptr_1
operator|)
operator|->
name|state
operator|->
name|unique_num
operator|==
operator|(
operator|*
operator|(
name|alt_state_t
operator|*
operator|)
name|alt_state_ptr_2
operator|)
operator|->
name|state
operator|->
name|unique_num
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
operator|(
operator|*
operator|(
name|alt_state_t
operator|*
operator|)
name|alt_state_ptr_1
operator|)
operator|->
name|state
operator|->
name|unique_num
operator|<
operator|(
operator|*
operator|(
name|alt_state_t
operator|*
operator|)
name|alt_state_ptr_2
operator|)
operator|->
name|state
operator|->
name|unique_num
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* The function sorts ALT_STATES_LIST and removes duplicated alt    states from the list.  The comparison key is alt state unique    number.  */
end_comment

begin_function
specifier|static
name|alt_state_t
name|uniq_sort_alt_states
parameter_list|(
name|alt_state_t
name|alt_states_list
parameter_list|)
block|{
name|alt_state_t
name|curr_alt_state
decl_stmt|;
name|VEC
argument_list|(
name|alt_state_t
argument_list|,
name|heap
argument_list|)
operator|*
name|alt_states
expr_stmt|;
name|size_t
name|i
decl_stmt|;
name|size_t
name|prev_unique_state_ind
decl_stmt|;
name|alt_state_t
name|result
decl_stmt|;
if|if
condition|(
name|alt_states_list
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|alt_states_list
operator|->
name|next_alt_state
operator|==
literal|0
condition|)
return|return
name|alt_states_list
return|;
name|alt_states
operator|=
name|VEC_alloc
argument_list|(
name|alt_state_t
argument_list|,
name|heap
argument_list|,
literal|150
argument_list|)
expr_stmt|;
for|for
control|(
name|curr_alt_state
operator|=
name|alt_states_list
init|;
name|curr_alt_state
operator|!=
name|NULL
condition|;
name|curr_alt_state
operator|=
name|curr_alt_state
operator|->
name|next_alt_state
control|)
name|VEC_safe_push
argument_list|(
name|alt_state_t
argument_list|,
name|heap
argument_list|,
name|alt_states
argument_list|,
name|curr_alt_state
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|VEC_address
argument_list|(
name|alt_state_t
argument_list|,
name|alt_states
argument_list|)
argument_list|,
name|VEC_length
argument_list|(
name|alt_state_t
argument_list|,
name|alt_states
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|alt_state_t
argument_list|)
argument_list|,
name|alt_state_cmp
argument_list|)
expr_stmt|;
name|prev_unique_state_ind
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|VEC_length
argument_list|(
name|alt_state_t
argument_list|,
name|alt_states
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|VEC_index
argument_list|(
name|alt_state_t
argument_list|,
name|alt_states
argument_list|,
name|prev_unique_state_ind
argument_list|)
operator|->
name|state
operator|!=
name|VEC_index
argument_list|(
name|alt_state_t
argument_list|,
name|alt_states
argument_list|,
name|i
argument_list|)
operator|->
name|state
condition|)
block|{
name|prev_unique_state_ind
operator|++
expr_stmt|;
name|VEC_replace
argument_list|(
name|alt_state_t
argument_list|,
name|alt_states
argument_list|,
name|prev_unique_state_ind
argument_list|,
name|VEC_index
argument_list|(
name|alt_state_t
argument_list|,
name|alt_states
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|VEC_truncate
argument_list|(
name|alt_state_t
argument_list|,
name|alt_states
argument_list|,
name|prev_unique_state_ind
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|VEC_length
argument_list|(
name|alt_state_t
argument_list|,
name|alt_states
argument_list|)
condition|;
name|i
operator|++
control|)
name|VEC_index
argument_list|(
name|alt_state_t
argument_list|,
name|alt_states
argument_list|,
name|i
operator|-
literal|1
argument_list|)
operator|->
name|next_sorted_alt_state
operator|=
name|VEC_index
argument_list|(
name|alt_state_t
argument_list|,
name|alt_states
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|VEC_last
argument_list|(
name|alt_state_t
argument_list|,
name|alt_states
argument_list|)
operator|->
name|next_sorted_alt_state
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|VEC_index
argument_list|(
name|alt_state_t
argument_list|,
name|alt_states
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|alt_state_t
argument_list|,
name|heap
argument_list|,
name|alt_states
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* The function checks equality of alt state lists.  Remember that the    lists must be already sorted by the previous function.  */
end_comment

begin_function
specifier|static
name|int
name|alt_states_eq
parameter_list|(
name|alt_state_t
name|alt_states_1
parameter_list|,
name|alt_state_t
name|alt_states_2
parameter_list|)
block|{
while|while
condition|(
name|alt_states_1
operator|!=
name|NULL
operator|&&
name|alt_states_2
operator|!=
name|NULL
operator|&&
name|alt_state_cmp
argument_list|(
operator|&
name|alt_states_1
argument_list|,
operator|&
name|alt_states_2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|alt_states_1
operator|=
name|alt_states_1
operator|->
name|next_sorted_alt_state
expr_stmt|;
name|alt_states_2
operator|=
name|alt_states_2
operator|->
name|next_sorted_alt_state
expr_stmt|;
block|}
return|return
name|alt_states_1
operator|==
name|alt_states_2
return|;
block|}
end_function

begin_comment
comment|/* Initialization of the abstract data.  */
end_comment

begin_function
specifier|static
name|void
name|initiate_alt_states
parameter_list|(
name|void
parameter_list|)
block|{
name|first_free_alt_state
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finishing work with the abstract data.  */
end_comment

begin_function
specifier|static
name|void
name|finish_alt_states
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_escape
end_escape

begin_comment
comment|/* The page contains macros for work with bits strings.  We could use    standard gcc bitmap or sbitmap but it would result in difficulties    of building canadian cross.  */
end_comment

begin_comment
comment|/* Set bit number bitno in the bit string.  The macro is not side    effect proof.  */
end_comment

begin_define
define|#
directive|define
name|SET_BIT
parameter_list|(
name|bitstring
parameter_list|,
name|bitno
parameter_list|)
define|\
value|(((char *) (bitstring)) [(bitno) / CHAR_BIT] |= 1<< (bitno) % CHAR_BIT)
end_define

begin_define
define|#
directive|define
name|CLEAR_BIT
parameter_list|(
name|bitstring
parameter_list|,
name|bitno
parameter_list|)
define|\
value|(((char *) (bitstring)) [(bitno) / CHAR_BIT]&= ~(1<< (bitno) % CHAR_BIT))
end_define

begin_comment
comment|/* Test if bit number bitno in the bitstring is set.  The macro is not    side effect proof.  */
end_comment

begin_define
define|#
directive|define
name|TEST_BIT
parameter_list|(
name|bitstring
parameter_list|,
name|bitno
parameter_list|)
define|\
value|(((char *) (bitstring)) [(bitno) / CHAR_BIT]>> (bitno) % CHAR_BIT& 1)
end_define

begin_escape
end_escape

begin_comment
comment|/* This page contains abstract data `state'.  */
end_comment

begin_comment
comment|/* Maximal length of reservations in cycles (>= 1).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_cycles_num
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of set elements (see type set_el_t) needed for    representation of one cycle reservation.  It is depended on units    number.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|els_in_cycle_reserv
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of set elements (see type set_el_t) needed for    representation of maximal length reservation.  Deterministic    reservation is stored as set (bit string) of length equal to the    variable value * number of bits in set_el_t.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|els_in_reservs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array of pointers to unit declarations.  */
end_comment

begin_decl_stmt
specifier|static
name|unit_decl_t
modifier|*
name|units_array
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Temporary reservation of maximal length.  */
end_comment

begin_decl_stmt
specifier|static
name|reserv_sets_t
name|temp_reserv
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The state table itself is represented by the following variable.  */
end_comment

begin_decl_stmt
specifier|static
name|htab_t
name|state_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Linked list of free 'state' structures to be recycled.  The    next_equiv_class_state pointer is borrowed for a free list.  */
end_comment

begin_decl_stmt
specifier|static
name|state_t
name|first_free_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|curr_unique_state_num
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|NDEBUG
end_ifndef

begin_comment
comment|/* The following variables is maximal number of allocated nodes    `state'.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|allocated_states_num
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Allocate new reservation set.  */
end_comment

begin_function
specifier|static
name|reserv_sets_t
name|alloc_empty_reserv_sets
parameter_list|(
name|void
parameter_list|)
block|{
name|reserv_sets_t
name|result
decl_stmt|;
name|obstack_blank
argument_list|(
operator|&
name|irp
argument_list|,
name|els_in_reservs
operator|*
sizeof|sizeof
argument_list|(
name|set_el_t
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
operator|(
name|reserv_sets_t
operator|)
name|obstack_base
argument_list|(
operator|&
name|irp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|obstack_finish
argument_list|(
operator|&
name|irp
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|result
argument_list|,
literal|0
argument_list|,
name|els_in_reservs
operator|*
sizeof|sizeof
argument_list|(
name|set_el_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Hash value of reservation set.  */
end_comment

begin_function
specifier|static
name|unsigned
name|reserv_sets_hash_value
parameter_list|(
name|reserv_sets_t
name|reservs
parameter_list|)
block|{
name|set_el_t
name|hash_value
decl_stmt|;
name|unsigned
name|result
decl_stmt|;
name|int
name|reservs_num
decl_stmt|,
name|i
decl_stmt|;
name|set_el_t
modifier|*
name|reserv_ptr
decl_stmt|;
name|hash_value
operator|=
literal|0
expr_stmt|;
name|reservs_num
operator|=
name|els_in_reservs
expr_stmt|;
name|reserv_ptr
operator|=
name|reservs
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|reservs_num
operator|!=
literal|0
condition|)
block|{
name|reservs_num
operator|--
expr_stmt|;
name|hash_value
operator|+=
operator|(
operator|(
operator|*
name|reserv_ptr
operator|>>
name|i
operator|)
operator||
operator|(
operator|*
name|reserv_ptr
operator|<<
operator|(
sizeof|sizeof
argument_list|(
name|set_el_t
argument_list|)
operator|*
name|CHAR_BIT
operator|-
name|i
operator|)
operator|)
operator|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|==
sizeof|sizeof
argument_list|(
name|set_el_t
argument_list|)
operator|*
name|CHAR_BIT
condition|)
name|i
operator|=
literal|0
expr_stmt|;
name|reserv_ptr
operator|++
expr_stmt|;
block|}
if|if
condition|(
sizeof|sizeof
argument_list|(
name|set_el_t
argument_list|)
operator|<=
sizeof|sizeof
argument_list|(
name|unsigned
argument_list|)
condition|)
return|return
name|hash_value
return|;
name|result
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
sizeof|sizeof
argument_list|(
name|set_el_t
argument_list|)
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|-=
sizeof|sizeof
argument_list|(
name|unsigned
argument_list|)
operator|-
literal|1
control|)
block|{
name|result
operator|+=
operator|(
name|unsigned
operator|)
name|hash_value
expr_stmt|;
name|hash_value
operator|>>=
operator|(
sizeof|sizeof
argument_list|(
name|unsigned
argument_list|)
operator|-
literal|1
operator|)
operator|*
name|CHAR_BIT
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Comparison of given reservation sets.  */
end_comment

begin_function
specifier|static
name|int
name|reserv_sets_cmp
parameter_list|(
name|reserv_sets_t
name|reservs_1
parameter_list|,
name|reserv_sets_t
name|reservs_2
parameter_list|)
block|{
name|int
name|reservs_num
decl_stmt|;
name|set_el_t
modifier|*
name|reserv_ptr_1
decl_stmt|;
name|set_el_t
modifier|*
name|reserv_ptr_2
decl_stmt|;
name|gcc_assert
argument_list|(
name|reservs_1
operator|&&
name|reservs_2
argument_list|)
expr_stmt|;
name|reservs_num
operator|=
name|els_in_reservs
expr_stmt|;
name|reserv_ptr_1
operator|=
name|reservs_1
expr_stmt|;
name|reserv_ptr_2
operator|=
name|reservs_2
expr_stmt|;
while|while
condition|(
name|reservs_num
operator|!=
literal|0
operator|&&
operator|*
name|reserv_ptr_1
operator|==
operator|*
name|reserv_ptr_2
condition|)
block|{
name|reservs_num
operator|--
expr_stmt|;
name|reserv_ptr_1
operator|++
expr_stmt|;
name|reserv_ptr_2
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|reservs_num
operator|==
literal|0
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
operator|*
name|reserv_ptr_1
operator|<
operator|*
name|reserv_ptr_2
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* The function checks equality of the reservation sets.  */
end_comment

begin_function
specifier|static
name|int
name|reserv_sets_eq
parameter_list|(
name|reserv_sets_t
name|reservs_1
parameter_list|,
name|reserv_sets_t
name|reservs_2
parameter_list|)
block|{
return|return
name|reserv_sets_cmp
argument_list|(
name|reservs_1
argument_list|,
name|reservs_2
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Set up in the reservation set that unit with UNIT_NUM is used on    CYCLE_NUM.  */
end_comment

begin_function
specifier|static
name|void
name|set_unit_reserv
parameter_list|(
name|reserv_sets_t
name|reservs
parameter_list|,
name|int
name|cycle_num
parameter_list|,
name|int
name|unit_num
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|cycle_num
operator|<
name|max_cycles_num
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|reservs
argument_list|,
name|cycle_num
operator|*
name|els_in_cycle_reserv
operator|*
sizeof|sizeof
argument_list|(
name|set_el_t
argument_list|)
operator|*
name|CHAR_BIT
operator|+
name|unit_num
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set up in the reservation set RESERVS that unit with UNIT_NUM is    used on CYCLE_NUM.  */
end_comment

begin_function
specifier|static
name|int
name|test_unit_reserv
parameter_list|(
name|reserv_sets_t
name|reservs
parameter_list|,
name|int
name|cycle_num
parameter_list|,
name|int
name|unit_num
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|cycle_num
operator|<
name|max_cycles_num
argument_list|)
expr_stmt|;
return|return
name|TEST_BIT
argument_list|(
name|reservs
argument_list|,
name|cycle_num
operator|*
name|els_in_cycle_reserv
operator|*
sizeof|sizeof
argument_list|(
name|set_el_t
argument_list|)
operator|*
name|CHAR_BIT
operator|+
name|unit_num
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The function checks that the reservation sets are intersected,    i.e. there is a unit reservation on a cycle in both reservation    sets.  */
end_comment

begin_function
specifier|static
name|int
name|reserv_sets_are_intersected
parameter_list|(
name|reserv_sets_t
name|operand_1
parameter_list|,
name|reserv_sets_t
name|operand_2
parameter_list|)
block|{
name|set_el_t
modifier|*
name|el_ptr_1
decl_stmt|;
name|set_el_t
modifier|*
name|el_ptr_2
decl_stmt|;
name|set_el_t
modifier|*
name|cycle_ptr_1
decl_stmt|;
name|set_el_t
modifier|*
name|cycle_ptr_2
decl_stmt|;
name|gcc_assert
argument_list|(
name|operand_1
operator|&&
name|operand_2
argument_list|)
expr_stmt|;
for|for
control|(
name|el_ptr_1
operator|=
name|operand_1
operator|,
name|el_ptr_2
operator|=
name|operand_2
init|;
name|el_ptr_1
operator|<
name|operand_1
operator|+
name|els_in_reservs
condition|;
name|el_ptr_1
operator|++
operator|,
name|el_ptr_2
operator|++
control|)
if|if
condition|(
operator|*
name|el_ptr_1
operator|&
operator|*
name|el_ptr_2
condition|)
return|return
literal|1
return|;
name|reserv_sets_or
argument_list|(
name|temp_reserv
argument_list|,
name|operand_1
argument_list|,
name|operand_2
argument_list|)
expr_stmt|;
for|for
control|(
name|cycle_ptr_1
operator|=
name|operand_1
operator|,
name|cycle_ptr_2
operator|=
name|operand_2
init|;
name|cycle_ptr_1
operator|<
name|operand_1
operator|+
name|els_in_reservs
condition|;
name|cycle_ptr_1
operator|+=
name|els_in_cycle_reserv
operator|,
name|cycle_ptr_2
operator|+=
name|els_in_cycle_reserv
control|)
block|{
for|for
control|(
name|el_ptr_1
operator|=
name|cycle_ptr_1
operator|,
name|el_ptr_2
operator|=
name|get_excl_set
argument_list|(
name|cycle_ptr_2
argument_list|)
init|;
name|el_ptr_1
operator|<
name|cycle_ptr_1
operator|+
name|els_in_cycle_reserv
condition|;
name|el_ptr_1
operator|++
operator|,
name|el_ptr_2
operator|++
control|)
if|if
condition|(
operator|*
name|el_ptr_1
operator|&
operator|*
name|el_ptr_2
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|check_presence_pattern_sets
argument_list|(
name|cycle_ptr_1
argument_list|,
name|cycle_ptr_2
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|check_presence_pattern_sets
argument_list|(
name|temp_reserv
operator|+
operator|(
name|cycle_ptr_2
operator|-
name|operand_2
operator|)
argument_list|,
name|cycle_ptr_2
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|check_absence_pattern_sets
argument_list|(
name|cycle_ptr_1
argument_list|,
name|cycle_ptr_2
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|check_absence_pattern_sets
argument_list|(
name|temp_reserv
operator|+
operator|(
name|cycle_ptr_2
operator|-
name|operand_2
operator|)
argument_list|,
name|cycle_ptr_2
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* The function sets up RESULT bits by bits of OPERAND shifted on one    cpu cycle.  The remaining bits of OPERAND (representing the last    cycle unit reservations) are not changed.  */
end_comment

begin_function
specifier|static
name|void
name|reserv_sets_shift
parameter_list|(
name|reserv_sets_t
name|result
parameter_list|,
name|reserv_sets_t
name|operand
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|gcc_assert
argument_list|(
name|result
operator|&&
name|operand
operator|&&
name|result
operator|!=
name|operand
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|els_in_cycle_reserv
init|;
name|i
operator|<
name|els_in_reservs
condition|;
name|i
operator|++
control|)
name|result
index|[
name|i
operator|-
name|els_in_cycle_reserv
index|]
operator|=
name|operand
index|[
name|i
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* OR of the reservation sets.  */
end_comment

begin_function
specifier|static
name|void
name|reserv_sets_or
parameter_list|(
name|reserv_sets_t
name|result
parameter_list|,
name|reserv_sets_t
name|operand_1
parameter_list|,
name|reserv_sets_t
name|operand_2
parameter_list|)
block|{
name|set_el_t
modifier|*
name|el_ptr_1
decl_stmt|;
name|set_el_t
modifier|*
name|el_ptr_2
decl_stmt|;
name|set_el_t
modifier|*
name|result_set_el_ptr
decl_stmt|;
name|gcc_assert
argument_list|(
name|result
operator|&&
name|operand_1
operator|&&
name|operand_2
argument_list|)
expr_stmt|;
for|for
control|(
name|el_ptr_1
operator|=
name|operand_1
operator|,
name|el_ptr_2
operator|=
name|operand_2
operator|,
name|result_set_el_ptr
operator|=
name|result
init|;
name|el_ptr_1
operator|<
name|operand_1
operator|+
name|els_in_reservs
condition|;
name|el_ptr_1
operator|++
operator|,
name|el_ptr_2
operator|++
operator|,
name|result_set_el_ptr
operator|++
control|)
operator|*
name|result_set_el_ptr
operator|=
operator|*
name|el_ptr_1
operator||
operator|*
name|el_ptr_2
expr_stmt|;
block|}
end_function

begin_comment
comment|/* AND of the reservation sets.  */
end_comment

begin_function
specifier|static
name|void
name|reserv_sets_and
parameter_list|(
name|reserv_sets_t
name|result
parameter_list|,
name|reserv_sets_t
name|operand_1
parameter_list|,
name|reserv_sets_t
name|operand_2
parameter_list|)
block|{
name|set_el_t
modifier|*
name|el_ptr_1
decl_stmt|;
name|set_el_t
modifier|*
name|el_ptr_2
decl_stmt|;
name|set_el_t
modifier|*
name|result_set_el_ptr
decl_stmt|;
name|gcc_assert
argument_list|(
name|result
operator|&&
name|operand_1
operator|&&
name|operand_2
argument_list|)
expr_stmt|;
for|for
control|(
name|el_ptr_1
operator|=
name|operand_1
operator|,
name|el_ptr_2
operator|=
name|operand_2
operator|,
name|result_set_el_ptr
operator|=
name|result
init|;
name|el_ptr_1
operator|<
name|operand_1
operator|+
name|els_in_reservs
condition|;
name|el_ptr_1
operator|++
operator|,
name|el_ptr_2
operator|++
operator|,
name|result_set_el_ptr
operator|++
control|)
operator|*
name|result_set_el_ptr
operator|=
operator|*
name|el_ptr_1
operator|&
operator|*
name|el_ptr_2
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function outputs string representation of units reservation on    cycle START_CYCLE in the reservation set.  The function uses repeat    construction if REPETITION_NUM> 1.  */
end_comment

begin_function
specifier|static
name|void
name|output_cycle_reservs
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|reserv_sets_t
name|reservs
parameter_list|,
name|int
name|start_cycle
parameter_list|,
name|int
name|repetition_num
parameter_list|)
block|{
name|int
name|unit_num
decl_stmt|;
name|int
name|reserved_units_num
decl_stmt|;
name|reserved_units_num
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|unit_num
operator|=
literal|0
init|;
name|unit_num
operator|<
name|description
operator|->
name|units_num
condition|;
name|unit_num
operator|++
control|)
if|if
condition|(
name|TEST_BIT
argument_list|(
name|reservs
argument_list|,
name|start_cycle
operator|*
name|els_in_cycle_reserv
operator|*
sizeof|sizeof
argument_list|(
name|set_el_t
argument_list|)
operator|*
name|CHAR_BIT
operator|+
name|unit_num
argument_list|)
condition|)
name|reserved_units_num
operator|++
expr_stmt|;
name|gcc_assert
argument_list|(
name|repetition_num
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|repetition_num
operator|!=
literal|1
operator|&&
name|reserved_units_num
operator|>
literal|1
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|reserved_units_num
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|unit_num
operator|=
literal|0
init|;
name|unit_num
operator|<
name|description
operator|->
name|units_num
condition|;
name|unit_num
operator|++
control|)
if|if
condition|(
name|TEST_BIT
argument_list|(
name|reservs
argument_list|,
name|start_cycle
operator|*
name|els_in_cycle_reserv
operator|*
sizeof|sizeof
argument_list|(
name|set_el_t
argument_list|)
operator|*
name|CHAR_BIT
operator|+
name|unit_num
argument_list|)
condition|)
block|{
if|if
condition|(
name|reserved_units_num
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"+"
argument_list|)
expr_stmt|;
name|reserved_units_num
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s"
argument_list|,
name|units_array
index|[
name|unit_num
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reserved_units_num
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
name|NOTHING_NAME
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|repetition_num
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|repetition_num
operator|!=
literal|1
operator|&&
name|reserved_units_num
operator|>
literal|1
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
if|if
condition|(
name|repetition_num
operator|!=
literal|1
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"*%d"
argument_list|,
name|repetition_num
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function outputs string representation of units reservation in    the reservation set.  */
end_comment

begin_function
specifier|static
name|void
name|output_reserv_sets
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|reserv_sets_t
name|reservs
parameter_list|)
block|{
name|int
name|start_cycle
init|=
literal|0
decl_stmt|;
name|int
name|cycle
decl_stmt|;
name|int
name|repetition_num
decl_stmt|;
name|repetition_num
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cycle
operator|=
literal|0
init|;
name|cycle
operator|<
name|max_cycles_num
condition|;
name|cycle
operator|++
control|)
if|if
condition|(
name|repetition_num
operator|==
literal|0
condition|)
block|{
name|repetition_num
operator|++
expr_stmt|;
name|start_cycle
operator|=
name|cycle
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|memcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reservs
operator|+
name|start_cycle
operator|*
name|els_in_cycle_reserv
operator|*
sizeof|sizeof
argument_list|(
name|set_el_t
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|reservs
operator|+
name|cycle
operator|*
name|els_in_cycle_reserv
operator|*
sizeof|sizeof
argument_list|(
name|set_el_t
argument_list|)
argument_list|,
name|els_in_cycle_reserv
operator|*
sizeof|sizeof
argument_list|(
name|set_el_t
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|repetition_num
operator|++
expr_stmt|;
else|else
block|{
if|if
condition|(
name|start_cycle
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|output_cycle_reservs
argument_list|(
name|f
argument_list|,
name|reservs
argument_list|,
name|start_cycle
argument_list|,
name|repetition_num
argument_list|)
expr_stmt|;
name|repetition_num
operator|=
literal|1
expr_stmt|;
name|start_cycle
operator|=
name|cycle
expr_stmt|;
block|}
if|if
condition|(
name|start_cycle
operator|<
name|max_cycles_num
condition|)
block|{
if|if
condition|(
name|start_cycle
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|output_cycle_reservs
argument_list|(
name|f
argument_list|,
name|reservs
argument_list|,
name|start_cycle
argument_list|,
name|repetition_num
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The following function returns free node state for AUTOMATON.  It    may be new allocated node or node freed earlier.  The function also    allocates reservation set if WITH_RESERVS has nonzero value.  */
end_comment

begin_function
specifier|static
name|state_t
name|get_free_state
parameter_list|(
name|int
name|with_reservs
parameter_list|,
name|automaton_t
name|automaton
parameter_list|)
block|{
name|state_t
name|result
decl_stmt|;
name|gcc_assert
argument_list|(
name|max_cycles_num
operator|>
literal|0
operator|&&
name|automaton
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_free_state
condition|)
block|{
name|result
operator|=
name|first_free_state
expr_stmt|;
name|first_free_state
operator|=
name|result
operator|->
name|next_equiv_class_state
expr_stmt|;
name|result
operator|->
name|next_equiv_class_state
operator|=
name|NULL
expr_stmt|;
name|result
operator|->
name|automaton
operator|=
name|automaton
expr_stmt|;
name|result
operator|->
name|first_out_arc
operator|=
name|NULL
expr_stmt|;
name|result
operator|->
name|it_was_placed_in_stack_for_NDFA_forming
operator|=
literal|0
expr_stmt|;
name|result
operator|->
name|it_was_placed_in_stack_for_DFA_forming
operator|=
literal|0
expr_stmt|;
name|result
operator|->
name|component_states
operator|=
name|NULL
expr_stmt|;
name|result
operator|->
name|longest_path_length
operator|=
name|UNDEFINED_LONGEST_PATH_LENGTH
expr_stmt|;
block|}
else|else
block|{
ifndef|#
directive|ifndef
name|NDEBUG
name|allocated_states_num
operator|++
expr_stmt|;
endif|#
directive|endif
name|result
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|state
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|->
name|automaton
operator|=
name|automaton
expr_stmt|;
name|result
operator|->
name|first_out_arc
operator|=
name|NULL
expr_stmt|;
name|result
operator|->
name|unique_num
operator|=
name|curr_unique_state_num
expr_stmt|;
name|result
operator|->
name|longest_path_length
operator|=
name|UNDEFINED_LONGEST_PATH_LENGTH
expr_stmt|;
name|curr_unique_state_num
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|with_reservs
condition|)
block|{
if|if
condition|(
name|result
operator|->
name|reservs
operator|==
name|NULL
condition|)
name|result
operator|->
name|reservs
operator|=
name|alloc_empty_reserv_sets
argument_list|()
expr_stmt|;
else|else
name|memset
argument_list|(
name|result
operator|->
name|reservs
argument_list|,
literal|0
argument_list|,
name|els_in_reservs
operator|*
sizeof|sizeof
argument_list|(
name|set_el_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* The function frees node STATE.  */
end_comment

begin_function
specifier|static
name|void
name|free_state
parameter_list|(
name|state_t
name|state
parameter_list|)
block|{
name|free_alt_states
argument_list|(
name|state
operator|->
name|component_states
argument_list|)
expr_stmt|;
name|state
operator|->
name|next_equiv_class_state
operator|=
name|first_free_state
expr_stmt|;
name|first_free_state
operator|=
name|state
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Hash value of STATE.  If STATE represents deterministic state it is    simply hash value of the corresponding reservation set.  Otherwise    it is formed from hash values of the component deterministic    states.  One more key is order number of state automaton.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|state_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|state
parameter_list|)
block|{
name|unsigned
name|int
name|hash_value
decl_stmt|;
name|alt_state_t
name|alt_state
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|state_t
operator|)
name|state
operator|)
operator|->
name|component_states
operator|==
name|NULL
condition|)
name|hash_value
operator|=
name|reserv_sets_hash_value
argument_list|(
operator|(
operator|(
name|state_t
operator|)
name|state
operator|)
operator|->
name|reservs
argument_list|)
expr_stmt|;
else|else
block|{
name|hash_value
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|alt_state
operator|=
operator|(
operator|(
name|state_t
operator|)
name|state
operator|)
operator|->
name|component_states
init|;
name|alt_state
operator|!=
name|NULL
condition|;
name|alt_state
operator|=
name|alt_state
operator|->
name|next_sorted_alt_state
control|)
name|hash_value
operator|=
operator|(
operator|(
operator|(
name|hash_value
operator|>>
operator|(
sizeof|sizeof
argument_list|(
name|unsigned
argument_list|)
operator|-
literal|1
operator|)
operator|*
name|CHAR_BIT
operator|)
operator||
operator|(
name|hash_value
operator|<<
name|CHAR_BIT
operator|)
operator|)
operator|+
name|alt_state
operator|->
name|state
operator|->
name|unique_num
operator|)
expr_stmt|;
block|}
name|hash_value
operator|=
operator|(
operator|(
operator|(
name|hash_value
operator|>>
operator|(
sizeof|sizeof
argument_list|(
name|unsigned
argument_list|)
operator|-
literal|1
operator|)
operator|*
name|CHAR_BIT
operator|)
operator||
operator|(
name|hash_value
operator|<<
name|CHAR_BIT
operator|)
operator|)
operator|+
operator|(
operator|(
name|state_t
operator|)
name|state
operator|)
operator|->
name|automaton
operator|->
name|automaton_order_num
operator|)
expr_stmt|;
return|return
name|hash_value
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero value if the states are the same.  */
end_comment

begin_function
specifier|static
name|int
name|state_eq_p
parameter_list|(
specifier|const
name|void
modifier|*
name|state_1
parameter_list|,
specifier|const
name|void
modifier|*
name|state_2
parameter_list|)
block|{
name|alt_state_t
name|alt_state_1
decl_stmt|;
name|alt_state_t
name|alt_state_2
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|state_t
operator|)
name|state_1
operator|)
operator|->
name|automaton
operator|!=
operator|(
operator|(
name|state_t
operator|)
name|state_2
operator|)
operator|->
name|automaton
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
operator|(
operator|(
name|state_t
operator|)
name|state_1
operator|)
operator|->
name|component_states
operator|==
name|NULL
operator|&&
operator|(
operator|(
name|state_t
operator|)
name|state_2
operator|)
operator|->
name|component_states
operator|==
name|NULL
condition|)
return|return
name|reserv_sets_eq
argument_list|(
operator|(
operator|(
name|state_t
operator|)
name|state_1
operator|)
operator|->
name|reservs
argument_list|,
operator|(
operator|(
name|state_t
operator|)
name|state_2
operator|)
operator|->
name|reservs
argument_list|)
return|;
elseif|else
if|if
condition|(
operator|(
operator|(
name|state_t
operator|)
name|state_1
operator|)
operator|->
name|component_states
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|state_t
operator|)
name|state_2
operator|)
operator|->
name|component_states
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|alt_state_1
operator|=
operator|(
operator|(
name|state_t
operator|)
name|state_1
operator|)
operator|->
name|component_states
operator|,
name|alt_state_2
operator|=
operator|(
operator|(
name|state_t
operator|)
name|state_2
operator|)
operator|->
name|component_states
init|;
name|alt_state_1
operator|!=
name|NULL
operator|&&
name|alt_state_2
operator|!=
name|NULL
condition|;
name|alt_state_1
operator|=
name|alt_state_1
operator|->
name|next_sorted_alt_state
operator|,
name|alt_state_2
operator|=
name|alt_state_2
operator|->
name|next_sorted_alt_state
control|)
comment|/* All state in the list must be already in the hash table.            Also the lists must be sorted.  */
if|if
condition|(
name|alt_state_1
operator|->
name|state
operator|!=
name|alt_state_2
operator|->
name|state
condition|)
return|return
literal|0
return|;
return|return
name|alt_state_1
operator|==
name|alt_state_2
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Insert STATE into the state table.  */
end_comment

begin_function
specifier|static
name|state_t
name|insert_state
parameter_list|(
name|state_t
name|state
parameter_list|)
block|{
name|void
modifier|*
modifier|*
name|entry_ptr
decl_stmt|;
name|entry_ptr
operator|=
name|htab_find_slot
argument_list|(
name|state_table
argument_list|,
operator|(
name|void
operator|*
operator|)
name|state
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|entry_ptr
operator|==
name|NULL
condition|)
operator|*
name|entry_ptr
operator|=
operator|(
name|void
operator|*
operator|)
name|state
expr_stmt|;
return|return
operator|(
name|state_t
operator|)
operator|*
name|entry_ptr
return|;
block|}
end_function

begin_comment
comment|/* Add reservation of unit with UNIT_NUM on cycle CYCLE_NUM to    deterministic STATE.  */
end_comment

begin_function
specifier|static
name|void
name|set_state_reserv
parameter_list|(
name|state_t
name|state
parameter_list|,
name|int
name|cycle_num
parameter_list|,
name|int
name|unit_num
parameter_list|)
block|{
name|set_unit_reserv
argument_list|(
name|state
operator|->
name|reservs
argument_list|,
name|cycle_num
argument_list|,
name|unit_num
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return nonzero value if the deterministic states contains a    reservation of the same cpu unit on the same cpu cycle.  */
end_comment

begin_function
specifier|static
name|int
name|intersected_state_reservs_p
parameter_list|(
name|state_t
name|state1
parameter_list|,
name|state_t
name|state2
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|state1
operator|->
name|automaton
operator|==
name|state2
operator|->
name|automaton
argument_list|)
expr_stmt|;
return|return
name|reserv_sets_are_intersected
argument_list|(
name|state1
operator|->
name|reservs
argument_list|,
name|state2
operator|->
name|reservs
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return deterministic state (inserted into the table) which    representing the automaton state which is union of reservations of    the deterministic states masked by RESERVS.  */
end_comment

begin_function
specifier|static
name|state_t
name|states_union
parameter_list|(
name|state_t
name|state1
parameter_list|,
name|state_t
name|state2
parameter_list|,
name|reserv_sets_t
name|reservs
parameter_list|)
block|{
name|state_t
name|result
decl_stmt|;
name|state_t
name|state_in_table
decl_stmt|;
name|gcc_assert
argument_list|(
name|state1
operator|->
name|automaton
operator|==
name|state2
operator|->
name|automaton
argument_list|)
expr_stmt|;
name|result
operator|=
name|get_free_state
argument_list|(
literal|1
argument_list|,
name|state1
operator|->
name|automaton
argument_list|)
expr_stmt|;
name|reserv_sets_or
argument_list|(
name|result
operator|->
name|reservs
argument_list|,
name|state1
operator|->
name|reservs
argument_list|,
name|state2
operator|->
name|reservs
argument_list|)
expr_stmt|;
name|reserv_sets_and
argument_list|(
name|result
operator|->
name|reservs
argument_list|,
name|result
operator|->
name|reservs
argument_list|,
name|reservs
argument_list|)
expr_stmt|;
name|state_in_table
operator|=
name|insert_state
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|state_in_table
condition|)
block|{
name|free_state
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|result
operator|=
name|state_in_table
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Return deterministic state (inserted into the table) which    represent the automaton state is obtained from deterministic STATE    by advancing cpu cycle and masking by RESERVS.  */
end_comment

begin_function
specifier|static
name|state_t
name|state_shift
parameter_list|(
name|state_t
name|state
parameter_list|,
name|reserv_sets_t
name|reservs
parameter_list|)
block|{
name|state_t
name|result
decl_stmt|;
name|state_t
name|state_in_table
decl_stmt|;
name|result
operator|=
name|get_free_state
argument_list|(
literal|1
argument_list|,
name|state
operator|->
name|automaton
argument_list|)
expr_stmt|;
name|reserv_sets_shift
argument_list|(
name|result
operator|->
name|reservs
argument_list|,
name|state
operator|->
name|reservs
argument_list|)
expr_stmt|;
name|reserv_sets_and
argument_list|(
name|result
operator|->
name|reservs
argument_list|,
name|result
operator|->
name|reservs
argument_list|,
name|reservs
argument_list|)
expr_stmt|;
name|state_in_table
operator|=
name|insert_state
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|state_in_table
condition|)
block|{
name|free_state
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|result
operator|=
name|state_in_table
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Initialization of the abstract data.  */
end_comment

begin_function
specifier|static
name|void
name|initiate_states
parameter_list|(
name|void
parameter_list|)
block|{
name|decl_t
name|decl
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|description
operator|->
name|units_num
condition|)
name|units_array
operator|=
name|XNEWVEC
argument_list|(
name|unit_decl_t
argument_list|,
name|description
operator|->
name|units_num
argument_list|)
expr_stmt|;
else|else
name|units_array
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_unit
condition|)
name|units_array
index|[
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|unit_num
index|]
operator|=
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
name|max_cycles_num
operator|=
name|description
operator|->
name|max_insn_reserv_cycles
expr_stmt|;
name|els_in_cycle_reserv
operator|=
operator|(
operator|(
name|description
operator|->
name|units_num
operator|+
sizeof|sizeof
argument_list|(
name|set_el_t
argument_list|)
operator|*
name|CHAR_BIT
operator|-
literal|1
operator|)
operator|/
operator|(
sizeof|sizeof
argument_list|(
name|set_el_t
argument_list|)
operator|*
name|CHAR_BIT
operator|)
operator|)
expr_stmt|;
name|els_in_reservs
operator|=
name|els_in_cycle_reserv
operator|*
name|max_cycles_num
expr_stmt|;
name|curr_unique_state_num
operator|=
literal|0
expr_stmt|;
name|initiate_alt_states
argument_list|()
expr_stmt|;
name|state_table
operator|=
name|htab_create
argument_list|(
literal|1500
argument_list|,
name|state_hash
argument_list|,
name|state_eq_p
argument_list|,
operator|(
name|htab_del
operator|)
literal|0
argument_list|)
expr_stmt|;
name|temp_reserv
operator|=
name|alloc_empty_reserv_sets
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finishing work with the abstract data.  */
end_comment

begin_function
specifier|static
name|void
name|finish_states
parameter_list|(
name|void
parameter_list|)
block|{
name|free
argument_list|(
name|units_array
argument_list|)
expr_stmt|;
name|units_array
operator|=
literal|0
expr_stmt|;
name|htab_delete
argument_list|(
name|state_table
argument_list|)
expr_stmt|;
name|first_free_state
operator|=
name|NULL
expr_stmt|;
name|finish_alt_states
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Abstract data `arcs'.  */
end_comment

begin_comment
comment|/* List of free arcs.  */
end_comment

begin_decl_stmt
specifier|static
name|arc_t
name|first_free_arc
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|NDEBUG
end_ifndef

begin_comment
comment|/* The following variables is maximal number of allocated nodes    `arc'.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|allocated_arcs_num
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The function frees node ARC.  */
end_comment

begin_function
specifier|static
name|void
name|free_arc
parameter_list|(
name|arc_t
name|arc
parameter_list|)
block|{
name|arc
operator|->
name|next_out_arc
operator|=
name|first_free_arc
expr_stmt|;
name|first_free_arc
operator|=
name|arc
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function removes and frees ARC staring from FROM_STATE.  */
end_comment

begin_function
specifier|static
name|void
name|remove_arc
parameter_list|(
name|state_t
name|from_state
parameter_list|,
name|arc_t
name|arc
parameter_list|)
block|{
name|arc_t
name|prev_arc
decl_stmt|;
name|arc_t
name|curr_arc
decl_stmt|;
name|gcc_assert
argument_list|(
name|arc
argument_list|)
expr_stmt|;
for|for
control|(
name|prev_arc
operator|=
name|NULL
operator|,
name|curr_arc
operator|=
name|from_state
operator|->
name|first_out_arc
init|;
name|curr_arc
operator|!=
name|NULL
condition|;
name|prev_arc
operator|=
name|curr_arc
operator|,
name|curr_arc
operator|=
name|curr_arc
operator|->
name|next_out_arc
control|)
if|if
condition|(
name|curr_arc
operator|==
name|arc
condition|)
break|break;
name|gcc_assert
argument_list|(
name|curr_arc
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev_arc
operator|==
name|NULL
condition|)
name|from_state
operator|->
name|first_out_arc
operator|=
name|arc
operator|->
name|next_out_arc
expr_stmt|;
else|else
name|prev_arc
operator|->
name|next_out_arc
operator|=
name|arc
operator|->
name|next_out_arc
expr_stmt|;
name|from_state
operator|->
name|num_out_arcs
operator|--
expr_stmt|;
name|free_arc
argument_list|(
name|arc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The functions returns arc with given characteristics (or NULL if    the arc does not exist).  */
end_comment

begin_function
specifier|static
name|arc_t
name|find_arc
parameter_list|(
name|state_t
name|from_state
parameter_list|,
name|state_t
name|to_state
parameter_list|,
name|ainsn_t
name|insn
parameter_list|)
block|{
name|arc_t
name|arc
decl_stmt|;
for|for
control|(
name|arc
operator|=
name|first_out_arc
argument_list|(
name|from_state
argument_list|)
init|;
name|arc
operator|!=
name|NULL
condition|;
name|arc
operator|=
name|next_out_arc
argument_list|(
name|arc
argument_list|)
control|)
if|if
condition|(
name|arc
operator|->
name|to_state
operator|==
name|to_state
operator|&&
name|arc
operator|->
name|insn
operator|==
name|insn
condition|)
return|return
name|arc
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* The function adds arc from FROM_STATE to TO_STATE marked by AINSN.    The function returns added arc (or already existing arc).  */
end_comment

begin_function
specifier|static
name|arc_t
name|add_arc
parameter_list|(
name|state_t
name|from_state
parameter_list|,
name|state_t
name|to_state
parameter_list|,
name|ainsn_t
name|ainsn
parameter_list|)
block|{
name|arc_t
name|new_arc
decl_stmt|;
name|new_arc
operator|=
name|find_arc
argument_list|(
name|from_state
argument_list|,
name|to_state
argument_list|,
name|ainsn
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_arc
operator|!=
name|NULL
condition|)
return|return
name|new_arc
return|;
if|if
condition|(
name|first_free_arc
operator|==
name|NULL
condition|)
block|{
ifndef|#
directive|ifndef
name|NDEBUG
name|allocated_arcs_num
operator|++
expr_stmt|;
endif|#
directive|endif
name|new_arc
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|arc
argument_list|)
argument_list|)
expr_stmt|;
name|new_arc
operator|->
name|to_state
operator|=
name|NULL
expr_stmt|;
name|new_arc
operator|->
name|insn
operator|=
name|NULL
expr_stmt|;
name|new_arc
operator|->
name|next_out_arc
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|new_arc
operator|=
name|first_free_arc
expr_stmt|;
name|first_free_arc
operator|=
name|first_free_arc
operator|->
name|next_out_arc
expr_stmt|;
block|}
name|new_arc
operator|->
name|to_state
operator|=
name|to_state
expr_stmt|;
name|new_arc
operator|->
name|insn
operator|=
name|ainsn
expr_stmt|;
name|ainsn
operator|->
name|arc_exists_p
operator|=
literal|1
expr_stmt|;
name|new_arc
operator|->
name|next_out_arc
operator|=
name|from_state
operator|->
name|first_out_arc
expr_stmt|;
name|from_state
operator|->
name|first_out_arc
operator|=
name|new_arc
expr_stmt|;
name|from_state
operator|->
name|num_out_arcs
operator|++
expr_stmt|;
name|new_arc
operator|->
name|next_arc_marked_by_insn
operator|=
name|NULL
expr_stmt|;
return|return
name|new_arc
return|;
block|}
end_function

begin_comment
comment|/* The function returns the first arc starting from STATE.  */
end_comment

begin_function
specifier|static
name|arc_t
name|first_out_arc
parameter_list|(
name|state_t
name|state
parameter_list|)
block|{
return|return
name|state
operator|->
name|first_out_arc
return|;
block|}
end_function

begin_comment
comment|/* The function returns next out arc after ARC.  */
end_comment

begin_function
specifier|static
name|arc_t
name|next_out_arc
parameter_list|(
name|arc_t
name|arc
parameter_list|)
block|{
return|return
name|arc
operator|->
name|next_out_arc
return|;
block|}
end_function

begin_comment
comment|/* Initialization of the abstract data.  */
end_comment

begin_function
specifier|static
name|void
name|initiate_arcs
parameter_list|(
name|void
parameter_list|)
block|{
name|first_free_arc
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finishing work with the abstract data.  */
end_comment

begin_function
specifier|static
name|void
name|finish_arcs
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_escape
end_escape

begin_comment
comment|/* Abstract data `automata lists'.  */
end_comment

begin_comment
comment|/* List of free states.  */
end_comment

begin_decl_stmt
specifier|static
name|automata_list_el_t
name|first_free_automata_list_el
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The list being formed.  */
end_comment

begin_decl_stmt
specifier|static
name|automata_list_el_t
name|current_automata_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Hash table of automata lists.  */
end_comment

begin_decl_stmt
specifier|static
name|htab_t
name|automata_list_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following function returns free automata list el.  It may be    new allocated node or node freed earlier.  */
end_comment

begin_function
specifier|static
name|automata_list_el_t
name|get_free_automata_list_el
parameter_list|(
name|void
parameter_list|)
block|{
name|automata_list_el_t
name|result
decl_stmt|;
if|if
condition|(
name|first_free_automata_list_el
operator|!=
name|NULL
condition|)
block|{
name|result
operator|=
name|first_free_automata_list_el
expr_stmt|;
name|first_free_automata_list_el
operator|=
name|first_free_automata_list_el
operator|->
name|next_automata_list_el
expr_stmt|;
block|}
else|else
name|result
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|automata_list_el
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|->
name|automaton
operator|=
name|NULL
expr_stmt|;
name|result
operator|->
name|next_automata_list_el
operator|=
name|NULL
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* The function frees node AUTOMATA_LIST_EL.  */
end_comment

begin_function
specifier|static
name|void
name|free_automata_list_el
parameter_list|(
name|automata_list_el_t
name|automata_list_el
parameter_list|)
block|{
if|if
condition|(
name|automata_list_el
operator|==
name|NULL
condition|)
return|return;
name|automata_list_el
operator|->
name|next_automata_list_el
operator|=
name|first_free_automata_list_el
expr_stmt|;
name|first_free_automata_list_el
operator|=
name|automata_list_el
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function frees list AUTOMATA_LIST.  */
end_comment

begin_function
specifier|static
name|void
name|free_automata_list
parameter_list|(
name|automata_list_el_t
name|automata_list
parameter_list|)
block|{
name|automata_list_el_t
name|curr_automata_list_el
decl_stmt|;
name|automata_list_el_t
name|next_automata_list_el
decl_stmt|;
for|for
control|(
name|curr_automata_list_el
operator|=
name|automata_list
init|;
name|curr_automata_list_el
operator|!=
name|NULL
condition|;
name|curr_automata_list_el
operator|=
name|next_automata_list_el
control|)
block|{
name|next_automata_list_el
operator|=
name|curr_automata_list_el
operator|->
name|next_automata_list_el
expr_stmt|;
name|free_automata_list_el
argument_list|(
name|curr_automata_list_el
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Hash value of AUTOMATA_LIST.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|automata_list_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|automata_list
parameter_list|)
block|{
name|unsigned
name|int
name|hash_value
decl_stmt|;
name|automata_list_el_t
name|curr_automata_list_el
decl_stmt|;
name|hash_value
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|curr_automata_list_el
operator|=
operator|(
name|automata_list_el_t
operator|)
name|automata_list
init|;
name|curr_automata_list_el
operator|!=
name|NULL
condition|;
name|curr_automata_list_el
operator|=
name|curr_automata_list_el
operator|->
name|next_automata_list_el
control|)
name|hash_value
operator|=
operator|(
operator|(
operator|(
name|hash_value
operator|>>
operator|(
sizeof|sizeof
argument_list|(
name|unsigned
argument_list|)
operator|-
literal|1
operator|)
operator|*
name|CHAR_BIT
operator|)
operator||
operator|(
name|hash_value
operator|<<
name|CHAR_BIT
operator|)
operator|)
operator|+
name|curr_automata_list_el
operator|->
name|automaton
operator|->
name|automaton_order_num
operator|)
expr_stmt|;
return|return
name|hash_value
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero value if the automata_lists are the same.  */
end_comment

begin_function
specifier|static
name|int
name|automata_list_eq_p
parameter_list|(
specifier|const
name|void
modifier|*
name|automata_list_1
parameter_list|,
specifier|const
name|void
modifier|*
name|automata_list_2
parameter_list|)
block|{
name|automata_list_el_t
name|automata_list_el_1
decl_stmt|;
name|automata_list_el_t
name|automata_list_el_2
decl_stmt|;
for|for
control|(
name|automata_list_el_1
operator|=
operator|(
name|automata_list_el_t
operator|)
name|automata_list_1
operator|,
name|automata_list_el_2
operator|=
operator|(
name|automata_list_el_t
operator|)
name|automata_list_2
init|;
name|automata_list_el_1
operator|!=
name|NULL
operator|&&
name|automata_list_el_2
operator|!=
name|NULL
condition|;
name|automata_list_el_1
operator|=
name|automata_list_el_1
operator|->
name|next_automata_list_el
operator|,
name|automata_list_el_2
operator|=
name|automata_list_el_2
operator|->
name|next_automata_list_el
control|)
if|if
condition|(
name|automata_list_el_1
operator|->
name|automaton
operator|!=
name|automata_list_el_2
operator|->
name|automaton
condition|)
return|return
literal|0
return|;
return|return
name|automata_list_el_1
operator|==
name|automata_list_el_2
return|;
block|}
end_function

begin_comment
comment|/* Initialization of the abstract data.  */
end_comment

begin_function
specifier|static
name|void
name|initiate_automata_lists
parameter_list|(
name|void
parameter_list|)
block|{
name|first_free_automata_list_el
operator|=
name|NULL
expr_stmt|;
name|automata_list_table
operator|=
name|htab_create
argument_list|(
literal|1500
argument_list|,
name|automata_list_hash
argument_list|,
name|automata_list_eq_p
argument_list|,
operator|(
name|htab_del
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The following function starts new automata list and makes it the    current one.  */
end_comment

begin_function
specifier|static
name|void
name|automata_list_start
parameter_list|(
name|void
parameter_list|)
block|{
name|current_automata_list
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The following function adds AUTOMATON to the current list.  */
end_comment

begin_function
specifier|static
name|void
name|automata_list_add
parameter_list|(
name|automaton_t
name|automaton
parameter_list|)
block|{
name|automata_list_el_t
name|el
decl_stmt|;
name|el
operator|=
name|get_free_automata_list_el
argument_list|()
expr_stmt|;
name|el
operator|->
name|automaton
operator|=
name|automaton
expr_stmt|;
name|el
operator|->
name|next_automata_list_el
operator|=
name|current_automata_list
expr_stmt|;
name|current_automata_list
operator|=
name|el
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The following function finishes forming the current list, inserts    it into the table and returns it.  */
end_comment

begin_function
specifier|static
name|automata_list_el_t
name|automata_list_finish
parameter_list|(
name|void
parameter_list|)
block|{
name|void
modifier|*
modifier|*
name|entry_ptr
decl_stmt|;
if|if
condition|(
name|current_automata_list
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|entry_ptr
operator|=
name|htab_find_slot
argument_list|(
name|automata_list_table
argument_list|,
operator|(
name|void
operator|*
operator|)
name|current_automata_list
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|entry_ptr
operator|==
name|NULL
condition|)
operator|*
name|entry_ptr
operator|=
operator|(
name|void
operator|*
operator|)
name|current_automata_list
expr_stmt|;
else|else
name|free_automata_list
argument_list|(
name|current_automata_list
argument_list|)
expr_stmt|;
name|current_automata_list
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|automata_list_el_t
operator|)
operator|*
name|entry_ptr
return|;
block|}
end_function

begin_comment
comment|/* Finishing work with the abstract data.  */
end_comment

begin_function
specifier|static
name|void
name|finish_automata_lists
parameter_list|(
name|void
parameter_list|)
block|{
name|htab_delete
argument_list|(
name|automata_list_table
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The page contains abstract data for work with exclusion sets (see    exclusion_set in file rtl.def).  */
end_comment

begin_comment
comment|/* The following variable refers to an exclusion set returned by    get_excl_set.  This is bit string of length equal to cpu units    number.  If exclusion set for given unit contains 1 for a unit,    then simultaneous reservation of the units is prohibited.  */
end_comment

begin_decl_stmt
specifier|static
name|reserv_sets_t
name|excl_set
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The array contains exclusion sets for each unit.  */
end_comment

begin_decl_stmt
specifier|static
name|reserv_sets_t
modifier|*
name|unit_excl_set_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following function forms the array containing exclusion sets    for each unit.  */
end_comment

begin_function
specifier|static
name|void
name|initiate_excl_sets
parameter_list|(
name|void
parameter_list|)
block|{
name|decl_t
name|decl
decl_stmt|;
name|reserv_sets_t
name|unit_excl_set
decl_stmt|;
name|unit_set_el_t
name|el
decl_stmt|;
name|int
name|i
decl_stmt|;
name|obstack_blank
argument_list|(
operator|&
name|irp
argument_list|,
name|els_in_cycle_reserv
operator|*
sizeof|sizeof
argument_list|(
name|set_el_t
argument_list|)
argument_list|)
expr_stmt|;
name|excl_set
operator|=
operator|(
name|reserv_sets_t
operator|)
name|obstack_base
argument_list|(
operator|&
name|irp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|obstack_finish
argument_list|(
operator|&
name|irp
argument_list|)
expr_stmt|;
name|obstack_blank
argument_list|(
operator|&
name|irp
argument_list|,
name|description
operator|->
name|units_num
operator|*
sizeof|sizeof
argument_list|(
name|reserv_sets_t
argument_list|)
argument_list|)
expr_stmt|;
name|unit_excl_set_table
operator|=
operator|(
name|reserv_sets_t
operator|*
operator|)
name|obstack_base
argument_list|(
operator|&
name|irp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|obstack_finish
argument_list|(
operator|&
name|irp
argument_list|)
expr_stmt|;
comment|/* Evaluate unit exclusion sets.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_unit
condition|)
block|{
name|obstack_blank
argument_list|(
operator|&
name|irp
argument_list|,
name|els_in_cycle_reserv
operator|*
sizeof|sizeof
argument_list|(
name|set_el_t
argument_list|)
argument_list|)
expr_stmt|;
name|unit_excl_set
operator|=
operator|(
name|reserv_sets_t
operator|)
name|obstack_base
argument_list|(
operator|&
name|irp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|obstack_finish
argument_list|(
operator|&
name|irp
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|unit_excl_set
argument_list|,
literal|0
argument_list|,
name|els_in_cycle_reserv
operator|*
sizeof|sizeof
argument_list|(
name|set_el_t
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|el
operator|=
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|excl_list
init|;
name|el
operator|!=
name|NULL
condition|;
name|el
operator|=
name|el
operator|->
name|next_unit_set_el
control|)
block|{
name|SET_BIT
argument_list|(
name|unit_excl_set
argument_list|,
name|el
operator|->
name|unit_decl
operator|->
name|unit_num
argument_list|)
expr_stmt|;
name|el
operator|->
name|unit_decl
operator|->
name|in_set_p
operator|=
name|TRUE
expr_stmt|;
block|}
name|unit_excl_set_table
index|[
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|unit_num
index|]
operator|=
name|unit_excl_set
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* The function sets up and return EXCL_SET which is union of    exclusion sets for each unit in IN_SET.  */
end_comment

begin_function
specifier|static
name|reserv_sets_t
name|get_excl_set
parameter_list|(
name|reserv_sets_t
name|in_set
parameter_list|)
block|{
name|int
name|excl_char_num
decl_stmt|;
name|int
name|chars_num
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|start_unit_num
decl_stmt|;
name|int
name|unit_num
decl_stmt|;
name|chars_num
operator|=
name|els_in_cycle_reserv
operator|*
sizeof|sizeof
argument_list|(
name|set_el_t
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|excl_set
argument_list|,
literal|0
argument_list|,
name|chars_num
argument_list|)
expr_stmt|;
for|for
control|(
name|excl_char_num
operator|=
literal|0
init|;
name|excl_char_num
operator|<
name|chars_num
condition|;
name|excl_char_num
operator|++
control|)
if|if
condition|(
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|in_set
operator|)
index|[
name|excl_char_num
index|]
condition|)
for|for
control|(
name|i
operator|=
name|CHAR_BIT
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
operator|(
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|in_set
operator|)
index|[
name|excl_char_num
index|]
operator|>>
name|i
operator|)
operator|&
literal|1
condition|)
block|{
name|start_unit_num
operator|=
name|excl_char_num
operator|*
name|CHAR_BIT
operator|+
name|i
expr_stmt|;
if|if
condition|(
name|start_unit_num
operator|>=
name|description
operator|->
name|units_num
condition|)
return|return
name|excl_set
return|;
for|for
control|(
name|unit_num
operator|=
literal|0
init|;
name|unit_num
operator|<
name|els_in_cycle_reserv
condition|;
name|unit_num
operator|++
control|)
block|{
name|excl_set
index|[
name|unit_num
index|]
operator||=
name|unit_excl_set_table
index|[
name|start_unit_num
index|]
index|[
name|unit_num
index|]
expr_stmt|;
block|}
block|}
return|return
name|excl_set
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The page contains abstract data for work with presence/absence    pattern sets (see presence_set/absence_set in file rtl.def).  */
end_comment

begin_comment
comment|/* The following arrays contain correspondingly presence, final    presence, absence, and final absence patterns for each unit.  */
end_comment

begin_decl_stmt
specifier|static
name|pattern_reserv_t
modifier|*
name|unit_presence_set_table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|pattern_reserv_t
modifier|*
name|unit_final_presence_set_table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|pattern_reserv_t
modifier|*
name|unit_absence_set_table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|pattern_reserv_t
modifier|*
name|unit_final_absence_set_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following function forms list of reservation sets for given    PATTERN_LIST.  */
end_comment

begin_function
specifier|static
name|pattern_reserv_t
name|form_reserv_sets_list
parameter_list|(
name|pattern_set_el_t
name|pattern_list
parameter_list|)
block|{
name|pattern_set_el_t
name|el
decl_stmt|;
name|pattern_reserv_t
name|first
decl_stmt|,
name|curr
decl_stmt|,
name|prev
decl_stmt|;
name|int
name|i
decl_stmt|;
name|prev
operator|=
name|first
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|el
operator|=
name|pattern_list
init|;
name|el
operator|!=
name|NULL
condition|;
name|el
operator|=
name|el
operator|->
name|next_pattern_set_el
control|)
block|{
name|curr
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pattern_reserv
argument_list|)
argument_list|)
expr_stmt|;
name|curr
operator|->
name|reserv
operator|=
name|alloc_empty_reserv_sets
argument_list|()
expr_stmt|;
name|curr
operator|->
name|next_pattern_reserv
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|el
operator|->
name|units_num
condition|;
name|i
operator|++
control|)
block|{
name|SET_BIT
argument_list|(
name|curr
operator|->
name|reserv
argument_list|,
name|el
operator|->
name|unit_decls
index|[
name|i
index|]
operator|->
name|unit_num
argument_list|)
expr_stmt|;
name|el
operator|->
name|unit_decls
index|[
name|i
index|]
operator|->
name|in_set_p
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|prev
operator|!=
name|NULL
condition|)
name|prev
operator|->
name|next_pattern_reserv
operator|=
name|curr
expr_stmt|;
else|else
name|first
operator|=
name|curr
expr_stmt|;
name|prev
operator|=
name|curr
expr_stmt|;
block|}
return|return
name|first
return|;
block|}
end_function

begin_comment
comment|/* The following function forms the array containing presence and    absence pattern sets for each unit.  */
end_comment

begin_function
specifier|static
name|void
name|initiate_presence_absence_pattern_sets
parameter_list|(
name|void
parameter_list|)
block|{
name|decl_t
name|decl
decl_stmt|;
name|int
name|i
decl_stmt|;
name|obstack_blank
argument_list|(
operator|&
name|irp
argument_list|,
name|description
operator|->
name|units_num
operator|*
sizeof|sizeof
argument_list|(
name|pattern_reserv_t
argument_list|)
argument_list|)
expr_stmt|;
name|unit_presence_set_table
operator|=
operator|(
name|pattern_reserv_t
operator|*
operator|)
name|obstack_base
argument_list|(
operator|&
name|irp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|obstack_finish
argument_list|(
operator|&
name|irp
argument_list|)
expr_stmt|;
name|obstack_blank
argument_list|(
operator|&
name|irp
argument_list|,
name|description
operator|->
name|units_num
operator|*
sizeof|sizeof
argument_list|(
name|pattern_reserv_t
argument_list|)
argument_list|)
expr_stmt|;
name|unit_final_presence_set_table
operator|=
operator|(
name|pattern_reserv_t
operator|*
operator|)
name|obstack_base
argument_list|(
operator|&
name|irp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|obstack_finish
argument_list|(
operator|&
name|irp
argument_list|)
expr_stmt|;
name|obstack_blank
argument_list|(
operator|&
name|irp
argument_list|,
name|description
operator|->
name|units_num
operator|*
sizeof|sizeof
argument_list|(
name|pattern_reserv_t
argument_list|)
argument_list|)
expr_stmt|;
name|unit_absence_set_table
operator|=
operator|(
name|pattern_reserv_t
operator|*
operator|)
name|obstack_base
argument_list|(
operator|&
name|irp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|obstack_finish
argument_list|(
operator|&
name|irp
argument_list|)
expr_stmt|;
name|obstack_blank
argument_list|(
operator|&
name|irp
argument_list|,
name|description
operator|->
name|units_num
operator|*
sizeof|sizeof
argument_list|(
name|pattern_reserv_t
argument_list|)
argument_list|)
expr_stmt|;
name|unit_final_absence_set_table
operator|=
operator|(
name|pattern_reserv_t
operator|*
operator|)
name|obstack_base
argument_list|(
operator|&
name|irp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|obstack_finish
argument_list|(
operator|&
name|irp
argument_list|)
expr_stmt|;
comment|/* Evaluate unit presence/absence sets.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_unit
condition|)
block|{
name|unit_presence_set_table
index|[
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|unit_num
index|]
operator|=
name|form_reserv_sets_list
argument_list|(
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|presence_list
argument_list|)
expr_stmt|;
name|unit_final_presence_set_table
index|[
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|unit_num
index|]
operator|=
name|form_reserv_sets_list
argument_list|(
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|final_presence_list
argument_list|)
expr_stmt|;
name|unit_absence_set_table
index|[
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|unit_num
index|]
operator|=
name|form_reserv_sets_list
argument_list|(
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|absence_list
argument_list|)
expr_stmt|;
name|unit_final_absence_set_table
index|[
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|unit_num
index|]
operator|=
name|form_reserv_sets_list
argument_list|(
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|final_absence_list
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* The function checks that CHECKED_SET satisfies all presence pattern    sets for units in ORIGIONAL_SET.  The function returns TRUE if it    is ok.  */
end_comment

begin_function
specifier|static
name|int
name|check_presence_pattern_sets
parameter_list|(
name|reserv_sets_t
name|checked_set
parameter_list|,
name|reserv_sets_t
name|origional_set
parameter_list|,
name|int
name|final_p
parameter_list|)
block|{
name|int
name|char_num
decl_stmt|;
name|int
name|chars_num
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|start_unit_num
decl_stmt|;
name|int
name|unit_num
decl_stmt|;
name|int
name|presence_p
decl_stmt|;
name|pattern_reserv_t
name|pat_reserv
decl_stmt|;
name|chars_num
operator|=
name|els_in_cycle_reserv
operator|*
sizeof|sizeof
argument_list|(
name|set_el_t
argument_list|)
expr_stmt|;
for|for
control|(
name|char_num
operator|=
literal|0
init|;
name|char_num
operator|<
name|chars_num
condition|;
name|char_num
operator|++
control|)
if|if
condition|(
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|origional_set
operator|)
index|[
name|char_num
index|]
condition|)
for|for
control|(
name|i
operator|=
name|CHAR_BIT
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
operator|(
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|origional_set
operator|)
index|[
name|char_num
index|]
operator|>>
name|i
operator|)
operator|&
literal|1
condition|)
block|{
name|start_unit_num
operator|=
name|char_num
operator|*
name|CHAR_BIT
operator|+
name|i
expr_stmt|;
if|if
condition|(
name|start_unit_num
operator|>=
name|description
operator|->
name|units_num
condition|)
break|break;
if|if
condition|(
operator|(
name|final_p
operator|&&
name|unit_final_presence_set_table
index|[
name|start_unit_num
index|]
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|!
name|final_p
operator|&&
name|unit_presence_set_table
index|[
name|start_unit_num
index|]
operator|==
name|NULL
operator|)
condition|)
continue|continue;
name|presence_p
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|pat_reserv
operator|=
operator|(
name|final_p
condition|?
name|unit_final_presence_set_table
index|[
name|start_unit_num
index|]
else|:
name|unit_presence_set_table
index|[
name|start_unit_num
index|]
operator|)
init|;
name|pat_reserv
operator|!=
name|NULL
condition|;
name|pat_reserv
operator|=
name|pat_reserv
operator|->
name|next_pattern_reserv
control|)
block|{
for|for
control|(
name|unit_num
operator|=
literal|0
init|;
name|unit_num
operator|<
name|els_in_cycle_reserv
condition|;
name|unit_num
operator|++
control|)
if|if
condition|(
operator|(
name|checked_set
index|[
name|unit_num
index|]
operator|&
name|pat_reserv
operator|->
name|reserv
index|[
name|unit_num
index|]
operator|)
operator|!=
name|pat_reserv
operator|->
name|reserv
index|[
name|unit_num
index|]
condition|)
break|break;
name|presence_p
operator|=
name|presence_p
operator|||
name|unit_num
operator|>=
name|els_in_cycle_reserv
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|presence_p
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* The function checks that CHECKED_SET satisfies all absence pattern    sets for units in ORIGIONAL_SET.  The function returns TRUE if it    is ok.  */
end_comment

begin_function
specifier|static
name|int
name|check_absence_pattern_sets
parameter_list|(
name|reserv_sets_t
name|checked_set
parameter_list|,
name|reserv_sets_t
name|origional_set
parameter_list|,
name|int
name|final_p
parameter_list|)
block|{
name|int
name|char_num
decl_stmt|;
name|int
name|chars_num
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|start_unit_num
decl_stmt|;
name|int
name|unit_num
decl_stmt|;
name|pattern_reserv_t
name|pat_reserv
decl_stmt|;
name|chars_num
operator|=
name|els_in_cycle_reserv
operator|*
sizeof|sizeof
argument_list|(
name|set_el_t
argument_list|)
expr_stmt|;
for|for
control|(
name|char_num
operator|=
literal|0
init|;
name|char_num
operator|<
name|chars_num
condition|;
name|char_num
operator|++
control|)
if|if
condition|(
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|origional_set
operator|)
index|[
name|char_num
index|]
condition|)
for|for
control|(
name|i
operator|=
name|CHAR_BIT
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
operator|(
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|origional_set
operator|)
index|[
name|char_num
index|]
operator|>>
name|i
operator|)
operator|&
literal|1
condition|)
block|{
name|start_unit_num
operator|=
name|char_num
operator|*
name|CHAR_BIT
operator|+
name|i
expr_stmt|;
if|if
condition|(
name|start_unit_num
operator|>=
name|description
operator|->
name|units_num
condition|)
break|break;
for|for
control|(
name|pat_reserv
operator|=
operator|(
name|final_p
condition|?
name|unit_final_absence_set_table
index|[
name|start_unit_num
index|]
else|:
name|unit_absence_set_table
index|[
name|start_unit_num
index|]
operator|)
init|;
name|pat_reserv
operator|!=
name|NULL
condition|;
name|pat_reserv
operator|=
name|pat_reserv
operator|->
name|next_pattern_reserv
control|)
block|{
for|for
control|(
name|unit_num
operator|=
literal|0
init|;
name|unit_num
operator|<
name|els_in_cycle_reserv
condition|;
name|unit_num
operator|++
control|)
if|if
condition|(
operator|(
name|checked_set
index|[
name|unit_num
index|]
operator|&
name|pat_reserv
operator|->
name|reserv
index|[
name|unit_num
index|]
operator|)
operator|!=
name|pat_reserv
operator|->
name|reserv
index|[
name|unit_num
index|]
operator|&&
name|pat_reserv
operator|->
name|reserv
index|[
name|unit_num
index|]
condition|)
break|break;
if|if
condition|(
name|unit_num
operator|>=
name|els_in_cycle_reserv
condition|)
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This page contains code for transformation of original reservations    described in .md file.  The main goal of transformations is    simplifying reservation and lifting up all `|' on the top of IR    reservation representation.  */
end_comment

begin_comment
comment|/* The following function makes copy of IR representation of    reservation.  The function also substitutes all reservations    defined by define_reservation by corresponding value during making    the copy.  */
end_comment

begin_function
specifier|static
name|regexp_t
name|copy_insn_regexp
parameter_list|(
name|regexp_t
name|regexp
parameter_list|)
block|{
name|regexp_t
name|result
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|regexp
operator|->
name|mode
condition|)
block|{
case|case
name|rm_reserv
case|:
name|result
operator|=
name|copy_insn_regexp
argument_list|(
name|REGEXP_RESERV
argument_list|(
name|regexp
argument_list|)
operator|->
name|reserv_decl
operator|->
name|regexp
argument_list|)
expr_stmt|;
break|break;
case|case
name|rm_unit
case|:
name|result
operator|=
name|copy_node
argument_list|(
name|regexp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|regexp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|rm_repeat
case|:
name|result
operator|=
name|copy_node
argument_list|(
name|regexp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|regexp
argument_list|)
argument_list|)
expr_stmt|;
name|REGEXP_REPEAT
argument_list|(
name|result
argument_list|)
operator|->
name|regexp
operator|=
name|copy_insn_regexp
argument_list|(
name|REGEXP_REPEAT
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexp
argument_list|)
expr_stmt|;
break|break;
case|case
name|rm_sequence
case|:
name|result
operator|=
name|copy_node
argument_list|(
name|regexp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|regexp
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|regexp_t
argument_list|)
operator|*
operator|(
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|;
name|i
operator|++
control|)
name|REGEXP_SEQUENCE
argument_list|(
name|result
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
operator|=
name|copy_insn_regexp
argument_list|(
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|rm_allof
case|:
name|result
operator|=
name|copy_node
argument_list|(
name|regexp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|regexp
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|regexp_t
argument_list|)
operator|*
operator|(
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|;
name|i
operator|++
control|)
name|REGEXP_ALLOF
argument_list|(
name|result
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
operator|=
name|copy_insn_regexp
argument_list|(
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|rm_oneof
case|:
name|result
operator|=
name|copy_node
argument_list|(
name|regexp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|regexp
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|regexp_t
argument_list|)
operator|*
operator|(
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|;
name|i
operator|++
control|)
name|REGEXP_ONEOF
argument_list|(
name|result
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
operator|=
name|copy_insn_regexp
argument_list|(
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|rm_nothing
case|:
name|result
operator|=
name|copy_node
argument_list|(
name|regexp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|regexp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* The following variable is set up 1 if a transformation has been    applied.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|regexp_transformed_p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The function makes transformation    A*N -> A, A, ...  */
end_comment

begin_function
specifier|static
name|regexp_t
name|transform_1
parameter_list|(
name|regexp_t
name|regexp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|repeat_num
decl_stmt|;
name|regexp_t
name|operand
decl_stmt|;
name|pos_t
name|pos
decl_stmt|;
if|if
condition|(
name|regexp
operator|->
name|mode
operator|==
name|rm_repeat
condition|)
block|{
name|repeat_num
operator|=
name|REGEXP_REPEAT
argument_list|(
name|regexp
argument_list|)
operator|->
name|repeat_num
expr_stmt|;
name|gcc_assert
argument_list|(
name|repeat_num
operator|>
literal|1
argument_list|)
expr_stmt|;
name|operand
operator|=
name|REGEXP_REPEAT
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexp
expr_stmt|;
name|pos
operator|=
name|regexp
operator|->
name|mode
expr_stmt|;
name|regexp
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|regexp
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|regexp_t
argument_list|)
operator|*
operator|(
name|repeat_num
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|regexp
operator|->
name|mode
operator|=
name|rm_sequence
expr_stmt|;
name|regexp
operator|->
name|pos
operator|=
name|pos
expr_stmt|;
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
operator|=
name|repeat_num
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|repeat_num
condition|;
name|i
operator|++
control|)
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
operator|=
name|copy_insn_regexp
argument_list|(
name|operand
argument_list|)
expr_stmt|;
name|regexp_transformed_p
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|regexp
return|;
block|}
end_function

begin_comment
comment|/* The function makes transformations    ...,(A,B,...),C,... -> ...,A,B,...,C,...    ...+(A+B+...)+C+... -> ...+A+B+...+C+...    ...|(A|B|...)|C|... -> ...|A|B|...|C|...  */
end_comment

begin_function
specifier|static
name|regexp_t
name|transform_2
parameter_list|(
name|regexp_t
name|regexp
parameter_list|)
block|{
if|if
condition|(
name|regexp
operator|->
name|mode
operator|==
name|rm_sequence
condition|)
block|{
name|regexp_t
name|sequence
init|=
name|NULL
decl_stmt|;
name|regexp_t
name|result
decl_stmt|;
name|int
name|sequence_index
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
operator|->
name|mode
operator|==
name|rm_sequence
condition|)
block|{
name|sequence_index
operator|=
name|i
expr_stmt|;
name|sequence
operator|=
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|<
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|)
block|{
name|gcc_assert
argument_list|(
name|REGEXP_SEQUENCE
argument_list|(
name|sequence
argument_list|)
operator|->
name|regexps_num
operator|>
literal|1
operator|&&
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
operator|>
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|regexp
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|regexp_t
argument_list|)
operator|*
operator|(
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
operator|+
name|REGEXP_SEQUENCE
argument_list|(
name|sequence
argument_list|)
operator|->
name|regexps_num
operator|-
literal|2
operator|)
argument_list|)
expr_stmt|;
name|result
operator|->
name|mode
operator|=
name|rm_sequence
expr_stmt|;
name|result
operator|->
name|pos
operator|=
name|regexp
operator|->
name|pos
expr_stmt|;
name|REGEXP_SEQUENCE
argument_list|(
name|result
argument_list|)
operator|->
name|regexps_num
operator|=
operator|(
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
operator|+
name|REGEXP_SEQUENCE
argument_list|(
name|sequence
argument_list|)
operator|->
name|regexps_num
operator|-
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|i
operator|<
name|sequence_index
condition|)
name|REGEXP_SEQUENCE
argument_list|(
name|result
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
operator|=
name|copy_insn_regexp
argument_list|(
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|>
name|sequence_index
condition|)
name|REGEXP_SEQUENCE
argument_list|(
name|result
argument_list|)
operator|->
name|regexps
index|[
name|i
operator|+
name|REGEXP_SEQUENCE
argument_list|(
name|sequence
argument_list|)
operator|->
name|regexps_num
operator|-
literal|1
index|]
operator|=
name|copy_insn_regexp
argument_list|(
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|REGEXP_SEQUENCE
argument_list|(
name|sequence
argument_list|)
operator|->
name|regexps_num
condition|;
name|j
operator|++
control|)
name|REGEXP_SEQUENCE
argument_list|(
name|result
argument_list|)
operator|->
name|regexps
index|[
name|i
operator|+
name|j
index|]
operator|=
name|copy_insn_regexp
argument_list|(
name|REGEXP_SEQUENCE
argument_list|(
name|sequence
argument_list|)
operator|->
name|regexps
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|regexp_transformed_p
operator|=
literal|1
expr_stmt|;
name|regexp
operator|=
name|result
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|regexp
operator|->
name|mode
operator|==
name|rm_allof
condition|)
block|{
name|regexp_t
name|allof
init|=
name|NULL
decl_stmt|;
name|regexp_t
name|result
decl_stmt|;
name|int
name|allof_index
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
operator|->
name|mode
operator|==
name|rm_allof
condition|)
block|{
name|allof_index
operator|=
name|i
expr_stmt|;
name|allof
operator|=
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|<
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|)
block|{
name|gcc_assert
argument_list|(
name|REGEXP_ALLOF
argument_list|(
name|allof
argument_list|)
operator|->
name|regexps_num
operator|>
literal|1
operator|&&
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
operator|>
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|regexp
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|regexp_t
argument_list|)
operator|*
operator|(
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
operator|+
name|REGEXP_ALLOF
argument_list|(
name|allof
argument_list|)
operator|->
name|regexps_num
operator|-
literal|2
operator|)
argument_list|)
expr_stmt|;
name|result
operator|->
name|mode
operator|=
name|rm_allof
expr_stmt|;
name|result
operator|->
name|pos
operator|=
name|regexp
operator|->
name|pos
expr_stmt|;
name|REGEXP_ALLOF
argument_list|(
name|result
argument_list|)
operator|->
name|regexps_num
operator|=
operator|(
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
operator|+
name|REGEXP_ALLOF
argument_list|(
name|allof
argument_list|)
operator|->
name|regexps_num
operator|-
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|i
operator|<
name|allof_index
condition|)
name|REGEXP_ALLOF
argument_list|(
name|result
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
operator|=
name|copy_insn_regexp
argument_list|(
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|>
name|allof_index
condition|)
name|REGEXP_ALLOF
argument_list|(
name|result
argument_list|)
operator|->
name|regexps
index|[
name|i
operator|+
name|REGEXP_ALLOF
argument_list|(
name|allof
argument_list|)
operator|->
name|regexps_num
operator|-
literal|1
index|]
operator|=
name|copy_insn_regexp
argument_list|(
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|REGEXP_ALLOF
argument_list|(
name|allof
argument_list|)
operator|->
name|regexps_num
condition|;
name|j
operator|++
control|)
name|REGEXP_ALLOF
argument_list|(
name|result
argument_list|)
operator|->
name|regexps
index|[
name|i
operator|+
name|j
index|]
operator|=
name|copy_insn_regexp
argument_list|(
name|REGEXP_ALLOF
argument_list|(
name|allof
argument_list|)
operator|->
name|regexps
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|regexp_transformed_p
operator|=
literal|1
expr_stmt|;
name|regexp
operator|=
name|result
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|regexp
operator|->
name|mode
operator|==
name|rm_oneof
condition|)
block|{
name|regexp_t
name|oneof
init|=
name|NULL
decl_stmt|;
name|regexp_t
name|result
decl_stmt|;
name|int
name|oneof_index
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
operator|->
name|mode
operator|==
name|rm_oneof
condition|)
block|{
name|oneof_index
operator|=
name|i
expr_stmt|;
name|oneof
operator|=
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|<
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|)
block|{
name|gcc_assert
argument_list|(
name|REGEXP_ONEOF
argument_list|(
name|oneof
argument_list|)
operator|->
name|regexps_num
operator|>
literal|1
operator|&&
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
operator|>
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|regexp
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|regexp_t
argument_list|)
operator|*
operator|(
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
operator|+
name|REGEXP_ONEOF
argument_list|(
name|oneof
argument_list|)
operator|->
name|regexps_num
operator|-
literal|2
operator|)
argument_list|)
expr_stmt|;
name|result
operator|->
name|mode
operator|=
name|rm_oneof
expr_stmt|;
name|result
operator|->
name|pos
operator|=
name|regexp
operator|->
name|pos
expr_stmt|;
name|REGEXP_ONEOF
argument_list|(
name|result
argument_list|)
operator|->
name|regexps_num
operator|=
operator|(
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
operator|+
name|REGEXP_ONEOF
argument_list|(
name|oneof
argument_list|)
operator|->
name|regexps_num
operator|-
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|i
operator|<
name|oneof_index
condition|)
name|REGEXP_ONEOF
argument_list|(
name|result
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
operator|=
name|copy_insn_regexp
argument_list|(
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|>
name|oneof_index
condition|)
name|REGEXP_ONEOF
argument_list|(
name|result
argument_list|)
operator|->
name|regexps
index|[
name|i
operator|+
name|REGEXP_ONEOF
argument_list|(
name|oneof
argument_list|)
operator|->
name|regexps_num
operator|-
literal|1
index|]
operator|=
name|copy_insn_regexp
argument_list|(
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|REGEXP_ONEOF
argument_list|(
name|oneof
argument_list|)
operator|->
name|regexps_num
condition|;
name|j
operator|++
control|)
name|REGEXP_ONEOF
argument_list|(
name|result
argument_list|)
operator|->
name|regexps
index|[
name|i
operator|+
name|j
index|]
operator|=
name|copy_insn_regexp
argument_list|(
name|REGEXP_ONEOF
argument_list|(
name|oneof
argument_list|)
operator|->
name|regexps
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|regexp_transformed_p
operator|=
literal|1
expr_stmt|;
name|regexp
operator|=
name|result
expr_stmt|;
block|}
block|}
return|return
name|regexp
return|;
block|}
end_function

begin_comment
comment|/* The function makes transformations    ...,A|B|...,C,... -> (...,A,C,...)|(...,B,C,...)|...    ...+(A|B|...)+C+... -> (...+A+C+...)|(...+B+C+...)|...    ...+(A,B,...)+C+... -> (...+A+C+...),B,...    ...+(A,B,...)+(C,D,...) -> (A+C),(B+D),...  */
end_comment

begin_function
specifier|static
name|regexp_t
name|transform_3
parameter_list|(
name|regexp_t
name|regexp
parameter_list|)
block|{
if|if
condition|(
name|regexp
operator|->
name|mode
operator|==
name|rm_sequence
condition|)
block|{
name|regexp_t
name|oneof
init|=
name|NULL
decl_stmt|;
name|int
name|oneof_index
init|=
literal|0
decl_stmt|;
name|regexp_t
name|result
decl_stmt|;
name|regexp_t
name|sequence
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
operator|->
name|mode
operator|==
name|rm_oneof
condition|)
block|{
name|oneof_index
operator|=
name|i
expr_stmt|;
name|oneof
operator|=
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|<
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|)
block|{
name|gcc_assert
argument_list|(
name|REGEXP_ONEOF
argument_list|(
name|oneof
argument_list|)
operator|->
name|regexps_num
operator|>
literal|1
operator|&&
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
operator|>
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|regexp
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|regexp_t
argument_list|)
operator|*
operator|(
name|REGEXP_ONEOF
argument_list|(
name|oneof
argument_list|)
operator|->
name|regexps_num
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|result
operator|->
name|mode
operator|=
name|rm_oneof
expr_stmt|;
name|result
operator|->
name|pos
operator|=
name|regexp
operator|->
name|pos
expr_stmt|;
name|REGEXP_ONEOF
argument_list|(
name|result
argument_list|)
operator|->
name|regexps_num
operator|=
name|REGEXP_ONEOF
argument_list|(
name|oneof
argument_list|)
operator|->
name|regexps_num
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGEXP_ONEOF
argument_list|(
name|result
argument_list|)
operator|->
name|regexps_num
condition|;
name|i
operator|++
control|)
block|{
name|sequence
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|regexp
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|regexp_t
argument_list|)
operator|*
operator|(
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|sequence
operator|->
name|mode
operator|=
name|rm_sequence
expr_stmt|;
name|sequence
operator|->
name|pos
operator|=
name|regexp
operator|->
name|pos
expr_stmt|;
name|REGEXP_SEQUENCE
argument_list|(
name|sequence
argument_list|)
operator|->
name|regexps_num
operator|=
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
expr_stmt|;
name|REGEXP_ONEOF
argument_list|(
name|result
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
operator|=
name|sequence
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|REGEXP_SEQUENCE
argument_list|(
name|sequence
argument_list|)
operator|->
name|regexps_num
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|j
operator|!=
name|oneof_index
condition|)
name|REGEXP_SEQUENCE
argument_list|(
name|sequence
argument_list|)
operator|->
name|regexps
index|[
name|j
index|]
operator|=
name|copy_insn_regexp
argument_list|(
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|j
index|]
argument_list|)
expr_stmt|;
else|else
name|REGEXP_SEQUENCE
argument_list|(
name|sequence
argument_list|)
operator|->
name|regexps
index|[
name|j
index|]
operator|=
name|copy_insn_regexp
argument_list|(
name|REGEXP_ONEOF
argument_list|(
name|oneof
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|regexp_transformed_p
operator|=
literal|1
expr_stmt|;
name|regexp
operator|=
name|result
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|regexp
operator|->
name|mode
operator|==
name|rm_allof
condition|)
block|{
name|regexp_t
name|oneof
init|=
name|NULL
decl_stmt|;
name|regexp_t
name|seq
decl_stmt|;
name|int
name|oneof_index
init|=
literal|0
decl_stmt|;
name|int
name|max_seq_length
decl_stmt|,
name|allof_length
decl_stmt|;
name|regexp_t
name|result
decl_stmt|;
name|regexp_t
name|allof
init|=
name|NULL
decl_stmt|;
name|regexp_t
name|allof_op
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
operator|->
name|mode
operator|==
name|rm_oneof
condition|)
block|{
name|oneof_index
operator|=
name|i
expr_stmt|;
name|oneof
operator|=
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|<
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|)
block|{
name|gcc_assert
argument_list|(
name|REGEXP_ONEOF
argument_list|(
name|oneof
argument_list|)
operator|->
name|regexps_num
operator|>
literal|1
operator|&&
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
operator|>
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|regexp
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|regexp_t
argument_list|)
operator|*
operator|(
name|REGEXP_ONEOF
argument_list|(
name|oneof
argument_list|)
operator|->
name|regexps_num
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|result
operator|->
name|mode
operator|=
name|rm_oneof
expr_stmt|;
name|result
operator|->
name|pos
operator|=
name|regexp
operator|->
name|pos
expr_stmt|;
name|REGEXP_ONEOF
argument_list|(
name|result
argument_list|)
operator|->
name|regexps_num
operator|=
name|REGEXP_ONEOF
argument_list|(
name|oneof
argument_list|)
operator|->
name|regexps_num
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGEXP_ONEOF
argument_list|(
name|result
argument_list|)
operator|->
name|regexps_num
condition|;
name|i
operator|++
control|)
block|{
name|allof
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|regexp
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|regexp_t
argument_list|)
operator|*
operator|(
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|allof
operator|->
name|mode
operator|=
name|rm_allof
expr_stmt|;
name|allof
operator|->
name|pos
operator|=
name|regexp
operator|->
name|pos
expr_stmt|;
name|REGEXP_ALLOF
argument_list|(
name|allof
argument_list|)
operator|->
name|regexps_num
operator|=
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
expr_stmt|;
name|REGEXP_ONEOF
argument_list|(
name|result
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
operator|=
name|allof
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|REGEXP_ALLOF
argument_list|(
name|allof
argument_list|)
operator|->
name|regexps_num
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|j
operator|!=
name|oneof_index
condition|)
name|REGEXP_ALLOF
argument_list|(
name|allof
argument_list|)
operator|->
name|regexps
index|[
name|j
index|]
operator|=
name|copy_insn_regexp
argument_list|(
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|j
index|]
argument_list|)
expr_stmt|;
else|else
name|REGEXP_ALLOF
argument_list|(
name|allof
argument_list|)
operator|->
name|regexps
index|[
name|j
index|]
operator|=
name|copy_insn_regexp
argument_list|(
name|REGEXP_ONEOF
argument_list|(
name|oneof
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|regexp_transformed_p
operator|=
literal|1
expr_stmt|;
name|regexp
operator|=
name|result
expr_stmt|;
block|}
name|max_seq_length
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|regexp
operator|->
name|mode
operator|==
name|rm_allof
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
operator|->
name|mode
condition|)
block|{
case|case
name|rm_sequence
case|:
name|seq
operator|=
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|max_seq_length
operator|<
name|REGEXP_SEQUENCE
argument_list|(
name|seq
argument_list|)
operator|->
name|regexps_num
condition|)
name|max_seq_length
operator|=
name|REGEXP_SEQUENCE
argument_list|(
name|seq
argument_list|)
operator|->
name|regexps_num
expr_stmt|;
break|break;
case|case
name|rm_unit
case|:
case|case
name|rm_nothing
case|:
break|break;
default|default:
name|max_seq_length
operator|=
literal|0
expr_stmt|;
goto|goto
name|break_for
goto|;
block|}
block|}
name|break_for
label|:
if|if
condition|(
name|max_seq_length
operator|!=
literal|0
condition|)
block|{
name|gcc_assert
argument_list|(
name|max_seq_length
operator|!=
literal|1
operator|&&
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
operator|>
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|regexp
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|regexp_t
argument_list|)
operator|*
operator|(
name|max_seq_length
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|result
operator|->
name|mode
operator|=
name|rm_sequence
expr_stmt|;
name|result
operator|->
name|pos
operator|=
name|regexp
operator|->
name|pos
expr_stmt|;
name|REGEXP_SEQUENCE
argument_list|(
name|result
argument_list|)
operator|->
name|regexps_num
operator|=
name|max_seq_length
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_seq_length
condition|;
name|i
operator|++
control|)
block|{
name|allof_length
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|;
name|j
operator|++
control|)
switch|switch
condition|(
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|j
index|]
operator|->
name|mode
condition|)
block|{
case|case
name|rm_sequence
case|:
if|if
condition|(
name|i
operator|<
operator|(
name|REGEXP_SEQUENCE
argument_list|(
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|j
index|]
argument_list|)
operator|->
name|regexps_num
operator|)
condition|)
block|{
name|allof_op
operator|=
operator|(
name|REGEXP_SEQUENCE
argument_list|(
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|j
index|]
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
operator|)
expr_stmt|;
name|allof_length
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|rm_unit
case|:
case|case
name|rm_nothing
case|:
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|allof_op
operator|=
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|j
index|]
expr_stmt|;
name|allof_length
operator|++
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|allof_length
operator|==
literal|1
condition|)
name|REGEXP_SEQUENCE
argument_list|(
name|result
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
operator|=
name|allof_op
expr_stmt|;
else|else
block|{
name|allof
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|regexp
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|regexp_t
argument_list|)
operator|*
operator|(
name|allof_length
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|allof
operator|->
name|mode
operator|=
name|rm_allof
expr_stmt|;
name|allof
operator|->
name|pos
operator|=
name|regexp
operator|->
name|pos
expr_stmt|;
name|REGEXP_ALLOF
argument_list|(
name|allof
argument_list|)
operator|->
name|regexps_num
operator|=
name|allof_length
expr_stmt|;
name|REGEXP_SEQUENCE
argument_list|(
name|result
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
operator|=
name|allof
expr_stmt|;
name|allof_length
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|j
index|]
operator|->
name|mode
operator|==
name|rm_sequence
operator|&&
operator|(
name|i
operator|<
operator|(
name|REGEXP_SEQUENCE
argument_list|(
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|j
index|]
argument_list|)
operator|->
name|regexps_num
operator|)
operator|)
condition|)
block|{
name|allof_op
operator|=
operator|(
name|REGEXP_SEQUENCE
argument_list|(
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|j
index|]
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
operator|)
expr_stmt|;
name|REGEXP_ALLOF
argument_list|(
name|allof
argument_list|)
operator|->
name|regexps
index|[
name|allof_length
index|]
operator|=
name|allof_op
expr_stmt|;
name|allof_length
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
operator|(
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|j
index|]
operator|->
name|mode
operator|==
name|rm_unit
operator|||
operator|(
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|j
index|]
operator|->
name|mode
operator|==
name|rm_nothing
operator|)
operator|)
condition|)
block|{
name|allof_op
operator|=
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|j
index|]
expr_stmt|;
name|REGEXP_ALLOF
argument_list|(
name|allof
argument_list|)
operator|->
name|regexps
index|[
name|allof_length
index|]
operator|=
name|allof_op
expr_stmt|;
name|allof_length
operator|++
expr_stmt|;
block|}
block|}
block|}
name|regexp_transformed_p
operator|=
literal|1
expr_stmt|;
name|regexp
operator|=
name|result
expr_stmt|;
block|}
block|}
return|return
name|regexp
return|;
block|}
end_function

begin_comment
comment|/* The function traverses IR of reservation and applies transformations    implemented by FUNC.  */
end_comment

begin_function
specifier|static
name|regexp_t
name|regexp_transform_func
parameter_list|(
name|regexp_t
name|regexp
parameter_list|,
name|regexp_t
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|regexp_t
name|regexp
parameter_list|)
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|regexp
operator|->
name|mode
condition|)
block|{
case|case
name|rm_sequence
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|;
name|i
operator|++
control|)
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
operator|=
name|regexp_transform_func
argument_list|(
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
argument_list|,
name|func
argument_list|)
expr_stmt|;
break|break;
case|case
name|rm_allof
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|;
name|i
operator|++
control|)
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
operator|=
name|regexp_transform_func
argument_list|(
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
argument_list|,
name|func
argument_list|)
expr_stmt|;
break|break;
case|case
name|rm_oneof
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|;
name|i
operator|++
control|)
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
operator|=
name|regexp_transform_func
argument_list|(
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
argument_list|,
name|func
argument_list|)
expr_stmt|;
break|break;
case|case
name|rm_repeat
case|:
name|REGEXP_REPEAT
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexp
operator|=
name|regexp_transform_func
argument_list|(
name|REGEXP_REPEAT
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexp
argument_list|,
name|func
argument_list|)
expr_stmt|;
break|break;
case|case
name|rm_nothing
case|:
case|case
name|rm_unit
case|:
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
return|return
call|(
modifier|*
name|func
call|)
argument_list|(
name|regexp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The function applies all transformations for IR representation of    reservation REGEXP.  */
end_comment

begin_function
specifier|static
name|regexp_t
name|transform_regexp
parameter_list|(
name|regexp_t
name|regexp
parameter_list|)
block|{
name|regexp
operator|=
name|regexp_transform_func
argument_list|(
name|regexp
argument_list|,
name|transform_1
argument_list|)
expr_stmt|;
do|do
block|{
name|regexp_transformed_p
operator|=
literal|0
expr_stmt|;
name|regexp
operator|=
name|regexp_transform_func
argument_list|(
name|regexp
argument_list|,
name|transform_2
argument_list|)
expr_stmt|;
name|regexp
operator|=
name|regexp_transform_func
argument_list|(
name|regexp
argument_list|,
name|transform_3
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|regexp_transformed_p
condition|)
do|;
return|return
name|regexp
return|;
block|}
end_function

begin_comment
comment|/* The function applies all transformations for reservations of all    insn declarations.  */
end_comment

begin_function
specifier|static
name|void
name|transform_insn_regexps
parameter_list|(
name|void
parameter_list|)
block|{
name|decl_t
name|decl
decl_stmt|;
name|int
name|i
decl_stmt|;
name|transform_time
operator|=
name|create_ticker
argument_list|()
expr_stmt|;
name|add_advance_cycle_insn_decl
argument_list|()
expr_stmt|;
if|if
condition|(
name|progress_flag
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Reservation transformation..."
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_insn_reserv
operator|&&
name|decl
operator|!=
name|advance_cycle_insn_decl
condition|)
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|transformed_regexp
operator|=
name|transform_regexp
argument_list|(
name|copy_insn_regexp
argument_list|(
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|regexp
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|progress_flag
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"done\n"
argument_list|)
expr_stmt|;
name|ticker_off
argument_list|(
operator|&
name|transform_time
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The following variable value is TRUE if the first annotated message    about units to automata distribution has been output.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|annotation_message_reported_p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following structure describes usage of a unit in a reservation.  */
end_comment

begin_struct
struct|struct
name|unit_usage
block|{
name|unit_decl_t
name|unit_decl
decl_stmt|;
comment|/* The following forms a list of units used on the same cycle in the      same alternative.  */
name|struct
name|unit_usage
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|unit_usage
modifier|*
name|unit_usage_t
typedef|;
end_typedef

begin_expr_stmt
name|DEF_VEC_P
argument_list|(
name|unit_usage_t
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEF_VEC_ALLOC_P
argument_list|(
name|unit_usage_t
argument_list|,
name|heap
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Obstack for unit_usage structures.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|unit_usages
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VLA for representation of array of pointers to unit usage    structures.  There is an element for each combination of    (alternative number, cycle).  Unit usages on given cycle in    alternative with given number are referred through element with    index equals to the cycle * number of all alternatives in the regexp    + the alternative number.  */
end_comment

begin_expr_stmt
specifier|static
name|VEC
argument_list|(
name|unit_usage_t
argument_list|,
name|heap
argument_list|)
operator|*
name|cycle_alt_unit_usages
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* The following function creates the structure unit_usage for UNIT on    CYCLE in REGEXP alternative with ALT_NUM.  The structure is made    accessed through cycle_alt_unit_usages.  */
end_comment

begin_function
specifier|static
name|void
name|store_alt_unit_usage
parameter_list|(
name|regexp_t
name|regexp
parameter_list|,
name|regexp_t
name|unit
parameter_list|,
name|int
name|cycle
parameter_list|,
name|int
name|alt_num
parameter_list|)
block|{
name|size_t
name|length
decl_stmt|;
name|unit_decl_t
name|unit_decl
decl_stmt|;
name|unit_usage_t
name|unit_usage_ptr
decl_stmt|;
name|int
name|index
decl_stmt|;
name|gcc_assert
argument_list|(
name|regexp
operator|&&
name|regexp
operator|->
name|mode
operator|==
name|rm_oneof
operator|&&
name|alt_num
operator|<
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
argument_list|)
expr_stmt|;
name|unit_decl
operator|=
name|REGEXP_UNIT
argument_list|(
name|unit
argument_list|)
operator|->
name|unit_decl
expr_stmt|;
name|length
operator|=
operator|(
name|cycle
operator|+
literal|1
operator|)
operator|*
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
expr_stmt|;
while|while
condition|(
name|VEC_length
argument_list|(
name|unit_usage_t
argument_list|,
name|cycle_alt_unit_usages
argument_list|)
operator|<
name|length
condition|)
name|VEC_safe_push
argument_list|(
name|unit_usage_t
argument_list|,
name|heap
argument_list|,
name|cycle_alt_unit_usages
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|obstack_blank
argument_list|(
operator|&
name|unit_usages
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|unit_usage
argument_list|)
argument_list|)
expr_stmt|;
name|unit_usage_ptr
operator|=
operator|(
expr|struct
name|unit_usage
operator|*
operator|)
name|obstack_base
argument_list|(
operator|&
name|unit_usages
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|obstack_finish
argument_list|(
operator|&
name|unit_usages
argument_list|)
expr_stmt|;
name|unit_usage_ptr
operator|->
name|unit_decl
operator|=
name|unit_decl
expr_stmt|;
name|index
operator|=
name|cycle
operator|*
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
operator|+
name|alt_num
expr_stmt|;
name|unit_usage_ptr
operator|->
name|next
operator|=
name|VEC_index
argument_list|(
name|unit_usage_t
argument_list|,
name|cycle_alt_unit_usages
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|VEC_replace
argument_list|(
name|unit_usage_t
argument_list|,
name|cycle_alt_unit_usages
argument_list|,
name|index
argument_list|,
name|unit_usage_ptr
argument_list|)
expr_stmt|;
name|unit_decl
operator|->
name|last_distribution_check_cycle
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* undefined */
block|}
end_function

begin_comment
comment|/* The function processes given REGEXP to find units with the wrong    distribution.  */
end_comment

begin_function
specifier|static
name|void
name|check_regexp_units_distribution
parameter_list|(
specifier|const
name|char
modifier|*
name|insn_reserv_name
parameter_list|,
name|regexp_t
name|regexp
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|cycle
decl_stmt|;
name|regexp_t
name|seq
decl_stmt|,
name|allof
decl_stmt|,
name|unit
decl_stmt|;
name|struct
name|unit_usage
modifier|*
name|unit_usage_ptr
decl_stmt|,
modifier|*
name|other_unit_usage_ptr
decl_stmt|;
if|if
condition|(
name|regexp
operator|==
name|NULL
operator|||
name|regexp
operator|->
name|mode
operator|!=
name|rm_oneof
condition|)
return|return;
comment|/* Store all unit usages in the regexp:  */
name|obstack_init
argument_list|(
operator|&
name|unit_usages
argument_list|)
expr_stmt|;
name|cycle_alt_unit_usages
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|seq
operator|=
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
expr_stmt|;
switch|switch
condition|(
name|seq
operator|->
name|mode
condition|)
block|{
case|case
name|rm_sequence
case|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|REGEXP_SEQUENCE
argument_list|(
name|seq
argument_list|)
operator|->
name|regexps_num
condition|;
name|j
operator|++
control|)
block|{
name|allof
operator|=
name|REGEXP_SEQUENCE
argument_list|(
name|seq
argument_list|)
operator|->
name|regexps
index|[
name|j
index|]
expr_stmt|;
switch|switch
condition|(
name|allof
operator|->
name|mode
condition|)
block|{
case|case
name|rm_allof
case|:
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|REGEXP_ALLOF
argument_list|(
name|allof
argument_list|)
operator|->
name|regexps_num
condition|;
name|k
operator|++
control|)
block|{
name|unit
operator|=
name|REGEXP_ALLOF
argument_list|(
name|allof
argument_list|)
operator|->
name|regexps
index|[
name|k
index|]
expr_stmt|;
if|if
condition|(
name|unit
operator|->
name|mode
operator|==
name|rm_unit
condition|)
name|store_alt_unit_usage
argument_list|(
name|regexp
argument_list|,
name|unit
argument_list|,
name|j
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|gcc_assert
argument_list|(
name|unit
operator|->
name|mode
operator|==
name|rm_nothing
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|rm_unit
case|:
name|store_alt_unit_usage
argument_list|(
name|regexp
argument_list|,
name|allof
argument_list|,
name|j
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|rm_nothing
case|:
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
break|break;
case|case
name|rm_allof
case|:
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|REGEXP_ALLOF
argument_list|(
name|seq
argument_list|)
operator|->
name|regexps_num
condition|;
name|k
operator|++
control|)
block|{
name|unit
operator|=
name|REGEXP_ALLOF
argument_list|(
name|seq
argument_list|)
operator|->
name|regexps
index|[
name|k
index|]
expr_stmt|;
switch|switch
condition|(
name|unit
operator|->
name|mode
condition|)
block|{
case|case
name|rm_unit
case|:
name|store_alt_unit_usage
argument_list|(
name|regexp
argument_list|,
name|unit
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|rm_nothing
case|:
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
break|break;
case|case
name|rm_unit
case|:
name|store_alt_unit_usage
argument_list|(
name|regexp
argument_list|,
name|seq
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|rm_nothing
case|:
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Check distribution:  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|VEC_length
argument_list|(
name|unit_usage_t
argument_list|,
name|cycle_alt_unit_usages
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|cycle
operator|=
name|i
operator|/
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
expr_stmt|;
for|for
control|(
name|unit_usage_ptr
operator|=
name|VEC_index
argument_list|(
name|unit_usage_t
argument_list|,
name|cycle_alt_unit_usages
argument_list|,
name|i
argument_list|)
init|;
name|unit_usage_ptr
operator|!=
name|NULL
condition|;
name|unit_usage_ptr
operator|=
name|unit_usage_ptr
operator|->
name|next
control|)
if|if
condition|(
name|cycle
operator|!=
name|unit_usage_ptr
operator|->
name|unit_decl
operator|->
name|last_distribution_check_cycle
condition|)
block|{
name|unit_usage_ptr
operator|->
name|unit_decl
operator|->
name|last_distribution_check_cycle
operator|=
name|cycle
expr_stmt|;
for|for
control|(
name|k
operator|=
name|cycle
operator|*
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
init|;
name|k
operator|<
operator|(
name|int
operator|)
name|VEC_length
argument_list|(
name|unit_usage_t
argument_list|,
name|cycle_alt_unit_usages
argument_list|)
operator|&&
name|k
operator|==
name|cycle
operator|*
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|;
name|k
operator|++
control|)
block|{
for|for
control|(
name|other_unit_usage_ptr
operator|=
name|VEC_index
argument_list|(
name|unit_usage_t
argument_list|,
name|cycle_alt_unit_usages
argument_list|,
name|k
argument_list|)
init|;
name|other_unit_usage_ptr
operator|!=
name|NULL
condition|;
name|other_unit_usage_ptr
operator|=
name|other_unit_usage_ptr
operator|->
name|next
control|)
if|if
condition|(
name|unit_usage_ptr
operator|->
name|unit_decl
operator|->
name|automaton_decl
operator|==
name|other_unit_usage_ptr
operator|->
name|unit_decl
operator|->
name|automaton_decl
condition|)
break|break;
if|if
condition|(
name|other_unit_usage_ptr
operator|==
name|NULL
operator|&&
operator|(
name|VEC_index
argument_list|(
name|unit_usage_t
argument_list|,
name|cycle_alt_unit_usages
argument_list|,
name|k
argument_list|)
operator|!=
name|NULL
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|k
operator|<
operator|(
name|int
operator|)
name|VEC_length
argument_list|(
name|unit_usage_t
argument_list|,
name|cycle_alt_unit_usages
argument_list|)
operator|&&
name|k
operator|==
name|cycle
operator|*
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|)
block|{
if|if
condition|(
operator|!
name|annotation_message_reported_p
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"The following units do not satisfy units-automata distribution rule"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|" (A unit of given unit automaton should be on each reserv. altern.)"
argument_list|)
expr_stmt|;
name|annotation_message_reported_p
operator|=
name|TRUE
expr_stmt|;
block|}
name|error
argument_list|(
literal|"Unit %s, reserv. %s, cycle %d"
argument_list|,
name|unit_usage_ptr
operator|->
name|unit_decl
operator|->
name|name
argument_list|,
name|insn_reserv_name
argument_list|,
name|cycle
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|VEC_free
argument_list|(
name|unit_usage_t
argument_list|,
name|heap
argument_list|,
name|cycle_alt_unit_usages
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|unit_usages
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function finds units which violates units to automata    distribution rule.  If the units exist, report about them.  */
end_comment

begin_function
specifier|static
name|void
name|check_unit_distributions_to_automata
parameter_list|(
name|void
parameter_list|)
block|{
name|decl_t
name|decl
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|progress_flag
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Check unit distributions to automata..."
argument_list|)
expr_stmt|;
name|annotation_message_reported_p
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_insn_reserv
condition|)
name|check_regexp_units_distribution
argument_list|(
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|name
argument_list|,
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|transformed_regexp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|progress_flag
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"done\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The page contains code for building alt_states (see comments for    IR) describing all possible insns reservations of an automaton.  */
end_comment

begin_comment
comment|/* Current state being formed for which the current alt_state    refers.  */
end_comment

begin_decl_stmt
specifier|static
name|state_t
name|state_being_formed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current alt_state being formed.  */
end_comment

begin_decl_stmt
specifier|static
name|alt_state_t
name|alt_state_being_formed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This recursive function processes `,' and units in reservation    REGEXP for forming alt_states of AUTOMATON.  It is believed that    CURR_CYCLE is start cycle of all reservation REGEXP.  */
end_comment

begin_function
specifier|static
name|int
name|process_seq_for_forming_states
parameter_list|(
name|regexp_t
name|regexp
parameter_list|,
name|automaton_t
name|automaton
parameter_list|,
name|int
name|curr_cycle
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|regexp
operator|==
name|NULL
condition|)
return|return
name|curr_cycle
return|;
switch|switch
condition|(
name|regexp
operator|->
name|mode
condition|)
block|{
case|case
name|rm_unit
case|:
if|if
condition|(
name|REGEXP_UNIT
argument_list|(
name|regexp
argument_list|)
operator|->
name|unit_decl
operator|->
name|corresponding_automaton_num
operator|==
name|automaton
operator|->
name|automaton_order_num
condition|)
name|set_state_reserv
argument_list|(
name|state_being_formed
argument_list|,
name|curr_cycle
argument_list|,
name|REGEXP_UNIT
argument_list|(
name|regexp
argument_list|)
operator|->
name|unit_decl
operator|->
name|unit_num
argument_list|)
expr_stmt|;
return|return
name|curr_cycle
return|;
case|case
name|rm_sequence
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|;
name|i
operator|++
control|)
name|curr_cycle
operator|=
name|process_seq_for_forming_states
argument_list|(
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
argument_list|,
name|automaton
argument_list|,
name|curr_cycle
argument_list|)
operator|+
literal|1
expr_stmt|;
return|return
name|curr_cycle
return|;
case|case
name|rm_allof
case|:
block|{
name|int
name|finish_cycle
init|=
literal|0
decl_stmt|;
name|int
name|cycle
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|;
name|i
operator|++
control|)
block|{
name|cycle
operator|=
name|process_seq_for_forming_states
argument_list|(
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
argument_list|,
name|automaton
argument_list|,
name|curr_cycle
argument_list|)
expr_stmt|;
if|if
condition|(
name|finish_cycle
operator|<
name|cycle
condition|)
name|finish_cycle
operator|=
name|cycle
expr_stmt|;
block|}
return|return
name|finish_cycle
return|;
block|}
case|case
name|rm_nothing
case|:
return|return
name|curr_cycle
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This recursive function finishes forming ALT_STATE of AUTOMATON and    inserts alt_state into the table.  */
end_comment

begin_function
specifier|static
name|void
name|finish_forming_alt_state
parameter_list|(
name|alt_state_t
name|alt_state
parameter_list|,
name|automaton_t
name|automaton
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|state_t
name|state_in_table
decl_stmt|;
name|state_t
name|corresponding_state
decl_stmt|;
name|corresponding_state
operator|=
name|alt_state
operator|->
name|state
expr_stmt|;
name|state_in_table
operator|=
name|insert_state
argument_list|(
name|corresponding_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|state_in_table
operator|!=
name|corresponding_state
condition|)
block|{
name|free_state
argument_list|(
name|corresponding_state
argument_list|)
expr_stmt|;
name|alt_state
operator|->
name|state
operator|=
name|state_in_table
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The following variable value is current automaton insn for whose    reservation the alt states are created.  */
end_comment

begin_decl_stmt
specifier|static
name|ainsn_t
name|curr_ainsn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This recursive function processes `|' in reservation REGEXP for    forming alt_states of AUTOMATON.  List of the alt states should    have the same order as in the description.  */
end_comment

begin_function
specifier|static
name|void
name|process_alts_for_forming_states
parameter_list|(
name|regexp_t
name|regexp
parameter_list|,
name|automaton_t
name|automaton
parameter_list|,
name|int
name|inside_oneof_p
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|regexp
operator|->
name|mode
operator|!=
name|rm_oneof
condition|)
block|{
name|alt_state_being_formed
operator|=
name|get_free_alt_state
argument_list|()
expr_stmt|;
name|state_being_formed
operator|=
name|get_free_state
argument_list|(
literal|1
argument_list|,
name|automaton
argument_list|)
expr_stmt|;
name|alt_state_being_formed
operator|->
name|state
operator|=
name|state_being_formed
expr_stmt|;
comment|/* We inserts in reverse order but we process alternatives also          in reverse order.  So we have the same order of alternative          as in the description.  */
name|alt_state_being_formed
operator|->
name|next_alt_state
operator|=
name|curr_ainsn
operator|->
name|alt_states
expr_stmt|;
name|curr_ainsn
operator|->
name|alt_states
operator|=
name|alt_state_being_formed
expr_stmt|;
operator|(
name|void
operator|)
name|process_seq_for_forming_states
argument_list|(
name|regexp
argument_list|,
name|automaton
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|finish_forming_alt_state
argument_list|(
name|alt_state_being_formed
argument_list|,
name|automaton
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gcc_assert
argument_list|(
operator|!
name|inside_oneof_p
argument_list|)
expr_stmt|;
comment|/* We processes it in reverse order to get list with the same 	 order as in the description.  See also the previous 	 commentary.  */
for|for
control|(
name|i
operator|=
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|process_alts_for_forming_states
argument_list|(
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
argument_list|,
name|automaton
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Create nodes alt_state for all AUTOMATON insns.  */
end_comment

begin_function
specifier|static
name|void
name|create_alt_states
parameter_list|(
name|automaton_t
name|automaton
parameter_list|)
block|{
name|struct
name|insn_reserv_decl
modifier|*
name|reserv_decl
decl_stmt|;
for|for
control|(
name|curr_ainsn
operator|=
name|automaton
operator|->
name|ainsn_list
init|;
name|curr_ainsn
operator|!=
name|NULL
condition|;
name|curr_ainsn
operator|=
name|curr_ainsn
operator|->
name|next_ainsn
control|)
block|{
name|reserv_decl
operator|=
name|curr_ainsn
operator|->
name|insn_reserv_decl
expr_stmt|;
if|if
condition|(
name|reserv_decl
operator|!=
name|DECL_INSN_RESERV
argument_list|(
name|advance_cycle_insn_decl
argument_list|)
condition|)
block|{
name|curr_ainsn
operator|->
name|alt_states
operator|=
name|NULL
expr_stmt|;
name|process_alts_for_forming_states
argument_list|(
name|reserv_decl
operator|->
name|transformed_regexp
argument_list|,
name|automaton
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|curr_ainsn
operator|->
name|sorted_alt_states
operator|=
name|uniq_sort_alt_states
argument_list|(
name|curr_ainsn
operator|->
name|alt_states
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The page contains major code for building DFA(s) for fast pipeline    hazards recognition.  */
end_comment

begin_comment
comment|/* The function forms list of ainsns of AUTOMATON with the same    reservation.  */
end_comment

begin_function
specifier|static
name|void
name|form_ainsn_with_same_reservs
parameter_list|(
name|automaton_t
name|automaton
parameter_list|)
block|{
name|ainsn_t
name|curr_ainsn
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|VEC
argument_list|(
name|ainsn_t
argument_list|,
name|heap
argument_list|)
operator|*
name|last_insns
operator|=
name|VEC_alloc
argument_list|(
name|ainsn_t
argument_list|,
name|heap
argument_list|,
literal|150
argument_list|)
expr_stmt|;
for|for
control|(
name|curr_ainsn
operator|=
name|automaton
operator|->
name|ainsn_list
init|;
name|curr_ainsn
operator|!=
name|NULL
condition|;
name|curr_ainsn
operator|=
name|curr_ainsn
operator|->
name|next_ainsn
control|)
if|if
condition|(
name|curr_ainsn
operator|->
name|insn_reserv_decl
operator|==
name|DECL_INSN_RESERV
argument_list|(
name|advance_cycle_insn_decl
argument_list|)
condition|)
block|{
name|curr_ainsn
operator|->
name|next_same_reservs_insn
operator|=
name|NULL
expr_stmt|;
name|curr_ainsn
operator|->
name|first_insn_with_same_reservs
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VEC_length
argument_list|(
name|ainsn_t
argument_list|,
name|last_insns
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|alt_states_eq
argument_list|(
name|curr_ainsn
operator|->
name|sorted_alt_states
argument_list|,
name|VEC_index
argument_list|(
name|ainsn_t
argument_list|,
name|last_insns
argument_list|,
name|i
argument_list|)
operator|->
name|sorted_alt_states
argument_list|)
condition|)
break|break;
name|curr_ainsn
operator|->
name|next_same_reservs_insn
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|VEC_length
argument_list|(
name|ainsn_t
argument_list|,
name|last_insns
argument_list|)
condition|)
block|{
name|curr_ainsn
operator|->
name|first_insn_with_same_reservs
operator|=
literal|0
expr_stmt|;
name|VEC_index
argument_list|(
name|ainsn_t
argument_list|,
name|last_insns
argument_list|,
name|i
argument_list|)
operator|->
name|next_same_reservs_insn
operator|=
name|curr_ainsn
expr_stmt|;
name|VEC_replace
argument_list|(
name|ainsn_t
argument_list|,
name|last_insns
argument_list|,
name|i
argument_list|,
name|curr_ainsn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|VEC_safe_push
argument_list|(
name|ainsn_t
argument_list|,
name|heap
argument_list|,
name|last_insns
argument_list|,
name|curr_ainsn
argument_list|)
expr_stmt|;
name|curr_ainsn
operator|->
name|first_insn_with_same_reservs
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|VEC_free
argument_list|(
name|ainsn_t
argument_list|,
name|heap
argument_list|,
name|last_insns
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Forming unit reservations which can affect creating the automaton    states achieved from a given state.  It permits to build smaller    automata in many cases.  We would have the same automata after    the minimization without such optimization, but the automaton    right after the building could be huge.  So in other words, usage    of reservs_matter means some minimization during building the    automaton.  */
end_comment

begin_function
specifier|static
name|reserv_sets_t
name|form_reservs_matter
parameter_list|(
name|automaton_t
name|automaton
parameter_list|)
block|{
name|int
name|cycle
decl_stmt|,
name|unit
decl_stmt|;
name|reserv_sets_t
name|reservs_matter
init|=
name|alloc_empty_reserv_sets
argument_list|()
decl_stmt|;
for|for
control|(
name|cycle
operator|=
literal|0
init|;
name|cycle
operator|<
name|max_cycles_num
condition|;
name|cycle
operator|++
control|)
for|for
control|(
name|unit
operator|=
literal|0
init|;
name|unit
operator|<
name|description
operator|->
name|units_num
condition|;
name|unit
operator|++
control|)
if|if
condition|(
name|units_array
index|[
name|unit
index|]
operator|->
name|automaton_decl
operator|==
name|automaton
operator|->
name|corresponding_automaton_decl
operator|&&
operator|(
name|cycle
operator|>=
name|units_array
index|[
name|unit
index|]
operator|->
name|min_occ_cycle_num
comment|/* We can not remove queried unit from reservations.  */
operator|||
name|units_array
index|[
name|unit
index|]
operator|->
name|query_p
comment|/* We can not remove units which are used 		 `exclusion_set', `presence_set', 		 `final_presence_set', `absence_set', and 		 `final_absence_set'.  */
operator|||
name|units_array
index|[
name|unit
index|]
operator|->
name|in_set_p
operator|)
condition|)
name|set_unit_reserv
argument_list|(
name|reservs_matter
argument_list|,
name|cycle
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|reservs_matter
return|;
block|}
end_function

begin_comment
comment|/* The following function creates all states of nondeterministic AUTOMATON.  */
end_comment

begin_function
specifier|static
name|void
name|make_automaton
parameter_list|(
name|automaton_t
name|automaton
parameter_list|)
block|{
name|ainsn_t
name|ainsn
decl_stmt|;
name|struct
name|insn_reserv_decl
modifier|*
name|insn_reserv_decl
decl_stmt|;
name|alt_state_t
name|alt_state
decl_stmt|;
name|state_t
name|state
decl_stmt|;
name|state_t
name|start_state
decl_stmt|;
name|state_t
name|state2
decl_stmt|;
name|ainsn_t
name|advance_cycle_ainsn
decl_stmt|;
name|arc_t
name|added_arc
decl_stmt|;
name|VEC
argument_list|(
name|state_t
argument_list|,
name|heap
argument_list|)
operator|*
name|state_stack
operator|=
name|VEC_alloc
argument_list|(
name|state_t
argument_list|,
name|heap
argument_list|,
literal|150
argument_list|)
expr_stmt|;
name|int
name|states_n
decl_stmt|;
name|reserv_sets_t
name|reservs_matter
init|=
name|form_reservs_matter
argument_list|(
name|automaton
argument_list|)
decl_stmt|;
comment|/* Create the start state (empty state).  */
name|start_state
operator|=
name|insert_state
argument_list|(
name|get_free_state
argument_list|(
literal|1
argument_list|,
name|automaton
argument_list|)
argument_list|)
expr_stmt|;
name|automaton
operator|->
name|start_state
operator|=
name|start_state
expr_stmt|;
name|start_state
operator|->
name|it_was_placed_in_stack_for_NDFA_forming
operator|=
literal|1
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|state_t
argument_list|,
name|heap
argument_list|,
name|state_stack
argument_list|,
name|start_state
argument_list|)
expr_stmt|;
name|states_n
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|VEC_length
argument_list|(
name|state_t
argument_list|,
name|state_stack
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|state
operator|=
name|VEC_pop
argument_list|(
name|state_t
argument_list|,
name|state_stack
argument_list|)
expr_stmt|;
name|advance_cycle_ainsn
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|ainsn
operator|=
name|automaton
operator|->
name|ainsn_list
init|;
name|ainsn
operator|!=
name|NULL
condition|;
name|ainsn
operator|=
name|ainsn
operator|->
name|next_ainsn
control|)
if|if
condition|(
name|ainsn
operator|->
name|first_insn_with_same_reservs
condition|)
block|{
name|insn_reserv_decl
operator|=
name|ainsn
operator|->
name|insn_reserv_decl
expr_stmt|;
if|if
condition|(
name|insn_reserv_decl
operator|!=
name|DECL_INSN_RESERV
argument_list|(
name|advance_cycle_insn_decl
argument_list|)
condition|)
block|{
comment|/* We process alt_states in the same order as they are                    present in the description.  */
name|added_arc
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|alt_state
operator|=
name|ainsn
operator|->
name|alt_states
init|;
name|alt_state
operator|!=
name|NULL
condition|;
name|alt_state
operator|=
name|alt_state
operator|->
name|next_alt_state
control|)
block|{
name|state2
operator|=
name|alt_state
operator|->
name|state
expr_stmt|;
if|if
condition|(
operator|!
name|intersected_state_reservs_p
argument_list|(
name|state
argument_list|,
name|state2
argument_list|)
condition|)
block|{
name|state2
operator|=
name|states_union
argument_list|(
name|state
argument_list|,
name|state2
argument_list|,
name|reservs_matter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|state2
operator|->
name|it_was_placed_in_stack_for_NDFA_forming
condition|)
block|{
name|state2
operator|->
name|it_was_placed_in_stack_for_NDFA_forming
operator|=
literal|1
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|state_t
argument_list|,
name|heap
argument_list|,
name|state_stack
argument_list|,
name|state2
argument_list|)
expr_stmt|;
name|states_n
operator|++
expr_stmt|;
if|if
condition|(
name|progress_flag
operator|&&
name|states_n
operator|%
literal|100
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
block|}
name|added_arc
operator|=
name|add_arc
argument_list|(
name|state
argument_list|,
name|state2
argument_list|,
name|ainsn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ndfa_flag
condition|)
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|ndfa_flag
operator|&&
name|added_arc
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|alt_state
operator|=
name|ainsn
operator|->
name|alt_states
init|;
name|alt_state
operator|!=
name|NULL
condition|;
name|alt_state
operator|=
name|alt_state
operator|->
name|next_alt_state
control|)
name|state2
operator|=
name|alt_state
operator|->
name|state
expr_stmt|;
block|}
block|}
else|else
name|advance_cycle_ainsn
operator|=
name|ainsn
expr_stmt|;
block|}
comment|/* Add transition to advance cycle.  */
name|state2
operator|=
name|state_shift
argument_list|(
name|state
argument_list|,
name|reservs_matter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|state2
operator|->
name|it_was_placed_in_stack_for_NDFA_forming
condition|)
block|{
name|state2
operator|->
name|it_was_placed_in_stack_for_NDFA_forming
operator|=
literal|1
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|state_t
argument_list|,
name|heap
argument_list|,
name|state_stack
argument_list|,
name|state2
argument_list|)
expr_stmt|;
name|states_n
operator|++
expr_stmt|;
if|if
condition|(
name|progress_flag
operator|&&
name|states_n
operator|%
literal|100
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|advance_cycle_ainsn
argument_list|)
expr_stmt|;
name|add_arc
argument_list|(
name|state
argument_list|,
name|state2
argument_list|,
name|advance_cycle_ainsn
argument_list|)
expr_stmt|;
block|}
name|VEC_free
argument_list|(
name|state_t
argument_list|,
name|heap
argument_list|,
name|state_stack
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Foms lists of all arcs of STATE marked by the same ainsn.  */
end_comment

begin_function
specifier|static
name|void
name|form_arcs_marked_by_insn
parameter_list|(
name|state_t
name|state
parameter_list|)
block|{
name|decl_t
name|decl
decl_stmt|;
name|arc_t
name|arc
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_insn_reserv
condition|)
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|arcs_marked_by_insn
operator|=
name|NULL
expr_stmt|;
block|}
for|for
control|(
name|arc
operator|=
name|first_out_arc
argument_list|(
name|state
argument_list|)
init|;
name|arc
operator|!=
name|NULL
condition|;
name|arc
operator|=
name|next_out_arc
argument_list|(
name|arc
argument_list|)
control|)
block|{
name|gcc_assert
argument_list|(
name|arc
operator|->
name|insn
argument_list|)
expr_stmt|;
name|arc
operator|->
name|next_arc_marked_by_insn
operator|=
name|arc
operator|->
name|insn
operator|->
name|insn_reserv_decl
operator|->
name|arcs_marked_by_insn
expr_stmt|;
name|arc
operator|->
name|insn
operator|->
name|insn_reserv_decl
operator|->
name|arcs_marked_by_insn
operator|=
name|arc
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The function creates composed state (see comments for IR) from    ORIGINAL_STATE and list of arcs ARCS_MARKED_BY_INSN marked by the    same insn.  If the composed state is not in STATE_STACK yet, it is    pushed into STATE_STACK.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|create_composed_state
argument_list|(
name|state_t
name|original_state
argument_list|,
name|arc_t
name|arcs_marked_by_insn
argument_list|,
name|VEC
argument_list|(
name|state_t
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
name|state_stack
argument_list|)
block|{
name|state_t
name|state
decl_stmt|;
name|alt_state_t
name|alt_state
decl_stmt|,
name|curr_alt_state
decl_stmt|;
name|alt_state_t
name|new_alt_state
decl_stmt|;
name|arc_t
name|curr_arc
decl_stmt|;
name|arc_t
name|next_arc
decl_stmt|;
name|state_t
name|state_in_table
decl_stmt|;
name|state_t
name|temp_state
decl_stmt|;
name|alt_state_t
name|canonical_alt_states_list
decl_stmt|;
name|int
name|alts_number
decl_stmt|;
name|int
name|new_state_p
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|arcs_marked_by_insn
operator|==
name|NULL
condition|)
return|return
name|new_state_p
return|;
if|if
condition|(
name|arcs_marked_by_insn
operator|->
name|next_arc_marked_by_insn
operator|==
name|NULL
condition|)
name|state
operator|=
name|arcs_marked_by_insn
operator|->
name|to_state
expr_stmt|;
else|else
block|{
name|gcc_assert
argument_list|(
name|ndfa_flag
argument_list|)
expr_stmt|;
comment|/* Create composed state.  */
name|state
operator|=
name|get_free_state
argument_list|(
literal|0
argument_list|,
name|arcs_marked_by_insn
operator|->
name|to_state
operator|->
name|automaton
argument_list|)
expr_stmt|;
name|curr_alt_state
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|curr_arc
operator|=
name|arcs_marked_by_insn
init|;
name|curr_arc
operator|!=
name|NULL
condition|;
name|curr_arc
operator|=
name|curr_arc
operator|->
name|next_arc_marked_by_insn
control|)
if|if
condition|(
name|curr_arc
operator|->
name|to_state
operator|->
name|component_states
operator|==
name|NULL
condition|)
block|{
name|new_alt_state
operator|=
name|get_free_alt_state
argument_list|()
expr_stmt|;
name|new_alt_state
operator|->
name|next_alt_state
operator|=
name|curr_alt_state
expr_stmt|;
name|new_alt_state
operator|->
name|state
operator|=
name|curr_arc
operator|->
name|to_state
expr_stmt|;
name|curr_alt_state
operator|=
name|new_alt_state
expr_stmt|;
block|}
else|else
for|for
control|(
name|alt_state
operator|=
name|curr_arc
operator|->
name|to_state
operator|->
name|component_states
init|;
name|alt_state
operator|!=
name|NULL
condition|;
name|alt_state
operator|=
name|alt_state
operator|->
name|next_sorted_alt_state
control|)
block|{
name|new_alt_state
operator|=
name|get_free_alt_state
argument_list|()
expr_stmt|;
name|new_alt_state
operator|->
name|next_alt_state
operator|=
name|curr_alt_state
expr_stmt|;
name|new_alt_state
operator|->
name|state
operator|=
name|alt_state
operator|->
name|state
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|alt_state
operator|->
name|state
operator|->
name|component_states
argument_list|)
expr_stmt|;
name|curr_alt_state
operator|=
name|new_alt_state
expr_stmt|;
block|}
comment|/* There are not identical sets in the alt state list.  */
name|canonical_alt_states_list
operator|=
name|uniq_sort_alt_states
argument_list|(
name|curr_alt_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|canonical_alt_states_list
operator|->
name|next_sorted_alt_state
operator|==
name|NULL
condition|)
block|{
name|temp_state
operator|=
name|state
expr_stmt|;
name|state
operator|=
name|canonical_alt_states_list
operator|->
name|state
expr_stmt|;
name|free_state
argument_list|(
name|temp_state
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|state
operator|->
name|component_states
operator|=
name|canonical_alt_states_list
expr_stmt|;
name|state_in_table
operator|=
name|insert_state
argument_list|(
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|state_in_table
operator|!=
name|state
condition|)
block|{
name|gcc_assert
argument_list|(
name|state_in_table
operator|->
name|it_was_placed_in_stack_for_DFA_forming
argument_list|)
expr_stmt|;
name|free_state
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|state
operator|=
name|state_in_table
expr_stmt|;
block|}
else|else
block|{
name|gcc_assert
argument_list|(
operator|!
name|state
operator|->
name|it_was_placed_in_stack_for_DFA_forming
argument_list|)
expr_stmt|;
name|new_state_p
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|curr_alt_state
operator|=
name|state
operator|->
name|component_states
init|;
name|curr_alt_state
operator|!=
name|NULL
condition|;
name|curr_alt_state
operator|=
name|curr_alt_state
operator|->
name|next_sorted_alt_state
control|)
for|for
control|(
name|curr_arc
operator|=
name|first_out_arc
argument_list|(
name|curr_alt_state
operator|->
name|state
argument_list|)
init|;
name|curr_arc
operator|!=
name|NULL
condition|;
name|curr_arc
operator|=
name|next_out_arc
argument_list|(
name|curr_arc
argument_list|)
control|)
name|add_arc
argument_list|(
name|state
argument_list|,
name|curr_arc
operator|->
name|to_state
argument_list|,
name|curr_arc
operator|->
name|insn
argument_list|)
expr_stmt|;
block|}
name|arcs_marked_by_insn
operator|->
name|to_state
operator|=
name|state
expr_stmt|;
for|for
control|(
name|alts_number
operator|=
literal|0
operator|,
name|curr_arc
operator|=
name|arcs_marked_by_insn
operator|->
name|next_arc_marked_by_insn
init|;
name|curr_arc
operator|!=
name|NULL
condition|;
name|curr_arc
operator|=
name|next_arc
control|)
block|{
name|next_arc
operator|=
name|curr_arc
operator|->
name|next_arc_marked_by_insn
expr_stmt|;
name|remove_arc
argument_list|(
name|original_state
argument_list|,
name|curr_arc
argument_list|)
expr_stmt|;
name|alts_number
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|state
operator|->
name|it_was_placed_in_stack_for_DFA_forming
condition|)
block|{
name|state
operator|->
name|it_was_placed_in_stack_for_DFA_forming
operator|=
literal|1
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|state_t
argument_list|,
name|heap
argument_list|,
operator|*
name|state_stack
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
return|return
name|new_state_p
return|;
block|}
end_decl_stmt

begin_comment
comment|/* The function transforms nondeterministic AUTOMATON into    deterministic.  */
end_comment

begin_function
specifier|static
name|void
name|NDFA_to_DFA
parameter_list|(
name|automaton_t
name|automaton
parameter_list|)
block|{
name|state_t
name|start_state
decl_stmt|;
name|state_t
name|state
decl_stmt|;
name|decl_t
name|decl
decl_stmt|;
name|VEC
argument_list|(
name|state_t
argument_list|,
name|heap
argument_list|)
operator|*
name|state_stack
expr_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|states_n
decl_stmt|;
name|state_stack
operator|=
name|VEC_alloc
argument_list|(
name|state_t
argument_list|,
name|heap
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Create the start state (empty state).  */
name|start_state
operator|=
name|automaton
operator|->
name|start_state
expr_stmt|;
name|start_state
operator|->
name|it_was_placed_in_stack_for_DFA_forming
operator|=
literal|1
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|state_t
argument_list|,
name|heap
argument_list|,
name|state_stack
argument_list|,
name|start_state
argument_list|)
expr_stmt|;
name|states_n
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|VEC_length
argument_list|(
name|state_t
argument_list|,
name|state_stack
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|state
operator|=
name|VEC_pop
argument_list|(
name|state_t
argument_list|,
name|state_stack
argument_list|)
expr_stmt|;
name|form_arcs_marked_by_insn
argument_list|(
name|state
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_insn_reserv
operator|&&
name|create_composed_state
argument_list|(
name|state
argument_list|,
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|arcs_marked_by_insn
argument_list|,
operator|&
name|state_stack
argument_list|)
condition|)
block|{
name|states_n
operator|++
expr_stmt|;
if|if
condition|(
name|progress_flag
operator|&&
name|states_n
operator|%
literal|100
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|VEC_free
argument_list|(
name|state_t
argument_list|,
name|heap
argument_list|,
name|state_stack
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The following variable value is current number (1, 2, ...) of passing    graph of states.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|curr_state_graph_pass_num
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This recursive function passes all states achieved from START_STATE    and applies APPLIED_FUNC to them.  */
end_comment

begin_function
specifier|static
name|void
name|pass_state_graph
parameter_list|(
name|state_t
name|start_state
parameter_list|,
name|void
function_decl|(
modifier|*
name|applied_func
function_decl|)
parameter_list|(
name|state_t
name|state
parameter_list|)
parameter_list|)
block|{
name|arc_t
name|arc
decl_stmt|;
if|if
condition|(
name|start_state
operator|->
name|pass_num
operator|==
name|curr_state_graph_pass_num
condition|)
return|return;
name|start_state
operator|->
name|pass_num
operator|=
name|curr_state_graph_pass_num
expr_stmt|;
call|(
modifier|*
name|applied_func
call|)
argument_list|(
name|start_state
argument_list|)
expr_stmt|;
for|for
control|(
name|arc
operator|=
name|first_out_arc
argument_list|(
name|start_state
argument_list|)
init|;
name|arc
operator|!=
name|NULL
condition|;
name|arc
operator|=
name|next_out_arc
argument_list|(
name|arc
argument_list|)
control|)
name|pass_state_graph
argument_list|(
name|arc
operator|->
name|to_state
argument_list|,
name|applied_func
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This recursive function passes all states of AUTOMATON and applies    APPLIED_FUNC to them.  */
end_comment

begin_function
specifier|static
name|void
name|pass_states
parameter_list|(
name|automaton_t
name|automaton
parameter_list|,
name|void
function_decl|(
modifier|*
name|applied_func
function_decl|)
parameter_list|(
name|state_t
name|state
parameter_list|)
parameter_list|)
block|{
name|curr_state_graph_pass_num
operator|++
expr_stmt|;
name|pass_state_graph
argument_list|(
name|automaton
operator|->
name|start_state
argument_list|,
name|applied_func
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function initializes code for passing of all states.  */
end_comment

begin_function
specifier|static
name|void
name|initiate_pass_states
parameter_list|(
name|void
parameter_list|)
block|{
name|curr_state_graph_pass_num
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The following vla is used for storing pointers to all achieved    states.  */
end_comment

begin_expr_stmt
specifier|static
name|VEC
argument_list|(
name|state_t
argument_list|,
name|heap
argument_list|)
operator|*
name|all_achieved_states
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* This function is called by function pass_states to add an achieved    STATE.  */
end_comment

begin_function
specifier|static
name|void
name|add_achieved_state
parameter_list|(
name|state_t
name|state
parameter_list|)
block|{
name|VEC_safe_push
argument_list|(
name|state_t
argument_list|,
name|heap
argument_list|,
name|all_achieved_states
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function sets up equivalence numbers of insns which mark all    out arcs of STATE by equiv_class_num_1 (if ODD_ITERATION_FLAG has    nonzero value) or by equiv_class_num_2 of the destination state.    The function returns number of out arcs of STATE.  */
end_comment

begin_function
specifier|static
name|void
name|set_out_arc_insns_equiv_num
parameter_list|(
name|state_t
name|state
parameter_list|,
name|int
name|odd_iteration_flag
parameter_list|)
block|{
name|arc_t
name|arc
decl_stmt|;
for|for
control|(
name|arc
operator|=
name|first_out_arc
argument_list|(
name|state
argument_list|)
init|;
name|arc
operator|!=
name|NULL
condition|;
name|arc
operator|=
name|next_out_arc
argument_list|(
name|arc
argument_list|)
control|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|arc
operator|->
name|insn
operator|->
name|insn_reserv_decl
operator|->
name|equiv_class_num
argument_list|)
expr_stmt|;
name|arc
operator|->
name|insn
operator|->
name|insn_reserv_decl
operator|->
name|equiv_class_num
operator|=
operator|(
name|odd_iteration_flag
condition|?
name|arc
operator|->
name|to_state
operator|->
name|equiv_class_num_1
else|:
name|arc
operator|->
name|to_state
operator|->
name|equiv_class_num_2
operator|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|arc
operator|->
name|insn
operator|->
name|insn_reserv_decl
operator|->
name|equiv_class_num
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The function clears equivalence numbers and alt_states in all insns    which mark all out arcs of STATE.  */
end_comment

begin_function
specifier|static
name|void
name|clear_arc_insns_equiv_num
parameter_list|(
name|state_t
name|state
parameter_list|)
block|{
name|arc_t
name|arc
decl_stmt|;
for|for
control|(
name|arc
operator|=
name|first_out_arc
argument_list|(
name|state
argument_list|)
init|;
name|arc
operator|!=
name|NULL
condition|;
name|arc
operator|=
name|next_out_arc
argument_list|(
name|arc
argument_list|)
control|)
name|arc
operator|->
name|insn
operator|->
name|insn_reserv_decl
operator|->
name|equiv_class_num
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The following function returns TRUE if STATE reserves the unit with    UNIT_NUM on the first cycle.  */
end_comment

begin_function
specifier|static
name|int
name|first_cycle_unit_presence
parameter_list|(
name|state_t
name|state
parameter_list|,
name|int
name|unit_num
parameter_list|)
block|{
name|alt_state_t
name|alt_state
decl_stmt|;
if|if
condition|(
name|state
operator|->
name|component_states
operator|==
name|NULL
condition|)
return|return
name|test_unit_reserv
argument_list|(
name|state
operator|->
name|reservs
argument_list|,
literal|0
argument_list|,
name|unit_num
argument_list|)
return|;
else|else
block|{
for|for
control|(
name|alt_state
operator|=
name|state
operator|->
name|component_states
init|;
name|alt_state
operator|!=
name|NULL
condition|;
name|alt_state
operator|=
name|alt_state
operator|->
name|next_sorted_alt_state
control|)
if|if
condition|(
name|test_unit_reserv
argument_list|(
name|alt_state
operator|->
name|state
operator|->
name|reservs
argument_list|,
literal|0
argument_list|,
name|unit_num
argument_list|)
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* This fills in the presence_signature[] member of STATE.  */
end_comment

begin_function
specifier|static
name|void
name|cache_presence
parameter_list|(
name|state_t
name|state
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|num
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|sz
decl_stmt|;
name|sz
operator|=
operator|(
name|description
operator|->
name|query_units_num
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|CHAR_BIT
operator|-
literal|1
operator|)
operator|/
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|CHAR_BIT
operator|)
expr_stmt|;
name|state
operator|->
name|presence_signature
operator|=
name|create_node
argument_list|(
name|sz
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|units_num
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|units_array
index|[
name|i
index|]
operator|->
name|query_p
condition|)
block|{
name|int
name|presence1_p
init|=
name|first_cycle_unit_presence
argument_list|(
name|state
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|state
operator|->
name|presence_signature
index|[
name|num
operator|/
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|CHAR_BIT
operator|)
index|]
operator||=
operator|(
operator|!
operator|!
name|presence1_p
operator|)
operator|<<
operator|(
name|num
operator|%
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|CHAR_BIT
operator|)
operator|)
expr_stmt|;
name|num
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The function returns nonzero value if STATE is not equivalent to    ANOTHER_STATE from the same current partition on equivalence    classes.  Another state has ANOTHER_STATE_OUT_ARCS_NUM number of    output arcs.  Iteration of making equivalence partition is defined    by ODD_ITERATION_FLAG.  */
end_comment

begin_function
specifier|static
name|int
name|state_is_differed
parameter_list|(
name|state_t
name|state
parameter_list|,
name|state_t
name|another_state
parameter_list|,
name|int
name|odd_iteration_flag
parameter_list|)
block|{
name|arc_t
name|arc
decl_stmt|;
name|unsigned
name|int
name|sz
decl_stmt|,
name|si
decl_stmt|;
name|gcc_assert
argument_list|(
name|state
operator|->
name|num_out_arcs
operator|==
name|another_state
operator|->
name|num_out_arcs
argument_list|)
expr_stmt|;
name|sz
operator|=
operator|(
name|description
operator|->
name|query_units_num
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|CHAR_BIT
operator|-
literal|1
operator|)
operator|/
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|CHAR_BIT
operator|)
expr_stmt|;
for|for
control|(
name|si
operator|=
literal|0
init|;
name|si
operator|<
name|sz
condition|;
name|si
operator|++
control|)
name|gcc_assert
argument_list|(
name|state
operator|->
name|presence_signature
index|[
name|si
index|]
operator|==
name|another_state
operator|->
name|presence_signature
index|[
name|si
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|arc
operator|=
name|first_out_arc
argument_list|(
name|state
argument_list|)
init|;
name|arc
operator|!=
name|NULL
condition|;
name|arc
operator|=
name|next_out_arc
argument_list|(
name|arc
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|odd_iteration_flag
condition|?
name|arc
operator|->
name|to_state
operator|->
name|equiv_class_num_1
else|:
name|arc
operator|->
name|to_state
operator|->
name|equiv_class_num_2
operator|)
operator|!=
name|arc
operator|->
name|insn
operator|->
name|insn_reserv_decl
operator|->
name|equiv_class_num
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Compares two states pointed to by STATE_PTR_1 and STATE_PTR_2    and return -1, 0 or 1.  This function can be used as predicate for    qsort().  It requires the member presence_signature[] of both    states be filled.  */
end_comment

begin_function
specifier|static
name|int
name|compare_states_for_equiv
parameter_list|(
specifier|const
name|void
modifier|*
name|state_ptr_1
parameter_list|,
specifier|const
name|void
modifier|*
name|state_ptr_2
parameter_list|)
block|{
name|state_t
name|s1
init|=
operator|*
operator|(
name|state_t
operator|*
operator|)
name|state_ptr_1
decl_stmt|;
name|state_t
name|s2
init|=
operator|*
operator|(
name|state_t
operator|*
operator|)
name|state_ptr_2
decl_stmt|;
name|unsigned
name|int
name|sz
decl_stmt|,
name|si
decl_stmt|;
if|if
condition|(
name|s1
operator|->
name|num_out_arcs
operator|<
name|s2
operator|->
name|num_out_arcs
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|s1
operator|->
name|num_out_arcs
operator|>
name|s2
operator|->
name|num_out_arcs
condition|)
return|return
literal|1
return|;
name|sz
operator|=
operator|(
name|description
operator|->
name|query_units_num
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|CHAR_BIT
operator|-
literal|1
operator|)
operator|/
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|CHAR_BIT
operator|)
expr_stmt|;
for|for
control|(
name|si
operator|=
literal|0
init|;
name|si
operator|<
name|sz
condition|;
name|si
operator|++
control|)
if|if
condition|(
name|s1
operator|->
name|presence_signature
index|[
name|si
index|]
operator|<
name|s2
operator|->
name|presence_signature
index|[
name|si
index|]
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|s1
operator|->
name|presence_signature
index|[
name|si
index|]
operator|>
name|s2
operator|->
name|presence_signature
index|[
name|si
index|]
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* The function makes initial partition of STATES on equivalent    classes and saves it into *CLASSES.  This function requires the input    to be sorted via compare_states_for_equiv().  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|init_equiv_class
argument_list|(
name|VEC
argument_list|(
name|state_t
argument_list|,
name|heap
argument_list|)
operator|*
name|states
argument_list|,
name|VEC
argument_list|(
name|state_t
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
name|classes
argument_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|state_t
name|prev
init|=
literal|0
decl_stmt|;
name|int
name|class_num
init|=
literal|1
decl_stmt|;
operator|*
name|classes
operator|=
name|VEC_alloc
argument_list|(
name|state_t
argument_list|,
name|heap
argument_list|,
literal|150
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VEC_length
argument_list|(
name|state_t
argument_list|,
name|states
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|state_t
name|state
init|=
name|VEC_index
argument_list|(
name|state_t
argument_list|,
name|states
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|prev
condition|)
block|{
if|if
condition|(
name|compare_states_for_equiv
argument_list|(
operator|&
name|prev
argument_list|,
operator|&
name|state
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|VEC_safe_push
argument_list|(
name|state_t
argument_list|,
name|heap
argument_list|,
operator|*
name|classes
argument_list|,
name|prev
argument_list|)
expr_stmt|;
name|class_num
operator|++
expr_stmt|;
name|prev
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|state
operator|->
name|equiv_class_num_1
operator|=
name|class_num
expr_stmt|;
name|state
operator|->
name|next_equiv_class_state
operator|=
name|prev
expr_stmt|;
name|prev
operator|=
name|state
expr_stmt|;
block|}
if|if
condition|(
name|prev
condition|)
name|VEC_safe_push
argument_list|(
name|state_t
argument_list|,
name|heap
argument_list|,
operator|*
name|classes
argument_list|,
name|prev
argument_list|)
expr_stmt|;
return|return
name|class_num
return|;
block|}
end_decl_stmt

begin_comment
comment|/* The function copies pointers to equivalent states from vla FROM    into vla TO.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|copy_equiv_class
argument_list|(
name|VEC
argument_list|(
name|state_t
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
name|to
argument_list|,
name|VEC
argument_list|(
name|state_t
argument_list|,
name|heap
argument_list|)
operator|*
name|from
argument_list|)
block|{
name|VEC_free
argument_list|(
name|state_t
argument_list|,
name|heap
argument_list|,
operator|*
name|to
argument_list|)
expr_stmt|;
operator|*
name|to
operator|=
name|VEC_copy
argument_list|(
name|state_t
argument_list|,
name|heap
argument_list|,
name|from
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* The function processes equivalence class given by its first state,    FIRST_STATE, on odd iteration if ODD_ITERATION_FLAG.  If there    are not equivalent states, the function partitions the class    removing nonequivalent states and placing them in    *NEXT_ITERATION_CLASSES, increments *NEW_EQUIV_CLASS_NUM_PTR ans    assigns it to the state equivalence number.  If the class has been    partitioned, the function returns nonzero value.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|partition_equiv_class
argument_list|(
name|state_t
name|first_state
argument_list|,
name|int
name|odd_iteration_flag
argument_list|,
name|VEC
argument_list|(
name|state_t
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
name|next_iteration_classes
argument_list|,
name|int
operator|*
name|new_equiv_class_num_ptr
argument_list|)
block|{
name|state_t
name|new_equiv_class
decl_stmt|;
name|int
name|partition_p
decl_stmt|;
name|state_t
name|curr_state
decl_stmt|;
name|state_t
name|prev_state
decl_stmt|;
name|state_t
name|next_state
decl_stmt|;
name|partition_p
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|first_state
operator|!=
name|NULL
condition|)
block|{
name|new_equiv_class
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|first_state
operator|->
name|next_equiv_class_state
operator|!=
name|NULL
condition|)
block|{
comment|/* There are more one states in the class equivalence.  */
name|set_out_arc_insns_equiv_num
argument_list|(
name|first_state
argument_list|,
name|odd_iteration_flag
argument_list|)
expr_stmt|;
for|for
control|(
name|prev_state
operator|=
name|first_state
operator|,
name|curr_state
operator|=
name|first_state
operator|->
name|next_equiv_class_state
init|;
name|curr_state
operator|!=
name|NULL
condition|;
name|curr_state
operator|=
name|next_state
control|)
block|{
name|next_state
operator|=
name|curr_state
operator|->
name|next_equiv_class_state
expr_stmt|;
if|if
condition|(
name|state_is_differed
argument_list|(
name|curr_state
argument_list|,
name|first_state
argument_list|,
name|odd_iteration_flag
argument_list|)
condition|)
block|{
comment|/* Remove curr state from the class equivalence.  */
name|prev_state
operator|->
name|next_equiv_class_state
operator|=
name|next_state
expr_stmt|;
comment|/* Add curr state to the new class equivalence.  */
name|curr_state
operator|->
name|next_equiv_class_state
operator|=
name|new_equiv_class
expr_stmt|;
if|if
condition|(
name|new_equiv_class
operator|==
name|NULL
condition|)
operator|(
operator|*
name|new_equiv_class_num_ptr
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|odd_iteration_flag
condition|)
name|curr_state
operator|->
name|equiv_class_num_2
operator|=
operator|*
name|new_equiv_class_num_ptr
expr_stmt|;
else|else
name|curr_state
operator|->
name|equiv_class_num_1
operator|=
operator|*
name|new_equiv_class_num_ptr
expr_stmt|;
name|new_equiv_class
operator|=
name|curr_state
expr_stmt|;
name|partition_p
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|prev_state
operator|=
name|curr_state
expr_stmt|;
block|}
name|clear_arc_insns_equiv_num
argument_list|(
name|first_state
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|new_equiv_class
operator|!=
name|NULL
condition|)
name|VEC_safe_push
argument_list|(
name|state_t
argument_list|,
name|heap
argument_list|,
operator|*
name|next_iteration_classes
argument_list|,
name|new_equiv_class
argument_list|)
expr_stmt|;
name|first_state
operator|=
name|new_equiv_class
expr_stmt|;
block|}
return|return
name|partition_p
return|;
block|}
end_decl_stmt

begin_comment
comment|/* The function finds equivalent states of AUTOMATON.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|evaluate_equiv_classes
argument_list|(
name|automaton_t
name|automaton
argument_list|,
name|VEC
argument_list|(
name|state_t
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
name|equiv_classes
argument_list|)
block|{
name|int
name|new_equiv_class_num
decl_stmt|;
name|int
name|odd_iteration_flag
decl_stmt|;
name|int
name|finish_flag
decl_stmt|;
name|VEC
argument_list|(
name|state_t
argument_list|,
name|heap
argument_list|)
operator|*
name|next_iteration_classes
expr_stmt|;
name|size_t
name|i
decl_stmt|;
name|all_achieved_states
operator|=
name|VEC_alloc
argument_list|(
name|state_t
argument_list|,
name|heap
argument_list|,
literal|1500
argument_list|)
expr_stmt|;
name|pass_states
argument_list|(
name|automaton
argument_list|,
name|add_achieved_state
argument_list|)
expr_stmt|;
name|pass_states
argument_list|(
name|automaton
argument_list|,
name|cache_presence
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|VEC_address
argument_list|(
name|state_t
argument_list|,
name|all_achieved_states
argument_list|)
argument_list|,
name|VEC_length
argument_list|(
name|state_t
argument_list|,
name|all_achieved_states
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|state_t
argument_list|)
argument_list|,
name|compare_states_for_equiv
argument_list|)
expr_stmt|;
name|odd_iteration_flag
operator|=
literal|0
expr_stmt|;
name|new_equiv_class_num
operator|=
name|init_equiv_class
argument_list|(
name|all_achieved_states
argument_list|,
operator|&
name|next_iteration_classes
argument_list|)
expr_stmt|;
do|do
block|{
name|odd_iteration_flag
operator|=
operator|!
name|odd_iteration_flag
expr_stmt|;
name|finish_flag
operator|=
literal|1
expr_stmt|;
name|copy_equiv_class
argument_list|(
name|equiv_classes
argument_list|,
name|next_iteration_classes
argument_list|)
expr_stmt|;
comment|/* Transfer equiv numbers for the next iteration.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VEC_length
argument_list|(
name|state_t
argument_list|,
name|all_achieved_states
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|odd_iteration_flag
condition|)
name|VEC_index
argument_list|(
name|state_t
argument_list|,
name|all_achieved_states
argument_list|,
name|i
argument_list|)
operator|->
name|equiv_class_num_2
operator|=
name|VEC_index
argument_list|(
name|state_t
argument_list|,
name|all_achieved_states
argument_list|,
name|i
argument_list|)
operator|->
name|equiv_class_num_1
expr_stmt|;
else|else
name|VEC_index
argument_list|(
name|state_t
argument_list|,
name|all_achieved_states
argument_list|,
name|i
argument_list|)
operator|->
name|equiv_class_num_1
operator|=
name|VEC_index
argument_list|(
name|state_t
argument_list|,
name|all_achieved_states
argument_list|,
name|i
argument_list|)
operator|->
name|equiv_class_num_2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VEC_length
argument_list|(
name|state_t
argument_list|,
operator|*
name|equiv_classes
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|partition_equiv_class
argument_list|(
name|VEC_index
argument_list|(
name|state_t
argument_list|,
operator|*
name|equiv_classes
argument_list|,
name|i
argument_list|)
argument_list|,
name|odd_iteration_flag
argument_list|,
operator|&
name|next_iteration_classes
argument_list|,
operator|&
name|new_equiv_class_num
argument_list|)
condition|)
name|finish_flag
operator|=
literal|0
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|finish_flag
condition|)
do|;
name|VEC_free
argument_list|(
name|state_t
argument_list|,
name|heap
argument_list|,
name|next_iteration_classes
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|state_t
argument_list|,
name|heap
argument_list|,
name|all_achieved_states
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* The function merges equivalent states of AUTOMATON.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|merge_states
argument_list|(
name|automaton_t
name|automaton
argument_list|,
name|VEC
argument_list|(
name|state_t
argument_list|,
name|heap
argument_list|)
operator|*
name|equiv_classes
argument_list|)
block|{
name|state_t
name|curr_state
decl_stmt|;
name|state_t
name|new_state
decl_stmt|;
name|state_t
name|first_class_state
decl_stmt|;
name|alt_state_t
name|alt_states
decl_stmt|;
name|alt_state_t
name|alt_state
decl_stmt|,
name|new_alt_state
decl_stmt|;
name|arc_t
name|curr_arc
decl_stmt|;
name|arc_t
name|next_arc
decl_stmt|;
name|size_t
name|i
decl_stmt|;
comment|/* Create states corresponding to equivalence classes containing two      or more states.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VEC_length
argument_list|(
name|state_t
argument_list|,
name|equiv_classes
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|curr_state
operator|=
name|VEC_index
argument_list|(
name|state_t
argument_list|,
name|equiv_classes
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|curr_state
operator|->
name|next_equiv_class_state
operator|!=
name|NULL
condition|)
block|{
comment|/* There are more one states in the class equivalence.  */
comment|/* Create new compound state.  */
name|new_state
operator|=
name|get_free_state
argument_list|(
literal|0
argument_list|,
name|automaton
argument_list|)
expr_stmt|;
name|alt_states
operator|=
name|NULL
expr_stmt|;
name|first_class_state
operator|=
name|curr_state
expr_stmt|;
for|for
control|(
name|curr_state
operator|=
name|first_class_state
init|;
name|curr_state
operator|!=
name|NULL
condition|;
name|curr_state
operator|=
name|curr_state
operator|->
name|next_equiv_class_state
control|)
block|{
name|curr_state
operator|->
name|equiv_class_state
operator|=
name|new_state
expr_stmt|;
if|if
condition|(
name|curr_state
operator|->
name|component_states
operator|==
name|NULL
condition|)
block|{
name|new_alt_state
operator|=
name|get_free_alt_state
argument_list|()
expr_stmt|;
name|new_alt_state
operator|->
name|state
operator|=
name|curr_state
expr_stmt|;
name|new_alt_state
operator|->
name|next_alt_state
operator|=
name|alt_states
expr_stmt|;
name|alt_states
operator|=
name|new_alt_state
expr_stmt|;
block|}
else|else
for|for
control|(
name|alt_state
operator|=
name|curr_state
operator|->
name|component_states
init|;
name|alt_state
operator|!=
name|NULL
condition|;
name|alt_state
operator|=
name|alt_state
operator|->
name|next_sorted_alt_state
control|)
block|{
name|new_alt_state
operator|=
name|get_free_alt_state
argument_list|()
expr_stmt|;
name|new_alt_state
operator|->
name|state
operator|=
name|alt_state
operator|->
name|state
expr_stmt|;
name|new_alt_state
operator|->
name|next_alt_state
operator|=
name|alt_states
expr_stmt|;
name|alt_states
operator|=
name|new_alt_state
expr_stmt|;
block|}
block|}
comment|/* Its is important that alt states were sorted before and 	     after merging to have the same querying results.  */
name|new_state
operator|->
name|component_states
operator|=
name|uniq_sort_alt_states
argument_list|(
name|alt_states
argument_list|)
expr_stmt|;
block|}
else|else
name|curr_state
operator|->
name|equiv_class_state
operator|=
name|curr_state
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VEC_length
argument_list|(
name|state_t
argument_list|,
name|equiv_classes
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|curr_state
operator|=
name|VEC_index
argument_list|(
name|state_t
argument_list|,
name|equiv_classes
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|curr_state
operator|->
name|next_equiv_class_state
operator|!=
name|NULL
condition|)
block|{
name|first_class_state
operator|=
name|curr_state
expr_stmt|;
comment|/* Create new arcs output from the state corresponding to 	     equiv class.  */
for|for
control|(
name|curr_arc
operator|=
name|first_out_arc
argument_list|(
name|first_class_state
argument_list|)
init|;
name|curr_arc
operator|!=
name|NULL
condition|;
name|curr_arc
operator|=
name|next_out_arc
argument_list|(
name|curr_arc
argument_list|)
control|)
name|add_arc
argument_list|(
name|first_class_state
operator|->
name|equiv_class_state
argument_list|,
name|curr_arc
operator|->
name|to_state
operator|->
name|equiv_class_state
argument_list|,
name|curr_arc
operator|->
name|insn
argument_list|)
expr_stmt|;
comment|/* Delete output arcs from states of given class equivalence.  */
for|for
control|(
name|curr_state
operator|=
name|first_class_state
init|;
name|curr_state
operator|!=
name|NULL
condition|;
name|curr_state
operator|=
name|curr_state
operator|->
name|next_equiv_class_state
control|)
block|{
if|if
condition|(
name|automaton
operator|->
name|start_state
operator|==
name|curr_state
condition|)
name|automaton
operator|->
name|start_state
operator|=
name|curr_state
operator|->
name|equiv_class_state
expr_stmt|;
comment|/* Delete the state and its output arcs.  */
for|for
control|(
name|curr_arc
operator|=
name|first_out_arc
argument_list|(
name|curr_state
argument_list|)
init|;
name|curr_arc
operator|!=
name|NULL
condition|;
name|curr_arc
operator|=
name|next_arc
control|)
block|{
name|next_arc
operator|=
name|next_out_arc
argument_list|(
name|curr_arc
argument_list|)
expr_stmt|;
name|free_arc
argument_list|(
name|curr_arc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* Change `to_state' of arcs output from the state of given 	     equivalence class.  */
for|for
control|(
name|curr_arc
operator|=
name|first_out_arc
argument_list|(
name|curr_state
argument_list|)
init|;
name|curr_arc
operator|!=
name|NULL
condition|;
name|curr_arc
operator|=
name|next_out_arc
argument_list|(
name|curr_arc
argument_list|)
control|)
name|curr_arc
operator|->
name|to_state
operator|=
name|curr_arc
operator|->
name|to_state
operator|->
name|equiv_class_state
expr_stmt|;
block|}
block|}
block|}
end_decl_stmt

begin_comment
comment|/* The function sets up new_cycle_p for states if there is arc to the    state marked by advance_cycle_insn_decl.  */
end_comment

begin_function
specifier|static
name|void
name|set_new_cycle_flags
parameter_list|(
name|state_t
name|state
parameter_list|)
block|{
name|arc_t
name|arc
decl_stmt|;
for|for
control|(
name|arc
operator|=
name|first_out_arc
argument_list|(
name|state
argument_list|)
init|;
name|arc
operator|!=
name|NULL
condition|;
name|arc
operator|=
name|next_out_arc
argument_list|(
name|arc
argument_list|)
control|)
if|if
condition|(
name|arc
operator|->
name|insn
operator|->
name|insn_reserv_decl
operator|==
name|DECL_INSN_RESERV
argument_list|(
name|advance_cycle_insn_decl
argument_list|)
condition|)
name|arc
operator|->
name|to_state
operator|->
name|new_cycle_p
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The top level function for minimization of deterministic    AUTOMATON.  */
end_comment

begin_function
specifier|static
name|void
name|minimize_DFA
parameter_list|(
name|automaton_t
name|automaton
parameter_list|)
block|{
name|VEC
argument_list|(
name|state_t
argument_list|,
name|heap
argument_list|)
operator|*
name|equiv_classes
operator|=
literal|0
expr_stmt|;
name|evaluate_equiv_classes
argument_list|(
name|automaton
argument_list|,
operator|&
name|equiv_classes
argument_list|)
expr_stmt|;
name|merge_states
argument_list|(
name|automaton
argument_list|,
name|equiv_classes
argument_list|)
expr_stmt|;
name|pass_states
argument_list|(
name|automaton
argument_list|,
name|set_new_cycle_flags
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|state_t
argument_list|,
name|heap
argument_list|,
name|equiv_classes
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Values of two variables are counted number of states and arcs in an    automaton.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|curr_counted_states_num
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|curr_counted_arcs_num
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The function is called by function `pass_states' to count states    and arcs of an automaton.  */
end_comment

begin_function
specifier|static
name|void
name|incr_states_and_arcs_nums
parameter_list|(
name|state_t
name|state
parameter_list|)
block|{
name|arc_t
name|arc
decl_stmt|;
name|curr_counted_states_num
operator|++
expr_stmt|;
for|for
control|(
name|arc
operator|=
name|first_out_arc
argument_list|(
name|state
argument_list|)
init|;
name|arc
operator|!=
name|NULL
condition|;
name|arc
operator|=
name|next_out_arc
argument_list|(
name|arc
argument_list|)
control|)
name|curr_counted_arcs_num
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function counts states and arcs of AUTOMATON.  */
end_comment

begin_function
specifier|static
name|void
name|count_states_and_arcs
parameter_list|(
name|automaton_t
name|automaton
parameter_list|,
name|int
modifier|*
name|states_num
parameter_list|,
name|int
modifier|*
name|arcs_num
parameter_list|)
block|{
name|curr_counted_states_num
operator|=
literal|0
expr_stmt|;
name|curr_counted_arcs_num
operator|=
literal|0
expr_stmt|;
name|pass_states
argument_list|(
name|automaton
argument_list|,
name|incr_states_and_arcs_nums
argument_list|)
expr_stmt|;
operator|*
name|states_num
operator|=
name|curr_counted_states_num
expr_stmt|;
operator|*
name|arcs_num
operator|=
name|curr_counted_arcs_num
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function builds one DFA AUTOMATON for fast pipeline hazards    recognition after checking and simplifying IR of the    description.  */
end_comment

begin_function
specifier|static
name|void
name|build_automaton
parameter_list|(
name|automaton_t
name|automaton
parameter_list|)
block|{
name|int
name|states_num
decl_stmt|;
name|int
name|arcs_num
decl_stmt|;
name|ticker_on
argument_list|(
operator|&
name|NDFA_time
argument_list|)
expr_stmt|;
if|if
condition|(
name|progress_flag
condition|)
block|{
if|if
condition|(
name|automaton
operator|->
name|corresponding_automaton_decl
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Create anonymous automaton"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Create automaton `%s'"
argument_list|,
name|automaton
operator|->
name|corresponding_automaton_decl
operator|->
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" (1 dot is 100 new states):"
argument_list|)
expr_stmt|;
block|}
name|make_automaton
argument_list|(
name|automaton
argument_list|)
expr_stmt|;
if|if
condition|(
name|progress_flag
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" done\n"
argument_list|)
expr_stmt|;
name|ticker_off
argument_list|(
operator|&
name|NDFA_time
argument_list|)
expr_stmt|;
name|count_states_and_arcs
argument_list|(
name|automaton
argument_list|,
operator|&
name|states_num
argument_list|,
operator|&
name|arcs_num
argument_list|)
expr_stmt|;
name|automaton
operator|->
name|NDFA_states_num
operator|=
name|states_num
expr_stmt|;
name|automaton
operator|->
name|NDFA_arcs_num
operator|=
name|arcs_num
expr_stmt|;
name|ticker_on
argument_list|(
operator|&
name|NDFA_to_DFA_time
argument_list|)
expr_stmt|;
if|if
condition|(
name|progress_flag
condition|)
block|{
if|if
condition|(
name|automaton
operator|->
name|corresponding_automaton_decl
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Make anonymous DFA"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Make DFA `%s'"
argument_list|,
name|automaton
operator|->
name|corresponding_automaton_decl
operator|->
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" (1 dot is 100 new states):"
argument_list|)
expr_stmt|;
block|}
name|NDFA_to_DFA
argument_list|(
name|automaton
argument_list|)
expr_stmt|;
if|if
condition|(
name|progress_flag
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" done\n"
argument_list|)
expr_stmt|;
name|ticker_off
argument_list|(
operator|&
name|NDFA_to_DFA_time
argument_list|)
expr_stmt|;
name|count_states_and_arcs
argument_list|(
name|automaton
argument_list|,
operator|&
name|states_num
argument_list|,
operator|&
name|arcs_num
argument_list|)
expr_stmt|;
name|automaton
operator|->
name|DFA_states_num
operator|=
name|states_num
expr_stmt|;
name|automaton
operator|->
name|DFA_arcs_num
operator|=
name|arcs_num
expr_stmt|;
if|if
condition|(
operator|!
name|no_minimization_flag
condition|)
block|{
name|ticker_on
argument_list|(
operator|&
name|minimize_time
argument_list|)
expr_stmt|;
if|if
condition|(
name|progress_flag
condition|)
block|{
if|if
condition|(
name|automaton
operator|->
name|corresponding_automaton_decl
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Minimize anonymous DFA..."
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Minimize DFA `%s'..."
argument_list|,
name|automaton
operator|->
name|corresponding_automaton_decl
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|minimize_DFA
argument_list|(
name|automaton
argument_list|)
expr_stmt|;
if|if
condition|(
name|progress_flag
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"done\n"
argument_list|)
expr_stmt|;
name|ticker_off
argument_list|(
operator|&
name|minimize_time
argument_list|)
expr_stmt|;
name|count_states_and_arcs
argument_list|(
name|automaton
argument_list|,
operator|&
name|states_num
argument_list|,
operator|&
name|arcs_num
argument_list|)
expr_stmt|;
name|automaton
operator|->
name|minimal_DFA_states_num
operator|=
name|states_num
expr_stmt|;
name|automaton
operator|->
name|minimal_DFA_arcs_num
operator|=
name|arcs_num
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The page contains code for enumeration  of all states of an automaton.  */
end_comment

begin_comment
comment|/* Variable used for enumeration of all states of an automaton.  Its    value is current number of automaton states.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|curr_state_order_num
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The function is called by function `pass_states' for enumerating    states.  */
end_comment

begin_function
specifier|static
name|void
name|set_order_state_num
parameter_list|(
name|state_t
name|state
parameter_list|)
block|{
name|state
operator|->
name|order_state_num
operator|=
name|curr_state_order_num
expr_stmt|;
name|curr_state_order_num
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function enumerates all states of AUTOMATON.  */
end_comment

begin_function
specifier|static
name|void
name|enumerate_states
parameter_list|(
name|automaton_t
name|automaton
parameter_list|)
block|{
name|curr_state_order_num
operator|=
literal|0
expr_stmt|;
name|pass_states
argument_list|(
name|automaton
argument_list|,
name|set_order_state_num
argument_list|)
expr_stmt|;
name|automaton
operator|->
name|achieved_states_num
operator|=
name|curr_state_order_num
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The page contains code for finding equivalent automaton insns    (ainsns).  */
end_comment

begin_comment
comment|/* The function inserts AINSN into cyclic list    CYCLIC_EQUIV_CLASS_INSN_LIST of ainsns.  */
end_comment

begin_function
specifier|static
name|ainsn_t
name|insert_ainsn_into_equiv_class
parameter_list|(
name|ainsn_t
name|ainsn
parameter_list|,
name|ainsn_t
name|cyclic_equiv_class_insn_list
parameter_list|)
block|{
if|if
condition|(
name|cyclic_equiv_class_insn_list
operator|==
name|NULL
condition|)
name|ainsn
operator|->
name|next_equiv_class_insn
operator|=
name|ainsn
expr_stmt|;
else|else
block|{
name|ainsn
operator|->
name|next_equiv_class_insn
operator|=
name|cyclic_equiv_class_insn_list
operator|->
name|next_equiv_class_insn
expr_stmt|;
name|cyclic_equiv_class_insn_list
operator|->
name|next_equiv_class_insn
operator|=
name|ainsn
expr_stmt|;
block|}
return|return
name|ainsn
return|;
block|}
end_function

begin_comment
comment|/* The function deletes equiv_class_insn into cyclic list of    equivalent ainsns.  */
end_comment

begin_function
specifier|static
name|void
name|delete_ainsn_from_equiv_class
parameter_list|(
name|ainsn_t
name|equiv_class_insn
parameter_list|)
block|{
name|ainsn_t
name|curr_equiv_class_insn
decl_stmt|;
name|ainsn_t
name|prev_equiv_class_insn
decl_stmt|;
name|prev_equiv_class_insn
operator|=
name|equiv_class_insn
expr_stmt|;
for|for
control|(
name|curr_equiv_class_insn
operator|=
name|equiv_class_insn
operator|->
name|next_equiv_class_insn
init|;
name|curr_equiv_class_insn
operator|!=
name|equiv_class_insn
condition|;
name|curr_equiv_class_insn
operator|=
name|curr_equiv_class_insn
operator|->
name|next_equiv_class_insn
control|)
name|prev_equiv_class_insn
operator|=
name|curr_equiv_class_insn
expr_stmt|;
if|if
condition|(
name|prev_equiv_class_insn
operator|!=
name|equiv_class_insn
condition|)
name|prev_equiv_class_insn
operator|->
name|next_equiv_class_insn
operator|=
name|equiv_class_insn
operator|->
name|next_equiv_class_insn
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function processes AINSN of a state in order to find equivalent    ainsns.  INSN_ARCS_ARRAY is table: code of insn -> out arc of the    state.  */
end_comment

begin_function
specifier|static
name|void
name|process_insn_equiv_class
parameter_list|(
name|ainsn_t
name|ainsn
parameter_list|,
name|arc_t
modifier|*
name|insn_arcs_array
parameter_list|)
block|{
name|ainsn_t
name|next_insn
decl_stmt|;
name|ainsn_t
name|curr_insn
decl_stmt|;
name|ainsn_t
name|cyclic_insn_list
decl_stmt|;
name|arc_t
name|arc
decl_stmt|;
name|gcc_assert
argument_list|(
name|insn_arcs_array
index|[
name|ainsn
operator|->
name|insn_reserv_decl
operator|->
name|insn_num
index|]
argument_list|)
expr_stmt|;
name|curr_insn
operator|=
name|ainsn
expr_stmt|;
comment|/* New class of ainsns which are not equivalent to given ainsn.  */
name|cyclic_insn_list
operator|=
name|NULL
expr_stmt|;
do|do
block|{
name|next_insn
operator|=
name|curr_insn
operator|->
name|next_equiv_class_insn
expr_stmt|;
name|arc
operator|=
name|insn_arcs_array
index|[
name|curr_insn
operator|->
name|insn_reserv_decl
operator|->
name|insn_num
index|]
expr_stmt|;
if|if
condition|(
name|arc
operator|==
name|NULL
operator|||
operator|(
name|insn_arcs_array
index|[
name|ainsn
operator|->
name|insn_reserv_decl
operator|->
name|insn_num
index|]
operator|->
name|to_state
operator|!=
name|arc
operator|->
name|to_state
operator|)
condition|)
block|{
name|delete_ainsn_from_equiv_class
argument_list|(
name|curr_insn
argument_list|)
expr_stmt|;
name|cyclic_insn_list
operator|=
name|insert_ainsn_into_equiv_class
argument_list|(
name|curr_insn
argument_list|,
name|cyclic_insn_list
argument_list|)
expr_stmt|;
block|}
name|curr_insn
operator|=
name|next_insn
expr_stmt|;
block|}
do|while
condition|(
name|curr_insn
operator|!=
name|ainsn
condition|)
do|;
block|}
end_function

begin_comment
comment|/* The function processes STATE in order to find equivalent ainsns.  */
end_comment

begin_function
specifier|static
name|void
name|process_state_for_insn_equiv_partition
parameter_list|(
name|state_t
name|state
parameter_list|)
block|{
name|arc_t
name|arc
decl_stmt|;
name|arc_t
modifier|*
name|insn_arcs_array
init|=
name|XCNEWVEC
argument_list|(
name|arc_t
argument_list|,
name|description
operator|->
name|insns_num
argument_list|)
decl_stmt|;
comment|/* Process insns of the arcs.  */
for|for
control|(
name|arc
operator|=
name|first_out_arc
argument_list|(
name|state
argument_list|)
init|;
name|arc
operator|!=
name|NULL
condition|;
name|arc
operator|=
name|next_out_arc
argument_list|(
name|arc
argument_list|)
control|)
name|insn_arcs_array
index|[
name|arc
operator|->
name|insn
operator|->
name|insn_reserv_decl
operator|->
name|insn_num
index|]
operator|=
name|arc
expr_stmt|;
for|for
control|(
name|arc
operator|=
name|first_out_arc
argument_list|(
name|state
argument_list|)
init|;
name|arc
operator|!=
name|NULL
condition|;
name|arc
operator|=
name|next_out_arc
argument_list|(
name|arc
argument_list|)
control|)
name|process_insn_equiv_class
argument_list|(
name|arc
operator|->
name|insn
argument_list|,
name|insn_arcs_array
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|insn_arcs_array
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function searches for equivalent ainsns of AUTOMATON.  */
end_comment

begin_function
specifier|static
name|void
name|set_insn_equiv_classes
parameter_list|(
name|automaton_t
name|automaton
parameter_list|)
block|{
name|ainsn_t
name|ainsn
decl_stmt|;
name|ainsn_t
name|first_insn
decl_stmt|;
name|ainsn_t
name|curr_insn
decl_stmt|;
name|ainsn_t
name|cyclic_insn_list
decl_stmt|;
name|ainsn_t
name|insn_with_same_reservs
decl_stmt|;
name|int
name|equiv_classes_num
decl_stmt|;
comment|/* All insns are included in one equivalence class.  */
name|cyclic_insn_list
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|ainsn
operator|=
name|automaton
operator|->
name|ainsn_list
init|;
name|ainsn
operator|!=
name|NULL
condition|;
name|ainsn
operator|=
name|ainsn
operator|->
name|next_ainsn
control|)
if|if
condition|(
name|ainsn
operator|->
name|first_insn_with_same_reservs
condition|)
name|cyclic_insn_list
operator|=
name|insert_ainsn_into_equiv_class
argument_list|(
name|ainsn
argument_list|,
name|cyclic_insn_list
argument_list|)
expr_stmt|;
comment|/* Process insns in order to make equivalence partition.  */
name|pass_states
argument_list|(
name|automaton
argument_list|,
name|process_state_for_insn_equiv_partition
argument_list|)
expr_stmt|;
comment|/* Enumerate equiv classes.  */
for|for
control|(
name|ainsn
operator|=
name|automaton
operator|->
name|ainsn_list
init|;
name|ainsn
operator|!=
name|NULL
condition|;
name|ainsn
operator|=
name|ainsn
operator|->
name|next_ainsn
control|)
comment|/* Set undefined value.  */
name|ainsn
operator|->
name|insn_equiv_class_num
operator|=
operator|-
literal|1
expr_stmt|;
name|equiv_classes_num
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ainsn
operator|=
name|automaton
operator|->
name|ainsn_list
init|;
name|ainsn
operator|!=
name|NULL
condition|;
name|ainsn
operator|=
name|ainsn
operator|->
name|next_ainsn
control|)
if|if
condition|(
name|ainsn
operator|->
name|insn_equiv_class_num
operator|<
literal|0
condition|)
block|{
name|first_insn
operator|=
name|ainsn
expr_stmt|;
name|gcc_assert
argument_list|(
name|first_insn
operator|->
name|first_insn_with_same_reservs
argument_list|)
expr_stmt|;
name|first_insn
operator|->
name|first_ainsn_with_given_equivalence_num
operator|=
literal|1
expr_stmt|;
name|curr_insn
operator|=
name|first_insn
expr_stmt|;
do|do
block|{
for|for
control|(
name|insn_with_same_reservs
operator|=
name|curr_insn
init|;
name|insn_with_same_reservs
operator|!=
name|NULL
condition|;
name|insn_with_same_reservs
operator|=
name|insn_with_same_reservs
operator|->
name|next_same_reservs_insn
control|)
name|insn_with_same_reservs
operator|->
name|insn_equiv_class_num
operator|=
name|equiv_classes_num
expr_stmt|;
name|curr_insn
operator|=
name|curr_insn
operator|->
name|next_equiv_class_insn
expr_stmt|;
block|}
do|while
condition|(
name|curr_insn
operator|!=
name|first_insn
condition|)
do|;
name|equiv_classes_num
operator|++
expr_stmt|;
block|}
name|automaton
operator|->
name|insn_equiv_classes_num
operator|=
name|equiv_classes_num
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This page contains code for creating DFA(s) and calls functions    building them.  */
end_comment

begin_comment
comment|/* The following value is used to prevent floating point overflow for    estimating an automaton bound.  The value should be less DBL_MAX on    the host machine.  We use here approximate minimum of maximal    double floating point value required by ANSI C standard.  It    will work for non ANSI sun compiler too.  */
end_comment

begin_define
define|#
directive|define
name|MAX_FLOATING_POINT_VALUE_FOR_AUTOMATON_BOUND
value|1.0E37
end_define

begin_comment
comment|/* The function estimate size of the single DFA used by PHR (pipeline    hazards recognizer).  */
end_comment

begin_function
specifier|static
name|double
name|estimate_one_automaton_bound
parameter_list|(
name|void
parameter_list|)
block|{
name|decl_t
name|decl
decl_stmt|;
name|double
name|one_automaton_estimation_bound
decl_stmt|;
name|double
name|root_value
decl_stmt|;
name|int
name|i
decl_stmt|;
name|one_automaton_estimation_bound
operator|=
literal|1.0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_unit
condition|)
block|{
name|root_value
operator|=
name|exp
argument_list|(
name|log
argument_list|(
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|max_occ_cycle_num
operator|-
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|min_occ_cycle_num
operator|+
literal|1.0
argument_list|)
operator|/
name|automata_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|MAX_FLOATING_POINT_VALUE_FOR_AUTOMATON_BOUND
operator|/
name|root_value
operator|>
name|one_automaton_estimation_bound
condition|)
name|one_automaton_estimation_bound
operator|*=
name|root_value
expr_stmt|;
block|}
block|}
return|return
name|one_automaton_estimation_bound
return|;
block|}
end_function

begin_comment
comment|/* The function compares unit declarations according to their maximal    cycle in reservations.  */
end_comment

begin_function
specifier|static
name|int
name|compare_max_occ_cycle_nums
parameter_list|(
specifier|const
name|void
modifier|*
name|unit_decl_1
parameter_list|,
specifier|const
name|void
modifier|*
name|unit_decl_2
parameter_list|)
block|{
if|if
condition|(
operator|(
name|DECL_UNIT
argument_list|(
operator|*
operator|(
name|decl_t
operator|*
operator|)
name|unit_decl_1
argument_list|)
operator|->
name|max_occ_cycle_num
operator|)
operator|<
operator|(
name|DECL_UNIT
argument_list|(
operator|*
operator|(
name|decl_t
operator|*
operator|)
name|unit_decl_2
argument_list|)
operator|->
name|max_occ_cycle_num
operator|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
operator|(
name|DECL_UNIT
argument_list|(
operator|*
operator|(
name|decl_t
operator|*
operator|)
name|unit_decl_1
argument_list|)
operator|->
name|max_occ_cycle_num
operator|)
operator|==
operator|(
name|DECL_UNIT
argument_list|(
operator|*
operator|(
name|decl_t
operator|*
operator|)
name|unit_decl_2
argument_list|)
operator|->
name|max_occ_cycle_num
operator|)
condition|)
return|return
literal|0
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* The function makes heuristic assigning automata to units.  Actually    efficacy of the algorithm has been checked yet??? */
end_comment

begin_function
specifier|static
name|void
name|units_to_automata_heuristic_distr
parameter_list|(
name|void
parameter_list|)
block|{
name|double
name|estimation_bound
decl_stmt|;
name|int
name|automaton_num
decl_stmt|;
name|int
name|rest_units_num
decl_stmt|;
name|double
name|bound_value
decl_stmt|;
name|unit_decl_t
modifier|*
name|unit_decls
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|description
operator|->
name|units_num
operator|==
literal|0
condition|)
return|return;
name|estimation_bound
operator|=
name|estimate_one_automaton_bound
argument_list|()
expr_stmt|;
name|unit_decls
operator|=
name|XNEWVEC
argument_list|(
name|unit_decl_t
argument_list|,
name|description
operator|->
name|units_num
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|description
operator|->
name|decls
index|[
name|i
index|]
operator|->
name|mode
operator|==
name|dm_unit
condition|)
name|unit_decls
index|[
name|j
operator|++
index|]
operator|=
name|DECL_UNIT
argument_list|(
name|description
operator|->
name|decls
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|j
operator|==
name|description
operator|->
name|units_num
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|unit_decls
argument_list|,
name|description
operator|->
name|units_num
argument_list|,
sizeof|sizeof
argument_list|(
name|unit_decl_t
argument_list|)
argument_list|,
name|compare_max_occ_cycle_nums
argument_list|)
expr_stmt|;
name|automaton_num
operator|=
literal|0
expr_stmt|;
name|bound_value
operator|=
name|unit_decls
index|[
literal|0
index|]
operator|->
name|max_occ_cycle_num
expr_stmt|;
name|unit_decls
index|[
literal|0
index|]
operator|->
name|corresponding_automaton_num
operator|=
name|automaton_num
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|description
operator|->
name|units_num
condition|;
name|i
operator|++
control|)
block|{
name|rest_units_num
operator|=
name|description
operator|->
name|units_num
operator|-
name|i
operator|+
literal|1
expr_stmt|;
name|gcc_assert
argument_list|(
name|automata_num
operator|-
name|automaton_num
operator|-
literal|1
operator|<=
name|rest_units_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|automaton_num
operator|<
name|automata_num
operator|-
literal|1
operator|&&
operator|(
operator|(
name|automata_num
operator|-
name|automaton_num
operator|-
literal|1
operator|==
name|rest_units_num
operator|)
operator|||
operator|(
name|bound_value
operator|>
operator|(
name|estimation_bound
operator|/
name|unit_decls
index|[
name|i
index|]
operator|->
name|max_occ_cycle_num
operator|)
operator|)
operator|)
condition|)
block|{
name|bound_value
operator|=
name|unit_decls
index|[
name|i
index|]
operator|->
name|max_occ_cycle_num
expr_stmt|;
name|automaton_num
operator|++
expr_stmt|;
block|}
else|else
name|bound_value
operator|*=
name|unit_decls
index|[
name|i
index|]
operator|->
name|max_occ_cycle_num
expr_stmt|;
name|unit_decls
index|[
name|i
index|]
operator|->
name|corresponding_automaton_num
operator|=
name|automaton_num
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|automaton_num
operator|==
name|automata_num
operator|-
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|unit_decls
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The functions creates automaton insns for each automata.  Automaton    insn is simply insn for given automaton which makes reservation    only of units of the automaton.  */
end_comment

begin_function
specifier|static
name|ainsn_t
name|create_ainsns
parameter_list|(
name|void
parameter_list|)
block|{
name|decl_t
name|decl
decl_stmt|;
name|ainsn_t
name|first_ainsn
decl_stmt|;
name|ainsn_t
name|curr_ainsn
decl_stmt|;
name|ainsn_t
name|prev_ainsn
decl_stmt|;
name|int
name|i
decl_stmt|;
name|first_ainsn
operator|=
name|NULL
expr_stmt|;
name|prev_ainsn
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_insn_reserv
condition|)
block|{
name|curr_ainsn
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ainsn
argument_list|)
argument_list|)
expr_stmt|;
name|curr_ainsn
operator|->
name|insn_reserv_decl
operator|=
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|curr_ainsn
operator|->
name|important_p
operator|=
name|FALSE
expr_stmt|;
name|curr_ainsn
operator|->
name|next_ainsn
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|prev_ainsn
operator|==
name|NULL
condition|)
name|first_ainsn
operator|=
name|curr_ainsn
expr_stmt|;
else|else
name|prev_ainsn
operator|->
name|next_ainsn
operator|=
name|curr_ainsn
expr_stmt|;
name|prev_ainsn
operator|=
name|curr_ainsn
expr_stmt|;
block|}
block|}
return|return
name|first_ainsn
return|;
block|}
end_function

begin_comment
comment|/* The function assigns automata to units according to constructions    `define_automaton' in the description.  */
end_comment

begin_function
specifier|static
name|void
name|units_to_automata_distr
parameter_list|(
name|void
parameter_list|)
block|{
name|decl_t
name|decl
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_unit
condition|)
block|{
if|if
condition|(
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|automaton_decl
operator|==
name|NULL
operator|||
operator|(
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|automaton_decl
operator|->
name|corresponding_automaton
operator|==
name|NULL
operator|)
condition|)
comment|/* Distribute to the first automaton.  */
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|corresponding_automaton_num
operator|=
literal|0
expr_stmt|;
else|else
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|corresponding_automaton_num
operator|=
operator|(
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|automaton_decl
operator|->
name|corresponding_automaton
operator|->
name|automaton_order_num
operator|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* The function creates DFA(s) for fast pipeline hazards recognition    after checking and simplifying IR of the description.  */
end_comment

begin_function
specifier|static
name|void
name|create_automata
parameter_list|(
name|void
parameter_list|)
block|{
name|automaton_t
name|curr_automaton
decl_stmt|;
name|automaton_t
name|prev_automaton
decl_stmt|;
name|decl_t
name|decl
decl_stmt|;
name|int
name|curr_automaton_num
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|automata_num
operator|!=
literal|0
condition|)
block|{
name|units_to_automata_heuristic_distr
argument_list|()
expr_stmt|;
for|for
control|(
name|prev_automaton
operator|=
name|NULL
operator|,
name|curr_automaton_num
operator|=
literal|0
init|;
name|curr_automaton_num
operator|<
name|automata_num
condition|;
name|curr_automaton_num
operator|++
operator|,
name|prev_automaton
operator|=
name|curr_automaton
control|)
block|{
name|curr_automaton
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|automaton
argument_list|)
argument_list|)
expr_stmt|;
name|curr_automaton
operator|->
name|ainsn_list
operator|=
name|create_ainsns
argument_list|()
expr_stmt|;
name|curr_automaton
operator|->
name|corresponding_automaton_decl
operator|=
name|NULL
expr_stmt|;
name|curr_automaton
operator|->
name|next_automaton
operator|=
name|NULL
expr_stmt|;
name|curr_automaton
operator|->
name|automaton_order_num
operator|=
name|curr_automaton_num
expr_stmt|;
if|if
condition|(
name|prev_automaton
operator|==
name|NULL
condition|)
name|description
operator|->
name|first_automaton
operator|=
name|curr_automaton
expr_stmt|;
else|else
name|prev_automaton
operator|->
name|next_automaton
operator|=
name|curr_automaton
expr_stmt|;
block|}
block|}
else|else
block|{
name|curr_automaton_num
operator|=
literal|0
expr_stmt|;
name|prev_automaton
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_automaton
operator|&&
name|DECL_AUTOMATON
argument_list|(
name|decl
argument_list|)
operator|->
name|automaton_is_used
condition|)
block|{
name|curr_automaton
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|automaton
argument_list|)
argument_list|)
expr_stmt|;
name|curr_automaton
operator|->
name|ainsn_list
operator|=
name|create_ainsns
argument_list|()
expr_stmt|;
name|curr_automaton
operator|->
name|corresponding_automaton_decl
operator|=
name|DECL_AUTOMATON
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|curr_automaton
operator|->
name|next_automaton
operator|=
name|NULL
expr_stmt|;
name|DECL_AUTOMATON
argument_list|(
name|decl
argument_list|)
operator|->
name|corresponding_automaton
operator|=
name|curr_automaton
expr_stmt|;
name|curr_automaton
operator|->
name|automaton_order_num
operator|=
name|curr_automaton_num
expr_stmt|;
if|if
condition|(
name|prev_automaton
operator|==
name|NULL
condition|)
name|description
operator|->
name|first_automaton
operator|=
name|curr_automaton
expr_stmt|;
else|else
name|prev_automaton
operator|->
name|next_automaton
operator|=
name|curr_automaton
expr_stmt|;
name|curr_automaton_num
operator|++
expr_stmt|;
name|prev_automaton
operator|=
name|curr_automaton
expr_stmt|;
block|}
block|}
if|if
condition|(
name|curr_automaton_num
operator|==
literal|0
condition|)
block|{
name|curr_automaton
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|automaton
argument_list|)
argument_list|)
expr_stmt|;
name|curr_automaton
operator|->
name|ainsn_list
operator|=
name|create_ainsns
argument_list|()
expr_stmt|;
name|curr_automaton
operator|->
name|corresponding_automaton_decl
operator|=
name|NULL
expr_stmt|;
name|curr_automaton
operator|->
name|next_automaton
operator|=
name|NULL
expr_stmt|;
name|description
operator|->
name|first_automaton
operator|=
name|curr_automaton
expr_stmt|;
block|}
name|units_to_automata_distr
argument_list|()
expr_stmt|;
block|}
name|NDFA_time
operator|=
name|create_ticker
argument_list|()
expr_stmt|;
name|ticker_off
argument_list|(
operator|&
name|NDFA_time
argument_list|)
expr_stmt|;
name|NDFA_to_DFA_time
operator|=
name|create_ticker
argument_list|()
expr_stmt|;
name|ticker_off
argument_list|(
operator|&
name|NDFA_to_DFA_time
argument_list|)
expr_stmt|;
name|minimize_time
operator|=
name|create_ticker
argument_list|()
expr_stmt|;
name|ticker_off
argument_list|(
operator|&
name|minimize_time
argument_list|)
expr_stmt|;
name|equiv_time
operator|=
name|create_ticker
argument_list|()
expr_stmt|;
name|ticker_off
argument_list|(
operator|&
name|equiv_time
argument_list|)
expr_stmt|;
for|for
control|(
name|curr_automaton
operator|=
name|description
operator|->
name|first_automaton
init|;
name|curr_automaton
operator|!=
name|NULL
condition|;
name|curr_automaton
operator|=
name|curr_automaton
operator|->
name|next_automaton
control|)
block|{
if|if
condition|(
name|progress_flag
condition|)
block|{
if|if
condition|(
name|curr_automaton
operator|->
name|corresponding_automaton_decl
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Prepare anonymous automaton creation ... "
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Prepare automaton `%s' creation..."
argument_list|,
name|curr_automaton
operator|->
name|corresponding_automaton_decl
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|create_alt_states
argument_list|(
name|curr_automaton
argument_list|)
expr_stmt|;
name|form_ainsn_with_same_reservs
argument_list|(
name|curr_automaton
argument_list|)
expr_stmt|;
if|if
condition|(
name|progress_flag
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"done\n"
argument_list|)
expr_stmt|;
name|build_automaton
argument_list|(
name|curr_automaton
argument_list|)
expr_stmt|;
name|enumerate_states
argument_list|(
name|curr_automaton
argument_list|)
expr_stmt|;
name|ticker_on
argument_list|(
operator|&
name|equiv_time
argument_list|)
expr_stmt|;
name|set_insn_equiv_classes
argument_list|(
name|curr_automaton
argument_list|)
expr_stmt|;
name|ticker_off
argument_list|(
operator|&
name|equiv_time
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This page contains code for forming string representation of    regexp.  The representation is formed on IR obstack.  So you should    not work with IR obstack between regexp_representation and    finish_regexp_representation calls.  */
end_comment

begin_comment
comment|/* This recursive function forms string representation of regexp    (without tailing '\0').  */
end_comment

begin_function
specifier|static
name|void
name|form_regexp
parameter_list|(
name|regexp_t
name|regexp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|regexp
operator|->
name|mode
condition|)
block|{
case|case
name|rm_unit
case|:
case|case
name|rm_reserv
case|:
block|{
specifier|const
name|char
modifier|*
name|name
init|=
operator|(
name|regexp
operator|->
name|mode
operator|==
name|rm_unit
condition|?
name|REGEXP_UNIT
argument_list|(
name|regexp
argument_list|)
operator|->
name|name
else|:
name|REGEXP_RESERV
argument_list|(
name|regexp
argument_list|)
operator|->
name|name
operator|)
decl_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|irp
argument_list|,
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|rm_sequence
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|obstack_1grow
argument_list|(
operator|&
name|irp
argument_list|,
literal|','
argument_list|)
expr_stmt|;
name|form_regexp
argument_list|(
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|rm_allof
case|:
name|obstack_1grow
argument_list|(
operator|&
name|irp
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|obstack_1grow
argument_list|(
operator|&
name|irp
argument_list|,
literal|'+'
argument_list|)
expr_stmt|;
if|if
condition|(
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
operator|->
name|mode
operator|==
name|rm_sequence
operator|||
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
operator|->
name|mode
operator|==
name|rm_oneof
condition|)
name|obstack_1grow
argument_list|(
operator|&
name|irp
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
name|form_regexp
argument_list|(
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
operator|->
name|mode
operator|==
name|rm_sequence
operator|||
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
operator|->
name|mode
operator|==
name|rm_oneof
condition|)
name|obstack_1grow
argument_list|(
operator|&
name|irp
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
block|}
name|obstack_1grow
argument_list|(
operator|&
name|irp
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
break|break;
case|case
name|rm_oneof
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|obstack_1grow
argument_list|(
operator|&
name|irp
argument_list|,
literal|'|'
argument_list|)
expr_stmt|;
if|if
condition|(
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
operator|->
name|mode
operator|==
name|rm_sequence
condition|)
name|obstack_1grow
argument_list|(
operator|&
name|irp
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
name|form_regexp
argument_list|(
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
operator|->
name|mode
operator|==
name|rm_sequence
condition|)
name|obstack_1grow
argument_list|(
operator|&
name|irp
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|rm_repeat
case|:
block|{
name|char
name|digits
index|[
literal|30
index|]
decl_stmt|;
if|if
condition|(
name|REGEXP_REPEAT
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexp
operator|->
name|mode
operator|==
name|rm_sequence
operator|||
name|REGEXP_REPEAT
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexp
operator|->
name|mode
operator|==
name|rm_allof
operator|||
name|REGEXP_REPEAT
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexp
operator|->
name|mode
operator|==
name|rm_oneof
condition|)
name|obstack_1grow
argument_list|(
operator|&
name|irp
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
name|form_regexp
argument_list|(
name|REGEXP_REPEAT
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|REGEXP_REPEAT
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexp
operator|->
name|mode
operator|==
name|rm_sequence
operator|||
name|REGEXP_REPEAT
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexp
operator|->
name|mode
operator|==
name|rm_allof
operator|||
name|REGEXP_REPEAT
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexp
operator|->
name|mode
operator|==
name|rm_oneof
condition|)
name|obstack_1grow
argument_list|(
operator|&
name|irp
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|digits
argument_list|,
literal|"*%d"
argument_list|,
name|REGEXP_REPEAT
argument_list|(
name|regexp
argument_list|)
operator|->
name|repeat_num
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|irp
argument_list|,
name|digits
argument_list|,
name|strlen
argument_list|(
name|digits
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|rm_nothing
case|:
name|obstack_grow
argument_list|(
operator|&
name|irp
argument_list|,
name|NOTHING_NAME
argument_list|,
name|strlen
argument_list|(
name|NOTHING_NAME
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The function returns string representation of REGEXP on IR    obstack.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|regexp_representation
parameter_list|(
name|regexp_t
name|regexp
parameter_list|)
block|{
name|form_regexp
argument_list|(
name|regexp
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|irp
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
return|return
name|obstack_base
argument_list|(
operator|&
name|irp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The function frees memory allocated for last formed string    representation of regexp.  */
end_comment

begin_function
specifier|static
name|void
name|finish_regexp_representation
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|length
init|=
name|obstack_object_size
argument_list|(
operator|&
name|irp
argument_list|)
decl_stmt|;
name|obstack_blank_fast
argument_list|(
operator|&
name|irp
argument_list|,
operator|-
name|length
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This page contains code for output PHR (pipeline hazards recognizer).  */
end_comment

begin_comment
comment|/* The function outputs minimal C type which is sufficient for    representation numbers in range min_range_value and    max_range_value.  Because host machine and build machine may be    different, we use here minimal values required by ANSI C standard    instead of UCHAR_MAX, SHRT_MAX, SHRT_MIN, etc.  This is a good    approximation.  */
end_comment

begin_function
specifier|static
name|void
name|output_range_type
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|long
name|int
name|min_range_value
parameter_list|,
name|long
name|int
name|max_range_value
parameter_list|)
block|{
if|if
condition|(
name|min_range_value
operator|>=
literal|0
operator|&&
name|max_range_value
operator|<=
literal|255
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"unsigned char"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|min_range_value
operator|>=
operator|-
literal|127
operator|&&
name|max_range_value
operator|<=
literal|127
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"signed char"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|min_range_value
operator|>=
literal|0
operator|&&
name|max_range_value
operator|<=
literal|65535
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"unsigned short"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|min_range_value
operator|>=
operator|-
literal|32767
operator|&&
name|max_range_value
operator|<=
literal|32767
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"short"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"int"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The following macro value is used as value of member    `longest_path_length' of state when we are processing path and the    state on the path.  */
end_comment

begin_define
define|#
directive|define
name|ON_THE_PATH
value|-2
end_define

begin_comment
comment|/* The following recursive function searches for the length of the    longest path starting from STATE which does not contain cycles and    `cycle advance' arcs.  */
end_comment

begin_function
specifier|static
name|int
name|longest_path_length
parameter_list|(
name|state_t
name|state
parameter_list|)
block|{
name|arc_t
name|arc
decl_stmt|;
name|int
name|length
decl_stmt|,
name|result
decl_stmt|;
if|if
condition|(
name|state
operator|->
name|longest_path_length
operator|!=
name|UNDEFINED_LONGEST_PATH_LENGTH
condition|)
block|{
comment|/* We don't expect the path cycle here.  Our graph may contain       	 only cycles with one state on the path not containing `cycle       	 advance' arcs -- see comment below.  */
name|gcc_assert
argument_list|(
name|state
operator|->
name|longest_path_length
operator|!=
name|ON_THE_PATH
argument_list|)
expr_stmt|;
comment|/* We already visited the state.  */
return|return
name|state
operator|->
name|longest_path_length
return|;
block|}
name|result
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|arc
operator|=
name|first_out_arc
argument_list|(
name|state
argument_list|)
init|;
name|arc
operator|!=
name|NULL
condition|;
name|arc
operator|=
name|next_out_arc
argument_list|(
name|arc
argument_list|)
control|)
comment|/* Ignore cycles containing one state and `cycle advance' arcs.  */
if|if
condition|(
name|arc
operator|->
name|to_state
operator|!=
name|state
operator|&&
operator|(
name|arc
operator|->
name|insn
operator|->
name|insn_reserv_decl
operator|!=
name|DECL_INSN_RESERV
argument_list|(
name|advance_cycle_insn_decl
argument_list|)
operator|)
condition|)
block|{
name|length
operator|=
name|longest_path_length
argument_list|(
name|arc
operator|->
name|to_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|>
name|result
condition|)
name|result
operator|=
name|length
expr_stmt|;
block|}
name|state
operator|->
name|longest_path_length
operator|=
name|result
operator|+
literal|1
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* The function outputs all initialization values of VECT.  */
end_comment

begin_function
specifier|static
name|void
name|output_vect
parameter_list|(
name|vla_hwint_t
name|vect
parameter_list|)
block|{
name|int
name|els_on_line
decl_stmt|;
name|size_t
name|vect_length
init|=
name|VEC_length
argument_list|(
name|vect_el_t
argument_list|,
name|vect
argument_list|)
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|els_on_line
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|vect_length
operator|==
literal|0
condition|)
name|fputs
argument_list|(
literal|"0 /* This is dummy el because the vect is empty */"
argument_list|,
name|output_file
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vect_length
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"%5ld"
argument_list|,
operator|(
name|long
operator|)
name|VEC_index
argument_list|(
name|vect_el_t
argument_list|,
name|vect
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|els_on_line
operator|==
literal|10
condition|)
block|{
name|els_on_line
operator|=
literal|0
expr_stmt|;
name|fputs
argument_list|(
literal|",\n"
argument_list|,
name|output_file
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|<
name|vect_length
operator|-
literal|1
condition|)
name|fputs
argument_list|(
literal|", "
argument_list|,
name|output_file
argument_list|)
expr_stmt|;
name|els_on_line
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The following is name of the structure which represents DFA(s) for    PHR.  */
end_comment

begin_define
define|#
directive|define
name|CHIP_NAME
value|"DFA_chip"
end_define

begin_comment
comment|/* The following is name of member which represents state of a DFA for    PHR.  */
end_comment

begin_function
specifier|static
name|void
name|output_chip_member_name
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|automaton_t
name|automaton
parameter_list|)
block|{
if|if
condition|(
name|automaton
operator|->
name|corresponding_automaton_decl
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"automaton_state_%d"
argument_list|,
name|automaton
operator|->
name|automaton_order_num
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s_automaton_state"
argument_list|,
name|automaton
operator|->
name|corresponding_automaton_decl
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The following is name of temporary variable which stores state of a    DFA for PHR.  */
end_comment

begin_function
specifier|static
name|void
name|output_temp_chip_member_name
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|automaton_t
name|automaton
parameter_list|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"_"
argument_list|)
expr_stmt|;
name|output_chip_member_name
argument_list|(
name|f
argument_list|,
name|automaton
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is name of macro value which is code of pseudo_insn    representing advancing cpu cycle.  Its value is used as internal    code unknown insn.  */
end_comment

begin_define
define|#
directive|define
name|ADVANCE_CYCLE_VALUE_NAME
value|"DFA__ADVANCE_CYCLE"
end_define

begin_comment
comment|/* Output name of translate vector for given automaton.  */
end_comment

begin_function
specifier|static
name|void
name|output_translate_vect_name
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|automaton_t
name|automaton
parameter_list|)
block|{
if|if
condition|(
name|automaton
operator|->
name|corresponding_automaton_decl
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"translate_%d"
argument_list|,
name|automaton
operator|->
name|automaton_order_num
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s_translate"
argument_list|,
name|automaton
operator|->
name|corresponding_automaton_decl
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output name for simple transition table representation.  */
end_comment

begin_function
specifier|static
name|void
name|output_trans_full_vect_name
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|automaton_t
name|automaton
parameter_list|)
block|{
if|if
condition|(
name|automaton
operator|->
name|corresponding_automaton_decl
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"transitions_%d"
argument_list|,
name|automaton
operator|->
name|automaton_order_num
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s_transitions"
argument_list|,
name|automaton
operator|->
name|corresponding_automaton_decl
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output name of comb vector of the transition table for given    automaton.  */
end_comment

begin_function
specifier|static
name|void
name|output_trans_comb_vect_name
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|automaton_t
name|automaton
parameter_list|)
block|{
if|if
condition|(
name|automaton
operator|->
name|corresponding_automaton_decl
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"transitions_%d"
argument_list|,
name|automaton
operator|->
name|automaton_order_num
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s_transitions"
argument_list|,
name|automaton
operator|->
name|corresponding_automaton_decl
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output name of check vector of the transition table for given    automaton.  */
end_comment

begin_function
specifier|static
name|void
name|output_trans_check_vect_name
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|automaton_t
name|automaton
parameter_list|)
block|{
if|if
condition|(
name|automaton
operator|->
name|corresponding_automaton_decl
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"check_%d"
argument_list|,
name|automaton
operator|->
name|automaton_order_num
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s_check"
argument_list|,
name|automaton
operator|->
name|corresponding_automaton_decl
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output name of base vector of the transition table for given    automaton.  */
end_comment

begin_function
specifier|static
name|void
name|output_trans_base_vect_name
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|automaton_t
name|automaton
parameter_list|)
block|{
if|if
condition|(
name|automaton
operator|->
name|corresponding_automaton_decl
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"base_%d"
argument_list|,
name|automaton
operator|->
name|automaton_order_num
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s_base"
argument_list|,
name|automaton
operator|->
name|corresponding_automaton_decl
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output name of simple min issue delay table representation.  */
end_comment

begin_function
specifier|static
name|void
name|output_min_issue_delay_vect_name
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|automaton_t
name|automaton
parameter_list|)
block|{
if|if
condition|(
name|automaton
operator|->
name|corresponding_automaton_decl
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"min_issue_delay_%d"
argument_list|,
name|automaton
operator|->
name|automaton_order_num
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s_min_issue_delay"
argument_list|,
name|automaton
operator|->
name|corresponding_automaton_decl
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output name of deadlock vector for given automaton.  */
end_comment

begin_function
specifier|static
name|void
name|output_dead_lock_vect_name
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|automaton_t
name|automaton
parameter_list|)
block|{
if|if
condition|(
name|automaton
operator|->
name|corresponding_automaton_decl
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"dead_lock_%d"
argument_list|,
name|automaton
operator|->
name|automaton_order_num
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s_dead_lock"
argument_list|,
name|automaton
operator|->
name|corresponding_automaton_decl
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output name of reserved units table for AUTOMATON into file F.  */
end_comment

begin_function
specifier|static
name|void
name|output_reserved_units_table_name
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|automaton_t
name|automaton
parameter_list|)
block|{
if|if
condition|(
name|automaton
operator|->
name|corresponding_automaton_decl
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"reserved_units_%d"
argument_list|,
name|automaton
operator|->
name|automaton_order_num
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s_reserved_units"
argument_list|,
name|automaton
operator|->
name|corresponding_automaton_decl
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Name of the PHR interface macro.  */
end_comment

begin_define
define|#
directive|define
name|CPU_UNITS_QUERY_MACRO_NAME
value|"CPU_UNITS_QUERY"
end_define

begin_comment
comment|/* Names of an internal functions: */
end_comment

begin_define
define|#
directive|define
name|INTERNAL_MIN_ISSUE_DELAY_FUNC_NAME
value|"internal_min_issue_delay"
end_define

begin_comment
comment|/* This is external type of DFA(s) state.  */
end_comment

begin_define
define|#
directive|define
name|STATE_TYPE_NAME
value|"state_t"
end_define

begin_define
define|#
directive|define
name|INTERNAL_TRANSITION_FUNC_NAME
value|"internal_state_transition"
end_define

begin_define
define|#
directive|define
name|INTERNAL_RESET_FUNC_NAME
value|"internal_reset"
end_define

begin_define
define|#
directive|define
name|INTERNAL_DEAD_LOCK_FUNC_NAME
value|"internal_state_dead_lock_p"
end_define

begin_define
define|#
directive|define
name|INTERNAL_INSN_LATENCY_FUNC_NAME
value|"internal_insn_latency"
end_define

begin_comment
comment|/* Name of cache of insn dfa codes.  */
end_comment

begin_define
define|#
directive|define
name|DFA_INSN_CODES_VARIABLE_NAME
value|"dfa_insn_codes"
end_define

begin_comment
comment|/* Name of length of cache of insn dfa codes.  */
end_comment

begin_define
define|#
directive|define
name|DFA_INSN_CODES_LENGTH_VARIABLE_NAME
value|"dfa_insn_codes_length"
end_define

begin_comment
comment|/* Names of the PHR interface functions: */
end_comment

begin_define
define|#
directive|define
name|SIZE_FUNC_NAME
value|"state_size"
end_define

begin_define
define|#
directive|define
name|TRANSITION_FUNC_NAME
value|"state_transition"
end_define

begin_define
define|#
directive|define
name|MIN_ISSUE_DELAY_FUNC_NAME
value|"min_issue_delay"
end_define

begin_define
define|#
directive|define
name|MIN_INSN_CONFLICT_DELAY_FUNC_NAME
value|"min_insn_conflict_delay"
end_define

begin_define
define|#
directive|define
name|DEAD_LOCK_FUNC_NAME
value|"state_dead_lock_p"
end_define

begin_define
define|#
directive|define
name|RESET_FUNC_NAME
value|"state_reset"
end_define

begin_define
define|#
directive|define
name|INSN_LATENCY_FUNC_NAME
value|"insn_latency"
end_define

begin_define
define|#
directive|define
name|PRINT_RESERVATION_FUNC_NAME
value|"print_reservation"
end_define

begin_define
define|#
directive|define
name|GET_CPU_UNIT_CODE_FUNC_NAME
value|"get_cpu_unit_code"
end_define

begin_define
define|#
directive|define
name|CPU_UNIT_RESERVATION_P_FUNC_NAME
value|"cpu_unit_reservation_p"
end_define

begin_define
define|#
directive|define
name|DFA_CLEAN_INSN_CACHE_FUNC_NAME
value|"dfa_clean_insn_cache"
end_define

begin_define
define|#
directive|define
name|DFA_CLEAR_SINGLE_INSN_CACHE_FUNC_NAME
value|"dfa_clear_single_insn_cache"
end_define

begin_define
define|#
directive|define
name|DFA_START_FUNC_NAME
value|"dfa_start"
end_define

begin_define
define|#
directive|define
name|DFA_FINISH_FUNC_NAME
value|"dfa_finish"
end_define

begin_comment
comment|/* Names of parameters of the PHR interface functions.  */
end_comment

begin_define
define|#
directive|define
name|STATE_NAME
value|"state"
end_define

begin_define
define|#
directive|define
name|INSN_PARAMETER_NAME
value|"insn"
end_define

begin_define
define|#
directive|define
name|INSN2_PARAMETER_NAME
value|"insn2"
end_define

begin_define
define|#
directive|define
name|CHIP_PARAMETER_NAME
value|"chip"
end_define

begin_define
define|#
directive|define
name|FILE_PARAMETER_NAME
value|"f"
end_define

begin_define
define|#
directive|define
name|CPU_UNIT_NAME_PARAMETER_NAME
value|"cpu_unit_name"
end_define

begin_define
define|#
directive|define
name|CPU_CODE_PARAMETER_NAME
value|"cpu_unit_code"
end_define

begin_comment
comment|/* Names of the variables whose values are internal insn code of rtx    insn.  */
end_comment

begin_define
define|#
directive|define
name|INTERNAL_INSN_CODE_NAME
value|"insn_code"
end_define

begin_define
define|#
directive|define
name|INTERNAL_INSN2_CODE_NAME
value|"insn2_code"
end_define

begin_comment
comment|/* Names of temporary variables in some functions.  */
end_comment

begin_define
define|#
directive|define
name|TEMPORARY_VARIABLE_NAME
value|"temp"
end_define

begin_define
define|#
directive|define
name|I_VARIABLE_NAME
value|"i"
end_define

begin_comment
comment|/* Name of result variable in some functions.  */
end_comment

begin_define
define|#
directive|define
name|RESULT_VARIABLE_NAME
value|"res"
end_define

begin_comment
comment|/* Name of function (attribute) to translate insn into internal insn    code.  */
end_comment

begin_define
define|#
directive|define
name|INTERNAL_DFA_INSN_CODE_FUNC_NAME
value|"internal_dfa_insn_code"
end_define

begin_comment
comment|/* Name of function (attribute) to translate insn into internal insn    code with caching.  */
end_comment

begin_define
define|#
directive|define
name|DFA_INSN_CODE_FUNC_NAME
value|"dfa_insn_code"
end_define

begin_comment
comment|/* Output C type which is used for representation of codes of states    of AUTOMATON.  */
end_comment

begin_function
specifier|static
name|void
name|output_state_member_type
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|automaton_t
name|automaton
parameter_list|)
block|{
name|output_range_type
argument_list|(
name|f
argument_list|,
literal|0
argument_list|,
name|automaton
operator|->
name|achieved_states_num
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output definition of the structure representing current DFA(s)    state(s).  */
end_comment

begin_function
specifier|static
name|void
name|output_chip_definitions
parameter_list|(
name|void
parameter_list|)
block|{
name|automaton_t
name|automaton
decl_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"struct %s\n{\n"
argument_list|,
name|CHIP_NAME
argument_list|)
expr_stmt|;
for|for
control|(
name|automaton
operator|=
name|description
operator|->
name|first_automaton
init|;
name|automaton
operator|!=
name|NULL
condition|;
name|automaton
operator|=
name|automaton
operator|->
name|next_automaton
control|)
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"  "
argument_list|)
expr_stmt|;
name|output_state_member_type
argument_list|(
name|output_file
argument_list|,
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|output_chip_member_name
argument_list|(
name|output_file
argument_list|,
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|";\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"};\n\n"
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|fprintf (output_file, "static struct %s %s;\n\n", CHIP_NAME, CHIP_NAME);
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* The function outputs translate vector of internal insn code into    insn equivalence class number.  The equivalence class number is    used to access to table and vectors representing DFA(s).  */
end_comment

begin_function
specifier|static
name|void
name|output_translate_vect
parameter_list|(
name|automaton_t
name|automaton
parameter_list|)
block|{
name|ainsn_t
name|ainsn
decl_stmt|;
name|int
name|insn_value
decl_stmt|;
name|vla_hwint_t
name|translate_vect
decl_stmt|;
name|translate_vect
operator|=
name|VEC_alloc
argument_list|(
name|vect_el_t
argument_list|,
name|heap
argument_list|,
name|description
operator|->
name|insns_num
argument_list|)
expr_stmt|;
for|for
control|(
name|insn_value
operator|=
literal|0
init|;
name|insn_value
operator|<
name|description
operator|->
name|insns_num
condition|;
name|insn_value
operator|++
control|)
comment|/* Undefined value */
name|VEC_quick_push
argument_list|(
name|vect_el_t
argument_list|,
name|translate_vect
argument_list|,
name|automaton
operator|->
name|insn_equiv_classes_num
argument_list|)
expr_stmt|;
for|for
control|(
name|ainsn
operator|=
name|automaton
operator|->
name|ainsn_list
init|;
name|ainsn
operator|!=
name|NULL
condition|;
name|ainsn
operator|=
name|ainsn
operator|->
name|next_ainsn
control|)
name|VEC_replace
argument_list|(
name|vect_el_t
argument_list|,
name|translate_vect
argument_list|,
name|ainsn
operator|->
name|insn_reserv_decl
operator|->
name|insn_num
argument_list|,
name|ainsn
operator|->
name|insn_equiv_class_num
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"/* Vector translating external insn codes to internal ones.*/\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"static const "
argument_list|)
expr_stmt|;
name|output_range_type
argument_list|(
name|output_file
argument_list|,
literal|0
argument_list|,
name|automaton
operator|->
name|insn_equiv_classes_num
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|output_translate_vect_name
argument_list|(
name|output_file
argument_list|,
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"[] ATTRIBUTE_UNUSED = {\n"
argument_list|)
expr_stmt|;
name|output_vect
argument_list|(
name|translate_vect
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"};\n\n"
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|vect_el_t
argument_list|,
name|heap
argument_list|,
name|translate_vect
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The value in a table state x ainsn -> something which represents    undefined value.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|undefined_vect_el_value
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following function returns nonzero value if the best    representation of the table is comb vector.  */
end_comment

begin_function
specifier|static
name|int
name|comb_vect_p
parameter_list|(
name|state_ainsn_table_t
name|tab
parameter_list|)
block|{
return|return
operator|(
literal|2
operator|*
name|VEC_length
argument_list|(
name|vect_el_t
argument_list|,
name|tab
operator|->
name|full_vect
argument_list|)
operator|>
literal|5
operator|*
name|VEC_length
argument_list|(
name|vect_el_t
argument_list|,
name|tab
operator|->
name|comb_vect
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* The following function creates new table for AUTOMATON.  */
end_comment

begin_function
specifier|static
name|state_ainsn_table_t
name|create_state_ainsn_table
parameter_list|(
name|automaton_t
name|automaton
parameter_list|)
block|{
name|state_ainsn_table_t
name|tab
decl_stmt|;
name|int
name|full_vect_length
decl_stmt|;
name|int
name|i
decl_stmt|;
name|tab
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|state_ainsn_table
argument_list|)
argument_list|)
expr_stmt|;
name|tab
operator|->
name|automaton
operator|=
name|automaton
expr_stmt|;
name|tab
operator|->
name|comb_vect
operator|=
name|VEC_alloc
argument_list|(
name|vect_el_t
argument_list|,
name|heap
argument_list|,
literal|10000
argument_list|)
expr_stmt|;
name|tab
operator|->
name|check_vect
operator|=
name|VEC_alloc
argument_list|(
name|vect_el_t
argument_list|,
name|heap
argument_list|,
literal|10000
argument_list|)
expr_stmt|;
name|tab
operator|->
name|base_vect
operator|=
literal|0
expr_stmt|;
name|VEC_safe_grow
argument_list|(
name|vect_el_t
argument_list|,
name|heap
argument_list|,
name|tab
operator|->
name|base_vect
argument_list|,
name|automaton
operator|->
name|achieved_states_num
argument_list|)
expr_stmt|;
name|full_vect_length
operator|=
operator|(
name|automaton
operator|->
name|insn_equiv_classes_num
operator|*
name|automaton
operator|->
name|achieved_states_num
operator|)
expr_stmt|;
name|tab
operator|->
name|full_vect
operator|=
name|VEC_alloc
argument_list|(
name|vect_el_t
argument_list|,
name|heap
argument_list|,
name|full_vect_length
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|full_vect_length
condition|;
name|i
operator|++
control|)
name|VEC_quick_push
argument_list|(
name|vect_el_t
argument_list|,
name|tab
operator|->
name|full_vect
argument_list|,
name|undefined_vect_el_value
argument_list|)
expr_stmt|;
name|tab
operator|->
name|min_base_vect_el_value
operator|=
literal|0
expr_stmt|;
name|tab
operator|->
name|max_base_vect_el_value
operator|=
literal|0
expr_stmt|;
name|tab
operator|->
name|min_comb_vect_el_value
operator|=
literal|0
expr_stmt|;
name|tab
operator|->
name|max_comb_vect_el_value
operator|=
literal|0
expr_stmt|;
return|return
name|tab
return|;
block|}
end_function

begin_comment
comment|/* The following function outputs the best C representation of the    table TAB of given TABLE_NAME.  */
end_comment

begin_function
specifier|static
name|void
name|output_state_ainsn_table
parameter_list|(
name|state_ainsn_table_t
name|tab
parameter_list|,
specifier|const
name|char
modifier|*
name|table_name
parameter_list|,
name|void
function_decl|(
modifier|*
name|output_full_vect_name_func
function_decl|)
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|automaton_t
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|output_comb_vect_name_func
function_decl|)
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|automaton_t
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|output_check_vect_name_func
function_decl|)
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|automaton_t
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|output_base_vect_name_func
function_decl|)
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|automaton_t
parameter_list|)
parameter_list|)
block|{
if|if
condition|(
operator|!
name|comb_vect_p
argument_list|(
name|tab
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"/* Vector for %s.  */\n"
argument_list|,
name|table_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"static const "
argument_list|)
expr_stmt|;
name|output_range_type
argument_list|(
name|output_file
argument_list|,
name|tab
operator|->
name|min_comb_vect_el_value
argument_list|,
name|tab
operator|->
name|max_comb_vect_el_value
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
call|(
modifier|*
name|output_full_vect_name_func
call|)
argument_list|(
name|output_file
argument_list|,
name|tab
operator|->
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"[] ATTRIBUTE_UNUSED = {\n"
argument_list|)
expr_stmt|;
name|output_vect
argument_list|(
name|tab
operator|->
name|full_vect
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"};\n\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"/* Comb vector for %s.  */\n"
argument_list|,
name|table_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"static const "
argument_list|)
expr_stmt|;
name|output_range_type
argument_list|(
name|output_file
argument_list|,
name|tab
operator|->
name|min_comb_vect_el_value
argument_list|,
name|tab
operator|->
name|max_comb_vect_el_value
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
call|(
modifier|*
name|output_comb_vect_name_func
call|)
argument_list|(
name|output_file
argument_list|,
name|tab
operator|->
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"[] ATTRIBUTE_UNUSED = {\n"
argument_list|)
expr_stmt|;
name|output_vect
argument_list|(
name|tab
operator|->
name|comb_vect
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"};\n\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"/* Check vector for %s.  */\n"
argument_list|,
name|table_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"static const "
argument_list|)
expr_stmt|;
name|output_range_type
argument_list|(
name|output_file
argument_list|,
literal|0
argument_list|,
name|tab
operator|->
name|automaton
operator|->
name|achieved_states_num
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
call|(
modifier|*
name|output_check_vect_name_func
call|)
argument_list|(
name|output_file
argument_list|,
name|tab
operator|->
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"[] = {\n"
argument_list|)
expr_stmt|;
name|output_vect
argument_list|(
name|tab
operator|->
name|check_vect
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"};\n\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"/* Base vector for %s.  */\n"
argument_list|,
name|table_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"static const "
argument_list|)
expr_stmt|;
name|output_range_type
argument_list|(
name|output_file
argument_list|,
name|tab
operator|->
name|min_base_vect_el_value
argument_list|,
name|tab
operator|->
name|max_base_vect_el_value
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
call|(
modifier|*
name|output_base_vect_name_func
call|)
argument_list|(
name|output_file
argument_list|,
name|tab
operator|->
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"[] = {\n"
argument_list|)
expr_stmt|;
name|output_vect
argument_list|(
name|tab
operator|->
name|base_vect
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"};\n\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The following function adds vector VECT to table TAB as its line    with number VECT_NUM.  */
end_comment

begin_function
specifier|static
name|void
name|add_vect
parameter_list|(
name|state_ainsn_table_t
name|tab
parameter_list|,
name|int
name|vect_num
parameter_list|,
name|vla_hwint_t
name|vect
parameter_list|)
block|{
name|int
name|vect_length
decl_stmt|;
name|size_t
name|real_vect_length
decl_stmt|;
name|int
name|comb_vect_index
decl_stmt|;
name|int
name|comb_vect_els_num
decl_stmt|;
name|int
name|vect_index
decl_stmt|;
name|int
name|first_unempty_vect_index
decl_stmt|;
name|int
name|additional_els_num
decl_stmt|;
name|int
name|no_state_value
decl_stmt|;
name|vect_el_t
name|vect_el
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|long
name|vect_mask
decl_stmt|,
name|comb_vect_mask
decl_stmt|;
name|vect_length
operator|=
name|VEC_length
argument_list|(
name|vect_el_t
argument_list|,
name|vect
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|vect_length
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|VEC_last
argument_list|(
name|vect_el_t
argument_list|,
name|vect
argument_list|)
operator|!=
name|undefined_vect_el_value
argument_list|)
expr_stmt|;
name|real_vect_length
operator|=
name|tab
operator|->
name|automaton
operator|->
name|insn_equiv_classes_num
expr_stmt|;
comment|/* Form full vector in the table: */
block|{
name|size_t
name|full_base
init|=
name|tab
operator|->
name|automaton
operator|->
name|insn_equiv_classes_num
operator|*
name|vect_num
decl_stmt|;
if|if
condition|(
name|VEC_length
argument_list|(
name|vect_el_t
argument_list|,
name|tab
operator|->
name|full_vect
argument_list|)
operator|<
name|full_base
operator|+
name|vect_length
condition|)
name|VEC_safe_grow
argument_list|(
name|vect_el_t
argument_list|,
name|heap
argument_list|,
name|tab
operator|->
name|full_vect
argument_list|,
name|full_base
operator|+
name|vect_length
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vect_length
condition|;
name|i
operator|++
control|)
name|VEC_replace
argument_list|(
name|vect_el_t
argument_list|,
name|tab
operator|->
name|full_vect
argument_list|,
name|full_base
operator|+
name|i
argument_list|,
name|VEC_index
argument_list|(
name|vect_el_t
argument_list|,
name|vect
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Form comb vector in the table: */
name|gcc_assert
argument_list|(
name|VEC_length
argument_list|(
name|vect_el_t
argument_list|,
name|tab
operator|->
name|comb_vect
argument_list|)
operator|==
name|VEC_length
argument_list|(
name|vect_el_t
argument_list|,
name|tab
operator|->
name|check_vect
argument_list|)
argument_list|)
expr_stmt|;
name|comb_vect_els_num
operator|=
name|VEC_length
argument_list|(
name|vect_el_t
argument_list|,
name|tab
operator|->
name|comb_vect
argument_list|)
expr_stmt|;
for|for
control|(
name|first_unempty_vect_index
operator|=
literal|0
init|;
name|first_unempty_vect_index
operator|<
name|vect_length
condition|;
name|first_unempty_vect_index
operator|++
control|)
if|if
condition|(
name|VEC_index
argument_list|(
name|vect_el_t
argument_list|,
name|vect
argument_list|,
name|first_unempty_vect_index
argument_list|)
operator|!=
name|undefined_vect_el_value
condition|)
break|break;
comment|/* Search for the place in comb vect for the inserted vect.  */
comment|/* Slow case.  */
if|if
condition|(
name|vect_length
operator|-
name|first_unempty_vect_index
operator|>=
name|SIZEOF_LONG
operator|*
name|CHAR_BIT
condition|)
block|{
for|for
control|(
name|comb_vect_index
operator|=
literal|0
init|;
name|comb_vect_index
operator|<
name|comb_vect_els_num
condition|;
name|comb_vect_index
operator|++
control|)
block|{
for|for
control|(
name|vect_index
operator|=
name|first_unempty_vect_index
init|;
name|vect_index
operator|<
name|vect_length
operator|&&
name|vect_index
operator|+
name|comb_vect_index
operator|<
name|comb_vect_els_num
condition|;
name|vect_index
operator|++
control|)
if|if
condition|(
name|VEC_index
argument_list|(
name|vect_el_t
argument_list|,
name|vect
argument_list|,
name|vect_index
argument_list|)
operator|!=
name|undefined_vect_el_value
operator|&&
operator|(
name|VEC_index
argument_list|(
name|vect_el_t
argument_list|,
name|tab
operator|->
name|comb_vect
argument_list|,
name|vect_index
operator|+
name|comb_vect_index
argument_list|)
operator|!=
name|undefined_vect_el_value
operator|)
condition|)
break|break;
if|if
condition|(
name|vect_index
operator|>=
name|vect_length
operator|||
name|vect_index
operator|+
name|comb_vect_index
operator|>=
name|comb_vect_els_num
condition|)
break|break;
block|}
goto|goto
name|found
goto|;
block|}
comment|/* Fast case.  */
name|vect_mask
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|vect_index
operator|=
name|first_unempty_vect_index
init|;
name|vect_index
operator|<
name|vect_length
condition|;
name|vect_index
operator|++
control|)
block|{
name|vect_mask
operator|=
name|vect_mask
operator|<<
literal|1
expr_stmt|;
if|if
condition|(
name|VEC_index
argument_list|(
name|vect_el_t
argument_list|,
name|vect
argument_list|,
name|vect_index
argument_list|)
operator|!=
name|undefined_vect_el_value
condition|)
name|vect_mask
operator||=
literal|1
expr_stmt|;
block|}
comment|/* Search for the place in comb vect for the inserted vect.  */
name|comb_vect_index
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|comb_vect_els_num
operator|==
literal|0
condition|)
goto|goto
name|found
goto|;
name|comb_vect_mask
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|vect_index
operator|=
name|first_unempty_vect_index
init|;
name|vect_index
operator|<
name|vect_length
operator|&&
name|vect_index
operator|<
name|comb_vect_els_num
condition|;
name|vect_index
operator|++
control|)
block|{
name|comb_vect_mask
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|vect_index
operator|+
name|comb_vect_index
operator|<
name|comb_vect_els_num
operator|&&
name|VEC_index
argument_list|(
name|vect_el_t
argument_list|,
name|tab
operator|->
name|comb_vect
argument_list|,
name|vect_index
operator|+
name|comb_vect_index
argument_list|)
operator|!=
name|undefined_vect_el_value
condition|)
name|comb_vect_mask
operator||=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|vect_mask
operator|&
name|comb_vect_mask
operator|)
operator|==
literal|0
condition|)
goto|goto
name|found
goto|;
for|for
control|(
name|comb_vect_index
operator|=
literal|1
operator|,
name|i
operator|=
name|vect_length
init|;
name|i
operator|<
name|comb_vect_els_num
condition|;
name|comb_vect_index
operator|++
operator|,
name|i
operator|++
control|)
block|{
name|comb_vect_mask
operator|=
operator|(
name|comb_vect_mask
operator|<<
literal|1
operator|)
operator||
literal|1
expr_stmt|;
name|comb_vect_mask
operator|^=
operator|(
name|VEC_index
argument_list|(
name|vect_el_t
argument_list|,
name|tab
operator|->
name|comb_vect
argument_list|,
name|i
argument_list|)
operator|==
name|undefined_vect_el_value
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|vect_mask
operator|&
name|comb_vect_mask
operator|)
operator|==
literal|0
condition|)
goto|goto
name|found
goto|;
block|}
for|for
control|(
init|;
name|comb_vect_index
operator|<
name|comb_vect_els_num
condition|;
name|comb_vect_index
operator|++
control|)
block|{
name|comb_vect_mask
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|vect_mask
operator|&
name|comb_vect_mask
operator|)
operator|==
literal|0
condition|)
goto|goto
name|found
goto|;
block|}
name|found
label|:
comment|/* Slot was found.  */
name|additional_els_num
operator|=
name|comb_vect_index
operator|+
name|real_vect_length
operator|-
name|comb_vect_els_num
expr_stmt|;
if|if
condition|(
name|additional_els_num
operator|<
literal|0
condition|)
name|additional_els_num
operator|=
literal|0
expr_stmt|;
comment|/* Expand comb and check vectors.  */
name|vect_el
operator|=
name|undefined_vect_el_value
expr_stmt|;
name|no_state_value
operator|=
name|tab
operator|->
name|automaton
operator|->
name|achieved_states_num
expr_stmt|;
while|while
condition|(
name|additional_els_num
operator|>
literal|0
condition|)
block|{
name|VEC_safe_push
argument_list|(
name|vect_el_t
argument_list|,
name|heap
argument_list|,
name|tab
operator|->
name|comb_vect
argument_list|,
name|vect_el
argument_list|)
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|vect_el_t
argument_list|,
name|heap
argument_list|,
name|tab
operator|->
name|check_vect
argument_list|,
name|no_state_value
argument_list|)
expr_stmt|;
name|additional_els_num
operator|--
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|VEC_length
argument_list|(
name|vect_el_t
argument_list|,
name|tab
operator|->
name|comb_vect
argument_list|)
operator|>=
name|comb_vect_index
operator|+
name|real_vect_length
argument_list|)
expr_stmt|;
comment|/* Fill comb and check vectors.  */
for|for
control|(
name|vect_index
operator|=
literal|0
init|;
name|vect_index
operator|<
name|vect_length
condition|;
name|vect_index
operator|++
control|)
if|if
condition|(
name|VEC_index
argument_list|(
name|vect_el_t
argument_list|,
name|vect
argument_list|,
name|vect_index
argument_list|)
operator|!=
name|undefined_vect_el_value
condition|)
block|{
name|vect_el_t
name|x
init|=
name|VEC_index
argument_list|(
name|vect_el_t
argument_list|,
name|vect
argument_list|,
name|vect_index
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|VEC_index
argument_list|(
name|vect_el_t
argument_list|,
name|tab
operator|->
name|comb_vect
argument_list|,
name|comb_vect_index
operator|+
name|vect_index
argument_list|)
operator|==
name|undefined_vect_el_value
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|x
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tab
operator|->
name|max_comb_vect_el_value
operator|<
name|x
condition|)
name|tab
operator|->
name|max_comb_vect_el_value
operator|=
name|x
expr_stmt|;
if|if
condition|(
name|tab
operator|->
name|min_comb_vect_el_value
operator|>
name|x
condition|)
name|tab
operator|->
name|min_comb_vect_el_value
operator|=
name|x
expr_stmt|;
name|VEC_replace
argument_list|(
name|vect_el_t
argument_list|,
name|tab
operator|->
name|comb_vect
argument_list|,
name|comb_vect_index
operator|+
name|vect_index
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|VEC_replace
argument_list|(
name|vect_el_t
argument_list|,
name|tab
operator|->
name|check_vect
argument_list|,
name|comb_vect_index
operator|+
name|vect_index
argument_list|,
name|vect_num
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tab
operator|->
name|max_comb_vect_el_value
operator|<
name|undefined_vect_el_value
condition|)
name|tab
operator|->
name|max_comb_vect_el_value
operator|=
name|undefined_vect_el_value
expr_stmt|;
if|if
condition|(
name|tab
operator|->
name|min_comb_vect_el_value
operator|>
name|undefined_vect_el_value
condition|)
name|tab
operator|->
name|min_comb_vect_el_value
operator|=
name|undefined_vect_el_value
expr_stmt|;
if|if
condition|(
name|tab
operator|->
name|max_base_vect_el_value
operator|<
name|comb_vect_index
condition|)
name|tab
operator|->
name|max_base_vect_el_value
operator|=
name|comb_vect_index
expr_stmt|;
if|if
condition|(
name|tab
operator|->
name|min_base_vect_el_value
operator|>
name|comb_vect_index
condition|)
name|tab
operator|->
name|min_base_vect_el_value
operator|=
name|comb_vect_index
expr_stmt|;
name|VEC_replace
argument_list|(
name|vect_el_t
argument_list|,
name|tab
operator|->
name|base_vect
argument_list|,
name|vect_num
argument_list|,
name|comb_vect_index
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return number of out arcs of STATE.  */
end_comment

begin_function
specifier|static
name|int
name|out_state_arcs_num
parameter_list|(
name|state_t
name|state
parameter_list|)
block|{
name|int
name|result
decl_stmt|;
name|arc_t
name|arc
decl_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|arc
operator|=
name|first_out_arc
argument_list|(
name|state
argument_list|)
init|;
name|arc
operator|!=
name|NULL
condition|;
name|arc
operator|=
name|next_out_arc
argument_list|(
name|arc
argument_list|)
control|)
block|{
name|gcc_assert
argument_list|(
name|arc
operator|->
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|arc
operator|->
name|insn
operator|->
name|first_ainsn_with_given_equivalence_num
condition|)
name|result
operator|++
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Compare number of possible transitions from the states.  */
end_comment

begin_function
specifier|static
name|int
name|compare_transition_els_num
parameter_list|(
specifier|const
name|void
modifier|*
name|state_ptr_1
parameter_list|,
specifier|const
name|void
modifier|*
name|state_ptr_2
parameter_list|)
block|{
name|int
name|transition_els_num_1
decl_stmt|;
name|int
name|transition_els_num_2
decl_stmt|;
name|transition_els_num_1
operator|=
name|out_state_arcs_num
argument_list|(
operator|*
operator|(
name|state_t
operator|*
operator|)
name|state_ptr_1
argument_list|)
expr_stmt|;
name|transition_els_num_2
operator|=
name|out_state_arcs_num
argument_list|(
operator|*
operator|(
name|state_t
operator|*
operator|)
name|state_ptr_2
argument_list|)
expr_stmt|;
if|if
condition|(
name|transition_els_num_1
operator|<
name|transition_els_num_2
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|transition_els_num_1
operator|==
name|transition_els_num_2
condition|)
return|return
literal|0
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* The function adds element EL_VALUE to vector VECT for a table state    x AINSN.  */
end_comment

begin_function
specifier|static
name|void
name|add_vect_el
parameter_list|(
name|vla_hwint_t
modifier|*
name|vect
parameter_list|,
name|ainsn_t
name|ainsn
parameter_list|,
name|int
name|el_value
parameter_list|)
block|{
name|int
name|equiv_class_num
decl_stmt|;
name|int
name|vect_index
decl_stmt|;
name|gcc_assert
argument_list|(
name|ainsn
argument_list|)
expr_stmt|;
name|equiv_class_num
operator|=
name|ainsn
operator|->
name|insn_equiv_class_num
expr_stmt|;
for|for
control|(
name|vect_index
operator|=
name|VEC_length
argument_list|(
name|vect_el_t
argument_list|,
operator|*
name|vect
argument_list|)
init|;
name|vect_index
operator|<=
name|equiv_class_num
condition|;
name|vect_index
operator|++
control|)
name|VEC_safe_push
argument_list|(
name|vect_el_t
argument_list|,
name|heap
argument_list|,
operator|*
name|vect
argument_list|,
name|undefined_vect_el_value
argument_list|)
expr_stmt|;
name|VEC_replace
argument_list|(
name|vect_el_t
argument_list|,
operator|*
name|vect
argument_list|,
name|equiv_class_num
argument_list|,
name|el_value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is for forming vector of states of an automaton.  */
end_comment

begin_expr_stmt
specifier|static
name|VEC
argument_list|(
name|state_t
argument_list|,
name|heap
argument_list|)
operator|*
name|output_states_vect
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* The function is called by function pass_states.  The function adds    STATE to `output_states_vect'.  */
end_comment

begin_function
specifier|static
name|void
name|add_states_vect_el
parameter_list|(
name|state_t
name|state
parameter_list|)
block|{
name|VEC_safe_push
argument_list|(
name|state_t
argument_list|,
name|heap
argument_list|,
name|output_states_vect
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Form and output vectors (comb, check, base or full vector)    representing transition table of AUTOMATON.  */
end_comment

begin_function
specifier|static
name|void
name|output_trans_table
parameter_list|(
name|automaton_t
name|automaton
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|arc_t
name|arc
decl_stmt|;
name|vla_hwint_t
name|transition_vect
init|=
literal|0
decl_stmt|;
name|undefined_vect_el_value
operator|=
name|automaton
operator|->
name|achieved_states_num
expr_stmt|;
name|automaton
operator|->
name|trans_table
operator|=
name|create_state_ainsn_table
argument_list|(
name|automaton
argument_list|)
expr_stmt|;
comment|/* Create vect of pointers to states ordered by num of transitions      from the state (state with the maximum num is the first).  */
name|output_states_vect
operator|=
literal|0
expr_stmt|;
name|pass_states
argument_list|(
name|automaton
argument_list|,
name|add_states_vect_el
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|VEC_address
argument_list|(
name|state_t
argument_list|,
name|output_states_vect
argument_list|)
argument_list|,
name|VEC_length
argument_list|(
name|state_t
argument_list|,
name|output_states_vect
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|state_t
argument_list|)
argument_list|,
name|compare_transition_els_num
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VEC_length
argument_list|(
name|state_t
argument_list|,
name|output_states_vect
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|VEC_truncate
argument_list|(
name|vect_el_t
argument_list|,
name|transition_vect
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|arc
operator|=
name|first_out_arc
argument_list|(
name|VEC_index
argument_list|(
name|state_t
argument_list|,
name|output_states_vect
argument_list|,
name|i
argument_list|)
argument_list|)
init|;
name|arc
operator|!=
name|NULL
condition|;
name|arc
operator|=
name|next_out_arc
argument_list|(
name|arc
argument_list|)
control|)
block|{
name|gcc_assert
argument_list|(
name|arc
operator|->
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|arc
operator|->
name|insn
operator|->
name|first_ainsn_with_given_equivalence_num
condition|)
name|add_vect_el
argument_list|(
operator|&
name|transition_vect
argument_list|,
name|arc
operator|->
name|insn
argument_list|,
name|arc
operator|->
name|to_state
operator|->
name|order_state_num
argument_list|)
expr_stmt|;
block|}
name|add_vect
argument_list|(
name|automaton
operator|->
name|trans_table
argument_list|,
name|VEC_index
argument_list|(
name|state_t
argument_list|,
name|output_states_vect
argument_list|,
name|i
argument_list|)
operator|->
name|order_state_num
argument_list|,
name|transition_vect
argument_list|)
expr_stmt|;
block|}
name|output_state_ainsn_table
argument_list|(
name|automaton
operator|->
name|trans_table
argument_list|,
literal|"state transitions"
argument_list|,
name|output_trans_full_vect_name
argument_list|,
name|output_trans_comb_vect_name
argument_list|,
name|output_trans_check_vect_name
argument_list|,
name|output_trans_base_vect_name
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|state_t
argument_list|,
name|heap
argument_list|,
name|output_states_vect
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|vect_el_t
argument_list|,
name|heap
argument_list|,
name|transition_vect
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The current number of passing states to find minimal issue delay    value for an ainsn and state.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|curr_state_pass_num
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This recursive function passes states to find minimal issue delay    value for AINSN.  The state being visited is STATE.  The function    returns minimal issue delay value for AINSN in STATE or -1 if we    enter into a loop.  */
end_comment

begin_function
specifier|static
name|int
name|min_issue_delay_pass_states
parameter_list|(
name|state_t
name|state
parameter_list|,
name|ainsn_t
name|ainsn
parameter_list|)
block|{
name|arc_t
name|arc
decl_stmt|;
name|int
name|min_insn_issue_delay
decl_stmt|,
name|insn_issue_delay
decl_stmt|;
if|if
condition|(
name|state
operator|->
name|state_pass_num
operator|==
name|curr_state_pass_num
operator|||
name|state
operator|->
name|min_insn_issue_delay
operator|!=
operator|-
literal|1
condition|)
comment|/* We've entered into a loop or already have the correct value for        given state and ainsn.  */
return|return
name|state
operator|->
name|min_insn_issue_delay
return|;
name|state
operator|->
name|state_pass_num
operator|=
name|curr_state_pass_num
expr_stmt|;
name|min_insn_issue_delay
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|arc
operator|=
name|first_out_arc
argument_list|(
name|state
argument_list|)
init|;
name|arc
operator|!=
name|NULL
condition|;
name|arc
operator|=
name|next_out_arc
argument_list|(
name|arc
argument_list|)
control|)
if|if
condition|(
name|arc
operator|->
name|insn
operator|==
name|ainsn
condition|)
block|{
name|min_insn_issue_delay
operator|=
literal|0
expr_stmt|;
break|break;
block|}
else|else
block|{
name|insn_issue_delay
operator|=
name|min_issue_delay_pass_states
argument_list|(
name|arc
operator|->
name|to_state
argument_list|,
name|ainsn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn_issue_delay
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|arc
operator|->
name|insn
operator|->
name|insn_reserv_decl
operator|==
name|DECL_INSN_RESERV
argument_list|(
name|advance_cycle_insn_decl
argument_list|)
condition|)
name|insn_issue_delay
operator|++
expr_stmt|;
if|if
condition|(
name|min_insn_issue_delay
operator|==
operator|-
literal|1
operator|||
name|min_insn_issue_delay
operator|>
name|insn_issue_delay
condition|)
block|{
name|min_insn_issue_delay
operator|=
name|insn_issue_delay
expr_stmt|;
if|if
condition|(
name|insn_issue_delay
operator|==
literal|0
condition|)
break|break;
block|}
block|}
block|}
return|return
name|min_insn_issue_delay
return|;
block|}
end_function

begin_comment
comment|/* The function searches minimal issue delay value for AINSN in STATE.    The function can return negative value if we can not issue AINSN.  We    will report about it later.  */
end_comment

begin_function
specifier|static
name|int
name|min_issue_delay
parameter_list|(
name|state_t
name|state
parameter_list|,
name|ainsn_t
name|ainsn
parameter_list|)
block|{
name|curr_state_pass_num
operator|++
expr_stmt|;
name|state
operator|->
name|min_insn_issue_delay
operator|=
name|min_issue_delay_pass_states
argument_list|(
name|state
argument_list|,
name|ainsn
argument_list|)
expr_stmt|;
return|return
name|state
operator|->
name|min_insn_issue_delay
return|;
block|}
end_function

begin_comment
comment|/* The function initiates code for finding minimal issue delay values.    It should be called only once.  */
end_comment

begin_function
specifier|static
name|void
name|initiate_min_issue_delay_pass_states
parameter_list|(
name|void
parameter_list|)
block|{
name|curr_state_pass_num
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Form and output vectors representing minimal issue delay table of    AUTOMATON.  The table is state x ainsn -> minimal issue delay of    the ainsn.  */
end_comment

begin_function
specifier|static
name|void
name|output_min_issue_delay_table
parameter_list|(
name|automaton_t
name|automaton
parameter_list|)
block|{
name|vla_hwint_t
name|min_issue_delay_vect
decl_stmt|;
name|vla_hwint_t
name|compressed_min_issue_delay_vect
decl_stmt|;
name|vect_el_t
name|min_delay
decl_stmt|;
name|ainsn_t
name|ainsn
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|min_issue_delay_len
decl_stmt|;
name|size_t
name|compressed_min_issue_delay_len
decl_stmt|;
name|size_t
name|cfactor
decl_stmt|;
comment|/* Create vect of pointers to states ordered by num of transitions      from the state (state with the maximum num is the first).  */
name|output_states_vect
operator|=
literal|0
expr_stmt|;
name|pass_states
argument_list|(
name|automaton
argument_list|,
name|add_states_vect_el
argument_list|)
expr_stmt|;
name|min_issue_delay_len
operator|=
operator|(
name|VEC_length
argument_list|(
name|state_t
argument_list|,
name|output_states_vect
argument_list|)
operator|*
name|automaton
operator|->
name|insn_equiv_classes_num
operator|)
expr_stmt|;
name|min_issue_delay_vect
operator|=
name|VEC_alloc
argument_list|(
name|vect_el_t
argument_list|,
name|heap
argument_list|,
name|min_issue_delay_len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|min_issue_delay_len
condition|;
name|i
operator|++
control|)
name|VEC_quick_push
argument_list|(
name|vect_el_t
argument_list|,
name|min_issue_delay_vect
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|automaton
operator|->
name|max_min_delay
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ainsn
operator|=
name|automaton
operator|->
name|ainsn_list
init|;
name|ainsn
operator|!=
name|NULL
condition|;
name|ainsn
operator|=
name|ainsn
operator|->
name|next_ainsn
control|)
if|if
condition|(
name|ainsn
operator|->
name|first_ainsn_with_given_equivalence_num
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VEC_length
argument_list|(
name|state_t
argument_list|,
name|output_states_vect
argument_list|)
condition|;
name|i
operator|++
control|)
name|VEC_index
argument_list|(
name|state_t
argument_list|,
name|output_states_vect
argument_list|,
name|i
argument_list|)
operator|->
name|min_insn_issue_delay
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VEC_length
argument_list|(
name|state_t
argument_list|,
name|output_states_vect
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|state_t
name|s
init|=
name|VEC_index
argument_list|(
name|state_t
argument_list|,
name|output_states_vect
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|min_delay
operator|=
name|min_issue_delay
argument_list|(
name|s
argument_list|,
name|ainsn
argument_list|)
expr_stmt|;
if|if
condition|(
name|automaton
operator|->
name|max_min_delay
operator|<
name|min_delay
condition|)
name|automaton
operator|->
name|max_min_delay
operator|=
name|min_delay
expr_stmt|;
name|VEC_replace
argument_list|(
name|vect_el_t
argument_list|,
name|min_issue_delay_vect
argument_list|,
name|s
operator|->
name|order_state_num
operator|*
name|automaton
operator|->
name|insn_equiv_classes_num
operator|+
name|ainsn
operator|->
name|insn_equiv_class_num
argument_list|,
name|min_delay
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"/* Vector of min issue delay of insns.  */\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"static const "
argument_list|)
expr_stmt|;
name|output_range_type
argument_list|(
name|output_file
argument_list|,
literal|0
argument_list|,
name|automaton
operator|->
name|max_min_delay
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|output_min_issue_delay_vect_name
argument_list|(
name|output_file
argument_list|,
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"[] ATTRIBUTE_UNUSED = {\n"
argument_list|)
expr_stmt|;
comment|/* Compress the vector.  */
if|if
condition|(
name|automaton
operator|->
name|max_min_delay
operator|<
literal|2
condition|)
name|cfactor
operator|=
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
name|automaton
operator|->
name|max_min_delay
operator|<
literal|4
condition|)
name|cfactor
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|automaton
operator|->
name|max_min_delay
operator|<
literal|16
condition|)
name|cfactor
operator|=
literal|2
expr_stmt|;
else|else
name|cfactor
operator|=
literal|1
expr_stmt|;
name|automaton
operator|->
name|min_issue_delay_table_compression_factor
operator|=
name|cfactor
expr_stmt|;
name|compressed_min_issue_delay_len
operator|=
operator|(
name|min_issue_delay_len
operator|+
name|cfactor
operator|-
literal|1
operator|)
operator|/
name|cfactor
expr_stmt|;
name|compressed_min_issue_delay_vect
operator|=
name|VEC_alloc
argument_list|(
name|vect_el_t
argument_list|,
name|heap
argument_list|,
name|compressed_min_issue_delay_len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|compressed_min_issue_delay_len
condition|;
name|i
operator|++
control|)
name|VEC_quick_push
argument_list|(
name|vect_el_t
argument_list|,
name|compressed_min_issue_delay_vect
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|min_issue_delay_len
condition|;
name|i
operator|++
control|)
block|{
name|size_t
name|ci
init|=
name|i
operator|/
name|cfactor
decl_stmt|;
name|vect_el_t
name|x
init|=
name|VEC_index
argument_list|(
name|vect_el_t
argument_list|,
name|min_issue_delay_vect
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|vect_el_t
name|cx
init|=
name|VEC_index
argument_list|(
name|vect_el_t
argument_list|,
name|compressed_min_issue_delay_vect
argument_list|,
name|ci
argument_list|)
decl_stmt|;
name|cx
operator||=
name|x
operator|<<
operator|(
literal|8
operator|-
operator|(
name|i
operator|%
name|cfactor
operator|+
literal|1
operator|)
operator|*
operator|(
literal|8
operator|/
name|cfactor
operator|)
operator|)
expr_stmt|;
name|VEC_replace
argument_list|(
name|vect_el_t
argument_list|,
name|compressed_min_issue_delay_vect
argument_list|,
name|ci
argument_list|,
name|cx
argument_list|)
expr_stmt|;
block|}
name|output_vect
argument_list|(
name|compressed_min_issue_delay_vect
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"};\n\n"
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|state_t
argument_list|,
name|heap
argument_list|,
name|output_states_vect
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|vect_el_t
argument_list|,
name|heap
argument_list|,
name|min_issue_delay_vect
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|vect_el_t
argument_list|,
name|heap
argument_list|,
name|compressed_min_issue_delay_vect
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Form and output vector representing the locked states of    AUTOMATON.  */
end_comment

begin_function
specifier|static
name|void
name|output_dead_lock_vect
parameter_list|(
name|automaton_t
name|automaton
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|arc_t
name|arc
decl_stmt|;
name|vla_hwint_t
name|dead_lock_vect
init|=
literal|0
decl_stmt|;
comment|/* Create vect of pointers to states ordered by num of      transitions from the state (state with the maximum num is the      first).  */
name|automaton
operator|->
name|locked_states
operator|=
literal|0
expr_stmt|;
name|output_states_vect
operator|=
literal|0
expr_stmt|;
name|pass_states
argument_list|(
name|automaton
argument_list|,
name|add_states_vect_el
argument_list|)
expr_stmt|;
name|VEC_safe_grow
argument_list|(
name|vect_el_t
argument_list|,
name|heap
argument_list|,
name|dead_lock_vect
argument_list|,
name|VEC_length
argument_list|(
name|state_t
argument_list|,
name|output_states_vect
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VEC_length
argument_list|(
name|state_t
argument_list|,
name|output_states_vect
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|state_t
name|s
init|=
name|VEC_index
argument_list|(
name|state_t
argument_list|,
name|output_states_vect
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|arc
operator|=
name|first_out_arc
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|arc
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_out_arc
argument_list|(
name|arc
argument_list|)
operator|==
name|NULL
operator|&&
operator|(
name|arc
operator|->
name|insn
operator|->
name|insn_reserv_decl
operator|==
name|DECL_INSN_RESERV
argument_list|(
name|advance_cycle_insn_decl
argument_list|)
operator|)
condition|)
block|{
name|VEC_replace
argument_list|(
name|vect_el_t
argument_list|,
name|dead_lock_vect
argument_list|,
name|s
operator|->
name|order_state_num
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|automaton
operator|->
name|locked_states
operator|++
expr_stmt|;
block|}
else|else
name|VEC_replace
argument_list|(
name|vect_el_t
argument_list|,
name|dead_lock_vect
argument_list|,
name|s
operator|->
name|order_state_num
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|automaton
operator|->
name|locked_states
operator|==
literal|0
condition|)
return|return;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"/* Vector for locked state flags.  */\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"static const "
argument_list|)
expr_stmt|;
name|output_range_type
argument_list|(
name|output_file
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|output_dead_lock_vect_name
argument_list|(
name|output_file
argument_list|,
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"[] = {\n"
argument_list|)
expr_stmt|;
name|output_vect
argument_list|(
name|dead_lock_vect
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"};\n\n"
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|state_t
argument_list|,
name|heap
argument_list|,
name|output_states_vect
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|vect_el_t
argument_list|,
name|heap
argument_list|,
name|dead_lock_vect
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Form and output vector representing reserved units of the states of    AUTOMATON.  */
end_comment

begin_function
specifier|static
name|void
name|output_reserved_units_table
parameter_list|(
name|automaton_t
name|automaton
parameter_list|)
block|{
name|vla_hwint_t
name|reserved_units_table
init|=
literal|0
decl_stmt|;
name|int
name|state_byte_size
decl_stmt|;
name|int
name|reserved_units_size
decl_stmt|;
name|size_t
name|n
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|description
operator|->
name|query_units_num
operator|==
literal|0
condition|)
return|return;
comment|/* Create vect of pointers to states.  */
name|output_states_vect
operator|=
literal|0
expr_stmt|;
name|pass_states
argument_list|(
name|automaton
argument_list|,
name|add_states_vect_el
argument_list|)
expr_stmt|;
comment|/* Create vector.  */
name|state_byte_size
operator|=
operator|(
name|description
operator|->
name|query_units_num
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
name|reserved_units_size
operator|=
operator|(
name|VEC_length
argument_list|(
name|state_t
argument_list|,
name|output_states_vect
argument_list|)
operator|*
name|state_byte_size
operator|)
expr_stmt|;
name|reserved_units_table
operator|=
name|VEC_alloc
argument_list|(
name|vect_el_t
argument_list|,
name|heap
argument_list|,
name|reserved_units_size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reserved_units_size
condition|;
name|i
operator|++
control|)
name|VEC_quick_push
argument_list|(
name|vect_el_t
argument_list|,
name|reserved_units_table
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|VEC_length
argument_list|(
name|state_t
argument_list|,
name|output_states_vect
argument_list|)
condition|;
name|n
operator|++
control|)
block|{
name|state_t
name|s
init|=
name|VEC_index
argument_list|(
name|state_t
argument_list|,
name|output_states_vect
argument_list|,
name|n
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|units_num
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|units_array
index|[
name|i
index|]
operator|->
name|query_p
operator|&&
name|first_cycle_unit_presence
argument_list|(
name|s
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|int
name|ri
init|=
operator|(
name|s
operator|->
name|order_state_num
operator|*
name|state_byte_size
operator|+
name|units_array
index|[
name|i
index|]
operator|->
name|query_num
operator|/
literal|8
operator|)
decl_stmt|;
name|vect_el_t
name|x
init|=
name|VEC_index
argument_list|(
name|vect_el_t
argument_list|,
name|reserved_units_table
argument_list|,
name|ri
argument_list|)
decl_stmt|;
name|x
operator|+=
literal|1
operator|<<
operator|(
name|units_array
index|[
name|i
index|]
operator|->
name|query_num
operator|%
literal|8
operator|)
expr_stmt|;
name|VEC_replace
argument_list|(
name|vect_el_t
argument_list|,
name|reserved_units_table
argument_list|,
name|ri
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\n#if %s\n"
argument_list|,
name|CPU_UNITS_QUERY_MACRO_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"/* Vector for reserved units of states.  */\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"static const "
argument_list|)
expr_stmt|;
name|output_range_type
argument_list|(
name|output_file
argument_list|,
literal|0
argument_list|,
literal|255
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|output_reserved_units_table_name
argument_list|(
name|output_file
argument_list|,
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"[] = {\n"
argument_list|)
expr_stmt|;
name|output_vect
argument_list|(
name|reserved_units_table
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"};\n#endif /* #if %s */\n\n"
argument_list|,
name|CPU_UNITS_QUERY_MACRO_NAME
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|state_t
argument_list|,
name|heap
argument_list|,
name|output_states_vect
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|vect_el_t
argument_list|,
name|heap
argument_list|,
name|reserved_units_table
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function outputs all tables representing DFA(s) used for fast    pipeline hazards recognition.  */
end_comment

begin_function
specifier|static
name|void
name|output_tables
parameter_list|(
name|void
parameter_list|)
block|{
name|automaton_t
name|automaton
decl_stmt|;
name|initiate_min_issue_delay_pass_states
argument_list|()
expr_stmt|;
for|for
control|(
name|automaton
operator|=
name|description
operator|->
name|first_automaton
init|;
name|automaton
operator|!=
name|NULL
condition|;
name|automaton
operator|=
name|automaton
operator|->
name|next_automaton
control|)
block|{
name|output_translate_vect
argument_list|(
name|automaton
argument_list|)
expr_stmt|;
name|output_trans_table
argument_list|(
name|automaton
argument_list|)
expr_stmt|;
name|output_min_issue_delay_table
argument_list|(
name|automaton
argument_list|)
expr_stmt|;
name|output_dead_lock_vect
argument_list|(
name|automaton
argument_list|)
expr_stmt|;
name|output_reserved_units_table
argument_list|(
name|automaton
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\n#define %s %d\n\n"
argument_list|,
name|ADVANCE_CYCLE_VALUE_NAME
argument_list|,
name|DECL_INSN_RESERV
argument_list|(
name|advance_cycle_insn_decl
argument_list|)
operator|->
name|insn_num
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function outputs definition and value of PHR interface variable    `max_insn_queue_index'.  Its value is not less than maximal queue    length needed for the insn scheduler.  */
end_comment

begin_function
specifier|static
name|void
name|output_max_insn_queue_index_def
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|max
decl_stmt|,
name|latency
decl_stmt|;
name|decl_t
name|decl
decl_stmt|;
name|max
operator|=
name|description
operator|->
name|max_insn_reserv_cycles
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_insn_reserv
operator|&&
name|decl
operator|!=
name|advance_cycle_insn_decl
condition|)
block|{
name|latency
operator|=
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|default_latency
expr_stmt|;
if|if
condition|(
name|latency
operator|>
name|max
condition|)
name|max
operator|=
name|latency
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_bypass
condition|)
block|{
name|latency
operator|=
name|DECL_BYPASS
argument_list|(
name|decl
argument_list|)
operator|->
name|latency
expr_stmt|;
if|if
condition|(
name|latency
operator|>
name|max
condition|)
name|max
operator|=
name|latency
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
literal|1
operator|<<
name|i
operator|)
operator|<=
name|max
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|gcc_assert
argument_list|(
name|i
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\nconst int max_insn_queue_index = %d;\n\n"
argument_list|,
operator|(
literal|1
operator|<<
name|i
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function outputs switch cases for insn reservations using    function *output_automata_list_code.  */
end_comment

begin_function
specifier|static
name|void
name|output_insn_code_cases
parameter_list|(
name|void
function_decl|(
modifier|*
name|output_automata_list_code
function_decl|)
parameter_list|(
name|automata_list_el_t
parameter_list|)
parameter_list|)
block|{
name|decl_t
name|decl
decl_stmt|,
name|decl2
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_insn_reserv
condition|)
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|processed_p
operator|=
name|FALSE
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_insn_reserv
operator|&&
operator|!
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|processed_p
condition|)
block|{
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|description
operator|->
name|decls_num
condition|;
name|j
operator|++
control|)
block|{
name|decl2
operator|=
name|description
operator|->
name|decls
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|decl2
operator|->
name|mode
operator|==
name|dm_insn_reserv
operator|&&
operator|(
name|DECL_INSN_RESERV
argument_list|(
name|decl2
argument_list|)
operator|->
name|important_automata_list
operator|==
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|important_automata_list
operator|)
condition|)
block|{
name|DECL_INSN_RESERV
argument_list|(
name|decl2
argument_list|)
operator|->
name|processed_p
operator|=
name|TRUE
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"    case %d: /* %s */\n"
argument_list|,
name|DECL_INSN_RESERV
argument_list|(
name|decl2
argument_list|)
operator|->
name|insn_num
argument_list|,
name|DECL_INSN_RESERV
argument_list|(
name|decl2
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
call|(
modifier|*
name|output_automata_list_code
call|)
argument_list|(
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|important_automata_list
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* The function outputs a code for evaluation of a minimal delay of    issue of insns which have reservations in given AUTOMATA_LIST.  */
end_comment

begin_function
specifier|static
name|void
name|output_automata_list_min_issue_delay_code
parameter_list|(
name|automata_list_el_t
name|automata_list
parameter_list|)
block|{
name|automata_list_el_t
name|el
decl_stmt|;
name|automaton_t
name|automaton
decl_stmt|;
for|for
control|(
name|el
operator|=
name|automata_list
init|;
name|el
operator|!=
name|NULL
condition|;
name|el
operator|=
name|el
operator|->
name|next_automata_list_el
control|)
block|{
name|automaton
operator|=
name|el
operator|->
name|automaton
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\n      %s = "
argument_list|,
name|TEMPORARY_VARIABLE_NAME
argument_list|)
expr_stmt|;
name|output_min_issue_delay_vect_name
argument_list|(
name|output_file
argument_list|,
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
operator|(
name|automaton
operator|->
name|min_issue_delay_table_compression_factor
operator|!=
literal|1
condition|?
literal|" [("
else|:
literal|" ["
operator|)
argument_list|)
expr_stmt|;
name|output_translate_vect_name
argument_list|(
name|output_file
argument_list|,
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" [%s] + "
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"%s->"
argument_list|,
name|CHIP_PARAMETER_NAME
argument_list|)
expr_stmt|;
name|output_chip_member_name
argument_list|(
name|output_file
argument_list|,
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" * %d"
argument_list|,
name|automaton
operator|->
name|insn_equiv_classes_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|automaton
operator|->
name|min_issue_delay_table_compression_factor
operator|==
literal|1
condition|)
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"];\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|") / %d];\n"
argument_list|,
name|automaton
operator|->
name|min_issue_delay_table_compression_factor
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"      %s = (%s>> (8 - ("
argument_list|,
name|TEMPORARY_VARIABLE_NAME
argument_list|,
name|TEMPORARY_VARIABLE_NAME
argument_list|)
expr_stmt|;
name|output_translate_vect_name
argument_list|(
name|output_file
argument_list|,
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" [%s] %% %d + 1) * %d))& %d;\n"
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|,
name|automaton
operator|->
name|min_issue_delay_table_compression_factor
argument_list|,
literal|8
operator|/
name|automaton
operator|->
name|min_issue_delay_table_compression_factor
argument_list|,
operator|(
literal|1
operator|<<
operator|(
literal|8
operator|/
name|automaton
operator|->
name|min_issue_delay_table_compression_factor
operator|)
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|el
operator|==
name|automata_list
condition|)
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"      %s = %s;\n"
argument_list|,
name|RESULT_VARIABLE_NAME
argument_list|,
name|TEMPORARY_VARIABLE_NAME
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"      if (%s> %s)\n"
argument_list|,
name|TEMPORARY_VARIABLE_NAME
argument_list|,
name|RESULT_VARIABLE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"        %s = %s;\n"
argument_list|,
name|RESULT_VARIABLE_NAME
argument_list|,
name|TEMPORARY_VARIABLE_NAME
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"      break;\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output function `internal_min_issue_delay'.  */
end_comment

begin_function
specifier|static
name|void
name|output_internal_min_issue_delay_func
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"static int\n%s (int %s, struct %s *%s ATTRIBUTE_UNUSED)\n"
argument_list|,
name|INTERNAL_MIN_ISSUE_DELAY_FUNC_NAME
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|,
name|CHIP_NAME
argument_list|,
name|CHIP_PARAMETER_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"{\n  int %s ATTRIBUTE_UNUSED;\n  int %s = -1;\n"
argument_list|,
name|TEMPORARY_VARIABLE_NAME
argument_list|,
name|RESULT_VARIABLE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\n  switch (%s)\n    {\n"
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|)
expr_stmt|;
name|output_insn_code_cases
argument_list|(
name|output_automata_list_min_issue_delay_code
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\n    default:\n      %s = -1;\n      break;\n    }\n"
argument_list|,
name|RESULT_VARIABLE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"  return %s;\n"
argument_list|,
name|RESULT_VARIABLE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"}\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function outputs a code changing state after issue of insns    which have reservations in given AUTOMATA_LIST.  */
end_comment

begin_function
specifier|static
name|void
name|output_automata_list_transition_code
parameter_list|(
name|automata_list_el_t
name|automata_list
parameter_list|)
block|{
name|automata_list_el_t
name|el
decl_stmt|,
name|next_el
decl_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"      {\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|automata_list
operator|!=
name|NULL
operator|&&
name|automata_list
operator|->
name|next_automata_list_el
operator|!=
name|NULL
condition|)
for|for
control|(
name|el
operator|=
name|automata_list
init|;
condition|;
name|el
operator|=
name|next_el
control|)
block|{
name|next_el
operator|=
name|el
operator|->
name|next_automata_list_el
expr_stmt|;
if|if
condition|(
name|next_el
operator|==
name|NULL
condition|)
break|break;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"        "
argument_list|)
expr_stmt|;
name|output_state_member_type
argument_list|(
name|output_file
argument_list|,
name|el
operator|->
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|output_temp_chip_member_name
argument_list|(
name|output_file
argument_list|,
name|el
operator|->
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|";\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|el
operator|=
name|automata_list
init|;
name|el
operator|!=
name|NULL
condition|;
name|el
operator|=
name|el
operator|->
name|next_automata_list_el
control|)
if|if
condition|(
name|comb_vect_p
argument_list|(
name|el
operator|->
name|automaton
operator|->
name|trans_table
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\n        %s = "
argument_list|,
name|TEMPORARY_VARIABLE_NAME
argument_list|)
expr_stmt|;
name|output_trans_base_vect_name
argument_list|(
name|output_file
argument_list|,
name|el
operator|->
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" [%s->"
argument_list|,
name|CHIP_PARAMETER_NAME
argument_list|)
expr_stmt|;
name|output_chip_member_name
argument_list|(
name|output_file
argument_list|,
name|el
operator|->
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"] + "
argument_list|)
expr_stmt|;
name|output_translate_vect_name
argument_list|(
name|output_file
argument_list|,
name|el
operator|->
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" [%s];\n"
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"        if ("
argument_list|)
expr_stmt|;
name|output_trans_check_vect_name
argument_list|(
name|output_file
argument_list|,
name|el
operator|->
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" [%s] != %s->"
argument_list|,
name|TEMPORARY_VARIABLE_NAME
argument_list|,
name|CHIP_PARAMETER_NAME
argument_list|)
expr_stmt|;
name|output_chip_member_name
argument_list|(
name|output_file
argument_list|,
name|el
operator|->
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"          return %s (%s, %s);\n"
argument_list|,
name|INTERNAL_MIN_ISSUE_DELAY_FUNC_NAME
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|,
name|CHIP_PARAMETER_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"        else\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"          "
argument_list|)
expr_stmt|;
if|if
condition|(
name|el
operator|->
name|next_automata_list_el
operator|!=
name|NULL
condition|)
name|output_temp_chip_member_name
argument_list|(
name|output_file
argument_list|,
name|el
operator|->
name|automaton
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"%s->"
argument_list|,
name|CHIP_PARAMETER_NAME
argument_list|)
expr_stmt|;
name|output_chip_member_name
argument_list|(
name|output_file
argument_list|,
name|el
operator|->
name|automaton
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" = "
argument_list|)
expr_stmt|;
name|output_trans_comb_vect_name
argument_list|(
name|output_file
argument_list|,
name|el
operator|->
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" [%s];\n"
argument_list|,
name|TEMPORARY_VARIABLE_NAME
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\n        %s = "
argument_list|,
name|TEMPORARY_VARIABLE_NAME
argument_list|)
expr_stmt|;
name|output_trans_full_vect_name
argument_list|(
name|output_file
argument_list|,
name|el
operator|->
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" ["
argument_list|)
expr_stmt|;
name|output_translate_vect_name
argument_list|(
name|output_file
argument_list|,
name|el
operator|->
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" [%s] + "
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"%s->"
argument_list|,
name|CHIP_PARAMETER_NAME
argument_list|)
expr_stmt|;
name|output_chip_member_name
argument_list|(
name|output_file
argument_list|,
name|el
operator|->
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" * %d];\n"
argument_list|,
name|el
operator|->
name|automaton
operator|->
name|insn_equiv_classes_num
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"        if (%s>= %d)\n"
argument_list|,
name|TEMPORARY_VARIABLE_NAME
argument_list|,
name|el
operator|->
name|automaton
operator|->
name|achieved_states_num
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"          return %s (%s, %s);\n"
argument_list|,
name|INTERNAL_MIN_ISSUE_DELAY_FUNC_NAME
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|,
name|CHIP_PARAMETER_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"        else\n          "
argument_list|)
expr_stmt|;
if|if
condition|(
name|el
operator|->
name|next_automata_list_el
operator|!=
name|NULL
condition|)
name|output_temp_chip_member_name
argument_list|(
name|output_file
argument_list|,
name|el
operator|->
name|automaton
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"%s->"
argument_list|,
name|CHIP_PARAMETER_NAME
argument_list|)
expr_stmt|;
name|output_chip_member_name
argument_list|(
name|output_file
argument_list|,
name|el
operator|->
name|automaton
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" = %s;\n"
argument_list|,
name|TEMPORARY_VARIABLE_NAME
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|automata_list
operator|!=
name|NULL
operator|&&
name|automata_list
operator|->
name|next_automata_list_el
operator|!=
name|NULL
condition|)
for|for
control|(
name|el
operator|=
name|automata_list
init|;
condition|;
name|el
operator|=
name|next_el
control|)
block|{
name|next_el
operator|=
name|el
operator|->
name|next_automata_list_el
expr_stmt|;
if|if
condition|(
name|next_el
operator|==
name|NULL
condition|)
break|break;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"        %s->"
argument_list|,
name|CHIP_PARAMETER_NAME
argument_list|)
expr_stmt|;
name|output_chip_member_name
argument_list|(
name|output_file
argument_list|,
name|el
operator|->
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" = "
argument_list|)
expr_stmt|;
name|output_temp_chip_member_name
argument_list|(
name|output_file
argument_list|,
name|el
operator|->
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|";\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"        return -1;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"      }\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output function `internal_state_transition'.  */
end_comment

begin_function
specifier|static
name|void
name|output_internal_trans_func
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"static int\n%s (int %s, struct %s *%s ATTRIBUTE_UNUSED)\n"
argument_list|,
name|INTERNAL_TRANSITION_FUNC_NAME
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|,
name|CHIP_NAME
argument_list|,
name|CHIP_PARAMETER_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"{\n  int %s ATTRIBUTE_UNUSED;\n"
argument_list|,
name|TEMPORARY_VARIABLE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\n  switch (%s)\n    {\n"
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|)
expr_stmt|;
name|output_insn_code_cases
argument_list|(
name|output_automata_list_transition_code
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\n    default:\n      return -1;\n    }\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"}\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output code    if (insn != 0)     {       insn_code = dfa_insn_code (insn);       if (insn_code> DFA__ADVANCE_CYCLE)         return code;     }   else     insn_code = DFA__ADVANCE_CYCLE;    where insn denotes INSN_NAME, insn_code denotes INSN_CODE_NAME, and   code denotes CODE.  */
end_comment

begin_function
specifier|static
name|void
name|output_internal_insn_code_evaluation
parameter_list|(
specifier|const
name|char
modifier|*
name|insn_name
parameter_list|,
specifier|const
name|char
modifier|*
name|insn_code_name
parameter_list|,
name|int
name|code
parameter_list|)
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\n  if (%s != 0)\n    {\n"
argument_list|,
name|insn_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"      %s = %s (%s);\n"
argument_list|,
name|insn_code_name
argument_list|,
name|DFA_INSN_CODE_FUNC_NAME
argument_list|,
name|insn_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"      if (%s> %s)\n        return %d;\n"
argument_list|,
name|insn_code_name
argument_list|,
name|ADVANCE_CYCLE_VALUE_NAME
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"    }\n  else\n    %s = %s;\n\n"
argument_list|,
name|insn_code_name
argument_list|,
name|ADVANCE_CYCLE_VALUE_NAME
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function outputs `dfa_insn_code' and its helper function    `dfa_insn_code_enlarge'.  */
end_comment

begin_function
specifier|static
name|void
name|output_dfa_insn_code_func
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Emacs c-mode gets really confused if there's a { or } in column 0      inside a string, so don't do that.  */
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\ static void\n\ dfa_insn_code_enlarge (int uid)\n\ {\n\   int i = %s;\n\   %s = 2 * uid;\n\   %s = xrealloc (%s,\n\                  %s * sizeof(int));\n\   for (; i< %s; i++)\n\     %s[i] = -1;\n}\n\n"
argument_list|,
name|DFA_INSN_CODES_LENGTH_VARIABLE_NAME
argument_list|,
name|DFA_INSN_CODES_LENGTH_VARIABLE_NAME
argument_list|,
name|DFA_INSN_CODES_VARIABLE_NAME
argument_list|,
name|DFA_INSN_CODES_VARIABLE_NAME
argument_list|,
name|DFA_INSN_CODES_LENGTH_VARIABLE_NAME
argument_list|,
name|DFA_INSN_CODES_LENGTH_VARIABLE_NAME
argument_list|,
name|DFA_INSN_CODES_VARIABLE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\ static inline int\n%s (rtx %s)\n\ {\n\   int uid = INSN_UID (%s);\n\   int %s;\n\n"
argument_list|,
name|DFA_INSN_CODE_FUNC_NAME
argument_list|,
name|INSN_PARAMETER_NAME
argument_list|,
name|INSN_PARAMETER_NAME
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"  if (uid>= %s)\n    dfa_insn_code_enlarge (uid);\n\n"
argument_list|,
name|DFA_INSN_CODES_LENGTH_VARIABLE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"  %s = %s[uid];\n"
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|,
name|DFA_INSN_CODES_VARIABLE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\   if (%s< 0)\n\     {\n\       %s = %s (%s);\n\       %s[uid] = %s;\n\     }\n"
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|,
name|INTERNAL_DFA_INSN_CODE_FUNC_NAME
argument_list|,
name|INSN_PARAMETER_NAME
argument_list|,
name|DFA_INSN_CODES_VARIABLE_NAME
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"  return %s;\n}\n\n"
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function outputs PHR interface function `state_transition'.  */
end_comment

begin_function
specifier|static
name|void
name|output_trans_func
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"int\n%s (%s %s, rtx %s)\n"
argument_list|,
name|TRANSITION_FUNC_NAME
argument_list|,
name|STATE_TYPE_NAME
argument_list|,
name|STATE_NAME
argument_list|,
name|INSN_PARAMETER_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"{\n  int %s;\n"
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|)
expr_stmt|;
name|output_internal_insn_code_evaluation
argument_list|(
name|INSN_PARAMETER_NAME
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"  return %s (%s, %s);\n}\n\n"
argument_list|,
name|INTERNAL_TRANSITION_FUNC_NAME
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|,
name|STATE_NAME
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output function `min_issue_delay'.  */
end_comment

begin_function
specifier|static
name|void
name|output_min_issue_delay_func
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"int\n%s (%s %s, rtx %s)\n"
argument_list|,
name|MIN_ISSUE_DELAY_FUNC_NAME
argument_list|,
name|STATE_TYPE_NAME
argument_list|,
name|STATE_NAME
argument_list|,
name|INSN_PARAMETER_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"{\n  int %s;\n"
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\n  if (%s != 0)\n    {\n"
argument_list|,
name|INSN_PARAMETER_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"      %s = %s (%s);\n"
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|,
name|DFA_INSN_CODE_FUNC_NAME
argument_list|,
name|INSN_PARAMETER_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"      if (%s> %s)\n        return 0;\n"
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|,
name|ADVANCE_CYCLE_VALUE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"    }\n  else\n    %s = %s;\n"
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|,
name|ADVANCE_CYCLE_VALUE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\n  return %s (%s, %s);\n"
argument_list|,
name|INTERNAL_MIN_ISSUE_DELAY_FUNC_NAME
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|,
name|STATE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"}\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output function `internal_dead_lock'.  */
end_comment

begin_function
specifier|static
name|void
name|output_internal_dead_lock_func
parameter_list|(
name|void
parameter_list|)
block|{
name|automaton_t
name|automaton
decl_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"static int\n%s (struct %s *ARG_UNUSED (%s))\n"
argument_list|,
name|INTERNAL_DEAD_LOCK_FUNC_NAME
argument_list|,
name|CHIP_NAME
argument_list|,
name|CHIP_PARAMETER_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"{\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|automaton
operator|=
name|description
operator|->
name|first_automaton
init|;
name|automaton
operator|!=
name|NULL
condition|;
name|automaton
operator|=
name|automaton
operator|->
name|next_automaton
control|)
if|if
condition|(
name|automaton
operator|->
name|locked_states
condition|)
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"  if ("
argument_list|)
expr_stmt|;
name|output_dead_lock_vect_name
argument_list|(
name|output_file
argument_list|,
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" [%s->"
argument_list|,
name|CHIP_PARAMETER_NAME
argument_list|)
expr_stmt|;
name|output_chip_member_name
argument_list|(
name|output_file
argument_list|,
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"])\n    return 1/* TRUE */;\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"  return 0/* FALSE */;\n}\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function outputs PHR interface function `state_dead_lock_p'.  */
end_comment

begin_function
specifier|static
name|void
name|output_dead_lock_func
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"int\n%s (%s %s)\n"
argument_list|,
name|DEAD_LOCK_FUNC_NAME
argument_list|,
name|STATE_TYPE_NAME
argument_list|,
name|STATE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"{\n  return %s (%s);\n}\n\n"
argument_list|,
name|INTERNAL_DEAD_LOCK_FUNC_NAME
argument_list|,
name|STATE_NAME
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output function `internal_reset'.  */
end_comment

begin_function
specifier|static
name|void
name|output_internal_reset_func
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"static inline void\n%s (struct %s *%s)\n"
argument_list|,
name|INTERNAL_RESET_FUNC_NAME
argument_list|,
name|CHIP_NAME
argument_list|,
name|CHIP_PARAMETER_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"{\n  memset (%s, 0, sizeof (struct %s));\n}\n\n"
argument_list|,
name|CHIP_PARAMETER_NAME
argument_list|,
name|CHIP_NAME
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function outputs PHR interface function `state_size'.  */
end_comment

begin_function
specifier|static
name|void
name|output_size_func
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"int\n%s (void)\n"
argument_list|,
name|SIZE_FUNC_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"{\n  return sizeof (struct %s);\n}\n\n"
argument_list|,
name|CHIP_NAME
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function outputs PHR interface function `state_reset'.  */
end_comment

begin_function
specifier|static
name|void
name|output_reset_func
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"void\n%s (%s %s)\n"
argument_list|,
name|RESET_FUNC_NAME
argument_list|,
name|STATE_TYPE_NAME
argument_list|,
name|STATE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"{\n  %s (%s);\n}\n\n"
argument_list|,
name|INTERNAL_RESET_FUNC_NAME
argument_list|,
name|STATE_NAME
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output function `min_insn_conflict_delay'.  */
end_comment

begin_function
specifier|static
name|void
name|output_min_insn_conflict_delay_func
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"int\n%s (%s %s, rtx %s, rtx %s)\n"
argument_list|,
name|MIN_INSN_CONFLICT_DELAY_FUNC_NAME
argument_list|,
name|STATE_TYPE_NAME
argument_list|,
name|STATE_NAME
argument_list|,
name|INSN_PARAMETER_NAME
argument_list|,
name|INSN2_PARAMETER_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"{\n  struct %s %s;\n  int %s, %s, transition;\n"
argument_list|,
name|CHIP_NAME
argument_list|,
name|CHIP_NAME
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|,
name|INTERNAL_INSN2_CODE_NAME
argument_list|)
expr_stmt|;
name|output_internal_insn_code_evaluation
argument_list|(
name|INSN_PARAMETER_NAME
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|output_internal_insn_code_evaluation
argument_list|(
name|INSN2_PARAMETER_NAME
argument_list|,
name|INTERNAL_INSN2_CODE_NAME
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"  memcpy (&%s, %s, sizeof (%s));\n"
argument_list|,
name|CHIP_NAME
argument_list|,
name|STATE_NAME
argument_list|,
name|CHIP_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"  %s (&%s);\n"
argument_list|,
name|INTERNAL_RESET_FUNC_NAME
argument_list|,
name|CHIP_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"  transition = %s (%s,&%s);\n"
argument_list|,
name|INTERNAL_TRANSITION_FUNC_NAME
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|,
name|CHIP_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"  gcc_assert (transition<= 0);\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"  return %s (%s,&%s);\n"
argument_list|,
name|INTERNAL_MIN_ISSUE_DELAY_FUNC_NAME
argument_list|,
name|INTERNAL_INSN2_CODE_NAME
argument_list|,
name|CHIP_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"}\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output function `internal_insn_latency'.  */
end_comment

begin_function
specifier|static
name|void
name|output_internal_insn_latency_func
parameter_list|(
name|void
parameter_list|)
block|{
name|decl_t
name|decl
decl_stmt|;
name|struct
name|bypass_decl
modifier|*
name|bypass
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|col
decl_stmt|;
specifier|const
name|char
modifier|*
name|tabletype
init|=
literal|"unsigned char"
decl_stmt|;
comment|/* Find the smallest integer type that can hold all the default      latency values.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|description
operator|->
name|decls
index|[
name|i
index|]
operator|->
name|mode
operator|==
name|dm_insn_reserv
condition|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|default_latency
operator|>
name|UCHAR_MAX
operator|&&
name|tabletype
index|[
literal|0
index|]
operator|!=
literal|'i'
condition|)
comment|/* Don't shrink it.  */
name|tabletype
operator|=
literal|"unsigned short"
expr_stmt|;
if|if
condition|(
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|default_latency
operator|>
name|USHRT_MAX
condition|)
name|tabletype
operator|=
literal|"int"
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"static int\n%s (int %s ATTRIBUTE_UNUSED,\n\tint %s ATTRIBUTE_UNUSED,\n\trtx %s ATTRIBUTE_UNUSED,\n\trtx %s ATTRIBUTE_UNUSED)\n"
argument_list|,
name|INTERNAL_INSN_LATENCY_FUNC_NAME
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|,
name|INTERNAL_INSN2_CODE_NAME
argument_list|,
name|INSN_PARAMETER_NAME
argument_list|,
name|INSN2_PARAMETER_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"{\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_INSN_RESERV
argument_list|(
name|advance_cycle_insn_decl
argument_list|)
operator|->
name|insn_num
operator|==
literal|0
condition|)
block|{
name|fputs
argument_list|(
literal|"  return 0;\n}\n\n"
argument_list|,
name|output_file
argument_list|)
expr_stmt|;
return|return;
block|}
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"  static const %s default_latencies[] =\n    {"
argument_list|,
name|tabletype
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
operator|,
name|col
operator|=
literal|7
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|description
operator|->
name|decls
index|[
name|i
index|]
operator|->
name|mode
operator|==
name|dm_insn_reserv
operator|&&
name|description
operator|->
name|decls
index|[
name|i
index|]
operator|!=
name|advance_cycle_insn_decl
condition|)
block|{
if|if
condition|(
operator|(
name|col
operator|=
operator|(
name|col
operator|+
literal|1
operator|)
operator|%
literal|8
operator|)
operator|==
literal|0
condition|)
name|fputs
argument_list|(
literal|"\n     "
argument_list|,
name|output_file
argument_list|)
expr_stmt|;
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
name|gcc_assert
argument_list|(
name|j
operator|++
operator|==
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|insn_num
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"% 4d,"
argument_list|,
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|default_latency
argument_list|)
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|j
operator|==
name|DECL_INSN_RESERV
argument_list|(
name|advance_cycle_insn_decl
argument_list|)
operator|->
name|insn_num
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n    };\n"
argument_list|,
name|output_file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"  if (%s>= %s || %s>= %s)\n    return 0;\n"
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|,
name|ADVANCE_CYCLE_VALUE_NAME
argument_list|,
name|INTERNAL_INSN2_CODE_NAME
argument_list|,
name|ADVANCE_CYCLE_VALUE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"  switch (%s)\n    {\n"
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|description
operator|->
name|decls
index|[
name|i
index|]
operator|->
name|mode
operator|==
name|dm_insn_reserv
operator|&&
name|DECL_INSN_RESERV
argument_list|(
name|description
operator|->
name|decls
index|[
name|i
index|]
argument_list|)
operator|->
name|bypass_list
condition|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"    case %d:\n      switch (%s)\n        {\n"
argument_list|,
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|insn_num
argument_list|,
name|INTERNAL_INSN2_CODE_NAME
argument_list|)
expr_stmt|;
for|for
control|(
name|bypass
operator|=
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|bypass_list
init|;
name|bypass
operator|!=
name|NULL
condition|;
name|bypass
operator|=
name|bypass
operator|->
name|next
control|)
block|{
name|gcc_assert
argument_list|(
name|bypass
operator|->
name|in_insn_reserv
operator|->
name|insn_num
operator|!=
operator|(
name|DECL_INSN_RESERV
argument_list|(
name|advance_cycle_insn_decl
argument_list|)
operator|->
name|insn_num
operator|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"        case %d:\n"
argument_list|,
name|bypass
operator|->
name|in_insn_reserv
operator|->
name|insn_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|bypass
operator|->
name|bypass_guard_name
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"          return %d;\n"
argument_list|,
name|bypass
operator|->
name|latency
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"          if (%s (%s, %s))\n"
argument_list|,
name|bypass
operator|->
name|bypass_guard_name
argument_list|,
name|INSN_PARAMETER_NAME
argument_list|,
name|INSN2_PARAMETER_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"            return %d;\n          break;\n"
argument_list|,
name|bypass
operator|->
name|latency
argument_list|)
expr_stmt|;
block|}
block|}
name|fputs
argument_list|(
literal|"        }\n      break;\n"
argument_list|,
name|output_file
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"    }\n  return default_latencies[%s];\n}\n\n"
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function outputs PHR interface function `insn_latency'.  */
end_comment

begin_function
specifier|static
name|void
name|output_insn_latency_func
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"int\n%s (rtx %s, rtx %s)\n"
argument_list|,
name|INSN_LATENCY_FUNC_NAME
argument_list|,
name|INSN_PARAMETER_NAME
argument_list|,
name|INSN2_PARAMETER_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"{\n  int %s, %s;\n"
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|,
name|INTERNAL_INSN2_CODE_NAME
argument_list|)
expr_stmt|;
name|output_internal_insn_code_evaluation
argument_list|(
name|INSN_PARAMETER_NAME
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|output_internal_insn_code_evaluation
argument_list|(
name|INSN2_PARAMETER_NAME
argument_list|,
name|INTERNAL_INSN2_CODE_NAME
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"  return %s (%s, %s, %s, %s);\n}\n\n"
argument_list|,
name|INTERNAL_INSN_LATENCY_FUNC_NAME
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|,
name|INTERNAL_INSN2_CODE_NAME
argument_list|,
name|INSN_PARAMETER_NAME
argument_list|,
name|INSN2_PARAMETER_NAME
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function outputs PHR interface function `print_reservation'.  */
end_comment

begin_function
specifier|static
name|void
name|output_print_reservation_func
parameter_list|(
name|void
parameter_list|)
block|{
name|decl_t
name|decl
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"void\n%s (FILE *%s, rtx %s ATTRIBUTE_UNUSED)\n{\n"
argument_list|,
name|PRINT_RESERVATION_FUNC_NAME
argument_list|,
name|FILE_PARAMETER_NAME
argument_list|,
name|INSN_PARAMETER_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_INSN_RESERV
argument_list|(
name|advance_cycle_insn_decl
argument_list|)
operator|->
name|insn_num
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"  fputs (\"%s\", %s);\n}\n\n"
argument_list|,
name|NOTHING_NAME
argument_list|,
name|FILE_PARAMETER_NAME
argument_list|)
expr_stmt|;
return|return;
block|}
name|fputs
argument_list|(
literal|"  static const char *const reservation_names[] =\n    {"
argument_list|,
name|output_file
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_insn_reserv
operator|&&
name|decl
operator|!=
name|advance_cycle_insn_decl
condition|)
block|{
name|gcc_assert
argument_list|(
name|j
operator|==
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|insn_num
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\n      \"%s\","
argument_list|,
name|regexp_representation
argument_list|(
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|regexp
argument_list|)
argument_list|)
expr_stmt|;
name|finish_regexp_representation
argument_list|()
expr_stmt|;
block|}
block|}
name|gcc_assert
argument_list|(
name|j
operator|==
name|DECL_INSN_RESERV
argument_list|(
name|advance_cycle_insn_decl
argument_list|)
operator|->
name|insn_num
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\n      \"%s\"\n    };\n  int %s;\n\n"
argument_list|,
name|NOTHING_NAME
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"  if (%s == 0)\n    %s = %s;\n"
argument_list|,
name|INSN_PARAMETER_NAME
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|,
name|ADVANCE_CYCLE_VALUE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"  else\n\     {\n\       %s = %s (%s);\n\       if (%s> %s)\n\         %s = %s;\n\     }\n"
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|,
name|DFA_INSN_CODE_FUNC_NAME
argument_list|,
name|INSN_PARAMETER_NAME
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|,
name|ADVANCE_CYCLE_VALUE_NAME
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|,
name|ADVANCE_CYCLE_VALUE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"  fputs (reservation_names[%s], %s);\n}\n\n"
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|,
name|FILE_PARAMETER_NAME
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The following function is used to sort unit declaration by their    names.  */
end_comment

begin_function
specifier|static
name|int
name|units_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|unit1
parameter_list|,
specifier|const
name|void
modifier|*
name|unit2
parameter_list|)
block|{
specifier|const
name|unit_decl_t
name|u1
init|=
operator|*
operator|(
name|unit_decl_t
operator|*
operator|)
name|unit1
decl_stmt|;
specifier|const
name|unit_decl_t
name|u2
init|=
operator|*
operator|(
name|unit_decl_t
operator|*
operator|)
name|unit2
decl_stmt|;
return|return
name|strcmp
argument_list|(
name|u1
operator|->
name|name
argument_list|,
name|u2
operator|->
name|name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The following macro value is name of struct containing unit name    and unit code.  */
end_comment

begin_define
define|#
directive|define
name|NAME_CODE_STRUCT_NAME
value|"name_code"
end_define

begin_comment
comment|/* The following macro value is name of table of struct name_code.  */
end_comment

begin_define
define|#
directive|define
name|NAME_CODE_TABLE_NAME
value|"name_code_table"
end_define

begin_comment
comment|/* The following macro values are member names for struct name_code.  */
end_comment

begin_define
define|#
directive|define
name|NAME_MEMBER_NAME
value|"name"
end_define

begin_define
define|#
directive|define
name|CODE_MEMBER_NAME
value|"code"
end_define

begin_comment
comment|/* The following macro values are local variable names for function    `get_cpu_unit_code'.  */
end_comment

begin_define
define|#
directive|define
name|CMP_VARIABLE_NAME
value|"cmp"
end_define

begin_define
define|#
directive|define
name|LOW_VARIABLE_NAME
value|"l"
end_define

begin_define
define|#
directive|define
name|MIDDLE_VARIABLE_NAME
value|"m"
end_define

begin_define
define|#
directive|define
name|HIGH_VARIABLE_NAME
value|"h"
end_define

begin_comment
comment|/* The following function outputs function to obtain internal cpu unit    code by the cpu unit name.  */
end_comment

begin_function
specifier|static
name|void
name|output_get_cpu_unit_code_func
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|unit_decl_t
modifier|*
name|units
decl_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"int\n%s (const char *%s)\n"
argument_list|,
name|GET_CPU_UNIT_CODE_FUNC_NAME
argument_list|,
name|CPU_UNIT_NAME_PARAMETER_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"{\n  struct %s {const char *%s; int %s;};\n"
argument_list|,
name|NAME_CODE_STRUCT_NAME
argument_list|,
name|NAME_MEMBER_NAME
argument_list|,
name|CODE_MEMBER_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"  int %s, %s, %s, %s;\n"
argument_list|,
name|CMP_VARIABLE_NAME
argument_list|,
name|LOW_VARIABLE_NAME
argument_list|,
name|MIDDLE_VARIABLE_NAME
argument_list|,
name|HIGH_VARIABLE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"  static struct %s %s [] =\n    {\n"
argument_list|,
name|NAME_CODE_STRUCT_NAME
argument_list|,
name|NAME_CODE_TABLE_NAME
argument_list|)
expr_stmt|;
name|units
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|unit_decl_t
argument_list|)
operator|*
name|description
operator|->
name|units_num
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|units
argument_list|,
name|units_array
argument_list|,
sizeof|sizeof
argument_list|(
name|unit_decl_t
argument_list|)
operator|*
name|description
operator|->
name|units_num
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|units
argument_list|,
name|description
operator|->
name|units_num
argument_list|,
sizeof|sizeof
argument_list|(
name|unit_decl_t
argument_list|)
argument_list|,
name|units_cmp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|units_num
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|units
index|[
name|i
index|]
operator|->
name|query_p
condition|)
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"      {\"%s\", %d},\n"
argument_list|,
name|units
index|[
name|i
index|]
operator|->
name|name
argument_list|,
name|units
index|[
name|i
index|]
operator|->
name|query_num
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"    };\n\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"  /* The following is binary search: */\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"  %s = 0;\n"
argument_list|,
name|LOW_VARIABLE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"  %s = sizeof (%s) / sizeof (struct %s) - 1;\n"
argument_list|,
name|HIGH_VARIABLE_NAME
argument_list|,
name|NAME_CODE_TABLE_NAME
argument_list|,
name|NAME_CODE_STRUCT_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"  while (%s<= %s)\n    {\n"
argument_list|,
name|LOW_VARIABLE_NAME
argument_list|,
name|HIGH_VARIABLE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"      %s = (%s + %s) / 2;\n"
argument_list|,
name|MIDDLE_VARIABLE_NAME
argument_list|,
name|LOW_VARIABLE_NAME
argument_list|,
name|HIGH_VARIABLE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"      %s = strcmp (%s, %s [%s].%s);\n"
argument_list|,
name|CMP_VARIABLE_NAME
argument_list|,
name|CPU_UNIT_NAME_PARAMETER_NAME
argument_list|,
name|NAME_CODE_TABLE_NAME
argument_list|,
name|MIDDLE_VARIABLE_NAME
argument_list|,
name|NAME_MEMBER_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"      if (%s< 0)\n"
argument_list|,
name|CMP_VARIABLE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"        %s = %s - 1;\n"
argument_list|,
name|HIGH_VARIABLE_NAME
argument_list|,
name|MIDDLE_VARIABLE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"      else if (%s> 0)\n"
argument_list|,
name|CMP_VARIABLE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"        %s = %s + 1;\n"
argument_list|,
name|LOW_VARIABLE_NAME
argument_list|,
name|MIDDLE_VARIABLE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"      else\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"        return %s [%s].%s;\n    }\n"
argument_list|,
name|NAME_CODE_TABLE_NAME
argument_list|,
name|MIDDLE_VARIABLE_NAME
argument_list|,
name|CODE_MEMBER_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"  return -1;\n}\n\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|units
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The following function outputs function to check reservation of cpu    unit (its internal code will be passed as the function argument) in    given cpu state.  */
end_comment

begin_function
specifier|static
name|void
name|output_cpu_unit_reservation_p
parameter_list|(
name|void
parameter_list|)
block|{
name|automaton_t
name|automaton
decl_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"int\n%s (%s %s, int %s)\n"
argument_list|,
name|CPU_UNIT_RESERVATION_P_FUNC_NAME
argument_list|,
name|STATE_TYPE_NAME
argument_list|,
name|STATE_NAME
argument_list|,
name|CPU_CODE_PARAMETER_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"{\n  gcc_assert (%s>= 0&& %s< %d);\n"
argument_list|,
name|CPU_CODE_PARAMETER_NAME
argument_list|,
name|CPU_CODE_PARAMETER_NAME
argument_list|,
name|description
operator|->
name|query_units_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|description
operator|->
name|query_units_num
operator|>
literal|0
condition|)
for|for
control|(
name|automaton
operator|=
name|description
operator|->
name|first_automaton
init|;
name|automaton
operator|!=
name|NULL
condition|;
name|automaton
operator|=
name|automaton
operator|->
name|next_automaton
control|)
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"  if (("
argument_list|)
expr_stmt|;
name|output_reserved_units_table_name
argument_list|(
name|output_file
argument_list|,
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" [((struct %s *) %s)->"
argument_list|,
name|CHIP_NAME
argument_list|,
name|STATE_NAME
argument_list|)
expr_stmt|;
name|output_chip_member_name
argument_list|(
name|output_file
argument_list|,
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" * %d + %s / 8]>> (%s %% 8))& 1)\n"
argument_list|,
operator|(
name|description
operator|->
name|query_units_num
operator|+
literal|7
operator|)
operator|/
literal|8
argument_list|,
name|CPU_CODE_PARAMETER_NAME
argument_list|,
name|CPU_CODE_PARAMETER_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"    return 1;\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"  return 0;\n}\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function outputs PHR interface functions `dfa_clean_insn_cache'    and 'dfa_clear_single_insn_cache'.  */
end_comment

begin_function
specifier|static
name|void
name|output_dfa_clean_insn_cache_func
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"void\n%s (void)\n{\n  int %s;\n\n"
argument_list|,
name|DFA_CLEAN_INSN_CACHE_FUNC_NAME
argument_list|,
name|I_VARIABLE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"  for (%s = 0; %s< %s; %s++)\n    %s [%s] = -1;\n}\n\n"
argument_list|,
name|I_VARIABLE_NAME
argument_list|,
name|I_VARIABLE_NAME
argument_list|,
name|DFA_INSN_CODES_LENGTH_VARIABLE_NAME
argument_list|,
name|I_VARIABLE_NAME
argument_list|,
name|DFA_INSN_CODES_VARIABLE_NAME
argument_list|,
name|I_VARIABLE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"void\n%s (rtx %s)\n{\n  int %s;\n\n"
argument_list|,
name|DFA_CLEAR_SINGLE_INSN_CACHE_FUNC_NAME
argument_list|,
name|INSN_PARAMETER_NAME
argument_list|,
name|I_VARIABLE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"  %s = INSN_UID (%s);\n  if (%s< %s)\n    %s [%s] = -1;\n}\n\n"
argument_list|,
name|I_VARIABLE_NAME
argument_list|,
name|INSN_PARAMETER_NAME
argument_list|,
name|I_VARIABLE_NAME
argument_list|,
name|DFA_INSN_CODES_LENGTH_VARIABLE_NAME
argument_list|,
name|DFA_INSN_CODES_VARIABLE_NAME
argument_list|,
name|I_VARIABLE_NAME
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function outputs PHR interface function `dfa_start'.  */
end_comment

begin_function
specifier|static
name|void
name|output_dfa_start_func
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"void\n%s (void)\n{\n  %s = get_max_uid ();\n"
argument_list|,
name|DFA_START_FUNC_NAME
argument_list|,
name|DFA_INSN_CODES_LENGTH_VARIABLE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"  %s = xmalloc (%s * sizeof (int));\n"
argument_list|,
name|DFA_INSN_CODES_VARIABLE_NAME
argument_list|,
name|DFA_INSN_CODES_LENGTH_VARIABLE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"  %s ();\n}\n\n"
argument_list|,
name|DFA_CLEAN_INSN_CACHE_FUNC_NAME
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function outputs PHR interface function `dfa_finish'.  */
end_comment

begin_function
specifier|static
name|void
name|output_dfa_finish_func
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"void\n%s (void)\n{\n  free (%s);\n}\n\n"
argument_list|,
name|DFA_FINISH_FUNC_NAME
argument_list|,
name|DFA_INSN_CODES_VARIABLE_NAME
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The page contains code for output description file (readable    representation of original description and generated DFA(s).  */
end_comment

begin_comment
comment|/* The function outputs string representation of IR reservation.  */
end_comment

begin_function
specifier|static
name|void
name|output_regexp
parameter_list|(
name|regexp_t
name|regexp
parameter_list|)
block|{
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|"%s"
argument_list|,
name|regexp_representation
argument_list|(
name|regexp
argument_list|)
argument_list|)
expr_stmt|;
name|finish_regexp_representation
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output names of units in LIST separated by comma.  */
end_comment

begin_function
specifier|static
name|void
name|output_unit_set_el_list
parameter_list|(
name|unit_set_el_t
name|list
parameter_list|)
block|{
name|unit_set_el_t
name|el
decl_stmt|;
for|for
control|(
name|el
operator|=
name|list
init|;
name|el
operator|!=
name|NULL
condition|;
name|el
operator|=
name|el
operator|->
name|next_unit_set_el
control|)
block|{
if|if
condition|(
name|el
operator|!=
name|list
condition|)
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|"%s"
argument_list|,
name|el
operator|->
name|unit_decl
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output patterns in LIST separated by comma.  */
end_comment

begin_function
specifier|static
name|void
name|output_pattern_set_el_list
parameter_list|(
name|pattern_set_el_t
name|list
parameter_list|)
block|{
name|pattern_set_el_t
name|el
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|el
operator|=
name|list
init|;
name|el
operator|!=
name|NULL
condition|;
name|el
operator|=
name|el
operator|->
name|next_pattern_set_el
control|)
block|{
if|if
condition|(
name|el
operator|!=
name|list
condition|)
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|el
operator|->
name|units_num
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
operator|(
name|i
operator|==
literal|0
condition|?
literal|"%s"
else|:
literal|" %s"
operator|)
argument_list|,
name|el
operator|->
name|unit_decls
index|[
name|i
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The function outputs string representation of IR define_reservation    and define_insn_reservation.  */
end_comment

begin_function
specifier|static
name|void
name|output_description
parameter_list|(
name|void
parameter_list|)
block|{
name|decl_t
name|decl
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_unit
condition|)
block|{
if|if
condition|(
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|excl_list
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|"unit %s exlusion_set: "
argument_list|,
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
name|output_unit_set_el_list
argument_list|(
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|excl_list
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|presence_list
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|"unit %s presence_set: "
argument_list|,
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
name|output_pattern_set_el_list
argument_list|(
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|presence_list
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|final_presence_list
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|"unit %s final_presence_set: "
argument_list|,
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
name|output_pattern_set_el_list
argument_list|(
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|final_presence_list
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|absence_list
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|"unit %s absence_set: "
argument_list|,
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
name|output_pattern_set_el_list
argument_list|(
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|absence_list
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|final_absence_list
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|"unit %s final_absence_set: "
argument_list|,
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
name|output_pattern_set_el_list
argument_list|(
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|final_absence_list
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_reserv
condition|)
block|{
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|"reservation %s: "
argument_list|,
name|DECL_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
name|output_regexp
argument_list|(
name|DECL_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|regexp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_insn_reserv
operator|&&
name|decl
operator|!=
name|advance_cycle_insn_decl
condition|)
block|{
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|"insn reservation %s "
argument_list|,
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
name|print_rtl
argument_list|(
name|output_description_file
argument_list|,
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|condexp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|": "
argument_list|)
expr_stmt|;
name|output_regexp
argument_list|(
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|regexp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_bypass
condition|)
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|"bypass %d %s %s\n"
argument_list|,
name|DECL_BYPASS
argument_list|(
name|decl
argument_list|)
operator|->
name|latency
argument_list|,
name|DECL_BYPASS
argument_list|(
name|decl
argument_list|)
operator|->
name|out_insn_name
argument_list|,
name|DECL_BYPASS
argument_list|(
name|decl
argument_list|)
operator|->
name|in_insn_name
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|"\n\f\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function outputs name of AUTOMATON.  */
end_comment

begin_function
specifier|static
name|void
name|output_automaton_name
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|automaton_t
name|automaton
parameter_list|)
block|{
if|if
condition|(
name|automaton
operator|->
name|corresponding_automaton_decl
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"#%d"
argument_list|,
name|automaton
operator|->
name|automaton_order_num
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"`%s'"
argument_list|,
name|automaton
operator|->
name|corresponding_automaton_decl
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Maximal length of line for pretty printing into description    file.  */
end_comment

begin_define
define|#
directive|define
name|MAX_LINE_LENGTH
value|70
end_define

begin_comment
comment|/* The function outputs units name belonging to AUTOMATON.  */
end_comment

begin_function
specifier|static
name|void
name|output_automaton_units
parameter_list|(
name|automaton_t
name|automaton
parameter_list|)
block|{
name|decl_t
name|decl
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|curr_line_length
decl_stmt|;
name|int
name|there_is_an_automaton_unit
decl_stmt|;
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|"\n  Corresponding units:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|"    "
argument_list|)
expr_stmt|;
name|curr_line_length
operator|=
literal|4
expr_stmt|;
name|there_is_an_automaton_unit
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_unit
operator|&&
operator|(
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|corresponding_automaton_num
operator|==
name|automaton
operator|->
name|automaton_order_num
operator|)
condition|)
block|{
name|there_is_an_automaton_unit
operator|=
literal|1
expr_stmt|;
name|name
operator|=
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|name
expr_stmt|;
if|if
condition|(
name|curr_line_length
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
operator|>
name|MAX_LINE_LENGTH
condition|)
block|{
name|curr_line_length
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|4
expr_stmt|;
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|"\n    "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|curr_line_length
operator|+=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|there_is_an_automaton_unit
condition|)
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|"<None>"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The following variable is used for forming array of all possible cpu unit    reservations described by the current DFA state.  */
end_comment

begin_expr_stmt
specifier|static
name|VEC
argument_list|(
name|reserv_sets_t
argument_list|,
name|heap
argument_list|)
operator|*
name|state_reservs
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* The function forms `state_reservs' for STATE.  */
end_comment

begin_function
specifier|static
name|void
name|add_state_reservs
parameter_list|(
name|state_t
name|state
parameter_list|)
block|{
name|alt_state_t
name|curr_alt_state
decl_stmt|;
if|if
condition|(
name|state
operator|->
name|component_states
operator|!=
name|NULL
condition|)
for|for
control|(
name|curr_alt_state
operator|=
name|state
operator|->
name|component_states
init|;
name|curr_alt_state
operator|!=
name|NULL
condition|;
name|curr_alt_state
operator|=
name|curr_alt_state
operator|->
name|next_sorted_alt_state
control|)
name|add_state_reservs
argument_list|(
name|curr_alt_state
operator|->
name|state
argument_list|)
expr_stmt|;
else|else
name|VEC_safe_push
argument_list|(
name|reserv_sets_t
argument_list|,
name|heap
argument_list|,
name|state_reservs
argument_list|,
name|state
operator|->
name|reservs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function outputs readable representation of all out arcs of    STATE.  */
end_comment

begin_function
specifier|static
name|void
name|output_state_arcs
parameter_list|(
name|state_t
name|state
parameter_list|)
block|{
name|arc_t
name|arc
decl_stmt|;
name|ainsn_t
name|ainsn
decl_stmt|;
specifier|const
name|char
modifier|*
name|insn_name
decl_stmt|;
name|int
name|curr_line_length
decl_stmt|;
for|for
control|(
name|arc
operator|=
name|first_out_arc
argument_list|(
name|state
argument_list|)
init|;
name|arc
operator|!=
name|NULL
condition|;
name|arc
operator|=
name|next_out_arc
argument_list|(
name|arc
argument_list|)
control|)
block|{
name|ainsn
operator|=
name|arc
operator|->
name|insn
expr_stmt|;
name|gcc_assert
argument_list|(
name|ainsn
operator|->
name|first_insn_with_same_reservs
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|"    "
argument_list|)
expr_stmt|;
name|curr_line_length
operator|=
literal|7
expr_stmt|;
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|"%2d: "
argument_list|,
name|ainsn
operator|->
name|insn_equiv_class_num
argument_list|)
expr_stmt|;
do|do
block|{
name|insn_name
operator|=
name|ainsn
operator|->
name|insn_reserv_decl
operator|->
name|name
expr_stmt|;
if|if
condition|(
name|curr_line_length
operator|+
name|strlen
argument_list|(
name|insn_name
argument_list|)
operator|>
name|MAX_LINE_LENGTH
condition|)
block|{
if|if
condition|(
name|ainsn
operator|!=
name|arc
operator|->
name|insn
condition|)
block|{
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|",\n      "
argument_list|)
expr_stmt|;
name|curr_line_length
operator|=
name|strlen
argument_list|(
name|insn_name
argument_list|)
operator|+
literal|6
expr_stmt|;
block|}
else|else
name|curr_line_length
operator|+=
name|strlen
argument_list|(
name|insn_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|curr_line_length
operator|+=
name|strlen
argument_list|(
name|insn_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ainsn
operator|!=
name|arc
operator|->
name|insn
condition|)
block|{
name|curr_line_length
operator|+=
literal|2
expr_stmt|;
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|"%s"
argument_list|,
name|insn_name
argument_list|)
expr_stmt|;
name|ainsn
operator|=
name|ainsn
operator|->
name|next_same_reservs_insn
expr_stmt|;
block|}
do|while
condition|(
name|ainsn
operator|!=
name|NULL
condition|)
do|;
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|"    %d \n"
argument_list|,
name|arc
operator|->
name|to_state
operator|->
name|order_state_num
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The following function is used for sorting possible cpu unit    reservation of a DFA state.  */
end_comment

begin_function
specifier|static
name|int
name|state_reservs_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|reservs_ptr_1
parameter_list|,
specifier|const
name|void
modifier|*
name|reservs_ptr_2
parameter_list|)
block|{
return|return
name|reserv_sets_cmp
argument_list|(
operator|*
operator|(
name|reserv_sets_t
operator|*
operator|)
name|reservs_ptr_1
argument_list|,
operator|*
operator|(
name|reserv_sets_t
operator|*
operator|)
name|reservs_ptr_2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The following function is used for sorting possible cpu unit    reservation of a DFA state.  */
end_comment

begin_function
specifier|static
name|void
name|remove_state_duplicate_reservs
parameter_list|(
name|void
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|VEC_length
argument_list|(
name|reserv_sets_t
argument_list|,
name|state_reservs
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reserv_sets_cmp
argument_list|(
name|VEC_index
argument_list|(
name|reserv_sets_t
argument_list|,
name|state_reservs
argument_list|,
name|j
argument_list|)
argument_list|,
name|VEC_index
argument_list|(
name|reserv_sets_t
argument_list|,
name|state_reservs
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|j
operator|++
expr_stmt|;
name|VEC_replace
argument_list|(
name|reserv_sets_t
argument_list|,
name|state_reservs
argument_list|,
name|j
argument_list|,
name|VEC_index
argument_list|(
name|reserv_sets_t
argument_list|,
name|state_reservs
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|VEC_truncate
argument_list|(
name|reserv_sets_t
argument_list|,
name|state_reservs
argument_list|,
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The following function output readable representation of DFA(s)    state used for fast recognition of pipeline hazards.  State is    described by possible (current and scheduled) cpu unit    reservations.  */
end_comment

begin_function
specifier|static
name|void
name|output_state
parameter_list|(
name|state_t
name|state
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|state_reservs
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|"  State #%d"
argument_list|,
name|state
operator|->
name|order_state_num
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
name|state
operator|->
name|new_cycle_p
condition|?
literal|" (new cycle)\n"
else|:
literal|"\n"
argument_list|)
expr_stmt|;
name|add_state_reservs
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|VEC_address
argument_list|(
name|reserv_sets_t
argument_list|,
name|state_reservs
argument_list|)
argument_list|,
name|VEC_length
argument_list|(
name|reserv_sets_t
argument_list|,
name|state_reservs
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|reserv_sets_t
argument_list|)
argument_list|,
name|state_reservs_cmp
argument_list|)
expr_stmt|;
name|remove_state_duplicate_reservs
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|VEC_length
argument_list|(
name|reserv_sets_t
argument_list|,
name|state_reservs
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|"    "
argument_list|)
expr_stmt|;
name|output_reserv_sets
argument_list|(
name|output_description_file
argument_list|,
name|VEC_index
argument_list|(
name|reserv_sets_t
argument_list|,
name|state_reservs
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|output_state_arcs
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|reserv_sets_t
argument_list|,
name|heap
argument_list|,
name|state_reservs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The following function output readable representation of    DFAs used for fast recognition of pipeline hazards.  */
end_comment

begin_function
specifier|static
name|void
name|output_automaton_descriptions
parameter_list|(
name|void
parameter_list|)
block|{
name|automaton_t
name|automaton
decl_stmt|;
for|for
control|(
name|automaton
operator|=
name|description
operator|->
name|first_automaton
init|;
name|automaton
operator|!=
name|NULL
condition|;
name|automaton
operator|=
name|automaton
operator|->
name|next_automaton
control|)
block|{
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|"\nAutomaton "
argument_list|)
expr_stmt|;
name|output_automaton_name
argument_list|(
name|output_description_file
argument_list|,
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|output_automaton_units
argument_list|(
name|automaton
argument_list|)
expr_stmt|;
name|pass_states
argument_list|(
name|automaton
argument_list|,
name|output_state
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The page contains top level function for generation DFA(s) used for    PHR.  */
end_comment

begin_comment
comment|/* The function outputs statistics about work of different phases of    DFA generator.  */
end_comment

begin_function
specifier|static
name|void
name|output_statistics
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|)
block|{
name|automaton_t
name|automaton
decl_stmt|;
name|int
name|states_num
decl_stmt|;
ifndef|#
directive|ifndef
name|NDEBUG
name|int
name|transition_comb_vect_els
init|=
literal|0
decl_stmt|;
name|int
name|transition_full_vect_els
init|=
literal|0
decl_stmt|;
name|int
name|min_issue_delay_vect_els
init|=
literal|0
decl_stmt|;
name|int
name|locked_states
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
for|for
control|(
name|automaton
operator|=
name|description
operator|->
name|first_automaton
init|;
name|automaton
operator|!=
name|NULL
condition|;
name|automaton
operator|=
name|automaton
operator|->
name|next_automaton
control|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\nAutomaton "
argument_list|)
expr_stmt|;
name|output_automaton_name
argument_list|(
name|f
argument_list|,
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n    %5d NDFA states,          %5d NDFA arcs\n"
argument_list|,
name|automaton
operator|->
name|NDFA_states_num
argument_list|,
name|automaton
operator|->
name|NDFA_arcs_num
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"    %5d DFA states,           %5d DFA arcs\n"
argument_list|,
name|automaton
operator|->
name|DFA_states_num
argument_list|,
name|automaton
operator|->
name|DFA_arcs_num
argument_list|)
expr_stmt|;
name|states_num
operator|=
name|automaton
operator|->
name|DFA_states_num
expr_stmt|;
if|if
condition|(
operator|!
name|no_minimization_flag
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"    %5d minimal DFA states,   %5d minimal DFA arcs\n"
argument_list|,
name|automaton
operator|->
name|minimal_DFA_states_num
argument_list|,
name|automaton
operator|->
name|minimal_DFA_arcs_num
argument_list|)
expr_stmt|;
name|states_num
operator|=
name|automaton
operator|->
name|minimal_DFA_states_num
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"    %5d all insns      %5d insn equivalence classes\n"
argument_list|,
name|description
operator|->
name|insns_num
argument_list|,
name|automaton
operator|->
name|insn_equiv_classes_num
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"    %d locked states\n"
argument_list|,
name|automaton
operator|->
name|locked_states
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NDEBUG
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%5ld transition comb vector els, %5ld trans table els: %s\n"
argument_list|,
operator|(
name|long
operator|)
name|VEC_length
argument_list|(
name|vect_el_t
argument_list|,
name|automaton
operator|->
name|trans_table
operator|->
name|comb_vect
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|VEC_length
argument_list|(
name|vect_el_t
argument_list|,
name|automaton
operator|->
name|trans_table
operator|->
name|full_vect
argument_list|)
argument_list|,
operator|(
name|comb_vect_p
argument_list|(
name|automaton
operator|->
name|trans_table
argument_list|)
condition|?
literal|"use comb vect"
else|:
literal|"use simple vect"
operator|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%5ld min delay table els, compression factor %d\n"
argument_list|,
operator|(
name|long
operator|)
name|states_num
operator|*
name|automaton
operator|->
name|insn_equiv_classes_num
argument_list|,
name|automaton
operator|->
name|min_issue_delay_table_compression_factor
argument_list|)
expr_stmt|;
name|transition_comb_vect_els
operator|+=
name|VEC_length
argument_list|(
name|vect_el_t
argument_list|,
name|automaton
operator|->
name|trans_table
operator|->
name|comb_vect
argument_list|)
expr_stmt|;
name|transition_full_vect_els
operator|+=
name|VEC_length
argument_list|(
name|vect_el_t
argument_list|,
name|automaton
operator|->
name|trans_table
operator|->
name|full_vect
argument_list|)
expr_stmt|;
name|min_issue_delay_vect_els
operator|+=
name|states_num
operator|*
name|automaton
operator|->
name|insn_equiv_classes_num
expr_stmt|;
name|locked_states
operator|+=
name|automaton
operator|->
name|locked_states
expr_stmt|;
endif|#
directive|endif
block|}
ifndef|#
directive|ifndef
name|NDEBUG
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n%5d all allocated states,     %5d all allocated arcs\n"
argument_list|,
name|allocated_states_num
argument_list|,
name|allocated_arcs_num
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%5d all allocated alternative states\n"
argument_list|,
name|allocated_alt_states_num
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%5d all transition comb vector els, %5d all trans table els\n"
argument_list|,
name|transition_comb_vect_els
argument_list|,
name|transition_full_vect_els
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%5d all min delay table els\n"
argument_list|,
name|min_issue_delay_vect_els
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%5d all locked states\n"
argument_list|,
name|locked_states
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* The function output times of work of different phases of DFA    generator.  */
end_comment

begin_function
specifier|static
name|void
name|output_time_statistics
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n  transformation: "
argument_list|)
expr_stmt|;
name|print_active_time
argument_list|(
name|f
argument_list|,
name|transform_time
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
operator|(
operator|!
name|ndfa_flag
condition|?
literal|", building DFA: "
else|:
literal|", building NDFA: "
operator|)
argument_list|)
expr_stmt|;
name|print_active_time
argument_list|(
name|f
argument_list|,
name|NDFA_time
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndfa_flag
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|", NDFA -> DFA: "
argument_list|)
expr_stmt|;
name|print_active_time
argument_list|(
name|f
argument_list|,
name|NDFA_to_DFA_time
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n  DFA minimization: "
argument_list|)
expr_stmt|;
name|print_active_time
argument_list|(
name|f
argument_list|,
name|minimize_time
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|", making insn equivalence: "
argument_list|)
expr_stmt|;
name|print_active_time
argument_list|(
name|f
argument_list|,
name|equiv_time
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n all automaton generation: "
argument_list|)
expr_stmt|;
name|print_active_time
argument_list|(
name|f
argument_list|,
name|automaton_generation_time
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|", output: "
argument_list|)
expr_stmt|;
name|print_active_time
argument_list|(
name|f
argument_list|,
name|output_time
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function generates DFA (deterministic finite state automaton)    for fast recognition of pipeline hazards.  No errors during    checking must be fixed before this function call.  */
end_comment

begin_function
specifier|static
name|void
name|generate
parameter_list|(
name|void
parameter_list|)
block|{
name|automata_num
operator|=
name|split_argument
expr_stmt|;
if|if
condition|(
name|description
operator|->
name|units_num
operator|<
name|automata_num
condition|)
name|automata_num
operator|=
name|description
operator|->
name|units_num
expr_stmt|;
name|initiate_states
argument_list|()
expr_stmt|;
name|initiate_arcs
argument_list|()
expr_stmt|;
name|initiate_automata_lists
argument_list|()
expr_stmt|;
name|initiate_pass_states
argument_list|()
expr_stmt|;
name|initiate_excl_sets
argument_list|()
expr_stmt|;
name|initiate_presence_absence_pattern_sets
argument_list|()
expr_stmt|;
name|automaton_generation_time
operator|=
name|create_ticker
argument_list|()
expr_stmt|;
name|create_automata
argument_list|()
expr_stmt|;
name|ticker_off
argument_list|(
operator|&
name|automaton_generation_time
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This page mainly contains top level functions of pipeline hazards    description translator.  */
end_comment

begin_comment
comment|/* The following macro value is suffix of name of description file of    pipeline hazards description translator.  */
end_comment

begin_define
define|#
directive|define
name|STANDARD_OUTPUT_DESCRIPTION_FILE_SUFFIX
value|".dfa"
end_define

begin_comment
comment|/* The function returns suffix of given file name.  The returned    string can not be changed.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|file_name_suffix
parameter_list|(
specifier|const
name|char
modifier|*
name|file_name
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|last_period
decl_stmt|;
for|for
control|(
name|last_period
operator|=
name|NULL
init|;
operator|*
name|file_name
operator|!=
literal|'\0'
condition|;
name|file_name
operator|++
control|)
if|if
condition|(
operator|*
name|file_name
operator|==
literal|'.'
condition|)
name|last_period
operator|=
name|file_name
expr_stmt|;
return|return
operator|(
name|last_period
operator|==
name|NULL
condition|?
name|file_name
else|:
name|last_period
operator|)
return|;
block|}
end_function

begin_comment
comment|/* The function returns base name of given file name, i.e. pointer to    first char after last `/' (or `\' for WIN32) in given file name,    given file name itself if the directory name is absent.  The    returned string can not be changed.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|base_file_name
parameter_list|(
specifier|const
name|char
modifier|*
name|file_name
parameter_list|)
block|{
name|int
name|directory_name_length
decl_stmt|;
name|directory_name_length
operator|=
name|strlen
argument_list|(
name|file_name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|WIN32
while|while
condition|(
name|directory_name_length
operator|>=
literal|0
operator|&&
name|file_name
index|[
name|directory_name_length
index|]
operator|!=
literal|'/'
operator|&&
name|file_name
index|[
name|directory_name_length
index|]
operator|!=
literal|'\\'
condition|)
else|#
directive|else
while|while
condition|(
name|directory_name_length
operator|>=
literal|0
operator|&&
name|file_name
index|[
name|directory_name_length
index|]
operator|!=
literal|'/'
condition|)
endif|#
directive|endif
name|directory_name_length
operator|--
expr_stmt|;
return|return
name|file_name
operator|+
name|directory_name_length
operator|+
literal|1
return|;
block|}
end_function

begin_comment
comment|/* The following is top level function to initialize the work of    pipeline hazards description translator.  */
end_comment

begin_function
specifier|static
name|void
name|initiate_automaton_gen
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|base_name
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ndfa_flag
operator|=
literal|0
expr_stmt|;
name|split_argument
operator|=
literal|0
expr_stmt|;
comment|/* default value */
name|no_minimization_flag
operator|=
literal|0
expr_stmt|;
name|time_flag
operator|=
literal|0
expr_stmt|;
name|v_flag
operator|=
literal|0
expr_stmt|;
name|w_flag
operator|=
literal|0
expr_stmt|;
name|progress_flag
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|NO_MINIMIZATION_OPTION
argument_list|)
operator|==
literal|0
condition|)
name|no_minimization_flag
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|TIME_OPTION
argument_list|)
operator|==
literal|0
condition|)
name|time_flag
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|V_OPTION
argument_list|)
operator|==
literal|0
condition|)
name|v_flag
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|W_OPTION
argument_list|)
operator|==
literal|0
condition|)
name|w_flag
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|NDFA_OPTION
argument_list|)
operator|==
literal|0
condition|)
name|ndfa_flag
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|PROGRESS_OPTION
argument_list|)
operator|==
literal|0
condition|)
name|progress_flag
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-split"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|+
literal|1
operator|>=
name|argc
condition|)
name|fatal
argument_list|(
literal|"-split has no argument."
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
literal|"option `-split' has not been implemented yet\n"
argument_list|)
expr_stmt|;
comment|/* split_argument = atoi (argument_vect [i + 1]); */
block|}
comment|/* Initialize IR storage.  */
name|obstack_init
argument_list|(
operator|&
name|irp
argument_list|)
expr_stmt|;
name|initiate_automaton_decl_table
argument_list|()
expr_stmt|;
name|initiate_insn_decl_table
argument_list|()
expr_stmt|;
name|initiate_decl_table
argument_list|()
expr_stmt|;
name|output_file
operator|=
name|stdout
expr_stmt|;
name|output_description_file
operator|=
name|NULL
expr_stmt|;
name|base_name
operator|=
name|base_file_name
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|irp
argument_list|,
name|base_name
argument_list|,
name|strlen
argument_list|(
name|base_name
argument_list|)
operator|-
name|strlen
argument_list|(
name|file_name_suffix
argument_list|(
name|base_name
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|irp
argument_list|,
name|STANDARD_OUTPUT_DESCRIPTION_FILE_SUFFIX
argument_list|,
name|strlen
argument_list|(
name|STANDARD_OUTPUT_DESCRIPTION_FILE_SUFFIX
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|irp
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
name|output_description_file_name
operator|=
name|obstack_base
argument_list|(
operator|&
name|irp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|obstack_finish
argument_list|(
operator|&
name|irp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The following function checks existence at least one arc marked by    each insn.  */
end_comment

begin_function
specifier|static
name|void
name|check_automata_insn_issues
parameter_list|(
name|void
parameter_list|)
block|{
name|automaton_t
name|automaton
decl_stmt|;
name|ainsn_t
name|ainsn
decl_stmt|,
name|reserv_ainsn
decl_stmt|;
for|for
control|(
name|automaton
operator|=
name|description
operator|->
name|first_automaton
init|;
name|automaton
operator|!=
name|NULL
condition|;
name|automaton
operator|=
name|automaton
operator|->
name|next_automaton
control|)
block|{
for|for
control|(
name|ainsn
operator|=
name|automaton
operator|->
name|ainsn_list
init|;
name|ainsn
operator|!=
name|NULL
condition|;
name|ainsn
operator|=
name|ainsn
operator|->
name|next_ainsn
control|)
if|if
condition|(
name|ainsn
operator|->
name|first_insn_with_same_reservs
operator|&&
operator|!
name|ainsn
operator|->
name|arc_exists_p
condition|)
block|{
for|for
control|(
name|reserv_ainsn
operator|=
name|ainsn
init|;
name|reserv_ainsn
operator|!=
name|NULL
condition|;
name|reserv_ainsn
operator|=
name|reserv_ainsn
operator|->
name|next_same_reservs_insn
control|)
if|if
condition|(
name|automaton
operator|->
name|corresponding_automaton_decl
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|w_flag
condition|)
name|error
argument_list|(
literal|"Automaton `%s': Insn `%s' will never be issued"
argument_list|,
name|automaton
operator|->
name|corresponding_automaton_decl
operator|->
name|name
argument_list|,
name|reserv_ainsn
operator|->
name|insn_reserv_decl
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|0
argument_list|,
literal|"Automaton `%s': Insn `%s' will never be issued"
argument_list|,
name|automaton
operator|->
name|corresponding_automaton_decl
operator|->
name|name
argument_list|,
name|reserv_ainsn
operator|->
name|insn_reserv_decl
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|w_flag
condition|)
name|error
argument_list|(
literal|"Insn `%s' will never be issued"
argument_list|,
name|reserv_ainsn
operator|->
name|insn_reserv_decl
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|0
argument_list|,
literal|"Insn `%s' will never be issued"
argument_list|,
name|reserv_ainsn
operator|->
name|insn_reserv_decl
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* The following vla is used for storing pointers to all achieved    states.  */
end_comment

begin_expr_stmt
specifier|static
name|VEC
argument_list|(
name|state_t
argument_list|,
name|heap
argument_list|)
operator|*
name|automaton_states
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* This function is called by function pass_states to add an achieved    STATE.  */
end_comment

begin_function
specifier|static
name|void
name|add_automaton_state
parameter_list|(
name|state_t
name|state
parameter_list|)
block|{
name|VEC_safe_push
argument_list|(
name|state_t
argument_list|,
name|heap
argument_list|,
name|automaton_states
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The following function forms list of important automata (whose    states may be changed after the insn issue) for each insn.  */
end_comment

begin_function
specifier|static
name|void
name|form_important_insn_automata_lists
parameter_list|(
name|void
parameter_list|)
block|{
name|automaton_t
name|automaton
decl_stmt|;
name|decl_t
name|decl
decl_stmt|;
name|ainsn_t
name|ainsn
decl_stmt|;
name|arc_t
name|arc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|size_t
name|n
decl_stmt|;
name|automaton_states
operator|=
literal|0
expr_stmt|;
comment|/* Mark important ainsns.  */
for|for
control|(
name|automaton
operator|=
name|description
operator|->
name|first_automaton
init|;
name|automaton
operator|!=
name|NULL
condition|;
name|automaton
operator|=
name|automaton
operator|->
name|next_automaton
control|)
block|{
name|VEC_truncate
argument_list|(
name|state_t
argument_list|,
name|automaton_states
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pass_states
argument_list|(
name|automaton
argument_list|,
name|add_automaton_state
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|VEC_length
argument_list|(
name|state_t
argument_list|,
name|automaton_states
argument_list|)
condition|;
name|n
operator|++
control|)
block|{
name|state_t
name|s
init|=
name|VEC_index
argument_list|(
name|state_t
argument_list|,
name|automaton_states
argument_list|,
name|n
argument_list|)
decl_stmt|;
for|for
control|(
name|arc
operator|=
name|first_out_arc
argument_list|(
name|s
argument_list|)
init|;
name|arc
operator|!=
name|NULL
condition|;
name|arc
operator|=
name|next_out_arc
argument_list|(
name|arc
argument_list|)
control|)
if|if
condition|(
name|arc
operator|->
name|to_state
operator|!=
name|s
condition|)
block|{
name|gcc_assert
argument_list|(
name|arc
operator|->
name|insn
operator|->
name|first_insn_with_same_reservs
argument_list|)
expr_stmt|;
for|for
control|(
name|ainsn
operator|=
name|arc
operator|->
name|insn
init|;
name|ainsn
operator|!=
name|NULL
condition|;
name|ainsn
operator|=
name|ainsn
operator|->
name|next_same_reservs_insn
control|)
name|ainsn
operator|->
name|important_p
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
name|VEC_free
argument_list|(
name|state_t
argument_list|,
name|heap
argument_list|,
name|automaton_states
argument_list|)
expr_stmt|;
comment|/* Create automata sets for the insns.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_insn_reserv
condition|)
block|{
name|automata_list_start
argument_list|()
expr_stmt|;
for|for
control|(
name|automaton
operator|=
name|description
operator|->
name|first_automaton
init|;
name|automaton
operator|!=
name|NULL
condition|;
name|automaton
operator|=
name|automaton
operator|->
name|next_automaton
control|)
for|for
control|(
name|ainsn
operator|=
name|automaton
operator|->
name|ainsn_list
init|;
name|ainsn
operator|!=
name|NULL
condition|;
name|ainsn
operator|=
name|ainsn
operator|->
name|next_ainsn
control|)
if|if
condition|(
name|ainsn
operator|->
name|important_p
operator|&&
name|ainsn
operator|->
name|insn_reserv_decl
operator|==
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|automata_list_add
argument_list|(
name|automaton
argument_list|)
expr_stmt|;
break|break;
block|}
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|important_automata_list
operator|=
name|automata_list_finish
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* The following is top level function to generate automat(a,on) for    fast recognition of pipeline hazards.  */
end_comment

begin_function
specifier|static
name|void
name|expand_automata
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|description
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|description
argument_list|)
comment|/* One entry for cycle advancing insn.  */
operator|+
sizeof|sizeof
argument_list|(
name|decl_t
argument_list|)
operator|*
name|VEC_length
argument_list|(
name|decl_t
argument_list|,
name|decls
argument_list|)
argument_list|)
expr_stmt|;
name|description
operator|->
name|decls_num
operator|=
name|VEC_length
argument_list|(
name|decl_t
argument_list|,
name|decls
argument_list|)
expr_stmt|;
name|description
operator|->
name|query_units_num
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|description
operator|->
name|decls
index|[
name|i
index|]
operator|=
name|VEC_index
argument_list|(
name|decl_t
argument_list|,
name|decls
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|description
operator|->
name|decls
index|[
name|i
index|]
operator|->
name|mode
operator|==
name|dm_unit
operator|&&
name|DECL_UNIT
argument_list|(
name|description
operator|->
name|decls
index|[
name|i
index|]
argument_list|)
operator|->
name|query_p
condition|)
name|DECL_UNIT
argument_list|(
name|description
operator|->
name|decls
index|[
name|i
index|]
argument_list|)
operator|->
name|query_num
operator|=
name|description
operator|->
name|query_units_num
operator|++
expr_stmt|;
block|}
name|all_time
operator|=
name|create_ticker
argument_list|()
expr_stmt|;
name|check_time
operator|=
name|create_ticker
argument_list|()
expr_stmt|;
if|if
condition|(
name|progress_flag
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Check description..."
argument_list|)
expr_stmt|;
name|check_all_description
argument_list|()
expr_stmt|;
if|if
condition|(
name|progress_flag
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"done\n"
argument_list|)
expr_stmt|;
name|ticker_off
argument_list|(
operator|&
name|check_time
argument_list|)
expr_stmt|;
name|generation_time
operator|=
name|create_ticker
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|have_error
condition|)
block|{
name|transform_insn_regexps
argument_list|()
expr_stmt|;
name|check_unit_distributions_to_automata
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|have_error
condition|)
block|{
name|generate
argument_list|()
expr_stmt|;
name|check_automata_insn_issues
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|have_error
condition|)
block|{
name|form_important_insn_automata_lists
argument_list|()
expr_stmt|;
block|}
name|ticker_off
argument_list|(
operator|&
name|generation_time
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The following is top level function to output PHR and to finish    work with pipeline description translator.  */
end_comment

begin_function
specifier|static
name|void
name|write_automata
parameter_list|(
name|void
parameter_list|)
block|{
name|output_time
operator|=
name|create_ticker
argument_list|()
expr_stmt|;
if|if
condition|(
name|progress_flag
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Forming and outputting automata tables..."
argument_list|)
expr_stmt|;
name|output_tables
argument_list|()
expr_stmt|;
if|if
condition|(
name|progress_flag
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"done\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Output functions to work with automata..."
argument_list|)
expr_stmt|;
block|}
name|output_chip_definitions
argument_list|()
expr_stmt|;
name|output_max_insn_queue_index_def
argument_list|()
expr_stmt|;
name|output_internal_min_issue_delay_func
argument_list|()
expr_stmt|;
name|output_internal_trans_func
argument_list|()
expr_stmt|;
comment|/* Cache of insn dfa codes: */
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\nstatic int *%s;\n"
argument_list|,
name|DFA_INSN_CODES_VARIABLE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\nstatic int %s;\n\n"
argument_list|,
name|DFA_INSN_CODES_LENGTH_VARIABLE_NAME
argument_list|)
expr_stmt|;
name|output_dfa_insn_code_func
argument_list|()
expr_stmt|;
name|output_trans_func
argument_list|()
expr_stmt|;
name|output_min_issue_delay_func
argument_list|()
expr_stmt|;
name|output_internal_dead_lock_func
argument_list|()
expr_stmt|;
name|output_dead_lock_func
argument_list|()
expr_stmt|;
name|output_size_func
argument_list|()
expr_stmt|;
name|output_internal_reset_func
argument_list|()
expr_stmt|;
name|output_reset_func
argument_list|()
expr_stmt|;
name|output_min_insn_conflict_delay_func
argument_list|()
expr_stmt|;
name|output_internal_insn_latency_func
argument_list|()
expr_stmt|;
name|output_insn_latency_func
argument_list|()
expr_stmt|;
name|output_print_reservation_func
argument_list|()
expr_stmt|;
comment|/* Output function get_cpu_unit_code.  */
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\n#if %s\n\n"
argument_list|,
name|CPU_UNITS_QUERY_MACRO_NAME
argument_list|)
expr_stmt|;
name|output_get_cpu_unit_code_func
argument_list|()
expr_stmt|;
name|output_cpu_unit_reservation_p
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\n#endif /* #if %s */\n\n"
argument_list|,
name|CPU_UNITS_QUERY_MACRO_NAME
argument_list|)
expr_stmt|;
name|output_dfa_clean_insn_cache_func
argument_list|()
expr_stmt|;
name|output_dfa_start_func
argument_list|()
expr_stmt|;
name|output_dfa_finish_func
argument_list|()
expr_stmt|;
if|if
condition|(
name|progress_flag
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"done\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|v_flag
condition|)
block|{
name|output_description_file
operator|=
name|fopen
argument_list|(
name|output_description_file_name
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_description_file
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|output_description_file_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|progress_flag
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Output automata description..."
argument_list|)
expr_stmt|;
name|output_description
argument_list|()
expr_stmt|;
name|output_automaton_descriptions
argument_list|()
expr_stmt|;
if|if
condition|(
name|progress_flag
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"done\n"
argument_list|)
expr_stmt|;
name|output_statistics
argument_list|(
name|output_description_file
argument_list|)
expr_stmt|;
block|}
name|output_statistics
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|ticker_off
argument_list|(
operator|&
name|output_time
argument_list|)
expr_stmt|;
name|output_time_statistics
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|finish_states
argument_list|()
expr_stmt|;
name|finish_arcs
argument_list|()
expr_stmt|;
name|finish_automata_lists
argument_list|()
expr_stmt|;
if|if
condition|(
name|time_flag
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Summary:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  check time "
argument_list|)
expr_stmt|;
name|print_active_time
argument_list|(
name|stderr
argument_list|,
name|check_time
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", generation time "
argument_list|)
expr_stmt|;
name|print_active_time
argument_list|(
name|stderr
argument_list|,
name|generation_time
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", all time "
argument_list|)
expr_stmt|;
name|print_active_time
argument_list|(
name|stderr
argument_list|,
name|all_time
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Finish all work.  */
if|if
condition|(
name|output_description_file
operator|!=
name|NULL
condition|)
block|{
name|fflush
argument_list|(
name|output_description_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stdout
argument_list|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|"Error in writing DFA description file %s"
argument_list|,
name|output_description_file_name
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|output_description_file
argument_list|)
expr_stmt|;
block|}
name|finish_automaton_decl_table
argument_list|()
expr_stmt|;
name|finish_insn_decl_table
argument_list|()
expr_stmt|;
name|finish_decl_table
argument_list|()
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|irp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_error
operator|&&
name|output_description_file
operator|!=
name|NULL
condition|)
name|remove
argument_list|(
name|output_description_file_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|rtx
name|desc
decl_stmt|;
name|progname
operator|=
literal|"genautomata"
expr_stmt|;
if|if
condition|(
name|init_md_reader_args
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
operator|!=
name|SUCCESS_EXIT_CODE
condition|)
return|return
operator|(
name|FATAL_EXIT_CODE
operator|)
return|;
name|initiate_automaton_gen
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|lineno
decl_stmt|;
name|int
name|insn_code_number
decl_stmt|;
name|desc
operator|=
name|read_md_rtx
argument_list|(
operator|&
name|lineno
argument_list|,
operator|&
name|insn_code_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|==
name|NULL
condition|)
break|break;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|desc
argument_list|)
condition|)
block|{
case|case
name|DEFINE_CPU_UNIT
case|:
name|gen_cpu_unit
argument_list|(
name|desc
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEFINE_QUERY_CPU_UNIT
case|:
name|gen_query_cpu_unit
argument_list|(
name|desc
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEFINE_BYPASS
case|:
name|gen_bypass
argument_list|(
name|desc
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXCLUSION_SET
case|:
name|gen_excl_set
argument_list|(
name|desc
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRESENCE_SET
case|:
name|gen_presence_set
argument_list|(
name|desc
argument_list|)
expr_stmt|;
break|break;
case|case
name|FINAL_PRESENCE_SET
case|:
name|gen_final_presence_set
argument_list|(
name|desc
argument_list|)
expr_stmt|;
break|break;
case|case
name|ABSENCE_SET
case|:
name|gen_absence_set
argument_list|(
name|desc
argument_list|)
expr_stmt|;
break|break;
case|case
name|FINAL_ABSENCE_SET
case|:
name|gen_final_absence_set
argument_list|(
name|desc
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEFINE_AUTOMATON
case|:
name|gen_automaton
argument_list|(
name|desc
argument_list|)
expr_stmt|;
break|break;
case|case
name|AUTOMATA_OPTION
case|:
name|gen_automata_option
argument_list|(
name|desc
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEFINE_RESERVATION
case|:
name|gen_reserv
argument_list|(
name|desc
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEFINE_INSN_RESERVATION
case|:
name|gen_insn_reserv
argument_list|(
name|desc
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|have_error
condition|)
return|return
name|FATAL_EXIT_CODE
return|;
name|puts
argument_list|(
literal|"/* Generated automatically by the program `genautomata'\n"
literal|"   from the machine description file `md'.  */\n\n"
literal|"#include \"config.h\"\n"
literal|"#include \"system.h\"\n"
literal|"#include \"coretypes.h\"\n"
literal|"#include \"tm.h\"\n"
literal|"#include \"rtl.h\"\n"
literal|"#include \"tm_p.h\"\n"
literal|"#include \"insn-config.h\"\n"
literal|"#include \"recog.h\"\n"
literal|"#include \"regs.h\"\n"
literal|"#include \"real.h\"\n"
literal|"#include \"output.h\"\n"
literal|"#include \"insn-attr.h\"\n"
literal|"#include \"toplev.h\"\n"
literal|"#include \"flags.h\"\n"
literal|"#include \"function.h\"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|VEC_length
argument_list|(
name|decl_t
argument_list|,
name|decls
argument_list|)
operator|>
literal|0
condition|)
block|{
name|expand_automata
argument_list|()
expr_stmt|;
name|write_automata
argument_list|()
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
return|return
operator|(
name|ferror
argument_list|(
name|stdout
argument_list|)
operator|!=
literal|0
condition|?
name|FATAL_EXIT_CODE
else|:
name|SUCCESS_EXIT_CODE
operator|)
return|;
block|}
end_function

end_unit

