begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Pipeline hazard description translator.    Copyright (C) 2000, 2001, 2002 Free Software Foundation, Inc.     Written by Vladimir Makarov<vmakarov@redhat.com>     This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* References:        1. Detecting pipeline structural hazards quickly. T. Proebsting,       C. Fraser. Proceedings of ACM SIGPLAN-SIGACT Symposium on       Principles of Programming Languages, pages 280--286, 1994.        This article is a good start point to understand usage of finite       state automata for pipeline hazard recognizers.  But I'd       recommend the 2nd article for more deep understanding.     2. Efficient Instruction Scheduling Using Finite State Automata:       V. Bala and N. Rubin, Proceedings of MICRO-28.  This is the best       article about usage of finite state automata for pipeline hazard       recognizers.     The current implementation is different from the 2nd article in the    following:     1. New operator `|' (alternative) is permitted in functional unit       reservation which can be treated deterministicly and       non-deterministicly.     2. Possibility of usage of nondeterministic automata too.     3. Possibility to query functional unit reservations for given       automaton state.     4. Several constructions to describe impossible reservations       (`exclusion_set', `presence_set', and `absence_set').     5. No reverse automata are generated.  Trace instruction scheduling       requires this.  It can be easily added in the future if we       really need this.     6. Union of automaton states are not generated yet.  It is planned       to be implemented.  Such feature is needed to make more accurate       interlock insn scheduling to get state describing functional       unit reservation in a joint CFG point. */
end_comment

begin_comment
comment|/* This file code processes constructions of machine description file    which describes automaton used for recognition of processor pipeline    hazards by insn scheduler and can be used for other tasks (such as    VLIW insn packing.     The translator functions `gen_cpu_unit', `gen_query_cpu_unit',    `gen_bypass', `gen_excl_set', `gen_presence_set',    `gen_absence_set', `gen_automaton', `gen_automata_option',    `gen_reserv', `gen_insn_reserv' are called from file    `genattrtab.c'.  They transform RTL constructions describing    automata in .md file into internal representation convenient for    further processing.      The translator major function `expand_automata' processes the    description internal representation into finite state automaton.    It can be divided on:       o checking correctness of the automaton pipeline description        (major function is `check_all_description').       o generating automaton (automata) from the description (major        function is `make_automaton').       o optional transformation of nondeterministic finite state        automata into deterministic ones if the alternative operator        `|' is treated nondeterministicly in the description (major        function is NDFA_to_DFA).       o optional minimization of the finite state automata by merging        equivalent automaton states (major function is `minimize_DFA').       o forming tables (some as comb vectors) and attributes        representing the automata (functions output_..._table).     Function `write_automata' outputs the created finite state    automaton as different tables and functions which works with the    automata to inquire automaton state and to change its state.  These    function are used by gcc instruction scheduler and may be some    other gcc code.  */
end_comment

begin_include
include|#
directive|include
file|"hconfig.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"errors.h"
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"varray.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|CHAR_BIT
end_ifndef

begin_define
define|#
directive|define
name|CHAR_BIT
value|8
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"genattrtab.h"
end_include

begin_comment
comment|/* Positions in machine description file.  Now they are not used.  But    they could be used in the future for better diagnostic messages.  */
end_comment

begin_typedef
typedef|typedef
name|int
name|pos_t
typedef|;
end_typedef

begin_comment
comment|/* The following is element of vector of current (and planned in the    future) functional unit reservations.  */
end_comment

begin_typedef
typedef|typedef
name|unsigned
name|HOST_WIDE_INT
name|set_el_t
typedef|;
end_typedef

begin_comment
comment|/* Reservations of function units are represented by value of the following    type.  */
end_comment

begin_typedef
typedef|typedef
name|set_el_t
modifier|*
name|reserv_sets_t
typedef|;
end_typedef

begin_comment
comment|/* The following structure represents variable length array (vla) of    pointers and HOST WIDE INTs.  We could be use only varray.  But we    add new lay because we add elements very frequently and this could    stress OS allocator when varray is used only.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|size_t
name|length
decl_stmt|;
comment|/* current size of vla.  */
name|varray_type
name|varray
decl_stmt|;
comment|/* container for vla.  */
block|}
name|vla_ptr_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|vla_ptr_t
name|vla_hwint_t
typedef|;
end_typedef

begin_comment
comment|/* The following structure describes a ticker.  */
end_comment

begin_struct
struct|struct
name|ticker
block|{
comment|/* The following member value is time of the ticker creation with      taking into account time when the ticker is off.  Active time of      the ticker is current time minus the value.  */
name|int
name|modified_creation_time
decl_stmt|;
comment|/* The following member value is time (incremented by one) when the      ticker was off.  Zero value means that now the ticker is on.  */
name|int
name|incremented_off_time
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The ticker is represented by the following type.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|ticker
name|ticker_t
typedef|;
end_typedef

begin_comment
comment|/* The following type describes elements of output vectors.  */
end_comment

begin_typedef
typedef|typedef
name|HOST_WIDE_INT
name|vect_el_t
typedef|;
end_typedef

begin_comment
comment|/* Forward declaration of structures of internal representation of    pipeline description based on NDFA.  */
end_comment

begin_struct_decl
struct_decl|struct
name|unit_decl
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|bypass_decl
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|result_decl
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|automaton_decl
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|unit_rel_decl
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|reserv_decl
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|insn_reserv_decl
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|decl
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|unit_regexp
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|result_regexp
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|reserv_regexp
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|nothing_regexp
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|sequence_regexp
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|repeat_regexp
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|allof_regexp
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|oneof_regexp
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|regexp
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|description
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|unit_set_el
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|state
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|alt_state
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|arc
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|ainsn
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|automaton
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|state_ainsn_table
struct_decl|;
end_struct_decl

begin_comment
comment|/* The following typedefs are for brevity.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|unit_decl
modifier|*
name|unit_decl_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|decl
modifier|*
name|decl_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|regexp
modifier|*
name|regexp_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|unit_set_el
modifier|*
name|unit_set_el_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|alt_state
modifier|*
name|alt_state_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|state
modifier|*
name|state_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|arc
modifier|*
name|arc_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|ainsn
modifier|*
name|ainsn_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|automaton
modifier|*
name|automaton_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|automata_list_el
modifier|*
name|automata_list_el_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|state_ainsn_table
modifier|*
name|state_ainsn_table_t
typedef|;
end_typedef

begin_comment
comment|/* Prototypes of functions gen_cpu_unit, gen_query_cpu_unit,    gen_bypass, gen_excl_set, gen_presence_set, gen_absence_set,    gen_automaton, gen_automata_option, gen_reserv, gen_insn_reserv,    initiate_automaton_gen, expand_automata, write_automata are    described on the file top because the functions are called from    function `main'.  */
end_comment

begin_decl_stmt
specifier|static
name|void
modifier|*
name|create_node
name|PARAMS
argument_list|(
operator|(
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
modifier|*
name|copy_node
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|check_name
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|pos_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|next_sep_el
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_sep_els
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|get_str_vect
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|regexp_t
name|gen_regexp_el
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|regexp_t
name|gen_regexp_repeat
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|regexp_t
name|gen_regexp_allof
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|regexp_t
name|gen_regexp_oneof
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|regexp_t
name|gen_regexp_sequence
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|regexp_t
name|gen_regexp
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|string_hash
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|hashval_t
name|automaton_decl_hash
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|automaton_decl_eq_p
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|decl_t
name|insert_automaton_decl
name|PARAMS
argument_list|(
operator|(
name|decl_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|decl_t
name|find_automaton_decl
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|initiate_automaton_decl_table
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|finish_automaton_decl_table
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|hashval_t
name|insn_decl_hash
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|insn_decl_eq_p
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|decl_t
name|insert_insn_decl
name|PARAMS
argument_list|(
operator|(
name|decl_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|decl_t
name|find_insn_decl
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|initiate_insn_decl_table
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|finish_insn_decl_table
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|hashval_t
name|decl_hash
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|decl_eq_p
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|decl_t
name|insert_decl
name|PARAMS
argument_list|(
operator|(
name|decl_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|decl_t
name|find_decl
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|initiate_decl_table
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|finish_decl_table
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unit_set_el_t
name|process_excls
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
name|int
operator|,
name|pos_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_excls
name|PARAMS
argument_list|(
operator|(
name|unit_set_el_t
operator|,
name|unit_set_el_t
operator|,
name|pos_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unit_set_el_t
name|process_presence_absence
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
name|int
operator|,
name|pos_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_presence_absence
name|PARAMS
argument_list|(
operator|(
name|unit_set_el_t
operator|,
name|unit_set_el_t
operator|,
name|pos_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|process_decls
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bypass_decl
modifier|*
name|find_bypass
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bypass_decl
operator|*
operator|,
expr|struct
name|insn_reserv_decl
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|check_automaton_usage
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|regexp_t
name|process_regexp
name|PARAMS
argument_list|(
operator|(
name|regexp_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|process_regexp_decls
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|check_usage
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|loop_in_regexp
name|PARAMS
argument_list|(
operator|(
name|regexp_t
operator|,
name|decl_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|check_loops_in_regexps
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|process_regexp_cycles
name|PARAMS
argument_list|(
operator|(
name|regexp_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|evaluate_max_reserv_cycles
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|check_all_description
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ticker_t
name|create_ticker
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ticker_off
name|PARAMS
argument_list|(
operator|(
name|ticker_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ticker_on
name|PARAMS
argument_list|(
operator|(
name|ticker_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|active_time
name|PARAMS
argument_list|(
operator|(
name|ticker_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_active_time
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|ticker_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_advance_cycle_insn_decl
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|alt_state_t
name|get_free_alt_state
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_alt_state
name|PARAMS
argument_list|(
operator|(
name|alt_state_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_alt_states
name|PARAMS
argument_list|(
operator|(
name|alt_state_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|alt_state_cmp
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
name|alt_state_ptr_1
operator|,
specifier|const
name|void
operator|*
name|alt_state_ptr_2
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|alt_state_t
name|uniq_sort_alt_states
name|PARAMS
argument_list|(
operator|(
name|alt_state_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|alt_states_eq
name|PARAMS
argument_list|(
operator|(
name|alt_state_t
operator|,
name|alt_state_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|initiate_alt_states
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|finish_alt_states
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reserv_sets_t
name|alloc_empty_reserv_sets
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|reserv_sets_hash_value
name|PARAMS
argument_list|(
operator|(
name|reserv_sets_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reserv_sets_cmp
name|PARAMS
argument_list|(
operator|(
name|reserv_sets_t
operator|,
name|reserv_sets_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reserv_sets_eq
name|PARAMS
argument_list|(
operator|(
name|reserv_sets_t
operator|,
name|reserv_sets_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_unit_reserv
name|PARAMS
argument_list|(
operator|(
name|reserv_sets_t
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|test_unit_reserv
name|PARAMS
argument_list|(
operator|(
name|reserv_sets_t
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|it_is_empty_reserv_sets
name|PARAMS
argument_list|(
operator|(
name|reserv_sets_t
operator|)
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reserv_sets_are_intersected
name|PARAMS
argument_list|(
operator|(
name|reserv_sets_t
operator|,
name|reserv_sets_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reserv_sets_shift
name|PARAMS
argument_list|(
operator|(
name|reserv_sets_t
operator|,
name|reserv_sets_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reserv_sets_or
name|PARAMS
argument_list|(
operator|(
name|reserv_sets_t
operator|,
name|reserv_sets_t
operator|,
name|reserv_sets_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reserv_sets_and
name|PARAMS
argument_list|(
operator|(
name|reserv_sets_t
operator|,
name|reserv_sets_t
operator|,
name|reserv_sets_t
operator|)
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_cycle_reservs
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|reserv_sets_t
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_reserv_sets
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|reserv_sets_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|state_t
name|get_free_state
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|automaton_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_state
name|PARAMS
argument_list|(
operator|(
name|state_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|hashval_t
name|state_hash
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|state_eq_p
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|state_t
name|insert_state
name|PARAMS
argument_list|(
operator|(
name|state_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_state_reserv
name|PARAMS
argument_list|(
operator|(
name|state_t
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|intersected_state_reservs_p
name|PARAMS
argument_list|(
operator|(
name|state_t
operator|,
name|state_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|state_t
name|states_union
name|PARAMS
argument_list|(
operator|(
name|state_t
operator|,
name|state_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|state_t
name|state_shift
name|PARAMS
argument_list|(
operator|(
name|state_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|initiate_states
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|finish_states
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_arc
name|PARAMS
argument_list|(
operator|(
name|arc_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remove_arc
name|PARAMS
argument_list|(
operator|(
name|state_t
operator|,
name|arc_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|arc_t
name|find_arc
name|PARAMS
argument_list|(
operator|(
name|state_t
operator|,
name|state_t
operator|,
name|ainsn_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|arc_t
name|add_arc
name|PARAMS
argument_list|(
operator|(
name|state_t
operator|,
name|state_t
operator|,
name|ainsn_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|arc_t
name|first_out_arc
name|PARAMS
argument_list|(
operator|(
name|state_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|arc_t
name|next_out_arc
name|PARAMS
argument_list|(
operator|(
name|arc_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|initiate_arcs
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|finish_arcs
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|automata_list_el_t
name|get_free_automata_list_el
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_automata_list_el
name|PARAMS
argument_list|(
operator|(
name|automata_list_el_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_automata_list
name|PARAMS
argument_list|(
operator|(
name|automata_list_el_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|hashval_t
name|automata_list_hash
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|automata_list_eq_p
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|initiate_automata_lists
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|automata_list_start
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|automata_list_add
name|PARAMS
argument_list|(
operator|(
name|automaton_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|automata_list_el_t
name|automata_list_finish
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|finish_automata_lists
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|initiate_excl_sets
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reserv_sets_t
name|get_excl_set
name|PARAMS
argument_list|(
operator|(
name|reserv_sets_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|initiate_presence_absence_sets
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reserv_sets_t
name|get_presence_absence_set
name|PARAMS
argument_list|(
operator|(
name|reserv_sets_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|regexp_t
name|copy_insn_regexp
name|PARAMS
argument_list|(
operator|(
name|regexp_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|regexp_t
name|transform_1
name|PARAMS
argument_list|(
operator|(
name|regexp_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|regexp_t
name|transform_2
name|PARAMS
argument_list|(
operator|(
name|regexp_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|regexp_t
name|transform_3
name|PARAMS
argument_list|(
operator|(
name|regexp_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|regexp_t
name|regexp_transform_func
name|PARAMS
argument_list|(
operator|(
name|regexp_t
operator|,
name|regexp_t
argument_list|(
operator|*
argument_list|)
argument_list|(
name|regexp_t
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|regexp_t
name|transform_regexp
name|PARAMS
argument_list|(
operator|(
name|regexp_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|transform_insn_regexps
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|process_unit_to_form_the_same_automaton_unit_lists
name|PARAMS
argument_list|(
operator|(
name|regexp_t
operator|,
name|regexp_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|form_the_same_automaton_unit_lists_from_regexp
name|PARAMS
argument_list|(
operator|(
name|regexp_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|form_the_same_automaton_unit_lists
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|check_unit_distributions_to_automata
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|process_seq_for_forming_states
name|PARAMS
argument_list|(
operator|(
name|regexp_t
operator|,
name|automaton_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|finish_forming_alt_state
name|PARAMS
argument_list|(
operator|(
name|alt_state_t
operator|,
name|automaton_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|process_alts_for_forming_states
name|PARAMS
argument_list|(
operator|(
name|regexp_t
operator|,
name|automaton_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|create_alt_states
name|PARAMS
argument_list|(
operator|(
name|automaton_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|form_ainsn_with_same_reservs
name|PARAMS
argument_list|(
operator|(
name|automaton_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|make_automaton
name|PARAMS
argument_list|(
operator|(
name|automaton_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|form_arcs_marked_by_insn
name|PARAMS
argument_list|(
operator|(
name|state_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|create_composed_state
name|PARAMS
argument_list|(
operator|(
name|state_t
operator|,
name|arc_t
operator|,
name|vla_ptr_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|NDFA_to_DFA
name|PARAMS
argument_list|(
operator|(
name|automaton_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pass_state_graph
name|PARAMS
argument_list|(
operator|(
name|state_t
operator|,
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|state_t
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pass_states
name|PARAMS
argument_list|(
operator|(
name|automaton_t
operator|,
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|state_t
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|initiate_pass_states
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_achieved_state
name|PARAMS
argument_list|(
operator|(
name|state_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|set_out_arc_insns_equiv_num
name|PARAMS
argument_list|(
operator|(
name|state_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|clear_arc_insns_equiv_num
name|PARAMS
argument_list|(
operator|(
name|state_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|copy_equiv_class
name|PARAMS
argument_list|(
operator|(
name|vla_ptr_t
operator|*
name|to
operator|,
specifier|const
name|vla_ptr_t
operator|*
name|from
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|state_is_differed
name|PARAMS
argument_list|(
operator|(
name|state_t
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|state_t
name|init_equiv_class
name|PARAMS
argument_list|(
operator|(
name|state_t
operator|*
name|states
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|partition_equiv_class
name|PARAMS
argument_list|(
operator|(
name|state_t
operator|*
operator|,
name|int
operator|,
name|vla_ptr_t
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|evaluate_equiv_classes
name|PARAMS
argument_list|(
operator|(
name|automaton_t
operator|,
name|vla_ptr_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|merge_states
name|PARAMS
argument_list|(
operator|(
name|automaton_t
operator|,
name|vla_ptr_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_new_cycle_flags
name|PARAMS
argument_list|(
operator|(
name|state_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|minimize_DFA
name|PARAMS
argument_list|(
operator|(
name|automaton_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|incr_states_and_arcs_nums
name|PARAMS
argument_list|(
operator|(
name|state_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|count_states_and_arcs
name|PARAMS
argument_list|(
operator|(
name|automaton_t
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|build_automaton
name|PARAMS
argument_list|(
operator|(
name|automaton_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_order_state_num
name|PARAMS
argument_list|(
operator|(
name|state_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|enumerate_states
name|PARAMS
argument_list|(
operator|(
name|automaton_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ainsn_t
name|insert_ainsn_into_equiv_class
name|PARAMS
argument_list|(
operator|(
name|ainsn_t
operator|,
name|ainsn_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|delete_ainsn_from_equiv_class
name|PARAMS
argument_list|(
operator|(
name|ainsn_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|process_insn_equiv_class
name|PARAMS
argument_list|(
operator|(
name|ainsn_t
operator|,
name|arc_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|process_state_for_insn_equiv_partition
name|PARAMS
argument_list|(
operator|(
name|state_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_insn_equiv_classes
name|PARAMS
argument_list|(
operator|(
name|automaton_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|double
name|estimate_one_automaton_bound
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|compare_max_occ_cycle_nums
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|units_to_automata_heuristic_distr
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ainsn_t
name|create_ainsns
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|units_to_automata_distr
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|create_automata
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|form_regexp
name|PARAMS
argument_list|(
operator|(
name|regexp_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|regexp_representation
name|PARAMS
argument_list|(
operator|(
name|regexp_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|finish_regexp_representation
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_range_type
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|long
name|int
operator|,
name|long
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|longest_path_length
name|PARAMS
argument_list|(
operator|(
name|state_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|process_state_longest_path_length
name|PARAMS
argument_list|(
operator|(
name|state_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_dfa_max_issue_rate
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_vect
name|PARAMS
argument_list|(
operator|(
name|vect_el_t
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_chip_member_name
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|automaton_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_temp_chip_member_name
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|automaton_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_translate_vect_name
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|automaton_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_trans_full_vect_name
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|automaton_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_trans_comb_vect_name
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|automaton_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_trans_check_vect_name
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|automaton_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_trans_base_vect_name
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|automaton_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_state_alts_full_vect_name
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|automaton_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_state_alts_comb_vect_name
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|automaton_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_state_alts_check_vect_name
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|automaton_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_state_alts_base_vect_name
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|automaton_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_min_issue_delay_vect_name
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|automaton_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_dead_lock_vect_name
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|automaton_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_reserved_units_table_name
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|automaton_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_state_member_type
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|automaton_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_chip_definitions
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_translate_vect
name|PARAMS
argument_list|(
operator|(
name|automaton_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|comb_vect_p
name|PARAMS
argument_list|(
operator|(
name|state_ainsn_table_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|state_ainsn_table_t
name|create_state_ainsn_table
name|PARAMS
argument_list|(
operator|(
name|automaton_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_state_ainsn_table
name|PARAMS
argument_list|(
operator|(
name|state_ainsn_table_t
operator|,
name|char
operator|*
operator|,
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|FILE
operator|*
argument_list|,
name|automaton_t
argument_list|)
operator|,
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|FILE
operator|*
argument_list|,
name|automaton_t
argument_list|)
operator|,
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|FILE
operator|*
argument_list|,
name|automaton_t
argument_list|)
operator|,
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|FILE
operator|*
argument_list|,
name|automaton_t
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_vect
name|PARAMS
argument_list|(
operator|(
name|state_ainsn_table_t
operator|,
name|int
operator|,
name|vect_el_t
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|out_state_arcs_num
name|PARAMS
argument_list|(
operator|(
name|state_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|compare_transition_els_num
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_vect_el
name|PARAMS
argument_list|(
operator|(
name|vla_hwint_t
operator|*
operator|,
name|ainsn_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_states_vect_el
name|PARAMS
argument_list|(
operator|(
name|state_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_trans_table
name|PARAMS
argument_list|(
operator|(
name|automaton_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_state_alts_table
name|PARAMS
argument_list|(
operator|(
name|automaton_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|min_issue_delay_pass_states
name|PARAMS
argument_list|(
operator|(
name|state_t
operator|,
name|ainsn_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|min_issue_delay
name|PARAMS
argument_list|(
operator|(
name|state_t
operator|,
name|ainsn_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|initiate_min_issue_delay_pass_states
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_min_issue_delay_table
name|PARAMS
argument_list|(
operator|(
name|automaton_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_dead_lock_vect
name|PARAMS
argument_list|(
operator|(
name|automaton_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_reserved_units_table
name|PARAMS
argument_list|(
operator|(
name|automaton_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_tables
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_max_insn_queue_index_def
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_insn_code_cases
name|PARAMS
argument_list|(
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|automata_list_el_t
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_automata_list_min_issue_delay_code
name|PARAMS
argument_list|(
operator|(
name|automata_list_el_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_internal_min_issue_delay_func
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_automata_list_transition_code
name|PARAMS
argument_list|(
operator|(
name|automata_list_el_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_internal_trans_func
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_internal_insn_code_evaluation
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_dfa_insn_code_func
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_trans_func
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_automata_list_state_alts_code
name|PARAMS
argument_list|(
operator|(
name|automata_list_el_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_internal_state_alts_func
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_state_alts_func
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_min_issue_delay_func
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_internal_dead_lock_func
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_dead_lock_func
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_internal_reset_func
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_size_func
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_reset_func
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_min_insn_conflict_delay_func
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_internal_insn_latency_func
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_insn_latency_func
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_print_reservation_func
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|units_cmp
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_get_cpu_unit_code_func
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_cpu_unit_reservation_p
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_dfa_start_func
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_dfa_finish_func
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_regexp
name|PARAMS
argument_list|(
operator|(
name|regexp_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_unit_set_el_list
name|PARAMS
argument_list|(
operator|(
name|unit_set_el_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_description
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_automaton_name
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|automaton_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_automaton_units
name|PARAMS
argument_list|(
operator|(
name|automaton_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_state_reservs
name|PARAMS
argument_list|(
operator|(
name|state_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_state_arcs
name|PARAMS
argument_list|(
operator|(
name|state_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|state_reservs_cmp
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remove_state_duplicate_reservs
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_state
name|PARAMS
argument_list|(
operator|(
name|state_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_automaton_descriptions
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_statistics
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_time_statistics
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|generate
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|make_insn_alts_attr
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|make_internal_dfa_insn_code_attr
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|make_default_insn_latency_attr
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|make_bypass_attr
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|file_name_suffix
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|base_file_name
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|check_automata_insn_issues
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_automaton_state
name|PARAMS
argument_list|(
operator|(
name|state_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|form_important_insn_automata_lists
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Undefined position.  */
end_comment

begin_decl_stmt
specifier|static
name|pos_t
name|no_pos
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* All IR is stored in the following obstack.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|irp
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* This page contains code for work with variable length array (vla)    of pointers.  We could be use only varray.  But we add new lay    because we add elements very frequently and this could stress OS    allocator when varray is used only.  */
end_comment

begin_comment
comment|/* Start work with vla.  */
end_comment

begin_define
define|#
directive|define
name|VLA_PTR_CREATE
parameter_list|(
name|vla
parameter_list|,
name|allocated_length
parameter_list|,
name|name
parameter_list|)
define|\
value|do									\     {                                                                	\       vla_ptr_t *const vla_ptr =&(vla);                                \                                                                       	\       VARRAY_GENERIC_PTR_INIT (vla_ptr->varray, allocated_length, name);\       vla_ptr->length = 0;                                              \     }									\   while (0)
end_define

begin_comment
comment|/* Finish work with the vla.  */
end_comment

begin_define
define|#
directive|define
name|VLA_PTR_DELETE
parameter_list|(
name|vla
parameter_list|)
value|VARRAY_FREE ((vla).varray)
end_define

begin_comment
comment|/* Return start address of the vla.  */
end_comment

begin_define
define|#
directive|define
name|VLA_PTR_BEGIN
parameter_list|(
name|vla
parameter_list|)
value|((void *)&VARRAY_GENERIC_PTR ((vla).varray, 0))
end_define

begin_comment
comment|/* Address of the last element of the vla.  Do not use side effects in    the macro argument.  */
end_comment

begin_define
define|#
directive|define
name|VLA_PTR_LAST
parameter_list|(
name|vla
parameter_list|)
value|(&VARRAY_GENERIC_PTR ((vla).varray,         \                                                 (vla).length - 1))
end_define

begin_comment
comment|/* Nullify the vla.  */
end_comment

begin_define
define|#
directive|define
name|VLA_PTR_NULLIFY
parameter_list|(
name|vla
parameter_list|)
value|((vla).length = 0)
end_define

begin_comment
comment|/* Shorten the vla on given number bytes.  */
end_comment

begin_define
define|#
directive|define
name|VLA_PTR_SHORTEN
parameter_list|(
name|vla
parameter_list|,
name|n
parameter_list|)
value|((vla).length -= (n))
end_define

begin_comment
comment|/* Expand the vla on N elements.  The values of new elements are    undefined.  */
end_comment

begin_define
define|#
directive|define
name|VLA_PTR_EXPAND
parameter_list|(
name|vla
parameter_list|,
name|n
parameter_list|)
define|\
value|do {                                                                \     vla_ptr_t *const expand_vla_ptr =&(vla);                         \     const size_t new_length = (n) + expand_vla_ptr->length;           \                                                                       \     if (VARRAY_SIZE (expand_vla_ptr->varray)< new_length)            \       VARRAY_GROW (expand_vla_ptr->varray,                            \                    (new_length - expand_vla_ptr->length< 128         \                     ? expand_vla_ptr->length + 128 : new_length));    \     expand_vla_ptr->length = new_length;                              \   } while (0)
end_define

begin_comment
comment|/* Add element to the end of the vla.  */
end_comment

begin_define
define|#
directive|define
name|VLA_PTR_ADD
parameter_list|(
name|vla
parameter_list|,
name|ptr
parameter_list|)
define|\
value|do {                                                                \     vla_ptr_t *const vla_ptr =&(vla);                                \                                                                       \     VLA_PTR_EXPAND (*vla_ptr, 1);                                     \     VARRAY_GENERIC_PTR (vla_ptr->varray, vla_ptr->length - 1) = (ptr);\   } while (0)
end_define

begin_comment
comment|/* Length of the vla in elements.  */
end_comment

begin_define
define|#
directive|define
name|VLA_PTR_LENGTH
parameter_list|(
name|vla
parameter_list|)
value|((vla).length)
end_define

begin_comment
comment|/* N-th element of the vla.  */
end_comment

begin_define
define|#
directive|define
name|VLA_PTR
parameter_list|(
name|vla
parameter_list|,
name|n
parameter_list|)
value|VARRAY_GENERIC_PTR ((vla).varray, n)
end_define

begin_comment
comment|/* The following macros are analogous to the previous ones but for    VLAs of HOST WIDE INTs.  */
end_comment

begin_define
define|#
directive|define
name|VLA_HWINT_CREATE
parameter_list|(
name|vla
parameter_list|,
name|allocated_length
parameter_list|,
name|name
parameter_list|)
define|\
value|do {                                                                \     vla_hwint_t *const vla_ptr =&(vla);                              \                                                                       \     VARRAY_WIDE_INT_INIT (vla_ptr->varray, allocated_length, name);   \     vla_ptr->length = 0;                                              \   } while (0)
end_define

begin_define
define|#
directive|define
name|VLA_HWINT_DELETE
parameter_list|(
name|vla
parameter_list|)
value|VARRAY_FREE ((vla).varray)
end_define

begin_define
define|#
directive|define
name|VLA_HWINT_BEGIN
parameter_list|(
name|vla
parameter_list|)
value|(&VARRAY_WIDE_INT ((vla).varray, 0))
end_define

begin_define
define|#
directive|define
name|VLA_HWINT_NULLIFY
parameter_list|(
name|vla
parameter_list|)
value|((vla).length = 0)
end_define

begin_define
define|#
directive|define
name|VLA_HWINT_EXPAND
parameter_list|(
name|vla
parameter_list|,
name|n
parameter_list|)
define|\
value|do {                                                                \     vla_hwint_t *const expand_vla_ptr =&(vla);                       \     const size_t new_length = (n) + expand_vla_ptr->length;           \                                                                       \     if (VARRAY_SIZE (expand_vla_ptr->varray)< new_length)            \       VARRAY_GROW (expand_vla_ptr->varray,                            \                    (new_length - expand_vla_ptr->length< 128         \                     ? expand_vla_ptr->length + 128 : new_length));    \     expand_vla_ptr->length = new_length;                              \   } while (0)
end_define

begin_define
define|#
directive|define
name|VLA_HWINT_ADD
parameter_list|(
name|vla
parameter_list|,
name|ptr
parameter_list|)
define|\
value|do {                                                                \     vla_hwint_t *const vla_ptr =&(vla);                              \                                                                       \     VLA_HWINT_EXPAND (*vla_ptr, 1);                                   \     VARRAY_WIDE_INT (vla_ptr->varray, vla_ptr->length - 1) = (ptr);   \   } while (0)
end_define

begin_define
define|#
directive|define
name|VLA_HWINT_LENGTH
parameter_list|(
name|vla
parameter_list|)
value|((vla).length)
end_define

begin_define
define|#
directive|define
name|VLA_HWINT
parameter_list|(
name|vla
parameter_list|,
name|n
parameter_list|)
value|VARRAY_WIDE_INT ((vla).varray, n)
end_define

begin_escape
end_escape

begin_comment
comment|/* Options with the following names can be set up in automata_option    construction.  Because the strings occur more one time we use the    macros.  */
end_comment

begin_define
define|#
directive|define
name|NO_MINIMIZATION_OPTION
value|"-no-minimization"
end_define

begin_define
define|#
directive|define
name|TIME_OPTION
value|"-time"
end_define

begin_define
define|#
directive|define
name|V_OPTION
value|"-v"
end_define

begin_define
define|#
directive|define
name|W_OPTION
value|"-w"
end_define

begin_define
define|#
directive|define
name|NDFA_OPTION
value|"-ndfa"
end_define

begin_comment
comment|/* The following flags are set up by function `initiate_automaton_gen'.  */
end_comment

begin_comment
comment|/* Make automata with nondeterministic reservation by insns (`-ndfa').  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ndfa_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Do not make minimization of DFA (`-no-minimization').  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|no_minimization_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Value of this variable is number of automata being generated.  The    actual number of automata may be less this value if there is not    sufficient number of units.  This value is defined by argument of    option `-split' or by constructions automaton if the value is zero    (it is default value of the argument).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|split_argument
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag of output time statistics (`-time').  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|time_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag of creation of description file which contains description of    result automaton and statistics information (`-v').  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|v_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag of generating warning instead of error for non-critical errors    (`-w').  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|w_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Output file for pipeline hazard recognizer (PHR) being generated.    The value is NULL if the file is not defined.  */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|output_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Description file of PHR.  The value is NULL if the file is not    created.  */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|output_description_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* PHR description file name.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|output_description_file_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Value of the following variable is node representing description    being processed.  This is start point of IR.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|description
modifier|*
name|description
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* This page contains description of IR structure (nodes).  */
end_comment

begin_enum
enum|enum
name|decl_mode
block|{
name|dm_unit
block|,
name|dm_bypass
block|,
name|dm_automaton
block|,
name|dm_excl
block|,
name|dm_presence
block|,
name|dm_absence
block|,
name|dm_reserv
block|,
name|dm_insn_reserv
block|}
enum|;
end_enum

begin_comment
comment|/* This describes define_cpu_unit and define_query_cpu_unit (see file    rtl.def).  */
end_comment

begin_struct
struct|struct
name|unit_decl
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* NULL if the automaton name is absent.  */
name|char
modifier|*
name|automaton_name
decl_stmt|;
comment|/* If the following value is not zero, the cpu unit reservation is      described in define_query_cpu_unit.  */
name|char
name|query_p
decl_stmt|;
comment|/* The following fields are defined by checker.  */
comment|/* The following field value is nonzero if the unit is used in an      regexp.  */
name|char
name|unit_is_used
decl_stmt|;
comment|/* The following field value is used to form cyclic lists of units      which should be in the same automaton because the unit is      reserved not on all alternatives of a regexp on a cycle.  */
name|unit_decl_t
name|the_same_automaton_unit
decl_stmt|;
comment|/* The following field is TRUE if we already reported that the unit      is not in the same automaton.  */
name|int
name|the_same_automaton_message_reported_p
decl_stmt|;
comment|/* The following field value is order number (0, 1, ...) of given      unit.  */
name|int
name|unit_num
decl_stmt|;
comment|/* The following field value is corresponding declaration of      automaton which was given in description.  If the field value is      NULL then automaton in the unit declaration was absent.  */
name|struct
name|automaton_decl
modifier|*
name|automaton_decl
decl_stmt|;
comment|/* The following field value is maximal cycle number (1, ...) on      which given unit occurs in insns.  Zero value means that given      unit is not used in insns.  */
name|int
name|max_occ_cycle_num
decl_stmt|;
comment|/* The following list contains units which conflict with given      unit.  */
name|unit_set_el_t
name|excl_list
decl_stmt|;
comment|/* The following list contains units which are required to      reservation of given unit.  */
name|unit_set_el_t
name|presence_list
decl_stmt|;
comment|/* The following list contains units which should be not present in      reservation for given unit.  */
name|unit_set_el_t
name|absence_list
decl_stmt|;
comment|/* The following is used only when `query_p' has nonzero value.      This is query number for the unit.  */
name|int
name|query_num
decl_stmt|;
comment|/* The following fields are defined by automaton generator.  */
comment|/* The following field value is number of the automaton to which      given unit belongs.  */
name|int
name|corresponding_automaton_num
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This describes define_bypass (see file rtl.def).  */
end_comment

begin_struct
struct|struct
name|bypass_decl
block|{
name|int
name|latency
decl_stmt|;
name|char
modifier|*
name|out_insn_name
decl_stmt|;
name|char
modifier|*
name|in_insn_name
decl_stmt|;
name|char
modifier|*
name|bypass_guard_name
decl_stmt|;
comment|/* The following fields are defined by checker.  */
comment|/* output and input insns of given bypass.  */
name|struct
name|insn_reserv_decl
modifier|*
name|out_insn_reserv
decl_stmt|;
name|struct
name|insn_reserv_decl
modifier|*
name|in_insn_reserv
decl_stmt|;
comment|/* The next bypass for given output insn.  */
name|struct
name|bypass_decl
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This describes define_automaton (see file rtl.def).  */
end_comment

begin_struct
struct|struct
name|automaton_decl
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* The following fields are defined by automaton generator.  */
comment|/* The following field value is nonzero if the automaton is used in      an regexp definition.  */
name|char
name|automaton_is_used
decl_stmt|;
comment|/* The following fields are defined by checker.  */
comment|/* The following field value is the corresponding automaton.  This      field is not NULL only if the automaton is present in unit      declarations and the automatic partition on automata is not      used.  */
name|automaton_t
name|corresponding_automaton
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This describes unit relations: exclusion_set, presence_set, or    absence_set (see file rtl.def).  */
end_comment

begin_struct
struct|struct
name|unit_rel_decl
block|{
name|int
name|names_num
decl_stmt|;
name|int
name|first_list_length
decl_stmt|;
name|char
modifier|*
name|names
index|[
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This describes define_reservation (see file rtl.def).  */
end_comment

begin_struct
struct|struct
name|reserv_decl
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|regexp_t
name|regexp
decl_stmt|;
comment|/* The following fields are defined by checker.  */
comment|/* The following field value is nonzero if the unit is used in an      regexp.  */
name|char
name|reserv_is_used
decl_stmt|;
comment|/* The following field is used to check up cycle in expression      definition.  */
name|int
name|loop_pass_num
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This describes define_insn_reservartion (see file rtl.def).  */
end_comment

begin_struct
struct|struct
name|insn_reserv_decl
block|{
name|rtx
name|condexp
decl_stmt|;
name|int
name|default_latency
decl_stmt|;
name|regexp_t
name|regexp
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
comment|/* The following fields are defined by checker.  */
comment|/* The following field value is order number (0, 1, ...) of given      insn.  */
name|int
name|insn_num
decl_stmt|;
comment|/* The following field value is list of bypasses in which given insn      is output insn.  */
name|struct
name|bypass_decl
modifier|*
name|bypass_list
decl_stmt|;
comment|/* The following fields are defined by automaton generator.  */
comment|/* The following field is the insn regexp transformed that      the regexp has not optional regexp, repetition regexp, and an      reservation name (i.e. reservation identifiers are changed by the      corresponding regexp) and all alternations are the topest level      of the regexp.  The value can be NULL only if it is special      insn `cycle advancing'.  */
name|regexp_t
name|transformed_regexp
decl_stmt|;
comment|/* The following field value is list of arcs marked given      insn.  The field is used in transfromation NDFA -> DFA.  */
name|arc_t
name|arcs_marked_by_insn
decl_stmt|;
comment|/* The two following fields are used during minimization of a finite state      automaton.  */
comment|/* The field value is number of equivalence class of state into      which arc marked by given insn enters from a state (fixed during      an automaton minimization).  */
name|int
name|equiv_class_num
decl_stmt|;
comment|/* The field value is state_alts of arc leaving a state (fixed      during an automaton minimization) and marked by given insn      enters.  */
name|int
name|state_alts
decl_stmt|;
comment|/* The following member value is the list to automata which can be      changed by the insn issue.  */
name|automata_list_el_t
name|important_automata_list
decl_stmt|;
comment|/* The following member is used to process insn once for output.  */
name|int
name|processed_p
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This contains a declaration mentioned above.  */
end_comment

begin_struct
struct|struct
name|decl
block|{
comment|/* What node in the union? */
name|enum
name|decl_mode
name|mode
decl_stmt|;
name|pos_t
name|pos
decl_stmt|;
union|union
block|{
name|struct
name|unit_decl
name|unit
decl_stmt|;
name|struct
name|bypass_decl
name|bypass
decl_stmt|;
name|struct
name|automaton_decl
name|automaton
decl_stmt|;
name|struct
name|unit_rel_decl
name|excl
decl_stmt|;
name|struct
name|unit_rel_decl
name|presence
decl_stmt|;
name|struct
name|unit_rel_decl
name|absence
decl_stmt|;
name|struct
name|reserv_decl
name|reserv
decl_stmt|;
name|struct
name|insn_reserv_decl
name|insn_reserv
decl_stmt|;
block|}
name|decl
union|;
block|}
struct|;
end_struct

begin_comment
comment|/* The following structures represent parsed reservation strings.  */
end_comment

begin_enum
enum|enum
name|regexp_mode
block|{
name|rm_unit
block|,
name|rm_reserv
block|,
name|rm_nothing
block|,
name|rm_sequence
block|,
name|rm_repeat
block|,
name|rm_allof
block|,
name|rm_oneof
block|}
enum|;
end_enum

begin_comment
comment|/* Cpu unit in reservation.  */
end_comment

begin_struct
struct|struct
name|unit_regexp
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|unit_decl_t
name|unit_decl
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Define_reservation in a reservation.  */
end_comment

begin_struct
struct|struct
name|reserv_regexp
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|reserv_decl
modifier|*
name|reserv_decl
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Absence of reservation (represented by string `nothing').  */
end_comment

begin_struct
struct|struct
name|nothing_regexp
block|{
comment|/* This used to be empty but ISO C doesn't allow that.  */
name|char
name|unused
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Representation of reservations separated by ',' (see file    rtl.def).  */
end_comment

begin_struct
struct|struct
name|sequence_regexp
block|{
name|int
name|regexps_num
decl_stmt|;
name|regexp_t
name|regexps
index|[
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Representation of construction `repeat' (see file rtl.def).  */
end_comment

begin_struct
struct|struct
name|repeat_regexp
block|{
name|int
name|repeat_num
decl_stmt|;
name|regexp_t
name|regexp
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Representation of reservations separated by '+' (see file    rtl.def).  */
end_comment

begin_struct
struct|struct
name|allof_regexp
block|{
name|int
name|regexps_num
decl_stmt|;
name|regexp_t
name|regexps
index|[
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Representation of reservations separated by '|' (see file    rtl.def).  */
end_comment

begin_struct
struct|struct
name|oneof_regexp
block|{
name|int
name|regexps_num
decl_stmt|;
name|regexp_t
name|regexps
index|[
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Representation of a reservation string.  */
end_comment

begin_struct
struct|struct
name|regexp
block|{
comment|/* What node in the union? */
name|enum
name|regexp_mode
name|mode
decl_stmt|;
name|pos_t
name|pos
decl_stmt|;
union|union
block|{
name|struct
name|unit_regexp
name|unit
decl_stmt|;
name|struct
name|reserv_regexp
name|reserv
decl_stmt|;
name|struct
name|nothing_regexp
name|nothing
decl_stmt|;
name|struct
name|sequence_regexp
name|sequence
decl_stmt|;
name|struct
name|repeat_regexp
name|repeat
decl_stmt|;
name|struct
name|allof_regexp
name|allof
decl_stmt|;
name|struct
name|oneof_regexp
name|oneof
decl_stmt|;
block|}
name|regexp
union|;
block|}
struct|;
end_struct

begin_comment
comment|/* Reperesents description of pipeline hazard description based on    NDFA.  */
end_comment

begin_struct
struct|struct
name|description
block|{
name|int
name|decls_num
decl_stmt|;
comment|/* The following fields are defined by checker.  */
comment|/* The following fields values are correspondingly number of all      units, query units, and insns in the description.  */
name|int
name|units_num
decl_stmt|;
name|int
name|query_units_num
decl_stmt|;
name|int
name|insns_num
decl_stmt|;
comment|/* The following field value is max length (in cycles) of      reservations of insns.  The field value is defined only for      correct programs.  */
name|int
name|max_insn_reserv_cycles
decl_stmt|;
comment|/* The following fields are defined by automaton generator.  */
comment|/* The following field value is the first automaton.  */
name|automaton_t
name|first_automaton
decl_stmt|;
comment|/* The following field is created by pipeline hazard parser and      contains all declarations.  We allocate additional entry for      special insn "cycle advancing" which is added by the automaton      generator.  */
name|decl_t
name|decls
index|[
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The following nodes are created in automaton checker.  */
end_comment

begin_comment
comment|/* The following nodes represent exclusion, presence, absence set for    cpu units.  Each element are accessed through only one excl_list,    presence_list, absence_list.  */
end_comment

begin_struct
struct|struct
name|unit_set_el
block|{
name|unit_decl_t
name|unit_decl
decl_stmt|;
name|unit_set_el_t
name|next_unit_set_el
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The following nodes are created in automaton generator.  */
end_comment

begin_comment
comment|/* The following node type describes state automaton.  The state may    be deterministic or non-deterministic.  Non-deterministic state has    several component states which represent alternative cpu units    reservations.  The state also is used for describing a    deterministic reservation of automaton insn.  */
end_comment

begin_struct
struct|struct
name|state
block|{
comment|/* The following member value is nonzero if there is a transition by      cycle advancing.  */
name|int
name|new_cycle_p
decl_stmt|;
comment|/* The following field is list of processor unit reservations on      each cycle.  */
name|reserv_sets_t
name|reservs
decl_stmt|;
comment|/* The following field is unique number of given state between other      states.  */
name|int
name|unique_num
decl_stmt|;
comment|/* The following field value is automaton to which given state      belongs.  */
name|automaton_t
name|automaton
decl_stmt|;
comment|/* The following field value is the first arc output from given      state.  */
name|arc_t
name|first_out_arc
decl_stmt|;
comment|/* The following field is used to form NDFA.  */
name|char
name|it_was_placed_in_stack_for_NDFA_forming
decl_stmt|;
comment|/* The following field is used to form DFA.  */
name|char
name|it_was_placed_in_stack_for_DFA_forming
decl_stmt|;
comment|/* The following field is used to transform NDFA to DFA.  The field      value is not NULL if the state is a compound state.  In this case      the value of field `unit_sets_list' is NULL.  All states in the      list are in the hash table.  The list is formed through field      `next_sorted_alt_state'.  */
name|alt_state_t
name|component_states
decl_stmt|;
comment|/* The following field is used for passing graph of states.  */
name|int
name|pass_num
decl_stmt|;
comment|/* The list of states belonging to one equivalence class is formed      with the aid of the following field.  */
name|state_t
name|next_equiv_class_state
decl_stmt|;
comment|/* The two following fields are used during minimization of a finite      state automaton.  */
name|int
name|equiv_class_num_1
decl_stmt|,
name|equiv_class_num_2
decl_stmt|;
comment|/* The following field is used during minimization of a finite state      automaton.  The field value is state corresponding to equivalence      class to which given state belongs.  */
name|state_t
name|equiv_class_state
decl_stmt|;
comment|/* The following field value is the order number of given state.      The states in final DFA is enumerated with the aid of the      following field.  */
name|int
name|order_state_num
decl_stmt|;
comment|/* This member is used for passing states for searching minimal      delay time.  */
name|int
name|state_pass_num
decl_stmt|;
comment|/* The following member is used to evaluate min issue delay of insn      for a state.  */
name|int
name|min_insn_issue_delay
decl_stmt|;
comment|/* The following member is used to evaluate max issue rate of the      processor.  The value of the member is maximal length of the path      from given state no containing arcs marked by special insn `cycle      advancing'.  */
name|int
name|longest_path_length
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The following macro is an initial value of member    `longest_path_length' of a state.  */
end_comment

begin_define
define|#
directive|define
name|UNDEFINED_LONGEST_PATH_LENGTH
value|-1
end_define

begin_comment
comment|/* Automaton arc.  */
end_comment

begin_struct
struct|struct
name|arc
block|{
comment|/* The following field refers for the state into which given arc      enters.  */
name|state_t
name|to_state
decl_stmt|;
comment|/* The following field describes that the insn issue (with cycle      advancing for special insn `cycle advancing' and without cycle      advancing for others) makes transition from given state to      another given state.  */
name|ainsn_t
name|insn
decl_stmt|;
comment|/* The following field value is the next arc output from the same      state.  */
name|arc_t
name|next_out_arc
decl_stmt|;
comment|/* List of arcs marked given insn is formed with the following      field.  The field is used in transfromation NDFA -> DFA.  */
name|arc_t
name|next_arc_marked_by_insn
decl_stmt|;
comment|/* The following field is defined if NDFA_FLAG is zero.  The member      value is number of alternative reservations which can be used for      transition for given state by given insn.  */
name|int
name|state_alts
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The following node type describes a deterministic alternative in    non-deterministic state which characterizes cpu unit reservations    of automaton insn or which is part of NDFA.  */
end_comment

begin_struct
struct|struct
name|alt_state
block|{
comment|/* The following field is a determinist state which characterizes      unit reservations of the instruction.  */
name|state_t
name|state
decl_stmt|;
comment|/* The following field refers to the next state which characterizes      unit reservations of the instruction.  */
name|alt_state_t
name|next_alt_state
decl_stmt|;
comment|/* The following field refers to the next state in sorted list.  */
name|alt_state_t
name|next_sorted_alt_state
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The following node type describes insn of automaton.  They are    labels of FA arcs.  */
end_comment

begin_struct
struct|struct
name|ainsn
block|{
comment|/* The following field value is the corresponding insn declaration      of description.  */
name|struct
name|insn_reserv_decl
modifier|*
name|insn_reserv_decl
decl_stmt|;
comment|/* The following field value is the next insn declaration for an      automaton.  */
name|ainsn_t
name|next_ainsn
decl_stmt|;
comment|/* The following field is states which characterize automaton unit      reservations of the instruction.  The value can be NULL only if it      is special insn `cycle advancing'.  */
name|alt_state_t
name|alt_states
decl_stmt|;
comment|/* The following field is sorted list of states which characterize      automaton unit reservations of the instruction.  The value can be      NULL only if it is special insn `cycle advancing'.  */
name|alt_state_t
name|sorted_alt_states
decl_stmt|;
comment|/* The following field refers the next automaton insn with      the same reservations.  */
name|ainsn_t
name|next_same_reservs_insn
decl_stmt|;
comment|/* The following field is flag of the first automaton insn with the      same reservations in the declaration list.  Only arcs marked such      insn is present in the automaton.  This significantly decreases      memory requirements especially when several automata are      formed.  */
name|char
name|first_insn_with_same_reservs
decl_stmt|;
comment|/* The following member has nonzero value if there is arc from state of      the automaton marked by the ainsn.  */
name|char
name|arc_exists_p
decl_stmt|;
comment|/* Cyclic list of insns of an equivalence class is formed with the      aid of the following field.  */
name|ainsn_t
name|next_equiv_class_insn
decl_stmt|;
comment|/* The following field value is nonzero if the insn declaration is      the first insn declaration with given equivalence number.  */
name|char
name|first_ainsn_with_given_equialence_num
decl_stmt|;
comment|/* The following field is number of class of equivalence of insns.      It is necessary because many insns may be equivalent with the      point of view of pipeline hazards.  */
name|int
name|insn_equiv_class_num
decl_stmt|;
comment|/* The following member value is TRUE if there is an arc in the      automaton marked by the insn into another state.  In other      words, the insn can change the state of the automaton.  */
name|int
name|important_p
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The folowing describes an automaton for PHR.  */
end_comment

begin_struct
struct|struct
name|automaton
block|{
comment|/* The following field value is the list of insn declarations for      given automaton.  */
name|ainsn_t
name|ainsn_list
decl_stmt|;
comment|/* The following field value is the corresponding automaton      declaration.  This field is not NULL only if the automatic      partition on automata is not used.  */
name|struct
name|automaton_decl
modifier|*
name|corresponding_automaton_decl
decl_stmt|;
comment|/* The following field value is the next automaton.  */
name|automaton_t
name|next_automaton
decl_stmt|;
comment|/* The following field is start state of FA.  There are not unit      reservations in the state.  */
name|state_t
name|start_state
decl_stmt|;
comment|/* The following field value is number of equivalence classes of      insns (see field `insn_equiv_class_num' in      `insn_reserv_decl').  */
name|int
name|insn_equiv_classes_num
decl_stmt|;
comment|/* The following field value is number of states of final DFA.  */
name|int
name|achieved_states_num
decl_stmt|;
comment|/* The following field value is the order number (0, 1, ...) of      given automaton.  */
name|int
name|automaton_order_num
decl_stmt|;
comment|/* The following fields contain statistics information about      building automaton.  */
name|int
name|NDFA_states_num
decl_stmt|,
name|DFA_states_num
decl_stmt|;
comment|/* The following field value is defined only if minimization of DFA      is used.  */
name|int
name|minimal_DFA_states_num
decl_stmt|;
name|int
name|NDFA_arcs_num
decl_stmt|,
name|DFA_arcs_num
decl_stmt|;
comment|/* The following field value is defined only if minimization of DFA      is used.  */
name|int
name|minimal_DFA_arcs_num
decl_stmt|;
comment|/* The following two members refer for two table state x ainsn ->      int.  */
name|state_ainsn_table_t
name|trans_table
decl_stmt|;
name|state_ainsn_table_t
name|state_alts_table
decl_stmt|;
comment|/* The following member value is maximal value of min issue delay      for insns of the automaton.  */
name|int
name|max_min_delay
decl_stmt|;
comment|/* Usually min issue delay is small and we can place several (2, 4,      8) elements in one vector element.  So the compression factor can      be 1 (no compression), 2, 4, 8.  */
name|int
name|min_issue_delay_table_compression_factor
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The following is the element of the list of automata.  */
end_comment

begin_struct
struct|struct
name|automata_list_el
block|{
comment|/* The automaton itself.  */
name|automaton_t
name|automaton
decl_stmt|;
comment|/* The next automata set element.  */
name|automata_list_el_t
name|next_automata_list_el
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The following structure describes a table state X ainsn -> int(>= 0).  */
end_comment

begin_struct
struct|struct
name|state_ainsn_table
block|{
comment|/* Automaton to which given table belongs.  */
name|automaton_t
name|automaton
decl_stmt|;
comment|/* The following tree vectors for comb vector implementation of the      table.  */
name|vla_hwint_t
name|comb_vect
decl_stmt|;
name|vla_hwint_t
name|check_vect
decl_stmt|;
name|vla_hwint_t
name|base_vect
decl_stmt|;
comment|/* This is simple implementation of the table.  */
name|vla_hwint_t
name|full_vect
decl_stmt|;
comment|/* Minimal and maximal values of the previous vectors.  */
name|int
name|min_comb_vect_el_value
decl_stmt|,
name|max_comb_vect_el_value
decl_stmt|;
name|int
name|min_base_vect_el_value
decl_stmt|,
name|max_base_vect_el_value
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Macros to access members of unions.  Use only them for access to    union members of declarations and regexps.  */
end_comment

begin_if
if|#
directive|if
name|defined
name|ENABLE_CHECKING
operator|&&
operator|(
name|GCC_VERSION
operator|>=
literal|2007
operator|)
end_if

begin_define
define|#
directive|define
name|DECL_UNIT
parameter_list|(
name|d
parameter_list|)
value|__extension__					\ (({ struct decl *const _decl = (d);					\      if (_decl->mode != dm_unit)					\        decl_mode_check_failed (_decl->mode, "dm_unit",			\ 			       __FILE__, __LINE__, __FUNCTION__);	\&(_decl)->decl.unit; }))
end_define

begin_define
define|#
directive|define
name|DECL_BYPASS
parameter_list|(
name|d
parameter_list|)
value|__extension__					\ (({ struct decl *const _decl = (d);					\      if (_decl->mode != dm_bypass)					\        decl_mode_check_failed (_decl->mode, "dm_bypass",		\ 			       __FILE__, __LINE__, __FUNCTION__);	\&(_decl)->decl.bypass; }))
end_define

begin_define
define|#
directive|define
name|DECL_AUTOMATON
parameter_list|(
name|d
parameter_list|)
value|__extension__					\ (({ struct decl *const _decl = (d);				       	\      if (_decl->mode != dm_automaton)					\        decl_mode_check_failed (_decl->mode, "dm_automaton",		\ 			       __FILE__, __LINE__, __FUNCTION__);	\&(_decl)->decl.automaton; }))
end_define

begin_define
define|#
directive|define
name|DECL_EXCL
parameter_list|(
name|d
parameter_list|)
value|__extension__					\ (({ struct decl *const _decl = (d);				       	\      if (_decl->mode != dm_excl)					\        decl_mode_check_failed (_decl->mode, "dm_excl",			\ 			       __FILE__, __LINE__, __FUNCTION__);	\&(_decl)->decl.excl; }))
end_define

begin_define
define|#
directive|define
name|DECL_PRESENCE
parameter_list|(
name|d
parameter_list|)
value|__extension__					\ (({ struct decl *const _decl = (d);					\      if (_decl->mode != dm_presence)					\        decl_mode_check_failed (_decl->mode, "dm_presence",		\ 			       __FILE__, __LINE__, __FUNCTION__);	\&(_decl)->decl.presence; }))
end_define

begin_define
define|#
directive|define
name|DECL_ABSENCE
parameter_list|(
name|d
parameter_list|)
value|__extension__					\ (({ struct decl *const _decl = (d);				       	\      if (_decl->mode != dm_absence)					\        decl_mode_check_failed (_decl->mode, "dm_absence",		\ 			       __FILE__, __LINE__, __FUNCTION__);	\&(_decl)->decl.absence; }))
end_define

begin_define
define|#
directive|define
name|DECL_RESERV
parameter_list|(
name|d
parameter_list|)
value|__extension__					\ (({ struct decl *const _decl = (d);					\      if (_decl->mode != dm_reserv)					\        decl_mode_check_failed (_decl->mode, "dm_reserv",		\ 			       __FILE__, __LINE__, __FUNCTION__);	\&(_decl)->decl.reserv; }))
end_define

begin_define
define|#
directive|define
name|DECL_INSN_RESERV
parameter_list|(
name|d
parameter_list|)
value|__extension__				\ (({ struct decl *const _decl = (d);				       	\      if (_decl->mode != dm_insn_reserv)					\        decl_mode_check_failed (_decl->mode, "dm_insn_reserv",		\ 			       __FILE__, __LINE__, __FUNCTION__);	\&(_decl)->decl.insn_reserv; }))
end_define

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|decl_name
name|PARAMS
argument_list|(
operator|(
expr|enum
name|decl_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|decl_mode_check_failed
name|PARAMS
argument_list|(
operator|(
expr|enum
name|decl_mode
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return string representation of declaration mode MODE.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|decl_name
parameter_list|(
name|mode
parameter_list|)
name|enum
name|decl_mode
name|mode
decl_stmt|;
block|{
specifier|static
name|char
name|str
index|[
literal|100
index|]
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|dm_unit
condition|)
return|return
literal|"dm_unit"
return|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|dm_bypass
condition|)
return|return
literal|"dm_bypass"
return|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|dm_automaton
condition|)
return|return
literal|"dm_automaton"
return|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|dm_excl
condition|)
return|return
literal|"dm_excl"
return|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|dm_presence
condition|)
return|return
literal|"dm_presence"
return|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|dm_absence
condition|)
return|return
literal|"dm_absence"
return|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|dm_reserv
condition|)
return|return
literal|"dm_reserv"
return|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|dm_insn_reserv
condition|)
return|return
literal|"dm_insn_reserv"
return|;
else|else
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"unknown (%d)"
argument_list|,
operator|(
name|int
operator|)
name|mode
argument_list|)
expr_stmt|;
return|return
name|str
return|;
block|}
end_function

begin_comment
comment|/* The function prints message about unexpected declaration and finish    the program.  */
end_comment

begin_function
specifier|static
name|void
name|decl_mode_check_failed
parameter_list|(
name|mode
parameter_list|,
name|expected_mode_str
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|,
name|func
parameter_list|)
name|enum
name|decl_mode
name|mode
decl_stmt|;
specifier|const
name|char
modifier|*
name|expected_mode_str
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
specifier|const
name|char
modifier|*
name|func
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n%s: %d: error in %s: DECL check: expected decl %s, have %s\n"
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|func
argument_list|,
name|expected_mode_str
argument_list|,
name|decl_name
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|REGEXP_UNIT
parameter_list|(
name|r
parameter_list|)
value|__extension__					\ (({ struct regexp *const _regexp = (r);					\      if (_regexp->mode != rm_unit)					\        regexp_mode_check_failed (_regexp->mode, "rm_unit",		\ 			       __FILE__, __LINE__, __FUNCTION__);	\&(_regexp)->regexp.unit; }))
end_define

begin_define
define|#
directive|define
name|REGEXP_RESERV
parameter_list|(
name|r
parameter_list|)
value|__extension__					\ (({ struct regexp *const _regexp = (r);					\      if (_regexp->mode != rm_reserv)					\        regexp_mode_check_failed (_regexp->mode, "rm_reserv",		\ 			       __FILE__, __LINE__, __FUNCTION__);	\&(_regexp)->regexp.reserv; }))
end_define

begin_define
define|#
directive|define
name|REGEXP_SEQUENCE
parameter_list|(
name|r
parameter_list|)
value|__extension__				\ (({ struct regexp *const _regexp = (r);					\      if (_regexp->mode != rm_sequence)					\        regexp_mode_check_failed (_regexp->mode, "rm_sequence",		\ 			       __FILE__, __LINE__, __FUNCTION__);	\&(_regexp)->regexp.sequence; }))
end_define

begin_define
define|#
directive|define
name|REGEXP_REPEAT
parameter_list|(
name|r
parameter_list|)
value|__extension__					\ (({ struct regexp *const _regexp = (r);					\      if (_regexp->mode != rm_repeat)					\        regexp_mode_check_failed (_regexp->mode, "rm_repeat",		\ 			       __FILE__, __LINE__, __FUNCTION__);	\&(_regexp)->regexp.repeat; }))
end_define

begin_define
define|#
directive|define
name|REGEXP_ALLOF
parameter_list|(
name|r
parameter_list|)
value|__extension__					\ (({ struct regexp *const _regexp = (r);					\      if (_regexp->mode != rm_allof)					\        regexp_mode_check_failed (_regexp->mode, "rm_allof",		\ 			       __FILE__, __LINE__, __FUNCTION__);	\&(_regexp)->regexp.allof; }))
end_define

begin_define
define|#
directive|define
name|REGEXP_ONEOF
parameter_list|(
name|r
parameter_list|)
value|__extension__					\ (({ struct regexp *const _regexp = (r);					\      if (_regexp->mode != rm_oneof)					\        regexp_mode_check_failed (_regexp->mode, "rm_oneof",		\ 			       __FILE__, __LINE__, __FUNCTION__);	\&(_regexp)->regexp.oneof; }))
end_define

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|regexp_name
name|PARAMS
argument_list|(
operator|(
expr|enum
name|regexp_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|regexp_mode_check_failed
name|PARAMS
argument_list|(
operator|(
expr|enum
name|regexp_mode
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return string representation of regexp mode MODE.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|regexp_name
parameter_list|(
name|mode
parameter_list|)
name|enum
name|regexp_mode
name|mode
decl_stmt|;
block|{
specifier|static
name|char
name|str
index|[
literal|100
index|]
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|rm_unit
condition|)
return|return
literal|"rm_unit"
return|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|rm_reserv
condition|)
return|return
literal|"rm_reserv"
return|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|rm_nothing
condition|)
return|return
literal|"rm_nothing"
return|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|rm_sequence
condition|)
return|return
literal|"rm_sequence"
return|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|rm_repeat
condition|)
return|return
literal|"rm_repeat"
return|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|rm_allof
condition|)
return|return
literal|"rm_allof"
return|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|rm_oneof
condition|)
return|return
literal|"rm_oneof"
return|;
else|else
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"unknown (%d)"
argument_list|,
operator|(
name|int
operator|)
name|mode
argument_list|)
expr_stmt|;
return|return
name|str
return|;
block|}
end_function

begin_comment
comment|/* The function prints message about unexpected regexp and finish the    program.  */
end_comment

begin_function
specifier|static
name|void
name|regexp_mode_check_failed
parameter_list|(
name|mode
parameter_list|,
name|expected_mode_str
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|,
name|func
parameter_list|)
name|enum
name|regexp_mode
name|mode
decl_stmt|;
specifier|const
name|char
modifier|*
name|expected_mode_str
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
specifier|const
name|char
modifier|*
name|func
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n%s: %d: error in %s: REGEXP check: expected decl %s, have %s\n"
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|func
argument_list|,
name|expected_mode_str
argument_list|,
name|regexp_name
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* #if defined ENABLE_RTL_CHECKING&& (GCC_VERSION>= 2007) */
end_comment

begin_define
define|#
directive|define
name|DECL_UNIT
parameter_list|(
name|d
parameter_list|)
value|(&(d)->decl.unit)
end_define

begin_define
define|#
directive|define
name|DECL_BYPASS
parameter_list|(
name|d
parameter_list|)
value|(&(d)->decl.bypass)
end_define

begin_define
define|#
directive|define
name|DECL_AUTOMATON
parameter_list|(
name|d
parameter_list|)
value|(&(d)->decl.automaton)
end_define

begin_define
define|#
directive|define
name|DECL_EXCL
parameter_list|(
name|d
parameter_list|)
value|(&(d)->decl.excl)
end_define

begin_define
define|#
directive|define
name|DECL_PRESENCE
parameter_list|(
name|d
parameter_list|)
value|(&(d)->decl.presence)
end_define

begin_define
define|#
directive|define
name|DECL_ABSENCE
parameter_list|(
name|d
parameter_list|)
value|(&(d)->decl.absence)
end_define

begin_define
define|#
directive|define
name|DECL_RESERV
parameter_list|(
name|d
parameter_list|)
value|(&(d)->decl.reserv)
end_define

begin_define
define|#
directive|define
name|DECL_INSN_RESERV
parameter_list|(
name|d
parameter_list|)
value|(&(d)->decl.insn_reserv)
end_define

begin_define
define|#
directive|define
name|REGEXP_UNIT
parameter_list|(
name|r
parameter_list|)
value|(&(r)->regexp.unit)
end_define

begin_define
define|#
directive|define
name|REGEXP_RESERV
parameter_list|(
name|r
parameter_list|)
value|(&(r)->regexp.reserv)
end_define

begin_define
define|#
directive|define
name|REGEXP_SEQUENCE
parameter_list|(
name|r
parameter_list|)
value|(&(r)->regexp.sequence)
end_define

begin_define
define|#
directive|define
name|REGEXP_REPEAT
parameter_list|(
name|r
parameter_list|)
value|(&(r)->regexp.repeat)
end_define

begin_define
define|#
directive|define
name|REGEXP_ALLOF
parameter_list|(
name|r
parameter_list|)
value|(&(r)->regexp.allof)
end_define

begin_define
define|#
directive|define
name|REGEXP_ONEOF
parameter_list|(
name|r
parameter_list|)
value|(&(r)->regexp.oneof)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* #if defined ENABLE_RTL_CHECKING&& (GCC_VERSION>= 2007) */
end_comment

begin_comment
comment|/* Create IR structure (node).  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|create_node
parameter_list|(
name|size
parameter_list|)
name|size_t
name|size
decl_stmt|;
block|{
name|void
modifier|*
name|result
decl_stmt|;
name|obstack_blank
argument_list|(
operator|&
name|irp
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|result
operator|=
name|obstack_base
argument_list|(
operator|&
name|irp
argument_list|)
expr_stmt|;
name|obstack_finish
argument_list|(
operator|&
name|irp
argument_list|)
expr_stmt|;
comment|/* Default values of members are NULL and zero.  */
name|memset
argument_list|(
name|result
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Copy IR structure (node).  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|copy_node
parameter_list|(
name|from
parameter_list|,
name|size
parameter_list|)
specifier|const
name|void
modifier|*
name|from
decl_stmt|;
name|size_t
name|size
decl_stmt|;
block|{
name|void
modifier|*
specifier|const
name|result
init|=
name|create_node
argument_list|(
name|size
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|result
argument_list|,
name|from
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* The function checks that NAME does not contain quotes (`"').  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|check_name
parameter_list|(
name|name
parameter_list|,
name|pos
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|pos_t
name|pos
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
for|for
control|(
name|str
operator|=
name|name
init|;
operator|*
name|str
operator|!=
literal|'\0'
condition|;
name|str
operator|++
control|)
if|if
condition|(
operator|*
name|str
operator|==
literal|'\"'
condition|)
name|error
argument_list|(
literal|"Name `%s' contains quotes"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|name
return|;
block|}
end_function

begin_comment
comment|/* Pointers top all declartions during IR generation are stored in the    following.  */
end_comment

begin_decl_stmt
specifier|static
name|vla_ptr_t
name|decls
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Given a pointer to a (char *) and a separator, return an alloc'ed    string containing the next separated element, taking parentheses    into account if PAR_FLAG has nonzero value.  Advance the pointer to    after the string scanned, or the end-of-string.  Return NULL if at    end of string.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|next_sep_el
parameter_list|(
name|pstr
parameter_list|,
name|sep
parameter_list|,
name|par_flag
parameter_list|)
name|char
modifier|*
modifier|*
name|pstr
decl_stmt|;
name|int
name|sep
decl_stmt|;
name|int
name|par_flag
decl_stmt|;
block|{
name|char
modifier|*
name|out_str
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|pars_num
decl_stmt|;
name|int
name|n_spaces
decl_stmt|;
comment|/* Remove leading whitespaces.  */
while|while
condition|(
name|ISSPACE
argument_list|(
operator|(
name|int
operator|)
operator|*
operator|*
name|pstr
argument_list|)
condition|)
operator|(
operator|*
name|pstr
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pstr
operator|==
literal|'\0'
condition|)
return|return
name|NULL
return|;
name|n_spaces
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|pars_num
operator|=
literal|0
operator|,
name|p
operator|=
operator|*
name|pstr
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|par_flag
operator|&&
operator|*
name|p
operator|==
literal|'('
condition|)
name|pars_num
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|par_flag
operator|&&
operator|*
name|p
operator|==
literal|')'
condition|)
name|pars_num
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
name|pars_num
operator|==
literal|0
operator|&&
operator|*
name|p
operator|==
name|sep
condition|)
break|break;
if|if
condition|(
name|pars_num
operator|==
literal|0
operator|&&
name|ISSPACE
argument_list|(
operator|(
name|int
operator|)
operator|*
name|p
argument_list|)
condition|)
name|n_spaces
operator|++
expr_stmt|;
else|else
block|{
for|for
control|(
init|;
name|n_spaces
operator|!=
literal|0
condition|;
name|n_spaces
operator|--
control|)
name|obstack_1grow
argument_list|(
operator|&
name|irp
argument_list|,
name|p
index|[
operator|-
name|n_spaces
index|]
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|irp
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
block|}
name|obstack_1grow
argument_list|(
operator|&
name|irp
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
name|out_str
operator|=
name|obstack_base
argument_list|(
operator|&
name|irp
argument_list|)
expr_stmt|;
name|obstack_finish
argument_list|(
operator|&
name|irp
argument_list|)
expr_stmt|;
operator|*
name|pstr
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pstr
operator|==
name|sep
condition|)
operator|(
operator|*
name|pstr
operator|)
operator|++
expr_stmt|;
return|return
name|out_str
return|;
block|}
end_function

begin_comment
comment|/* Given a string and a separator, return the number of separated    elements in it, taking parentheses into account if PAR_FLAG has    nonzero value.  Return 0 for the null string, -1 if parantheses is    not balanced.  */
end_comment

begin_function
specifier|static
name|int
name|n_sep_els
parameter_list|(
name|s
parameter_list|,
name|sep
parameter_list|,
name|par_flag
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|sep
decl_stmt|;
name|int
name|par_flag
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
name|int
name|pars_num
decl_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
for|for
control|(
name|pars_num
operator|=
literal|0
operator|,
name|n
operator|=
literal|1
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
if|if
condition|(
name|par_flag
operator|&&
operator|*
name|s
operator|==
literal|'('
condition|)
name|pars_num
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|par_flag
operator|&&
operator|*
name|s
operator|==
literal|')'
condition|)
name|pars_num
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
name|pars_num
operator|==
literal|0
operator|&&
operator|*
name|s
operator|==
name|sep
condition|)
name|n
operator|++
expr_stmt|;
return|return
operator|(
name|pars_num
operator|!=
literal|0
condition|?
operator|-
literal|1
else|:
name|n
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Given a string and a separator, return vector of strings which are    elements in the string and number of elements through els_num.    Take parentheses into account if PAR_FLAG has nonzero value.    Return 0 for the null string, -1 if parantheses are not balanced.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
modifier|*
name|get_str_vect
parameter_list|(
name|str
parameter_list|,
name|els_num
parameter_list|,
name|sep
parameter_list|,
name|par_flag
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|int
modifier|*
name|els_num
decl_stmt|;
name|int
name|sep
decl_stmt|;
name|int
name|par_flag
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
modifier|*
name|vect
decl_stmt|;
name|char
modifier|*
modifier|*
name|pstr
decl_stmt|;
operator|*
name|els_num
operator|=
name|n_sep_els
argument_list|(
name|str
argument_list|,
name|sep
argument_list|,
name|par_flag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|els_num
operator|<=
literal|0
condition|)
return|return
name|NULL
return|;
name|obstack_blank
argument_list|(
operator|&
name|irp
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
operator|*
name|els_num
operator|)
argument_list|)
expr_stmt|;
name|vect
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|obstack_base
argument_list|(
operator|&
name|irp
argument_list|)
expr_stmt|;
name|obstack_finish
argument_list|(
operator|&
name|irp
argument_list|)
expr_stmt|;
name|pstr
operator|=
operator|&
name|str
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|*
name|els_num
condition|;
name|i
operator|++
control|)
name|vect
index|[
name|i
index|]
operator|=
name|next_sep_el
argument_list|(
name|pstr
argument_list|,
name|sep
argument_list|,
name|par_flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_sep_el
argument_list|(
name|pstr
argument_list|,
name|sep
argument_list|,
name|par_flag
argument_list|)
operator|!=
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|vect
return|;
block|}
end_function

begin_comment
comment|/* Process a DEFINE_CPU_UNIT.       This gives information about a unit contained in CPU.  We fill a    struct unit_decl with information used later by `expand_automata'.  */
end_comment

begin_function
name|void
name|gen_cpu_unit
parameter_list|(
name|def
parameter_list|)
name|rtx
name|def
decl_stmt|;
block|{
name|decl_t
name|decl
decl_stmt|;
name|char
modifier|*
modifier|*
name|str_cpu_units
decl_stmt|;
name|int
name|vect_length
decl_stmt|;
name|int
name|i
decl_stmt|;
name|str_cpu_units
operator|=
name|get_str_vect
argument_list|(
operator|(
name|char
operator|*
operator|)
name|XSTR
argument_list|(
name|def
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|vect_length
argument_list|,
literal|','
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|str_cpu_units
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"invalid string `%s' in define_cpu_unit"
argument_list|,
name|XSTR
argument_list|(
name|def
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vect_length
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|decl
operator|->
name|mode
operator|=
name|dm_unit
expr_stmt|;
name|decl
operator|->
name|pos
operator|=
literal|0
expr_stmt|;
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|name
operator|=
name|check_name
argument_list|(
name|str_cpu_units
index|[
name|i
index|]
argument_list|,
name|decl
operator|->
name|pos
argument_list|)
expr_stmt|;
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|automaton_name
operator|=
operator|(
name|char
operator|*
operator|)
name|XSTR
argument_list|(
name|def
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|query_p
operator|=
literal|0
expr_stmt|;
name|VLA_PTR_ADD
argument_list|(
name|decls
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|num_dfa_decls
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Process a DEFINE_QUERY_CPU_UNIT.       This gives information about a unit contained in CPU.  We fill a    struct unit_decl with information used later by `expand_automata'.  */
end_comment

begin_function
name|void
name|gen_query_cpu_unit
parameter_list|(
name|def
parameter_list|)
name|rtx
name|def
decl_stmt|;
block|{
name|decl_t
name|decl
decl_stmt|;
name|char
modifier|*
modifier|*
name|str_cpu_units
decl_stmt|;
name|int
name|vect_length
decl_stmt|;
name|int
name|i
decl_stmt|;
name|str_cpu_units
operator|=
name|get_str_vect
argument_list|(
operator|(
name|char
operator|*
operator|)
name|XSTR
argument_list|(
name|def
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|vect_length
argument_list|,
literal|','
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|str_cpu_units
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"invalid string `%s' in define_query_cpu_unit"
argument_list|,
name|XSTR
argument_list|(
name|def
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vect_length
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|decl
operator|->
name|mode
operator|=
name|dm_unit
expr_stmt|;
name|decl
operator|->
name|pos
operator|=
literal|0
expr_stmt|;
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|name
operator|=
name|check_name
argument_list|(
name|str_cpu_units
index|[
name|i
index|]
argument_list|,
name|decl
operator|->
name|pos
argument_list|)
expr_stmt|;
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|automaton_name
operator|=
operator|(
name|char
operator|*
operator|)
name|XSTR
argument_list|(
name|def
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|query_p
operator|=
literal|1
expr_stmt|;
name|VLA_PTR_ADD
argument_list|(
name|decls
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|num_dfa_decls
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Process a DEFINE_BYPASS.       This gives information about a unit contained in the CPU.  We fill    in a struct bypass_decl with information used later by    `expand_automata'.  */
end_comment

begin_function
name|void
name|gen_bypass
parameter_list|(
name|def
parameter_list|)
name|rtx
name|def
decl_stmt|;
block|{
name|decl_t
name|decl
decl_stmt|;
name|char
modifier|*
modifier|*
name|out_insns
decl_stmt|;
name|int
name|out_length
decl_stmt|;
name|char
modifier|*
modifier|*
name|in_insns
decl_stmt|;
name|int
name|in_length
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|out_insns
operator|=
name|get_str_vect
argument_list|(
operator|(
name|char
operator|*
operator|)
name|XSTR
argument_list|(
name|def
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|&
name|out_length
argument_list|,
literal|','
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|out_insns
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"invalid string `%s' in define_bypass"
argument_list|,
name|XSTR
argument_list|(
name|def
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|in_insns
operator|=
name|get_str_vect
argument_list|(
operator|(
name|char
operator|*
operator|)
name|XSTR
argument_list|(
name|def
argument_list|,
literal|2
argument_list|)
argument_list|,
operator|&
name|in_length
argument_list|,
literal|','
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_insns
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"invalid string `%s' in define_bypass"
argument_list|,
name|XSTR
argument_list|(
name|def
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|out_length
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|in_length
condition|;
name|j
operator|++
control|)
block|{
name|decl
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|decl
operator|->
name|mode
operator|=
name|dm_bypass
expr_stmt|;
name|decl
operator|->
name|pos
operator|=
literal|0
expr_stmt|;
name|DECL_BYPASS
argument_list|(
name|decl
argument_list|)
operator|->
name|latency
operator|=
name|XINT
argument_list|(
name|def
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DECL_BYPASS
argument_list|(
name|decl
argument_list|)
operator|->
name|out_insn_name
operator|=
name|out_insns
index|[
name|i
index|]
expr_stmt|;
name|DECL_BYPASS
argument_list|(
name|decl
argument_list|)
operator|->
name|in_insn_name
operator|=
name|in_insns
index|[
name|j
index|]
expr_stmt|;
name|DECL_BYPASS
argument_list|(
name|decl
argument_list|)
operator|->
name|bypass_guard_name
operator|=
operator|(
name|char
operator|*
operator|)
name|XSTR
argument_list|(
name|def
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|VLA_PTR_ADD
argument_list|(
name|decls
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|num_dfa_decls
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Process an EXCLUSION_SET.       This gives information about a cpu unit conflicts.  We fill a    struct unit_rel_decl (excl) with information used later by    `expand_automata'.  */
end_comment

begin_function
name|void
name|gen_excl_set
parameter_list|(
name|def
parameter_list|)
name|rtx
name|def
decl_stmt|;
block|{
name|decl_t
name|decl
decl_stmt|;
name|char
modifier|*
modifier|*
name|first_str_cpu_units
decl_stmt|;
name|char
modifier|*
modifier|*
name|second_str_cpu_units
decl_stmt|;
name|int
name|first_vect_length
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|i
decl_stmt|;
name|first_str_cpu_units
operator|=
name|get_str_vect
argument_list|(
operator|(
name|char
operator|*
operator|)
name|XSTR
argument_list|(
name|def
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|first_vect_length
argument_list|,
literal|','
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_str_cpu_units
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"invalid first string `%s' in exclusion_set"
argument_list|,
name|XSTR
argument_list|(
name|def
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|second_str_cpu_units
operator|=
name|get_str_vect
argument_list|(
operator|(
name|char
operator|*
operator|)
name|XSTR
argument_list|(
name|def
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|&
name|length
argument_list|,
literal|','
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|second_str_cpu_units
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"invalid second string `%s' in exclusion_set"
argument_list|,
name|XSTR
argument_list|(
name|def
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|length
operator|+=
name|first_vect_length
expr_stmt|;
name|decl
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|decl
argument_list|)
operator|+
operator|(
name|length
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|decl
operator|->
name|mode
operator|=
name|dm_excl
expr_stmt|;
name|decl
operator|->
name|pos
operator|=
literal|0
expr_stmt|;
name|DECL_EXCL
argument_list|(
name|decl
argument_list|)
operator|->
name|names_num
operator|=
name|length
expr_stmt|;
name|DECL_EXCL
argument_list|(
name|decl
argument_list|)
operator|->
name|first_list_length
operator|=
name|first_vect_length
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|i
operator|<
name|first_vect_length
condition|)
name|DECL_EXCL
argument_list|(
name|decl
argument_list|)
operator|->
name|names
index|[
name|i
index|]
operator|=
name|first_str_cpu_units
index|[
name|i
index|]
expr_stmt|;
else|else
name|DECL_EXCL
argument_list|(
name|decl
argument_list|)
operator|->
name|names
index|[
name|i
index|]
operator|=
name|second_str_cpu_units
index|[
name|i
operator|-
name|first_vect_length
index|]
expr_stmt|;
name|VLA_PTR_ADD
argument_list|(
name|decls
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|num_dfa_decls
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process a PRESENCE_SET.       This gives information about a cpu unit reservation requirements.    We fill a struct unit_rel_decl (presence) with information used    later by `expand_automata'.  */
end_comment

begin_function
name|void
name|gen_presence_set
parameter_list|(
name|def
parameter_list|)
name|rtx
name|def
decl_stmt|;
block|{
name|decl_t
name|decl
decl_stmt|;
name|char
modifier|*
modifier|*
name|first_str_cpu_units
decl_stmt|;
name|char
modifier|*
modifier|*
name|second_str_cpu_units
decl_stmt|;
name|int
name|first_vect_length
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|i
decl_stmt|;
name|first_str_cpu_units
operator|=
name|get_str_vect
argument_list|(
operator|(
name|char
operator|*
operator|)
name|XSTR
argument_list|(
name|def
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|first_vect_length
argument_list|,
literal|','
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_str_cpu_units
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"invalid first string `%s' in presence_set"
argument_list|,
name|XSTR
argument_list|(
name|def
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|second_str_cpu_units
operator|=
name|get_str_vect
argument_list|(
operator|(
name|char
operator|*
operator|)
name|XSTR
argument_list|(
name|def
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|&
name|length
argument_list|,
literal|','
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|second_str_cpu_units
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"invalid second string `%s' in presence_set"
argument_list|,
name|XSTR
argument_list|(
name|def
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|length
operator|+=
name|first_vect_length
expr_stmt|;
name|decl
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|decl
argument_list|)
operator|+
operator|(
name|length
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|decl
operator|->
name|mode
operator|=
name|dm_presence
expr_stmt|;
name|decl
operator|->
name|pos
operator|=
literal|0
expr_stmt|;
name|DECL_PRESENCE
argument_list|(
name|decl
argument_list|)
operator|->
name|names_num
operator|=
name|length
expr_stmt|;
name|DECL_PRESENCE
argument_list|(
name|decl
argument_list|)
operator|->
name|first_list_length
operator|=
name|first_vect_length
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|i
operator|<
name|first_vect_length
condition|)
name|DECL_PRESENCE
argument_list|(
name|decl
argument_list|)
operator|->
name|names
index|[
name|i
index|]
operator|=
name|first_str_cpu_units
index|[
name|i
index|]
expr_stmt|;
else|else
name|DECL_PRESENCE
argument_list|(
name|decl
argument_list|)
operator|->
name|names
index|[
name|i
index|]
operator|=
name|second_str_cpu_units
index|[
name|i
operator|-
name|first_vect_length
index|]
expr_stmt|;
name|VLA_PTR_ADD
argument_list|(
name|decls
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|num_dfa_decls
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process an ABSENCE_SET.       This gives information about a cpu unit reservation requirements.    We fill a struct unit_rel_decl (absence) with information used    later by `expand_automata'.  */
end_comment

begin_function
name|void
name|gen_absence_set
parameter_list|(
name|def
parameter_list|)
name|rtx
name|def
decl_stmt|;
block|{
name|decl_t
name|decl
decl_stmt|;
name|char
modifier|*
modifier|*
name|first_str_cpu_units
decl_stmt|;
name|char
modifier|*
modifier|*
name|second_str_cpu_units
decl_stmt|;
name|int
name|first_vect_length
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|i
decl_stmt|;
name|first_str_cpu_units
operator|=
name|get_str_vect
argument_list|(
operator|(
name|char
operator|*
operator|)
name|XSTR
argument_list|(
name|def
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|first_vect_length
argument_list|,
literal|','
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_str_cpu_units
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"invalid first string `%s' in absence_set"
argument_list|,
name|XSTR
argument_list|(
name|def
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|second_str_cpu_units
operator|=
name|get_str_vect
argument_list|(
operator|(
name|char
operator|*
operator|)
name|XSTR
argument_list|(
name|def
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|&
name|length
argument_list|,
literal|','
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|second_str_cpu_units
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"invalid second string `%s' in absence_set"
argument_list|,
name|XSTR
argument_list|(
name|def
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|length
operator|+=
name|first_vect_length
expr_stmt|;
name|decl
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|decl
argument_list|)
operator|+
operator|(
name|length
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|decl
operator|->
name|mode
operator|=
name|dm_absence
expr_stmt|;
name|decl
operator|->
name|pos
operator|=
literal|0
expr_stmt|;
name|DECL_ABSENCE
argument_list|(
name|decl
argument_list|)
operator|->
name|names_num
operator|=
name|length
expr_stmt|;
name|DECL_ABSENCE
argument_list|(
name|decl
argument_list|)
operator|->
name|first_list_length
operator|=
name|first_vect_length
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|i
operator|<
name|first_vect_length
condition|)
name|DECL_ABSENCE
argument_list|(
name|decl
argument_list|)
operator|->
name|names
index|[
name|i
index|]
operator|=
name|first_str_cpu_units
index|[
name|i
index|]
expr_stmt|;
else|else
name|DECL_ABSENCE
argument_list|(
name|decl
argument_list|)
operator|->
name|names
index|[
name|i
index|]
operator|=
name|second_str_cpu_units
index|[
name|i
operator|-
name|first_vect_length
index|]
expr_stmt|;
name|VLA_PTR_ADD
argument_list|(
name|decls
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|num_dfa_decls
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process a DEFINE_AUTOMATON.       This gives information about a finite state automaton used for    recognizing pipeline hazards.  We fill a struct automaton_decl    with information used later by `expand_automata'.  */
end_comment

begin_function
name|void
name|gen_automaton
parameter_list|(
name|def
parameter_list|)
name|rtx
name|def
decl_stmt|;
block|{
name|decl_t
name|decl
decl_stmt|;
name|char
modifier|*
modifier|*
name|str_automata
decl_stmt|;
name|int
name|vect_length
decl_stmt|;
name|int
name|i
decl_stmt|;
name|str_automata
operator|=
name|get_str_vect
argument_list|(
operator|(
name|char
operator|*
operator|)
name|XSTR
argument_list|(
name|def
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|vect_length
argument_list|,
literal|','
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|str_automata
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"invalid string `%s' in define_automaton"
argument_list|,
name|XSTR
argument_list|(
name|def
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vect_length
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|decl
operator|->
name|mode
operator|=
name|dm_automaton
expr_stmt|;
name|decl
operator|->
name|pos
operator|=
literal|0
expr_stmt|;
name|DECL_AUTOMATON
argument_list|(
name|decl
argument_list|)
operator|->
name|name
operator|=
name|check_name
argument_list|(
name|str_automata
index|[
name|i
index|]
argument_list|,
name|decl
operator|->
name|pos
argument_list|)
expr_stmt|;
name|VLA_PTR_ADD
argument_list|(
name|decls
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|num_dfa_decls
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Process an AUTOMATA_OPTION.       This gives information how to generate finite state automaton used    for recognizing pipeline hazards.  */
end_comment

begin_function
name|void
name|gen_automata_option
parameter_list|(
name|def
parameter_list|)
name|rtx
name|def
decl_stmt|;
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|XSTR
argument_list|(
name|def
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NO_MINIMIZATION_OPTION
operator|+
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|no_minimization_flag
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|XSTR
argument_list|(
name|def
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TIME_OPTION
operator|+
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|time_flag
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|XSTR
argument_list|(
name|def
argument_list|,
literal|0
argument_list|)
argument_list|,
name|V_OPTION
operator|+
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|v_flag
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|XSTR
argument_list|(
name|def
argument_list|,
literal|0
argument_list|)
argument_list|,
name|W_OPTION
operator|+
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|w_flag
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|XSTR
argument_list|(
name|def
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NDFA_OPTION
operator|+
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|ndfa_flag
operator|=
literal|1
expr_stmt|;
else|else
name|fatal
argument_list|(
literal|"invalid option `%s' in automata_option"
argument_list|,
name|XSTR
argument_list|(
name|def
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Name in reservation to denote absence reservation.  */
end_comment

begin_define
define|#
directive|define
name|NOTHING_NAME
value|"nothing"
end_define

begin_comment
comment|/* The following string contains original reservation string being    parsed.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|reserv_str
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parse an element in STR.  */
end_comment

begin_function
specifier|static
name|regexp_t
name|gen_regexp_el
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|regexp_t
name|regexp
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|'('
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
index|[
name|len
operator|-
literal|1
index|]
operator|!=
literal|')'
condition|)
name|fatal
argument_list|(
literal|"garbage after ) in reservation `%s'"
argument_list|,
name|reserv_str
argument_list|)
expr_stmt|;
name|str
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|regexp
operator|=
name|gen_regexp_sequence
argument_list|(
name|str
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
name|NOTHING_NAME
argument_list|)
operator|==
literal|0
condition|)
block|{
name|regexp
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|regexp
operator|->
name|mode
operator|=
name|rm_nothing
expr_stmt|;
block|}
else|else
block|{
name|regexp
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|regexp
operator|->
name|mode
operator|=
name|rm_unit
expr_stmt|;
name|REGEXP_UNIT
argument_list|(
name|regexp
argument_list|)
operator|->
name|name
operator|=
name|str
expr_stmt|;
block|}
return|return
name|regexp
return|;
block|}
end_function

begin_comment
comment|/* Parse construction `repeat' in STR.  */
end_comment

begin_function
specifier|static
name|regexp_t
name|gen_regexp_repeat
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|regexp_t
name|regexp
decl_stmt|;
name|regexp_t
name|repeat
decl_stmt|;
name|char
modifier|*
modifier|*
name|repeat_vect
decl_stmt|;
name|int
name|els_num
decl_stmt|;
name|int
name|i
decl_stmt|;
name|repeat_vect
operator|=
name|get_str_vect
argument_list|(
name|str
argument_list|,
operator|&
name|els_num
argument_list|,
literal|'*'
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|repeat_vect
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"invalid `%s' in reservation `%s'"
argument_list|,
name|str
argument_list|,
name|reserv_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|els_num
operator|>
literal|1
condition|)
block|{
name|regexp
operator|=
name|gen_regexp_el
argument_list|(
name|repeat_vect
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|els_num
condition|;
name|i
operator|++
control|)
block|{
name|repeat
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|regexp
argument_list|)
argument_list|)
expr_stmt|;
name|repeat
operator|->
name|mode
operator|=
name|rm_repeat
expr_stmt|;
name|REGEXP_REPEAT
argument_list|(
name|repeat
argument_list|)
operator|->
name|regexp
operator|=
name|regexp
expr_stmt|;
name|REGEXP_REPEAT
argument_list|(
name|repeat
argument_list|)
operator|->
name|repeat_num
operator|=
name|atoi
argument_list|(
name|repeat_vect
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|REGEXP_REPEAT
argument_list|(
name|repeat
argument_list|)
operator|->
name|repeat_num
operator|<=
literal|1
condition|)
name|fatal
argument_list|(
literal|"repetition `%s'<= 1 in reservation `%s'"
argument_list|,
name|str
argument_list|,
name|reserv_str
argument_list|)
expr_stmt|;
name|regexp
operator|=
name|repeat
expr_stmt|;
block|}
return|return
name|regexp
return|;
block|}
else|else
return|return
name|gen_regexp_el
argument_list|(
name|str
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse reservation STR which possibly contains separator '+'.  */
end_comment

begin_function
specifier|static
name|regexp_t
name|gen_regexp_allof
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|regexp_t
name|allof
decl_stmt|;
name|char
modifier|*
modifier|*
name|allof_vect
decl_stmt|;
name|int
name|els_num
decl_stmt|;
name|int
name|i
decl_stmt|;
name|allof_vect
operator|=
name|get_str_vect
argument_list|(
name|str
argument_list|,
operator|&
name|els_num
argument_list|,
literal|'+'
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|allof_vect
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"invalid `%s' in reservation `%s'"
argument_list|,
name|str
argument_list|,
name|reserv_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|els_num
operator|>
literal|1
condition|)
block|{
name|allof
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|regexp
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|regexp_t
argument_list|)
operator|*
operator|(
name|els_num
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|allof
operator|->
name|mode
operator|=
name|rm_allof
expr_stmt|;
name|REGEXP_ALLOF
argument_list|(
name|allof
argument_list|)
operator|->
name|regexps_num
operator|=
name|els_num
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|els_num
condition|;
name|i
operator|++
control|)
name|REGEXP_ALLOF
argument_list|(
name|allof
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
operator|=
name|gen_regexp_repeat
argument_list|(
name|allof_vect
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
name|allof
return|;
block|}
else|else
return|return
name|gen_regexp_repeat
argument_list|(
name|str
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse reservation STR which possibly contains separator '|'.  */
end_comment

begin_function
specifier|static
name|regexp_t
name|gen_regexp_oneof
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|regexp_t
name|oneof
decl_stmt|;
name|char
modifier|*
modifier|*
name|oneof_vect
decl_stmt|;
name|int
name|els_num
decl_stmt|;
name|int
name|i
decl_stmt|;
name|oneof_vect
operator|=
name|get_str_vect
argument_list|(
name|str
argument_list|,
operator|&
name|els_num
argument_list|,
literal|'|'
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|oneof_vect
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"invalid `%s' in reservation `%s'"
argument_list|,
name|str
argument_list|,
name|reserv_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|els_num
operator|>
literal|1
condition|)
block|{
name|oneof
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|regexp
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|regexp_t
argument_list|)
operator|*
operator|(
name|els_num
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|oneof
operator|->
name|mode
operator|=
name|rm_oneof
expr_stmt|;
name|REGEXP_ONEOF
argument_list|(
name|oneof
argument_list|)
operator|->
name|regexps_num
operator|=
name|els_num
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|els_num
condition|;
name|i
operator|++
control|)
name|REGEXP_ONEOF
argument_list|(
name|oneof
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
operator|=
name|gen_regexp_allof
argument_list|(
name|oneof_vect
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
name|oneof
return|;
block|}
else|else
return|return
name|gen_regexp_allof
argument_list|(
name|str
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse reservation STR which possibly contains separator ','.  */
end_comment

begin_function
specifier|static
name|regexp_t
name|gen_regexp_sequence
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|regexp_t
name|sequence
decl_stmt|;
name|char
modifier|*
modifier|*
name|sequence_vect
decl_stmt|;
name|int
name|els_num
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sequence_vect
operator|=
name|get_str_vect
argument_list|(
name|str
argument_list|,
operator|&
name|els_num
argument_list|,
literal|','
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|els_num
operator|>
literal|1
condition|)
block|{
name|sequence
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|regexp
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|regexp_t
argument_list|)
operator|*
operator|(
name|els_num
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|sequence
operator|->
name|mode
operator|=
name|rm_sequence
expr_stmt|;
name|REGEXP_SEQUENCE
argument_list|(
name|sequence
argument_list|)
operator|->
name|regexps_num
operator|=
name|els_num
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|els_num
condition|;
name|i
operator|++
control|)
name|REGEXP_SEQUENCE
argument_list|(
name|sequence
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
operator|=
name|gen_regexp_oneof
argument_list|(
name|sequence_vect
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
name|sequence
return|;
block|}
else|else
return|return
name|gen_regexp_oneof
argument_list|(
name|str
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse construction reservation STR.  */
end_comment

begin_function
specifier|static
name|regexp_t
name|gen_regexp
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|reserv_str
operator|=
name|str
expr_stmt|;
return|return
name|gen_regexp_sequence
argument_list|(
name|str
argument_list|)
return|;
empty_stmt|;
block|}
end_function

begin_comment
comment|/* Process a DEFINE_RESERVATION.     This gives information about a reservation of cpu units.  We fill    in a struct reserv_decl with information used later by    `expand_automata'.  */
end_comment

begin_function
name|void
name|gen_reserv
parameter_list|(
name|def
parameter_list|)
name|rtx
name|def
decl_stmt|;
block|{
name|decl_t
name|decl
decl_stmt|;
name|decl
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|decl
operator|->
name|mode
operator|=
name|dm_reserv
expr_stmt|;
name|decl
operator|->
name|pos
operator|=
literal|0
expr_stmt|;
name|DECL_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|name
operator|=
name|check_name
argument_list|(
operator|(
name|char
operator|*
operator|)
name|XSTR
argument_list|(
name|def
argument_list|,
literal|0
argument_list|)
argument_list|,
name|decl
operator|->
name|pos
argument_list|)
expr_stmt|;
name|DECL_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|regexp
operator|=
name|gen_regexp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|XSTR
argument_list|(
name|def
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|VLA_PTR_ADD
argument_list|(
name|decls
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|num_dfa_decls
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process a DEFINE_INSN_RESERVATION.     This gives information about the reservation of cpu units by an    insn.  We fill a struct insn_reserv_decl with information used    later by `expand_automata'.  */
end_comment

begin_function
name|void
name|gen_insn_reserv
parameter_list|(
name|def
parameter_list|)
name|rtx
name|def
decl_stmt|;
block|{
name|decl_t
name|decl
decl_stmt|;
name|decl
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|decl
operator|->
name|mode
operator|=
name|dm_insn_reserv
expr_stmt|;
name|decl
operator|->
name|pos
operator|=
literal|0
expr_stmt|;
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|name
operator|=
name|check_name
argument_list|(
operator|(
name|char
operator|*
operator|)
name|XSTR
argument_list|(
name|def
argument_list|,
literal|0
argument_list|)
argument_list|,
name|decl
operator|->
name|pos
argument_list|)
expr_stmt|;
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|default_latency
operator|=
name|XINT
argument_list|(
name|def
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|condexp
operator|=
name|XEXP
argument_list|(
name|def
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|regexp
operator|=
name|gen_regexp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|XSTR
argument_list|(
name|def
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|VLA_PTR_ADD
argument_list|(
name|decls
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|num_dfa_decls
operator|++
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The function evaluates hash value (0..UINT_MAX) of string.  */
end_comment

begin_function
specifier|static
name|unsigned
name|string_hash
parameter_list|(
name|string
parameter_list|)
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|unsigned
name|result
decl_stmt|,
name|i
decl_stmt|;
for|for
control|(
name|result
operator|=
name|i
operator|=
literal|0
init|;
operator|*
name|string
operator|++
operator|!=
literal|'\0'
condition|;
name|i
operator|++
control|)
name|result
operator|+=
operator|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|string
operator|<<
operator|(
name|i
operator|%
name|CHAR_BIT
operator|)
operator|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This page contains abstract data `table of automaton declarations'.    Elements of the table is nodes representing automaton declarations.    Key of the table elements is name of given automaton.  Rememeber    that automaton names have own space.  */
end_comment

begin_comment
comment|/* The function evaluates hash value of an automaton declaration.  The    function is used by abstract data `hashtab'.  The function returns    hash value (0..UINT_MAX) of given automaton declaration.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|automaton_decl_hash
parameter_list|(
name|automaton_decl
parameter_list|)
specifier|const
name|void
modifier|*
name|automaton_decl
decl_stmt|;
block|{
specifier|const
name|decl_t
name|decl
init|=
operator|(
name|decl_t
operator|)
name|automaton_decl
decl_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_automaton
operator|&&
name|DECL_AUTOMATON
argument_list|(
name|decl
argument_list|)
operator|->
name|name
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|string_hash
argument_list|(
name|DECL_AUTOMATON
argument_list|(
name|decl
argument_list|)
operator|->
name|name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The function tests automaton declarations on equality of their    keys.  The function is used by abstract data `hashtab'.  The    function returns 1 if the declarations have the same key, 0    otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|automaton_decl_eq_p
parameter_list|(
name|automaton_decl_1
parameter_list|,
name|automaton_decl_2
parameter_list|)
specifier|const
name|void
modifier|*
name|automaton_decl_1
decl_stmt|;
specifier|const
name|void
modifier|*
name|automaton_decl_2
decl_stmt|;
block|{
specifier|const
name|decl_t
name|decl1
init|=
operator|(
name|decl_t
operator|)
name|automaton_decl_1
decl_stmt|;
specifier|const
name|decl_t
name|decl2
init|=
operator|(
name|decl_t
operator|)
name|automaton_decl_2
decl_stmt|;
if|if
condition|(
name|decl1
operator|->
name|mode
operator|!=
name|dm_automaton
operator|||
name|DECL_AUTOMATON
argument_list|(
name|decl1
argument_list|)
operator|->
name|name
operator|==
name|NULL
operator|||
name|decl2
operator|->
name|mode
operator|!=
name|dm_automaton
operator|||
name|DECL_AUTOMATON
argument_list|(
name|decl2
argument_list|)
operator|->
name|name
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|strcmp
argument_list|(
name|DECL_AUTOMATON
argument_list|(
name|decl1
argument_list|)
operator|->
name|name
argument_list|,
name|DECL_AUTOMATON
argument_list|(
name|decl2
argument_list|)
operator|->
name|name
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* The automaton declaration table itself is represented by the    following variable.  */
end_comment

begin_decl_stmt
specifier|static
name|htab_t
name|automaton_decl_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The function inserts automaton declaration into the table.  The    function does nothing if an automaton declaration with the same key    exists already in the table.  The function returns automaton    declaration node in the table with the same key as given automaton    declaration node.  */
end_comment

begin_function
specifier|static
name|decl_t
name|insert_automaton_decl
parameter_list|(
name|automaton_decl
parameter_list|)
name|decl_t
name|automaton_decl
decl_stmt|;
block|{
name|void
modifier|*
modifier|*
name|entry_ptr
decl_stmt|;
name|entry_ptr
operator|=
name|htab_find_slot
argument_list|(
name|automaton_decl_table
argument_list|,
name|automaton_decl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|entry_ptr
operator|==
name|NULL
condition|)
operator|*
name|entry_ptr
operator|=
operator|(
name|void
operator|*
operator|)
name|automaton_decl
expr_stmt|;
return|return
operator|(
name|decl_t
operator|)
operator|*
name|entry_ptr
return|;
block|}
end_function

begin_comment
comment|/* The following variable value is node representing automaton    declaration.  The node used for searching automaton declaration    with given name.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|decl
name|work_automaton_decl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The function searches for automaton declaration in the table with    the same key as node representing name of the automaton    declaration.  The function returns node found in the table, NULL if    such node does not exist in the table.  */
end_comment

begin_function
specifier|static
name|decl_t
name|find_automaton_decl
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|void
modifier|*
name|entry
decl_stmt|;
name|work_automaton_decl
operator|.
name|mode
operator|=
name|dm_automaton
expr_stmt|;
name|DECL_AUTOMATON
argument_list|(
operator|&
name|work_automaton_decl
argument_list|)
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|entry
operator|=
name|htab_find
argument_list|(
name|automaton_decl_table
argument_list|,
operator|&
name|work_automaton_decl
argument_list|)
expr_stmt|;
return|return
operator|(
name|decl_t
operator|)
name|entry
return|;
block|}
end_function

begin_comment
comment|/* The function creates empty automaton declaration table and node    representing automaton declaration and used for searching automaton    declaration with given name.  The function must be called only once    before any work with the automaton declaration table.  */
end_comment

begin_function
specifier|static
name|void
name|initiate_automaton_decl_table
parameter_list|()
block|{
name|work_automaton_decl
operator|.
name|mode
operator|=
name|dm_automaton
expr_stmt|;
name|automaton_decl_table
operator|=
name|htab_create
argument_list|(
literal|10
argument_list|,
name|automaton_decl_hash
argument_list|,
name|automaton_decl_eq_p
argument_list|,
operator|(
name|htab_del
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function deletes the automaton declaration table.  Only call of    function `initiate_automaton_decl_table' is possible immediately    after this function call.  */
end_comment

begin_function
specifier|static
name|void
name|finish_automaton_decl_table
parameter_list|()
block|{
name|htab_delete
argument_list|(
name|automaton_decl_table
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This page contains abstract data `table of insn declarations'.    Elements of the table is nodes representing insn declarations.  Key    of the table elements is name of given insn (in corresponding    define_insn_reservation).  Rememeber that insn names have own    space.  */
end_comment

begin_comment
comment|/* The function evaluates hash value of an insn declaration.  The    function is used by abstract data `hashtab'.  The function returns    hash value (0..UINT_MAX) of given insn declaration.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|insn_decl_hash
parameter_list|(
name|insn_decl
parameter_list|)
specifier|const
name|void
modifier|*
name|insn_decl
decl_stmt|;
block|{
specifier|const
name|decl_t
name|decl
init|=
operator|(
name|decl_t
operator|)
name|insn_decl
decl_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|!=
name|dm_insn_reserv
operator|||
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|name
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|string_hash
argument_list|(
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The function tests insn declarations on equality of their keys.    The function is used by abstract data `hashtab'.  The function    returns 1 if declarations have the same key, 0 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|insn_decl_eq_p
parameter_list|(
name|insn_decl_1
parameter_list|,
name|insn_decl_2
parameter_list|)
specifier|const
name|void
modifier|*
name|insn_decl_1
decl_stmt|;
specifier|const
name|void
modifier|*
name|insn_decl_2
decl_stmt|;
block|{
specifier|const
name|decl_t
name|decl1
init|=
operator|(
name|decl_t
operator|)
name|insn_decl_1
decl_stmt|;
specifier|const
name|decl_t
name|decl2
init|=
operator|(
name|decl_t
operator|)
name|insn_decl_2
decl_stmt|;
if|if
condition|(
name|decl1
operator|->
name|mode
operator|!=
name|dm_insn_reserv
operator|||
name|DECL_INSN_RESERV
argument_list|(
name|decl1
argument_list|)
operator|->
name|name
operator|==
name|NULL
operator|||
name|decl2
operator|->
name|mode
operator|!=
name|dm_insn_reserv
operator|||
name|DECL_INSN_RESERV
argument_list|(
name|decl2
argument_list|)
operator|->
name|name
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|strcmp
argument_list|(
name|DECL_INSN_RESERV
argument_list|(
name|decl1
argument_list|)
operator|->
name|name
argument_list|,
name|DECL_INSN_RESERV
argument_list|(
name|decl2
argument_list|)
operator|->
name|name
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* The insn declaration table itself is represented by the following    variable.  The table does not contain insn reservation    declarations.  */
end_comment

begin_decl_stmt
specifier|static
name|htab_t
name|insn_decl_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The function inserts insn declaration into the table.  The function    does nothing if an insn declaration with the same key exists    already in the table.  The function returns insn declaration node    in the table with the same key as given insn declaration node.  */
end_comment

begin_function
specifier|static
name|decl_t
name|insert_insn_decl
parameter_list|(
name|insn_decl
parameter_list|)
name|decl_t
name|insn_decl
decl_stmt|;
block|{
name|void
modifier|*
modifier|*
name|entry_ptr
decl_stmt|;
name|entry_ptr
operator|=
name|htab_find_slot
argument_list|(
name|insn_decl_table
argument_list|,
name|insn_decl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|entry_ptr
operator|==
name|NULL
condition|)
operator|*
name|entry_ptr
operator|=
operator|(
name|void
operator|*
operator|)
name|insn_decl
expr_stmt|;
return|return
operator|(
name|decl_t
operator|)
operator|*
name|entry_ptr
return|;
block|}
end_function

begin_comment
comment|/* The following variable value is node representing insn reservation    declaration.  The node used for searching insn reservation    declaration with given name.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|decl
name|work_insn_decl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The function searches for insn reservation declaration in the table    with the same key as node representing name of the insn reservation    declaration.  The function returns node found in the table, NULL if    such node does not exist in the table.  */
end_comment

begin_function
specifier|static
name|decl_t
name|find_insn_decl
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|void
modifier|*
name|entry
decl_stmt|;
name|work_insn_decl
operator|.
name|mode
operator|=
name|dm_insn_reserv
expr_stmt|;
name|DECL_INSN_RESERV
argument_list|(
operator|&
name|work_insn_decl
argument_list|)
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|entry
operator|=
name|htab_find
argument_list|(
name|insn_decl_table
argument_list|,
operator|&
name|work_insn_decl
argument_list|)
expr_stmt|;
return|return
operator|(
name|decl_t
operator|)
name|entry
return|;
block|}
end_function

begin_comment
comment|/* The function creates empty insn declaration table and node    representing insn declaration and used for searching insn    declaration with given name.  The function must be called only once    before any work with the insn declaration table.  */
end_comment

begin_function
specifier|static
name|void
name|initiate_insn_decl_table
parameter_list|()
block|{
name|work_insn_decl
operator|.
name|mode
operator|=
name|dm_insn_reserv
expr_stmt|;
name|insn_decl_table
operator|=
name|htab_create
argument_list|(
literal|10
argument_list|,
name|insn_decl_hash
argument_list|,
name|insn_decl_eq_p
argument_list|,
operator|(
name|htab_del
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function deletes the insn declaration table.  Only call of    function `initiate_insn_decl_table' is possible immediately after    this function call.  */
end_comment

begin_function
specifier|static
name|void
name|finish_insn_decl_table
parameter_list|()
block|{
name|htab_delete
argument_list|(
name|insn_decl_table
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This page contains abstract data `table of declarations'.  Elements    of the table is nodes representing declarations (of units and    reservations).  Key of the table elements is names of given    declarations.  */
end_comment

begin_comment
comment|/* The function evaluates hash value of a declaration.  The function    is used by abstract data `hashtab'.  The function returns hash    value (0..UINT_MAX) of given declaration.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|decl_hash
parameter_list|(
name|decl
parameter_list|)
specifier|const
name|void
modifier|*
name|decl
decl_stmt|;
block|{
specifier|const
name|decl_t
name|d
init|=
operator|(
specifier|const
name|decl_t
operator|)
name|decl
decl_stmt|;
if|if
condition|(
operator|(
name|d
operator|->
name|mode
operator|!=
name|dm_unit
operator|||
name|DECL_UNIT
argument_list|(
name|d
argument_list|)
operator|->
name|name
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|d
operator|->
name|mode
operator|!=
name|dm_reserv
operator|||
name|DECL_RESERV
argument_list|(
name|d
argument_list|)
operator|->
name|name
operator|==
name|NULL
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|string_hash
argument_list|(
name|d
operator|->
name|mode
operator|==
name|dm_unit
condition|?
name|DECL_UNIT
argument_list|(
name|d
argument_list|)
operator|->
name|name
else|:
name|DECL_RESERV
argument_list|(
name|d
argument_list|)
operator|->
name|name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The function tests declarations on equality of their keys.  The    function is used by abstract data `hashtab'.  The function    returns 1 if the declarations have the same key, 0 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|decl_eq_p
parameter_list|(
name|decl_1
parameter_list|,
name|decl_2
parameter_list|)
specifier|const
name|void
modifier|*
name|decl_1
decl_stmt|;
specifier|const
name|void
modifier|*
name|decl_2
decl_stmt|;
block|{
specifier|const
name|decl_t
name|d1
init|=
operator|(
specifier|const
name|decl_t
operator|)
name|decl_1
decl_stmt|;
specifier|const
name|decl_t
name|d2
init|=
operator|(
specifier|const
name|decl_t
operator|)
name|decl_2
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|d1
operator|->
name|mode
operator|!=
name|dm_unit
operator|||
name|DECL_UNIT
argument_list|(
name|d1
argument_list|)
operator|->
name|name
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|d1
operator|->
name|mode
operator|!=
name|dm_reserv
operator|||
name|DECL_RESERV
argument_list|(
name|d1
argument_list|)
operator|->
name|name
operator|==
name|NULL
operator|)
operator|)
operator|||
operator|(
operator|(
name|d2
operator|->
name|mode
operator|!=
name|dm_unit
operator|||
name|DECL_UNIT
argument_list|(
name|d2
argument_list|)
operator|->
name|name
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|d2
operator|->
name|mode
operator|!=
name|dm_reserv
operator|||
name|DECL_RESERV
argument_list|(
name|d2
argument_list|)
operator|->
name|name
operator|==
name|NULL
operator|)
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|strcmp
argument_list|(
operator|(
name|d1
operator|->
name|mode
operator|==
name|dm_unit
condition|?
name|DECL_UNIT
argument_list|(
name|d1
argument_list|)
operator|->
name|name
else|:
name|DECL_RESERV
argument_list|(
name|d1
argument_list|)
operator|->
name|name
operator|)
argument_list|,
operator|(
name|d2
operator|->
name|mode
operator|==
name|dm_unit
condition|?
name|DECL_UNIT
argument_list|(
name|d2
argument_list|)
operator|->
name|name
else|:
name|DECL_RESERV
argument_list|(
name|d2
argument_list|)
operator|->
name|name
operator|)
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* The declaration table itself is represented by the following    variable.  */
end_comment

begin_decl_stmt
specifier|static
name|htab_t
name|decl_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The function inserts declaration into the table.  The function does    nothing if a declaration with the same key exists already in the    table.  The function returns declaration node in the table with the    same key as given declaration node.  */
end_comment

begin_function
specifier|static
name|decl_t
name|insert_decl
parameter_list|(
name|decl
parameter_list|)
name|decl_t
name|decl
decl_stmt|;
block|{
name|void
modifier|*
modifier|*
name|entry_ptr
decl_stmt|;
name|entry_ptr
operator|=
name|htab_find_slot
argument_list|(
name|decl_table
argument_list|,
name|decl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|entry_ptr
operator|==
name|NULL
condition|)
operator|*
name|entry_ptr
operator|=
operator|(
name|void
operator|*
operator|)
name|decl
expr_stmt|;
return|return
operator|(
name|decl_t
operator|)
operator|*
name|entry_ptr
return|;
block|}
end_function

begin_comment
comment|/* The following variable value is node representing declaration.  The    node used for searching declaration with given name.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|decl
name|work_decl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The function searches for declaration in the table with the same    key as node representing name of the declaration.  The function    returns node found in the table, NULL if such node does not exist    in the table.  */
end_comment

begin_function
specifier|static
name|decl_t
name|find_decl
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|void
modifier|*
name|entry
decl_stmt|;
name|work_decl
operator|.
name|mode
operator|=
name|dm_unit
expr_stmt|;
name|DECL_UNIT
argument_list|(
operator|&
name|work_decl
argument_list|)
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|entry
operator|=
name|htab_find
argument_list|(
name|decl_table
argument_list|,
operator|&
name|work_decl
argument_list|)
expr_stmt|;
return|return
operator|(
name|decl_t
operator|)
name|entry
return|;
block|}
end_function

begin_comment
comment|/* The function creates empty declaration table and node representing    declaration and used for searching declaration with given name.    The function must be called only once before any work with the    declaration table.  */
end_comment

begin_function
specifier|static
name|void
name|initiate_decl_table
parameter_list|()
block|{
name|work_decl
operator|.
name|mode
operator|=
name|dm_unit
expr_stmt|;
name|decl_table
operator|=
name|htab_create
argument_list|(
literal|10
argument_list|,
name|decl_hash
argument_list|,
name|decl_eq_p
argument_list|,
operator|(
name|htab_del
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function deletes the declaration table.  Only call of function    `initiate_declaration_table' is possible immediately after this    function call.  */
end_comment

begin_function
specifier|static
name|void
name|finish_decl_table
parameter_list|()
block|{
name|htab_delete
argument_list|(
name|decl_table
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This page contains checker of pipeline hazard description.  */
end_comment

begin_comment
comment|/* Checking NAMES in an exclusion clause vector and returning formed    unit_set_el_list.  */
end_comment

begin_function
specifier|static
name|unit_set_el_t
name|process_excls
parameter_list|(
name|names
parameter_list|,
name|num
parameter_list|,
name|excl_pos
parameter_list|)
name|char
modifier|*
modifier|*
name|names
decl_stmt|;
name|int
name|num
decl_stmt|;
name|pos_t
name|excl_pos
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|unit_set_el_t
name|el_list
decl_stmt|;
name|unit_set_el_t
name|last_el
decl_stmt|;
name|unit_set_el_t
name|new_el
decl_stmt|;
name|decl_t
name|decl_in_table
decl_stmt|;
name|int
name|i
decl_stmt|;
name|el_list
operator|=
name|NULL
expr_stmt|;
name|last_el
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|decl_in_table
operator|=
name|find_decl
argument_list|(
name|names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl_in_table
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"unit `%s' in exclusion is not declared"
argument_list|,
name|names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|decl_in_table
operator|->
name|mode
operator|!=
name|dm_unit
condition|)
name|error
argument_list|(
literal|"`%s' in exclusion is not unit"
argument_list|,
name|names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|new_el
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|unit_set_el
argument_list|)
argument_list|)
expr_stmt|;
name|new_el
operator|->
name|unit_decl
operator|=
name|DECL_UNIT
argument_list|(
name|decl_in_table
argument_list|)
expr_stmt|;
name|new_el
operator|->
name|next_unit_set_el
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|last_el
operator|==
name|NULL
condition|)
name|el_list
operator|=
name|last_el
operator|=
name|new_el
expr_stmt|;
else|else
block|{
name|last_el
operator|->
name|next_unit_set_el
operator|=
name|new_el
expr_stmt|;
name|last_el
operator|=
name|last_el
operator|->
name|next_unit_set_el
expr_stmt|;
block|}
block|}
block|}
return|return
name|el_list
return|;
block|}
end_function

begin_comment
comment|/* The function adds each element from SOURCE_LIST to the exclusion    list of the each element from DEST_LIST.  Checking situation "unit    excludes itself".  */
end_comment

begin_function
specifier|static
name|void
name|add_excls
parameter_list|(
name|dest_list
parameter_list|,
name|source_list
parameter_list|,
name|excl_pos
parameter_list|)
name|unit_set_el_t
name|dest_list
decl_stmt|;
name|unit_set_el_t
name|source_list
decl_stmt|;
name|pos_t
name|excl_pos
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|unit_set_el_t
name|dst
decl_stmt|;
name|unit_set_el_t
name|src
decl_stmt|;
name|unit_set_el_t
name|curr_el
decl_stmt|;
name|unit_set_el_t
name|prev_el
decl_stmt|;
name|unit_set_el_t
name|copy
decl_stmt|;
for|for
control|(
name|dst
operator|=
name|dest_list
init|;
name|dst
operator|!=
name|NULL
condition|;
name|dst
operator|=
name|dst
operator|->
name|next_unit_set_el
control|)
for|for
control|(
name|src
operator|=
name|source_list
init|;
name|src
operator|!=
name|NULL
condition|;
name|src
operator|=
name|src
operator|->
name|next_unit_set_el
control|)
block|{
if|if
condition|(
name|dst
operator|->
name|unit_decl
operator|==
name|src
operator|->
name|unit_decl
condition|)
block|{
name|error
argument_list|(
literal|"unit `%s' excludes itself"
argument_list|,
name|src
operator|->
name|unit_decl
operator|->
name|name
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|dst
operator|->
name|unit_decl
operator|->
name|automaton_name
operator|!=
name|NULL
operator|&&
name|src
operator|->
name|unit_decl
operator|->
name|automaton_name
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|dst
operator|->
name|unit_decl
operator|->
name|automaton_name
argument_list|,
name|src
operator|->
name|unit_decl
operator|->
name|automaton_name
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"units `%s' and `%s' in exclusion set belong to different automata"
argument_list|,
name|src
operator|->
name|unit_decl
operator|->
name|name
argument_list|,
name|dst
operator|->
name|unit_decl
operator|->
name|name
argument_list|)
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|curr_el
operator|=
name|dst
operator|->
name|unit_decl
operator|->
name|excl_list
operator|,
name|prev_el
operator|=
name|NULL
init|;
name|curr_el
operator|!=
name|NULL
condition|;
name|prev_el
operator|=
name|curr_el
operator|,
name|curr_el
operator|=
name|curr_el
operator|->
name|next_unit_set_el
control|)
if|if
condition|(
name|curr_el
operator|->
name|unit_decl
operator|==
name|src
operator|->
name|unit_decl
condition|)
break|break;
if|if
condition|(
name|curr_el
operator|==
name|NULL
condition|)
block|{
comment|/* Element not found - insert.  */
name|copy
operator|=
name|copy_node
argument_list|(
name|src
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|copy
operator|->
name|next_unit_set_el
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|prev_el
operator|==
name|NULL
condition|)
name|dst
operator|->
name|unit_decl
operator|->
name|excl_list
operator|=
name|copy
expr_stmt|;
else|else
name|prev_el
operator|->
name|next_unit_set_el
operator|=
name|copy
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Checking NAMES in a presence clause vector and returning formed    unit_set_el_list.  The function is called only after processing all    exclusion sets.  */
end_comment

begin_function
specifier|static
name|unit_set_el_t
name|process_presence_absence
parameter_list|(
name|names
parameter_list|,
name|num
parameter_list|,
name|req_pos
parameter_list|,
name|presence_p
parameter_list|)
name|char
modifier|*
modifier|*
name|names
decl_stmt|;
name|int
name|num
decl_stmt|;
name|pos_t
name|req_pos
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|presence_p
decl_stmt|;
block|{
name|unit_set_el_t
name|el_list
decl_stmt|;
name|unit_set_el_t
name|last_el
decl_stmt|;
name|unit_set_el_t
name|new_el
decl_stmt|;
name|decl_t
name|decl_in_table
decl_stmt|;
name|int
name|i
decl_stmt|;
name|el_list
operator|=
name|NULL
expr_stmt|;
name|last_el
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|decl_in_table
operator|=
name|find_decl
argument_list|(
name|names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl_in_table
operator|==
name|NULL
condition|)
name|error
argument_list|(
operator|(
name|presence_p
condition|?
literal|"unit `%s' in presence set is not declared"
else|:
literal|"unit `%s' in absence set is not declared"
operator|)
argument_list|,
name|names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|decl_in_table
operator|->
name|mode
operator|!=
name|dm_unit
condition|)
name|error
argument_list|(
operator|(
name|presence_p
condition|?
literal|"`%s' in presence set is not unit"
else|:
literal|"`%s' in absence set is not unit"
operator|)
argument_list|,
name|names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|new_el
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|unit_set_el
argument_list|)
argument_list|)
expr_stmt|;
name|new_el
operator|->
name|unit_decl
operator|=
name|DECL_UNIT
argument_list|(
name|decl_in_table
argument_list|)
expr_stmt|;
name|new_el
operator|->
name|next_unit_set_el
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|last_el
operator|==
name|NULL
condition|)
name|el_list
operator|=
name|last_el
operator|=
name|new_el
expr_stmt|;
else|else
block|{
name|last_el
operator|->
name|next_unit_set_el
operator|=
name|new_el
expr_stmt|;
name|last_el
operator|=
name|last_el
operator|->
name|next_unit_set_el
expr_stmt|;
block|}
block|}
block|}
return|return
name|el_list
return|;
block|}
end_function

begin_comment
comment|/* The function adds each element from SOURCE_LIST to presence (if    PRESENCE_P) or absence list of the each element from DEST_LIST.    Checking situations "unit requires own presence", "unit requires    own absence", and "unit excludes and requires presence of ...".    Remember that we process absence sets only after all presence    sets.  */
end_comment

begin_function
specifier|static
name|void
name|add_presence_absence
parameter_list|(
name|dest_list
parameter_list|,
name|source_list
parameter_list|,
name|req_pos
parameter_list|,
name|presence_p
parameter_list|)
name|unit_set_el_t
name|dest_list
decl_stmt|;
name|unit_set_el_t
name|source_list
decl_stmt|;
name|pos_t
name|req_pos
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|presence_p
decl_stmt|;
block|{
name|unit_set_el_t
name|dst
decl_stmt|;
name|unit_set_el_t
name|src
decl_stmt|;
name|unit_set_el_t
name|curr_el
decl_stmt|;
name|unit_set_el_t
name|prev_el
decl_stmt|;
name|unit_set_el_t
name|copy
decl_stmt|;
for|for
control|(
name|dst
operator|=
name|dest_list
init|;
name|dst
operator|!=
name|NULL
condition|;
name|dst
operator|=
name|dst
operator|->
name|next_unit_set_el
control|)
for|for
control|(
name|src
operator|=
name|source_list
init|;
name|src
operator|!=
name|NULL
condition|;
name|src
operator|=
name|src
operator|->
name|next_unit_set_el
control|)
block|{
if|if
condition|(
name|dst
operator|->
name|unit_decl
operator|==
name|src
operator|->
name|unit_decl
condition|)
block|{
name|error
argument_list|(
operator|(
name|presence_p
condition|?
literal|"unit `%s' requires own presence"
else|:
literal|"unit `%s' requires own absence"
operator|)
argument_list|,
name|src
operator|->
name|unit_decl
operator|->
name|name
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|dst
operator|->
name|unit_decl
operator|->
name|automaton_name
operator|!=
name|NULL
operator|&&
name|src
operator|->
name|unit_decl
operator|->
name|automaton_name
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|dst
operator|->
name|unit_decl
operator|->
name|automaton_name
argument_list|,
name|src
operator|->
name|unit_decl
operator|->
name|automaton_name
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
operator|(
name|presence_p
condition|?
literal|"units `%s' and `%s' in presence set belong to different automata"
else|:
literal|"units `%s' and `%s' in absence set belong to different automata"
operator|)
argument_list|,
name|src
operator|->
name|unit_decl
operator|->
name|name
argument_list|,
name|dst
operator|->
name|unit_decl
operator|->
name|name
argument_list|)
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|curr_el
operator|=
operator|(
name|presence_p
condition|?
name|dst
operator|->
name|unit_decl
operator|->
name|presence_list
else|:
name|dst
operator|->
name|unit_decl
operator|->
name|absence_list
operator|)
operator|,
name|prev_el
operator|=
name|NULL
init|;
name|curr_el
operator|!=
name|NULL
condition|;
name|prev_el
operator|=
name|curr_el
operator|,
name|curr_el
operator|=
name|curr_el
operator|->
name|next_unit_set_el
control|)
if|if
condition|(
name|curr_el
operator|->
name|unit_decl
operator|==
name|src
operator|->
name|unit_decl
condition|)
break|break;
if|if
condition|(
name|curr_el
operator|==
name|NULL
condition|)
block|{
comment|/* Element not found - insert if there is no error.  */
name|int
name|no_error_flag
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|presence_p
condition|)
for|for
control|(
name|curr_el
operator|=
name|dst
operator|->
name|unit_decl
operator|->
name|excl_list
init|;
name|curr_el
operator|!=
name|NULL
condition|;
name|curr_el
operator|=
name|curr_el
operator|->
name|next_unit_set_el
control|)
block|{
if|if
condition|(
name|src
operator|->
name|unit_decl
operator|==
name|curr_el
operator|->
name|unit_decl
condition|)
block|{
if|if
condition|(
operator|!
name|w_flag
condition|)
block|{
name|error
argument_list|(
literal|"unit `%s' excludes and requires presence of `%s'"
argument_list|,
name|dst
operator|->
name|unit_decl
operator|->
name|name
argument_list|,
name|src
operator|->
name|unit_decl
operator|->
name|name
argument_list|)
expr_stmt|;
name|no_error_flag
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|warning
argument_list|(
literal|"unit `%s' excludes and requires presence of `%s'"
argument_list|,
name|dst
operator|->
name|unit_decl
operator|->
name|name
argument_list|,
name|src
operator|->
name|unit_decl
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
else|else
for|for
control|(
name|curr_el
operator|=
name|dst
operator|->
name|unit_decl
operator|->
name|presence_list
init|;
name|curr_el
operator|!=
name|NULL
condition|;
name|curr_el
operator|=
name|curr_el
operator|->
name|next_unit_set_el
control|)
block|{
if|if
condition|(
name|src
operator|->
name|unit_decl
operator|==
name|curr_el
operator|->
name|unit_decl
condition|)
block|{
if|if
condition|(
operator|!
name|w_flag
condition|)
block|{
name|error
argument_list|(
literal|"unit `%s' requires absence and presence of `%s'"
argument_list|,
name|dst
operator|->
name|unit_decl
operator|->
name|name
argument_list|,
name|src
operator|->
name|unit_decl
operator|->
name|name
argument_list|)
expr_stmt|;
name|no_error_flag
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|warning
argument_list|(
literal|"unit `%s' requires absence and presence of `%s'"
argument_list|,
name|dst
operator|->
name|unit_decl
operator|->
name|name
argument_list|,
name|src
operator|->
name|unit_decl
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|no_error_flag
condition|)
block|{
name|copy
operator|=
name|copy_node
argument_list|(
name|src
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|copy
operator|->
name|next_unit_set_el
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|prev_el
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|presence_p
condition|)
name|dst
operator|->
name|unit_decl
operator|->
name|presence_list
operator|=
name|copy
expr_stmt|;
else|else
name|dst
operator|->
name|unit_decl
operator|->
name|absence_list
operator|=
name|copy
expr_stmt|;
block|}
else|else
name|prev_el
operator|->
name|next_unit_set_el
operator|=
name|copy
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* The function searches for bypass with given IN_INSN_RESERV in given    BYPASS_LIST.  */
end_comment

begin_function
specifier|static
name|struct
name|bypass_decl
modifier|*
name|find_bypass
parameter_list|(
name|bypass_list
parameter_list|,
name|in_insn_reserv
parameter_list|)
name|struct
name|bypass_decl
modifier|*
name|bypass_list
decl_stmt|;
name|struct
name|insn_reserv_decl
modifier|*
name|in_insn_reserv
decl_stmt|;
block|{
name|struct
name|bypass_decl
modifier|*
name|bypass
decl_stmt|;
for|for
control|(
name|bypass
operator|=
name|bypass_list
init|;
name|bypass
operator|!=
name|NULL
condition|;
name|bypass
operator|=
name|bypass
operator|->
name|next
control|)
if|if
condition|(
name|bypass
operator|->
name|in_insn_reserv
operator|==
name|in_insn_reserv
condition|)
break|break;
return|return
name|bypass
return|;
block|}
end_function

begin_comment
comment|/* The function processes pipeline description declarations, checks    their correctness, and forms exclusion/presence/absence sets.  */
end_comment

begin_function
specifier|static
name|void
name|process_decls
parameter_list|()
block|{
name|decl_t
name|decl
decl_stmt|;
name|decl_t
name|automaton_decl
decl_stmt|;
name|decl_t
name|decl_in_table
decl_stmt|;
name|decl_t
name|out_insn_reserv
decl_stmt|;
name|decl_t
name|in_insn_reserv
decl_stmt|;
name|struct
name|bypass_decl
modifier|*
name|bypass
decl_stmt|;
name|int
name|automaton_presence
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Checking repeated automata declarations.  */
name|automaton_presence
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_automaton
condition|)
block|{
name|automaton_presence
operator|=
literal|1
expr_stmt|;
name|decl_in_table
operator|=
name|insert_automaton_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl_in_table
operator|!=
name|decl
condition|)
block|{
if|if
condition|(
operator|!
name|w_flag
condition|)
name|error
argument_list|(
literal|"repeated declaration of automaton `%s'"
argument_list|,
name|DECL_AUTOMATON
argument_list|(
name|decl
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"repeated declaration of automaton `%s'"
argument_list|,
name|DECL_AUTOMATON
argument_list|(
name|decl
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Checking undeclared automata, repeated declarations (except for      automata) and correctness of their attributes (insn latency times      etc.).  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_insn_reserv
condition|)
block|{
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|condexp
operator|=
name|check_attr_test
argument_list|(
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|condexp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|default_latency
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"define_insn_reservation `%s' has negative latency time"
argument_list|,
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|insn_num
operator|=
name|description
operator|->
name|insns_num
expr_stmt|;
name|description
operator|->
name|insns_num
operator|++
expr_stmt|;
name|decl_in_table
operator|=
name|insert_insn_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl_in_table
operator|!=
name|decl
condition|)
name|error
argument_list|(
literal|"`%s' is already used as insn reservation name"
argument_list|,
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_bypass
condition|)
block|{
if|if
condition|(
name|DECL_BYPASS
argument_list|(
name|decl
argument_list|)
operator|->
name|latency
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"define_bypass `%s - %s' has negative latency time"
argument_list|,
name|DECL_BYPASS
argument_list|(
name|decl
argument_list|)
operator|->
name|out_insn_name
argument_list|,
name|DECL_BYPASS
argument_list|(
name|decl
argument_list|)
operator|->
name|in_insn_name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_unit
operator|||
name|decl
operator|->
name|mode
operator|==
name|dm_reserv
condition|)
block|{
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_unit
condition|)
block|{
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|automaton_decl
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|automaton_name
operator|!=
name|NULL
condition|)
block|{
name|automaton_decl
operator|=
name|find_automaton_decl
argument_list|(
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|automaton_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|automaton_decl
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"automaton `%s' is not declared"
argument_list|,
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|automaton_name
argument_list|)
expr_stmt|;
else|else
block|{
name|DECL_AUTOMATON
argument_list|(
name|automaton_decl
argument_list|)
operator|->
name|automaton_is_used
operator|=
literal|1
expr_stmt|;
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|automaton_decl
operator|=
name|DECL_AUTOMATON
argument_list|(
name|automaton_decl
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|automaton_presence
condition|)
name|error
argument_list|(
literal|"define_unit `%s' without automaton when one defined"
argument_list|,
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|unit_num
operator|=
name|description
operator|->
name|units_num
expr_stmt|;
name|description
operator|->
name|units_num
operator|++
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|name
argument_list|,
name|NOTHING_NAME
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"`%s' is declared as cpu unit"
argument_list|,
name|NOTHING_NAME
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|decl_in_table
operator|=
name|find_decl
argument_list|(
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|DECL_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|name
argument_list|,
name|NOTHING_NAME
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"`%s' is declared as cpu reservation"
argument_list|,
name|NOTHING_NAME
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|decl_in_table
operator|=
name|find_decl
argument_list|(
name|DECL_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|decl_in_table
operator|==
name|NULL
condition|)
name|decl_in_table
operator|=
name|insert_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_unit
condition|)
name|error
argument_list|(
literal|"repeated declaration of unit `%s'"
argument_list|,
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"repeated declaration of reservation `%s'"
argument_list|,
name|DECL_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Check bypasses and form list of bypasses for each (output)      insn.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_bypass
condition|)
block|{
name|out_insn_reserv
operator|=
name|find_insn_decl
argument_list|(
name|DECL_BYPASS
argument_list|(
name|decl
argument_list|)
operator|->
name|out_insn_name
argument_list|)
expr_stmt|;
name|in_insn_reserv
operator|=
name|find_insn_decl
argument_list|(
name|DECL_BYPASS
argument_list|(
name|decl
argument_list|)
operator|->
name|in_insn_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|out_insn_reserv
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"there is no insn reservation `%s'"
argument_list|,
name|DECL_BYPASS
argument_list|(
name|decl
argument_list|)
operator|->
name|out_insn_name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|in_insn_reserv
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"there is no insn reservation `%s'"
argument_list|,
name|DECL_BYPASS
argument_list|(
name|decl
argument_list|)
operator|->
name|in_insn_name
argument_list|)
expr_stmt|;
else|else
block|{
name|DECL_BYPASS
argument_list|(
name|decl
argument_list|)
operator|->
name|out_insn_reserv
operator|=
name|DECL_INSN_RESERV
argument_list|(
name|out_insn_reserv
argument_list|)
expr_stmt|;
name|DECL_BYPASS
argument_list|(
name|decl
argument_list|)
operator|->
name|in_insn_reserv
operator|=
name|DECL_INSN_RESERV
argument_list|(
name|in_insn_reserv
argument_list|)
expr_stmt|;
name|bypass
operator|=
name|find_bypass
argument_list|(
name|DECL_INSN_RESERV
argument_list|(
name|out_insn_reserv
argument_list|)
operator|->
name|bypass_list
argument_list|,
name|DECL_BYPASS
argument_list|(
name|decl
argument_list|)
operator|->
name|in_insn_reserv
argument_list|)
expr_stmt|;
if|if
condition|(
name|bypass
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|DECL_BYPASS
argument_list|(
name|decl
argument_list|)
operator|->
name|latency
operator|==
name|bypass
operator|->
name|latency
condition|)
block|{
if|if
condition|(
operator|!
name|w_flag
condition|)
name|error
argument_list|(
literal|"the same bypass `%s - %s' is already defined"
argument_list|,
name|DECL_BYPASS
argument_list|(
name|decl
argument_list|)
operator|->
name|out_insn_name
argument_list|,
name|DECL_BYPASS
argument_list|(
name|decl
argument_list|)
operator|->
name|in_insn_name
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"the same bypass `%s - %s' is already defined"
argument_list|,
name|DECL_BYPASS
argument_list|(
name|decl
argument_list|)
operator|->
name|out_insn_name
argument_list|,
name|DECL_BYPASS
argument_list|(
name|decl
argument_list|)
operator|->
name|in_insn_name
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"bypass `%s - %s' is already defined"
argument_list|,
name|DECL_BYPASS
argument_list|(
name|decl
argument_list|)
operator|->
name|out_insn_name
argument_list|,
name|DECL_BYPASS
argument_list|(
name|decl
argument_list|)
operator|->
name|in_insn_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DECL_BYPASS
argument_list|(
name|decl
argument_list|)
operator|->
name|next
operator|=
name|DECL_INSN_RESERV
argument_list|(
name|out_insn_reserv
argument_list|)
operator|->
name|bypass_list
expr_stmt|;
name|DECL_INSN_RESERV
argument_list|(
name|out_insn_reserv
argument_list|)
operator|->
name|bypass_list
operator|=
name|DECL_BYPASS
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Check exclusion set declarations and form exclussion sets.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_excl
condition|)
block|{
name|unit_set_el_t
name|unit_set_el_list
decl_stmt|;
name|unit_set_el_t
name|unit_set_el_list_2
decl_stmt|;
name|unit_set_el_list
operator|=
name|process_excls
argument_list|(
name|DECL_EXCL
argument_list|(
name|decl
argument_list|)
operator|->
name|names
argument_list|,
name|DECL_EXCL
argument_list|(
name|decl
argument_list|)
operator|->
name|first_list_length
argument_list|,
name|decl
operator|->
name|pos
argument_list|)
expr_stmt|;
name|unit_set_el_list_2
operator|=
name|process_excls
argument_list|(
operator|&
name|DECL_EXCL
argument_list|(
name|decl
argument_list|)
operator|->
name|names
index|[
name|DECL_EXCL
argument_list|(
name|decl
argument_list|)
operator|->
name|first_list_length
index|]
argument_list|,
name|DECL_EXCL
argument_list|(
name|decl
argument_list|)
operator|->
name|names_num
operator|-
name|DECL_EXCL
argument_list|(
name|decl
argument_list|)
operator|->
name|first_list_length
argument_list|,
name|decl
operator|->
name|pos
argument_list|)
expr_stmt|;
name|add_excls
argument_list|(
name|unit_set_el_list
argument_list|,
name|unit_set_el_list_2
argument_list|,
name|decl
operator|->
name|pos
argument_list|)
expr_stmt|;
name|add_excls
argument_list|(
name|unit_set_el_list_2
argument_list|,
name|unit_set_el_list
argument_list|,
name|decl
operator|->
name|pos
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Check presence set declarations and form presence sets.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_presence
condition|)
block|{
name|unit_set_el_t
name|unit_set_el_list
decl_stmt|;
name|unit_set_el_t
name|unit_set_el_list_2
decl_stmt|;
name|unit_set_el_list
operator|=
name|process_presence_absence
argument_list|(
name|DECL_PRESENCE
argument_list|(
name|decl
argument_list|)
operator|->
name|names
argument_list|,
name|DECL_PRESENCE
argument_list|(
name|decl
argument_list|)
operator|->
name|first_list_length
argument_list|,
name|decl
operator|->
name|pos
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|unit_set_el_list_2
operator|=
name|process_presence_absence
argument_list|(
operator|&
name|DECL_PRESENCE
argument_list|(
name|decl
argument_list|)
operator|->
name|names
index|[
name|DECL_PRESENCE
argument_list|(
name|decl
argument_list|)
operator|->
name|first_list_length
index|]
argument_list|,
name|DECL_PRESENCE
argument_list|(
name|decl
argument_list|)
operator|->
name|names_num
operator|-
name|DECL_PRESENCE
argument_list|(
name|decl
argument_list|)
operator|->
name|first_list_length
argument_list|,
name|decl
operator|->
name|pos
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_presence_absence
argument_list|(
name|unit_set_el_list
argument_list|,
name|unit_set_el_list_2
argument_list|,
name|decl
operator|->
name|pos
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Check absence set declarations and form absence sets.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_absence
condition|)
block|{
name|unit_set_el_t
name|unit_set_el_list
decl_stmt|;
name|unit_set_el_t
name|unit_set_el_list_2
decl_stmt|;
name|unit_set_el_list
operator|=
name|process_presence_absence
argument_list|(
name|DECL_ABSENCE
argument_list|(
name|decl
argument_list|)
operator|->
name|names
argument_list|,
name|DECL_ABSENCE
argument_list|(
name|decl
argument_list|)
operator|->
name|first_list_length
argument_list|,
name|decl
operator|->
name|pos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|unit_set_el_list_2
operator|=
name|process_presence_absence
argument_list|(
operator|&
name|DECL_ABSENCE
argument_list|(
name|decl
argument_list|)
operator|->
name|names
index|[
name|DECL_ABSENCE
argument_list|(
name|decl
argument_list|)
operator|->
name|first_list_length
index|]
argument_list|,
name|DECL_ABSENCE
argument_list|(
name|decl
argument_list|)
operator|->
name|names_num
operator|-
name|DECL_ABSENCE
argument_list|(
name|decl
argument_list|)
operator|->
name|first_list_length
argument_list|,
name|decl
operator|->
name|pos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_presence_absence
argument_list|(
name|unit_set_el_list
argument_list|,
name|unit_set_el_list_2
argument_list|,
name|decl
operator|->
name|pos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* The following function checks that declared automaton is used.  If    the automaton is not used, the function fixes error/warning.  The    following function must be called only after `process_decls'.  */
end_comment

begin_function
specifier|static
name|void
name|check_automaton_usage
parameter_list|()
block|{
name|decl_t
name|decl
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_automaton
operator|&&
operator|!
name|DECL_AUTOMATON
argument_list|(
name|decl
argument_list|)
operator|->
name|automaton_is_used
condition|)
block|{
if|if
condition|(
operator|!
name|w_flag
condition|)
name|error
argument_list|(
literal|"automaton `%s' is not used"
argument_list|,
name|DECL_AUTOMATON
argument_list|(
name|decl
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"automaton `%s' is not used"
argument_list|,
name|DECL_AUTOMATON
argument_list|(
name|decl
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* The following recursive function processes all regexp in order to    fix usage of units or reservations and to fix errors of undeclared    name.  The function may change unit_regexp onto reserv_regexp.    Remember that reserv_regexp does not exist before the function    call.  */
end_comment

begin_function
specifier|static
name|regexp_t
name|process_regexp
parameter_list|(
name|regexp
parameter_list|)
name|regexp_t
name|regexp
decl_stmt|;
block|{
name|decl_t
name|decl_in_table
decl_stmt|;
name|regexp_t
name|new_regexp
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|regexp
operator|->
name|mode
operator|==
name|rm_unit
condition|)
block|{
name|decl_in_table
operator|=
name|find_decl
argument_list|(
name|REGEXP_UNIT
argument_list|(
name|regexp
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl_in_table
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"undeclared unit or reservation `%s'"
argument_list|,
name|REGEXP_UNIT
argument_list|(
name|regexp
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|decl_in_table
operator|->
name|mode
operator|==
name|dm_unit
condition|)
block|{
name|DECL_UNIT
argument_list|(
name|decl_in_table
argument_list|)
operator|->
name|unit_is_used
operator|=
literal|1
expr_stmt|;
name|REGEXP_UNIT
argument_list|(
name|regexp
argument_list|)
operator|->
name|unit_decl
operator|=
name|DECL_UNIT
argument_list|(
name|decl_in_table
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|decl_in_table
operator|->
name|mode
operator|==
name|dm_reserv
condition|)
block|{
name|DECL_RESERV
argument_list|(
name|decl_in_table
argument_list|)
operator|->
name|reserv_is_used
operator|=
literal|1
expr_stmt|;
name|new_regexp
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|regexp
argument_list|)
argument_list|)
expr_stmt|;
name|new_regexp
operator|->
name|mode
operator|=
name|rm_reserv
expr_stmt|;
name|new_regexp
operator|->
name|pos
operator|=
name|regexp
operator|->
name|pos
expr_stmt|;
name|REGEXP_RESERV
argument_list|(
name|new_regexp
argument_list|)
operator|->
name|name
operator|=
name|REGEXP_UNIT
argument_list|(
name|regexp
argument_list|)
operator|->
name|name
expr_stmt|;
name|REGEXP_RESERV
argument_list|(
name|new_regexp
argument_list|)
operator|->
name|reserv_decl
operator|=
name|DECL_RESERV
argument_list|(
name|decl_in_table
argument_list|)
expr_stmt|;
name|regexp
operator|=
name|new_regexp
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regexp
operator|->
name|mode
operator|==
name|rm_sequence
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|;
name|i
operator|++
control|)
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
operator|=
name|process_regexp
argument_list|(
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|regexp
operator|->
name|mode
operator|==
name|rm_allof
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|;
name|i
operator|++
control|)
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
operator|=
name|process_regexp
argument_list|(
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|regexp
operator|->
name|mode
operator|==
name|rm_oneof
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|;
name|i
operator|++
control|)
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
operator|=
name|process_regexp
argument_list|(
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|regexp
operator|->
name|mode
operator|==
name|rm_repeat
condition|)
name|REGEXP_REPEAT
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexp
operator|=
name|process_regexp
argument_list|(
name|REGEXP_REPEAT
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|regexp
operator|->
name|mode
operator|!=
name|rm_nothing
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|regexp
return|;
block|}
end_function

begin_comment
comment|/* The following function processes regexp of define_reservation and    define_insn_reservation with the aid of function    `process_regexp'.  */
end_comment

begin_function
specifier|static
name|void
name|process_regexp_decls
parameter_list|()
block|{
name|decl_t
name|decl
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_reserv
condition|)
name|DECL_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|regexp
operator|=
name|process_regexp
argument_list|(
name|DECL_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|regexp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_insn_reserv
condition|)
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|regexp
operator|=
name|process_regexp
argument_list|(
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|regexp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The following function checks that declared unit is used.  If the    unit is not used, the function fixes errors/warnings.  The    following function must be called only after `process_decls',    `process_regexp_decls'.  */
end_comment

begin_function
specifier|static
name|void
name|check_usage
parameter_list|()
block|{
name|decl_t
name|decl
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_unit
operator|&&
operator|!
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|unit_is_used
condition|)
block|{
if|if
condition|(
operator|!
name|w_flag
condition|)
name|error
argument_list|(
literal|"unit `%s' is not used"
argument_list|,
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"unit `%s' is not used"
argument_list|,
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_reserv
operator|&&
operator|!
name|DECL_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|reserv_is_used
condition|)
block|{
if|if
condition|(
operator|!
name|w_flag
condition|)
name|error
argument_list|(
literal|"reservation `%s' is not used"
argument_list|,
name|DECL_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"reservation `%s' is not used"
argument_list|,
name|DECL_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* The following variable value is number of reservation being    processed on loop recognition.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|curr_loop_pass_num
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following recursive function returns nonzero value if REGEXP    contains given decl or reservations in given regexp refers for    given decl.  */
end_comment

begin_function
specifier|static
name|int
name|loop_in_regexp
parameter_list|(
name|regexp
parameter_list|,
name|start_decl
parameter_list|)
name|regexp_t
name|regexp
decl_stmt|;
name|decl_t
name|start_decl
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|regexp
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|regexp
operator|->
name|mode
operator|==
name|rm_unit
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|regexp
operator|->
name|mode
operator|==
name|rm_reserv
condition|)
block|{
if|if
condition|(
name|start_decl
operator|->
name|mode
operator|==
name|dm_reserv
operator|&&
name|REGEXP_RESERV
argument_list|(
name|regexp
argument_list|)
operator|->
name|reserv_decl
operator|==
name|DECL_RESERV
argument_list|(
name|start_decl
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|REGEXP_RESERV
argument_list|(
name|regexp
argument_list|)
operator|->
name|reserv_decl
operator|->
name|loop_pass_num
operator|==
name|curr_loop_pass_num
condition|)
comment|/* declaration has been processed.  */
return|return
literal|0
return|;
else|else
block|{
name|REGEXP_RESERV
argument_list|(
name|regexp
argument_list|)
operator|->
name|reserv_decl
operator|->
name|loop_pass_num
operator|=
name|curr_loop_pass_num
expr_stmt|;
return|return
name|loop_in_regexp
argument_list|(
name|REGEXP_RESERV
argument_list|(
name|regexp
argument_list|)
operator|->
name|reserv_decl
operator|->
name|regexp
argument_list|,
name|start_decl
argument_list|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|regexp
operator|->
name|mode
operator|==
name|rm_sequence
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|loop_in_regexp
argument_list|(
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
argument_list|,
name|start_decl
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|regexp
operator|->
name|mode
operator|==
name|rm_allof
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|loop_in_regexp
argument_list|(
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
argument_list|,
name|start_decl
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|regexp
operator|->
name|mode
operator|==
name|rm_oneof
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|loop_in_regexp
argument_list|(
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
argument_list|,
name|start_decl
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|regexp
operator|->
name|mode
operator|==
name|rm_repeat
condition|)
return|return
name|loop_in_regexp
argument_list|(
name|REGEXP_REPEAT
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexp
argument_list|,
name|start_decl
argument_list|)
return|;
else|else
block|{
if|if
condition|(
name|regexp
operator|->
name|mode
operator|!=
name|rm_nothing
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* The following function fixes errors "cycle in definition ...".  The    function uses function `loop_in_regexp' for that.  */
end_comment

begin_function
specifier|static
name|void
name|check_loops_in_regexps
parameter_list|()
block|{
name|decl_t
name|decl
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_reserv
condition|)
name|DECL_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|loop_pass_num
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
name|curr_loop_pass_num
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_reserv
condition|)
block|{
name|DECL_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|loop_pass_num
operator|=
name|curr_loop_pass_num
expr_stmt|;
if|if
condition|(
name|loop_in_regexp
argument_list|(
name|DECL_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|regexp
argument_list|,
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|regexp
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|error
argument_list|(
literal|"cycle in definition of reservation `%s'"
argument_list|,
name|DECL_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* The function recursively processes IR of reservation and defines    max and min cycle for reservation of unit and for result in the    reservation.  */
end_comment

begin_function
specifier|static
name|int
name|process_regexp_cycles
parameter_list|(
name|regexp
parameter_list|,
name|start_cycle
parameter_list|)
name|regexp_t
name|regexp
decl_stmt|;
name|int
name|start_cycle
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|regexp
operator|->
name|mode
operator|==
name|rm_unit
condition|)
block|{
if|if
condition|(
name|REGEXP_UNIT
argument_list|(
name|regexp
argument_list|)
operator|->
name|unit_decl
operator|->
name|max_occ_cycle_num
operator|<
name|start_cycle
condition|)
name|REGEXP_UNIT
argument_list|(
name|regexp
argument_list|)
operator|->
name|unit_decl
operator|->
name|max_occ_cycle_num
operator|=
name|start_cycle
expr_stmt|;
return|return
name|start_cycle
return|;
block|}
elseif|else
if|if
condition|(
name|regexp
operator|->
name|mode
operator|==
name|rm_reserv
condition|)
return|return
name|process_regexp_cycles
argument_list|(
name|REGEXP_RESERV
argument_list|(
name|regexp
argument_list|)
operator|->
name|reserv_decl
operator|->
name|regexp
argument_list|,
name|start_cycle
argument_list|)
return|;
elseif|else
if|if
condition|(
name|regexp
operator|->
name|mode
operator|==
name|rm_repeat
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGEXP_REPEAT
argument_list|(
name|regexp
argument_list|)
operator|->
name|repeat_num
condition|;
name|i
operator|++
control|)
name|start_cycle
operator|=
name|process_regexp_cycles
argument_list|(
name|REGEXP_REPEAT
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexp
argument_list|,
name|start_cycle
argument_list|)
operator|+
literal|1
expr_stmt|;
return|return
name|start_cycle
return|;
block|}
elseif|else
if|if
condition|(
name|regexp
operator|->
name|mode
operator|==
name|rm_sequence
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|;
name|i
operator|++
control|)
name|start_cycle
operator|=
name|process_regexp_cycles
argument_list|(
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
argument_list|,
name|start_cycle
argument_list|)
operator|+
literal|1
expr_stmt|;
return|return
name|start_cycle
return|;
block|}
elseif|else
if|if
condition|(
name|regexp
operator|->
name|mode
operator|==
name|rm_allof
condition|)
block|{
name|int
name|finish_cycle
init|=
literal|0
decl_stmt|;
name|int
name|cycle
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|;
name|i
operator|++
control|)
block|{
name|cycle
operator|=
name|process_regexp_cycles
argument_list|(
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
argument_list|,
name|start_cycle
argument_list|)
expr_stmt|;
if|if
condition|(
name|finish_cycle
operator|<
name|cycle
condition|)
name|finish_cycle
operator|=
name|cycle
expr_stmt|;
block|}
return|return
name|finish_cycle
return|;
block|}
elseif|else
if|if
condition|(
name|regexp
operator|->
name|mode
operator|==
name|rm_oneof
condition|)
block|{
name|int
name|finish_cycle
init|=
literal|0
decl_stmt|;
name|int
name|cycle
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|;
name|i
operator|++
control|)
block|{
name|cycle
operator|=
name|process_regexp_cycles
argument_list|(
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
argument_list|,
name|start_cycle
argument_list|)
expr_stmt|;
if|if
condition|(
name|finish_cycle
operator|<
name|cycle
condition|)
name|finish_cycle
operator|=
name|cycle
expr_stmt|;
block|}
return|return
name|finish_cycle
return|;
block|}
else|else
block|{
if|if
condition|(
name|regexp
operator|->
name|mode
operator|!=
name|rm_nothing
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|start_cycle
return|;
block|}
block|}
end_function

begin_comment
comment|/* The following function is called only for correct program.  The    function defines max reservation of insns in cycles.  */
end_comment

begin_function
specifier|static
name|void
name|evaluate_max_reserv_cycles
parameter_list|()
block|{
name|int
name|max_insn_cycles_num
decl_stmt|;
name|decl_t
name|decl
decl_stmt|;
name|int
name|i
decl_stmt|;
name|description
operator|->
name|max_insn_reserv_cycles
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_insn_reserv
condition|)
block|{
name|max_insn_cycles_num
operator|=
name|process_regexp_cycles
argument_list|(
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|regexp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|description
operator|->
name|max_insn_reserv_cycles
operator|<
name|max_insn_cycles_num
condition|)
name|description
operator|->
name|max_insn_reserv_cycles
operator|=
name|max_insn_cycles_num
expr_stmt|;
block|}
block|}
name|description
operator|->
name|max_insn_reserv_cycles
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The following function calls functions for checking all    description.  */
end_comment

begin_function
specifier|static
name|void
name|check_all_description
parameter_list|()
block|{
name|process_decls
argument_list|()
expr_stmt|;
name|check_automaton_usage
argument_list|()
expr_stmt|;
name|process_regexp_decls
argument_list|()
expr_stmt|;
name|check_usage
argument_list|()
expr_stmt|;
name|check_loops_in_regexps
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|have_error
condition|)
name|evaluate_max_reserv_cycles
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The page contains abstract data `ticker'.  This data is used to    report time of different phases of building automata.  It is    possibly to write a description for which automata will be built    during several minutes even on fast machine.  */
end_comment

begin_comment
comment|/* The following function creates ticker and makes it active.  */
end_comment

begin_function
specifier|static
name|ticker_t
name|create_ticker
parameter_list|()
block|{
name|ticker_t
name|ticker
decl_stmt|;
name|ticker
operator|.
name|modified_creation_time
operator|=
name|get_run_time
argument_list|()
expr_stmt|;
name|ticker
operator|.
name|incremented_off_time
operator|=
literal|0
expr_stmt|;
return|return
name|ticker
return|;
block|}
end_function

begin_comment
comment|/* The following function switches off given ticker.  */
end_comment

begin_function
specifier|static
name|void
name|ticker_off
parameter_list|(
name|ticker
parameter_list|)
name|ticker_t
modifier|*
name|ticker
decl_stmt|;
block|{
if|if
condition|(
name|ticker
operator|->
name|incremented_off_time
operator|==
literal|0
condition|)
name|ticker
operator|->
name|incremented_off_time
operator|=
name|get_run_time
argument_list|()
operator|+
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The following function switches on given ticker.  */
end_comment

begin_function
specifier|static
name|void
name|ticker_on
parameter_list|(
name|ticker
parameter_list|)
name|ticker_t
modifier|*
name|ticker
decl_stmt|;
block|{
if|if
condition|(
name|ticker
operator|->
name|incremented_off_time
operator|!=
literal|0
condition|)
block|{
name|ticker
operator|->
name|modified_creation_time
operator|+=
name|get_run_time
argument_list|()
operator|-
name|ticker
operator|->
name|incremented_off_time
operator|+
literal|1
expr_stmt|;
name|ticker
operator|->
name|incremented_off_time
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The following function returns current time in milliseconds since    the moment when given ticker was created.  */
end_comment

begin_function
specifier|static
name|int
name|active_time
parameter_list|(
name|ticker
parameter_list|)
name|ticker_t
name|ticker
decl_stmt|;
block|{
if|if
condition|(
name|ticker
operator|.
name|incremented_off_time
operator|!=
literal|0
condition|)
return|return
name|ticker
operator|.
name|incremented_off_time
operator|-
literal|1
operator|-
name|ticker
operator|.
name|modified_creation_time
return|;
else|else
return|return
name|get_run_time
argument_list|()
operator|-
name|ticker
operator|.
name|modified_creation_time
return|;
block|}
end_function

begin_comment
comment|/* The following function returns string representation of active time    of given ticker.  The result is string representation of seconds    with accuracy of 1/100 second.  Only result of the last call of the    function exists.  Therefore the following code is not correct        printf ("parser time: %s\ngeneration time: %s\n",               active_time_string (parser_ticker),               active_time_string (generation_ticker));     Correct code has to be the following        printf ("parser time: %s\n", active_time_string (parser_ticker));       printf ("generation time: %s\n",               active_time_string (generation_ticker));  */
end_comment

begin_function
specifier|static
name|void
name|print_active_time
parameter_list|(
name|f
parameter_list|,
name|ticker
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
name|ticker_t
name|ticker
decl_stmt|;
block|{
name|int
name|msecs
decl_stmt|;
name|msecs
operator|=
name|active_time
argument_list|(
name|ticker
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%d.%06d"
argument_list|,
name|msecs
operator|/
literal|1000000
argument_list|,
name|msecs
operator|%
literal|1000000
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The following variable value is number of automaton which are    really being created.  This value is defined on the base of    argument of option `-split'.  If the variable has zero value the    number of automata is defined by the constructions `%automaton'.    This case occures when option `-split' is absent or has zero    argument.  If constructions `define_automaton' is absent only one    automaton is created.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|automata_num
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following variable values are times of        o transformation of regular expressions        o building NDFA (DFA if !ndfa_flag)        o NDFA -> DFA   (simply the same automaton if !ndfa_flag)        o DFA minimization        o building insn equivalence classes        o all previous ones        o code output */
end_comment

begin_decl_stmt
specifier|static
name|ticker_t
name|transform_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ticker_t
name|NDFA_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ticker_t
name|NDFA_to_DFA_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ticker_t
name|minimize_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ticker_t
name|equiv_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ticker_t
name|automaton_generation_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ticker_t
name|output_time
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following variable values are times of        all checking        all generation        all pipeline hazard translator work */
end_comment

begin_decl_stmt
specifier|static
name|ticker_t
name|check_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ticker_t
name|generation_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ticker_t
name|all_time
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Pseudo insn decl which denotes advancing cycle.  */
end_comment

begin_decl_stmt
specifier|static
name|decl_t
name|advance_cycle_insn_decl
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|add_advance_cycle_insn_decl
parameter_list|()
block|{
name|advance_cycle_insn_decl
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|advance_cycle_insn_decl
operator|->
name|mode
operator|=
name|dm_insn_reserv
expr_stmt|;
name|advance_cycle_insn_decl
operator|->
name|pos
operator|=
name|no_pos
expr_stmt|;
name|DECL_INSN_RESERV
argument_list|(
name|advance_cycle_insn_decl
argument_list|)
operator|->
name|regexp
operator|=
name|NULL
expr_stmt|;
name|DECL_INSN_RESERV
argument_list|(
name|advance_cycle_insn_decl
argument_list|)
operator|->
name|name
operator|=
operator|(
name|char
operator|*
operator|)
literal|"$advance_cycle"
expr_stmt|;
name|DECL_INSN_RESERV
argument_list|(
name|advance_cycle_insn_decl
argument_list|)
operator|->
name|insn_num
operator|=
name|description
operator|->
name|insns_num
expr_stmt|;
name|description
operator|->
name|decls
index|[
name|description
operator|->
name|decls_num
index|]
operator|=
name|advance_cycle_insn_decl
expr_stmt|;
name|description
operator|->
name|decls_num
operator|++
expr_stmt|;
name|description
operator|->
name|insns_num
operator|++
expr_stmt|;
name|num_dfa_decls
operator|++
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Abstract data `alternative states' which reperesents    nondeterministic nature of the description (see comments for    structures alt_state and state).  */
end_comment

begin_comment
comment|/* List of free states.  */
end_comment

begin_decl_stmt
specifier|static
name|alt_state_t
name|first_free_alt_state
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|NDEBUG
end_ifndef

begin_comment
comment|/* The following variables is maximal number of allocated nodes    alt_state.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|allocated_alt_states_num
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The following function returns free node alt_state.  It may be new    allocated node or node freed eralier.  */
end_comment

begin_function
specifier|static
name|alt_state_t
name|get_free_alt_state
parameter_list|()
block|{
name|alt_state_t
name|result
decl_stmt|;
if|if
condition|(
name|first_free_alt_state
operator|!=
name|NULL
condition|)
block|{
name|result
operator|=
name|first_free_alt_state
expr_stmt|;
name|first_free_alt_state
operator|=
name|first_free_alt_state
operator|->
name|next_alt_state
expr_stmt|;
block|}
else|else
block|{
ifndef|#
directive|ifndef
name|NDEBUG
name|allocated_alt_states_num
operator|++
expr_stmt|;
endif|#
directive|endif
name|result
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|alt_state
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|result
operator|->
name|state
operator|=
name|NULL
expr_stmt|;
name|result
operator|->
name|next_alt_state
operator|=
name|NULL
expr_stmt|;
name|result
operator|->
name|next_sorted_alt_state
operator|=
name|NULL
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* The function frees node ALT_STATE.  */
end_comment

begin_function
specifier|static
name|void
name|free_alt_state
parameter_list|(
name|alt_state
parameter_list|)
name|alt_state_t
name|alt_state
decl_stmt|;
block|{
if|if
condition|(
name|alt_state
operator|==
name|NULL
condition|)
return|return;
name|alt_state
operator|->
name|next_alt_state
operator|=
name|first_free_alt_state
expr_stmt|;
name|first_free_alt_state
operator|=
name|alt_state
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function frees list started with node ALT_STATE_LIST.  */
end_comment

begin_function
specifier|static
name|void
name|free_alt_states
parameter_list|(
name|alt_states_list
parameter_list|)
name|alt_state_t
name|alt_states_list
decl_stmt|;
block|{
name|alt_state_t
name|curr_alt_state
decl_stmt|;
name|alt_state_t
name|next_alt_state
decl_stmt|;
for|for
control|(
name|curr_alt_state
operator|=
name|alt_states_list
init|;
name|curr_alt_state
operator|!=
name|NULL
condition|;
name|curr_alt_state
operator|=
name|next_alt_state
control|)
block|{
name|next_alt_state
operator|=
name|curr_alt_state
operator|->
name|next_alt_state
expr_stmt|;
name|free_alt_state
argument_list|(
name|curr_alt_state
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The function compares unique numbers of alt states.  */
end_comment

begin_function
specifier|static
name|int
name|alt_state_cmp
parameter_list|(
name|alt_state_ptr_1
parameter_list|,
name|alt_state_ptr_2
parameter_list|)
specifier|const
name|void
modifier|*
name|alt_state_ptr_1
decl_stmt|;
specifier|const
name|void
modifier|*
name|alt_state_ptr_2
decl_stmt|;
block|{
if|if
condition|(
operator|(
operator|*
operator|(
name|alt_state_t
operator|*
operator|)
name|alt_state_ptr_1
operator|)
operator|->
name|state
operator|->
name|unique_num
operator|==
operator|(
operator|*
operator|(
name|alt_state_t
operator|*
operator|)
name|alt_state_ptr_2
operator|)
operator|->
name|state
operator|->
name|unique_num
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
operator|(
operator|*
operator|(
name|alt_state_t
operator|*
operator|)
name|alt_state_ptr_1
operator|)
operator|->
name|state
operator|->
name|unique_num
operator|<
operator|(
operator|*
operator|(
name|alt_state_t
operator|*
operator|)
name|alt_state_ptr_2
operator|)
operator|->
name|state
operator|->
name|unique_num
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* The function sorts ALT_STATES_LIST and removes duplicated alt    states from the list.  The comparison key is alt state unique    number.  */
end_comment

begin_function
specifier|static
name|alt_state_t
name|uniq_sort_alt_states
parameter_list|(
name|alt_states_list
parameter_list|)
name|alt_state_t
name|alt_states_list
decl_stmt|;
block|{
name|alt_state_t
name|curr_alt_state
decl_stmt|;
name|vla_ptr_t
name|alt_states
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|size_t
name|prev_unique_state_ind
decl_stmt|;
name|alt_state_t
name|result
decl_stmt|;
name|alt_state_t
modifier|*
name|result_ptr
decl_stmt|;
name|VLA_PTR_CREATE
argument_list|(
name|alt_states
argument_list|,
literal|150
argument_list|,
literal|"alt_states"
argument_list|)
expr_stmt|;
for|for
control|(
name|curr_alt_state
operator|=
name|alt_states_list
init|;
name|curr_alt_state
operator|!=
name|NULL
condition|;
name|curr_alt_state
operator|=
name|curr_alt_state
operator|->
name|next_alt_state
control|)
name|VLA_PTR_ADD
argument_list|(
name|alt_states
argument_list|,
name|curr_alt_state
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|VLA_PTR_BEGIN
argument_list|(
name|alt_states
argument_list|)
argument_list|,
name|VLA_PTR_LENGTH
argument_list|(
name|alt_states
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|alt_state_t
argument_list|)
argument_list|,
name|alt_state_cmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|VLA_PTR_LENGTH
argument_list|(
name|alt_states
argument_list|)
operator|==
literal|0
condition|)
name|result
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|result_ptr
operator|=
name|VLA_PTR_BEGIN
argument_list|(
name|alt_states
argument_list|)
expr_stmt|;
name|prev_unique_state_ind
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|VLA_PTR_LENGTH
argument_list|(
name|alt_states
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|result_ptr
index|[
name|prev_unique_state_ind
index|]
operator|->
name|state
operator|!=
name|result_ptr
index|[
name|i
index|]
operator|->
name|state
condition|)
block|{
name|prev_unique_state_ind
operator|++
expr_stmt|;
name|result_ptr
index|[
name|prev_unique_state_ind
index|]
operator|=
name|result_ptr
index|[
name|i
index|]
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|for (i = prev_unique_state_ind + 1; i< VLA_PTR_LENGTH (alt_states); i++)         free_alt_state (result_ptr [i]);
endif|#
directive|endif
name|VLA_PTR_SHORTEN
argument_list|(
name|alt_states
argument_list|,
name|i
operator|-
name|prev_unique_state_ind
operator|-
literal|1
argument_list|)
expr_stmt|;
name|result_ptr
operator|=
name|VLA_PTR_BEGIN
argument_list|(
name|alt_states
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|VLA_PTR_LENGTH
argument_list|(
name|alt_states
argument_list|)
condition|;
name|i
operator|++
control|)
name|result_ptr
index|[
name|i
operator|-
literal|1
index|]
operator|->
name|next_sorted_alt_state
operator|=
name|result_ptr
index|[
name|i
index|]
expr_stmt|;
name|result_ptr
index|[
name|i
operator|-
literal|1
index|]
operator|->
name|next_sorted_alt_state
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
operator|*
name|result_ptr
expr_stmt|;
block|}
name|VLA_PTR_DELETE
argument_list|(
name|alt_states
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* The function checks equality of alt state lists.  Remember that the    lists must be already sorted by the previous function.  */
end_comment

begin_function
specifier|static
name|int
name|alt_states_eq
parameter_list|(
name|alt_states_1
parameter_list|,
name|alt_states_2
parameter_list|)
name|alt_state_t
name|alt_states_1
decl_stmt|;
name|alt_state_t
name|alt_states_2
decl_stmt|;
block|{
while|while
condition|(
name|alt_states_1
operator|!=
name|NULL
operator|&&
name|alt_states_2
operator|!=
name|NULL
operator|&&
name|alt_state_cmp
argument_list|(
operator|&
name|alt_states_1
argument_list|,
operator|&
name|alt_states_2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|alt_states_1
operator|=
name|alt_states_1
operator|->
name|next_sorted_alt_state
expr_stmt|;
name|alt_states_2
operator|=
name|alt_states_2
operator|->
name|next_sorted_alt_state
expr_stmt|;
block|}
return|return
name|alt_states_1
operator|==
name|alt_states_2
return|;
block|}
end_function

begin_comment
comment|/* Initialization of the abstract data.  */
end_comment

begin_function
specifier|static
name|void
name|initiate_alt_states
parameter_list|()
block|{
name|first_free_alt_state
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finishing work with the abstract data.  */
end_comment

begin_function
specifier|static
name|void
name|finish_alt_states
parameter_list|()
block|{ }
end_function

begin_escape
end_escape

begin_comment
comment|/* The page contains macros for work with bits strings.  We could use    standard gcc bitmap or sbitmap but it would result in difficulties    of building canadian cross.  */
end_comment

begin_comment
comment|/* Set bit number bitno in the bit string.  The macro is not side    effect proof.  */
end_comment

begin_define
define|#
directive|define
name|SET_BIT
parameter_list|(
name|bitstring
parameter_list|,
name|bitno
parameter_list|)
define|\
value|(((char *) (bitstring)) [(bitno) / CHAR_BIT] |= 1<< (bitno) % CHAR_BIT)
end_define

begin_comment
comment|/* Test if bit number bitno in the bitstring is set.  The macro is not    side effect proof.  */
end_comment

begin_define
define|#
directive|define
name|TEST_BIT
parameter_list|(
name|bitstring
parameter_list|,
name|bitno
parameter_list|)
define|\
value|(((char *) (bitstring)) [(bitno) / CHAR_BIT]>> (bitno) % CHAR_BIT& 1)
end_define

begin_escape
end_escape

begin_comment
comment|/* This page contains abstract data `state'.  */
end_comment

begin_comment
comment|/* Maximal length of reservations in cycles (>= 1).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_cycles_num
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of set elements (see type set_el_t) needed for    representation of one cycle reservation.  It is depended on units    number.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|els_in_cycle_reserv
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of set elements (see type set_el_t) needed for    representation of maximal length reservation.  Deterministic    reservation is stored as set (bit string) of length equal to the    variable value * number of bits in set_el_t.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|els_in_reservs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VLA for representation of array of pointers to unit    declarations.  */
end_comment

begin_decl_stmt
specifier|static
name|vla_ptr_t
name|units_container
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The start address of the array.  */
end_comment

begin_decl_stmt
specifier|static
name|unit_decl_t
modifier|*
name|units_array
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Empty reservation of maximal length.  */
end_comment

begin_decl_stmt
specifier|static
name|reserv_sets_t
name|empty_reserv
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The state table itself is represented by the following variable.  */
end_comment

begin_decl_stmt
specifier|static
name|htab_t
name|state_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VLA for representation of array of pointers to free nodes    `state'.  */
end_comment

begin_decl_stmt
specifier|static
name|vla_ptr_t
name|free_states
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|curr_unique_state_num
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|NDEBUG
end_ifndef

begin_comment
comment|/* The following variables is maximal number of allocated nodes    `state'.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|allocated_states_num
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Allocate new reservation set.  */
end_comment

begin_function
specifier|static
name|reserv_sets_t
name|alloc_empty_reserv_sets
parameter_list|()
block|{
name|reserv_sets_t
name|result
decl_stmt|;
name|obstack_blank
argument_list|(
operator|&
name|irp
argument_list|,
name|els_in_reservs
operator|*
sizeof|sizeof
argument_list|(
name|set_el_t
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
operator|(
name|reserv_sets_t
operator|)
name|obstack_base
argument_list|(
operator|&
name|irp
argument_list|)
expr_stmt|;
name|obstack_finish
argument_list|(
operator|&
name|irp
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|result
argument_list|,
literal|0
argument_list|,
name|els_in_reservs
operator|*
sizeof|sizeof
argument_list|(
name|set_el_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Hash value of reservation set.  */
end_comment

begin_function
specifier|static
name|unsigned
name|reserv_sets_hash_value
parameter_list|(
name|reservs
parameter_list|)
name|reserv_sets_t
name|reservs
decl_stmt|;
block|{
name|set_el_t
name|hash_value
decl_stmt|;
name|unsigned
name|result
decl_stmt|;
name|int
name|reservs_num
decl_stmt|,
name|i
decl_stmt|;
name|set_el_t
modifier|*
name|reserv_ptr
decl_stmt|;
name|hash_value
operator|=
literal|0
expr_stmt|;
name|reservs_num
operator|=
name|els_in_reservs
expr_stmt|;
name|reserv_ptr
operator|=
name|reservs
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|reservs_num
operator|!=
literal|0
condition|)
block|{
name|reservs_num
operator|--
expr_stmt|;
name|hash_value
operator|+=
operator|(
operator|(
operator|*
name|reserv_ptr
operator|>>
name|i
operator|)
operator||
operator|(
operator|*
name|reserv_ptr
operator|<<
operator|(
sizeof|sizeof
argument_list|(
name|set_el_t
argument_list|)
operator|*
name|CHAR_BIT
operator|-
name|i
operator|)
operator|)
operator|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|==
sizeof|sizeof
argument_list|(
name|set_el_t
argument_list|)
operator|*
name|CHAR_BIT
condition|)
name|i
operator|=
literal|0
expr_stmt|;
name|reserv_ptr
operator|++
expr_stmt|;
block|}
if|if
condition|(
sizeof|sizeof
argument_list|(
name|set_el_t
argument_list|)
operator|<=
sizeof|sizeof
argument_list|(
name|unsigned
argument_list|)
condition|)
return|return
name|hash_value
return|;
name|result
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
sizeof|sizeof
argument_list|(
name|set_el_t
argument_list|)
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|-=
sizeof|sizeof
argument_list|(
name|unsigned
argument_list|)
operator|-
literal|1
control|)
block|{
name|result
operator|+=
operator|(
name|unsigned
operator|)
name|hash_value
expr_stmt|;
name|hash_value
operator|>>=
operator|(
sizeof|sizeof
argument_list|(
name|unsigned
argument_list|)
operator|-
literal|1
operator|)
operator|*
name|CHAR_BIT
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Comparison of given reservation sets.  */
end_comment

begin_function
specifier|static
name|int
name|reserv_sets_cmp
parameter_list|(
name|reservs_1
parameter_list|,
name|reservs_2
parameter_list|)
name|reserv_sets_t
name|reservs_1
decl_stmt|;
name|reserv_sets_t
name|reservs_2
decl_stmt|;
block|{
name|int
name|reservs_num
decl_stmt|;
name|set_el_t
modifier|*
name|reserv_ptr_1
decl_stmt|;
name|set_el_t
modifier|*
name|reserv_ptr_2
decl_stmt|;
if|if
condition|(
name|reservs_1
operator|==
name|NULL
operator|||
name|reservs_2
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|reservs_num
operator|=
name|els_in_reservs
expr_stmt|;
name|reserv_ptr_1
operator|=
name|reservs_1
expr_stmt|;
name|reserv_ptr_2
operator|=
name|reservs_2
expr_stmt|;
while|while
condition|(
name|reservs_num
operator|!=
literal|0
operator|&&
operator|*
name|reserv_ptr_1
operator|==
operator|*
name|reserv_ptr_2
condition|)
block|{
name|reservs_num
operator|--
expr_stmt|;
name|reserv_ptr_1
operator|++
expr_stmt|;
name|reserv_ptr_2
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|reservs_num
operator|==
literal|0
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
operator|*
name|reserv_ptr_1
operator|<
operator|*
name|reserv_ptr_2
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* The function checks equality of the reservation sets.  */
end_comment

begin_function
specifier|static
name|int
name|reserv_sets_eq
parameter_list|(
name|reservs_1
parameter_list|,
name|reservs_2
parameter_list|)
name|reserv_sets_t
name|reservs_1
decl_stmt|;
name|reserv_sets_t
name|reservs_2
decl_stmt|;
block|{
return|return
name|reserv_sets_cmp
argument_list|(
name|reservs_1
argument_list|,
name|reservs_2
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Set up in the reservation set that unit with UNIT_NUM is used on    CYCLE_NUM.  */
end_comment

begin_function
specifier|static
name|void
name|set_unit_reserv
parameter_list|(
name|reservs
parameter_list|,
name|cycle_num
parameter_list|,
name|unit_num
parameter_list|)
name|reserv_sets_t
name|reservs
decl_stmt|;
name|int
name|cycle_num
decl_stmt|;
name|int
name|unit_num
decl_stmt|;
block|{
if|if
condition|(
name|cycle_num
operator|>=
name|max_cycles_num
condition|)
name|abort
argument_list|()
expr_stmt|;
name|SET_BIT
argument_list|(
name|reservs
argument_list|,
name|cycle_num
operator|*
name|els_in_cycle_reserv
operator|*
sizeof|sizeof
argument_list|(
name|set_el_t
argument_list|)
operator|*
name|CHAR_BIT
operator|+
name|unit_num
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set up in the reservation set RESERVS that unit with UNIT_NUM is    used on CYCLE_NUM.  */
end_comment

begin_function
specifier|static
name|int
name|test_unit_reserv
parameter_list|(
name|reservs
parameter_list|,
name|cycle_num
parameter_list|,
name|unit_num
parameter_list|)
name|reserv_sets_t
name|reservs
decl_stmt|;
name|int
name|cycle_num
decl_stmt|;
name|int
name|unit_num
decl_stmt|;
block|{
if|if
condition|(
name|cycle_num
operator|>=
name|max_cycles_num
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|TEST_BIT
argument_list|(
name|reservs
argument_list|,
name|cycle_num
operator|*
name|els_in_cycle_reserv
operator|*
sizeof|sizeof
argument_list|(
name|set_el_t
argument_list|)
operator|*
name|CHAR_BIT
operator|+
name|unit_num
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The function checks that the reservation set represents no one unit    reservation.  */
end_comment

begin_function
specifier|static
name|int
name|it_is_empty_reserv_sets
parameter_list|(
name|operand
parameter_list|)
name|reserv_sets_t
name|operand
decl_stmt|;
block|{
name|set_el_t
modifier|*
name|reserv_ptr
decl_stmt|;
name|int
name|reservs_num
decl_stmt|;
if|if
condition|(
name|operand
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|reservs_num
operator|=
name|els_in_reservs
operator|,
name|reserv_ptr
operator|=
name|operand
init|;
name|reservs_num
operator|!=
literal|0
condition|;
name|reserv_ptr
operator|++
operator|,
name|reservs_num
operator|--
control|)
if|if
condition|(
operator|*
name|reserv_ptr
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* The function checks that the reservation sets are intersected,    i.e. there is a unit reservation on a cycle in both reservation    sets.  */
end_comment

begin_function
specifier|static
name|int
name|reserv_sets_are_intersected
parameter_list|(
name|operand_1
parameter_list|,
name|operand_2
parameter_list|)
name|reserv_sets_t
name|operand_1
decl_stmt|;
name|reserv_sets_t
name|operand_2
decl_stmt|;
block|{
name|set_el_t
modifier|*
name|el_ptr_1
decl_stmt|;
name|set_el_t
modifier|*
name|el_ptr_2
decl_stmt|;
name|set_el_t
modifier|*
name|cycle_ptr_1
decl_stmt|;
name|set_el_t
modifier|*
name|cycle_ptr_2
decl_stmt|;
name|int
name|nonzero_p
decl_stmt|;
if|if
condition|(
name|operand_1
operator|==
name|NULL
operator|||
name|operand_2
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|el_ptr_1
operator|=
name|operand_1
operator|,
name|el_ptr_2
operator|=
name|operand_2
init|;
name|el_ptr_1
operator|<
name|operand_1
operator|+
name|els_in_reservs
condition|;
name|el_ptr_1
operator|++
operator|,
name|el_ptr_2
operator|++
control|)
if|if
condition|(
operator|*
name|el_ptr_1
operator|&
operator|*
name|el_ptr_2
condition|)
return|return
literal|1
return|;
for|for
control|(
name|cycle_ptr_1
operator|=
name|operand_1
operator|,
name|cycle_ptr_2
operator|=
name|operand_2
init|;
name|cycle_ptr_1
operator|<
name|operand_1
operator|+
name|els_in_reservs
condition|;
name|cycle_ptr_1
operator|+=
name|els_in_cycle_reserv
operator|,
name|cycle_ptr_2
operator|+=
name|els_in_cycle_reserv
control|)
block|{
for|for
control|(
name|el_ptr_1
operator|=
name|cycle_ptr_1
operator|,
name|el_ptr_2
operator|=
name|get_excl_set
argument_list|(
name|cycle_ptr_2
argument_list|)
init|;
name|el_ptr_1
operator|<
name|cycle_ptr_1
operator|+
name|els_in_cycle_reserv
condition|;
name|el_ptr_1
operator|++
operator|,
name|el_ptr_2
operator|++
control|)
if|if
condition|(
operator|*
name|el_ptr_1
operator|&
operator|*
name|el_ptr_2
condition|)
return|return
literal|1
return|;
name|nonzero_p
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|el_ptr_1
operator|=
name|cycle_ptr_1
operator|,
name|el_ptr_2
operator|=
name|get_presence_absence_set
argument_list|(
name|cycle_ptr_2
argument_list|,
literal|1
argument_list|)
init|;
name|el_ptr_1
operator|<
name|cycle_ptr_1
operator|+
name|els_in_cycle_reserv
condition|;
name|el_ptr_1
operator|++
operator|,
name|el_ptr_2
operator|++
control|)
if|if
condition|(
operator|*
name|el_ptr_1
operator|&
operator|*
name|el_ptr_2
condition|)
break|break;
elseif|else
if|if
condition|(
operator|*
name|el_ptr_2
operator|!=
literal|0
condition|)
name|nonzero_p
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|nonzero_p
operator|&&
name|el_ptr_1
operator|>=
name|cycle_ptr_1
operator|+
name|els_in_cycle_reserv
condition|)
return|return
literal|1
return|;
for|for
control|(
name|el_ptr_1
operator|=
name|cycle_ptr_1
operator|,
name|el_ptr_2
operator|=
name|get_presence_absence_set
argument_list|(
name|cycle_ptr_2
argument_list|,
literal|0
argument_list|)
init|;
name|el_ptr_1
operator|<
name|cycle_ptr_1
operator|+
name|els_in_cycle_reserv
condition|;
name|el_ptr_1
operator|++
operator|,
name|el_ptr_2
operator|++
control|)
comment|/* It looks like code for exclusion but exclusion set is            made as symmetric relation preliminary.  */
if|if
condition|(
operator|*
name|el_ptr_1
operator|&
operator|*
name|el_ptr_2
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* The function sets up RESULT bits by bits of OPERAND shifted on one    cpu cycle.  The remaining bits of OPERAND (representing the last    cycle unit reservations) are not chenged.  */
end_comment

begin_function
specifier|static
name|void
name|reserv_sets_shift
parameter_list|(
name|result
parameter_list|,
name|operand
parameter_list|)
name|reserv_sets_t
name|result
decl_stmt|;
name|reserv_sets_t
name|operand
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
operator|||
name|operand
operator|==
name|NULL
operator|||
name|result
operator|==
name|operand
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
name|els_in_cycle_reserv
init|;
name|i
operator|<
name|els_in_reservs
condition|;
name|i
operator|++
control|)
name|result
index|[
name|i
operator|-
name|els_in_cycle_reserv
index|]
operator|=
name|operand
index|[
name|i
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* OR of the reservation sets.  */
end_comment

begin_function
specifier|static
name|void
name|reserv_sets_or
parameter_list|(
name|result
parameter_list|,
name|operand_1
parameter_list|,
name|operand_2
parameter_list|)
name|reserv_sets_t
name|result
decl_stmt|;
name|reserv_sets_t
name|operand_1
decl_stmt|;
name|reserv_sets_t
name|operand_2
decl_stmt|;
block|{
name|set_el_t
modifier|*
name|el_ptr_1
decl_stmt|;
name|set_el_t
modifier|*
name|el_ptr_2
decl_stmt|;
name|set_el_t
modifier|*
name|result_set_el_ptr
decl_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
operator|||
name|operand_1
operator|==
name|NULL
operator|||
name|operand_2
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|el_ptr_1
operator|=
name|operand_1
operator|,
name|el_ptr_2
operator|=
name|operand_2
operator|,
name|result_set_el_ptr
operator|=
name|result
init|;
name|el_ptr_1
operator|<
name|operand_1
operator|+
name|els_in_reservs
condition|;
name|el_ptr_1
operator|++
operator|,
name|el_ptr_2
operator|++
operator|,
name|result_set_el_ptr
operator|++
control|)
operator|*
name|result_set_el_ptr
operator|=
operator|*
name|el_ptr_1
operator||
operator|*
name|el_ptr_2
expr_stmt|;
block|}
end_function

begin_comment
comment|/* AND of the reservation sets.  */
end_comment

begin_function
specifier|static
name|void
name|reserv_sets_and
parameter_list|(
name|result
parameter_list|,
name|operand_1
parameter_list|,
name|operand_2
parameter_list|)
name|reserv_sets_t
name|result
decl_stmt|;
name|reserv_sets_t
name|operand_1
decl_stmt|;
name|reserv_sets_t
name|operand_2
decl_stmt|;
block|{
name|set_el_t
modifier|*
name|el_ptr_1
decl_stmt|;
name|set_el_t
modifier|*
name|el_ptr_2
decl_stmt|;
name|set_el_t
modifier|*
name|result_set_el_ptr
decl_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
operator|||
name|operand_1
operator|==
name|NULL
operator|||
name|operand_2
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|el_ptr_1
operator|=
name|operand_1
operator|,
name|el_ptr_2
operator|=
name|operand_2
operator|,
name|result_set_el_ptr
operator|=
name|result
init|;
name|el_ptr_1
operator|<
name|operand_1
operator|+
name|els_in_reservs
condition|;
name|el_ptr_1
operator|++
operator|,
name|el_ptr_2
operator|++
operator|,
name|result_set_el_ptr
operator|++
control|)
operator|*
name|result_set_el_ptr
operator|=
operator|*
name|el_ptr_1
operator|&
operator|*
name|el_ptr_2
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function outputs string representation of units reservation on    cycle START_CYCLE in the reservation set.  The function uses repeat    construction if REPETITION_NUM> 1.  */
end_comment

begin_function
specifier|static
name|void
name|output_cycle_reservs
parameter_list|(
name|f
parameter_list|,
name|reservs
parameter_list|,
name|start_cycle
parameter_list|,
name|repetition_num
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
name|reserv_sets_t
name|reservs
decl_stmt|;
name|int
name|start_cycle
decl_stmt|;
name|int
name|repetition_num
decl_stmt|;
block|{
name|int
name|unit_num
decl_stmt|;
name|int
name|reserved_units_num
decl_stmt|;
name|reserved_units_num
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|unit_num
operator|=
literal|0
init|;
name|unit_num
operator|<
name|description
operator|->
name|units_num
condition|;
name|unit_num
operator|++
control|)
if|if
condition|(
name|TEST_BIT
argument_list|(
name|reservs
argument_list|,
name|start_cycle
operator|*
name|els_in_cycle_reserv
operator|*
sizeof|sizeof
argument_list|(
name|set_el_t
argument_list|)
operator|*
name|CHAR_BIT
operator|+
name|unit_num
argument_list|)
condition|)
name|reserved_units_num
operator|++
expr_stmt|;
if|if
condition|(
name|repetition_num
operator|<=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|repetition_num
operator|!=
literal|1
operator|&&
name|reserved_units_num
operator|>
literal|1
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|reserved_units_num
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|unit_num
operator|=
literal|0
init|;
name|unit_num
operator|<
name|description
operator|->
name|units_num
condition|;
name|unit_num
operator|++
control|)
if|if
condition|(
name|TEST_BIT
argument_list|(
name|reservs
argument_list|,
name|start_cycle
operator|*
name|els_in_cycle_reserv
operator|*
sizeof|sizeof
argument_list|(
name|set_el_t
argument_list|)
operator|*
name|CHAR_BIT
operator|+
name|unit_num
argument_list|)
condition|)
block|{
if|if
condition|(
name|reserved_units_num
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"+"
argument_list|)
expr_stmt|;
name|reserved_units_num
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s"
argument_list|,
name|units_array
index|[
name|unit_num
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reserved_units_num
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
name|NOTHING_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|repetition_num
operator|<=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|reserved_units_num
operator|>
literal|1
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
if|if
condition|(
name|repetition_num
operator|!=
literal|1
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"*%d"
argument_list|,
name|repetition_num
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function outputs string representation of units reservation in    the reservation set.  */
end_comment

begin_function
specifier|static
name|void
name|output_reserv_sets
parameter_list|(
name|f
parameter_list|,
name|reservs
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
name|reserv_sets_t
name|reservs
decl_stmt|;
block|{
name|int
name|start_cycle
init|=
literal|0
decl_stmt|;
name|int
name|cycle
decl_stmt|;
name|int
name|repetition_num
decl_stmt|;
name|repetition_num
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cycle
operator|=
literal|0
init|;
name|cycle
operator|<
name|max_cycles_num
condition|;
name|cycle
operator|++
control|)
if|if
condition|(
name|repetition_num
operator|==
literal|0
condition|)
block|{
name|repetition_num
operator|++
expr_stmt|;
name|start_cycle
operator|=
name|cycle
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|memcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reservs
operator|+
name|start_cycle
operator|*
name|els_in_cycle_reserv
operator|*
sizeof|sizeof
argument_list|(
name|set_el_t
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|reservs
operator|+
name|cycle
operator|*
name|els_in_cycle_reserv
operator|*
sizeof|sizeof
argument_list|(
name|set_el_t
argument_list|)
argument_list|,
name|els_in_cycle_reserv
operator|*
sizeof|sizeof
argument_list|(
name|set_el_t
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|repetition_num
operator|++
expr_stmt|;
else|else
block|{
if|if
condition|(
name|start_cycle
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|output_cycle_reservs
argument_list|(
name|f
argument_list|,
name|reservs
argument_list|,
name|start_cycle
argument_list|,
name|repetition_num
argument_list|)
expr_stmt|;
name|repetition_num
operator|=
literal|1
expr_stmt|;
name|start_cycle
operator|=
name|cycle
expr_stmt|;
block|}
if|if
condition|(
name|start_cycle
operator|<
name|max_cycles_num
condition|)
block|{
if|if
condition|(
name|start_cycle
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|output_cycle_reservs
argument_list|(
name|f
argument_list|,
name|reservs
argument_list|,
name|start_cycle
argument_list|,
name|repetition_num
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The following function returns free node state for AUTOMATON.  It    may be new allocated node or node freed eralier.  The function also    allocates reservation set if WITH_RESERVS has nonzero value.  */
end_comment

begin_function
specifier|static
name|state_t
name|get_free_state
parameter_list|(
name|with_reservs
parameter_list|,
name|automaton
parameter_list|)
name|int
name|with_reservs
decl_stmt|;
name|automaton_t
name|automaton
decl_stmt|;
block|{
name|state_t
name|result
decl_stmt|;
if|if
condition|(
name|max_cycles_num
operator|<=
literal|0
operator|||
name|automaton
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|VLA_PTR_LENGTH
argument_list|(
name|free_states
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|result
operator|=
name|VLA_PTR
argument_list|(
name|free_states
argument_list|,
name|VLA_PTR_LENGTH
argument_list|(
name|free_states
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|VLA_PTR_SHORTEN
argument_list|(
name|free_states
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|result
operator|->
name|automaton
operator|=
name|automaton
expr_stmt|;
name|result
operator|->
name|first_out_arc
operator|=
name|NULL
expr_stmt|;
name|result
operator|->
name|it_was_placed_in_stack_for_NDFA_forming
operator|=
literal|0
expr_stmt|;
name|result
operator|->
name|it_was_placed_in_stack_for_DFA_forming
operator|=
literal|0
expr_stmt|;
name|result
operator|->
name|component_states
operator|=
name|NULL
expr_stmt|;
name|result
operator|->
name|longest_path_length
operator|=
name|UNDEFINED_LONGEST_PATH_LENGTH
expr_stmt|;
block|}
else|else
block|{
ifndef|#
directive|ifndef
name|NDEBUG
name|allocated_states_num
operator|++
expr_stmt|;
endif|#
directive|endif
name|result
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|state
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|->
name|automaton
operator|=
name|automaton
expr_stmt|;
name|result
operator|->
name|first_out_arc
operator|=
name|NULL
expr_stmt|;
name|result
operator|->
name|unique_num
operator|=
name|curr_unique_state_num
expr_stmt|;
name|result
operator|->
name|longest_path_length
operator|=
name|UNDEFINED_LONGEST_PATH_LENGTH
expr_stmt|;
name|curr_unique_state_num
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|with_reservs
condition|)
block|{
if|if
condition|(
name|result
operator|->
name|reservs
operator|==
name|NULL
condition|)
name|result
operator|->
name|reservs
operator|=
name|alloc_empty_reserv_sets
argument_list|()
expr_stmt|;
else|else
name|memset
argument_list|(
name|result
operator|->
name|reservs
argument_list|,
literal|0
argument_list|,
name|els_in_reservs
operator|*
sizeof|sizeof
argument_list|(
name|set_el_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* The function frees node STATE.  */
end_comment

begin_function
specifier|static
name|void
name|free_state
parameter_list|(
name|state
parameter_list|)
name|state_t
name|state
decl_stmt|;
block|{
name|free_alt_states
argument_list|(
name|state
operator|->
name|component_states
argument_list|)
expr_stmt|;
name|VLA_PTR_ADD
argument_list|(
name|free_states
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Hash value of STATE.  If STATE represents deterministic state it is    simply hash value of the corresponding reservation set.  Otherwise    it is formed from hash values of the component deterministic    states.  One more key is order number of state automaton.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|state_hash
parameter_list|(
name|state
parameter_list|)
specifier|const
name|void
modifier|*
name|state
decl_stmt|;
block|{
name|unsigned
name|int
name|hash_value
decl_stmt|;
name|alt_state_t
name|alt_state
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|state_t
operator|)
name|state
operator|)
operator|->
name|component_states
operator|==
name|NULL
condition|)
name|hash_value
operator|=
name|reserv_sets_hash_value
argument_list|(
operator|(
operator|(
name|state_t
operator|)
name|state
operator|)
operator|->
name|reservs
argument_list|)
expr_stmt|;
else|else
block|{
name|hash_value
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|alt_state
operator|=
operator|(
operator|(
name|state_t
operator|)
name|state
operator|)
operator|->
name|component_states
init|;
name|alt_state
operator|!=
name|NULL
condition|;
name|alt_state
operator|=
name|alt_state
operator|->
name|next_sorted_alt_state
control|)
name|hash_value
operator|=
operator|(
operator|(
operator|(
name|hash_value
operator|>>
operator|(
sizeof|sizeof
argument_list|(
name|unsigned
argument_list|)
operator|-
literal|1
operator|)
operator|*
name|CHAR_BIT
operator|)
operator||
operator|(
name|hash_value
operator|<<
name|CHAR_BIT
operator|)
operator|)
operator|+
name|alt_state
operator|->
name|state
operator|->
name|unique_num
operator|)
expr_stmt|;
block|}
name|hash_value
operator|=
operator|(
operator|(
operator|(
name|hash_value
operator|>>
operator|(
sizeof|sizeof
argument_list|(
name|unsigned
argument_list|)
operator|-
literal|1
operator|)
operator|*
name|CHAR_BIT
operator|)
operator||
operator|(
name|hash_value
operator|<<
name|CHAR_BIT
operator|)
operator|)
operator|+
operator|(
operator|(
name|state_t
operator|)
name|state
operator|)
operator|->
name|automaton
operator|->
name|automaton_order_num
operator|)
expr_stmt|;
return|return
name|hash_value
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero value if the states are the same.  */
end_comment

begin_function
specifier|static
name|int
name|state_eq_p
parameter_list|(
name|state_1
parameter_list|,
name|state_2
parameter_list|)
specifier|const
name|void
modifier|*
name|state_1
decl_stmt|;
specifier|const
name|void
modifier|*
name|state_2
decl_stmt|;
block|{
name|alt_state_t
name|alt_state_1
decl_stmt|;
name|alt_state_t
name|alt_state_2
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|state_t
operator|)
name|state_1
operator|)
operator|->
name|automaton
operator|!=
operator|(
operator|(
name|state_t
operator|)
name|state_2
operator|)
operator|->
name|automaton
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
operator|(
operator|(
name|state_t
operator|)
name|state_1
operator|)
operator|->
name|component_states
operator|==
name|NULL
operator|&&
operator|(
operator|(
name|state_t
operator|)
name|state_2
operator|)
operator|->
name|component_states
operator|==
name|NULL
condition|)
return|return
name|reserv_sets_eq
argument_list|(
operator|(
operator|(
name|state_t
operator|)
name|state_1
operator|)
operator|->
name|reservs
argument_list|,
operator|(
operator|(
name|state_t
operator|)
name|state_2
operator|)
operator|->
name|reservs
argument_list|)
return|;
elseif|else
if|if
condition|(
operator|(
operator|(
name|state_t
operator|)
name|state_1
operator|)
operator|->
name|component_states
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|state_t
operator|)
name|state_2
operator|)
operator|->
name|component_states
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|alt_state_1
operator|=
operator|(
operator|(
name|state_t
operator|)
name|state_1
operator|)
operator|->
name|component_states
operator|,
name|alt_state_2
operator|=
operator|(
operator|(
name|state_t
operator|)
name|state_2
operator|)
operator|->
name|component_states
init|;
name|alt_state_1
operator|!=
name|NULL
operator|&&
name|alt_state_2
operator|!=
name|NULL
condition|;
name|alt_state_1
operator|=
name|alt_state_1
operator|->
name|next_sorted_alt_state
operator|,
name|alt_state_2
operator|=
name|alt_state_2
operator|->
name|next_sorted_alt_state
control|)
comment|/* All state in the list must be already in the hash table.            Also the lists must be sorted.  */
if|if
condition|(
name|alt_state_1
operator|->
name|state
operator|!=
name|alt_state_2
operator|->
name|state
condition|)
return|return
literal|0
return|;
return|return
name|alt_state_1
operator|==
name|alt_state_2
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Insert STATE into the state table.  */
end_comment

begin_function
specifier|static
name|state_t
name|insert_state
parameter_list|(
name|state
parameter_list|)
name|state_t
name|state
decl_stmt|;
block|{
name|void
modifier|*
modifier|*
name|entry_ptr
decl_stmt|;
name|entry_ptr
operator|=
name|htab_find_slot
argument_list|(
name|state_table
argument_list|,
operator|(
name|void
operator|*
operator|)
name|state
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|entry_ptr
operator|==
name|NULL
condition|)
operator|*
name|entry_ptr
operator|=
operator|(
name|void
operator|*
operator|)
name|state
expr_stmt|;
return|return
operator|(
name|state_t
operator|)
operator|*
name|entry_ptr
return|;
block|}
end_function

begin_comment
comment|/* Add reservation of unit with UNIT_NUM on cycle CYCLE_NUM to    deterministic STATE.  */
end_comment

begin_function
specifier|static
name|void
name|set_state_reserv
parameter_list|(
name|state
parameter_list|,
name|cycle_num
parameter_list|,
name|unit_num
parameter_list|)
name|state_t
name|state
decl_stmt|;
name|int
name|cycle_num
decl_stmt|;
name|int
name|unit_num
decl_stmt|;
block|{
name|set_unit_reserv
argument_list|(
name|state
operator|->
name|reservs
argument_list|,
name|cycle_num
argument_list|,
name|unit_num
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return nonzero value if the deterministic states contains a    reservation of the same cpu unit on the same cpu cycle.  */
end_comment

begin_function
specifier|static
name|int
name|intersected_state_reservs_p
parameter_list|(
name|state1
parameter_list|,
name|state2
parameter_list|)
name|state_t
name|state1
decl_stmt|;
name|state_t
name|state2
decl_stmt|;
block|{
if|if
condition|(
name|state1
operator|->
name|automaton
operator|!=
name|state2
operator|->
name|automaton
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|reserv_sets_are_intersected
argument_list|(
name|state1
operator|->
name|reservs
argument_list|,
name|state2
operator|->
name|reservs
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return deterministic state (inserted into the table) which    representing the automaton state whic is union of reservations of    deterministic states.  */
end_comment

begin_function
specifier|static
name|state_t
name|states_union
parameter_list|(
name|state1
parameter_list|,
name|state2
parameter_list|)
name|state_t
name|state1
decl_stmt|;
name|state_t
name|state2
decl_stmt|;
block|{
name|state_t
name|result
decl_stmt|;
name|state_t
name|state_in_table
decl_stmt|;
if|if
condition|(
name|state1
operator|->
name|automaton
operator|!=
name|state2
operator|->
name|automaton
condition|)
name|abort
argument_list|()
expr_stmt|;
name|result
operator|=
name|get_free_state
argument_list|(
literal|1
argument_list|,
name|state1
operator|->
name|automaton
argument_list|)
expr_stmt|;
name|reserv_sets_or
argument_list|(
name|result
operator|->
name|reservs
argument_list|,
name|state1
operator|->
name|reservs
argument_list|,
name|state2
operator|->
name|reservs
argument_list|)
expr_stmt|;
name|state_in_table
operator|=
name|insert_state
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|state_in_table
condition|)
block|{
name|free_state
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|result
operator|=
name|state_in_table
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Return deterministic state (inserted into the table) which    represent the automaton state is obtained from deterministic STATE    by advancing cpu cycle.  */
end_comment

begin_function
specifier|static
name|state_t
name|state_shift
parameter_list|(
name|state
parameter_list|)
name|state_t
name|state
decl_stmt|;
block|{
name|state_t
name|result
decl_stmt|;
name|state_t
name|state_in_table
decl_stmt|;
name|result
operator|=
name|get_free_state
argument_list|(
literal|1
argument_list|,
name|state
operator|->
name|automaton
argument_list|)
expr_stmt|;
name|reserv_sets_shift
argument_list|(
name|result
operator|->
name|reservs
argument_list|,
name|state
operator|->
name|reservs
argument_list|)
expr_stmt|;
name|state_in_table
operator|=
name|insert_state
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|state_in_table
condition|)
block|{
name|free_state
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|result
operator|=
name|state_in_table
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Initialization of the abstract data.  */
end_comment

begin_function
specifier|static
name|void
name|initiate_states
parameter_list|()
block|{
name|decl_t
name|decl
decl_stmt|;
name|int
name|i
decl_stmt|;
name|VLA_PTR_CREATE
argument_list|(
name|units_container
argument_list|,
name|description
operator|->
name|units_num
argument_list|,
literal|"units_container"
argument_list|)
expr_stmt|;
name|units_array
operator|=
operator|(
name|description
operator|->
name|decls_num
operator|&&
name|description
operator|->
name|units_num
condition|?
name|VLA_PTR_BEGIN
argument_list|(
name|units_container
argument_list|)
else|:
name|NULL
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_unit
condition|)
name|units_array
index|[
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|unit_num
index|]
operator|=
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
name|max_cycles_num
operator|=
name|description
operator|->
name|max_insn_reserv_cycles
expr_stmt|;
name|els_in_cycle_reserv
operator|=
operator|(
operator|(
name|description
operator|->
name|units_num
operator|+
sizeof|sizeof
argument_list|(
name|set_el_t
argument_list|)
operator|*
name|CHAR_BIT
operator|-
literal|1
operator|)
operator|/
operator|(
sizeof|sizeof
argument_list|(
name|set_el_t
argument_list|)
operator|*
name|CHAR_BIT
operator|)
operator|)
expr_stmt|;
name|els_in_reservs
operator|=
name|els_in_cycle_reserv
operator|*
name|max_cycles_num
expr_stmt|;
name|curr_unique_state_num
operator|=
literal|0
expr_stmt|;
name|initiate_alt_states
argument_list|()
expr_stmt|;
name|VLA_PTR_CREATE
argument_list|(
name|free_states
argument_list|,
literal|1500
argument_list|,
literal|"free states"
argument_list|)
expr_stmt|;
name|state_table
operator|=
name|htab_create
argument_list|(
literal|1500
argument_list|,
name|state_hash
argument_list|,
name|state_eq_p
argument_list|,
operator|(
name|htab_del
operator|)
literal|0
argument_list|)
expr_stmt|;
name|empty_reserv
operator|=
name|alloc_empty_reserv_sets
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finisging work with the abstract data.  */
end_comment

begin_function
specifier|static
name|void
name|finish_states
parameter_list|()
block|{
name|VLA_PTR_DELETE
argument_list|(
name|units_container
argument_list|)
expr_stmt|;
name|htab_delete
argument_list|(
name|state_table
argument_list|)
expr_stmt|;
name|VLA_PTR_DELETE
argument_list|(
name|free_states
argument_list|)
expr_stmt|;
name|finish_alt_states
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Abstract data `arcs'.  */
end_comment

begin_comment
comment|/* List of free arcs.  */
end_comment

begin_decl_stmt
specifier|static
name|arc_t
name|first_free_arc
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|NDEBUG
end_ifndef

begin_comment
comment|/* The following variables is maximal number of allocated nodes    `arc'.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|allocated_arcs_num
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The function frees node ARC.  */
end_comment

begin_function
specifier|static
name|void
name|free_arc
parameter_list|(
name|arc
parameter_list|)
name|arc_t
name|arc
decl_stmt|;
block|{
name|arc
operator|->
name|next_out_arc
operator|=
name|first_free_arc
expr_stmt|;
name|first_free_arc
operator|=
name|arc
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function removes and frees ARC staring from FROM_STATE.  */
end_comment

begin_function
specifier|static
name|void
name|remove_arc
parameter_list|(
name|from_state
parameter_list|,
name|arc
parameter_list|)
name|state_t
name|from_state
decl_stmt|;
name|arc_t
name|arc
decl_stmt|;
block|{
name|arc_t
name|prev_arc
decl_stmt|;
name|arc_t
name|curr_arc
decl_stmt|;
if|if
condition|(
name|arc
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|prev_arc
operator|=
name|NULL
operator|,
name|curr_arc
operator|=
name|from_state
operator|->
name|first_out_arc
init|;
name|curr_arc
operator|!=
name|NULL
condition|;
name|prev_arc
operator|=
name|curr_arc
operator|,
name|curr_arc
operator|=
name|curr_arc
operator|->
name|next_out_arc
control|)
if|if
condition|(
name|curr_arc
operator|==
name|arc
condition|)
break|break;
if|if
condition|(
name|curr_arc
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|prev_arc
operator|==
name|NULL
condition|)
name|from_state
operator|->
name|first_out_arc
operator|=
name|arc
operator|->
name|next_out_arc
expr_stmt|;
else|else
name|prev_arc
operator|->
name|next_out_arc
operator|=
name|arc
operator|->
name|next_out_arc
expr_stmt|;
name|free_arc
argument_list|(
name|arc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The functions returns arc with given characteristics (or NULL if    the arc does not exist).  */
end_comment

begin_function
specifier|static
name|arc_t
name|find_arc
parameter_list|(
name|from_state
parameter_list|,
name|to_state
parameter_list|,
name|insn
parameter_list|)
name|state_t
name|from_state
decl_stmt|;
name|state_t
name|to_state
decl_stmt|;
name|ainsn_t
name|insn
decl_stmt|;
block|{
name|arc_t
name|arc
decl_stmt|;
for|for
control|(
name|arc
operator|=
name|first_out_arc
argument_list|(
name|from_state
argument_list|)
init|;
name|arc
operator|!=
name|NULL
condition|;
name|arc
operator|=
name|next_out_arc
argument_list|(
name|arc
argument_list|)
control|)
if|if
condition|(
name|arc
operator|->
name|to_state
operator|==
name|to_state
operator|&&
name|arc
operator|->
name|insn
operator|==
name|insn
condition|)
return|return
name|arc
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* The function adds arc from FROM_STATE to TO_STATE marked by AINSN    and with given STATE_ALTS.  The function returns added arc (or    already existing arc).  */
end_comment

begin_function
specifier|static
name|arc_t
name|add_arc
parameter_list|(
name|from_state
parameter_list|,
name|to_state
parameter_list|,
name|ainsn
parameter_list|,
name|state_alts
parameter_list|)
name|state_t
name|from_state
decl_stmt|;
name|state_t
name|to_state
decl_stmt|;
name|ainsn_t
name|ainsn
decl_stmt|;
name|int
name|state_alts
decl_stmt|;
block|{
name|arc_t
name|new_arc
decl_stmt|;
name|new_arc
operator|=
name|find_arc
argument_list|(
name|from_state
argument_list|,
name|to_state
argument_list|,
name|ainsn
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_arc
operator|!=
name|NULL
condition|)
return|return
name|new_arc
return|;
if|if
condition|(
name|first_free_arc
operator|==
name|NULL
condition|)
block|{
ifndef|#
directive|ifndef
name|NDEBUG
name|allocated_arcs_num
operator|++
expr_stmt|;
endif|#
directive|endif
name|new_arc
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|arc
argument_list|)
argument_list|)
expr_stmt|;
name|new_arc
operator|->
name|to_state
operator|=
name|NULL
expr_stmt|;
name|new_arc
operator|->
name|insn
operator|=
name|NULL
expr_stmt|;
name|new_arc
operator|->
name|next_out_arc
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|new_arc
operator|=
name|first_free_arc
expr_stmt|;
name|first_free_arc
operator|=
name|first_free_arc
operator|->
name|next_out_arc
expr_stmt|;
block|}
name|new_arc
operator|->
name|to_state
operator|=
name|to_state
expr_stmt|;
name|new_arc
operator|->
name|insn
operator|=
name|ainsn
expr_stmt|;
name|ainsn
operator|->
name|arc_exists_p
operator|=
literal|1
expr_stmt|;
name|new_arc
operator|->
name|next_out_arc
operator|=
name|from_state
operator|->
name|first_out_arc
expr_stmt|;
name|from_state
operator|->
name|first_out_arc
operator|=
name|new_arc
expr_stmt|;
name|new_arc
operator|->
name|next_arc_marked_by_insn
operator|=
name|NULL
expr_stmt|;
name|new_arc
operator|->
name|state_alts
operator|=
name|state_alts
expr_stmt|;
return|return
name|new_arc
return|;
block|}
end_function

begin_comment
comment|/* The function returns the first arc starting from STATE.  */
end_comment

begin_function
specifier|static
name|arc_t
name|first_out_arc
parameter_list|(
name|state
parameter_list|)
name|state_t
name|state
decl_stmt|;
block|{
return|return
name|state
operator|->
name|first_out_arc
return|;
block|}
end_function

begin_comment
comment|/* The function returns next out arc after ARC.  */
end_comment

begin_function
specifier|static
name|arc_t
name|next_out_arc
parameter_list|(
name|arc
parameter_list|)
name|arc_t
name|arc
decl_stmt|;
block|{
return|return
name|arc
operator|->
name|next_out_arc
return|;
block|}
end_function

begin_comment
comment|/* Initialization of the abstract data.  */
end_comment

begin_function
specifier|static
name|void
name|initiate_arcs
parameter_list|()
block|{
name|first_free_arc
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finishing work with the abstract data.  */
end_comment

begin_function
specifier|static
name|void
name|finish_arcs
parameter_list|()
block|{ }
end_function

begin_escape
end_escape

begin_comment
comment|/* Abstract data `automata lists'.  */
end_comment

begin_comment
comment|/* List of free states.  */
end_comment

begin_decl_stmt
specifier|static
name|automata_list_el_t
name|first_free_automata_list_el
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The list being formed.  */
end_comment

begin_decl_stmt
specifier|static
name|automata_list_el_t
name|current_automata_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Hash table of automata lists.  */
end_comment

begin_decl_stmt
specifier|static
name|htab_t
name|automata_list_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following function returns free automata list el.  It may be    new allocated node or node freed earlier.  */
end_comment

begin_function
specifier|static
name|automata_list_el_t
name|get_free_automata_list_el
parameter_list|()
block|{
name|automata_list_el_t
name|result
decl_stmt|;
if|if
condition|(
name|first_free_automata_list_el
operator|!=
name|NULL
condition|)
block|{
name|result
operator|=
name|first_free_automata_list_el
expr_stmt|;
name|first_free_automata_list_el
operator|=
name|first_free_automata_list_el
operator|->
name|next_automata_list_el
expr_stmt|;
block|}
else|else
name|result
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|automata_list_el
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|->
name|automaton
operator|=
name|NULL
expr_stmt|;
name|result
operator|->
name|next_automata_list_el
operator|=
name|NULL
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* The function frees node AUTOMATA_LIST_EL.  */
end_comment

begin_function
specifier|static
name|void
name|free_automata_list_el
parameter_list|(
name|automata_list_el
parameter_list|)
name|automata_list_el_t
name|automata_list_el
decl_stmt|;
block|{
if|if
condition|(
name|automata_list_el
operator|==
name|NULL
condition|)
return|return;
name|automata_list_el
operator|->
name|next_automata_list_el
operator|=
name|first_free_automata_list_el
expr_stmt|;
name|first_free_automata_list_el
operator|=
name|automata_list_el
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function frees list AUTOMATA_LIST.  */
end_comment

begin_function
specifier|static
name|void
name|free_automata_list
parameter_list|(
name|automata_list
parameter_list|)
name|automata_list_el_t
name|automata_list
decl_stmt|;
block|{
name|automata_list_el_t
name|curr_automata_list_el
decl_stmt|;
name|automata_list_el_t
name|next_automata_list_el
decl_stmt|;
for|for
control|(
name|curr_automata_list_el
operator|=
name|automata_list
init|;
name|curr_automata_list_el
operator|!=
name|NULL
condition|;
name|curr_automata_list_el
operator|=
name|next_automata_list_el
control|)
block|{
name|next_automata_list_el
operator|=
name|curr_automata_list_el
operator|->
name|next_automata_list_el
expr_stmt|;
name|free_automata_list_el
argument_list|(
name|curr_automata_list_el
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Hash value of AUTOMATA_LIST.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|automata_list_hash
parameter_list|(
name|automata_list
parameter_list|)
specifier|const
name|void
modifier|*
name|automata_list
decl_stmt|;
block|{
name|unsigned
name|int
name|hash_value
decl_stmt|;
name|automata_list_el_t
name|curr_automata_list_el
decl_stmt|;
name|hash_value
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|curr_automata_list_el
operator|=
operator|(
name|automata_list_el_t
operator|)
name|automata_list
init|;
name|curr_automata_list_el
operator|!=
name|NULL
condition|;
name|curr_automata_list_el
operator|=
name|curr_automata_list_el
operator|->
name|next_automata_list_el
control|)
name|hash_value
operator|=
operator|(
operator|(
operator|(
name|hash_value
operator|>>
operator|(
sizeof|sizeof
argument_list|(
name|unsigned
argument_list|)
operator|-
literal|1
operator|)
operator|*
name|CHAR_BIT
operator|)
operator||
operator|(
name|hash_value
operator|<<
name|CHAR_BIT
operator|)
operator|)
operator|+
name|curr_automata_list_el
operator|->
name|automaton
operator|->
name|automaton_order_num
operator|)
expr_stmt|;
return|return
name|hash_value
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero value if the automata_lists are the same.  */
end_comment

begin_function
specifier|static
name|int
name|automata_list_eq_p
parameter_list|(
name|automata_list_1
parameter_list|,
name|automata_list_2
parameter_list|)
specifier|const
name|void
modifier|*
name|automata_list_1
decl_stmt|;
specifier|const
name|void
modifier|*
name|automata_list_2
decl_stmt|;
block|{
name|automata_list_el_t
name|automata_list_el_1
decl_stmt|;
name|automata_list_el_t
name|automata_list_el_2
decl_stmt|;
for|for
control|(
name|automata_list_el_1
operator|=
operator|(
name|automata_list_el_t
operator|)
name|automata_list_1
operator|,
name|automata_list_el_2
operator|=
operator|(
name|automata_list_el_t
operator|)
name|automata_list_2
init|;
name|automata_list_el_1
operator|!=
name|NULL
operator|&&
name|automata_list_el_2
operator|!=
name|NULL
condition|;
name|automata_list_el_1
operator|=
name|automata_list_el_1
operator|->
name|next_automata_list_el
operator|,
name|automata_list_el_2
operator|=
name|automata_list_el_2
operator|->
name|next_automata_list_el
control|)
if|if
condition|(
name|automata_list_el_1
operator|->
name|automaton
operator|!=
name|automata_list_el_2
operator|->
name|automaton
condition|)
return|return
literal|0
return|;
return|return
name|automata_list_el_1
operator|==
name|automata_list_el_2
return|;
block|}
end_function

begin_comment
comment|/* Initialization of the abstract data.  */
end_comment

begin_function
specifier|static
name|void
name|initiate_automata_lists
parameter_list|()
block|{
name|first_free_automata_list_el
operator|=
name|NULL
expr_stmt|;
name|automata_list_table
operator|=
name|htab_create
argument_list|(
literal|1500
argument_list|,
name|automata_list_hash
argument_list|,
name|automata_list_eq_p
argument_list|,
operator|(
name|htab_del
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The following function starts new automata list and makes it the    current one.  */
end_comment

begin_function
specifier|static
name|void
name|automata_list_start
parameter_list|()
block|{
name|current_automata_list
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The following function adds AUTOMATON to the current list.  */
end_comment

begin_function
specifier|static
name|void
name|automata_list_add
parameter_list|(
name|automaton
parameter_list|)
name|automaton_t
name|automaton
decl_stmt|;
block|{
name|automata_list_el_t
name|el
decl_stmt|;
name|el
operator|=
name|get_free_automata_list_el
argument_list|()
expr_stmt|;
name|el
operator|->
name|automaton
operator|=
name|automaton
expr_stmt|;
name|el
operator|->
name|next_automata_list_el
operator|=
name|current_automata_list
expr_stmt|;
name|current_automata_list
operator|=
name|el
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The following function finishes forming the current list, inserts    it into the table and returns it.  */
end_comment

begin_function
specifier|static
name|automata_list_el_t
name|automata_list_finish
parameter_list|()
block|{
name|void
modifier|*
modifier|*
name|entry_ptr
decl_stmt|;
if|if
condition|(
name|current_automata_list
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|entry_ptr
operator|=
name|htab_find_slot
argument_list|(
name|automata_list_table
argument_list|,
operator|(
name|void
operator|*
operator|)
name|current_automata_list
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|entry_ptr
operator|==
name|NULL
condition|)
operator|*
name|entry_ptr
operator|=
operator|(
name|void
operator|*
operator|)
name|current_automata_list
expr_stmt|;
else|else
name|free_automata_list
argument_list|(
name|current_automata_list
argument_list|)
expr_stmt|;
name|current_automata_list
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|automata_list_el_t
operator|)
operator|*
name|entry_ptr
return|;
block|}
end_function

begin_comment
comment|/* Finishing work with the abstract data.  */
end_comment

begin_function
specifier|static
name|void
name|finish_automata_lists
parameter_list|()
block|{
name|htab_delete
argument_list|(
name|automata_list_table
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The page contains abstract data for work with exclusion sets (see    exclusion_set in file rtl.def).  */
end_comment

begin_comment
comment|/* The following variable refers to an exclusion set returned by    get_excl_set.  This is bit string of length equal to cpu units    number.  If exclusion set for given unit contains 1 for a unit,    then simultaneous reservation of the units is prohibited.  */
end_comment

begin_decl_stmt
specifier|static
name|reserv_sets_t
name|excl_set
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The array contains exclusion sets for each unit.  */
end_comment

begin_decl_stmt
specifier|static
name|reserv_sets_t
modifier|*
name|unit_excl_set_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following function forms the array containing exclusion sets    for each unit.  */
end_comment

begin_function
specifier|static
name|void
name|initiate_excl_sets
parameter_list|()
block|{
name|decl_t
name|decl
decl_stmt|;
name|reserv_sets_t
name|unit_excl_set
decl_stmt|;
name|unit_set_el_t
name|el
decl_stmt|;
name|int
name|i
decl_stmt|;
name|obstack_blank
argument_list|(
operator|&
name|irp
argument_list|,
name|els_in_cycle_reserv
operator|*
sizeof|sizeof
argument_list|(
name|set_el_t
argument_list|)
argument_list|)
expr_stmt|;
name|excl_set
operator|=
operator|(
name|reserv_sets_t
operator|)
name|obstack_base
argument_list|(
operator|&
name|irp
argument_list|)
expr_stmt|;
name|obstack_finish
argument_list|(
operator|&
name|irp
argument_list|)
expr_stmt|;
name|obstack_blank
argument_list|(
operator|&
name|irp
argument_list|,
name|description
operator|->
name|units_num
operator|*
sizeof|sizeof
argument_list|(
name|reserv_sets_t
argument_list|)
argument_list|)
expr_stmt|;
name|unit_excl_set_table
operator|=
operator|(
name|reserv_sets_t
operator|*
operator|)
name|obstack_base
argument_list|(
operator|&
name|irp
argument_list|)
expr_stmt|;
name|obstack_finish
argument_list|(
operator|&
name|irp
argument_list|)
expr_stmt|;
comment|/* Evaluate unit exclusion sets.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_unit
condition|)
block|{
name|obstack_blank
argument_list|(
operator|&
name|irp
argument_list|,
name|els_in_cycle_reserv
operator|*
sizeof|sizeof
argument_list|(
name|set_el_t
argument_list|)
argument_list|)
expr_stmt|;
name|unit_excl_set
operator|=
operator|(
name|reserv_sets_t
operator|)
name|obstack_base
argument_list|(
operator|&
name|irp
argument_list|)
expr_stmt|;
name|obstack_finish
argument_list|(
operator|&
name|irp
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|unit_excl_set
argument_list|,
literal|0
argument_list|,
name|els_in_cycle_reserv
operator|*
sizeof|sizeof
argument_list|(
name|set_el_t
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|el
operator|=
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|excl_list
init|;
name|el
operator|!=
name|NULL
condition|;
name|el
operator|=
name|el
operator|->
name|next_unit_set_el
control|)
name|SET_BIT
argument_list|(
name|unit_excl_set
argument_list|,
name|el
operator|->
name|unit_decl
operator|->
name|unit_num
argument_list|)
expr_stmt|;
name|unit_excl_set_table
index|[
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|unit_num
index|]
operator|=
name|unit_excl_set
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* The function sets up and return EXCL_SET which is union of    exclusion sets for each unit in IN_SET.  */
end_comment

begin_function
specifier|static
name|reserv_sets_t
name|get_excl_set
parameter_list|(
name|in_set
parameter_list|)
name|reserv_sets_t
name|in_set
decl_stmt|;
block|{
name|int
name|excl_char_num
decl_stmt|;
name|int
name|chars_num
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|start_unit_num
decl_stmt|;
name|int
name|unit_num
decl_stmt|;
name|chars_num
operator|=
name|els_in_cycle_reserv
operator|*
sizeof|sizeof
argument_list|(
name|set_el_t
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|excl_set
argument_list|,
literal|0
argument_list|,
name|chars_num
argument_list|)
expr_stmt|;
for|for
control|(
name|excl_char_num
operator|=
literal|0
init|;
name|excl_char_num
operator|<
name|chars_num
condition|;
name|excl_char_num
operator|++
control|)
if|if
condition|(
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|in_set
operator|)
index|[
name|excl_char_num
index|]
condition|)
for|for
control|(
name|i
operator|=
name|CHAR_BIT
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
operator|(
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|in_set
operator|)
index|[
name|excl_char_num
index|]
operator|>>
name|i
operator|)
operator|&
literal|1
condition|)
block|{
name|start_unit_num
operator|=
name|excl_char_num
operator|*
name|CHAR_BIT
operator|+
name|i
expr_stmt|;
if|if
condition|(
name|start_unit_num
operator|>=
name|description
operator|->
name|units_num
condition|)
return|return
name|excl_set
return|;
for|for
control|(
name|unit_num
operator|=
literal|0
init|;
name|unit_num
operator|<
name|els_in_cycle_reserv
condition|;
name|unit_num
operator|++
control|)
block|{
name|excl_set
index|[
name|unit_num
index|]
operator||=
name|unit_excl_set_table
index|[
name|start_unit_num
index|]
index|[
name|unit_num
index|]
expr_stmt|;
block|}
block|}
return|return
name|excl_set
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The page contains abstract data for work with presence/absence sets    (see presence_set/absence_set in file rtl.def).  */
end_comment

begin_comment
comment|/* The following variables refer to correspondingly a presence and an    absence set returned by get_presence_absence_set.  This is bit    string of length equal to cpu units number.  */
end_comment

begin_decl_stmt
specifier|static
name|reserv_sets_t
name|presence_set
decl_stmt|,
name|absence_set
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following arrays contain correspondingly presence and absence    sets for each unit.  */
end_comment

begin_decl_stmt
specifier|static
name|reserv_sets_t
modifier|*
name|unit_presence_set_table
decl_stmt|,
modifier|*
name|unit_absence_set_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following function forms the array containing presence and    absence sets for each unit */
end_comment

begin_function
specifier|static
name|void
name|initiate_presence_absence_sets
parameter_list|()
block|{
name|decl_t
name|decl
decl_stmt|;
name|reserv_sets_t
name|unit_set
decl_stmt|;
name|unit_set_el_t
name|el
decl_stmt|;
name|int
name|i
decl_stmt|;
name|obstack_blank
argument_list|(
operator|&
name|irp
argument_list|,
name|els_in_cycle_reserv
operator|*
sizeof|sizeof
argument_list|(
name|set_el_t
argument_list|)
argument_list|)
expr_stmt|;
name|presence_set
operator|=
operator|(
name|reserv_sets_t
operator|)
name|obstack_base
argument_list|(
operator|&
name|irp
argument_list|)
expr_stmt|;
name|obstack_finish
argument_list|(
operator|&
name|irp
argument_list|)
expr_stmt|;
name|obstack_blank
argument_list|(
operator|&
name|irp
argument_list|,
name|description
operator|->
name|units_num
operator|*
sizeof|sizeof
argument_list|(
name|reserv_sets_t
argument_list|)
argument_list|)
expr_stmt|;
name|unit_presence_set_table
operator|=
operator|(
name|reserv_sets_t
operator|*
operator|)
name|obstack_base
argument_list|(
operator|&
name|irp
argument_list|)
expr_stmt|;
name|obstack_finish
argument_list|(
operator|&
name|irp
argument_list|)
expr_stmt|;
name|obstack_blank
argument_list|(
operator|&
name|irp
argument_list|,
name|els_in_cycle_reserv
operator|*
sizeof|sizeof
argument_list|(
name|set_el_t
argument_list|)
argument_list|)
expr_stmt|;
name|absence_set
operator|=
operator|(
name|reserv_sets_t
operator|)
name|obstack_base
argument_list|(
operator|&
name|irp
argument_list|)
expr_stmt|;
name|obstack_finish
argument_list|(
operator|&
name|irp
argument_list|)
expr_stmt|;
name|obstack_blank
argument_list|(
operator|&
name|irp
argument_list|,
name|description
operator|->
name|units_num
operator|*
sizeof|sizeof
argument_list|(
name|reserv_sets_t
argument_list|)
argument_list|)
expr_stmt|;
name|unit_absence_set_table
operator|=
operator|(
name|reserv_sets_t
operator|*
operator|)
name|obstack_base
argument_list|(
operator|&
name|irp
argument_list|)
expr_stmt|;
name|obstack_finish
argument_list|(
operator|&
name|irp
argument_list|)
expr_stmt|;
comment|/* Evaluate unit presence/absence sets.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_unit
condition|)
block|{
name|obstack_blank
argument_list|(
operator|&
name|irp
argument_list|,
name|els_in_cycle_reserv
operator|*
sizeof|sizeof
argument_list|(
name|set_el_t
argument_list|)
argument_list|)
expr_stmt|;
name|unit_set
operator|=
operator|(
name|reserv_sets_t
operator|)
name|obstack_base
argument_list|(
operator|&
name|irp
argument_list|)
expr_stmt|;
name|obstack_finish
argument_list|(
operator|&
name|irp
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|unit_set
argument_list|,
literal|0
argument_list|,
name|els_in_cycle_reserv
operator|*
sizeof|sizeof
argument_list|(
name|set_el_t
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|el
operator|=
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|presence_list
init|;
name|el
operator|!=
name|NULL
condition|;
name|el
operator|=
name|el
operator|->
name|next_unit_set_el
control|)
name|SET_BIT
argument_list|(
name|unit_set
argument_list|,
name|el
operator|->
name|unit_decl
operator|->
name|unit_num
argument_list|)
expr_stmt|;
name|unit_presence_set_table
index|[
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|unit_num
index|]
operator|=
name|unit_set
expr_stmt|;
name|obstack_blank
argument_list|(
operator|&
name|irp
argument_list|,
name|els_in_cycle_reserv
operator|*
sizeof|sizeof
argument_list|(
name|set_el_t
argument_list|)
argument_list|)
expr_stmt|;
name|unit_set
operator|=
operator|(
name|reserv_sets_t
operator|)
name|obstack_base
argument_list|(
operator|&
name|irp
argument_list|)
expr_stmt|;
name|obstack_finish
argument_list|(
operator|&
name|irp
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|unit_set
argument_list|,
literal|0
argument_list|,
name|els_in_cycle_reserv
operator|*
sizeof|sizeof
argument_list|(
name|set_el_t
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|el
operator|=
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|absence_list
init|;
name|el
operator|!=
name|NULL
condition|;
name|el
operator|=
name|el
operator|->
name|next_unit_set_el
control|)
name|SET_BIT
argument_list|(
name|unit_set
argument_list|,
name|el
operator|->
name|unit_decl
operator|->
name|unit_num
argument_list|)
expr_stmt|;
name|unit_absence_set_table
index|[
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|unit_num
index|]
operator|=
name|unit_set
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* The function sets up and return PRESENCE_SET (if PRESENCE_P) or    ABSENCE_SET which is union of corresponding sets for each unit in    IN_SET.  */
end_comment

begin_function
specifier|static
name|reserv_sets_t
name|get_presence_absence_set
parameter_list|(
name|in_set
parameter_list|,
name|presence_p
parameter_list|)
name|reserv_sets_t
name|in_set
decl_stmt|;
name|int
name|presence_p
decl_stmt|;
block|{
name|int
name|char_num
decl_stmt|;
name|int
name|chars_num
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|start_unit_num
decl_stmt|;
name|int
name|unit_num
decl_stmt|;
name|chars_num
operator|=
name|els_in_cycle_reserv
operator|*
sizeof|sizeof
argument_list|(
name|set_el_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|presence_p
condition|)
name|memset
argument_list|(
name|presence_set
argument_list|,
literal|0
argument_list|,
name|chars_num
argument_list|)
expr_stmt|;
else|else
name|memset
argument_list|(
name|absence_set
argument_list|,
literal|0
argument_list|,
name|chars_num
argument_list|)
expr_stmt|;
for|for
control|(
name|char_num
operator|=
literal|0
init|;
name|char_num
operator|<
name|chars_num
condition|;
name|char_num
operator|++
control|)
if|if
condition|(
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|in_set
operator|)
index|[
name|char_num
index|]
condition|)
for|for
control|(
name|i
operator|=
name|CHAR_BIT
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
operator|(
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|in_set
operator|)
index|[
name|char_num
index|]
operator|>>
name|i
operator|)
operator|&
literal|1
condition|)
block|{
name|start_unit_num
operator|=
name|char_num
operator|*
name|CHAR_BIT
operator|+
name|i
expr_stmt|;
if|if
condition|(
name|start_unit_num
operator|>=
name|description
operator|->
name|units_num
condition|)
return|return
operator|(
name|presence_p
condition|?
name|presence_set
else|:
name|absence_set
operator|)
return|;
for|for
control|(
name|unit_num
operator|=
literal|0
init|;
name|unit_num
operator|<
name|els_in_cycle_reserv
condition|;
name|unit_num
operator|++
control|)
if|if
condition|(
name|presence_p
condition|)
name|presence_set
index|[
name|unit_num
index|]
operator||=
name|unit_presence_set_table
index|[
name|start_unit_num
index|]
index|[
name|unit_num
index|]
expr_stmt|;
else|else
name|absence_set
index|[
name|unit_num
index|]
operator||=
name|unit_absence_set_table
index|[
name|start_unit_num
index|]
index|[
name|unit_num
index|]
expr_stmt|;
block|}
return|return
operator|(
name|presence_p
condition|?
name|presence_set
else|:
name|absence_set
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This page contains code for transformation of original reservations    described in .md file.  The main goal of transformations is    simplifying reservation and lifting up all `|' on the top of IR    reservation representation.  */
end_comment

begin_comment
comment|/* The following function makes copy of IR representation of    reservation.  The function also substitutes all reservations    defined by define_reservation by corresponding value during making    the copy.  */
end_comment

begin_function
specifier|static
name|regexp_t
name|copy_insn_regexp
parameter_list|(
name|regexp
parameter_list|)
name|regexp_t
name|regexp
decl_stmt|;
block|{
name|regexp_t
name|result
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|regexp
operator|->
name|mode
operator|==
name|rm_reserv
condition|)
name|result
operator|=
name|copy_insn_regexp
argument_list|(
name|REGEXP_RESERV
argument_list|(
name|regexp
argument_list|)
operator|->
name|reserv_decl
operator|->
name|regexp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|regexp
operator|->
name|mode
operator|==
name|rm_unit
condition|)
name|result
operator|=
name|copy_node
argument_list|(
name|regexp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|regexp
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|regexp
operator|->
name|mode
operator|==
name|rm_repeat
condition|)
block|{
name|result
operator|=
name|copy_node
argument_list|(
name|regexp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|regexp
argument_list|)
argument_list|)
expr_stmt|;
name|REGEXP_REPEAT
argument_list|(
name|result
argument_list|)
operator|->
name|regexp
operator|=
name|copy_insn_regexp
argument_list|(
name|REGEXP_REPEAT
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regexp
operator|->
name|mode
operator|==
name|rm_sequence
condition|)
block|{
name|result
operator|=
name|copy_node
argument_list|(
name|regexp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|regexp
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|regexp_t
argument_list|)
operator|*
operator|(
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|;
name|i
operator|++
control|)
name|REGEXP_SEQUENCE
argument_list|(
name|result
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
operator|=
name|copy_insn_regexp
argument_list|(
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regexp
operator|->
name|mode
operator|==
name|rm_allof
condition|)
block|{
name|result
operator|=
name|copy_node
argument_list|(
name|regexp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|regexp
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|regexp_t
argument_list|)
operator|*
operator|(
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|;
name|i
operator|++
control|)
name|REGEXP_ALLOF
argument_list|(
name|result
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
operator|=
name|copy_insn_regexp
argument_list|(
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regexp
operator|->
name|mode
operator|==
name|rm_oneof
condition|)
block|{
name|result
operator|=
name|copy_node
argument_list|(
name|regexp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|regexp
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|regexp_t
argument_list|)
operator|*
operator|(
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|;
name|i
operator|++
control|)
name|REGEXP_ONEOF
argument_list|(
name|result
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
operator|=
name|copy_insn_regexp
argument_list|(
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|regexp
operator|->
name|mode
operator|!=
name|rm_nothing
condition|)
name|abort
argument_list|()
expr_stmt|;
name|result
operator|=
name|copy_node
argument_list|(
name|regexp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|regexp
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* The following variable is set up 1 if a transformation has been    applied.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|regexp_transformed_p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The function makes transformation    A*N -> A, A, ...  */
end_comment

begin_function
specifier|static
name|regexp_t
name|transform_1
parameter_list|(
name|regexp
parameter_list|)
name|regexp_t
name|regexp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|repeat_num
decl_stmt|;
name|regexp_t
name|operand
decl_stmt|;
name|pos_t
name|pos
decl_stmt|;
if|if
condition|(
name|regexp
operator|->
name|mode
operator|==
name|rm_repeat
condition|)
block|{
name|repeat_num
operator|=
name|REGEXP_REPEAT
argument_list|(
name|regexp
argument_list|)
operator|->
name|repeat_num
expr_stmt|;
if|if
condition|(
name|repeat_num
operator|<=
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
name|operand
operator|=
name|REGEXP_REPEAT
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexp
expr_stmt|;
name|pos
operator|=
name|regexp
operator|->
name|mode
expr_stmt|;
name|regexp
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|regexp
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|regexp_t
argument_list|)
operator|*
operator|(
name|repeat_num
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|regexp
operator|->
name|mode
operator|=
name|rm_sequence
expr_stmt|;
name|regexp
operator|->
name|pos
operator|=
name|pos
expr_stmt|;
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
operator|=
name|repeat_num
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|repeat_num
condition|;
name|i
operator|++
control|)
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
operator|=
name|copy_insn_regexp
argument_list|(
name|operand
argument_list|)
expr_stmt|;
name|regexp_transformed_p
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|regexp
return|;
block|}
end_function

begin_comment
comment|/* The function makes transformations    ...,(A,B,...),C,... -> ...,A,B,...,C,...    ...+(A+B+...)+C+... -> ...+A+B+...+C+...    ...|(A|B|...)|C|... -> ...|A|B|...|C|...  */
end_comment

begin_function
specifier|static
name|regexp_t
name|transform_2
parameter_list|(
name|regexp
parameter_list|)
name|regexp_t
name|regexp
decl_stmt|;
block|{
if|if
condition|(
name|regexp
operator|->
name|mode
operator|==
name|rm_sequence
condition|)
block|{
name|regexp_t
name|sequence
init|=
name|NULL
decl_stmt|;
name|regexp_t
name|result
decl_stmt|;
name|int
name|sequence_index
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
operator|->
name|mode
operator|==
name|rm_sequence
condition|)
block|{
name|sequence_index
operator|=
name|i
expr_stmt|;
name|sequence
operator|=
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|<
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|)
block|{
if|if
condition|(
name|REGEXP_SEQUENCE
argument_list|(
name|sequence
argument_list|)
operator|->
name|regexps_num
operator|<=
literal|1
operator|||
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
operator|<=
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
name|result
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|regexp
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|regexp_t
argument_list|)
operator|*
operator|(
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
operator|+
name|REGEXP_SEQUENCE
argument_list|(
name|sequence
argument_list|)
operator|->
name|regexps_num
operator|-
literal|2
operator|)
argument_list|)
expr_stmt|;
name|result
operator|->
name|mode
operator|=
name|rm_sequence
expr_stmt|;
name|result
operator|->
name|pos
operator|=
name|regexp
operator|->
name|pos
expr_stmt|;
name|REGEXP_SEQUENCE
argument_list|(
name|result
argument_list|)
operator|->
name|regexps_num
operator|=
operator|(
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
operator|+
name|REGEXP_SEQUENCE
argument_list|(
name|sequence
argument_list|)
operator|->
name|regexps_num
operator|-
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|i
operator|<
name|sequence_index
condition|)
name|REGEXP_SEQUENCE
argument_list|(
name|result
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
operator|=
name|copy_insn_regexp
argument_list|(
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|>
name|sequence_index
condition|)
name|REGEXP_SEQUENCE
argument_list|(
name|result
argument_list|)
operator|->
name|regexps
index|[
name|i
operator|+
name|REGEXP_SEQUENCE
argument_list|(
name|sequence
argument_list|)
operator|->
name|regexps_num
operator|-
literal|1
index|]
operator|=
name|copy_insn_regexp
argument_list|(
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|REGEXP_SEQUENCE
argument_list|(
name|sequence
argument_list|)
operator|->
name|regexps_num
condition|;
name|j
operator|++
control|)
name|REGEXP_SEQUENCE
argument_list|(
name|result
argument_list|)
operator|->
name|regexps
index|[
name|i
operator|+
name|j
index|]
operator|=
name|copy_insn_regexp
argument_list|(
name|REGEXP_SEQUENCE
argument_list|(
name|sequence
argument_list|)
operator|->
name|regexps
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|regexp_transformed_p
operator|=
literal|1
expr_stmt|;
name|regexp
operator|=
name|result
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|regexp
operator|->
name|mode
operator|==
name|rm_allof
condition|)
block|{
name|regexp_t
name|allof
init|=
name|NULL
decl_stmt|;
name|regexp_t
name|result
decl_stmt|;
name|int
name|allof_index
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
operator|->
name|mode
operator|==
name|rm_allof
condition|)
block|{
name|allof_index
operator|=
name|i
expr_stmt|;
name|allof
operator|=
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|<
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|)
block|{
if|if
condition|(
name|REGEXP_ALLOF
argument_list|(
name|allof
argument_list|)
operator|->
name|regexps_num
operator|<=
literal|1
operator|||
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
operator|<=
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
name|result
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|regexp
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|regexp_t
argument_list|)
operator|*
operator|(
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
operator|+
name|REGEXP_ALLOF
argument_list|(
name|allof
argument_list|)
operator|->
name|regexps_num
operator|-
literal|2
operator|)
argument_list|)
expr_stmt|;
name|result
operator|->
name|mode
operator|=
name|rm_allof
expr_stmt|;
name|result
operator|->
name|pos
operator|=
name|regexp
operator|->
name|pos
expr_stmt|;
name|REGEXP_ALLOF
argument_list|(
name|result
argument_list|)
operator|->
name|regexps_num
operator|=
operator|(
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
operator|+
name|REGEXP_ALLOF
argument_list|(
name|allof
argument_list|)
operator|->
name|regexps_num
operator|-
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|i
operator|<
name|allof_index
condition|)
name|REGEXP_ALLOF
argument_list|(
name|result
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
operator|=
name|copy_insn_regexp
argument_list|(
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|>
name|allof_index
condition|)
name|REGEXP_ALLOF
argument_list|(
name|result
argument_list|)
operator|->
name|regexps
index|[
name|i
operator|+
name|REGEXP_ALLOF
argument_list|(
name|allof
argument_list|)
operator|->
name|regexps_num
operator|-
literal|1
index|]
operator|=
name|copy_insn_regexp
argument_list|(
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|REGEXP_ALLOF
argument_list|(
name|allof
argument_list|)
operator|->
name|regexps_num
condition|;
name|j
operator|++
control|)
name|REGEXP_ALLOF
argument_list|(
name|result
argument_list|)
operator|->
name|regexps
index|[
name|i
operator|+
name|j
index|]
operator|=
name|copy_insn_regexp
argument_list|(
name|REGEXP_ALLOF
argument_list|(
name|allof
argument_list|)
operator|->
name|regexps
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|regexp_transformed_p
operator|=
literal|1
expr_stmt|;
name|regexp
operator|=
name|result
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|regexp
operator|->
name|mode
operator|==
name|rm_oneof
condition|)
block|{
name|regexp_t
name|oneof
init|=
name|NULL
decl_stmt|;
name|regexp_t
name|result
decl_stmt|;
name|int
name|oneof_index
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
operator|->
name|mode
operator|==
name|rm_oneof
condition|)
block|{
name|oneof_index
operator|=
name|i
expr_stmt|;
name|oneof
operator|=
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|<
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|)
block|{
if|if
condition|(
name|REGEXP_ONEOF
argument_list|(
name|oneof
argument_list|)
operator|->
name|regexps_num
operator|<=
literal|1
operator|||
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
operator|<=
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
name|result
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|regexp
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|regexp_t
argument_list|)
operator|*
operator|(
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
operator|+
name|REGEXP_ONEOF
argument_list|(
name|oneof
argument_list|)
operator|->
name|regexps_num
operator|-
literal|2
operator|)
argument_list|)
expr_stmt|;
name|result
operator|->
name|mode
operator|=
name|rm_oneof
expr_stmt|;
name|result
operator|->
name|pos
operator|=
name|regexp
operator|->
name|pos
expr_stmt|;
name|REGEXP_ONEOF
argument_list|(
name|result
argument_list|)
operator|->
name|regexps_num
operator|=
operator|(
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
operator|+
name|REGEXP_ONEOF
argument_list|(
name|oneof
argument_list|)
operator|->
name|regexps_num
operator|-
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|i
operator|<
name|oneof_index
condition|)
name|REGEXP_ONEOF
argument_list|(
name|result
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
operator|=
name|copy_insn_regexp
argument_list|(
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|>
name|oneof_index
condition|)
name|REGEXP_ONEOF
argument_list|(
name|result
argument_list|)
operator|->
name|regexps
index|[
name|i
operator|+
name|REGEXP_ONEOF
argument_list|(
name|oneof
argument_list|)
operator|->
name|regexps_num
operator|-
literal|1
index|]
operator|=
name|copy_insn_regexp
argument_list|(
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|REGEXP_ONEOF
argument_list|(
name|oneof
argument_list|)
operator|->
name|regexps_num
condition|;
name|j
operator|++
control|)
name|REGEXP_ONEOF
argument_list|(
name|result
argument_list|)
operator|->
name|regexps
index|[
name|i
operator|+
name|j
index|]
operator|=
name|copy_insn_regexp
argument_list|(
name|REGEXP_ONEOF
argument_list|(
name|oneof
argument_list|)
operator|->
name|regexps
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|regexp_transformed_p
operator|=
literal|1
expr_stmt|;
name|regexp
operator|=
name|result
expr_stmt|;
block|}
block|}
return|return
name|regexp
return|;
block|}
end_function

begin_comment
comment|/* The function makes transformations    ...,A|B|...,C,... -> (...,A,C,...)|(...,B,C,...)|...    ...+(A|B|...)+C+... -> (...+A+C+...)|(...+B+C+...)|...    ...+(A,B,...)+C+... -> (...+A+C+...),B,...    ...+(A,B,...)+(C,D,...) -> (A+C),(B+D),...  */
end_comment

begin_function
specifier|static
name|regexp_t
name|transform_3
parameter_list|(
name|regexp
parameter_list|)
name|regexp_t
name|regexp
decl_stmt|;
block|{
if|if
condition|(
name|regexp
operator|->
name|mode
operator|==
name|rm_sequence
condition|)
block|{
name|regexp_t
name|oneof
init|=
name|NULL
decl_stmt|;
name|int
name|oneof_index
init|=
literal|0
decl_stmt|;
name|regexp_t
name|result
decl_stmt|;
name|regexp_t
name|sequence
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
operator|->
name|mode
operator|==
name|rm_oneof
condition|)
block|{
name|oneof_index
operator|=
name|i
expr_stmt|;
name|oneof
operator|=
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|<
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|)
block|{
if|if
condition|(
name|REGEXP_ONEOF
argument_list|(
name|oneof
argument_list|)
operator|->
name|regexps_num
operator|<=
literal|1
operator|||
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
operator|<=
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
name|result
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|regexp
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|regexp_t
argument_list|)
operator|*
operator|(
name|REGEXP_ONEOF
argument_list|(
name|oneof
argument_list|)
operator|->
name|regexps_num
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|result
operator|->
name|mode
operator|=
name|rm_oneof
expr_stmt|;
name|result
operator|->
name|pos
operator|=
name|regexp
operator|->
name|pos
expr_stmt|;
name|REGEXP_ONEOF
argument_list|(
name|result
argument_list|)
operator|->
name|regexps_num
operator|=
name|REGEXP_ONEOF
argument_list|(
name|oneof
argument_list|)
operator|->
name|regexps_num
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGEXP_ONEOF
argument_list|(
name|result
argument_list|)
operator|->
name|regexps_num
condition|;
name|i
operator|++
control|)
block|{
name|sequence
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|regexp
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|regexp_t
argument_list|)
operator|*
operator|(
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|sequence
operator|->
name|mode
operator|=
name|rm_sequence
expr_stmt|;
name|sequence
operator|->
name|pos
operator|=
name|regexp
operator|->
name|pos
expr_stmt|;
name|REGEXP_SEQUENCE
argument_list|(
name|sequence
argument_list|)
operator|->
name|regexps_num
operator|=
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
expr_stmt|;
name|REGEXP_ONEOF
argument_list|(
name|result
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
operator|=
name|sequence
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|REGEXP_SEQUENCE
argument_list|(
name|sequence
argument_list|)
operator|->
name|regexps_num
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|j
operator|!=
name|oneof_index
condition|)
name|REGEXP_SEQUENCE
argument_list|(
name|sequence
argument_list|)
operator|->
name|regexps
index|[
name|j
index|]
operator|=
name|copy_insn_regexp
argument_list|(
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|j
index|]
argument_list|)
expr_stmt|;
else|else
name|REGEXP_SEQUENCE
argument_list|(
name|sequence
argument_list|)
operator|->
name|regexps
index|[
name|j
index|]
operator|=
name|copy_insn_regexp
argument_list|(
name|REGEXP_ONEOF
argument_list|(
name|oneof
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|regexp_transformed_p
operator|=
literal|1
expr_stmt|;
name|regexp
operator|=
name|result
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|regexp
operator|->
name|mode
operator|==
name|rm_allof
condition|)
block|{
name|regexp_t
name|oneof
init|=
name|NULL
decl_stmt|,
name|seq
decl_stmt|;
name|int
name|oneof_index
init|=
literal|0
decl_stmt|,
name|max_seq_length
decl_stmt|,
name|allof_length
decl_stmt|;
name|regexp_t
name|result
decl_stmt|;
name|regexp_t
name|allof
init|=
name|NULL
decl_stmt|,
name|allof_op
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
operator|->
name|mode
operator|==
name|rm_oneof
condition|)
block|{
name|oneof_index
operator|=
name|i
expr_stmt|;
name|oneof
operator|=
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|<
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|)
block|{
if|if
condition|(
name|REGEXP_ONEOF
argument_list|(
name|oneof
argument_list|)
operator|->
name|regexps_num
operator|<=
literal|1
operator|||
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
operator|<=
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
name|result
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|regexp
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|regexp_t
argument_list|)
operator|*
operator|(
name|REGEXP_ONEOF
argument_list|(
name|oneof
argument_list|)
operator|->
name|regexps_num
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|result
operator|->
name|mode
operator|=
name|rm_oneof
expr_stmt|;
name|result
operator|->
name|pos
operator|=
name|regexp
operator|->
name|pos
expr_stmt|;
name|REGEXP_ONEOF
argument_list|(
name|result
argument_list|)
operator|->
name|regexps_num
operator|=
name|REGEXP_ONEOF
argument_list|(
name|oneof
argument_list|)
operator|->
name|regexps_num
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGEXP_ONEOF
argument_list|(
name|result
argument_list|)
operator|->
name|regexps_num
condition|;
name|i
operator|++
control|)
block|{
name|allof
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|regexp
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|regexp_t
argument_list|)
operator|*
operator|(
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|allof
operator|->
name|mode
operator|=
name|rm_allof
expr_stmt|;
name|allof
operator|->
name|pos
operator|=
name|regexp
operator|->
name|pos
expr_stmt|;
name|REGEXP_ALLOF
argument_list|(
name|allof
argument_list|)
operator|->
name|regexps_num
operator|=
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
expr_stmt|;
name|REGEXP_ONEOF
argument_list|(
name|result
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
operator|=
name|allof
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|REGEXP_ALLOF
argument_list|(
name|allof
argument_list|)
operator|->
name|regexps_num
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|j
operator|!=
name|oneof_index
condition|)
name|REGEXP_ALLOF
argument_list|(
name|allof
argument_list|)
operator|->
name|regexps
index|[
name|j
index|]
operator|=
name|copy_insn_regexp
argument_list|(
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|j
index|]
argument_list|)
expr_stmt|;
else|else
name|REGEXP_ALLOF
argument_list|(
name|allof
argument_list|)
operator|->
name|regexps
index|[
name|j
index|]
operator|=
name|copy_insn_regexp
argument_list|(
name|REGEXP_ONEOF
argument_list|(
name|oneof
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|regexp_transformed_p
operator|=
literal|1
expr_stmt|;
name|regexp
operator|=
name|result
expr_stmt|;
block|}
name|max_seq_length
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|regexp
operator|->
name|mode
operator|==
name|rm_allof
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
operator|->
name|mode
operator|==
name|rm_sequence
condition|)
block|{
name|seq
operator|=
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|max_seq_length
operator|<
name|REGEXP_SEQUENCE
argument_list|(
name|seq
argument_list|)
operator|->
name|regexps_num
condition|)
name|max_seq_length
operator|=
name|REGEXP_SEQUENCE
argument_list|(
name|seq
argument_list|)
operator|->
name|regexps_num
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
operator|->
name|mode
operator|!=
name|rm_unit
condition|)
block|{
name|max_seq_length
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|max_seq_length
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|max_seq_length
operator|==
literal|1
operator|||
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
operator|<=
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
name|result
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|regexp
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|regexp_t
argument_list|)
operator|*
operator|(
name|max_seq_length
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|result
operator|->
name|mode
operator|=
name|rm_sequence
expr_stmt|;
name|result
operator|->
name|pos
operator|=
name|regexp
operator|->
name|pos
expr_stmt|;
name|REGEXP_SEQUENCE
argument_list|(
name|result
argument_list|)
operator|->
name|regexps_num
operator|=
name|max_seq_length
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_seq_length
condition|;
name|i
operator|++
control|)
block|{
name|allof_length
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|j
index|]
operator|->
name|mode
operator|==
name|rm_sequence
operator|&&
operator|(
name|i
operator|<
operator|(
name|REGEXP_SEQUENCE
argument_list|(
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|j
index|]
argument_list|)
operator|->
name|regexps_num
operator|)
operator|)
condition|)
block|{
name|allof_op
operator|=
operator|(
name|REGEXP_SEQUENCE
argument_list|(
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|j
index|]
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
operator|)
expr_stmt|;
name|allof_length
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
operator|(
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|j
index|]
operator|->
name|mode
operator|==
name|rm_unit
operator|)
condition|)
block|{
name|allof_op
operator|=
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|j
index|]
expr_stmt|;
name|allof_length
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|allof_length
operator|==
literal|1
condition|)
name|REGEXP_SEQUENCE
argument_list|(
name|result
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
operator|=
name|allof_op
expr_stmt|;
else|else
block|{
name|allof
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|regexp
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|regexp_t
argument_list|)
operator|*
operator|(
name|allof_length
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|allof
operator|->
name|mode
operator|=
name|rm_allof
expr_stmt|;
name|allof
operator|->
name|pos
operator|=
name|regexp
operator|->
name|pos
expr_stmt|;
name|REGEXP_ALLOF
argument_list|(
name|allof
argument_list|)
operator|->
name|regexps_num
operator|=
name|allof_length
expr_stmt|;
name|REGEXP_SEQUENCE
argument_list|(
name|result
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
operator|=
name|allof
expr_stmt|;
name|allof_length
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|j
index|]
operator|->
name|mode
operator|==
name|rm_sequence
operator|&&
operator|(
name|i
operator|<
operator|(
name|REGEXP_SEQUENCE
argument_list|(
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|j
index|]
argument_list|)
operator|->
name|regexps_num
operator|)
operator|)
condition|)
block|{
name|allof_op
operator|=
operator|(
name|REGEXP_SEQUENCE
argument_list|(
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|j
index|]
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
operator|)
expr_stmt|;
name|REGEXP_ALLOF
argument_list|(
name|allof
argument_list|)
operator|->
name|regexps
index|[
name|allof_length
index|]
operator|=
name|allof_op
expr_stmt|;
name|allof_length
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
operator|(
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|j
index|]
operator|->
name|mode
operator|==
name|rm_unit
operator|)
condition|)
block|{
name|allof_op
operator|=
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|j
index|]
expr_stmt|;
name|REGEXP_ALLOF
argument_list|(
name|allof
argument_list|)
operator|->
name|regexps
index|[
name|allof_length
index|]
operator|=
name|allof_op
expr_stmt|;
name|allof_length
operator|++
expr_stmt|;
block|}
block|}
block|}
name|regexp_transformed_p
operator|=
literal|1
expr_stmt|;
name|regexp
operator|=
name|result
expr_stmt|;
block|}
block|}
return|return
name|regexp
return|;
block|}
end_function

begin_comment
comment|/* The function traverses IR of reservation and applies transformations    implemented by FUNC.  */
end_comment

begin_function_decl
specifier|static
name|regexp_t
name|regexp_transform_func
parameter_list|(
name|regexp
parameter_list|,
name|func
parameter_list|)
name|regexp_t
name|regexp
decl_stmt|;
function_decl|regexp_t
parameter_list|(
function_decl|*func
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|regexp_t
name|regexp
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|regexp
operator|->
name|mode
operator|==
name|rm_sequence
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|;
name|i
operator|++
control|)
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
operator|=
name|regexp_transform_func
argument_list|(
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
argument_list|,
name|func
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|regexp
operator|->
name|mode
operator|==
name|rm_allof
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|;
name|i
operator|++
control|)
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
operator|=
name|regexp_transform_func
argument_list|(
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
argument_list|,
name|func
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|regexp
operator|->
name|mode
operator|==
name|rm_oneof
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|;
name|i
operator|++
control|)
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
operator|=
name|regexp_transform_func
argument_list|(
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
argument_list|,
name|func
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|regexp
operator|->
name|mode
operator|==
name|rm_repeat
condition|)
name|REGEXP_REPEAT
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexp
operator|=
name|regexp_transform_func
argument_list|(
name|REGEXP_REPEAT
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexp
argument_list|,
name|func
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|regexp
operator|->
name|mode
operator|!=
name|rm_nothing
operator|&&
name|regexp
operator|->
name|mode
operator|!=
name|rm_unit
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
call|(
modifier|*
name|func
call|)
argument_list|(
name|regexp
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/* The function applies all transformations for IR representation of    reservation REGEXP.  */
end_comment

begin_function
specifier|static
name|regexp_t
name|transform_regexp
parameter_list|(
name|regexp
parameter_list|)
name|regexp_t
name|regexp
decl_stmt|;
block|{
name|regexp
operator|=
name|regexp_transform_func
argument_list|(
name|regexp
argument_list|,
name|transform_1
argument_list|)
expr_stmt|;
do|do
block|{
name|regexp_transformed_p
operator|=
literal|0
expr_stmt|;
name|regexp
operator|=
name|regexp_transform_func
argument_list|(
name|regexp
argument_list|,
name|transform_2
argument_list|)
expr_stmt|;
name|regexp
operator|=
name|regexp_transform_func
argument_list|(
name|regexp
argument_list|,
name|transform_3
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|regexp_transformed_p
condition|)
do|;
return|return
name|regexp
return|;
block|}
end_function

begin_comment
comment|/* The function applys all transformations for reservations of all    insn declarations.  */
end_comment

begin_function
specifier|static
name|void
name|transform_insn_regexps
parameter_list|()
block|{
name|decl_t
name|decl
decl_stmt|;
name|int
name|i
decl_stmt|;
name|transform_time
operator|=
name|create_ticker
argument_list|()
expr_stmt|;
name|add_advance_cycle_insn_decl
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Reservation transformation..."
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_insn_reserv
operator|&&
name|decl
operator|!=
name|advance_cycle_insn_decl
condition|)
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|transformed_regexp
operator|=
name|transform_regexp
argument_list|(
name|copy_insn_regexp
argument_list|(
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|regexp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"done\n"
argument_list|)
expr_stmt|;
name|ticker_off
argument_list|(
operator|&
name|transform_time
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The following variable is an array indexed by cycle.  Each element    contains cyclic list of units which should be in the same cycle.  */
end_comment

begin_decl_stmt
specifier|static
name|unit_decl_t
modifier|*
name|the_same_automaton_lists
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The function processes all alternative reservations on CYCLE in    given REGEXP to check the UNIT is not reserved on the all    alternatives.  If it is true, the unit should be in the same    automaton with other analogous units reserved on CYCLE in given    REGEXP.  */
end_comment

begin_function
specifier|static
name|void
name|process_unit_to_form_the_same_automaton_unit_lists
parameter_list|(
name|unit
parameter_list|,
name|regexp
parameter_list|,
name|cycle
parameter_list|)
name|regexp_t
name|unit
decl_stmt|;
name|regexp_t
name|regexp
decl_stmt|;
name|int
name|cycle
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|k
decl_stmt|;
name|regexp_t
name|seq
decl_stmt|,
name|allof
decl_stmt|;
name|unit_decl_t
name|unit_decl
decl_stmt|,
name|last
decl_stmt|;
if|if
condition|(
name|regexp
operator|==
name|NULL
operator|||
name|regexp
operator|->
name|mode
operator|!=
name|rm_oneof
condition|)
name|abort
argument_list|()
expr_stmt|;
name|unit_decl
operator|=
name|REGEXP_UNIT
argument_list|(
name|unit
argument_list|)
operator|->
name|unit_decl
expr_stmt|;
for|for
control|(
name|i
operator|=
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|seq
operator|=
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|seq
operator|->
name|mode
operator|==
name|rm_sequence
condition|)
block|{
if|if
condition|(
name|cycle
operator|>=
name|REGEXP_SEQUENCE
argument_list|(
name|seq
argument_list|)
operator|->
name|regexps_num
condition|)
break|break;
name|allof
operator|=
name|REGEXP_SEQUENCE
argument_list|(
name|seq
argument_list|)
operator|->
name|regexps
index|[
name|cycle
index|]
expr_stmt|;
if|if
condition|(
name|allof
operator|->
name|mode
operator|==
name|rm_allof
condition|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|REGEXP_ALLOF
argument_list|(
name|allof
argument_list|)
operator|->
name|regexps_num
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|REGEXP_ALLOF
argument_list|(
name|allof
argument_list|)
operator|->
name|regexps
index|[
name|k
index|]
operator|->
name|mode
operator|==
name|rm_unit
operator|&&
operator|(
name|REGEXP_UNIT
argument_list|(
name|REGEXP_ALLOF
argument_list|(
name|allof
argument_list|)
operator|->
name|regexps
index|[
name|k
index|]
argument_list|)
operator|->
name|unit_decl
operator|==
name|unit_decl
operator|)
condition|)
break|break;
if|if
condition|(
name|k
operator|>=
name|REGEXP_ALLOF
argument_list|(
name|allof
argument_list|)
operator|->
name|regexps_num
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|allof
operator|->
name|mode
operator|==
name|rm_unit
operator|&&
name|REGEXP_UNIT
argument_list|(
name|allof
argument_list|)
operator|->
name|unit_decl
operator|!=
name|unit_decl
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|cycle
operator|!=
literal|0
condition|)
break|break;
elseif|else
if|if
condition|(
name|seq
operator|->
name|mode
operator|==
name|rm_allof
condition|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|REGEXP_ALLOF
argument_list|(
name|seq
argument_list|)
operator|->
name|regexps_num
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|REGEXP_ALLOF
argument_list|(
name|seq
argument_list|)
operator|->
name|regexps
index|[
name|k
index|]
operator|->
name|mode
operator|==
name|rm_unit
operator|&&
operator|(
name|REGEXP_UNIT
argument_list|(
name|REGEXP_ALLOF
argument_list|(
name|seq
argument_list|)
operator|->
name|regexps
index|[
name|k
index|]
argument_list|)
operator|->
name|unit_decl
operator|==
name|unit_decl
operator|)
condition|)
break|break;
if|if
condition|(
name|k
operator|>=
name|REGEXP_ALLOF
argument_list|(
name|seq
argument_list|)
operator|->
name|regexps_num
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|seq
operator|->
name|mode
operator|==
name|rm_unit
operator|&&
name|REGEXP_UNIT
argument_list|(
name|seq
argument_list|)
operator|->
name|unit_decl
operator|!=
name|unit_decl
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|the_same_automaton_lists
index|[
name|cycle
index|]
operator|==
name|NULL
condition|)
name|the_same_automaton_lists
index|[
name|cycle
index|]
operator|=
name|unit_decl
expr_stmt|;
else|else
block|{
for|for
control|(
name|last
operator|=
name|the_same_automaton_lists
index|[
name|cycle
index|]
init|;
condition|;
control|)
block|{
if|if
condition|(
name|last
operator|==
name|unit_decl
condition|)
return|return;
if|if
condition|(
name|last
operator|->
name|the_same_automaton_unit
operator|==
name|the_same_automaton_lists
index|[
name|cycle
index|]
condition|)
break|break;
name|last
operator|=
name|last
operator|->
name|the_same_automaton_unit
expr_stmt|;
block|}
name|last
operator|->
name|the_same_automaton_unit
operator|=
name|unit_decl
operator|->
name|the_same_automaton_unit
expr_stmt|;
name|unit_decl
operator|->
name|the_same_automaton_unit
operator|=
name|the_same_automaton_lists
index|[
name|cycle
index|]
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* The function processes given REGEXP to find units which should be    in the same automaton.  */
end_comment

begin_function
specifier|static
name|void
name|form_the_same_automaton_unit_lists_from_regexp
parameter_list|(
name|regexp
parameter_list|)
name|regexp_t
name|regexp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|regexp_t
name|seq
decl_stmt|,
name|allof
decl_stmt|,
name|unit
decl_stmt|;
if|if
condition|(
name|regexp
operator|==
name|NULL
operator|||
name|regexp
operator|->
name|mode
operator|!=
name|rm_oneof
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|max_insn_reserv_cycles
condition|;
name|i
operator|++
control|)
name|the_same_automaton_lists
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|seq
operator|=
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|seq
operator|->
name|mode
operator|==
name|rm_sequence
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|REGEXP_SEQUENCE
argument_list|(
name|seq
argument_list|)
operator|->
name|regexps_num
condition|;
name|j
operator|++
control|)
block|{
name|allof
operator|=
name|REGEXP_SEQUENCE
argument_list|(
name|seq
argument_list|)
operator|->
name|regexps
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|allof
operator|->
name|mode
operator|==
name|rm_allof
condition|)
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|REGEXP_ALLOF
argument_list|(
name|allof
argument_list|)
operator|->
name|regexps_num
condition|;
name|k
operator|++
control|)
block|{
name|unit
operator|=
name|REGEXP_ALLOF
argument_list|(
name|allof
argument_list|)
operator|->
name|regexps
index|[
name|k
index|]
expr_stmt|;
if|if
condition|(
name|unit
operator|->
name|mode
operator|==
name|rm_unit
condition|)
name|process_unit_to_form_the_same_automaton_unit_lists
argument_list|(
name|unit
argument_list|,
name|regexp
argument_list|,
name|j
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|unit
operator|->
name|mode
operator|!=
name|rm_nothing
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|allof
operator|->
name|mode
operator|==
name|rm_unit
condition|)
name|process_unit_to_form_the_same_automaton_unit_lists
argument_list|(
name|allof
argument_list|,
name|regexp
argument_list|,
name|j
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|allof
operator|->
name|mode
operator|!=
name|rm_nothing
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|seq
operator|->
name|mode
operator|==
name|rm_allof
condition|)
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|REGEXP_ALLOF
argument_list|(
name|seq
argument_list|)
operator|->
name|regexps_num
condition|;
name|k
operator|++
control|)
block|{
name|unit
operator|=
name|REGEXP_ALLOF
argument_list|(
name|seq
argument_list|)
operator|->
name|regexps
index|[
name|k
index|]
expr_stmt|;
if|if
condition|(
name|unit
operator|->
name|mode
operator|==
name|rm_unit
condition|)
name|process_unit_to_form_the_same_automaton_unit_lists
argument_list|(
name|unit
argument_list|,
name|regexp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|unit
operator|->
name|mode
operator|!=
name|rm_nothing
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|seq
operator|->
name|mode
operator|==
name|rm_unit
condition|)
name|process_unit_to_form_the_same_automaton_unit_lists
argument_list|(
name|seq
argument_list|,
name|regexp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|seq
operator|->
name|mode
operator|!=
name|rm_nothing
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The function initializes data to search for units which should be    in the same automaton and call function    `form_the_same_automaton_unit_lists_from_regexp' for each insn    reservation regexp.  */
end_comment

begin_function
specifier|static
name|void
name|form_the_same_automaton_unit_lists
parameter_list|()
block|{
name|decl_t
name|decl
decl_stmt|;
name|int
name|i
decl_stmt|;
name|the_same_automaton_lists
operator|=
operator|(
name|unit_decl_t
operator|*
operator|)
name|xmalloc
argument_list|(
name|description
operator|->
name|max_insn_reserv_cycles
operator|*
sizeof|sizeof
argument_list|(
name|unit_decl_t
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_unit
condition|)
block|{
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|the_same_automaton_message_reported_p
operator|=
name|FALSE
expr_stmt|;
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|the_same_automaton_unit
operator|=
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_insn_reserv
condition|)
name|form_the_same_automaton_unit_lists_from_regexp
argument_list|(
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|transformed_regexp
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|the_same_automaton_lists
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function finds units which should be in the same automaton and,    if they are not, reports about it.  */
end_comment

begin_function
specifier|static
name|void
name|check_unit_distributions_to_automata
parameter_list|()
block|{
name|decl_t
name|decl
decl_stmt|;
name|unit_decl_t
name|start_unit_decl
decl_stmt|,
name|unit_decl
decl_stmt|;
name|int
name|i
decl_stmt|;
name|form_the_same_automaton_unit_lists
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_unit
condition|)
block|{
name|start_unit_decl
operator|=
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|start_unit_decl
operator|->
name|the_same_automaton_message_reported_p
condition|)
for|for
control|(
name|unit_decl
operator|=
name|start_unit_decl
operator|->
name|the_same_automaton_unit
init|;
name|unit_decl
operator|!=
name|start_unit_decl
condition|;
name|unit_decl
operator|=
name|unit_decl
operator|->
name|the_same_automaton_unit
control|)
if|if
condition|(
name|start_unit_decl
operator|->
name|automaton_decl
operator|!=
name|unit_decl
operator|->
name|automaton_decl
condition|)
block|{
name|error
argument_list|(
literal|"Units `%s' and `%s' should be in the same automaton"
argument_list|,
name|start_unit_decl
operator|->
name|name
argument_list|,
name|unit_decl
operator|->
name|name
argument_list|)
expr_stmt|;
name|unit_decl
operator|->
name|the_same_automaton_message_reported_p
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The page contains code for building alt_states (see comments for    IR) describing all possible insns reservations of an automaton.  */
end_comment

begin_comment
comment|/* Current state being formed for which the current alt_state    refers.  */
end_comment

begin_decl_stmt
specifier|static
name|state_t
name|state_being_formed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current alt_state being formed.  */
end_comment

begin_decl_stmt
specifier|static
name|alt_state_t
name|alt_state_being_formed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This recursive function processes `,' and units in reservation    REGEXP for forming alt_states of AUTOMATON.  It is believed that    CURR_CYCLE is start cycle of all reservation REGEXP.  */
end_comment

begin_function
specifier|static
name|int
name|process_seq_for_forming_states
parameter_list|(
name|regexp
parameter_list|,
name|automaton
parameter_list|,
name|curr_cycle
parameter_list|)
name|regexp_t
name|regexp
decl_stmt|;
name|automaton_t
name|automaton
decl_stmt|;
name|int
name|curr_cycle
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|regexp
operator|==
name|NULL
condition|)
return|return
name|curr_cycle
return|;
elseif|else
if|if
condition|(
name|regexp
operator|->
name|mode
operator|==
name|rm_unit
condition|)
block|{
if|if
condition|(
name|REGEXP_UNIT
argument_list|(
name|regexp
argument_list|)
operator|->
name|unit_decl
operator|->
name|corresponding_automaton_num
operator|==
name|automaton
operator|->
name|automaton_order_num
condition|)
name|set_state_reserv
argument_list|(
name|state_being_formed
argument_list|,
name|curr_cycle
argument_list|,
name|REGEXP_UNIT
argument_list|(
name|regexp
argument_list|)
operator|->
name|unit_decl
operator|->
name|unit_num
argument_list|)
expr_stmt|;
return|return
name|curr_cycle
return|;
block|}
elseif|else
if|if
condition|(
name|regexp
operator|->
name|mode
operator|==
name|rm_sequence
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|;
name|i
operator|++
control|)
name|curr_cycle
operator|=
name|process_seq_for_forming_states
argument_list|(
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
argument_list|,
name|automaton
argument_list|,
name|curr_cycle
argument_list|)
operator|+
literal|1
expr_stmt|;
return|return
name|curr_cycle
return|;
block|}
elseif|else
if|if
condition|(
name|regexp
operator|->
name|mode
operator|==
name|rm_allof
condition|)
block|{
name|int
name|finish_cycle
init|=
literal|0
decl_stmt|;
name|int
name|cycle
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|;
name|i
operator|++
control|)
block|{
name|cycle
operator|=
name|process_seq_for_forming_states
argument_list|(
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
argument_list|,
name|automaton
argument_list|,
name|curr_cycle
argument_list|)
expr_stmt|;
if|if
condition|(
name|finish_cycle
operator|<
name|cycle
condition|)
name|finish_cycle
operator|=
name|cycle
expr_stmt|;
block|}
return|return
name|finish_cycle
return|;
block|}
else|else
block|{
if|if
condition|(
name|regexp
operator|->
name|mode
operator|!=
name|rm_nothing
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|curr_cycle
return|;
block|}
block|}
end_function

begin_comment
comment|/* This recursive function finishes forming ALT_STATE of AUTOMATON and    inserts alt_state into the table.  */
end_comment

begin_function
specifier|static
name|void
name|finish_forming_alt_state
parameter_list|(
name|alt_state
parameter_list|,
name|automaton
parameter_list|)
name|alt_state_t
name|alt_state
decl_stmt|;
name|automaton_t
name|automaton
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|state_t
name|state_in_table
decl_stmt|;
name|state_t
name|corresponding_state
decl_stmt|;
name|corresponding_state
operator|=
name|alt_state
operator|->
name|state
expr_stmt|;
name|state_in_table
operator|=
name|insert_state
argument_list|(
name|corresponding_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|state_in_table
operator|!=
name|corresponding_state
condition|)
block|{
name|free_state
argument_list|(
name|corresponding_state
argument_list|)
expr_stmt|;
name|alt_state
operator|->
name|state
operator|=
name|state_in_table
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The following variable value is current automaton insn for whose    reservation the alt states are created.  */
end_comment

begin_decl_stmt
specifier|static
name|ainsn_t
name|curr_ainsn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This recursive function processes `|' in reservation REGEXP for    forming alt_states of AUTOMATON.  List of the alt states should    have the same order as in the description.  */
end_comment

begin_function
specifier|static
name|void
name|process_alts_for_forming_states
parameter_list|(
name|regexp
parameter_list|,
name|automaton
parameter_list|,
name|inside_oneof_p
parameter_list|)
name|regexp_t
name|regexp
decl_stmt|;
name|automaton_t
name|automaton
decl_stmt|;
name|int
name|inside_oneof_p
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|regexp
operator|->
name|mode
operator|!=
name|rm_oneof
condition|)
block|{
name|alt_state_being_formed
operator|=
name|get_free_alt_state
argument_list|()
expr_stmt|;
name|state_being_formed
operator|=
name|get_free_state
argument_list|(
literal|1
argument_list|,
name|automaton
argument_list|)
expr_stmt|;
name|alt_state_being_formed
operator|->
name|state
operator|=
name|state_being_formed
expr_stmt|;
comment|/* We inserts in reverse order but we process alternatives also          in reverse order.  So we have the same order of alternative          as in the description.  */
name|alt_state_being_formed
operator|->
name|next_alt_state
operator|=
name|curr_ainsn
operator|->
name|alt_states
expr_stmt|;
name|curr_ainsn
operator|->
name|alt_states
operator|=
name|alt_state_being_formed
expr_stmt|;
operator|(
name|void
operator|)
name|process_seq_for_forming_states
argument_list|(
name|regexp
argument_list|,
name|automaton
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|finish_forming_alt_state
argument_list|(
name|alt_state_being_formed
argument_list|,
name|automaton
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|inside_oneof_p
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* We processes it in reverse order to get list with the same 	 order as in the description.  See also the previous 	 commentary.  */
for|for
control|(
name|i
operator|=
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|process_alts_for_forming_states
argument_list|(
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
argument_list|,
name|automaton
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Create nodes alt_state for all AUTOMATON insns.  */
end_comment

begin_function
specifier|static
name|void
name|create_alt_states
parameter_list|(
name|automaton
parameter_list|)
name|automaton_t
name|automaton
decl_stmt|;
block|{
name|struct
name|insn_reserv_decl
modifier|*
name|reserv_decl
decl_stmt|;
for|for
control|(
name|curr_ainsn
operator|=
name|automaton
operator|->
name|ainsn_list
init|;
name|curr_ainsn
operator|!=
name|NULL
condition|;
name|curr_ainsn
operator|=
name|curr_ainsn
operator|->
name|next_ainsn
control|)
block|{
name|reserv_decl
operator|=
name|curr_ainsn
operator|->
name|insn_reserv_decl
expr_stmt|;
if|if
condition|(
name|reserv_decl
operator|!=
name|DECL_INSN_RESERV
argument_list|(
name|advance_cycle_insn_decl
argument_list|)
condition|)
block|{
name|curr_ainsn
operator|->
name|alt_states
operator|=
name|NULL
expr_stmt|;
name|process_alts_for_forming_states
argument_list|(
name|reserv_decl
operator|->
name|transformed_regexp
argument_list|,
name|automaton
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|curr_ainsn
operator|->
name|sorted_alt_states
operator|=
name|uniq_sort_alt_states
argument_list|(
name|curr_ainsn
operator|->
name|alt_states
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The page contains major code for building DFA(s) for fast pipeline    hazards recognition.  */
end_comment

begin_comment
comment|/* The function forms list of ainsns of AUTOMATON with the same    reservation.  */
end_comment

begin_function
specifier|static
name|void
name|form_ainsn_with_same_reservs
parameter_list|(
name|automaton
parameter_list|)
name|automaton_t
name|automaton
decl_stmt|;
block|{
name|ainsn_t
name|curr_ainsn
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|vla_ptr_t
name|first_insns
decl_stmt|;
name|vla_ptr_t
name|last_insns
decl_stmt|;
name|VLA_PTR_CREATE
argument_list|(
name|first_insns
argument_list|,
literal|150
argument_list|,
literal|"first insns with the same reservs"
argument_list|)
expr_stmt|;
name|VLA_PTR_CREATE
argument_list|(
name|last_insns
argument_list|,
literal|150
argument_list|,
literal|"last insns with the same reservs"
argument_list|)
expr_stmt|;
for|for
control|(
name|curr_ainsn
operator|=
name|automaton
operator|->
name|ainsn_list
init|;
name|curr_ainsn
operator|!=
name|NULL
condition|;
name|curr_ainsn
operator|=
name|curr_ainsn
operator|->
name|next_ainsn
control|)
if|if
condition|(
name|curr_ainsn
operator|->
name|insn_reserv_decl
operator|==
name|DECL_INSN_RESERV
argument_list|(
name|advance_cycle_insn_decl
argument_list|)
condition|)
block|{
name|curr_ainsn
operator|->
name|next_same_reservs_insn
operator|=
name|NULL
expr_stmt|;
name|curr_ainsn
operator|->
name|first_insn_with_same_reservs
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VLA_PTR_LENGTH
argument_list|(
name|first_insns
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|alt_states_eq
argument_list|(
name|curr_ainsn
operator|->
name|sorted_alt_states
argument_list|,
operator|(
operator|(
name|ainsn_t
operator|)
name|VLA_PTR
argument_list|(
name|first_insns
argument_list|,
name|i
argument_list|)
operator|)
operator|->
name|sorted_alt_states
argument_list|)
condition|)
break|break;
name|curr_ainsn
operator|->
name|next_same_reservs_insn
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|VLA_PTR_LENGTH
argument_list|(
name|first_insns
argument_list|)
condition|)
block|{
name|curr_ainsn
operator|->
name|first_insn_with_same_reservs
operator|=
literal|0
expr_stmt|;
operator|(
operator|(
name|ainsn_t
operator|)
name|VLA_PTR
argument_list|(
name|last_insns
argument_list|,
name|i
argument_list|)
operator|)
operator|->
name|next_same_reservs_insn
operator|=
name|curr_ainsn
expr_stmt|;
name|VLA_PTR
argument_list|(
name|last_insns
argument_list|,
name|i
argument_list|)
operator|=
name|curr_ainsn
expr_stmt|;
block|}
else|else
block|{
name|VLA_PTR_ADD
argument_list|(
name|first_insns
argument_list|,
name|curr_ainsn
argument_list|)
expr_stmt|;
name|VLA_PTR_ADD
argument_list|(
name|last_insns
argument_list|,
name|curr_ainsn
argument_list|)
expr_stmt|;
name|curr_ainsn
operator|->
name|first_insn_with_same_reservs
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|VLA_PTR_DELETE
argument_list|(
name|first_insns
argument_list|)
expr_stmt|;
name|VLA_PTR_DELETE
argument_list|(
name|last_insns
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The following function creates all states of nondeterministic (if    NDFA_FLAG has nonzero value) or deterministic AUTOMATON.  */
end_comment

begin_function
specifier|static
name|void
name|make_automaton
parameter_list|(
name|automaton
parameter_list|)
name|automaton_t
name|automaton
decl_stmt|;
block|{
name|ainsn_t
name|ainsn
decl_stmt|;
name|struct
name|insn_reserv_decl
modifier|*
name|insn_reserv_decl
decl_stmt|;
name|alt_state_t
name|alt_state
decl_stmt|;
name|state_t
name|state
decl_stmt|;
name|state_t
name|start_state
decl_stmt|;
name|state_t
name|state2
decl_stmt|;
name|ainsn_t
name|advance_cycle_ainsn
decl_stmt|;
name|arc_t
name|added_arc
decl_stmt|;
name|vla_ptr_t
name|state_stack
decl_stmt|;
name|VLA_PTR_CREATE
argument_list|(
name|state_stack
argument_list|,
literal|150
argument_list|,
literal|"state stack"
argument_list|)
expr_stmt|;
comment|/* Create the start state (empty state).  */
name|start_state
operator|=
name|insert_state
argument_list|(
name|get_free_state
argument_list|(
literal|1
argument_list|,
name|automaton
argument_list|)
argument_list|)
expr_stmt|;
name|automaton
operator|->
name|start_state
operator|=
name|start_state
expr_stmt|;
name|start_state
operator|->
name|it_was_placed_in_stack_for_NDFA_forming
operator|=
literal|1
expr_stmt|;
name|VLA_PTR_ADD
argument_list|(
name|state_stack
argument_list|,
name|start_state
argument_list|)
expr_stmt|;
while|while
condition|(
name|VLA_PTR_LENGTH
argument_list|(
name|state_stack
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|state
operator|=
name|VLA_PTR
argument_list|(
name|state_stack
argument_list|,
name|VLA_PTR_LENGTH
argument_list|(
name|state_stack
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|VLA_PTR_SHORTEN
argument_list|(
name|state_stack
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|advance_cycle_ainsn
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|ainsn
operator|=
name|automaton
operator|->
name|ainsn_list
init|;
name|ainsn
operator|!=
name|NULL
condition|;
name|ainsn
operator|=
name|ainsn
operator|->
name|next_ainsn
control|)
if|if
condition|(
name|ainsn
operator|->
name|first_insn_with_same_reservs
condition|)
block|{
name|insn_reserv_decl
operator|=
name|ainsn
operator|->
name|insn_reserv_decl
expr_stmt|;
if|if
condition|(
name|insn_reserv_decl
operator|!=
name|DECL_INSN_RESERV
argument_list|(
name|advance_cycle_insn_decl
argument_list|)
condition|)
block|{
comment|/* We process alt_states in the same order as they are                    present in the description.  */
name|added_arc
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|alt_state
operator|=
name|ainsn
operator|->
name|alt_states
init|;
name|alt_state
operator|!=
name|NULL
condition|;
name|alt_state
operator|=
name|alt_state
operator|->
name|next_alt_state
control|)
block|{
name|state2
operator|=
name|alt_state
operator|->
name|state
expr_stmt|;
if|if
condition|(
operator|!
name|intersected_state_reservs_p
argument_list|(
name|state
argument_list|,
name|state2
argument_list|)
condition|)
block|{
name|state2
operator|=
name|states_union
argument_list|(
name|state
argument_list|,
name|state2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|state2
operator|->
name|it_was_placed_in_stack_for_NDFA_forming
condition|)
block|{
name|state2
operator|->
name|it_was_placed_in_stack_for_NDFA_forming
operator|=
literal|1
expr_stmt|;
name|VLA_PTR_ADD
argument_list|(
name|state_stack
argument_list|,
name|state2
argument_list|)
expr_stmt|;
block|}
name|added_arc
operator|=
name|add_arc
argument_list|(
name|state
argument_list|,
name|state2
argument_list|,
name|ainsn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ndfa_flag
condition|)
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|ndfa_flag
operator|&&
name|added_arc
operator|!=
name|NULL
condition|)
block|{
name|added_arc
operator|->
name|state_alts
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|alt_state
operator|=
name|ainsn
operator|->
name|alt_states
init|;
name|alt_state
operator|!=
name|NULL
condition|;
name|alt_state
operator|=
name|alt_state
operator|->
name|next_alt_state
control|)
block|{
name|state2
operator|=
name|alt_state
operator|->
name|state
expr_stmt|;
if|if
condition|(
operator|!
name|intersected_state_reservs_p
argument_list|(
name|state
argument_list|,
name|state2
argument_list|)
condition|)
name|added_arc
operator|->
name|state_alts
operator|++
expr_stmt|;
block|}
block|}
block|}
else|else
name|advance_cycle_ainsn
operator|=
name|ainsn
expr_stmt|;
block|}
comment|/* Add transition to advance cycle.  */
name|state2
operator|=
name|state_shift
argument_list|(
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|state2
operator|->
name|it_was_placed_in_stack_for_NDFA_forming
condition|)
block|{
name|state2
operator|->
name|it_was_placed_in_stack_for_NDFA_forming
operator|=
literal|1
expr_stmt|;
name|VLA_PTR_ADD
argument_list|(
name|state_stack
argument_list|,
name|state2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|advance_cycle_ainsn
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|add_arc
argument_list|(
name|state
argument_list|,
name|state2
argument_list|,
name|advance_cycle_ainsn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|VLA_PTR_DELETE
argument_list|(
name|state_stack
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Foms lists of all arcs of STATE marked by the same ainsn.  */
end_comment

begin_function
specifier|static
name|void
name|form_arcs_marked_by_insn
parameter_list|(
name|state
parameter_list|)
name|state_t
name|state
decl_stmt|;
block|{
name|decl_t
name|decl
decl_stmt|;
name|arc_t
name|arc
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_insn_reserv
condition|)
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|arcs_marked_by_insn
operator|=
name|NULL
expr_stmt|;
block|}
for|for
control|(
name|arc
operator|=
name|first_out_arc
argument_list|(
name|state
argument_list|)
init|;
name|arc
operator|!=
name|NULL
condition|;
name|arc
operator|=
name|next_out_arc
argument_list|(
name|arc
argument_list|)
control|)
block|{
if|if
condition|(
name|arc
operator|->
name|insn
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|arc
operator|->
name|next_arc_marked_by_insn
operator|=
name|arc
operator|->
name|insn
operator|->
name|insn_reserv_decl
operator|->
name|arcs_marked_by_insn
expr_stmt|;
name|arc
operator|->
name|insn
operator|->
name|insn_reserv_decl
operator|->
name|arcs_marked_by_insn
operator|=
name|arc
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The function creates composed state (see comments for IR) from    ORIGINAL_STATE and list of arcs ARCS_MARKED_BY_INSN marked by the    same insn.  If the composed state is not in STATE_STACK yet, it is    popped to STATE_STACK.  */
end_comment

begin_function
specifier|static
name|void
name|create_composed_state
parameter_list|(
name|original_state
parameter_list|,
name|arcs_marked_by_insn
parameter_list|,
name|state_stack
parameter_list|)
name|state_t
name|original_state
decl_stmt|;
name|arc_t
name|arcs_marked_by_insn
decl_stmt|;
name|vla_ptr_t
modifier|*
name|state_stack
decl_stmt|;
block|{
name|state_t
name|state
decl_stmt|;
name|alt_state_t
name|curr_alt_state
decl_stmt|;
name|alt_state_t
name|new_alt_state
decl_stmt|;
name|arc_t
name|curr_arc
decl_stmt|;
name|arc_t
name|next_arc
decl_stmt|;
name|state_t
name|state_in_table
decl_stmt|;
name|state_t
name|temp_state
decl_stmt|;
name|alt_state_t
name|canonical_alt_states_list
decl_stmt|;
name|int
name|alts_number
decl_stmt|;
if|if
condition|(
name|arcs_marked_by_insn
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|arcs_marked_by_insn
operator|->
name|next_arc_marked_by_insn
operator|==
name|NULL
condition|)
name|state
operator|=
name|arcs_marked_by_insn
operator|->
name|to_state
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|ndfa_flag
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Create composed state.  */
name|state
operator|=
name|get_free_state
argument_list|(
literal|0
argument_list|,
name|arcs_marked_by_insn
operator|->
name|to_state
operator|->
name|automaton
argument_list|)
expr_stmt|;
name|curr_alt_state
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|curr_arc
operator|=
name|arcs_marked_by_insn
init|;
name|curr_arc
operator|!=
name|NULL
condition|;
name|curr_arc
operator|=
name|curr_arc
operator|->
name|next_arc_marked_by_insn
control|)
block|{
name|new_alt_state
operator|=
name|get_free_alt_state
argument_list|()
expr_stmt|;
name|new_alt_state
operator|->
name|next_alt_state
operator|=
name|curr_alt_state
expr_stmt|;
name|new_alt_state
operator|->
name|state
operator|=
name|curr_arc
operator|->
name|to_state
expr_stmt|;
if|if
condition|(
name|curr_arc
operator|->
name|to_state
operator|->
name|component_states
operator|!=
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|curr_alt_state
operator|=
name|new_alt_state
expr_stmt|;
block|}
comment|/* There are not identical sets in the alt state list.  */
name|canonical_alt_states_list
operator|=
name|uniq_sort_alt_states
argument_list|(
name|curr_alt_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|canonical_alt_states_list
operator|->
name|next_sorted_alt_state
operator|==
name|NULL
condition|)
block|{
name|temp_state
operator|=
name|state
expr_stmt|;
name|state
operator|=
name|canonical_alt_states_list
operator|->
name|state
expr_stmt|;
name|free_state
argument_list|(
name|temp_state
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|state
operator|->
name|component_states
operator|=
name|canonical_alt_states_list
expr_stmt|;
name|state_in_table
operator|=
name|insert_state
argument_list|(
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|state_in_table
operator|!=
name|state
condition|)
block|{
if|if
condition|(
operator|!
name|state_in_table
operator|->
name|it_was_placed_in_stack_for_DFA_forming
condition|)
name|abort
argument_list|()
expr_stmt|;
name|free_state
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|state
operator|=
name|state_in_table
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|state
operator|->
name|it_was_placed_in_stack_for_DFA_forming
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|curr_alt_state
operator|=
name|state
operator|->
name|component_states
init|;
name|curr_alt_state
operator|!=
name|NULL
condition|;
name|curr_alt_state
operator|=
name|curr_alt_state
operator|->
name|next_sorted_alt_state
control|)
for|for
control|(
name|curr_arc
operator|=
name|first_out_arc
argument_list|(
name|curr_alt_state
operator|->
name|state
argument_list|)
init|;
name|curr_arc
operator|!=
name|NULL
condition|;
name|curr_arc
operator|=
name|next_out_arc
argument_list|(
name|curr_arc
argument_list|)
control|)
name|add_arc
argument_list|(
name|state
argument_list|,
name|curr_arc
operator|->
name|to_state
argument_list|,
name|curr_arc
operator|->
name|insn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|arcs_marked_by_insn
operator|->
name|to_state
operator|=
name|state
expr_stmt|;
for|for
control|(
name|alts_number
operator|=
literal|0
operator|,
name|curr_arc
operator|=
name|arcs_marked_by_insn
operator|->
name|next_arc_marked_by_insn
init|;
name|curr_arc
operator|!=
name|NULL
condition|;
name|curr_arc
operator|=
name|next_arc
control|)
block|{
name|next_arc
operator|=
name|curr_arc
operator|->
name|next_arc_marked_by_insn
expr_stmt|;
name|remove_arc
argument_list|(
name|original_state
argument_list|,
name|curr_arc
argument_list|)
expr_stmt|;
name|alts_number
operator|++
expr_stmt|;
block|}
name|arcs_marked_by_insn
operator|->
name|state_alts
operator|=
name|alts_number
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|state
operator|->
name|it_was_placed_in_stack_for_DFA_forming
condition|)
block|{
name|state
operator|->
name|it_was_placed_in_stack_for_DFA_forming
operator|=
literal|1
expr_stmt|;
name|VLA_PTR_ADD
argument_list|(
operator|*
name|state_stack
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The function transformes nondeterminstic AUTOMATON into    deterministic.  */
end_comment

begin_function
specifier|static
name|void
name|NDFA_to_DFA
parameter_list|(
name|automaton
parameter_list|)
name|automaton_t
name|automaton
decl_stmt|;
block|{
name|state_t
name|start_state
decl_stmt|;
name|state_t
name|state
decl_stmt|;
name|decl_t
name|decl
decl_stmt|;
name|vla_ptr_t
name|state_stack
decl_stmt|;
name|int
name|i
decl_stmt|;
name|VLA_PTR_CREATE
argument_list|(
name|state_stack
argument_list|,
literal|150
argument_list|,
literal|"state stack"
argument_list|)
expr_stmt|;
comment|/* Create the start state (empty state).  */
name|start_state
operator|=
name|automaton
operator|->
name|start_state
expr_stmt|;
name|start_state
operator|->
name|it_was_placed_in_stack_for_DFA_forming
operator|=
literal|1
expr_stmt|;
name|VLA_PTR_ADD
argument_list|(
name|state_stack
argument_list|,
name|start_state
argument_list|)
expr_stmt|;
while|while
condition|(
name|VLA_PTR_LENGTH
argument_list|(
name|state_stack
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|state
operator|=
name|VLA_PTR
argument_list|(
name|state_stack
argument_list|,
name|VLA_PTR_LENGTH
argument_list|(
name|state_stack
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|VLA_PTR_SHORTEN
argument_list|(
name|state_stack
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|form_arcs_marked_by_insn
argument_list|(
name|state
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_insn_reserv
condition|)
name|create_composed_state
argument_list|(
name|state
argument_list|,
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|arcs_marked_by_insn
argument_list|,
operator|&
name|state_stack
argument_list|)
expr_stmt|;
block|}
block|}
name|VLA_PTR_DELETE
argument_list|(
name|state_stack
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The following variable value is current number (1, 2, ...) of passing    graph of states.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|curr_state_graph_pass_num
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This recursive function passes all states achieved from START_STATE    and applies APPLIED_FUNC to them.  */
end_comment

begin_function_decl
specifier|static
name|void
name|pass_state_graph
parameter_list|(
name|start_state
parameter_list|,
name|applied_func
parameter_list|)
name|state_t
name|start_state
decl_stmt|;
function_decl|void
parameter_list|(
function_decl|*applied_func
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|state_t
name|state
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|arc_t
name|arc
decl_stmt|;
if|if
condition|(
name|start_state
operator|->
name|pass_num
operator|==
name|curr_state_graph_pass_num
condition|)
return|return;
name|start_state
operator|->
name|pass_num
operator|=
name|curr_state_graph_pass_num
expr_stmt|;
call|(
modifier|*
name|applied_func
call|)
argument_list|(
name|start_state
argument_list|)
expr_stmt|;
for|for
control|(
name|arc
operator|=
name|first_out_arc
argument_list|(
name|start_state
argument_list|)
init|;
name|arc
operator|!=
name|NULL
condition|;
name|arc
operator|=
name|next_out_arc
argument_list|(
name|arc
argument_list|)
control|)
name|pass_state_graph
argument_list|(
name|arc
operator|->
name|to_state
argument_list|,
name|applied_func
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* This recursive function passes all states of AUTOMATON and applies    APPLIED_FUNC to them.  */
end_comment

begin_function_decl
specifier|static
name|void
name|pass_states
parameter_list|(
name|automaton
parameter_list|,
name|applied_func
parameter_list|)
name|automaton_t
name|automaton
decl_stmt|;
function_decl|void
parameter_list|(
function_decl|*applied_func
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|state_t
name|state
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|curr_state_graph_pass_num
operator|++
expr_stmt|;
name|pass_state_graph
argument_list|(
name|automaton
operator|->
name|start_state
argument_list|,
name|applied_func
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* The function initializes code for passing of all states.  */
end_comment

begin_function
specifier|static
name|void
name|initiate_pass_states
parameter_list|()
block|{
name|curr_state_graph_pass_num
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The following vla is used for storing pointers to all achieved    states.  */
end_comment

begin_decl_stmt
specifier|static
name|vla_ptr_t
name|all_achieved_states
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This function is called by function pass_states to add an achieved    STATE.  */
end_comment

begin_function
specifier|static
name|void
name|add_achieved_state
parameter_list|(
name|state
parameter_list|)
name|state_t
name|state
decl_stmt|;
block|{
name|VLA_PTR_ADD
argument_list|(
name|all_achieved_states
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function sets up equivalence numbers of insns which mark all    out arcs of STATE by equiv_class_num_1 (if ODD_ITERATION_FLAG has    nonzero value) or by equiv_class_num_2 of the destination state.    The function returns number of out arcs of STATE.  */
end_comment

begin_function
specifier|static
name|int
name|set_out_arc_insns_equiv_num
parameter_list|(
name|state
parameter_list|,
name|odd_iteration_flag
parameter_list|)
name|state_t
name|state
decl_stmt|;
name|int
name|odd_iteration_flag
decl_stmt|;
block|{
name|int
name|state_out_arcs_num
decl_stmt|;
name|arc_t
name|arc
decl_stmt|;
name|state_out_arcs_num
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|arc
operator|=
name|first_out_arc
argument_list|(
name|state
argument_list|)
init|;
name|arc
operator|!=
name|NULL
condition|;
name|arc
operator|=
name|next_out_arc
argument_list|(
name|arc
argument_list|)
control|)
block|{
if|if
condition|(
name|arc
operator|->
name|insn
operator|->
name|insn_reserv_decl
operator|->
name|equiv_class_num
operator|!=
literal|0
operator|||
name|arc
operator|->
name|insn
operator|->
name|insn_reserv_decl
operator|->
name|state_alts
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|state_out_arcs_num
operator|++
expr_stmt|;
name|arc
operator|->
name|insn
operator|->
name|insn_reserv_decl
operator|->
name|equiv_class_num
operator|=
operator|(
name|odd_iteration_flag
condition|?
name|arc
operator|->
name|to_state
operator|->
name|equiv_class_num_1
else|:
name|arc
operator|->
name|to_state
operator|->
name|equiv_class_num_2
operator|)
expr_stmt|;
name|arc
operator|->
name|insn
operator|->
name|insn_reserv_decl
operator|->
name|state_alts
operator|=
name|arc
operator|->
name|state_alts
expr_stmt|;
if|if
condition|(
name|arc
operator|->
name|insn
operator|->
name|insn_reserv_decl
operator|->
name|equiv_class_num
operator|==
literal|0
operator|||
name|arc
operator|->
name|insn
operator|->
name|insn_reserv_decl
operator|->
name|state_alts
operator|<=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|state_out_arcs_num
return|;
block|}
end_function

begin_comment
comment|/* The function clears equivalence numbers and alt_states in all insns    which mark all out arcs of STATE.  */
end_comment

begin_function
specifier|static
name|void
name|clear_arc_insns_equiv_num
parameter_list|(
name|state
parameter_list|)
name|state_t
name|state
decl_stmt|;
block|{
name|arc_t
name|arc
decl_stmt|;
for|for
control|(
name|arc
operator|=
name|first_out_arc
argument_list|(
name|state
argument_list|)
init|;
name|arc
operator|!=
name|NULL
condition|;
name|arc
operator|=
name|next_out_arc
argument_list|(
name|arc
argument_list|)
control|)
block|{
name|arc
operator|->
name|insn
operator|->
name|insn_reserv_decl
operator|->
name|equiv_class_num
operator|=
literal|0
expr_stmt|;
name|arc
operator|->
name|insn
operator|->
name|insn_reserv_decl
operator|->
name|state_alts
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The function copies pointers to equivalent states from vla FROM    into vla TO.  */
end_comment

begin_function
specifier|static
name|void
name|copy_equiv_class
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|)
name|vla_ptr_t
modifier|*
name|to
decl_stmt|;
specifier|const
name|vla_ptr_t
modifier|*
name|from
decl_stmt|;
block|{
name|state_t
modifier|*
name|class_ptr
decl_stmt|;
name|VLA_PTR_NULLIFY
argument_list|(
operator|*
name|to
argument_list|)
expr_stmt|;
for|for
control|(
name|class_ptr
operator|=
name|VLA_PTR_BEGIN
argument_list|(
operator|*
name|from
argument_list|)
init|;
name|class_ptr
operator|<=
operator|(
name|state_t
operator|*
operator|)
name|VLA_PTR_LAST
argument_list|(
operator|*
name|from
argument_list|)
condition|;
name|class_ptr
operator|++
control|)
name|VLA_PTR_ADD
argument_list|(
operator|*
name|to
argument_list|,
operator|*
name|class_ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function returns nonzero value if STATE is not equivalent to    another state from the same current partition on equivalence    classes Another state has ORIGINAL_STATE_OUT_ARCS_NUM number of    output arcs.  Iteration of making equivalence partition is defined    by ODD_ITERATION_FLAG.  */
end_comment

begin_function
specifier|static
name|int
name|state_is_differed
parameter_list|(
name|state
parameter_list|,
name|original_state_out_arcs_num
parameter_list|,
name|odd_iteration_flag
parameter_list|)
name|state_t
name|state
decl_stmt|;
name|int
name|original_state_out_arcs_num
decl_stmt|;
name|int
name|odd_iteration_flag
decl_stmt|;
block|{
name|arc_t
name|arc
decl_stmt|;
name|int
name|state_out_arcs_num
decl_stmt|;
name|state_out_arcs_num
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|arc
operator|=
name|first_out_arc
argument_list|(
name|state
argument_list|)
init|;
name|arc
operator|!=
name|NULL
condition|;
name|arc
operator|=
name|next_out_arc
argument_list|(
name|arc
argument_list|)
control|)
block|{
name|state_out_arcs_num
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|odd_iteration_flag
condition|?
name|arc
operator|->
name|to_state
operator|->
name|equiv_class_num_1
else|:
name|arc
operator|->
name|to_state
operator|->
name|equiv_class_num_2
operator|)
operator|!=
name|arc
operator|->
name|insn
operator|->
name|insn_reserv_decl
operator|->
name|equiv_class_num
operator|||
operator|(
name|arc
operator|->
name|insn
operator|->
name|insn_reserv_decl
operator|->
name|state_alts
operator|!=
name|arc
operator|->
name|state_alts
operator|)
condition|)
return|return
literal|1
return|;
block|}
return|return
name|state_out_arcs_num
operator|!=
name|original_state_out_arcs_num
return|;
block|}
end_function

begin_comment
comment|/* The function makes initial partition of STATES on equivalent    classes.  */
end_comment

begin_function
specifier|static
name|state_t
name|init_equiv_class
parameter_list|(
name|states
parameter_list|,
name|states_num
parameter_list|)
name|state_t
modifier|*
name|states
decl_stmt|;
name|int
name|states_num
decl_stmt|;
block|{
name|state_t
modifier|*
name|state_ptr
decl_stmt|;
name|state_t
name|result_equiv_class
decl_stmt|;
name|result_equiv_class
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|state_ptr
operator|=
name|states
init|;
name|state_ptr
operator|<
name|states
operator|+
name|states_num
condition|;
name|state_ptr
operator|++
control|)
block|{
operator|(
operator|*
name|state_ptr
operator|)
operator|->
name|equiv_class_num_1
operator|=
literal|1
expr_stmt|;
operator|(
operator|*
name|state_ptr
operator|)
operator|->
name|next_equiv_class_state
operator|=
name|result_equiv_class
expr_stmt|;
name|result_equiv_class
operator|=
operator|*
name|state_ptr
expr_stmt|;
block|}
return|return
name|result_equiv_class
return|;
block|}
end_function

begin_comment
comment|/* The function processes equivalence class given by its pointer    EQUIV_CLASS_PTR on odd iteration if ODD_ITERATION_FLAG.  If there    are not equvalent states, the function partitions the class    removing nonequivalent states and placing them in    *NEXT_ITERATION_CLASSES, increments *NEW_EQUIV_CLASS_NUM_PTR ans    assigns it to the state equivalence number.  If the class has been    partitioned, the function returns nonzero value.  */
end_comment

begin_function
specifier|static
name|int
name|partition_equiv_class
parameter_list|(
name|equiv_class_ptr
parameter_list|,
name|odd_iteration_flag
parameter_list|,
name|next_iteration_classes
parameter_list|,
name|new_equiv_class_num_ptr
parameter_list|)
name|state_t
modifier|*
name|equiv_class_ptr
decl_stmt|;
name|int
name|odd_iteration_flag
decl_stmt|;
name|vla_ptr_t
modifier|*
name|next_iteration_classes
decl_stmt|;
name|int
modifier|*
name|new_equiv_class_num_ptr
decl_stmt|;
block|{
name|state_t
name|new_equiv_class
decl_stmt|;
name|int
name|partition_p
decl_stmt|;
name|state_t
name|first_state
decl_stmt|;
name|state_t
name|curr_state
decl_stmt|;
name|state_t
name|prev_state
decl_stmt|;
name|state_t
name|next_state
decl_stmt|;
name|int
name|out_arcs_num
decl_stmt|;
name|partition_p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|equiv_class_ptr
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|first_state
operator|=
operator|*
name|equiv_class_ptr
init|;
name|first_state
operator|!=
name|NULL
condition|;
name|first_state
operator|=
name|new_equiv_class
control|)
block|{
name|new_equiv_class
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|first_state
operator|->
name|next_equiv_class_state
operator|!=
name|NULL
condition|)
block|{
comment|/* There are more one states in the class equivalence.  */
name|out_arcs_num
operator|=
name|set_out_arc_insns_equiv_num
argument_list|(
name|first_state
argument_list|,
name|odd_iteration_flag
argument_list|)
expr_stmt|;
for|for
control|(
name|prev_state
operator|=
name|first_state
operator|,
name|curr_state
operator|=
name|first_state
operator|->
name|next_equiv_class_state
init|;
name|curr_state
operator|!=
name|NULL
condition|;
name|curr_state
operator|=
name|next_state
control|)
block|{
name|next_state
operator|=
name|curr_state
operator|->
name|next_equiv_class_state
expr_stmt|;
if|if
condition|(
name|state_is_differed
argument_list|(
name|curr_state
argument_list|,
name|out_arcs_num
argument_list|,
name|odd_iteration_flag
argument_list|)
condition|)
block|{
comment|/* Remove curr state from the class equivalence.  */
name|prev_state
operator|->
name|next_equiv_class_state
operator|=
name|next_state
expr_stmt|;
comment|/* Add curr state to the new class equivalence.  */
name|curr_state
operator|->
name|next_equiv_class_state
operator|=
name|new_equiv_class
expr_stmt|;
if|if
condition|(
name|new_equiv_class
operator|==
name|NULL
condition|)
operator|(
operator|*
name|new_equiv_class_num_ptr
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|odd_iteration_flag
condition|)
name|curr_state
operator|->
name|equiv_class_num_2
operator|=
operator|*
name|new_equiv_class_num_ptr
expr_stmt|;
else|else
name|curr_state
operator|->
name|equiv_class_num_1
operator|=
operator|*
name|new_equiv_class_num_ptr
expr_stmt|;
name|new_equiv_class
operator|=
name|curr_state
expr_stmt|;
name|partition_p
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|prev_state
operator|=
name|curr_state
expr_stmt|;
block|}
name|clear_arc_insns_equiv_num
argument_list|(
name|first_state
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|new_equiv_class
operator|!=
name|NULL
condition|)
name|VLA_PTR_ADD
argument_list|(
operator|*
name|next_iteration_classes
argument_list|,
name|new_equiv_class
argument_list|)
expr_stmt|;
block|}
return|return
name|partition_p
return|;
block|}
end_function

begin_comment
comment|/* The function finds equivalent states of AUTOMATON.  */
end_comment

begin_function
specifier|static
name|void
name|evaluate_equiv_classes
parameter_list|(
name|automaton
parameter_list|,
name|equiv_classes
parameter_list|)
name|automaton_t
name|automaton
decl_stmt|;
name|vla_ptr_t
modifier|*
name|equiv_classes
decl_stmt|;
block|{
name|state_t
name|new_equiv_class
decl_stmt|;
name|int
name|new_equiv_class_num
decl_stmt|;
name|int
name|odd_iteration_flag
decl_stmt|;
name|int
name|finish_flag
decl_stmt|;
name|vla_ptr_t
name|next_iteration_classes
decl_stmt|;
name|state_t
modifier|*
name|equiv_class_ptr
decl_stmt|;
name|state_t
modifier|*
name|state_ptr
decl_stmt|;
name|VLA_PTR_CREATE
argument_list|(
name|all_achieved_states
argument_list|,
literal|1500
argument_list|,
literal|"all achieved states"
argument_list|)
expr_stmt|;
name|pass_states
argument_list|(
name|automaton
argument_list|,
name|add_achieved_state
argument_list|)
expr_stmt|;
name|new_equiv_class
operator|=
name|init_equiv_class
argument_list|(
name|VLA_PTR_BEGIN
argument_list|(
name|all_achieved_states
argument_list|)
argument_list|,
name|VLA_PTR_LENGTH
argument_list|(
name|all_achieved_states
argument_list|)
argument_list|)
expr_stmt|;
name|odd_iteration_flag
operator|=
literal|0
expr_stmt|;
name|new_equiv_class_num
operator|=
literal|1
expr_stmt|;
name|VLA_PTR_CREATE
argument_list|(
name|next_iteration_classes
argument_list|,
literal|150
argument_list|,
literal|"next iteration classes"
argument_list|)
expr_stmt|;
name|VLA_PTR_ADD
argument_list|(
name|next_iteration_classes
argument_list|,
name|new_equiv_class
argument_list|)
expr_stmt|;
do|do
block|{
name|odd_iteration_flag
operator|=
operator|!
name|odd_iteration_flag
expr_stmt|;
name|finish_flag
operator|=
literal|1
expr_stmt|;
name|copy_equiv_class
argument_list|(
name|equiv_classes
argument_list|,
operator|&
name|next_iteration_classes
argument_list|)
expr_stmt|;
comment|/* Transfer equiv numbers for the next iteration.  */
for|for
control|(
name|state_ptr
operator|=
name|VLA_PTR_BEGIN
argument_list|(
name|all_achieved_states
argument_list|)
init|;
name|state_ptr
operator|<=
operator|(
name|state_t
operator|*
operator|)
name|VLA_PTR_LAST
argument_list|(
name|all_achieved_states
argument_list|)
condition|;
name|state_ptr
operator|++
control|)
if|if
condition|(
name|odd_iteration_flag
condition|)
operator|(
operator|*
name|state_ptr
operator|)
operator|->
name|equiv_class_num_2
operator|=
operator|(
operator|*
name|state_ptr
operator|)
operator|->
name|equiv_class_num_1
expr_stmt|;
else|else
operator|(
operator|*
name|state_ptr
operator|)
operator|->
name|equiv_class_num_1
operator|=
operator|(
operator|*
name|state_ptr
operator|)
operator|->
name|equiv_class_num_2
expr_stmt|;
for|for
control|(
name|equiv_class_ptr
operator|=
name|VLA_PTR_BEGIN
argument_list|(
operator|*
name|equiv_classes
argument_list|)
init|;
name|equiv_class_ptr
operator|<=
operator|(
name|state_t
operator|*
operator|)
name|VLA_PTR_LAST
argument_list|(
operator|*
name|equiv_classes
argument_list|)
condition|;
name|equiv_class_ptr
operator|++
control|)
if|if
condition|(
name|partition_equiv_class
argument_list|(
name|equiv_class_ptr
argument_list|,
name|odd_iteration_flag
argument_list|,
operator|&
name|next_iteration_classes
argument_list|,
operator|&
name|new_equiv_class_num
argument_list|)
condition|)
name|finish_flag
operator|=
literal|0
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|finish_flag
condition|)
do|;
name|VLA_PTR_DELETE
argument_list|(
name|next_iteration_classes
argument_list|)
expr_stmt|;
name|VLA_PTR_DELETE
argument_list|(
name|all_achieved_states
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function merges equivalent states of AUTOMATON.  */
end_comment

begin_function
specifier|static
name|void
name|merge_states
parameter_list|(
name|automaton
parameter_list|,
name|equiv_classes
parameter_list|)
name|automaton_t
name|automaton
decl_stmt|;
name|vla_ptr_t
modifier|*
name|equiv_classes
decl_stmt|;
block|{
name|state_t
modifier|*
name|equiv_class_ptr
decl_stmt|;
name|state_t
name|curr_state
decl_stmt|;
name|state_t
name|new_state
decl_stmt|;
name|state_t
name|first_class_state
decl_stmt|;
name|alt_state_t
name|alt_states
decl_stmt|;
name|alt_state_t
name|new_alt_state
decl_stmt|;
name|arc_t
name|curr_arc
decl_stmt|;
name|arc_t
name|next_arc
decl_stmt|;
comment|/* Create states corresponding to equivalence classes containing two      or more states.  */
for|for
control|(
name|equiv_class_ptr
operator|=
name|VLA_PTR_BEGIN
argument_list|(
operator|*
name|equiv_classes
argument_list|)
init|;
name|equiv_class_ptr
operator|<=
operator|(
name|state_t
operator|*
operator|)
name|VLA_PTR_LAST
argument_list|(
operator|*
name|equiv_classes
argument_list|)
condition|;
name|equiv_class_ptr
operator|++
control|)
if|if
condition|(
operator|(
operator|*
name|equiv_class_ptr
operator|)
operator|->
name|next_equiv_class_state
operator|!=
name|NULL
condition|)
block|{
comment|/* There are more one states in the class equivalence.  */
comment|/* Create new compound state.  */
name|new_state
operator|=
name|get_free_state
argument_list|(
literal|0
argument_list|,
name|automaton
argument_list|)
expr_stmt|;
name|alt_states
operator|=
name|NULL
expr_stmt|;
name|first_class_state
operator|=
operator|*
name|equiv_class_ptr
expr_stmt|;
for|for
control|(
name|curr_state
operator|=
name|first_class_state
init|;
name|curr_state
operator|!=
name|NULL
condition|;
name|curr_state
operator|=
name|curr_state
operator|->
name|next_equiv_class_state
control|)
block|{
name|curr_state
operator|->
name|equiv_class_state
operator|=
name|new_state
expr_stmt|;
name|new_alt_state
operator|=
name|get_free_alt_state
argument_list|()
expr_stmt|;
name|new_alt_state
operator|->
name|state
operator|=
name|curr_state
expr_stmt|;
name|new_alt_state
operator|->
name|next_sorted_alt_state
operator|=
name|alt_states
expr_stmt|;
name|alt_states
operator|=
name|new_alt_state
expr_stmt|;
block|}
name|new_state
operator|->
name|component_states
operator|=
name|alt_states
expr_stmt|;
block|}
else|else
operator|(
operator|*
name|equiv_class_ptr
operator|)
operator|->
name|equiv_class_state
operator|=
operator|*
name|equiv_class_ptr
expr_stmt|;
for|for
control|(
name|equiv_class_ptr
operator|=
name|VLA_PTR_BEGIN
argument_list|(
operator|*
name|equiv_classes
argument_list|)
init|;
name|equiv_class_ptr
operator|<=
operator|(
name|state_t
operator|*
operator|)
name|VLA_PTR_LAST
argument_list|(
operator|*
name|equiv_classes
argument_list|)
condition|;
name|equiv_class_ptr
operator|++
control|)
if|if
condition|(
operator|(
operator|*
name|equiv_class_ptr
operator|)
operator|->
name|next_equiv_class_state
operator|!=
name|NULL
condition|)
block|{
name|first_class_state
operator|=
operator|*
name|equiv_class_ptr
expr_stmt|;
comment|/* Create new arcs output from the state corresponding to            equiv class.  */
for|for
control|(
name|curr_arc
operator|=
name|first_out_arc
argument_list|(
name|first_class_state
argument_list|)
init|;
name|curr_arc
operator|!=
name|NULL
condition|;
name|curr_arc
operator|=
name|next_out_arc
argument_list|(
name|curr_arc
argument_list|)
control|)
name|add_arc
argument_list|(
name|first_class_state
operator|->
name|equiv_class_state
argument_list|,
name|curr_arc
operator|->
name|to_state
operator|->
name|equiv_class_state
argument_list|,
name|curr_arc
operator|->
name|insn
argument_list|,
name|curr_arc
operator|->
name|state_alts
argument_list|)
expr_stmt|;
comment|/* Delete output arcs from states of given class equivalence.  */
for|for
control|(
name|curr_state
operator|=
name|first_class_state
init|;
name|curr_state
operator|!=
name|NULL
condition|;
name|curr_state
operator|=
name|curr_state
operator|->
name|next_equiv_class_state
control|)
block|{
if|if
condition|(
name|automaton
operator|->
name|start_state
operator|==
name|curr_state
condition|)
name|automaton
operator|->
name|start_state
operator|=
name|curr_state
operator|->
name|equiv_class_state
expr_stmt|;
comment|/* Delete the state and its output arcs.  */
for|for
control|(
name|curr_arc
operator|=
name|first_out_arc
argument_list|(
name|curr_state
argument_list|)
init|;
name|curr_arc
operator|!=
name|NULL
condition|;
name|curr_arc
operator|=
name|next_arc
control|)
block|{
name|next_arc
operator|=
name|next_out_arc
argument_list|(
name|curr_arc
argument_list|)
expr_stmt|;
name|free_arc
argument_list|(
name|curr_arc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* Change `to_state' of arcs output from the state of given            equivalence class.  */
for|for
control|(
name|curr_arc
operator|=
name|first_out_arc
argument_list|(
operator|*
name|equiv_class_ptr
argument_list|)
init|;
name|curr_arc
operator|!=
name|NULL
condition|;
name|curr_arc
operator|=
name|next_out_arc
argument_list|(
name|curr_arc
argument_list|)
control|)
name|curr_arc
operator|->
name|to_state
operator|=
name|curr_arc
operator|->
name|to_state
operator|->
name|equiv_class_state
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The function sets up new_cycle_p for states if there is arc to the    state marked by advance_cycle_insn_decl.  */
end_comment

begin_function
specifier|static
name|void
name|set_new_cycle_flags
parameter_list|(
name|state
parameter_list|)
name|state_t
name|state
decl_stmt|;
block|{
name|arc_t
name|arc
decl_stmt|;
for|for
control|(
name|arc
operator|=
name|first_out_arc
argument_list|(
name|state
argument_list|)
init|;
name|arc
operator|!=
name|NULL
condition|;
name|arc
operator|=
name|next_out_arc
argument_list|(
name|arc
argument_list|)
control|)
if|if
condition|(
name|arc
operator|->
name|insn
operator|->
name|insn_reserv_decl
operator|==
name|DECL_INSN_RESERV
argument_list|(
name|advance_cycle_insn_decl
argument_list|)
condition|)
name|arc
operator|->
name|to_state
operator|->
name|new_cycle_p
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The top level function for minimization of deterministic    AUTOMATON.  */
end_comment

begin_function
specifier|static
name|void
name|minimize_DFA
parameter_list|(
name|automaton
parameter_list|)
name|automaton_t
name|automaton
decl_stmt|;
block|{
name|vla_ptr_t
name|equiv_classes
decl_stmt|;
name|VLA_PTR_CREATE
argument_list|(
name|equiv_classes
argument_list|,
literal|1500
argument_list|,
literal|"equivalence classes"
argument_list|)
expr_stmt|;
name|evaluate_equiv_classes
argument_list|(
name|automaton
argument_list|,
operator|&
name|equiv_classes
argument_list|)
expr_stmt|;
name|merge_states
argument_list|(
name|automaton
argument_list|,
operator|&
name|equiv_classes
argument_list|)
expr_stmt|;
name|pass_states
argument_list|(
name|automaton
argument_list|,
name|set_new_cycle_flags
argument_list|)
expr_stmt|;
name|VLA_PTR_DELETE
argument_list|(
name|equiv_classes
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Values of two variables are counted number of states and arcs in an    automaton.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|curr_counted_states_num
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|curr_counted_arcs_num
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The function is called by function `pass_states' to count states    and arcs of an automaton.  */
end_comment

begin_function
specifier|static
name|void
name|incr_states_and_arcs_nums
parameter_list|(
name|state
parameter_list|)
name|state_t
name|state
decl_stmt|;
block|{
name|arc_t
name|arc
decl_stmt|;
name|curr_counted_states_num
operator|++
expr_stmt|;
for|for
control|(
name|arc
operator|=
name|first_out_arc
argument_list|(
name|state
argument_list|)
init|;
name|arc
operator|!=
name|NULL
condition|;
name|arc
operator|=
name|next_out_arc
argument_list|(
name|arc
argument_list|)
control|)
name|curr_counted_arcs_num
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function counts states and arcs of AUTOMATON.  */
end_comment

begin_function
specifier|static
name|void
name|count_states_and_arcs
parameter_list|(
name|automaton
parameter_list|,
name|states_num
parameter_list|,
name|arcs_num
parameter_list|)
name|automaton_t
name|automaton
decl_stmt|;
name|int
modifier|*
name|states_num
decl_stmt|;
name|int
modifier|*
name|arcs_num
decl_stmt|;
block|{
name|curr_counted_states_num
operator|=
literal|0
expr_stmt|;
name|curr_counted_arcs_num
operator|=
literal|0
expr_stmt|;
name|pass_states
argument_list|(
name|automaton
argument_list|,
name|incr_states_and_arcs_nums
argument_list|)
expr_stmt|;
operator|*
name|states_num
operator|=
name|curr_counted_states_num
expr_stmt|;
operator|*
name|arcs_num
operator|=
name|curr_counted_arcs_num
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function builds one DFA AUTOMATON for fast pipeline hazards    recognition after checking and simplifying IR of the    description.  */
end_comment

begin_function
specifier|static
name|void
name|build_automaton
parameter_list|(
name|automaton
parameter_list|)
name|automaton_t
name|automaton
decl_stmt|;
block|{
name|int
name|states_num
decl_stmt|;
name|int
name|arcs_num
decl_stmt|;
name|ticker_on
argument_list|(
operator|&
name|NDFA_time
argument_list|)
expr_stmt|;
name|make_automaton
argument_list|(
name|automaton
argument_list|)
expr_stmt|;
name|ticker_off
argument_list|(
operator|&
name|NDFA_time
argument_list|)
expr_stmt|;
name|count_states_and_arcs
argument_list|(
name|automaton
argument_list|,
operator|&
name|states_num
argument_list|,
operator|&
name|arcs_num
argument_list|)
expr_stmt|;
name|automaton
operator|->
name|NDFA_states_num
operator|=
name|states_num
expr_stmt|;
name|automaton
operator|->
name|NDFA_arcs_num
operator|=
name|arcs_num
expr_stmt|;
name|ticker_on
argument_list|(
operator|&
name|NDFA_to_DFA_time
argument_list|)
expr_stmt|;
name|NDFA_to_DFA
argument_list|(
name|automaton
argument_list|)
expr_stmt|;
name|ticker_off
argument_list|(
operator|&
name|NDFA_to_DFA_time
argument_list|)
expr_stmt|;
name|count_states_and_arcs
argument_list|(
name|automaton
argument_list|,
operator|&
name|states_num
argument_list|,
operator|&
name|arcs_num
argument_list|)
expr_stmt|;
name|automaton
operator|->
name|DFA_states_num
operator|=
name|states_num
expr_stmt|;
name|automaton
operator|->
name|DFA_arcs_num
operator|=
name|arcs_num
expr_stmt|;
if|if
condition|(
operator|!
name|no_minimization_flag
condition|)
block|{
name|ticker_on
argument_list|(
operator|&
name|minimize_time
argument_list|)
expr_stmt|;
name|minimize_DFA
argument_list|(
name|automaton
argument_list|)
expr_stmt|;
name|ticker_off
argument_list|(
operator|&
name|minimize_time
argument_list|)
expr_stmt|;
name|count_states_and_arcs
argument_list|(
name|automaton
argument_list|,
operator|&
name|states_num
argument_list|,
operator|&
name|arcs_num
argument_list|)
expr_stmt|;
name|automaton
operator|->
name|minimal_DFA_states_num
operator|=
name|states_num
expr_stmt|;
name|automaton
operator|->
name|minimal_DFA_arcs_num
operator|=
name|arcs_num
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The page contains code for enumeration  of all states of an automaton.  */
end_comment

begin_comment
comment|/* Variable used for enumeration of all states of an automaton.  Its    value is current number of automaton states.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|curr_state_order_num
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The function is called by function `pass_states' for enumerating    states.  */
end_comment

begin_function
specifier|static
name|void
name|set_order_state_num
parameter_list|(
name|state
parameter_list|)
name|state_t
name|state
decl_stmt|;
block|{
name|state
operator|->
name|order_state_num
operator|=
name|curr_state_order_num
expr_stmt|;
name|curr_state_order_num
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function enumerates all states of AUTOMATON.  */
end_comment

begin_function
specifier|static
name|void
name|enumerate_states
parameter_list|(
name|automaton
parameter_list|)
name|automaton_t
name|automaton
decl_stmt|;
block|{
name|curr_state_order_num
operator|=
literal|0
expr_stmt|;
name|pass_states
argument_list|(
name|automaton
argument_list|,
name|set_order_state_num
argument_list|)
expr_stmt|;
name|automaton
operator|->
name|achieved_states_num
operator|=
name|curr_state_order_num
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The page contains code for finding equivalent automaton insns    (ainsns).  */
end_comment

begin_comment
comment|/* The function inserts AINSN into cyclic list    CYCLIC_EQUIV_CLASS_INSN_LIST of ainsns.  */
end_comment

begin_function
specifier|static
name|ainsn_t
name|insert_ainsn_into_equiv_class
parameter_list|(
name|ainsn
parameter_list|,
name|cyclic_equiv_class_insn_list
parameter_list|)
name|ainsn_t
name|ainsn
decl_stmt|;
name|ainsn_t
name|cyclic_equiv_class_insn_list
decl_stmt|;
block|{
if|if
condition|(
name|cyclic_equiv_class_insn_list
operator|==
name|NULL
condition|)
name|ainsn
operator|->
name|next_equiv_class_insn
operator|=
name|ainsn
expr_stmt|;
else|else
block|{
name|ainsn
operator|->
name|next_equiv_class_insn
operator|=
name|cyclic_equiv_class_insn_list
operator|->
name|next_equiv_class_insn
expr_stmt|;
name|cyclic_equiv_class_insn_list
operator|->
name|next_equiv_class_insn
operator|=
name|ainsn
expr_stmt|;
block|}
return|return
name|ainsn
return|;
block|}
end_function

begin_comment
comment|/* The function deletes equiv_class_insn into cyclic list of    equivalent ainsns.  */
end_comment

begin_function
specifier|static
name|void
name|delete_ainsn_from_equiv_class
parameter_list|(
name|equiv_class_insn
parameter_list|)
name|ainsn_t
name|equiv_class_insn
decl_stmt|;
block|{
name|ainsn_t
name|curr_equiv_class_insn
decl_stmt|;
name|ainsn_t
name|prev_equiv_class_insn
decl_stmt|;
name|prev_equiv_class_insn
operator|=
name|equiv_class_insn
expr_stmt|;
for|for
control|(
name|curr_equiv_class_insn
operator|=
name|equiv_class_insn
operator|->
name|next_equiv_class_insn
init|;
name|curr_equiv_class_insn
operator|!=
name|equiv_class_insn
condition|;
name|curr_equiv_class_insn
operator|=
name|curr_equiv_class_insn
operator|->
name|next_equiv_class_insn
control|)
name|prev_equiv_class_insn
operator|=
name|curr_equiv_class_insn
expr_stmt|;
if|if
condition|(
name|prev_equiv_class_insn
operator|!=
name|equiv_class_insn
condition|)
name|prev_equiv_class_insn
operator|->
name|next_equiv_class_insn
operator|=
name|equiv_class_insn
operator|->
name|next_equiv_class_insn
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function processes AINSN of a state in order to find equivalent    ainsns.  INSN_ARCS_ARRAY is table: code of insn -> out arc of the    state.  */
end_comment

begin_function
specifier|static
name|void
name|process_insn_equiv_class
parameter_list|(
name|ainsn
parameter_list|,
name|insn_arcs_array
parameter_list|)
name|ainsn_t
name|ainsn
decl_stmt|;
name|arc_t
modifier|*
name|insn_arcs_array
decl_stmt|;
block|{
name|ainsn_t
name|next_insn
decl_stmt|;
name|ainsn_t
name|curr_insn
decl_stmt|;
name|ainsn_t
name|cyclic_insn_list
decl_stmt|;
name|arc_t
name|arc
decl_stmt|;
if|if
condition|(
name|insn_arcs_array
index|[
name|ainsn
operator|->
name|insn_reserv_decl
operator|->
name|insn_num
index|]
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|curr_insn
operator|=
name|ainsn
expr_stmt|;
comment|/* New class of ainsns which are not equivalent to given ainsn.  */
name|cyclic_insn_list
operator|=
name|NULL
expr_stmt|;
do|do
block|{
name|next_insn
operator|=
name|curr_insn
operator|->
name|next_equiv_class_insn
expr_stmt|;
name|arc
operator|=
name|insn_arcs_array
index|[
name|curr_insn
operator|->
name|insn_reserv_decl
operator|->
name|insn_num
index|]
expr_stmt|;
if|if
condition|(
name|arc
operator|==
name|NULL
operator|||
operator|(
name|insn_arcs_array
index|[
name|ainsn
operator|->
name|insn_reserv_decl
operator|->
name|insn_num
index|]
operator|->
name|to_state
operator|!=
name|arc
operator|->
name|to_state
operator|)
condition|)
block|{
name|delete_ainsn_from_equiv_class
argument_list|(
name|curr_insn
argument_list|)
expr_stmt|;
name|cyclic_insn_list
operator|=
name|insert_ainsn_into_equiv_class
argument_list|(
name|curr_insn
argument_list|,
name|cyclic_insn_list
argument_list|)
expr_stmt|;
block|}
name|curr_insn
operator|=
name|next_insn
expr_stmt|;
block|}
do|while
condition|(
name|curr_insn
operator|!=
name|ainsn
condition|)
do|;
block|}
end_function

begin_comment
comment|/* The function processes STATE in order to find equivalent ainsns.  */
end_comment

begin_function
specifier|static
name|void
name|process_state_for_insn_equiv_partition
parameter_list|(
name|state
parameter_list|)
name|state_t
name|state
decl_stmt|;
block|{
name|arc_t
name|arc
decl_stmt|;
name|arc_t
modifier|*
name|insn_arcs_array
decl_stmt|;
name|int
name|i
decl_stmt|;
name|vla_ptr_t
name|insn_arcs_vect
decl_stmt|;
name|VLA_PTR_CREATE
argument_list|(
name|insn_arcs_vect
argument_list|,
literal|500
argument_list|,
literal|"insn arcs vector"
argument_list|)
expr_stmt|;
name|VLA_PTR_EXPAND
argument_list|(
name|insn_arcs_vect
argument_list|,
name|description
operator|->
name|insns_num
argument_list|)
expr_stmt|;
name|insn_arcs_array
operator|=
name|VLA_PTR_BEGIN
argument_list|(
name|insn_arcs_vect
argument_list|)
expr_stmt|;
comment|/* Process insns of the arcs.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|insns_num
condition|;
name|i
operator|++
control|)
name|insn_arcs_array
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|arc
operator|=
name|first_out_arc
argument_list|(
name|state
argument_list|)
init|;
name|arc
operator|!=
name|NULL
condition|;
name|arc
operator|=
name|next_out_arc
argument_list|(
name|arc
argument_list|)
control|)
name|insn_arcs_array
index|[
name|arc
operator|->
name|insn
operator|->
name|insn_reserv_decl
operator|->
name|insn_num
index|]
operator|=
name|arc
expr_stmt|;
for|for
control|(
name|arc
operator|=
name|first_out_arc
argument_list|(
name|state
argument_list|)
init|;
name|arc
operator|!=
name|NULL
condition|;
name|arc
operator|=
name|next_out_arc
argument_list|(
name|arc
argument_list|)
control|)
name|process_insn_equiv_class
argument_list|(
name|arc
operator|->
name|insn
argument_list|,
name|insn_arcs_array
argument_list|)
expr_stmt|;
name|VLA_PTR_DELETE
argument_list|(
name|insn_arcs_vect
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function searches for equivalent ainsns of AUTOMATON.  */
end_comment

begin_function
specifier|static
name|void
name|set_insn_equiv_classes
parameter_list|(
name|automaton
parameter_list|)
name|automaton_t
name|automaton
decl_stmt|;
block|{
name|ainsn_t
name|ainsn
decl_stmt|;
name|ainsn_t
name|first_insn
decl_stmt|;
name|ainsn_t
name|curr_insn
decl_stmt|;
name|ainsn_t
name|cyclic_insn_list
decl_stmt|;
name|ainsn_t
name|insn_with_same_reservs
decl_stmt|;
name|int
name|equiv_classes_num
decl_stmt|;
comment|/* All insns are included in one equivalence class.  */
name|cyclic_insn_list
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|ainsn
operator|=
name|automaton
operator|->
name|ainsn_list
init|;
name|ainsn
operator|!=
name|NULL
condition|;
name|ainsn
operator|=
name|ainsn
operator|->
name|next_ainsn
control|)
if|if
condition|(
name|ainsn
operator|->
name|first_insn_with_same_reservs
condition|)
name|cyclic_insn_list
operator|=
name|insert_ainsn_into_equiv_class
argument_list|(
name|ainsn
argument_list|,
name|cyclic_insn_list
argument_list|)
expr_stmt|;
comment|/* Process insns in order to make equivalence partition.  */
name|pass_states
argument_list|(
name|automaton
argument_list|,
name|process_state_for_insn_equiv_partition
argument_list|)
expr_stmt|;
comment|/* Enumerate equiv classes.  */
for|for
control|(
name|ainsn
operator|=
name|automaton
operator|->
name|ainsn_list
init|;
name|ainsn
operator|!=
name|NULL
condition|;
name|ainsn
operator|=
name|ainsn
operator|->
name|next_ainsn
control|)
comment|/* Set undefined value.  */
name|ainsn
operator|->
name|insn_equiv_class_num
operator|=
operator|-
literal|1
expr_stmt|;
name|equiv_classes_num
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ainsn
operator|=
name|automaton
operator|->
name|ainsn_list
init|;
name|ainsn
operator|!=
name|NULL
condition|;
name|ainsn
operator|=
name|ainsn
operator|->
name|next_ainsn
control|)
if|if
condition|(
name|ainsn
operator|->
name|insn_equiv_class_num
operator|<
literal|0
condition|)
block|{
name|first_insn
operator|=
name|ainsn
expr_stmt|;
if|if
condition|(
operator|!
name|first_insn
operator|->
name|first_insn_with_same_reservs
condition|)
name|abort
argument_list|()
expr_stmt|;
name|first_insn
operator|->
name|first_ainsn_with_given_equialence_num
operator|=
literal|1
expr_stmt|;
name|curr_insn
operator|=
name|first_insn
expr_stmt|;
do|do
block|{
for|for
control|(
name|insn_with_same_reservs
operator|=
name|curr_insn
init|;
name|insn_with_same_reservs
operator|!=
name|NULL
condition|;
name|insn_with_same_reservs
operator|=
name|insn_with_same_reservs
operator|->
name|next_same_reservs_insn
control|)
name|insn_with_same_reservs
operator|->
name|insn_equiv_class_num
operator|=
name|equiv_classes_num
expr_stmt|;
name|curr_insn
operator|=
name|curr_insn
operator|->
name|next_equiv_class_insn
expr_stmt|;
block|}
do|while
condition|(
name|curr_insn
operator|!=
name|first_insn
condition|)
do|;
name|equiv_classes_num
operator|++
expr_stmt|;
block|}
name|automaton
operator|->
name|insn_equiv_classes_num
operator|=
name|equiv_classes_num
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This page contains code for creating DFA(s) and calls functions    building them.  */
end_comment

begin_comment
comment|/* The following value is used to prevent floating point overflow for    estimating an automaton bound.  The value should be less DBL_MAX on    the host machine.  We use here approximate minimum of maximal    double floating point value required by ANSI C standard.  It    will work for non ANSI sun compiler too.  */
end_comment

begin_define
define|#
directive|define
name|MAX_FLOATING_POINT_VALUE_FOR_AUTOMATON_BOUND
value|1.0E37
end_define

begin_comment
comment|/* The function estimate size of the single DFA used by PHR (pipeline    hazards recognizer).  */
end_comment

begin_function
specifier|static
name|double
name|estimate_one_automaton_bound
parameter_list|()
block|{
name|decl_t
name|decl
decl_stmt|;
name|double
name|one_automaton_estimation_bound
decl_stmt|;
name|double
name|root_value
decl_stmt|;
name|int
name|i
decl_stmt|;
name|one_automaton_estimation_bound
operator|=
literal|1.0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_unit
condition|)
block|{
name|root_value
operator|=
name|exp
argument_list|(
name|log
argument_list|(
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|max_occ_cycle_num
operator|+
literal|1.0
argument_list|)
operator|/
name|automata_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|MAX_FLOATING_POINT_VALUE_FOR_AUTOMATON_BOUND
operator|/
name|root_value
operator|>
name|one_automaton_estimation_bound
condition|)
name|one_automaton_estimation_bound
operator|*=
name|root_value
expr_stmt|;
block|}
block|}
return|return
name|one_automaton_estimation_bound
return|;
block|}
end_function

begin_comment
comment|/* The function compares unit declarations acoording to their maximal    cycle in reservations.  */
end_comment

begin_function
specifier|static
name|int
name|compare_max_occ_cycle_nums
parameter_list|(
name|unit_decl_1
parameter_list|,
name|unit_decl_2
parameter_list|)
specifier|const
name|void
modifier|*
name|unit_decl_1
decl_stmt|;
specifier|const
name|void
modifier|*
name|unit_decl_2
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|DECL_UNIT
argument_list|(
operator|*
operator|(
name|decl_t
operator|*
operator|)
name|unit_decl_1
argument_list|)
operator|->
name|max_occ_cycle_num
operator|)
operator|<
operator|(
name|DECL_UNIT
argument_list|(
operator|*
operator|(
name|decl_t
operator|*
operator|)
name|unit_decl_2
argument_list|)
operator|->
name|max_occ_cycle_num
operator|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
operator|(
name|DECL_UNIT
argument_list|(
operator|*
operator|(
name|decl_t
operator|*
operator|)
name|unit_decl_1
argument_list|)
operator|->
name|max_occ_cycle_num
operator|)
operator|==
operator|(
name|DECL_UNIT
argument_list|(
operator|*
operator|(
name|decl_t
operator|*
operator|)
name|unit_decl_2
argument_list|)
operator|->
name|max_occ_cycle_num
operator|)
condition|)
return|return
literal|0
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* The function makes heuristic assigning automata to units.  Actually    efficacy of the algorithm has been checked yet??? */
end_comment

begin_function
specifier|static
name|void
name|units_to_automata_heuristic_distr
parameter_list|()
block|{
name|double
name|estimation_bound
decl_stmt|;
name|decl_t
name|decl
decl_stmt|;
name|decl_t
modifier|*
name|unit_decl_ptr
decl_stmt|;
name|int
name|automaton_num
decl_stmt|;
name|int
name|rest_units_num
decl_stmt|;
name|double
name|bound_value
decl_stmt|;
name|vla_ptr_t
name|unit_decls
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|description
operator|->
name|units_num
operator|==
literal|0
condition|)
return|return;
name|estimation_bound
operator|=
name|estimate_one_automaton_bound
argument_list|()
expr_stmt|;
name|VLA_PTR_CREATE
argument_list|(
name|unit_decls
argument_list|,
literal|150
argument_list|,
literal|"unit decls"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_unit
condition|)
name|VLA_PTR_ADD
argument_list|(
name|unit_decls
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
name|qsort
argument_list|(
name|VLA_PTR_BEGIN
argument_list|(
name|unit_decls
argument_list|)
argument_list|,
name|VLA_PTR_LENGTH
argument_list|(
name|unit_decls
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|decl_t
argument_list|)
argument_list|,
name|compare_max_occ_cycle_nums
argument_list|)
expr_stmt|;
name|automaton_num
operator|=
literal|0
expr_stmt|;
name|unit_decl_ptr
operator|=
name|VLA_PTR_BEGIN
argument_list|(
name|unit_decls
argument_list|)
expr_stmt|;
name|bound_value
operator|=
name|DECL_UNIT
argument_list|(
operator|*
name|unit_decl_ptr
argument_list|)
operator|->
name|max_occ_cycle_num
expr_stmt|;
name|DECL_UNIT
argument_list|(
operator|*
name|unit_decl_ptr
argument_list|)
operator|->
name|corresponding_automaton_num
operator|=
name|automaton_num
expr_stmt|;
for|for
control|(
name|unit_decl_ptr
operator|++
init|;
name|unit_decl_ptr
operator|<=
operator|(
name|decl_t
operator|*
operator|)
name|VLA_PTR_LAST
argument_list|(
name|unit_decls
argument_list|)
condition|;
name|unit_decl_ptr
operator|++
control|)
block|{
name|rest_units_num
operator|=
operator|(
operator|(
name|decl_t
operator|*
operator|)
name|VLA_PTR_LAST
argument_list|(
name|unit_decls
argument_list|)
operator|-
name|unit_decl_ptr
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|automata_num
operator|-
name|automaton_num
operator|-
literal|1
operator|>
name|rest_units_num
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|automaton_num
operator|<
name|automata_num
operator|-
literal|1
operator|&&
operator|(
operator|(
name|automata_num
operator|-
name|automaton_num
operator|-
literal|1
operator|==
name|rest_units_num
operator|)
operator|||
operator|(
name|bound_value
operator|>
operator|(
name|estimation_bound
operator|/
operator|(
name|DECL_UNIT
argument_list|(
operator|*
name|unit_decl_ptr
argument_list|)
operator|->
name|max_occ_cycle_num
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
name|bound_value
operator|=
name|DECL_UNIT
argument_list|(
operator|*
name|unit_decl_ptr
argument_list|)
operator|->
name|max_occ_cycle_num
expr_stmt|;
name|automaton_num
operator|++
expr_stmt|;
block|}
else|else
name|bound_value
operator|*=
name|DECL_UNIT
argument_list|(
operator|*
name|unit_decl_ptr
argument_list|)
operator|->
name|max_occ_cycle_num
expr_stmt|;
name|DECL_UNIT
argument_list|(
operator|*
name|unit_decl_ptr
argument_list|)
operator|->
name|corresponding_automaton_num
operator|=
name|automaton_num
expr_stmt|;
block|}
if|if
condition|(
name|automaton_num
operator|!=
name|automata_num
operator|-
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
name|VLA_PTR_DELETE
argument_list|(
name|unit_decls
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The functions creates automaton insns for each automata.  Automaton    insn is simply insn for given automaton which makes reservation    only of units of the automaton.  */
end_comment

begin_function
specifier|static
name|ainsn_t
name|create_ainsns
parameter_list|()
block|{
name|decl_t
name|decl
decl_stmt|;
name|ainsn_t
name|first_ainsn
decl_stmt|;
name|ainsn_t
name|curr_ainsn
decl_stmt|;
name|ainsn_t
name|prev_ainsn
decl_stmt|;
name|int
name|i
decl_stmt|;
name|first_ainsn
operator|=
name|NULL
expr_stmt|;
name|prev_ainsn
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_insn_reserv
condition|)
block|{
name|curr_ainsn
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ainsn
argument_list|)
argument_list|)
expr_stmt|;
name|curr_ainsn
operator|->
name|insn_reserv_decl
operator|=
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|curr_ainsn
operator|->
name|important_p
operator|=
name|FALSE
expr_stmt|;
name|curr_ainsn
operator|->
name|next_ainsn
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|prev_ainsn
operator|==
name|NULL
condition|)
name|first_ainsn
operator|=
name|curr_ainsn
expr_stmt|;
else|else
name|prev_ainsn
operator|->
name|next_ainsn
operator|=
name|curr_ainsn
expr_stmt|;
name|prev_ainsn
operator|=
name|curr_ainsn
expr_stmt|;
block|}
block|}
return|return
name|first_ainsn
return|;
block|}
end_function

begin_comment
comment|/* The function assigns automata to units according to constructions    `define_automaton' in the description.  */
end_comment

begin_function
specifier|static
name|void
name|units_to_automata_distr
parameter_list|()
block|{
name|decl_t
name|decl
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_unit
condition|)
block|{
if|if
condition|(
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|automaton_decl
operator|==
name|NULL
operator|||
operator|(
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|automaton_decl
operator|->
name|corresponding_automaton
operator|==
name|NULL
operator|)
condition|)
comment|/* Distribute to the first automaton.  */
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|corresponding_automaton_num
operator|=
literal|0
expr_stmt|;
else|else
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|corresponding_automaton_num
operator|=
operator|(
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|automaton_decl
operator|->
name|corresponding_automaton
operator|->
name|automaton_order_num
operator|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* The function creates DFA(s) for fast pipeline hazards recognition    after checking and simplifying IR of the description.  */
end_comment

begin_function
specifier|static
name|void
name|create_automata
parameter_list|()
block|{
name|automaton_t
name|curr_automaton
decl_stmt|;
name|automaton_t
name|prev_automaton
decl_stmt|;
name|decl_t
name|decl
decl_stmt|;
name|int
name|curr_automaton_num
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|automata_num
operator|!=
literal|0
condition|)
block|{
name|units_to_automata_heuristic_distr
argument_list|()
expr_stmt|;
for|for
control|(
name|prev_automaton
operator|=
name|NULL
operator|,
name|curr_automaton_num
operator|=
literal|0
init|;
name|curr_automaton_num
operator|<
name|automata_num
condition|;
name|curr_automaton_num
operator|++
operator|,
name|prev_automaton
operator|=
name|curr_automaton
control|)
block|{
name|curr_automaton
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|automaton
argument_list|)
argument_list|)
expr_stmt|;
name|curr_automaton
operator|->
name|ainsn_list
operator|=
name|create_ainsns
argument_list|()
expr_stmt|;
name|curr_automaton
operator|->
name|corresponding_automaton_decl
operator|=
name|NULL
expr_stmt|;
name|curr_automaton
operator|->
name|next_automaton
operator|=
name|NULL
expr_stmt|;
name|curr_automaton
operator|->
name|automaton_order_num
operator|=
name|curr_automaton_num
expr_stmt|;
if|if
condition|(
name|prev_automaton
operator|==
name|NULL
condition|)
name|description
operator|->
name|first_automaton
operator|=
name|curr_automaton
expr_stmt|;
else|else
name|prev_automaton
operator|->
name|next_automaton
operator|=
name|curr_automaton
expr_stmt|;
block|}
block|}
else|else
block|{
name|curr_automaton_num
operator|=
literal|0
expr_stmt|;
name|prev_automaton
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_automaton
operator|&&
name|DECL_AUTOMATON
argument_list|(
name|decl
argument_list|)
operator|->
name|automaton_is_used
condition|)
block|{
name|curr_automaton
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|automaton
argument_list|)
argument_list|)
expr_stmt|;
name|curr_automaton
operator|->
name|ainsn_list
operator|=
name|create_ainsns
argument_list|()
expr_stmt|;
name|curr_automaton
operator|->
name|corresponding_automaton_decl
operator|=
name|DECL_AUTOMATON
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|curr_automaton
operator|->
name|next_automaton
operator|=
name|NULL
expr_stmt|;
name|DECL_AUTOMATON
argument_list|(
name|decl
argument_list|)
operator|->
name|corresponding_automaton
operator|=
name|curr_automaton
expr_stmt|;
name|curr_automaton
operator|->
name|automaton_order_num
operator|=
name|curr_automaton_num
expr_stmt|;
if|if
condition|(
name|prev_automaton
operator|==
name|NULL
condition|)
name|description
operator|->
name|first_automaton
operator|=
name|curr_automaton
expr_stmt|;
else|else
name|prev_automaton
operator|->
name|next_automaton
operator|=
name|curr_automaton
expr_stmt|;
name|curr_automaton_num
operator|++
expr_stmt|;
name|prev_automaton
operator|=
name|curr_automaton
expr_stmt|;
block|}
block|}
if|if
condition|(
name|curr_automaton_num
operator|==
literal|0
condition|)
block|{
name|curr_automaton
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|automaton
argument_list|)
argument_list|)
expr_stmt|;
name|curr_automaton
operator|->
name|ainsn_list
operator|=
name|create_ainsns
argument_list|()
expr_stmt|;
name|curr_automaton
operator|->
name|corresponding_automaton_decl
operator|=
name|NULL
expr_stmt|;
name|curr_automaton
operator|->
name|next_automaton
operator|=
name|NULL
expr_stmt|;
name|description
operator|->
name|first_automaton
operator|=
name|curr_automaton
expr_stmt|;
block|}
name|units_to_automata_distr
argument_list|()
expr_stmt|;
block|}
name|NDFA_time
operator|=
name|create_ticker
argument_list|()
expr_stmt|;
name|ticker_off
argument_list|(
operator|&
name|NDFA_time
argument_list|)
expr_stmt|;
name|NDFA_to_DFA_time
operator|=
name|create_ticker
argument_list|()
expr_stmt|;
name|ticker_off
argument_list|(
operator|&
name|NDFA_to_DFA_time
argument_list|)
expr_stmt|;
name|minimize_time
operator|=
name|create_ticker
argument_list|()
expr_stmt|;
name|ticker_off
argument_list|(
operator|&
name|minimize_time
argument_list|)
expr_stmt|;
name|equiv_time
operator|=
name|create_ticker
argument_list|()
expr_stmt|;
name|ticker_off
argument_list|(
operator|&
name|equiv_time
argument_list|)
expr_stmt|;
for|for
control|(
name|curr_automaton
operator|=
name|description
operator|->
name|first_automaton
init|;
name|curr_automaton
operator|!=
name|NULL
condition|;
name|curr_automaton
operator|=
name|curr_automaton
operator|->
name|next_automaton
control|)
block|{
if|if
condition|(
name|curr_automaton
operator|->
name|corresponding_automaton_decl
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Create anonymous automaton ..."
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Create automaton `%s'..."
argument_list|,
name|curr_automaton
operator|->
name|corresponding_automaton_decl
operator|->
name|name
argument_list|)
expr_stmt|;
name|create_alt_states
argument_list|(
name|curr_automaton
argument_list|)
expr_stmt|;
name|form_ainsn_with_same_reservs
argument_list|(
name|curr_automaton
argument_list|)
expr_stmt|;
name|build_automaton
argument_list|(
name|curr_automaton
argument_list|)
expr_stmt|;
name|enumerate_states
argument_list|(
name|curr_automaton
argument_list|)
expr_stmt|;
name|ticker_on
argument_list|(
operator|&
name|equiv_time
argument_list|)
expr_stmt|;
name|set_insn_equiv_classes
argument_list|(
name|curr_automaton
argument_list|)
expr_stmt|;
name|ticker_off
argument_list|(
operator|&
name|equiv_time
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"done\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This page contains code for forming string representation of    regexp.  The representation is formed on IR obstack.  So you should    not work with IR obstack between regexp_representation and    finish_regexp_representation calls.  */
end_comment

begin_comment
comment|/* This recursive function forms string representation of regexp    (without tailing '\0').  */
end_comment

begin_function
specifier|static
name|void
name|form_regexp
parameter_list|(
name|regexp
parameter_list|)
name|regexp_t
name|regexp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|regexp
operator|->
name|mode
operator|==
name|rm_unit
operator|||
name|regexp
operator|->
name|mode
operator|==
name|rm_reserv
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
operator|(
name|regexp
operator|->
name|mode
operator|==
name|rm_unit
condition|?
name|REGEXP_UNIT
argument_list|(
name|regexp
argument_list|)
operator|->
name|name
else|:
name|REGEXP_RESERV
argument_list|(
name|regexp
argument_list|)
operator|->
name|name
operator|)
decl_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|irp
argument_list|,
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regexp
operator|->
name|mode
operator|==
name|rm_sequence
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|obstack_1grow
argument_list|(
operator|&
name|irp
argument_list|,
literal|','
argument_list|)
expr_stmt|;
name|form_regexp
argument_list|(
name|REGEXP_SEQUENCE
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regexp
operator|->
name|mode
operator|==
name|rm_allof
condition|)
block|{
name|obstack_1grow
argument_list|(
operator|&
name|irp
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|obstack_1grow
argument_list|(
operator|&
name|irp
argument_list|,
literal|'+'
argument_list|)
expr_stmt|;
if|if
condition|(
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
operator|->
name|mode
operator|==
name|rm_sequence
operator|||
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
operator|->
name|mode
operator|==
name|rm_oneof
condition|)
name|obstack_1grow
argument_list|(
operator|&
name|irp
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
name|form_regexp
argument_list|(
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
operator|->
name|mode
operator|==
name|rm_sequence
operator|||
name|REGEXP_ALLOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
operator|->
name|mode
operator|==
name|rm_oneof
condition|)
name|obstack_1grow
argument_list|(
operator|&
name|irp
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
block|}
name|obstack_1grow
argument_list|(
operator|&
name|irp
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regexp
operator|->
name|mode
operator|==
name|rm_oneof
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps_num
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|obstack_1grow
argument_list|(
operator|&
name|irp
argument_list|,
literal|'|'
argument_list|)
expr_stmt|;
if|if
condition|(
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
operator|->
name|mode
operator|==
name|rm_sequence
condition|)
name|obstack_1grow
argument_list|(
operator|&
name|irp
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
name|form_regexp
argument_list|(
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|REGEXP_ONEOF
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexps
index|[
name|i
index|]
operator|->
name|mode
operator|==
name|rm_sequence
condition|)
name|obstack_1grow
argument_list|(
operator|&
name|irp
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regexp
operator|->
name|mode
operator|==
name|rm_repeat
condition|)
block|{
name|char
name|digits
index|[
literal|30
index|]
decl_stmt|;
if|if
condition|(
name|REGEXP_REPEAT
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexp
operator|->
name|mode
operator|==
name|rm_sequence
operator|||
name|REGEXP_REPEAT
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexp
operator|->
name|mode
operator|==
name|rm_allof
operator|||
name|REGEXP_REPEAT
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexp
operator|->
name|mode
operator|==
name|rm_oneof
condition|)
name|obstack_1grow
argument_list|(
operator|&
name|irp
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
name|form_regexp
argument_list|(
name|REGEXP_REPEAT
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|REGEXP_REPEAT
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexp
operator|->
name|mode
operator|==
name|rm_sequence
operator|||
name|REGEXP_REPEAT
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexp
operator|->
name|mode
operator|==
name|rm_allof
operator|||
name|REGEXP_REPEAT
argument_list|(
name|regexp
argument_list|)
operator|->
name|regexp
operator|->
name|mode
operator|==
name|rm_oneof
condition|)
name|obstack_1grow
argument_list|(
operator|&
name|irp
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|digits
argument_list|,
literal|"*%d"
argument_list|,
name|REGEXP_REPEAT
argument_list|(
name|regexp
argument_list|)
operator|->
name|repeat_num
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|irp
argument_list|,
name|digits
argument_list|,
name|strlen
argument_list|(
name|digits
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regexp
operator|->
name|mode
operator|==
name|rm_nothing
condition|)
name|obstack_grow
argument_list|(
operator|&
name|irp
argument_list|,
name|NOTHING_NAME
argument_list|,
name|strlen
argument_list|(
name|NOTHING_NAME
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function returns string representation of REGEXP on IR    obstack.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|regexp_representation
parameter_list|(
name|regexp
parameter_list|)
name|regexp_t
name|regexp
decl_stmt|;
block|{
name|form_regexp
argument_list|(
name|regexp
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|irp
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
return|return
name|obstack_base
argument_list|(
operator|&
name|irp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The function frees memory allocated for last formed string    representation of regexp.  */
end_comment

begin_function
specifier|static
name|void
name|finish_regexp_representation
parameter_list|()
block|{
name|int
name|length
init|=
name|obstack_object_size
argument_list|(
operator|&
name|irp
argument_list|)
decl_stmt|;
name|obstack_blank_fast
argument_list|(
operator|&
name|irp
argument_list|,
operator|-
name|length
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This page contains code for output PHR (pipeline hazards recognizer).  */
end_comment

begin_comment
comment|/* The function outputs minimal C type which is sufficient for    representation numbers in range min_range_value and    max_range_value.  Because host machine and build machine may be    different, we use here minimal values required by ANSI C standard    instead of UCHAR_MAX, SHRT_MAX, SHRT_MIN, etc.  This is a good    approximation.  */
end_comment

begin_function
specifier|static
name|void
name|output_range_type
parameter_list|(
name|f
parameter_list|,
name|min_range_value
parameter_list|,
name|max_range_value
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
name|long
name|int
name|min_range_value
decl_stmt|;
name|long
name|int
name|max_range_value
decl_stmt|;
block|{
if|if
condition|(
name|min_range_value
operator|>=
literal|0
operator|&&
name|max_range_value
operator|<=
literal|255
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"unsigned char"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|min_range_value
operator|>=
operator|-
literal|127
operator|&&
name|max_range_value
operator|<=
literal|127
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"signed char"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|min_range_value
operator|>=
literal|0
operator|&&
name|max_range_value
operator|<=
literal|65535
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"unsigned short"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|min_range_value
operator|>=
operator|-
literal|32767
operator|&&
name|max_range_value
operator|<=
literal|32767
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"short"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"int"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The following macro value is used as value of member    `longest_path_length' of state when we are processing path and the    state on the path.  */
end_comment

begin_define
define|#
directive|define
name|ON_THE_PATH
value|-2
end_define

begin_comment
comment|/* The following recursive function searches for the length of the    longest path starting from STATE which does not contain cycles and    `cycle advance' arcs.  */
end_comment

begin_function
specifier|static
name|int
name|longest_path_length
parameter_list|(
name|state
parameter_list|)
name|state_t
name|state
decl_stmt|;
block|{
name|arc_t
name|arc
decl_stmt|;
name|int
name|length
decl_stmt|,
name|result
decl_stmt|;
if|if
condition|(
name|state
operator|->
name|longest_path_length
operator|==
name|ON_THE_PATH
condition|)
comment|/* We don't expect the path cycle here.  Our graph may contain        only cycles with one state on the path not containing `cycle        advance' arcs -- see comment below.  */
name|abort
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|state
operator|->
name|longest_path_length
operator|!=
name|UNDEFINED_LONGEST_PATH_LENGTH
condition|)
comment|/* We alreday visited the state.  */
return|return
name|state
operator|->
name|longest_path_length
return|;
name|result
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|arc
operator|=
name|first_out_arc
argument_list|(
name|state
argument_list|)
init|;
name|arc
operator|!=
name|NULL
condition|;
name|arc
operator|=
name|next_out_arc
argument_list|(
name|arc
argument_list|)
control|)
comment|/* Ignore cycles containing one state and `cycle advance' arcs.  */
if|if
condition|(
name|arc
operator|->
name|to_state
operator|!=
name|state
operator|&&
operator|(
name|arc
operator|->
name|insn
operator|->
name|insn_reserv_decl
operator|!=
name|DECL_INSN_RESERV
argument_list|(
name|advance_cycle_insn_decl
argument_list|)
operator|)
condition|)
block|{
name|length
operator|=
name|longest_path_length
argument_list|(
name|arc
operator|->
name|to_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|>
name|result
condition|)
name|result
operator|=
name|length
expr_stmt|;
block|}
name|state
operator|->
name|longest_path_length
operator|=
name|result
operator|+
literal|1
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* The following variable value is value of the corresponding global    variable in the automaton based pipeline interface.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_dfa_issue_rate
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following function processes the longest path length staring    from STATE to find MAX_DFA_ISSUE_RATE.  */
end_comment

begin_function
specifier|static
name|void
name|process_state_longest_path_length
parameter_list|(
name|state
parameter_list|)
name|state_t
name|state
decl_stmt|;
block|{
name|int
name|value
decl_stmt|;
name|value
operator|=
name|longest_path_length
argument_list|(
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|>
name|max_dfa_issue_rate
condition|)
name|max_dfa_issue_rate
operator|=
name|value
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The following macro value is name of the corresponding global    variable in the automaton based pipeline interface.  */
end_comment

begin_define
define|#
directive|define
name|MAX_DFA_ISSUE_RATE_VAR_NAME
value|"max_dfa_issue_rate"
end_define

begin_comment
comment|/* The following function calculates value of the corresponding    global variable and outputs its declaration.  */
end_comment

begin_function
specifier|static
name|void
name|output_dfa_max_issue_rate
parameter_list|()
block|{
name|automaton_t
name|automaton
decl_stmt|;
if|if
condition|(
name|UNDEFINED_LONGEST_PATH_LENGTH
operator|==
name|ON_THE_PATH
operator|||
name|ON_THE_PATH
operator|>=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|max_dfa_issue_rate
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|automaton
operator|=
name|description
operator|->
name|first_automaton
init|;
name|automaton
operator|!=
name|NULL
condition|;
name|automaton
operator|=
name|automaton
operator|->
name|next_automaton
control|)
name|pass_states
argument_list|(
name|automaton
argument_list|,
name|process_state_longest_path_length
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\nint %s = %d;\n"
argument_list|,
name|MAX_DFA_ISSUE_RATE_VAR_NAME
argument_list|,
name|max_dfa_issue_rate
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function outputs all initialization values of VECT with length    vect_length.  */
end_comment

begin_function
specifier|static
name|void
name|output_vect
parameter_list|(
name|vect
parameter_list|,
name|vect_length
parameter_list|)
name|vect_el_t
modifier|*
name|vect
decl_stmt|;
name|int
name|vect_length
decl_stmt|;
block|{
name|int
name|els_on_line
decl_stmt|;
name|els_on_line
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|vect_length
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"0 /* This is dummy el because the vect is empty */"
argument_list|)
expr_stmt|;
else|else
block|{
do|do
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"%5ld"
argument_list|,
operator|(
name|long
operator|)
operator|*
name|vect
argument_list|)
expr_stmt|;
name|vect_length
operator|--
expr_stmt|;
if|if
condition|(
name|els_on_line
operator|==
literal|10
condition|)
block|{
name|els_on_line
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|",\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vect_length
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|els_on_line
operator|++
expr_stmt|;
name|vect
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|vect_length
operator|!=
literal|0
condition|)
do|;
block|}
block|}
end_function

begin_comment
comment|/* The following is name of the structure which represents DFA(s) for    PHR.  */
end_comment

begin_define
define|#
directive|define
name|CHIP_NAME
value|"DFA_chip"
end_define

begin_comment
comment|/* The following is name of member which represents state of a DFA for    PHR.  */
end_comment

begin_function
specifier|static
name|void
name|output_chip_member_name
parameter_list|(
name|f
parameter_list|,
name|automaton
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
name|automaton_t
name|automaton
decl_stmt|;
block|{
if|if
condition|(
name|automaton
operator|->
name|corresponding_automaton_decl
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"automaton_state_%d"
argument_list|,
name|automaton
operator|->
name|automaton_order_num
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s_automaton_state"
argument_list|,
name|automaton
operator|->
name|corresponding_automaton_decl
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The following is name of temporary variable which stores state of a    DFA for PHR.  */
end_comment

begin_function
specifier|static
name|void
name|output_temp_chip_member_name
parameter_list|(
name|f
parameter_list|,
name|automaton
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
name|automaton_t
name|automaton
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"_"
argument_list|)
expr_stmt|;
name|output_chip_member_name
argument_list|(
name|f
argument_list|,
name|automaton
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is name of macro value which is code of pseudo_insn    representing advancing cpu cycle.  Its value is used as internal    code unknown insn.  */
end_comment

begin_define
define|#
directive|define
name|ADVANCE_CYCLE_VALUE_NAME
value|"DFA__ADVANCE_CYCLE"
end_define

begin_comment
comment|/* Output name of translate vector for given automaton.  */
end_comment

begin_function
specifier|static
name|void
name|output_translate_vect_name
parameter_list|(
name|f
parameter_list|,
name|automaton
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
name|automaton_t
name|automaton
decl_stmt|;
block|{
if|if
condition|(
name|automaton
operator|->
name|corresponding_automaton_decl
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"translate_%d"
argument_list|,
name|automaton
operator|->
name|automaton_order_num
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s_translate"
argument_list|,
name|automaton
operator|->
name|corresponding_automaton_decl
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output name for simple transition table representation.  */
end_comment

begin_function
specifier|static
name|void
name|output_trans_full_vect_name
parameter_list|(
name|f
parameter_list|,
name|automaton
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
name|automaton_t
name|automaton
decl_stmt|;
block|{
if|if
condition|(
name|automaton
operator|->
name|corresponding_automaton_decl
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"transitions_%d"
argument_list|,
name|automaton
operator|->
name|automaton_order_num
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s_transitions"
argument_list|,
name|automaton
operator|->
name|corresponding_automaton_decl
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output name of comb vector of the transition table for given    automaton.  */
end_comment

begin_function
specifier|static
name|void
name|output_trans_comb_vect_name
parameter_list|(
name|f
parameter_list|,
name|automaton
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
name|automaton_t
name|automaton
decl_stmt|;
block|{
if|if
condition|(
name|automaton
operator|->
name|corresponding_automaton_decl
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"transitions_%d"
argument_list|,
name|automaton
operator|->
name|automaton_order_num
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s_transitions"
argument_list|,
name|automaton
operator|->
name|corresponding_automaton_decl
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output name of check vector of the transition table for given    automaton.  */
end_comment

begin_function
specifier|static
name|void
name|output_trans_check_vect_name
parameter_list|(
name|f
parameter_list|,
name|automaton
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
name|automaton_t
name|automaton
decl_stmt|;
block|{
if|if
condition|(
name|automaton
operator|->
name|corresponding_automaton_decl
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"check_%d"
argument_list|,
name|automaton
operator|->
name|automaton_order_num
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s_check"
argument_list|,
name|automaton
operator|->
name|corresponding_automaton_decl
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output name of base vector of the transition table for given    automaton.  */
end_comment

begin_function
specifier|static
name|void
name|output_trans_base_vect_name
parameter_list|(
name|f
parameter_list|,
name|automaton
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
name|automaton_t
name|automaton
decl_stmt|;
block|{
if|if
condition|(
name|automaton
operator|->
name|corresponding_automaton_decl
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"base_%d"
argument_list|,
name|automaton
operator|->
name|automaton_order_num
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s_base"
argument_list|,
name|automaton
operator|->
name|corresponding_automaton_decl
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output name for simple alternatives number representation.  */
end_comment

begin_function
specifier|static
name|void
name|output_state_alts_full_vect_name
parameter_list|(
name|f
parameter_list|,
name|automaton
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
name|automaton_t
name|automaton
decl_stmt|;
block|{
if|if
condition|(
name|automaton
operator|->
name|corresponding_automaton_decl
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"state_alts_%d"
argument_list|,
name|automaton
operator|->
name|automaton_order_num
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s_state_alts"
argument_list|,
name|automaton
operator|->
name|corresponding_automaton_decl
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output name of comb vector of the alternatives number table for given    automaton.  */
end_comment

begin_function
specifier|static
name|void
name|output_state_alts_comb_vect_name
parameter_list|(
name|f
parameter_list|,
name|automaton
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
name|automaton_t
name|automaton
decl_stmt|;
block|{
if|if
condition|(
name|automaton
operator|->
name|corresponding_automaton_decl
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"state_alts_%d"
argument_list|,
name|automaton
operator|->
name|automaton_order_num
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s_state_alts"
argument_list|,
name|automaton
operator|->
name|corresponding_automaton_decl
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output name of check vector of the alternatives number table for given    automaton.  */
end_comment

begin_function
specifier|static
name|void
name|output_state_alts_check_vect_name
parameter_list|(
name|f
parameter_list|,
name|automaton
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
name|automaton_t
name|automaton
decl_stmt|;
block|{
if|if
condition|(
name|automaton
operator|->
name|corresponding_automaton_decl
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"check_state_alts_%d"
argument_list|,
name|automaton
operator|->
name|automaton_order_num
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s_check_state_alts"
argument_list|,
name|automaton
operator|->
name|corresponding_automaton_decl
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output name of base vector of the alternatives number table for given    automaton.  */
end_comment

begin_function
specifier|static
name|void
name|output_state_alts_base_vect_name
parameter_list|(
name|f
parameter_list|,
name|automaton
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
name|automaton_t
name|automaton
decl_stmt|;
block|{
if|if
condition|(
name|automaton
operator|->
name|corresponding_automaton_decl
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"base_state_alts_%d"
argument_list|,
name|automaton
operator|->
name|automaton_order_num
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s_base_state_alts"
argument_list|,
name|automaton
operator|->
name|corresponding_automaton_decl
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output name of simple min issue delay table representation.  */
end_comment

begin_function
specifier|static
name|void
name|output_min_issue_delay_vect_name
parameter_list|(
name|f
parameter_list|,
name|automaton
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
name|automaton_t
name|automaton
decl_stmt|;
block|{
if|if
condition|(
name|automaton
operator|->
name|corresponding_automaton_decl
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"min_issue_delay_%d"
argument_list|,
name|automaton
operator|->
name|automaton_order_num
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s_min_issue_delay"
argument_list|,
name|automaton
operator|->
name|corresponding_automaton_decl
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output name of deadlock vector for given automaton.  */
end_comment

begin_function
specifier|static
name|void
name|output_dead_lock_vect_name
parameter_list|(
name|f
parameter_list|,
name|automaton
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
name|automaton_t
name|automaton
decl_stmt|;
block|{
if|if
condition|(
name|automaton
operator|->
name|corresponding_automaton_decl
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"dead_lock_%d"
argument_list|,
name|automaton
operator|->
name|automaton_order_num
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s_dead_lock"
argument_list|,
name|automaton
operator|->
name|corresponding_automaton_decl
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output name of reserved units table for AUTOMATON into file F.  */
end_comment

begin_function
specifier|static
name|void
name|output_reserved_units_table_name
parameter_list|(
name|f
parameter_list|,
name|automaton
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
name|automaton_t
name|automaton
decl_stmt|;
block|{
if|if
condition|(
name|automaton
operator|->
name|corresponding_automaton_decl
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"reserved_units_%d"
argument_list|,
name|automaton
operator|->
name|automaton_order_num
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s_reserved_units"
argument_list|,
name|automaton
operator|->
name|corresponding_automaton_decl
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Name of the PHR interface macro.  */
end_comment

begin_define
define|#
directive|define
name|AUTOMATON_STATE_ALTS_MACRO_NAME
value|"AUTOMATON_STATE_ALTS"
end_define

begin_comment
comment|/* Name of the PHR interface macro.  */
end_comment

begin_define
define|#
directive|define
name|CPU_UNITS_QUERY_MACRO_NAME
value|"CPU_UNITS_QUERY"
end_define

begin_comment
comment|/* Names of an internal functions: */
end_comment

begin_define
define|#
directive|define
name|INTERNAL_MIN_ISSUE_DELAY_FUNC_NAME
value|"internal_min_issue_delay"
end_define

begin_comment
comment|/* This is external type of DFA(s) state.  */
end_comment

begin_define
define|#
directive|define
name|STATE_TYPE_NAME
value|"state_t"
end_define

begin_define
define|#
directive|define
name|INTERNAL_TRANSITION_FUNC_NAME
value|"internal_state_transition"
end_define

begin_define
define|#
directive|define
name|INTERNAL_STATE_ALTS_FUNC_NAME
value|"internal_state_alts"
end_define

begin_define
define|#
directive|define
name|INTERNAL_RESET_FUNC_NAME
value|"internal_reset"
end_define

begin_define
define|#
directive|define
name|INTERNAL_DEAD_LOCK_FUNC_NAME
value|"internal_state_dead_lock_p"
end_define

begin_define
define|#
directive|define
name|INTERNAL_INSN_LATENCY_FUNC_NAME
value|"internal_insn_latency"
end_define

begin_comment
comment|/* Name of cache of insn dfa codes.  */
end_comment

begin_define
define|#
directive|define
name|DFA_INSN_CODES_VARIABLE_NAME
value|"dfa_insn_codes"
end_define

begin_comment
comment|/* Name of length of cache of insn dfa codes.  */
end_comment

begin_define
define|#
directive|define
name|DFA_INSN_CODES_LENGTH_VARIABLE_NAME
value|"dfa_insn_codes_length"
end_define

begin_comment
comment|/* Names of the PHR interface functions: */
end_comment

begin_define
define|#
directive|define
name|SIZE_FUNC_NAME
value|"state_size"
end_define

begin_define
define|#
directive|define
name|TRANSITION_FUNC_NAME
value|"state_transition"
end_define

begin_define
define|#
directive|define
name|STATE_ALTS_FUNC_NAME
value|"state_alts"
end_define

begin_define
define|#
directive|define
name|MIN_ISSUE_DELAY_FUNC_NAME
value|"min_issue_delay"
end_define

begin_define
define|#
directive|define
name|MIN_INSN_CONFLICT_DELAY_FUNC_NAME
value|"min_insn_conflict_delay"
end_define

begin_define
define|#
directive|define
name|DEAD_LOCK_FUNC_NAME
value|"state_dead_lock_p"
end_define

begin_define
define|#
directive|define
name|RESET_FUNC_NAME
value|"state_reset"
end_define

begin_define
define|#
directive|define
name|INSN_LATENCY_FUNC_NAME
value|"insn_latency"
end_define

begin_define
define|#
directive|define
name|PRINT_RESERVATION_FUNC_NAME
value|"print_reservation"
end_define

begin_define
define|#
directive|define
name|GET_CPU_UNIT_CODE_FUNC_NAME
value|"get_cpu_unit_code"
end_define

begin_define
define|#
directive|define
name|CPU_UNIT_RESERVATION_P_FUNC_NAME
value|"cpu_unit_reservation_p"
end_define

begin_define
define|#
directive|define
name|DFA_START_FUNC_NAME
value|"dfa_start"
end_define

begin_define
define|#
directive|define
name|DFA_FINISH_FUNC_NAME
value|"dfa_finish"
end_define

begin_comment
comment|/* Names of parameters of the PHR interface functions.  */
end_comment

begin_define
define|#
directive|define
name|STATE_NAME
value|"state"
end_define

begin_define
define|#
directive|define
name|INSN_PARAMETER_NAME
value|"insn"
end_define

begin_define
define|#
directive|define
name|INSN2_PARAMETER_NAME
value|"insn2"
end_define

begin_define
define|#
directive|define
name|CHIP_PARAMETER_NAME
value|"chip"
end_define

begin_define
define|#
directive|define
name|FILE_PARAMETER_NAME
value|"f"
end_define

begin_define
define|#
directive|define
name|CPU_UNIT_NAME_PARAMETER_NAME
value|"cpu_unit_name"
end_define

begin_define
define|#
directive|define
name|CPU_CODE_PARAMETER_NAME
value|"cpu_unit_code"
end_define

begin_comment
comment|/* Names of the variables whose values are internal insn code of rtx    insn.  */
end_comment

begin_define
define|#
directive|define
name|INTERNAL_INSN_CODE_NAME
value|"insn_code"
end_define

begin_define
define|#
directive|define
name|INTERNAL_INSN2_CODE_NAME
value|"insn2_code"
end_define

begin_comment
comment|/* Names of temporary variables in some functions.  */
end_comment

begin_define
define|#
directive|define
name|TEMPORARY_VARIABLE_NAME
value|"temp"
end_define

begin_define
define|#
directive|define
name|I_VARIABLE_NAME
value|"i"
end_define

begin_comment
comment|/* Name of result variable in some functions.  */
end_comment

begin_define
define|#
directive|define
name|RESULT_VARIABLE_NAME
value|"res"
end_define

begin_comment
comment|/* Name of function (attribute) to translate insn into number of insn    alternatives reservation.  */
end_comment

begin_define
define|#
directive|define
name|INSN_ALTS_FUNC_NAME
value|"insn_alts"
end_define

begin_comment
comment|/* Name of function (attribute) to translate insn into internal insn    code.  */
end_comment

begin_define
define|#
directive|define
name|INTERNAL_DFA_INSN_CODE_FUNC_NAME
value|"internal_dfa_insn_code"
end_define

begin_comment
comment|/* Name of function (attribute) to translate insn into internal insn    code with caching.  */
end_comment

begin_define
define|#
directive|define
name|DFA_INSN_CODE_FUNC_NAME
value|"dfa_insn_code"
end_define

begin_comment
comment|/* Name of function (attribute) to translate insn into internal insn    code.  */
end_comment

begin_define
define|#
directive|define
name|INSN_DEFAULT_LATENCY_FUNC_NAME
value|"insn_default_latency"
end_define

begin_comment
comment|/* Name of function (attribute) to translate insn into internal insn    code.  */
end_comment

begin_define
define|#
directive|define
name|BYPASS_P_FUNC_NAME
value|"bypass_p"
end_define

begin_comment
comment|/* Output C type which is used for representation of codes of states    of AUTOMATON.  */
end_comment

begin_function
specifier|static
name|void
name|output_state_member_type
parameter_list|(
name|f
parameter_list|,
name|automaton
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
name|automaton_t
name|automaton
decl_stmt|;
block|{
name|output_range_type
argument_list|(
name|f
argument_list|,
literal|0
argument_list|,
name|automaton
operator|->
name|achieved_states_num
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output definition of the structure representing current DFA(s)    state(s).  */
end_comment

begin_function
specifier|static
name|void
name|output_chip_definitions
parameter_list|()
block|{
name|automaton_t
name|automaton
decl_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"struct %s\n{\n"
argument_list|,
name|CHIP_NAME
argument_list|)
expr_stmt|;
for|for
control|(
name|automaton
operator|=
name|description
operator|->
name|first_automaton
init|;
name|automaton
operator|!=
name|NULL
condition|;
name|automaton
operator|=
name|automaton
operator|->
name|next_automaton
control|)
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"  "
argument_list|)
expr_stmt|;
name|output_state_member_type
argument_list|(
name|output_file
argument_list|,
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|output_chip_member_name
argument_list|(
name|output_file
argument_list|,
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|";\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"};\n\n"
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|fprintf (output_file, "static struct %s %s;\n\n", CHIP_NAME, CHIP_NAME);
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* The function outputs translate vector of internal insn code into    insn equivalence class number.  The equivalence class number is    used to access to table and vectors reprewsenting DFA(s).  */
end_comment

begin_function
specifier|static
name|void
name|output_translate_vect
parameter_list|(
name|automaton
parameter_list|)
name|automaton_t
name|automaton
decl_stmt|;
block|{
name|ainsn_t
name|ainsn
decl_stmt|;
name|int
name|insn_value
decl_stmt|;
name|vla_hwint_t
name|translate_vect
decl_stmt|;
name|VLA_HWINT_CREATE
argument_list|(
name|translate_vect
argument_list|,
literal|250
argument_list|,
literal|"translate vector"
argument_list|)
expr_stmt|;
name|VLA_HWINT_EXPAND
argument_list|(
name|translate_vect
argument_list|,
name|description
operator|->
name|insns_num
argument_list|)
expr_stmt|;
for|for
control|(
name|insn_value
operator|=
literal|0
init|;
name|insn_value
operator|<=
name|description
operator|->
name|insns_num
condition|;
name|insn_value
operator|++
control|)
comment|/* Undefined value */
name|VLA_HWINT
argument_list|(
name|translate_vect
argument_list|,
name|insn_value
argument_list|)
operator|=
name|automaton
operator|->
name|insn_equiv_classes_num
expr_stmt|;
for|for
control|(
name|ainsn
operator|=
name|automaton
operator|->
name|ainsn_list
init|;
name|ainsn
operator|!=
name|NULL
condition|;
name|ainsn
operator|=
name|ainsn
operator|->
name|next_ainsn
control|)
name|VLA_HWINT
argument_list|(
name|translate_vect
argument_list|,
name|ainsn
operator|->
name|insn_reserv_decl
operator|->
name|insn_num
argument_list|)
operator|=
name|ainsn
operator|->
name|insn_equiv_class_num
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"/* Vector translating external insn codes to internal ones.*/\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"static const "
argument_list|)
expr_stmt|;
name|output_range_type
argument_list|(
name|output_file
argument_list|,
literal|0
argument_list|,
name|automaton
operator|->
name|insn_equiv_classes_num
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|output_translate_vect_name
argument_list|(
name|output_file
argument_list|,
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"[] ATTRIBUTE_UNUSED = {\n"
argument_list|)
expr_stmt|;
name|output_vect
argument_list|(
name|VLA_HWINT_BEGIN
argument_list|(
name|translate_vect
argument_list|)
argument_list|,
name|VLA_HWINT_LENGTH
argument_list|(
name|translate_vect
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"};\n\n"
argument_list|)
expr_stmt|;
name|VLA_HWINT_DELETE
argument_list|(
name|translate_vect
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The value in a table state x ainsn -> something which represents    undefined value.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|undefined_vect_el_value
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following function returns nonzero value if the best    representation of the table is comb vector.  */
end_comment

begin_function
specifier|static
name|int
name|comb_vect_p
parameter_list|(
name|tab
parameter_list|)
name|state_ainsn_table_t
name|tab
decl_stmt|;
block|{
return|return
operator|(
literal|2
operator|*
name|VLA_HWINT_LENGTH
argument_list|(
name|tab
operator|->
name|full_vect
argument_list|)
operator|>
literal|5
operator|*
name|VLA_HWINT_LENGTH
argument_list|(
name|tab
operator|->
name|comb_vect
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* The following function creates new table for AUTOMATON.  */
end_comment

begin_function
specifier|static
name|state_ainsn_table_t
name|create_state_ainsn_table
parameter_list|(
name|automaton
parameter_list|)
name|automaton_t
name|automaton
decl_stmt|;
block|{
name|state_ainsn_table_t
name|tab
decl_stmt|;
name|int
name|full_vect_length
decl_stmt|;
name|int
name|i
decl_stmt|;
name|tab
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|state_ainsn_table
argument_list|)
argument_list|)
expr_stmt|;
name|tab
operator|->
name|automaton
operator|=
name|automaton
expr_stmt|;
name|VLA_HWINT_CREATE
argument_list|(
name|tab
operator|->
name|comb_vect
argument_list|,
literal|10000
argument_list|,
literal|"comb vector"
argument_list|)
expr_stmt|;
name|VLA_HWINT_CREATE
argument_list|(
name|tab
operator|->
name|check_vect
argument_list|,
literal|10000
argument_list|,
literal|"check vector"
argument_list|)
expr_stmt|;
name|VLA_HWINT_CREATE
argument_list|(
name|tab
operator|->
name|base_vect
argument_list|,
literal|1000
argument_list|,
literal|"base vector"
argument_list|)
expr_stmt|;
name|VLA_HWINT_EXPAND
argument_list|(
name|tab
operator|->
name|base_vect
argument_list|,
name|automaton
operator|->
name|achieved_states_num
argument_list|)
expr_stmt|;
name|VLA_HWINT_CREATE
argument_list|(
name|tab
operator|->
name|full_vect
argument_list|,
literal|10000
argument_list|,
literal|"full vector"
argument_list|)
expr_stmt|;
name|full_vect_length
operator|=
operator|(
name|automaton
operator|->
name|insn_equiv_classes_num
operator|*
name|automaton
operator|->
name|achieved_states_num
operator|)
expr_stmt|;
name|VLA_HWINT_EXPAND
argument_list|(
name|tab
operator|->
name|full_vect
argument_list|,
name|full_vect_length
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|full_vect_length
condition|;
name|i
operator|++
control|)
name|VLA_HWINT
argument_list|(
name|tab
operator|->
name|full_vect
argument_list|,
name|i
argument_list|)
operator|=
name|undefined_vect_el_value
expr_stmt|;
name|tab
operator|->
name|min_base_vect_el_value
operator|=
literal|0
expr_stmt|;
name|tab
operator|->
name|max_base_vect_el_value
operator|=
literal|0
expr_stmt|;
name|tab
operator|->
name|min_comb_vect_el_value
operator|=
literal|0
expr_stmt|;
name|tab
operator|->
name|max_comb_vect_el_value
operator|=
literal|0
expr_stmt|;
return|return
name|tab
return|;
block|}
end_function

begin_comment
comment|/* The following function outputs the best C representation of the    table TAB of given TABLE_NAME.  */
end_comment

begin_function_decl
specifier|static
name|void
name|output_state_ainsn_table
parameter_list|(
name|tab
parameter_list|,
name|table_name
parameter_list|,
name|output_full_vect_name_func
parameter_list|,
name|output_comb_vect_name_func
parameter_list|,
name|output_check_vect_name_func
parameter_list|,
name|output_base_vect_name_func
parameter_list|)
name|state_ainsn_table_t
name|tab
decl_stmt|;
name|char
modifier|*
name|table_name
decl_stmt|;
function_decl|void
parameter_list|(
function_decl|*output_full_vect_name_func
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|automaton_t
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|void
argument_list|(
argument|*output_comb_vect_name_func
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|automaton_t
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|void
argument_list|(
argument|*output_check_vect_name_func
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|automaton_t
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|void
argument_list|(
argument|*output_base_vect_name_func
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|automaton_t
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|comb_vect_p
argument_list|(
name|tab
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"/* Vector for %s.  */\n"
argument_list|,
name|table_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"static const "
argument_list|)
expr_stmt|;
name|output_range_type
argument_list|(
name|output_file
argument_list|,
name|tab
operator|->
name|min_comb_vect_el_value
argument_list|,
name|tab
operator|->
name|max_comb_vect_el_value
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
call|(
modifier|*
name|output_full_vect_name_func
call|)
argument_list|(
name|output_file
argument_list|,
name|tab
operator|->
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"[] ATTRIBUTE_UNUSED = {\n"
argument_list|)
expr_stmt|;
name|output_vect
argument_list|(
name|VLA_HWINT_BEGIN
argument_list|(
name|tab
operator|->
name|full_vect
argument_list|)
argument_list|,
name|VLA_HWINT_LENGTH
argument_list|(
name|tab
operator|->
name|full_vect
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"};\n\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"/* Comb vector for %s.  */\n"
argument_list|,
name|table_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"static const "
argument_list|)
expr_stmt|;
name|output_range_type
argument_list|(
name|output_file
argument_list|,
name|tab
operator|->
name|min_comb_vect_el_value
argument_list|,
name|tab
operator|->
name|max_comb_vect_el_value
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
call|(
modifier|*
name|output_comb_vect_name_func
call|)
argument_list|(
name|output_file
argument_list|,
name|tab
operator|->
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"[] ATTRIBUTE_UNUSED = {\n"
argument_list|)
expr_stmt|;
name|output_vect
argument_list|(
name|VLA_HWINT_BEGIN
argument_list|(
name|tab
operator|->
name|comb_vect
argument_list|)
argument_list|,
name|VLA_HWINT_LENGTH
argument_list|(
name|tab
operator|->
name|comb_vect
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"};\n\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"/* Check vector for %s.  */\n"
argument_list|,
name|table_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"static const "
argument_list|)
expr_stmt|;
name|output_range_type
argument_list|(
name|output_file
argument_list|,
literal|0
argument_list|,
name|tab
operator|->
name|automaton
operator|->
name|achieved_states_num
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
call|(
modifier|*
name|output_check_vect_name_func
call|)
argument_list|(
name|output_file
argument_list|,
name|tab
operator|->
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"[] = {\n"
argument_list|)
expr_stmt|;
name|output_vect
argument_list|(
name|VLA_HWINT_BEGIN
argument_list|(
name|tab
operator|->
name|check_vect
argument_list|)
argument_list|,
name|VLA_HWINT_LENGTH
argument_list|(
name|tab
operator|->
name|check_vect
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"};\n\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"/* Base vector for %s.  */\n"
argument_list|,
name|table_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"static const "
argument_list|)
expr_stmt|;
name|output_range_type
argument_list|(
name|output_file
argument_list|,
name|tab
operator|->
name|min_base_vect_el_value
argument_list|,
name|tab
operator|->
name|max_base_vect_el_value
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
call|(
modifier|*
name|output_base_vect_name_func
call|)
argument_list|(
name|output_file
argument_list|,
name|tab
operator|->
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"[] = {\n"
argument_list|)
expr_stmt|;
name|output_vect
argument_list|(
name|VLA_HWINT_BEGIN
argument_list|(
name|tab
operator|->
name|base_vect
argument_list|)
argument_list|,
name|VLA_HWINT_LENGTH
argument_list|(
name|tab
operator|->
name|base_vect
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"};\n\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* The following function adds vector with length VECT_LENGTH and    elements pointed by VECT to table TAB as its line with number    VECT_NUM.  */
end_comment

begin_function
specifier|static
name|void
name|add_vect
parameter_list|(
name|tab
parameter_list|,
name|vect_num
parameter_list|,
name|vect
parameter_list|,
name|vect_length
parameter_list|)
name|state_ainsn_table_t
name|tab
decl_stmt|;
name|int
name|vect_num
decl_stmt|;
name|vect_el_t
modifier|*
name|vect
decl_stmt|;
name|int
name|vect_length
decl_stmt|;
block|{
name|int
name|real_vect_length
decl_stmt|;
name|vect_el_t
modifier|*
name|comb_vect_start
decl_stmt|;
name|vect_el_t
modifier|*
name|check_vect_start
decl_stmt|;
name|int
name|comb_vect_index
decl_stmt|;
name|int
name|comb_vect_els_num
decl_stmt|;
name|int
name|vect_index
decl_stmt|;
name|int
name|first_unempty_vect_index
decl_stmt|;
name|int
name|additional_els_num
decl_stmt|;
name|int
name|no_state_value
decl_stmt|;
name|vect_el_t
name|vect_el
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|vect_length
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|real_vect_length
operator|=
name|tab
operator|->
name|automaton
operator|->
name|insn_equiv_classes_num
expr_stmt|;
if|if
condition|(
name|vect
index|[
name|vect_length
operator|-
literal|1
index|]
operator|==
name|undefined_vect_el_value
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Form full vector in the table: */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vect_length
condition|;
name|i
operator|++
control|)
name|VLA_HWINT
argument_list|(
name|tab
operator|->
name|full_vect
argument_list|,
name|i
operator|+
name|tab
operator|->
name|automaton
operator|->
name|insn_equiv_classes_num
operator|*
name|vect_num
argument_list|)
operator|=
name|vect
index|[
name|i
index|]
expr_stmt|;
comment|/* Form comb vector in the table: */
if|if
condition|(
name|VLA_HWINT_LENGTH
argument_list|(
name|tab
operator|->
name|comb_vect
argument_list|)
operator|!=
name|VLA_HWINT_LENGTH
argument_list|(
name|tab
operator|->
name|check_vect
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|comb_vect_start
operator|=
name|VLA_HWINT_BEGIN
argument_list|(
name|tab
operator|->
name|comb_vect
argument_list|)
expr_stmt|;
name|comb_vect_els_num
operator|=
name|VLA_HWINT_LENGTH
argument_list|(
name|tab
operator|->
name|comb_vect
argument_list|)
expr_stmt|;
for|for
control|(
name|first_unempty_vect_index
operator|=
literal|0
init|;
name|first_unempty_vect_index
operator|<
name|vect_length
condition|;
name|first_unempty_vect_index
operator|++
control|)
if|if
condition|(
name|vect
index|[
name|first_unempty_vect_index
index|]
operator|!=
name|undefined_vect_el_value
condition|)
break|break;
comment|/* Search for the place in comb vect for the inserted vect.  */
for|for
control|(
name|comb_vect_index
operator|=
literal|0
init|;
name|comb_vect_index
operator|<
name|comb_vect_els_num
condition|;
name|comb_vect_index
operator|++
control|)
block|{
for|for
control|(
name|vect_index
operator|=
name|first_unempty_vect_index
init|;
name|vect_index
operator|<
name|vect_length
operator|&&
name|vect_index
operator|+
name|comb_vect_index
operator|<
name|comb_vect_els_num
condition|;
name|vect_index
operator|++
control|)
if|if
condition|(
name|vect
index|[
name|vect_index
index|]
operator|!=
name|undefined_vect_el_value
operator|&&
operator|(
name|comb_vect_start
index|[
name|vect_index
operator|+
name|comb_vect_index
index|]
operator|!=
name|undefined_vect_el_value
operator|)
condition|)
break|break;
if|if
condition|(
name|vect_index
operator|>=
name|vect_length
operator|||
name|vect_index
operator|+
name|comb_vect_index
operator|>=
name|comb_vect_els_num
condition|)
break|break;
block|}
comment|/* Slot was found.  */
name|additional_els_num
operator|=
name|comb_vect_index
operator|+
name|real_vect_length
operator|-
name|comb_vect_els_num
expr_stmt|;
if|if
condition|(
name|additional_els_num
operator|<
literal|0
condition|)
name|additional_els_num
operator|=
literal|0
expr_stmt|;
comment|/* Expand comb and check vectors.  */
name|vect_el
operator|=
name|undefined_vect_el_value
expr_stmt|;
name|no_state_value
operator|=
name|tab
operator|->
name|automaton
operator|->
name|achieved_states_num
expr_stmt|;
while|while
condition|(
name|additional_els_num
operator|>
literal|0
condition|)
block|{
name|VLA_HWINT_ADD
argument_list|(
name|tab
operator|->
name|comb_vect
argument_list|,
name|vect_el
argument_list|)
expr_stmt|;
name|VLA_HWINT_ADD
argument_list|(
name|tab
operator|->
name|check_vect
argument_list|,
name|no_state_value
argument_list|)
expr_stmt|;
name|additional_els_num
operator|--
expr_stmt|;
block|}
name|comb_vect_start
operator|=
name|VLA_HWINT_BEGIN
argument_list|(
name|tab
operator|->
name|comb_vect
argument_list|)
expr_stmt|;
name|check_vect_start
operator|=
name|VLA_HWINT_BEGIN
argument_list|(
name|tab
operator|->
name|check_vect
argument_list|)
expr_stmt|;
if|if
condition|(
name|VLA_HWINT_LENGTH
argument_list|(
name|tab
operator|->
name|comb_vect
argument_list|)
operator|<
call|(
name|size_t
call|)
argument_list|(
name|comb_vect_index
operator|+
name|real_vect_length
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Fill comb and check vectors.  */
for|for
control|(
name|vect_index
operator|=
literal|0
init|;
name|vect_index
operator|<
name|vect_length
condition|;
name|vect_index
operator|++
control|)
if|if
condition|(
name|vect
index|[
name|vect_index
index|]
operator|!=
name|undefined_vect_el_value
condition|)
block|{
if|if
condition|(
name|comb_vect_start
index|[
name|comb_vect_index
operator|+
name|vect_index
index|]
operator|!=
name|undefined_vect_el_value
condition|)
name|abort
argument_list|()
expr_stmt|;
name|comb_vect_start
index|[
name|comb_vect_index
operator|+
name|vect_index
index|]
operator|=
name|vect
index|[
name|vect_index
index|]
expr_stmt|;
if|if
condition|(
name|vect
index|[
name|vect_index
index|]
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|tab
operator|->
name|max_comb_vect_el_value
operator|<
name|vect
index|[
name|vect_index
index|]
condition|)
name|tab
operator|->
name|max_comb_vect_el_value
operator|=
name|vect
index|[
name|vect_index
index|]
expr_stmt|;
if|if
condition|(
name|tab
operator|->
name|min_comb_vect_el_value
operator|>
name|vect
index|[
name|vect_index
index|]
condition|)
name|tab
operator|->
name|min_comb_vect_el_value
operator|=
name|vect
index|[
name|vect_index
index|]
expr_stmt|;
name|check_vect_start
index|[
name|comb_vect_index
operator|+
name|vect_index
index|]
operator|=
name|vect_num
expr_stmt|;
block|}
if|if
condition|(
name|tab
operator|->
name|max_base_vect_el_value
operator|<
name|comb_vect_index
condition|)
name|tab
operator|->
name|max_base_vect_el_value
operator|=
name|comb_vect_index
expr_stmt|;
if|if
condition|(
name|tab
operator|->
name|min_base_vect_el_value
operator|>
name|comb_vect_index
condition|)
name|tab
operator|->
name|min_base_vect_el_value
operator|=
name|comb_vect_index
expr_stmt|;
name|VLA_HWINT
argument_list|(
name|tab
operator|->
name|base_vect
argument_list|,
name|vect_num
argument_list|)
operator|=
name|comb_vect_index
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return number of out arcs of STATE.  */
end_comment

begin_function
specifier|static
name|int
name|out_state_arcs_num
parameter_list|(
name|state
parameter_list|)
name|state_t
name|state
decl_stmt|;
block|{
name|int
name|result
decl_stmt|;
name|arc_t
name|arc
decl_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|arc
operator|=
name|first_out_arc
argument_list|(
name|state
argument_list|)
init|;
name|arc
operator|!=
name|NULL
condition|;
name|arc
operator|=
name|next_out_arc
argument_list|(
name|arc
argument_list|)
control|)
block|{
if|if
condition|(
name|arc
operator|->
name|insn
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|arc
operator|->
name|insn
operator|->
name|first_ainsn_with_given_equialence_num
condition|)
name|result
operator|++
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Compare number of possible transitions from the states.  */
end_comment

begin_function
specifier|static
name|int
name|compare_transition_els_num
parameter_list|(
name|state_ptr_1
parameter_list|,
name|state_ptr_2
parameter_list|)
specifier|const
name|void
modifier|*
name|state_ptr_1
decl_stmt|;
specifier|const
name|void
modifier|*
name|state_ptr_2
decl_stmt|;
block|{
name|int
name|transition_els_num_1
decl_stmt|;
name|int
name|transition_els_num_2
decl_stmt|;
name|transition_els_num_1
operator|=
name|out_state_arcs_num
argument_list|(
operator|*
operator|(
name|state_t
operator|*
operator|)
name|state_ptr_1
argument_list|)
expr_stmt|;
name|transition_els_num_2
operator|=
name|out_state_arcs_num
argument_list|(
operator|*
operator|(
name|state_t
operator|*
operator|)
name|state_ptr_2
argument_list|)
expr_stmt|;
if|if
condition|(
name|transition_els_num_1
operator|<
name|transition_els_num_2
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|transition_els_num_1
operator|==
name|transition_els_num_2
condition|)
return|return
literal|0
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* The function adds element EL_VALUE to vector VECT for a table state    x AINSN.  */
end_comment

begin_function
specifier|static
name|void
name|add_vect_el
parameter_list|(
name|vect
parameter_list|,
name|ainsn
parameter_list|,
name|el_value
parameter_list|)
name|vla_hwint_t
modifier|*
name|vect
decl_stmt|;
name|ainsn_t
name|ainsn
decl_stmt|;
name|int
name|el_value
decl_stmt|;
block|{
name|int
name|equiv_class_num
decl_stmt|;
name|int
name|vect_index
decl_stmt|;
if|if
condition|(
name|ainsn
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|equiv_class_num
operator|=
name|ainsn
operator|->
name|insn_equiv_class_num
expr_stmt|;
for|for
control|(
name|vect_index
operator|=
name|VLA_HWINT_LENGTH
argument_list|(
operator|*
name|vect
argument_list|)
init|;
name|vect_index
operator|<=
name|equiv_class_num
condition|;
name|vect_index
operator|++
control|)
name|VLA_HWINT_ADD
argument_list|(
operator|*
name|vect
argument_list|,
name|undefined_vect_el_value
argument_list|)
expr_stmt|;
name|VLA_HWINT
argument_list|(
operator|*
name|vect
argument_list|,
name|equiv_class_num
argument_list|)
operator|=
name|el_value
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is for forming vector of states of an automaton.  */
end_comment

begin_decl_stmt
specifier|static
name|vla_ptr_t
name|output_states_vect
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The function is called by function pass_states.  The function adds    STATE to `output_states_vect'.  */
end_comment

begin_function
specifier|static
name|void
name|add_states_vect_el
parameter_list|(
name|state
parameter_list|)
name|state_t
name|state
decl_stmt|;
block|{
name|VLA_PTR_ADD
argument_list|(
name|output_states_vect
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Form and output vectors (comb, check, base or full vector)    representing transition table of AUTOMATON.  */
end_comment

begin_function
specifier|static
name|void
name|output_trans_table
parameter_list|(
name|automaton
parameter_list|)
name|automaton_t
name|automaton
decl_stmt|;
block|{
name|state_t
modifier|*
name|state_ptr
decl_stmt|;
name|arc_t
name|arc
decl_stmt|;
name|vla_hwint_t
name|transition_vect
decl_stmt|;
name|undefined_vect_el_value
operator|=
name|automaton
operator|->
name|achieved_states_num
expr_stmt|;
name|automaton
operator|->
name|trans_table
operator|=
name|create_state_ainsn_table
argument_list|(
name|automaton
argument_list|)
expr_stmt|;
comment|/* Create vect of pointers to states ordered by num of transitions      from the state (state with the maximum num is the first).  */
name|VLA_PTR_CREATE
argument_list|(
name|output_states_vect
argument_list|,
literal|1500
argument_list|,
literal|"output states vector"
argument_list|)
expr_stmt|;
name|pass_states
argument_list|(
name|automaton
argument_list|,
name|add_states_vect_el
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|VLA_PTR_BEGIN
argument_list|(
name|output_states_vect
argument_list|)
argument_list|,
name|VLA_PTR_LENGTH
argument_list|(
name|output_states_vect
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|state_t
argument_list|)
argument_list|,
name|compare_transition_els_num
argument_list|)
expr_stmt|;
name|VLA_HWINT_CREATE
argument_list|(
name|transition_vect
argument_list|,
literal|500
argument_list|,
literal|"transition vector"
argument_list|)
expr_stmt|;
for|for
control|(
name|state_ptr
operator|=
name|VLA_PTR_BEGIN
argument_list|(
name|output_states_vect
argument_list|)
init|;
name|state_ptr
operator|<=
operator|(
name|state_t
operator|*
operator|)
name|VLA_PTR_LAST
argument_list|(
name|output_states_vect
argument_list|)
condition|;
name|state_ptr
operator|++
control|)
block|{
name|VLA_HWINT_NULLIFY
argument_list|(
name|transition_vect
argument_list|)
expr_stmt|;
for|for
control|(
name|arc
operator|=
name|first_out_arc
argument_list|(
operator|*
name|state_ptr
argument_list|)
init|;
name|arc
operator|!=
name|NULL
condition|;
name|arc
operator|=
name|next_out_arc
argument_list|(
name|arc
argument_list|)
control|)
block|{
if|if
condition|(
name|arc
operator|->
name|insn
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|arc
operator|->
name|insn
operator|->
name|first_ainsn_with_given_equialence_num
condition|)
name|add_vect_el
argument_list|(
operator|&
name|transition_vect
argument_list|,
name|arc
operator|->
name|insn
argument_list|,
name|arc
operator|->
name|to_state
operator|->
name|order_state_num
argument_list|)
expr_stmt|;
block|}
name|add_vect
argument_list|(
name|automaton
operator|->
name|trans_table
argument_list|,
operator|(
operator|*
name|state_ptr
operator|)
operator|->
name|order_state_num
argument_list|,
name|VLA_HWINT_BEGIN
argument_list|(
name|transition_vect
argument_list|)
argument_list|,
name|VLA_HWINT_LENGTH
argument_list|(
name|transition_vect
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|output_state_ainsn_table
argument_list|(
name|automaton
operator|->
name|trans_table
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|"state transitions"
argument_list|,
name|output_trans_full_vect_name
argument_list|,
name|output_trans_comb_vect_name
argument_list|,
name|output_trans_check_vect_name
argument_list|,
name|output_trans_base_vect_name
argument_list|)
expr_stmt|;
name|VLA_PTR_DELETE
argument_list|(
name|output_states_vect
argument_list|)
expr_stmt|;
name|VLA_HWINT_DELETE
argument_list|(
name|transition_vect
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Form and output vectors (comb, check, base or simple vect)    representing alts number table of AUTOMATON.  The table is state x    ainsn -> number of possible alternative reservations by the    ainsn.  */
end_comment

begin_function
specifier|static
name|void
name|output_state_alts_table
parameter_list|(
name|automaton
parameter_list|)
name|automaton_t
name|automaton
decl_stmt|;
block|{
name|state_t
modifier|*
name|state_ptr
decl_stmt|;
name|arc_t
name|arc
decl_stmt|;
name|vla_hwint_t
name|state_alts_vect
decl_stmt|;
name|undefined_vect_el_value
operator|=
literal|0
expr_stmt|;
comment|/* no alts when transition is not possible */
name|automaton
operator|->
name|state_alts_table
operator|=
name|create_state_ainsn_table
argument_list|(
name|automaton
argument_list|)
expr_stmt|;
comment|/* Create vect of pointers to states ordered by num of transitions      from the state (state with the maximum num is the first).  */
name|VLA_PTR_CREATE
argument_list|(
name|output_states_vect
argument_list|,
literal|1500
argument_list|,
literal|"output states vector"
argument_list|)
expr_stmt|;
name|pass_states
argument_list|(
name|automaton
argument_list|,
name|add_states_vect_el
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|VLA_PTR_BEGIN
argument_list|(
name|output_states_vect
argument_list|)
argument_list|,
name|VLA_PTR_LENGTH
argument_list|(
name|output_states_vect
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|state_t
argument_list|)
argument_list|,
name|compare_transition_els_num
argument_list|)
expr_stmt|;
comment|/* Create base, comb, and check vectors.  */
name|VLA_HWINT_CREATE
argument_list|(
name|state_alts_vect
argument_list|,
literal|500
argument_list|,
literal|"state alts vector"
argument_list|)
expr_stmt|;
for|for
control|(
name|state_ptr
operator|=
name|VLA_PTR_BEGIN
argument_list|(
name|output_states_vect
argument_list|)
init|;
name|state_ptr
operator|<=
operator|(
name|state_t
operator|*
operator|)
name|VLA_PTR_LAST
argument_list|(
name|output_states_vect
argument_list|)
condition|;
name|state_ptr
operator|++
control|)
block|{
name|VLA_HWINT_NULLIFY
argument_list|(
name|state_alts_vect
argument_list|)
expr_stmt|;
for|for
control|(
name|arc
operator|=
name|first_out_arc
argument_list|(
operator|*
name|state_ptr
argument_list|)
init|;
name|arc
operator|!=
name|NULL
condition|;
name|arc
operator|=
name|next_out_arc
argument_list|(
name|arc
argument_list|)
control|)
block|{
if|if
condition|(
name|arc
operator|->
name|insn
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|arc
operator|->
name|insn
operator|->
name|first_ainsn_with_given_equialence_num
condition|)
name|add_vect_el
argument_list|(
operator|&
name|state_alts_vect
argument_list|,
name|arc
operator|->
name|insn
argument_list|,
name|arc
operator|->
name|state_alts
argument_list|)
expr_stmt|;
block|}
name|add_vect
argument_list|(
name|automaton
operator|->
name|state_alts_table
argument_list|,
operator|(
operator|*
name|state_ptr
operator|)
operator|->
name|order_state_num
argument_list|,
name|VLA_HWINT_BEGIN
argument_list|(
name|state_alts_vect
argument_list|)
argument_list|,
name|VLA_HWINT_LENGTH
argument_list|(
name|state_alts_vect
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|output_state_ainsn_table
argument_list|(
name|automaton
operator|->
name|state_alts_table
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|"state insn alternatives"
argument_list|,
name|output_state_alts_full_vect_name
argument_list|,
name|output_state_alts_comb_vect_name
argument_list|,
name|output_state_alts_check_vect_name
argument_list|,
name|output_state_alts_base_vect_name
argument_list|)
expr_stmt|;
name|VLA_PTR_DELETE
argument_list|(
name|output_states_vect
argument_list|)
expr_stmt|;
name|VLA_HWINT_DELETE
argument_list|(
name|state_alts_vect
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The current number of passing states to find minimal issue delay    value for an ainsn and state.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|curr_state_pass_num
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This recursive function passes states to find minimal issue delay    value for AINSN.  The state being visited is STATE.  The function    returns minimal issue delay value for AINSN in STATE or -1 if we    enter into a loop.  */
end_comment

begin_function
specifier|static
name|int
name|min_issue_delay_pass_states
parameter_list|(
name|state
parameter_list|,
name|ainsn
parameter_list|)
name|state_t
name|state
decl_stmt|;
name|ainsn_t
name|ainsn
decl_stmt|;
block|{
name|arc_t
name|arc
decl_stmt|;
name|int
name|min_insn_issue_delay
decl_stmt|,
name|insn_issue_delay
decl_stmt|;
if|if
condition|(
name|state
operator|->
name|state_pass_num
operator|==
name|curr_state_pass_num
operator|||
name|state
operator|->
name|min_insn_issue_delay
operator|!=
operator|-
literal|1
condition|)
comment|/* We've entered into a loop or already have the correct value for        given state and ainsn.  */
return|return
name|state
operator|->
name|min_insn_issue_delay
return|;
name|state
operator|->
name|state_pass_num
operator|=
name|curr_state_pass_num
expr_stmt|;
name|min_insn_issue_delay
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|arc
operator|=
name|first_out_arc
argument_list|(
name|state
argument_list|)
init|;
name|arc
operator|!=
name|NULL
condition|;
name|arc
operator|=
name|next_out_arc
argument_list|(
name|arc
argument_list|)
control|)
if|if
condition|(
name|arc
operator|->
name|insn
operator|==
name|ainsn
condition|)
block|{
name|min_insn_issue_delay
operator|=
literal|0
expr_stmt|;
break|break;
block|}
else|else
block|{
name|insn_issue_delay
operator|=
name|min_issue_delay_pass_states
argument_list|(
name|arc
operator|->
name|to_state
argument_list|,
name|ainsn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn_issue_delay
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|arc
operator|->
name|insn
operator|->
name|insn_reserv_decl
operator|==
name|DECL_INSN_RESERV
argument_list|(
name|advance_cycle_insn_decl
argument_list|)
condition|)
name|insn_issue_delay
operator|++
expr_stmt|;
if|if
condition|(
name|min_insn_issue_delay
operator|==
operator|-
literal|1
operator|||
name|min_insn_issue_delay
operator|>
name|insn_issue_delay
condition|)
block|{
name|min_insn_issue_delay
operator|=
name|insn_issue_delay
expr_stmt|;
if|if
condition|(
name|insn_issue_delay
operator|==
literal|0
condition|)
break|break;
block|}
block|}
block|}
return|return
name|min_insn_issue_delay
return|;
block|}
end_function

begin_comment
comment|/* The function searches minimal issue delay value for AINSN in STATE.    The function can return negative value if we can not issue AINSN.  We    will report about it later.  */
end_comment

begin_function
specifier|static
name|int
name|min_issue_delay
parameter_list|(
name|state
parameter_list|,
name|ainsn
parameter_list|)
name|state_t
name|state
decl_stmt|;
name|ainsn_t
name|ainsn
decl_stmt|;
block|{
name|curr_state_pass_num
operator|++
expr_stmt|;
name|state
operator|->
name|min_insn_issue_delay
operator|=
name|min_issue_delay_pass_states
argument_list|(
name|state
argument_list|,
name|ainsn
argument_list|)
expr_stmt|;
return|return
name|state
operator|->
name|min_insn_issue_delay
return|;
block|}
end_function

begin_comment
comment|/* The function initiates code for finding minimal issue delay values.    It should be called only once.  */
end_comment

begin_function
specifier|static
name|void
name|initiate_min_issue_delay_pass_states
parameter_list|()
block|{
name|curr_state_pass_num
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Form and output vectors representing minimal issue delay table of    AUTOMATON.  The table is state x ainsn -> minimal issue delay of    the ainsn.  */
end_comment

begin_function
specifier|static
name|void
name|output_min_issue_delay_table
parameter_list|(
name|automaton
parameter_list|)
name|automaton_t
name|automaton
decl_stmt|;
block|{
name|vla_hwint_t
name|min_issue_delay_vect
decl_stmt|;
name|vla_hwint_t
name|compressed_min_issue_delay_vect
decl_stmt|;
name|vect_el_t
name|min_delay
decl_stmt|;
name|ainsn_t
name|ainsn
decl_stmt|;
name|state_t
modifier|*
name|state_ptr
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Create vect of pointers to states ordered by num of transitions      from the state (state with the maximum num is the first).  */
name|VLA_PTR_CREATE
argument_list|(
name|output_states_vect
argument_list|,
literal|1500
argument_list|,
literal|"output states vector"
argument_list|)
expr_stmt|;
name|pass_states
argument_list|(
name|automaton
argument_list|,
name|add_states_vect_el
argument_list|)
expr_stmt|;
name|VLA_HWINT_CREATE
argument_list|(
name|min_issue_delay_vect
argument_list|,
literal|1500
argument_list|,
literal|"min issue delay vector"
argument_list|)
expr_stmt|;
name|VLA_HWINT_EXPAND
argument_list|(
name|min_issue_delay_vect
argument_list|,
name|VLA_HWINT_LENGTH
argument_list|(
name|output_states_vect
argument_list|)
operator|*
name|automaton
operator|->
name|insn_equiv_classes_num
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
operator|(
name|int
operator|)
name|VLA_HWINT_LENGTH
argument_list|(
name|output_states_vect
argument_list|)
operator|*
name|automaton
operator|->
name|insn_equiv_classes_num
operator|)
condition|;
name|i
operator|++
control|)
name|VLA_HWINT
argument_list|(
name|min_issue_delay_vect
argument_list|,
name|i
argument_list|)
operator|=
literal|0
expr_stmt|;
name|automaton
operator|->
name|max_min_delay
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ainsn
operator|=
name|automaton
operator|->
name|ainsn_list
init|;
name|ainsn
operator|!=
name|NULL
condition|;
name|ainsn
operator|=
name|ainsn
operator|->
name|next_ainsn
control|)
if|if
condition|(
name|ainsn
operator|->
name|first_ainsn_with_given_equialence_num
condition|)
block|{
for|for
control|(
name|state_ptr
operator|=
name|VLA_PTR_BEGIN
argument_list|(
name|output_states_vect
argument_list|)
init|;
name|state_ptr
operator|<=
operator|(
name|state_t
operator|*
operator|)
name|VLA_PTR_LAST
argument_list|(
name|output_states_vect
argument_list|)
condition|;
name|state_ptr
operator|++
control|)
operator|(
operator|*
name|state_ptr
operator|)
operator|->
name|min_insn_issue_delay
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|state_ptr
operator|=
name|VLA_PTR_BEGIN
argument_list|(
name|output_states_vect
argument_list|)
init|;
name|state_ptr
operator|<=
operator|(
name|state_t
operator|*
operator|)
name|VLA_PTR_LAST
argument_list|(
name|output_states_vect
argument_list|)
condition|;
name|state_ptr
operator|++
control|)
block|{
name|min_delay
operator|=
name|min_issue_delay
argument_list|(
operator|*
name|state_ptr
argument_list|,
name|ainsn
argument_list|)
expr_stmt|;
if|if
condition|(
name|automaton
operator|->
name|max_min_delay
operator|<
name|min_delay
condition|)
name|automaton
operator|->
name|max_min_delay
operator|=
name|min_delay
expr_stmt|;
name|VLA_HWINT
argument_list|(
name|min_issue_delay_vect
argument_list|,
operator|(
operator|*
name|state_ptr
operator|)
operator|->
name|order_state_num
operator|*
name|automaton
operator|->
name|insn_equiv_classes_num
operator|+
name|ainsn
operator|->
name|insn_equiv_class_num
argument_list|)
operator|=
name|min_delay
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"/* Vector of min issue delay of insns.*/\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"static const "
argument_list|)
expr_stmt|;
name|output_range_type
argument_list|(
name|output_file
argument_list|,
literal|0
argument_list|,
name|automaton
operator|->
name|max_min_delay
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|output_min_issue_delay_vect_name
argument_list|(
name|output_file
argument_list|,
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"[] ATTRIBUTE_UNUSED = {\n"
argument_list|)
expr_stmt|;
comment|/* Compress the vector */
if|if
condition|(
name|automaton
operator|->
name|max_min_delay
operator|<
literal|2
condition|)
name|automaton
operator|->
name|min_issue_delay_table_compression_factor
operator|=
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
name|automaton
operator|->
name|max_min_delay
operator|<
literal|4
condition|)
name|automaton
operator|->
name|min_issue_delay_table_compression_factor
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|automaton
operator|->
name|max_min_delay
operator|<
literal|16
condition|)
name|automaton
operator|->
name|min_issue_delay_table_compression_factor
operator|=
literal|2
expr_stmt|;
else|else
name|automaton
operator|->
name|min_issue_delay_table_compression_factor
operator|=
literal|1
expr_stmt|;
name|VLA_HWINT_CREATE
argument_list|(
name|compressed_min_issue_delay_vect
argument_list|,
literal|1500
argument_list|,
literal|"compressed min issue delay vector"
argument_list|)
expr_stmt|;
name|VLA_HWINT_EXPAND
argument_list|(
name|compressed_min_issue_delay_vect
argument_list|,
operator|(
name|VLA_HWINT_LENGTH
argument_list|(
name|min_issue_delay_vect
argument_list|)
operator|+
name|automaton
operator|->
name|min_issue_delay_table_compression_factor
operator|-
literal|1
operator|)
operator|/
name|automaton
operator|->
name|min_issue_delay_table_compression_factor
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|VLA_HWINT_LENGTH
argument_list|(
name|compressed_min_issue_delay_vect
argument_list|)
condition|;
name|i
operator|++
control|)
name|VLA_HWINT
argument_list|(
name|compressed_min_issue_delay_vect
argument_list|,
name|i
argument_list|)
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|VLA_HWINT_LENGTH
argument_list|(
name|min_issue_delay_vect
argument_list|)
condition|;
name|i
operator|++
control|)
name|VLA_HWINT
argument_list|(
name|compressed_min_issue_delay_vect
argument_list|,
name|i
operator|/
name|automaton
operator|->
name|min_issue_delay_table_compression_factor
argument_list|)
operator||=
operator|(
name|VLA_HWINT
argument_list|(
name|min_issue_delay_vect
argument_list|,
name|i
argument_list|)
operator|<<
operator|(
literal|8
operator|-
operator|(
name|i
operator|%
name|automaton
operator|->
name|min_issue_delay_table_compression_factor
operator|+
literal|1
operator|)
operator|*
operator|(
literal|8
operator|/
name|automaton
operator|->
name|min_issue_delay_table_compression_factor
operator|)
operator|)
operator|)
expr_stmt|;
name|output_vect
argument_list|(
name|VLA_HWINT_BEGIN
argument_list|(
name|compressed_min_issue_delay_vect
argument_list|)
argument_list|,
name|VLA_HWINT_LENGTH
argument_list|(
name|compressed_min_issue_delay_vect
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"};\n\n"
argument_list|)
expr_stmt|;
name|VLA_PTR_DELETE
argument_list|(
name|output_states_vect
argument_list|)
expr_stmt|;
name|VLA_HWINT_DELETE
argument_list|(
name|min_issue_delay_vect
argument_list|)
expr_stmt|;
name|VLA_HWINT_DELETE
argument_list|(
name|compressed_min_issue_delay_vect
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NDEBUG
end_ifndef

begin_comment
comment|/* Number of states which contains transition only by advancing cpu    cycle.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|locked_states_num
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Form and output vector representing the locked states of    AUTOMATON.  */
end_comment

begin_function
specifier|static
name|void
name|output_dead_lock_vect
parameter_list|(
name|automaton
parameter_list|)
name|automaton_t
name|automaton
decl_stmt|;
block|{
name|state_t
modifier|*
name|state_ptr
decl_stmt|;
name|arc_t
name|arc
decl_stmt|;
name|vla_hwint_t
name|dead_lock_vect
decl_stmt|;
comment|/* Create vect of pointers to states ordered by num of      transitions from the state (state with the maximum num is the      first).  */
name|VLA_PTR_CREATE
argument_list|(
name|output_states_vect
argument_list|,
literal|1500
argument_list|,
literal|"output states vector"
argument_list|)
expr_stmt|;
name|pass_states
argument_list|(
name|automaton
argument_list|,
name|add_states_vect_el
argument_list|)
expr_stmt|;
name|VLA_HWINT_CREATE
argument_list|(
name|dead_lock_vect
argument_list|,
literal|1500
argument_list|,
literal|"is dead locked vector"
argument_list|)
expr_stmt|;
name|VLA_HWINT_EXPAND
argument_list|(
name|dead_lock_vect
argument_list|,
name|VLA_HWINT_LENGTH
argument_list|(
name|output_states_vect
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|state_ptr
operator|=
name|VLA_PTR_BEGIN
argument_list|(
name|output_states_vect
argument_list|)
init|;
name|state_ptr
operator|<=
operator|(
name|state_t
operator|*
operator|)
name|VLA_PTR_LAST
argument_list|(
name|output_states_vect
argument_list|)
condition|;
name|state_ptr
operator|++
control|)
block|{
name|arc
operator|=
name|first_out_arc
argument_list|(
operator|*
name|state_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|arc
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|VLA_HWINT
argument_list|(
name|dead_lock_vect
argument_list|,
operator|(
operator|*
name|state_ptr
operator|)
operator|->
name|order_state_num
argument_list|)
operator|=
operator|(
name|next_out_arc
argument_list|(
name|arc
argument_list|)
operator|==
name|NULL
operator|&&
operator|(
name|arc
operator|->
name|insn
operator|->
name|insn_reserv_decl
operator|==
name|DECL_INSN_RESERV
argument_list|(
name|advance_cycle_insn_decl
argument_list|)
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NDEBUG
if|if
condition|(
name|VLA_HWINT
argument_list|(
name|dead_lock_vect
argument_list|,
operator|(
operator|*
name|state_ptr
operator|)
operator|->
name|order_state_num
argument_list|)
condition|)
name|locked_states_num
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"/* Vector for locked state flags.  */\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"static const "
argument_list|)
expr_stmt|;
name|output_range_type
argument_list|(
name|output_file
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|output_dead_lock_vect_name
argument_list|(
name|output_file
argument_list|,
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"[] = {\n"
argument_list|)
expr_stmt|;
name|output_vect
argument_list|(
name|VLA_HWINT_BEGIN
argument_list|(
name|dead_lock_vect
argument_list|)
argument_list|,
name|VLA_HWINT_LENGTH
argument_list|(
name|dead_lock_vect
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"};\n\n"
argument_list|)
expr_stmt|;
name|VLA_HWINT_DELETE
argument_list|(
name|dead_lock_vect
argument_list|)
expr_stmt|;
name|VLA_PTR_DELETE
argument_list|(
name|output_states_vect
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Form and output vector representing reserved units of the states of    AUTOMATON.  */
end_comment

begin_function
specifier|static
name|void
name|output_reserved_units_table
parameter_list|(
name|automaton
parameter_list|)
name|automaton_t
name|automaton
decl_stmt|;
block|{
name|state_t
modifier|*
name|curr_state_ptr
decl_stmt|;
name|vla_hwint_t
name|reserved_units_table
decl_stmt|;
name|size_t
name|state_byte_size
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Create vect of pointers to states.  */
name|VLA_PTR_CREATE
argument_list|(
name|output_states_vect
argument_list|,
literal|1500
argument_list|,
literal|"output states vector"
argument_list|)
expr_stmt|;
name|pass_states
argument_list|(
name|automaton
argument_list|,
name|add_states_vect_el
argument_list|)
expr_stmt|;
comment|/* Create vector.  */
name|VLA_HWINT_CREATE
argument_list|(
name|reserved_units_table
argument_list|,
literal|1500
argument_list|,
literal|"reserved units vector"
argument_list|)
expr_stmt|;
name|state_byte_size
operator|=
operator|(
name|description
operator|->
name|query_units_num
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
name|VLA_HWINT_EXPAND
argument_list|(
name|reserved_units_table
argument_list|,
name|VLA_HWINT_LENGTH
argument_list|(
name|output_states_vect
argument_list|)
operator|*
name|state_byte_size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
call|(
name|int
call|)
argument_list|(
name|VLA_HWINT_LENGTH
argument_list|(
name|output_states_vect
argument_list|)
operator|*
name|state_byte_size
argument_list|)
condition|;
name|i
operator|++
control|)
name|VLA_HWINT
argument_list|(
name|reserved_units_table
argument_list|,
name|i
argument_list|)
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|curr_state_ptr
operator|=
name|VLA_PTR_BEGIN
argument_list|(
name|output_states_vect
argument_list|)
init|;
name|curr_state_ptr
operator|<=
operator|(
name|state_t
operator|*
operator|)
name|VLA_PTR_LAST
argument_list|(
name|output_states_vect
argument_list|)
condition|;
name|curr_state_ptr
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|units_num
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|units_array
index|[
name|i
index|]
operator|->
name|query_p
condition|)
block|{
if|if
condition|(
name|test_unit_reserv
argument_list|(
operator|(
operator|*
name|curr_state_ptr
operator|)
operator|->
name|reservs
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
condition|)
name|VLA_HWINT
argument_list|(
name|reserved_units_table
argument_list|,
operator|(
operator|*
name|curr_state_ptr
operator|)
operator|->
name|order_state_num
operator|*
name|state_byte_size
operator|+
name|units_array
index|[
name|i
index|]
operator|->
name|query_num
operator|/
literal|8
argument_list|)
operator|+=
operator|(
literal|1
operator|<<
operator|(
name|units_array
index|[
name|i
index|]
operator|->
name|query_num
operator|%
literal|8
operator|)
operator|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"/* Vector for reserved units of states.  */\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"static const "
argument_list|)
expr_stmt|;
name|output_range_type
argument_list|(
name|output_file
argument_list|,
literal|0
argument_list|,
literal|255
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|output_reserved_units_table_name
argument_list|(
name|output_file
argument_list|,
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"[] = {\n"
argument_list|)
expr_stmt|;
name|output_vect
argument_list|(
name|VLA_HWINT_BEGIN
argument_list|(
name|reserved_units_table
argument_list|)
argument_list|,
name|VLA_HWINT_LENGTH
argument_list|(
name|reserved_units_table
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"};\n\n"
argument_list|)
expr_stmt|;
name|VLA_HWINT_DELETE
argument_list|(
name|reserved_units_table
argument_list|)
expr_stmt|;
name|VLA_PTR_DELETE
argument_list|(
name|output_states_vect
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function outputs all tables representing DFA(s) used for fast    pipeline hazards recognition.  */
end_comment

begin_function
specifier|static
name|void
name|output_tables
parameter_list|()
block|{
name|automaton_t
name|automaton
decl_stmt|;
ifndef|#
directive|ifndef
name|NDEBUG
name|locked_states_num
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|initiate_min_issue_delay_pass_states
argument_list|()
expr_stmt|;
for|for
control|(
name|automaton
operator|=
name|description
operator|->
name|first_automaton
init|;
name|automaton
operator|!=
name|NULL
condition|;
name|automaton
operator|=
name|automaton
operator|->
name|next_automaton
control|)
block|{
name|output_translate_vect
argument_list|(
name|automaton
argument_list|)
expr_stmt|;
name|output_trans_table
argument_list|(
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\n#if %s\n"
argument_list|,
name|AUTOMATON_STATE_ALTS_MACRO_NAME
argument_list|)
expr_stmt|;
name|output_state_alts_table
argument_list|(
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\n#endif /* #if %s */\n\n"
argument_list|,
name|AUTOMATON_STATE_ALTS_MACRO_NAME
argument_list|)
expr_stmt|;
name|output_min_issue_delay_table
argument_list|(
name|automaton
argument_list|)
expr_stmt|;
name|output_dead_lock_vect
argument_list|(
name|automaton
argument_list|)
expr_stmt|;
if|if
condition|(
name|no_minimization_flag
condition|)
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\n#if %s\n\n"
argument_list|,
name|CPU_UNITS_QUERY_MACRO_NAME
argument_list|)
expr_stmt|;
name|output_reserved_units_table
argument_list|(
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\n#endif /* #if %s */\n\n"
argument_list|,
name|CPU_UNITS_QUERY_MACRO_NAME
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\n#define %s %d\n\n"
argument_list|,
name|ADVANCE_CYCLE_VALUE_NAME
argument_list|,
name|DECL_INSN_RESERV
argument_list|(
name|advance_cycle_insn_decl
argument_list|)
operator|->
name|insn_num
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function outputs definition and value of PHR interface variable    `max_insn_queue_index'.  Its value is not less than maximal queue    length needed for the insn scheduler.  */
end_comment

begin_function
specifier|static
name|void
name|output_max_insn_queue_index_def
parameter_list|()
block|{
name|int
name|i
decl_stmt|,
name|max
decl_stmt|,
name|latency
decl_stmt|;
name|decl_t
name|decl
decl_stmt|;
name|max
operator|=
name|description
operator|->
name|max_insn_reserv_cycles
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_insn_reserv
operator|&&
name|decl
operator|!=
name|advance_cycle_insn_decl
condition|)
block|{
name|latency
operator|=
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|default_latency
expr_stmt|;
if|if
condition|(
name|latency
operator|>
name|max
condition|)
name|max
operator|=
name|latency
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_bypass
condition|)
block|{
name|latency
operator|=
name|DECL_BYPASS
argument_list|(
name|decl
argument_list|)
operator|->
name|latency
expr_stmt|;
if|if
condition|(
name|latency
operator|>
name|max
condition|)
name|max
operator|=
name|latency
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
literal|1
operator|<<
name|i
operator|)
operator|<=
name|max
condition|;
name|i
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\nint max_insn_queue_index = %d;\n\n"
argument_list|,
operator|(
literal|1
operator|<<
name|i
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function outputs switch cases for insn reseravtions using    function *output_automata_list_code.  */
end_comment

begin_function_decl
specifier|static
name|void
name|output_insn_code_cases
parameter_list|(
name|output_automata_list_code
parameter_list|)
function_decl|void
parameter_list|(
function_decl|*output_automata_list_code
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|automata_list_el_t
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|decl_t
name|decl
decl_stmt|,
name|decl2
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_insn_reserv
condition|)
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|processed_p
operator|=
name|FALSE
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_insn_reserv
operator|&&
operator|!
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|processed_p
condition|)
block|{
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|description
operator|->
name|decls_num
condition|;
name|j
operator|++
control|)
block|{
name|decl2
operator|=
name|description
operator|->
name|decls
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|decl2
operator|->
name|mode
operator|==
name|dm_insn_reserv
operator|&&
operator|(
name|DECL_INSN_RESERV
argument_list|(
name|decl2
argument_list|)
operator|->
name|important_automata_list
operator|==
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|important_automata_list
operator|)
condition|)
block|{
name|DECL_INSN_RESERV
argument_list|(
name|decl2
argument_list|)
operator|->
name|processed_p
operator|=
name|TRUE
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"    case %d: /* %s */\n"
argument_list|,
name|DECL_INSN_RESERV
argument_list|(
name|decl2
argument_list|)
operator|->
name|insn_num
argument_list|,
name|DECL_INSN_RESERV
argument_list|(
name|decl2
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
call|(
modifier|*
name|output_automata_list_code
call|)
argument_list|(
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|important_automata_list
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/* The function outputs a code for evaluation of a minimal delay of    issue of insns which have reservations in given AUTOMATA_LIST.  */
end_comment

begin_function
specifier|static
name|void
name|output_automata_list_min_issue_delay_code
parameter_list|(
name|automata_list
parameter_list|)
name|automata_list_el_t
name|automata_list
decl_stmt|;
block|{
name|automata_list_el_t
name|el
decl_stmt|;
name|automaton_t
name|automaton
decl_stmt|;
for|for
control|(
name|el
operator|=
name|automata_list
init|;
name|el
operator|!=
name|NULL
condition|;
name|el
operator|=
name|el
operator|->
name|next_automata_list_el
control|)
block|{
name|automaton
operator|=
name|el
operator|->
name|automaton
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\n      %s = "
argument_list|,
name|TEMPORARY_VARIABLE_NAME
argument_list|)
expr_stmt|;
name|output_min_issue_delay_vect_name
argument_list|(
name|output_file
argument_list|,
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
operator|(
name|automaton
operator|->
name|min_issue_delay_table_compression_factor
operator|!=
literal|1
condition|?
literal|" [("
else|:
literal|" ["
operator|)
argument_list|)
expr_stmt|;
name|output_translate_vect_name
argument_list|(
name|output_file
argument_list|,
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" [%s] + "
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"%s->"
argument_list|,
name|CHIP_PARAMETER_NAME
argument_list|)
expr_stmt|;
name|output_chip_member_name
argument_list|(
name|output_file
argument_list|,
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" * %d"
argument_list|,
name|automaton
operator|->
name|insn_equiv_classes_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|automaton
operator|->
name|min_issue_delay_table_compression_factor
operator|==
literal|1
condition|)
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"];\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|") / %d];\n"
argument_list|,
name|automaton
operator|->
name|min_issue_delay_table_compression_factor
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"      %s = (%s>> (8 - ("
argument_list|,
name|TEMPORARY_VARIABLE_NAME
argument_list|,
name|TEMPORARY_VARIABLE_NAME
argument_list|)
expr_stmt|;
name|output_translate_vect_name
argument_list|(
name|output_file
argument_list|,
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" [%s] %% %d + 1) * %d))& %d;\n"
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|,
name|automaton
operator|->
name|min_issue_delay_table_compression_factor
argument_list|,
literal|8
operator|/
name|automaton
operator|->
name|min_issue_delay_table_compression_factor
argument_list|,
operator|(
literal|1
operator|<<
operator|(
literal|8
operator|/
name|automaton
operator|->
name|min_issue_delay_table_compression_factor
operator|)
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|el
operator|==
name|automata_list
condition|)
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"      %s = %s;\n"
argument_list|,
name|RESULT_VARIABLE_NAME
argument_list|,
name|TEMPORARY_VARIABLE_NAME
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"      if (%s> %s)\n"
argument_list|,
name|TEMPORARY_VARIABLE_NAME
argument_list|,
name|RESULT_VARIABLE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"        %s = %s;\n"
argument_list|,
name|RESULT_VARIABLE_NAME
argument_list|,
name|TEMPORARY_VARIABLE_NAME
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"      break;\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output function `internal_min_issue_delay'.  */
end_comment

begin_function
specifier|static
name|void
name|output_internal_min_issue_delay_func
parameter_list|()
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"static int %s PARAMS ((int, struct %s *));\n"
argument_list|,
name|INTERNAL_MIN_ISSUE_DELAY_FUNC_NAME
argument_list|,
name|CHIP_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"static int\n%s (%s, %s)\n\tint %s;\n\tstruct %s *%s  ATTRIBUTE_UNUSED;\n"
argument_list|,
name|INTERNAL_MIN_ISSUE_DELAY_FUNC_NAME
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|,
name|CHIP_PARAMETER_NAME
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|,
name|CHIP_NAME
argument_list|,
name|CHIP_PARAMETER_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"{\n  int %s ATTRIBUTE_UNUSED;\n  int %s = -1;\n"
argument_list|,
name|TEMPORARY_VARIABLE_NAME
argument_list|,
name|RESULT_VARIABLE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\n  switch (%s)\n    {\n"
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|)
expr_stmt|;
name|output_insn_code_cases
argument_list|(
name|output_automata_list_min_issue_delay_code
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\n    default:\n      %s = -1;\n      break;\n    }\n"
argument_list|,
name|RESULT_VARIABLE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"  return %s;\n"
argument_list|,
name|RESULT_VARIABLE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"}\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function outputs a code changing state after issue of insns    which have reservations in given AUTOMATA_LIST.  */
end_comment

begin_function
specifier|static
name|void
name|output_automata_list_transition_code
parameter_list|(
name|automata_list
parameter_list|)
name|automata_list_el_t
name|automata_list
decl_stmt|;
block|{
name|automata_list_el_t
name|el
decl_stmt|,
name|next_el
decl_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"      {\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|automata_list
operator|!=
name|NULL
operator|&&
name|automata_list
operator|->
name|next_automata_list_el
operator|!=
name|NULL
condition|)
for|for
control|(
name|el
operator|=
name|automata_list
init|;
condition|;
name|el
operator|=
name|next_el
control|)
block|{
name|next_el
operator|=
name|el
operator|->
name|next_automata_list_el
expr_stmt|;
if|if
condition|(
name|next_el
operator|==
name|NULL
condition|)
break|break;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"        "
argument_list|)
expr_stmt|;
name|output_state_member_type
argument_list|(
name|output_file
argument_list|,
name|el
operator|->
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|output_temp_chip_member_name
argument_list|(
name|output_file
argument_list|,
name|el
operator|->
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|";\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|el
operator|=
name|automata_list
init|;
name|el
operator|!=
name|NULL
condition|;
name|el
operator|=
name|el
operator|->
name|next_automata_list_el
control|)
if|if
condition|(
name|comb_vect_p
argument_list|(
name|el
operator|->
name|automaton
operator|->
name|trans_table
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\n        %s = "
argument_list|,
name|TEMPORARY_VARIABLE_NAME
argument_list|)
expr_stmt|;
name|output_trans_base_vect_name
argument_list|(
name|output_file
argument_list|,
name|el
operator|->
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" [%s->"
argument_list|,
name|CHIP_PARAMETER_NAME
argument_list|)
expr_stmt|;
name|output_chip_member_name
argument_list|(
name|output_file
argument_list|,
name|el
operator|->
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"] + "
argument_list|)
expr_stmt|;
name|output_translate_vect_name
argument_list|(
name|output_file
argument_list|,
name|el
operator|->
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" [%s];\n"
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"        if ("
argument_list|)
expr_stmt|;
name|output_trans_check_vect_name
argument_list|(
name|output_file
argument_list|,
name|el
operator|->
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" [%s] != %s->"
argument_list|,
name|TEMPORARY_VARIABLE_NAME
argument_list|,
name|CHIP_PARAMETER_NAME
argument_list|)
expr_stmt|;
name|output_chip_member_name
argument_list|(
name|output_file
argument_list|,
name|el
operator|->
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"          return %s (%s, %s);\n"
argument_list|,
name|INTERNAL_MIN_ISSUE_DELAY_FUNC_NAME
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|,
name|CHIP_PARAMETER_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"        else\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"          "
argument_list|)
expr_stmt|;
if|if
condition|(
name|el
operator|->
name|next_automata_list_el
operator|!=
name|NULL
condition|)
name|output_temp_chip_member_name
argument_list|(
name|output_file
argument_list|,
name|el
operator|->
name|automaton
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"%s->"
argument_list|,
name|CHIP_PARAMETER_NAME
argument_list|)
expr_stmt|;
name|output_chip_member_name
argument_list|(
name|output_file
argument_list|,
name|el
operator|->
name|automaton
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" = "
argument_list|)
expr_stmt|;
name|output_trans_comb_vect_name
argument_list|(
name|output_file
argument_list|,
name|el
operator|->
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" [%s];\n"
argument_list|,
name|TEMPORARY_VARIABLE_NAME
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\n        %s = "
argument_list|,
name|TEMPORARY_VARIABLE_NAME
argument_list|)
expr_stmt|;
name|output_trans_full_vect_name
argument_list|(
name|output_file
argument_list|,
name|el
operator|->
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" ["
argument_list|)
expr_stmt|;
name|output_translate_vect_name
argument_list|(
name|output_file
argument_list|,
name|el
operator|->
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" [%s] + "
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"%s->"
argument_list|,
name|CHIP_PARAMETER_NAME
argument_list|)
expr_stmt|;
name|output_chip_member_name
argument_list|(
name|output_file
argument_list|,
name|el
operator|->
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" * %d];\n"
argument_list|,
name|el
operator|->
name|automaton
operator|->
name|insn_equiv_classes_num
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"        if (%s>= %d)\n"
argument_list|,
name|TEMPORARY_VARIABLE_NAME
argument_list|,
name|el
operator|->
name|automaton
operator|->
name|achieved_states_num
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"          return %s (%s, %s);\n"
argument_list|,
name|INTERNAL_MIN_ISSUE_DELAY_FUNC_NAME
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|,
name|CHIP_PARAMETER_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"        else\n          "
argument_list|)
expr_stmt|;
if|if
condition|(
name|el
operator|->
name|next_automata_list_el
operator|!=
name|NULL
condition|)
name|output_temp_chip_member_name
argument_list|(
name|output_file
argument_list|,
name|el
operator|->
name|automaton
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"%s->"
argument_list|,
name|CHIP_PARAMETER_NAME
argument_list|)
expr_stmt|;
name|output_chip_member_name
argument_list|(
name|output_file
argument_list|,
name|el
operator|->
name|automaton
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" = %s;\n"
argument_list|,
name|TEMPORARY_VARIABLE_NAME
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|automata_list
operator|!=
name|NULL
operator|&&
name|automata_list
operator|->
name|next_automata_list_el
operator|!=
name|NULL
condition|)
for|for
control|(
name|el
operator|=
name|automata_list
init|;
condition|;
name|el
operator|=
name|next_el
control|)
block|{
name|next_el
operator|=
name|el
operator|->
name|next_automata_list_el
expr_stmt|;
if|if
condition|(
name|next_el
operator|==
name|NULL
condition|)
break|break;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"        %s->"
argument_list|,
name|CHIP_PARAMETER_NAME
argument_list|)
expr_stmt|;
name|output_chip_member_name
argument_list|(
name|output_file
argument_list|,
name|el
operator|->
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" = "
argument_list|)
expr_stmt|;
name|output_temp_chip_member_name
argument_list|(
name|output_file
argument_list|,
name|el
operator|->
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|";\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"        return -1;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"      }\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output function `internal_state_transition'.  */
end_comment

begin_function
specifier|static
name|void
name|output_internal_trans_func
parameter_list|()
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"static int %s PARAMS ((int, struct %s *));\n"
argument_list|,
name|INTERNAL_TRANSITION_FUNC_NAME
argument_list|,
name|CHIP_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"static int\n%s (%s, %s)\n\tint %s;\n\tstruct %s *%s  ATTRIBUTE_UNUSED;\n"
argument_list|,
name|INTERNAL_TRANSITION_FUNC_NAME
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|,
name|CHIP_PARAMETER_NAME
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|,
name|CHIP_NAME
argument_list|,
name|CHIP_PARAMETER_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"{\n  int %s ATTRIBUTE_UNUSED;\n"
argument_list|,
name|TEMPORARY_VARIABLE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\n  switch (%s)\n    {\n"
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|)
expr_stmt|;
name|output_insn_code_cases
argument_list|(
name|output_automata_list_transition_code
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\n    default:\n      return -1;\n    }\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"}\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output code    if (insn != 0)     {       insn_code = dfa_insn_code (insn);       if (insn_code> DFA__ADVANCE_CYCLE)         return code;     }   else     insn_code = DFA__ADVANCE_CYCLE;    where insn denotes INSN_NAME, insn_code denotes INSN_CODE_NAME, and   code denotes CODE.  */
end_comment

begin_function
specifier|static
name|void
name|output_internal_insn_code_evaluation
parameter_list|(
name|insn_name
parameter_list|,
name|insn_code_name
parameter_list|,
name|code
parameter_list|)
specifier|const
name|char
modifier|*
name|insn_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|insn_code_name
decl_stmt|;
name|int
name|code
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\n  if (%s != 0)\n    {\n"
argument_list|,
name|insn_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"      %s = %s (%s);\n"
argument_list|,
name|insn_code_name
argument_list|,
name|DFA_INSN_CODE_FUNC_NAME
argument_list|,
name|insn_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"      if (%s> %s)\n        return %d;\n"
argument_list|,
name|insn_code_name
argument_list|,
name|ADVANCE_CYCLE_VALUE_NAME
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"    }\n  else\n    %s = %s;\n\n"
argument_list|,
name|insn_code_name
argument_list|,
name|ADVANCE_CYCLE_VALUE_NAME
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function outputs function `dfa_insn_code'.  */
end_comment

begin_function
specifier|static
name|void
name|output_dfa_insn_code_func
parameter_list|()
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"#ifdef __GNUC__\n__inline__\n#endif\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"static int %s PARAMS ((rtx));\n"
argument_list|,
name|DFA_INSN_CODE_FUNC_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"static int\n%s (%s)\n\trtx %s;\n"
argument_list|,
name|DFA_INSN_CODE_FUNC_NAME
argument_list|,
name|INSN_PARAMETER_NAME
argument_list|,
name|INSN_PARAMETER_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"{\n  int %s;\n  int %s;\n\n"
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|,
name|TEMPORARY_VARIABLE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"  if (INSN_UID (%s)>= %s)\n    {\n"
argument_list|,
name|INSN_PARAMETER_NAME
argument_list|,
name|DFA_INSN_CODES_LENGTH_VARIABLE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"      %s = %s;\n      %s = 2 * INSN_UID (%s);\n"
argument_list|,
name|TEMPORARY_VARIABLE_NAME
argument_list|,
name|DFA_INSN_CODES_LENGTH_VARIABLE_NAME
argument_list|,
name|DFA_INSN_CODES_LENGTH_VARIABLE_NAME
argument_list|,
name|INSN_PARAMETER_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"      %s = xrealloc (%s, %s * sizeof (int));\n"
argument_list|,
name|DFA_INSN_CODES_VARIABLE_NAME
argument_list|,
name|DFA_INSN_CODES_VARIABLE_NAME
argument_list|,
name|DFA_INSN_CODES_LENGTH_VARIABLE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"      for (; %s< %s; %s++)\n        %s [%s] = -1;\n    }\n"
argument_list|,
name|TEMPORARY_VARIABLE_NAME
argument_list|,
name|DFA_INSN_CODES_LENGTH_VARIABLE_NAME
argument_list|,
name|TEMPORARY_VARIABLE_NAME
argument_list|,
name|DFA_INSN_CODES_VARIABLE_NAME
argument_list|,
name|TEMPORARY_VARIABLE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"  if ((%s = %s [INSN_UID (%s)])< 0)\n    {\n"
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|,
name|DFA_INSN_CODES_VARIABLE_NAME
argument_list|,
name|INSN_PARAMETER_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"      %s = %s (%s);\n"
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|,
name|INTERNAL_DFA_INSN_CODE_FUNC_NAME
argument_list|,
name|INSN_PARAMETER_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"      %s [INSN_UID (%s)] = %s;\n"
argument_list|,
name|DFA_INSN_CODES_VARIABLE_NAME
argument_list|,
name|INSN_PARAMETER_NAME
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"    }\n  return %s;\n}\n\n"
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function outputs PHR interface function `state_transition'.  */
end_comment

begin_function
specifier|static
name|void
name|output_trans_func
parameter_list|()
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"int\n%s (%s, %s)\n\t%s %s;\n\trtx %s;\n"
argument_list|,
name|TRANSITION_FUNC_NAME
argument_list|,
name|STATE_NAME
argument_list|,
name|INSN_PARAMETER_NAME
argument_list|,
name|STATE_TYPE_NAME
argument_list|,
name|STATE_NAME
argument_list|,
name|INSN_PARAMETER_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"{\n  int %s;\n"
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|)
expr_stmt|;
name|output_internal_insn_code_evaluation
argument_list|(
name|INSN_PARAMETER_NAME
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"  return %s (%s, %s);\n}\n\n"
argument_list|,
name|INTERNAL_TRANSITION_FUNC_NAME
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|,
name|STATE_NAME
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function outputs a code for evaluation of alternative states    number for insns which have reservations in given AUTOMATA_LIST.  */
end_comment

begin_function
specifier|static
name|void
name|output_automata_list_state_alts_code
parameter_list|(
name|automata_list
parameter_list|)
name|automata_list_el_t
name|automata_list
decl_stmt|;
block|{
name|automata_list_el_t
name|el
decl_stmt|;
name|automaton_t
name|automaton
decl_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"      {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|el
operator|=
name|automata_list
init|;
name|el
operator|!=
name|NULL
condition|;
name|el
operator|=
name|el
operator|->
name|next_automata_list_el
control|)
if|if
condition|(
name|comb_vect_p
argument_list|(
name|el
operator|->
name|automaton
operator|->
name|state_alts_table
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"        int %s;\n"
argument_list|,
name|TEMPORARY_VARIABLE_NAME
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
name|el
operator|=
name|automata_list
init|;
name|el
operator|!=
name|NULL
condition|;
name|el
operator|=
name|el
operator|->
name|next_automata_list_el
control|)
block|{
name|automaton
operator|=
name|el
operator|->
name|automaton
expr_stmt|;
if|if
condition|(
name|comb_vect_p
argument_list|(
name|automaton
operator|->
name|state_alts_table
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\n        %s = "
argument_list|,
name|TEMPORARY_VARIABLE_NAME
argument_list|)
expr_stmt|;
name|output_state_alts_base_vect_name
argument_list|(
name|output_file
argument_list|,
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" [%s->"
argument_list|,
name|CHIP_PARAMETER_NAME
argument_list|)
expr_stmt|;
name|output_chip_member_name
argument_list|(
name|output_file
argument_list|,
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"] + "
argument_list|)
expr_stmt|;
name|output_translate_vect_name
argument_list|(
name|output_file
argument_list|,
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" [%s];\n"
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"        if ("
argument_list|)
expr_stmt|;
name|output_state_alts_check_vect_name
argument_list|(
name|output_file
argument_list|,
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" [%s] != %s->"
argument_list|,
name|TEMPORARY_VARIABLE_NAME
argument_list|,
name|CHIP_PARAMETER_NAME
argument_list|)
expr_stmt|;
name|output_chip_member_name
argument_list|(
name|output_file
argument_list|,
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"          return 0;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"        else\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
operator|(
name|el
operator|==
name|automata_list
condition|?
literal|"          %s = "
else|:
literal|"          %s += "
operator|)
argument_list|,
name|RESULT_VARIABLE_NAME
argument_list|)
expr_stmt|;
name|output_state_alts_comb_vect_name
argument_list|(
name|output_file
argument_list|,
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" [%s];\n"
argument_list|,
name|TEMPORARY_VARIABLE_NAME
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
operator|(
name|el
operator|==
name|automata_list
condition|?
literal|"\n        %s = "
else|:
literal|"        %s += "
operator|)
argument_list|,
name|RESULT_VARIABLE_NAME
argument_list|)
expr_stmt|;
name|output_state_alts_full_vect_name
argument_list|(
name|output_file
argument_list|,
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" ["
argument_list|)
expr_stmt|;
name|output_translate_vect_name
argument_list|(
name|output_file
argument_list|,
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" [%s] + "
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"%s->"
argument_list|,
name|CHIP_PARAMETER_NAME
argument_list|)
expr_stmt|;
name|output_chip_member_name
argument_list|(
name|output_file
argument_list|,
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" * %d];\n"
argument_list|,
name|automaton
operator|->
name|insn_equiv_classes_num
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"        break;\n      }\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output function `internal_state_alts'.  */
end_comment

begin_function
specifier|static
name|void
name|output_internal_state_alts_func
parameter_list|()
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"static int %s PARAMS ((int, struct %s *));\n"
argument_list|,
name|INTERNAL_STATE_ALTS_FUNC_NAME
argument_list|,
name|CHIP_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"static int\n%s (%s, %s)\n\tint %s;\n\tstruct %s *%s;\n"
argument_list|,
name|INTERNAL_STATE_ALTS_FUNC_NAME
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|,
name|CHIP_PARAMETER_NAME
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|,
name|CHIP_NAME
argument_list|,
name|CHIP_PARAMETER_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"{\n  int %s;\n"
argument_list|,
name|RESULT_VARIABLE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\n  switch (%s)\n    {\n"
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|)
expr_stmt|;
name|output_insn_code_cases
argument_list|(
name|output_automata_list_state_alts_code
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\n    default:\n      %s = 0;\n      break;\n    }\n"
argument_list|,
name|RESULT_VARIABLE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"  return %s;\n"
argument_list|,
name|RESULT_VARIABLE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"}\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function outputs PHR interface function `state_alts'.  */
end_comment

begin_function
specifier|static
name|void
name|output_state_alts_func
parameter_list|()
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"int\n%s (%s, %s)\n\t%s %s;\n\trtx %s;\n"
argument_list|,
name|STATE_ALTS_FUNC_NAME
argument_list|,
name|STATE_NAME
argument_list|,
name|INSN_PARAMETER_NAME
argument_list|,
name|STATE_TYPE_NAME
argument_list|,
name|STATE_NAME
argument_list|,
name|INSN_PARAMETER_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"{\n  int %s;\n"
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|)
expr_stmt|;
name|output_internal_insn_code_evaluation
argument_list|(
name|INSN_PARAMETER_NAME
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"  return %s (%s, %s);\n}\n\n"
argument_list|,
name|INTERNAL_STATE_ALTS_FUNC_NAME
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|,
name|STATE_NAME
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output function `min_issue_delay'.  */
end_comment

begin_function
specifier|static
name|void
name|output_min_issue_delay_func
parameter_list|()
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"int\n%s (%s, %s)\n\t%s %s;\n\trtx %s;\n"
argument_list|,
name|MIN_ISSUE_DELAY_FUNC_NAME
argument_list|,
name|STATE_NAME
argument_list|,
name|INSN_PARAMETER_NAME
argument_list|,
name|STATE_TYPE_NAME
argument_list|,
name|STATE_NAME
argument_list|,
name|INSN_PARAMETER_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"{\n  int %s;\n"
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\n  if (%s != 0)\n    {\n"
argument_list|,
name|INSN_PARAMETER_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"      %s = %s (%s);\n"
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|,
name|DFA_INSN_CODE_FUNC_NAME
argument_list|,
name|INSN_PARAMETER_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"      if (%s> %s)\n        return 0;\n"
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|,
name|ADVANCE_CYCLE_VALUE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"    }\n  else\n    %s = %s;\n"
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|,
name|ADVANCE_CYCLE_VALUE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\n  return %s (%s, %s);\n"
argument_list|,
name|INTERNAL_MIN_ISSUE_DELAY_FUNC_NAME
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|,
name|STATE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"}\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output function `internal_dead_lock'.  */
end_comment

begin_function
specifier|static
name|void
name|output_internal_dead_lock_func
parameter_list|()
block|{
name|automaton_t
name|automaton
decl_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"static int %s PARAMS ((struct %s *));\n"
argument_list|,
name|INTERNAL_DEAD_LOCK_FUNC_NAME
argument_list|,
name|CHIP_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"static int\n%s (%s)\n\tstruct %s *%s;\n"
argument_list|,
name|INTERNAL_DEAD_LOCK_FUNC_NAME
argument_list|,
name|CHIP_PARAMETER_NAME
argument_list|,
name|CHIP_NAME
argument_list|,
name|CHIP_PARAMETER_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"{\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|automaton
operator|=
name|description
operator|->
name|first_automaton
init|;
name|automaton
operator|!=
name|NULL
condition|;
name|automaton
operator|=
name|automaton
operator|->
name|next_automaton
control|)
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"  if ("
argument_list|)
expr_stmt|;
name|output_dead_lock_vect_name
argument_list|(
name|output_file
argument_list|,
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" [%s->"
argument_list|,
name|CHIP_PARAMETER_NAME
argument_list|)
expr_stmt|;
name|output_chip_member_name
argument_list|(
name|output_file
argument_list|,
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"])\n    return 1/* TRUE */;\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"  return 0/* FALSE */;\n}\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function outputs PHR interface function `state_dead_lock_p'.  */
end_comment

begin_function
specifier|static
name|void
name|output_dead_lock_func
parameter_list|()
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"int\n%s (%s)\n\t%s %s;\n"
argument_list|,
name|DEAD_LOCK_FUNC_NAME
argument_list|,
name|STATE_NAME
argument_list|,
name|STATE_TYPE_NAME
argument_list|,
name|STATE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"{\n  return %s (%s);\n}\n\n"
argument_list|,
name|INTERNAL_DEAD_LOCK_FUNC_NAME
argument_list|,
name|STATE_NAME
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output function `internal_reset'.  */
end_comment

begin_function
specifier|static
name|void
name|output_internal_reset_func
parameter_list|()
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"static void %s PARAMS ((struct %s *));\n"
argument_list|,
name|INTERNAL_RESET_FUNC_NAME
argument_list|,
name|CHIP_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"static void\n%s (%s)\n\tstruct %s *%s;\n"
argument_list|,
name|INTERNAL_RESET_FUNC_NAME
argument_list|,
name|CHIP_PARAMETER_NAME
argument_list|,
name|CHIP_NAME
argument_list|,
name|CHIP_PARAMETER_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"{\n  memset (%s, 0, sizeof (struct %s));\n}\n\n"
argument_list|,
name|CHIP_PARAMETER_NAME
argument_list|,
name|CHIP_NAME
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function outputs PHR interface function `state_size'.  */
end_comment

begin_function
specifier|static
name|void
name|output_size_func
parameter_list|()
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"int\n%s ()\n"
argument_list|,
name|SIZE_FUNC_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"{\n  return sizeof (struct %s);\n}\n\n"
argument_list|,
name|CHIP_NAME
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function outputs PHR interface function `state_reset'.  */
end_comment

begin_function
specifier|static
name|void
name|output_reset_func
parameter_list|()
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"void\n%s (%s)\n\t %s %s;\n"
argument_list|,
name|RESET_FUNC_NAME
argument_list|,
name|STATE_NAME
argument_list|,
name|STATE_TYPE_NAME
argument_list|,
name|STATE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"{\n  %s (%s);\n}\n\n"
argument_list|,
name|INTERNAL_RESET_FUNC_NAME
argument_list|,
name|STATE_NAME
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output function `min_insn_conflict_delay'.  */
end_comment

begin_function
specifier|static
name|void
name|output_min_insn_conflict_delay_func
parameter_list|()
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"int\n%s (%s, %s, %s)\n\t%s %s;\n\trtx %s;\n\trtx %s;\n"
argument_list|,
name|MIN_INSN_CONFLICT_DELAY_FUNC_NAME
argument_list|,
name|STATE_NAME
argument_list|,
name|INSN_PARAMETER_NAME
argument_list|,
name|INSN2_PARAMETER_NAME
argument_list|,
name|STATE_TYPE_NAME
argument_list|,
name|STATE_NAME
argument_list|,
name|INSN_PARAMETER_NAME
argument_list|,
name|INSN2_PARAMETER_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"{\n  struct %s %s;\n  int %s, %s;\n"
argument_list|,
name|CHIP_NAME
argument_list|,
name|CHIP_NAME
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|,
name|INTERNAL_INSN2_CODE_NAME
argument_list|)
expr_stmt|;
name|output_internal_insn_code_evaluation
argument_list|(
name|INSN_PARAMETER_NAME
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|output_internal_insn_code_evaluation
argument_list|(
name|INSN2_PARAMETER_NAME
argument_list|,
name|INTERNAL_INSN2_CODE_NAME
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"  memcpy (&%s, %s, sizeof (%s));\n"
argument_list|,
name|CHIP_NAME
argument_list|,
name|STATE_NAME
argument_list|,
name|CHIP_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"  %s (&%s);\n"
argument_list|,
name|INTERNAL_RESET_FUNC_NAME
argument_list|,
name|CHIP_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"  if (%s (%s,&%s)> 0)\n    abort ();\n"
argument_list|,
name|INTERNAL_TRANSITION_FUNC_NAME
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|,
name|CHIP_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"  return %s (%s,&%s);\n"
argument_list|,
name|INTERNAL_MIN_ISSUE_DELAY_FUNC_NAME
argument_list|,
name|INTERNAL_INSN2_CODE_NAME
argument_list|,
name|CHIP_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"}\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output function `internal_insn_latency'.  */
end_comment

begin_function
specifier|static
name|void
name|output_internal_insn_latency_func
parameter_list|()
block|{
name|decl_t
name|decl
decl_stmt|;
name|struct
name|bypass_decl
modifier|*
name|bypass
decl_stmt|;
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"static int %s PARAMS ((int, int, rtx, rtx));\n"
argument_list|,
name|INTERNAL_INSN_LATENCY_FUNC_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"static int\n%s (%s, %s, %s, %s)"
argument_list|,
name|INTERNAL_INSN_LATENCY_FUNC_NAME
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|,
name|INTERNAL_INSN2_CODE_NAME
argument_list|,
name|INSN_PARAMETER_NAME
argument_list|,
name|INSN2_PARAMETER_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\n\tint %s;\n\tint %s;\n"
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|,
name|INTERNAL_INSN2_CODE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\trtx %s ATTRIBUTE_UNUSED;\n\trtx %s ATTRIBUTE_UNUSED;\n"
argument_list|,
name|INSN_PARAMETER_NAME
argument_list|,
name|INSN2_PARAMETER_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"{\n  switch (%s)\n    {\n"
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_insn_reserv
condition|)
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"    case %d:\n"
argument_list|,
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|insn_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|bypass_list
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"      return (%s != %s ? %d : 0);\n"
argument_list|,
name|INTERNAL_INSN2_CODE_NAME
argument_list|,
name|ADVANCE_CYCLE_VALUE_NAME
argument_list|,
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|default_latency
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"      switch (%s)\n        {\n"
argument_list|,
name|INTERNAL_INSN2_CODE_NAME
argument_list|)
expr_stmt|;
for|for
control|(
name|bypass
operator|=
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|bypass_list
init|;
name|bypass
operator|!=
name|NULL
condition|;
name|bypass
operator|=
name|bypass
operator|->
name|next
control|)
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"        case %d:\n"
argument_list|,
name|bypass
operator|->
name|in_insn_reserv
operator|->
name|insn_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|bypass
operator|->
name|bypass_guard_name
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"          return %d;\n"
argument_list|,
name|bypass
operator|->
name|latency
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"          return (%s (%s, %s) ? %d : %d);\n"
argument_list|,
name|bypass
operator|->
name|bypass_guard_name
argument_list|,
name|INSN_PARAMETER_NAME
argument_list|,
name|INSN2_PARAMETER_NAME
argument_list|,
name|bypass
operator|->
name|latency
argument_list|,
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|default_latency
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"        default:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"          return (%s != %s ? %d : 0);\n        }\n"
argument_list|,
name|INTERNAL_INSN2_CODE_NAME
argument_list|,
name|ADVANCE_CYCLE_VALUE_NAME
argument_list|,
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|default_latency
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"    default:\n      return 0;\n    }\n}\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function outputs PHR interface function `insn_latency'.  */
end_comment

begin_function
specifier|static
name|void
name|output_insn_latency_func
parameter_list|()
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"int\n%s (%s, %s)\n\trtx %s;\n\trtx %s;\n"
argument_list|,
name|INSN_LATENCY_FUNC_NAME
argument_list|,
name|INSN_PARAMETER_NAME
argument_list|,
name|INSN2_PARAMETER_NAME
argument_list|,
name|INSN_PARAMETER_NAME
argument_list|,
name|INSN2_PARAMETER_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"{\n  int %s, %s;\n"
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|,
name|INTERNAL_INSN2_CODE_NAME
argument_list|)
expr_stmt|;
name|output_internal_insn_code_evaluation
argument_list|(
name|INSN_PARAMETER_NAME
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|output_internal_insn_code_evaluation
argument_list|(
name|INSN2_PARAMETER_NAME
argument_list|,
name|INTERNAL_INSN2_CODE_NAME
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"  return %s (%s, %s, %s, %s);\n}\n\n"
argument_list|,
name|INTERNAL_INSN_LATENCY_FUNC_NAME
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|,
name|INTERNAL_INSN2_CODE_NAME
argument_list|,
name|INSN_PARAMETER_NAME
argument_list|,
name|INSN2_PARAMETER_NAME
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function outputs PHR interface function `print_reservation'.  */
end_comment

begin_function
specifier|static
name|void
name|output_print_reservation_func
parameter_list|()
block|{
name|decl_t
name|decl
decl_stmt|;
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"void\n%s (%s, %s)\n\tFILE *%s;\n\trtx %s;\n"
argument_list|,
name|PRINT_RESERVATION_FUNC_NAME
argument_list|,
name|FILE_PARAMETER_NAME
argument_list|,
name|INSN_PARAMETER_NAME
argument_list|,
name|FILE_PARAMETER_NAME
argument_list|,
name|INSN_PARAMETER_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"{\n  int %s;\n"
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\n  if (%s != 0)\n    {\n"
argument_list|,
name|INSN_PARAMETER_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"      %s = %s (%s);\n"
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|,
name|DFA_INSN_CODE_FUNC_NAME
argument_list|,
name|INSN_PARAMETER_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"      if (%s> %s)\n"
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|,
name|ADVANCE_CYCLE_VALUE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"        {\n          fprintf (%s, \"%s\");\n"
argument_list|,
name|FILE_PARAMETER_NAME
argument_list|,
name|NOTHING_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"          return;\n        }\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"    }\n  else\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"    {\n      fprintf (%s, \"%s\");\n      return;\n    }\n"
argument_list|,
name|FILE_PARAMETER_NAME
argument_list|,
name|NOTHING_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"  switch (%s)\n    {\n"
argument_list|,
name|INTERNAL_INSN_CODE_NAME
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_insn_reserv
operator|&&
name|decl
operator|!=
name|advance_cycle_insn_decl
condition|)
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"    case %d:\n"
argument_list|,
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|insn_num
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"      fprintf (%s, \"%s\");\n      break;\n"
argument_list|,
name|FILE_PARAMETER_NAME
argument_list|,
name|regexp_representation
argument_list|(
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|regexp
argument_list|)
argument_list|)
expr_stmt|;
name|finish_regexp_representation
argument_list|()
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"    default:\n      fprintf (%s, \"%s\");\n    }\n"
argument_list|,
name|FILE_PARAMETER_NAME
argument_list|,
name|NOTHING_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"}\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The following function is used to sort unit declaration by their    names.  */
end_comment

begin_function
specifier|static
name|int
name|units_cmp
parameter_list|(
name|unit1
parameter_list|,
name|unit2
parameter_list|)
specifier|const
name|void
modifier|*
name|unit1
decl_stmt|,
decl|*
name|unit2
decl_stmt|;
end_function

begin_block
block|{
specifier|const
name|unit_decl_t
name|u1
init|=
operator|*
operator|(
name|unit_decl_t
operator|*
operator|)
name|unit1
decl_stmt|;
specifier|const
name|unit_decl_t
name|u2
init|=
operator|*
operator|(
name|unit_decl_t
operator|*
operator|)
name|unit2
decl_stmt|;
return|return
name|strcmp
argument_list|(
name|u1
operator|->
name|name
argument_list|,
name|u2
operator|->
name|name
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/* The following macro value is name of struct containing unit name    and unit code.  */
end_comment

begin_define
define|#
directive|define
name|NAME_CODE_STRUCT_NAME
value|"name_code"
end_define

begin_comment
comment|/* The following macro value is name of table of struct name_code.  */
end_comment

begin_define
define|#
directive|define
name|NAME_CODE_TABLE_NAME
value|"name_code_table"
end_define

begin_comment
comment|/* The following macro values are member names for struct name_code.  */
end_comment

begin_define
define|#
directive|define
name|NAME_MEMBER_NAME
value|"name"
end_define

begin_define
define|#
directive|define
name|CODE_MEMBER_NAME
value|"code"
end_define

begin_comment
comment|/* The following macro values are local variable names for function    `get_cpu_unit_code'.  */
end_comment

begin_define
define|#
directive|define
name|CMP_VARIABLE_NAME
value|"cmp"
end_define

begin_define
define|#
directive|define
name|LOW_VARIABLE_NAME
value|"l"
end_define

begin_define
define|#
directive|define
name|MIDDLE_VARIABLE_NAME
value|"m"
end_define

begin_define
define|#
directive|define
name|HIGH_VARIABLE_NAME
value|"h"
end_define

begin_comment
comment|/* The following function outputs function to obtain internal cpu unit    code by the cpu unit name.  */
end_comment

begin_function
specifier|static
name|void
name|output_get_cpu_unit_code_func
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|unit_decl_t
modifier|*
name|units
decl_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"int\n%s (%s)\n\tconst char *%s;\n"
argument_list|,
name|GET_CPU_UNIT_CODE_FUNC_NAME
argument_list|,
name|CPU_UNIT_NAME_PARAMETER_NAME
argument_list|,
name|CPU_UNIT_NAME_PARAMETER_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"{\n  struct %s {const char *%s; int %s;};\n"
argument_list|,
name|NAME_CODE_STRUCT_NAME
argument_list|,
name|NAME_MEMBER_NAME
argument_list|,
name|CODE_MEMBER_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"  int %s, %s, %s, %s;\n"
argument_list|,
name|CMP_VARIABLE_NAME
argument_list|,
name|LOW_VARIABLE_NAME
argument_list|,
name|MIDDLE_VARIABLE_NAME
argument_list|,
name|HIGH_VARIABLE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"  static struct %s %s [] =\n    {\n"
argument_list|,
name|NAME_CODE_STRUCT_NAME
argument_list|,
name|NAME_CODE_TABLE_NAME
argument_list|)
expr_stmt|;
name|units
operator|=
operator|(
name|unit_decl_t
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|unit_decl_t
argument_list|)
operator|*
name|description
operator|->
name|units_num
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|units
argument_list|,
name|units_array
argument_list|,
sizeof|sizeof
argument_list|(
name|unit_decl_t
argument_list|)
operator|*
name|description
operator|->
name|units_num
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|units
argument_list|,
name|description
operator|->
name|units_num
argument_list|,
sizeof|sizeof
argument_list|(
name|unit_decl_t
argument_list|)
argument_list|,
name|units_cmp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|units_num
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|units
index|[
name|i
index|]
operator|->
name|query_p
condition|)
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"      {\"%s\", %d},\n"
argument_list|,
name|units
index|[
name|i
index|]
operator|->
name|name
argument_list|,
name|units
index|[
name|i
index|]
operator|->
name|query_num
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"    };\n\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"  /* The following is binary search: */\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"  %s = 0;\n"
argument_list|,
name|LOW_VARIABLE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"  %s = sizeof (%s) / sizeof (struct %s) - 1;\n"
argument_list|,
name|HIGH_VARIABLE_NAME
argument_list|,
name|NAME_CODE_TABLE_NAME
argument_list|,
name|NAME_CODE_STRUCT_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"  while (%s<= %s)\n    {\n"
argument_list|,
name|LOW_VARIABLE_NAME
argument_list|,
name|HIGH_VARIABLE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"      %s = (%s + %s) / 2;\n"
argument_list|,
name|MIDDLE_VARIABLE_NAME
argument_list|,
name|LOW_VARIABLE_NAME
argument_list|,
name|HIGH_VARIABLE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"      %s = strcmp (%s, %s [%s].%s);\n"
argument_list|,
name|CMP_VARIABLE_NAME
argument_list|,
name|CPU_UNIT_NAME_PARAMETER_NAME
argument_list|,
name|NAME_CODE_TABLE_NAME
argument_list|,
name|MIDDLE_VARIABLE_NAME
argument_list|,
name|NAME_MEMBER_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"      if (%s< 0)\n"
argument_list|,
name|CMP_VARIABLE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"        %s = %s - 1;\n"
argument_list|,
name|HIGH_VARIABLE_NAME
argument_list|,
name|MIDDLE_VARIABLE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"      else if (%s> 0)\n"
argument_list|,
name|CMP_VARIABLE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"        %s = %s + 1;\n"
argument_list|,
name|LOW_VARIABLE_NAME
argument_list|,
name|MIDDLE_VARIABLE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"      else\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"        return %s [%s].%s;\n    }\n"
argument_list|,
name|NAME_CODE_TABLE_NAME
argument_list|,
name|MIDDLE_VARIABLE_NAME
argument_list|,
name|CODE_MEMBER_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"  return -1;\n}\n\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|units
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The following function outputs function to check reservation of cpu    unit (its internal code will be passed as the function argument) in    given cpu state.  */
end_comment

begin_function
specifier|static
name|void
name|output_cpu_unit_reservation_p
parameter_list|()
block|{
name|automaton_t
name|automaton
decl_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"int\n%s (%s, %s)\n\t%s %s;\n\tint %s;\n"
argument_list|,
name|CPU_UNIT_RESERVATION_P_FUNC_NAME
argument_list|,
name|STATE_NAME
argument_list|,
name|CPU_CODE_PARAMETER_NAME
argument_list|,
name|STATE_TYPE_NAME
argument_list|,
name|STATE_NAME
argument_list|,
name|CPU_CODE_PARAMETER_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"{\n  if (%s< 0 || %s>= %d)\n    abort ();\n"
argument_list|,
name|CPU_CODE_PARAMETER_NAME
argument_list|,
name|CPU_CODE_PARAMETER_NAME
argument_list|,
name|description
operator|->
name|query_units_num
argument_list|)
expr_stmt|;
for|for
control|(
name|automaton
operator|=
name|description
operator|->
name|first_automaton
init|;
name|automaton
operator|!=
name|NULL
condition|;
name|automaton
operator|=
name|automaton
operator|->
name|next_automaton
control|)
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"  if (("
argument_list|)
expr_stmt|;
name|output_reserved_units_table_name
argument_list|(
name|output_file
argument_list|,
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" [((struct %s *) %s)->"
argument_list|,
name|CHIP_NAME
argument_list|,
name|STATE_NAME
argument_list|)
expr_stmt|;
name|output_chip_member_name
argument_list|(
name|output_file
argument_list|,
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" * %d + %s / 8]>> (%s %% 8))& 1)\n"
argument_list|,
operator|(
name|description
operator|->
name|query_units_num
operator|+
literal|7
operator|)
operator|/
literal|8
argument_list|,
name|CPU_CODE_PARAMETER_NAME
argument_list|,
name|CPU_CODE_PARAMETER_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"    return 1;\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"  return 0;\n}\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function outputs PHR interface function `dfa_start'.  */
end_comment

begin_function
specifier|static
name|void
name|output_dfa_start_func
parameter_list|()
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"void\n%s ()\n{\n  int %s;\n\n  %s = get_max_uid ();\n"
argument_list|,
name|DFA_START_FUNC_NAME
argument_list|,
name|I_VARIABLE_NAME
argument_list|,
name|DFA_INSN_CODES_LENGTH_VARIABLE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"  %s = (int *) xmalloc (%s * sizeof (int));\n"
argument_list|,
name|DFA_INSN_CODES_VARIABLE_NAME
argument_list|,
name|DFA_INSN_CODES_LENGTH_VARIABLE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"  for (%s = 0; %s< %s; %s++)\n    %s [%s] = -1;\n}\n\n"
argument_list|,
name|I_VARIABLE_NAME
argument_list|,
name|I_VARIABLE_NAME
argument_list|,
name|DFA_INSN_CODES_LENGTH_VARIABLE_NAME
argument_list|,
name|I_VARIABLE_NAME
argument_list|,
name|DFA_INSN_CODES_VARIABLE_NAME
argument_list|,
name|I_VARIABLE_NAME
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function outputs PHR interface function `dfa_finish'.  */
end_comment

begin_function
specifier|static
name|void
name|output_dfa_finish_func
parameter_list|()
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"void\n%s ()\n{\n  free (%s);\n}\n\n"
argument_list|,
name|DFA_FINISH_FUNC_NAME
argument_list|,
name|DFA_INSN_CODES_VARIABLE_NAME
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The page contains code for output description file (readable    representation of original description and generated DFA(s).  */
end_comment

begin_comment
comment|/* The function outputs string representation of IR reservation.  */
end_comment

begin_function
specifier|static
name|void
name|output_regexp
parameter_list|(
name|regexp
parameter_list|)
name|regexp_t
name|regexp
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|"%s"
argument_list|,
name|regexp_representation
argument_list|(
name|regexp
argument_list|)
argument_list|)
expr_stmt|;
name|finish_regexp_representation
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output names of units in LIST separated by comma.  */
end_comment

begin_function
specifier|static
name|void
name|output_unit_set_el_list
parameter_list|(
name|list
parameter_list|)
name|unit_set_el_t
name|list
decl_stmt|;
block|{
name|unit_set_el_t
name|el
decl_stmt|;
for|for
control|(
name|el
operator|=
name|list
init|;
name|el
operator|!=
name|NULL
condition|;
name|el
operator|=
name|el
operator|->
name|next_unit_set_el
control|)
block|{
if|if
condition|(
name|el
operator|!=
name|list
condition|)
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|"%s"
argument_list|,
name|el
operator|->
name|unit_decl
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The function outputs string representation of IR define_reservation    and define_insn_reservation.  */
end_comment

begin_function
specifier|static
name|void
name|output_description
parameter_list|()
block|{
name|decl_t
name|decl
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_unit
condition|)
block|{
if|if
condition|(
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|excl_list
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|"unit %s exlusion_set: "
argument_list|,
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
name|output_unit_set_el_list
argument_list|(
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|excl_list
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|presence_list
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|"unit %s presence_set: "
argument_list|,
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
name|output_unit_set_el_list
argument_list|(
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|presence_list
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|absence_list
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|"unit %s absence_set: "
argument_list|,
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
name|output_unit_set_el_list
argument_list|(
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|absence_list
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_reserv
condition|)
block|{
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|"reservation "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
name|DECL_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|": "
argument_list|)
expr_stmt|;
name|output_regexp
argument_list|(
name|DECL_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|regexp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_insn_reserv
operator|&&
name|decl
operator|!=
name|advance_cycle_insn_decl
condition|)
block|{
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|"insn reservation %s "
argument_list|,
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
name|print_rtl
argument_list|(
name|output_description_file
argument_list|,
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|condexp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|": "
argument_list|)
expr_stmt|;
name|output_regexp
argument_list|(
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|regexp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_bypass
condition|)
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|"bypass %d %s %s\n"
argument_list|,
name|DECL_BYPASS
argument_list|(
name|decl
argument_list|)
operator|->
name|latency
argument_list|,
name|DECL_BYPASS
argument_list|(
name|decl
argument_list|)
operator|->
name|out_insn_name
argument_list|,
name|DECL_BYPASS
argument_list|(
name|decl
argument_list|)
operator|->
name|in_insn_name
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|"\n\f\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function outputs name of AUTOMATON.  */
end_comment

begin_function
specifier|static
name|void
name|output_automaton_name
parameter_list|(
name|f
parameter_list|,
name|automaton
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
name|automaton_t
name|automaton
decl_stmt|;
block|{
if|if
condition|(
name|automaton
operator|->
name|corresponding_automaton_decl
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"#%d"
argument_list|,
name|automaton
operator|->
name|automaton_order_num
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"`%s'"
argument_list|,
name|automaton
operator|->
name|corresponding_automaton_decl
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Maximal length of line for pretty printing into description    file.  */
end_comment

begin_define
define|#
directive|define
name|MAX_LINE_LENGTH
value|70
end_define

begin_comment
comment|/* The function outputs units name belonging to AUTOMATON.  */
end_comment

begin_function
specifier|static
name|void
name|output_automaton_units
parameter_list|(
name|automaton
parameter_list|)
name|automaton_t
name|automaton
decl_stmt|;
block|{
name|decl_t
name|decl
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|curr_line_length
decl_stmt|;
name|int
name|there_is_an_automaton_unit
decl_stmt|;
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|"\n  Coresponding units:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|"    "
argument_list|)
expr_stmt|;
name|curr_line_length
operator|=
literal|4
expr_stmt|;
name|there_is_an_automaton_unit
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_unit
operator|&&
operator|(
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|corresponding_automaton_num
operator|==
name|automaton
operator|->
name|automaton_order_num
operator|)
condition|)
block|{
name|there_is_an_automaton_unit
operator|=
literal|1
expr_stmt|;
name|name
operator|=
name|DECL_UNIT
argument_list|(
name|decl
argument_list|)
operator|->
name|name
expr_stmt|;
if|if
condition|(
name|curr_line_length
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
operator|>
name|MAX_LINE_LENGTH
condition|)
block|{
name|curr_line_length
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|4
expr_stmt|;
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|"\n    "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|curr_line_length
operator|+=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|there_is_an_automaton_unit
condition|)
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|"<None>"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The following variable is used for forming array of all possible cpu unit    reservations described by the current DFA state.  */
end_comment

begin_decl_stmt
specifier|static
name|vla_ptr_t
name|state_reservs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The function forms `state_reservs' for STATE.  */
end_comment

begin_function
specifier|static
name|void
name|add_state_reservs
parameter_list|(
name|state
parameter_list|)
name|state_t
name|state
decl_stmt|;
block|{
name|alt_state_t
name|curr_alt_state
decl_stmt|;
name|reserv_sets_t
name|reservs
decl_stmt|;
if|if
condition|(
name|state
operator|->
name|component_states
operator|!=
name|NULL
condition|)
for|for
control|(
name|curr_alt_state
operator|=
name|state
operator|->
name|component_states
init|;
name|curr_alt_state
operator|!=
name|NULL
condition|;
name|curr_alt_state
operator|=
name|curr_alt_state
operator|->
name|next_sorted_alt_state
control|)
name|add_state_reservs
argument_list|(
name|curr_alt_state
operator|->
name|state
argument_list|)
expr_stmt|;
else|else
block|{
name|reservs
operator|=
name|state
operator|->
name|reservs
expr_stmt|;
name|VLA_PTR_ADD
argument_list|(
name|state_reservs
argument_list|,
name|reservs
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The function outputs readable represenatation of all out arcs of    STATE.  */
end_comment

begin_function
specifier|static
name|void
name|output_state_arcs
parameter_list|(
name|state
parameter_list|)
name|state_t
name|state
decl_stmt|;
block|{
name|arc_t
name|arc
decl_stmt|;
name|ainsn_t
name|ainsn
decl_stmt|;
name|char
modifier|*
name|insn_name
decl_stmt|;
name|int
name|curr_line_length
decl_stmt|;
for|for
control|(
name|arc
operator|=
name|first_out_arc
argument_list|(
name|state
argument_list|)
init|;
name|arc
operator|!=
name|NULL
condition|;
name|arc
operator|=
name|next_out_arc
argument_list|(
name|arc
argument_list|)
control|)
block|{
name|ainsn
operator|=
name|arc
operator|->
name|insn
expr_stmt|;
if|if
condition|(
operator|!
name|ainsn
operator|->
name|first_insn_with_same_reservs
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|"    "
argument_list|)
expr_stmt|;
name|curr_line_length
operator|=
literal|7
expr_stmt|;
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|"%2d: "
argument_list|,
name|ainsn
operator|->
name|insn_equiv_class_num
argument_list|)
expr_stmt|;
do|do
block|{
name|insn_name
operator|=
name|ainsn
operator|->
name|insn_reserv_decl
operator|->
name|name
expr_stmt|;
if|if
condition|(
name|curr_line_length
operator|+
name|strlen
argument_list|(
name|insn_name
argument_list|)
operator|>
name|MAX_LINE_LENGTH
condition|)
block|{
if|if
condition|(
name|ainsn
operator|!=
name|arc
operator|->
name|insn
condition|)
block|{
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|",\n      "
argument_list|)
expr_stmt|;
name|curr_line_length
operator|=
name|strlen
argument_list|(
name|insn_name
argument_list|)
operator|+
literal|6
expr_stmt|;
block|}
else|else
name|curr_line_length
operator|+=
name|strlen
argument_list|(
name|insn_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|curr_line_length
operator|+=
name|strlen
argument_list|(
name|insn_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ainsn
operator|!=
name|arc
operator|->
name|insn
condition|)
block|{
name|curr_line_length
operator|+=
literal|2
expr_stmt|;
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
name|insn_name
argument_list|)
expr_stmt|;
name|ainsn
operator|=
name|ainsn
operator|->
name|next_same_reservs_insn
expr_stmt|;
block|}
do|while
condition|(
name|ainsn
operator|!=
name|NULL
condition|)
do|;
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|"    %d (%d)\n"
argument_list|,
name|arc
operator|->
name|to_state
operator|->
name|order_state_num
argument_list|,
name|arc
operator|->
name|state_alts
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The following function is used for sorting possible cpu unit    reservation of a DFA state.  */
end_comment

begin_function
specifier|static
name|int
name|state_reservs_cmp
parameter_list|(
name|reservs_ptr_1
parameter_list|,
name|reservs_ptr_2
parameter_list|)
specifier|const
name|void
modifier|*
name|reservs_ptr_1
decl_stmt|;
specifier|const
name|void
modifier|*
name|reservs_ptr_2
decl_stmt|;
block|{
return|return
name|reserv_sets_cmp
argument_list|(
operator|*
operator|(
name|reserv_sets_t
operator|*
operator|)
name|reservs_ptr_1
argument_list|,
operator|*
operator|(
name|reserv_sets_t
operator|*
operator|)
name|reservs_ptr_2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The following function is used for sorting possible cpu unit    reservation of a DFA state.  */
end_comment

begin_function
specifier|static
name|void
name|remove_state_duplicate_reservs
parameter_list|()
block|{
name|reserv_sets_t
modifier|*
name|reservs_ptr
decl_stmt|;
name|reserv_sets_t
modifier|*
name|last_formed_reservs_ptr
decl_stmt|;
name|last_formed_reservs_ptr
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|reservs_ptr
operator|=
name|VLA_PTR_BEGIN
argument_list|(
name|state_reservs
argument_list|)
init|;
name|reservs_ptr
operator|<=
operator|(
name|reserv_sets_t
operator|*
operator|)
name|VLA_PTR_LAST
argument_list|(
name|state_reservs
argument_list|)
condition|;
name|reservs_ptr
operator|++
control|)
if|if
condition|(
name|last_formed_reservs_ptr
operator|==
name|NULL
condition|)
name|last_formed_reservs_ptr
operator|=
name|reservs_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|reserv_sets_cmp
argument_list|(
operator|*
name|last_formed_reservs_ptr
argument_list|,
operator|*
name|reservs_ptr
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|++
name|last_formed_reservs_ptr
expr_stmt|;
operator|*
name|last_formed_reservs_ptr
operator|=
operator|*
name|reservs_ptr
expr_stmt|;
block|}
name|VLA_PTR_SHORTEN
argument_list|(
name|state_reservs
argument_list|,
name|reservs_ptr
operator|-
name|last_formed_reservs_ptr
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The following function output readable representation of DFA(s)    state used for fast recognition of pipeline hazards.  State is    described by possible (current and scehduled) cpu unit    reservations.  */
end_comment

begin_function
specifier|static
name|void
name|output_state
parameter_list|(
name|state
parameter_list|)
name|state_t
name|state
decl_stmt|;
block|{
name|reserv_sets_t
modifier|*
name|reservs_ptr
decl_stmt|;
name|VLA_PTR_CREATE
argument_list|(
name|state_reservs
argument_list|,
literal|150
argument_list|,
literal|"state reservations"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|"  State #%d"
argument_list|,
name|state
operator|->
name|order_state_num
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
name|state
operator|->
name|new_cycle_p
condition|?
literal|" (new cycle)\n"
else|:
literal|"\n"
argument_list|)
expr_stmt|;
name|add_state_reservs
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|VLA_PTR_BEGIN
argument_list|(
name|state_reservs
argument_list|)
argument_list|,
name|VLA_PTR_LENGTH
argument_list|(
name|state_reservs
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|reserv_sets_t
argument_list|)
argument_list|,
name|state_reservs_cmp
argument_list|)
expr_stmt|;
name|remove_state_duplicate_reservs
argument_list|()
expr_stmt|;
for|for
control|(
name|reservs_ptr
operator|=
name|VLA_PTR_BEGIN
argument_list|(
name|state_reservs
argument_list|)
init|;
name|reservs_ptr
operator|<=
operator|(
name|reserv_sets_t
operator|*
operator|)
name|VLA_PTR_LAST
argument_list|(
name|state_reservs
argument_list|)
condition|;
name|reservs_ptr
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|"    "
argument_list|)
expr_stmt|;
name|output_reserv_sets
argument_list|(
name|output_description_file
argument_list|,
operator|*
name|reservs_ptr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|output_state_arcs
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|VLA_PTR_DELETE
argument_list|(
name|state_reservs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The following function output readable representation of    DFAs used for fast recognition of pipeline hazards.  */
end_comment

begin_function
specifier|static
name|void
name|output_automaton_descriptions
parameter_list|()
block|{
name|automaton_t
name|automaton
decl_stmt|;
for|for
control|(
name|automaton
operator|=
name|description
operator|->
name|first_automaton
init|;
name|automaton
operator|!=
name|NULL
condition|;
name|automaton
operator|=
name|automaton
operator|->
name|next_automaton
control|)
block|{
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|"\nAutomaton "
argument_list|)
expr_stmt|;
name|output_automaton_name
argument_list|(
name|output_description_file
argument_list|,
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_description_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|output_automaton_units
argument_list|(
name|automaton
argument_list|)
expr_stmt|;
name|pass_states
argument_list|(
name|automaton
argument_list|,
name|output_state
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The page contains top level function for generation DFA(s) used for    PHR.  */
end_comment

begin_comment
comment|/* The function outputs statistics about work of different phases of    DFA generator.  */
end_comment

begin_function
specifier|static
name|void
name|output_statistics
parameter_list|(
name|f
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
block|{
name|automaton_t
name|automaton
decl_stmt|;
ifndef|#
directive|ifndef
name|NDEBUG
name|int
name|transition_comb_vect_els
init|=
literal|0
decl_stmt|;
name|int
name|transition_full_vect_els
init|=
literal|0
decl_stmt|;
name|int
name|state_alts_comb_vect_els
init|=
literal|0
decl_stmt|;
name|int
name|state_alts_full_vect_els
init|=
literal|0
decl_stmt|;
name|int
name|min_issue_delay_vect_els
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
for|for
control|(
name|automaton
operator|=
name|description
operator|->
name|first_automaton
init|;
name|automaton
operator|!=
name|NULL
condition|;
name|automaton
operator|=
name|automaton
operator|->
name|next_automaton
control|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\nAutomaton "
argument_list|)
expr_stmt|;
name|output_automaton_name
argument_list|(
name|f
argument_list|,
name|automaton
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n    %5d NDFA states,          %5d NDFA arcs\n"
argument_list|,
name|automaton
operator|->
name|NDFA_states_num
argument_list|,
name|automaton
operator|->
name|NDFA_arcs_num
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"    %5d DFA states,           %5d DFA arcs\n"
argument_list|,
name|automaton
operator|->
name|DFA_states_num
argument_list|,
name|automaton
operator|->
name|DFA_arcs_num
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|no_minimization_flag
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"    %5d minimal DFA states,   %5d minimal DFA arcs\n"
argument_list|,
name|automaton
operator|->
name|minimal_DFA_states_num
argument_list|,
name|automaton
operator|->
name|minimal_DFA_arcs_num
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"    %5d all insns      %5d insn equivalence classes\n"
argument_list|,
name|description
operator|->
name|insns_num
argument_list|,
name|automaton
operator|->
name|insn_equiv_classes_num
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NDEBUG
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%5ld transition comb vector els, %5ld trans table els: %s\n"
argument_list|,
operator|(
name|long
operator|)
name|VLA_HWINT_LENGTH
argument_list|(
name|automaton
operator|->
name|trans_table
operator|->
name|comb_vect
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|VLA_HWINT_LENGTH
argument_list|(
name|automaton
operator|->
name|trans_table
operator|->
name|full_vect
argument_list|)
argument_list|,
operator|(
name|comb_vect_p
argument_list|(
name|automaton
operator|->
name|trans_table
argument_list|)
condition|?
literal|"use comb vect"
else|:
literal|"use simple vect"
operator|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%5ld state alts comb vector els, %5ld state alts table els: %s\n"
argument_list|,
operator|(
name|long
operator|)
name|VLA_HWINT_LENGTH
argument_list|(
name|automaton
operator|->
name|state_alts_table
operator|->
name|comb_vect
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|VLA_HWINT_LENGTH
argument_list|(
name|automaton
operator|->
name|state_alts_table
operator|->
name|full_vect
argument_list|)
argument_list|,
operator|(
name|comb_vect_p
argument_list|(
name|automaton
operator|->
name|state_alts_table
argument_list|)
condition|?
literal|"use comb vect"
else|:
literal|"use simple vect"
operator|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%5ld min delay table els, compression factor %d\n"
argument_list|,
operator|(
name|long
operator|)
name|automaton
operator|->
name|DFA_states_num
operator|*
name|automaton
operator|->
name|insn_equiv_classes_num
argument_list|,
name|automaton
operator|->
name|min_issue_delay_table_compression_factor
argument_list|)
expr_stmt|;
name|transition_comb_vect_els
operator|+=
name|VLA_HWINT_LENGTH
argument_list|(
name|automaton
operator|->
name|trans_table
operator|->
name|comb_vect
argument_list|)
expr_stmt|;
name|transition_full_vect_els
operator|+=
name|VLA_HWINT_LENGTH
argument_list|(
name|automaton
operator|->
name|trans_table
operator|->
name|full_vect
argument_list|)
expr_stmt|;
name|state_alts_comb_vect_els
operator|+=
name|VLA_HWINT_LENGTH
argument_list|(
name|automaton
operator|->
name|state_alts_table
operator|->
name|comb_vect
argument_list|)
expr_stmt|;
name|state_alts_full_vect_els
operator|+=
name|VLA_HWINT_LENGTH
argument_list|(
name|automaton
operator|->
name|state_alts_table
operator|->
name|full_vect
argument_list|)
expr_stmt|;
name|min_issue_delay_vect_els
operator|+=
name|automaton
operator|->
name|DFA_states_num
operator|*
name|automaton
operator|->
name|insn_equiv_classes_num
expr_stmt|;
endif|#
directive|endif
block|}
ifndef|#
directive|ifndef
name|NDEBUG
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n%5d all allocated states,     %5d all allocated arcs\n"
argument_list|,
name|allocated_states_num
argument_list|,
name|allocated_arcs_num
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%5d all allocated alternative states\n"
argument_list|,
name|allocated_alt_states_num
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%5d all transition comb vector els, %5d all trans table els\n"
argument_list|,
name|transition_comb_vect_els
argument_list|,
name|transition_full_vect_els
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%5d all state alts comb vector els, %5d all state alts table els\n"
argument_list|,
name|state_alts_comb_vect_els
argument_list|,
name|state_alts_full_vect_els
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%5d all min delay table els\n"
argument_list|,
name|min_issue_delay_vect_els
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%5d locked states num\n"
argument_list|,
name|locked_states_num
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* The function output times of work of different phases of DFA    generator.  */
end_comment

begin_function
specifier|static
name|void
name|output_time_statistics
parameter_list|(
name|f
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n  transformation: "
argument_list|)
expr_stmt|;
name|print_active_time
argument_list|(
name|f
argument_list|,
name|transform_time
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
operator|(
operator|!
name|ndfa_flag
condition|?
literal|", building DFA: "
else|:
literal|", building NDFA: "
operator|)
argument_list|)
expr_stmt|;
name|print_active_time
argument_list|(
name|f
argument_list|,
name|NDFA_time
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndfa_flag
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|", NDFA -> DFA: "
argument_list|)
expr_stmt|;
name|print_active_time
argument_list|(
name|f
argument_list|,
name|NDFA_to_DFA_time
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n  DFA minimization: "
argument_list|)
expr_stmt|;
name|print_active_time
argument_list|(
name|f
argument_list|,
name|minimize_time
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|", making insn equivalence: "
argument_list|)
expr_stmt|;
name|print_active_time
argument_list|(
name|f
argument_list|,
name|equiv_time
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n all automaton generation: "
argument_list|)
expr_stmt|;
name|print_active_time
argument_list|(
name|f
argument_list|,
name|automaton_generation_time
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|", output: "
argument_list|)
expr_stmt|;
name|print_active_time
argument_list|(
name|f
argument_list|,
name|output_time
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function generates DFA (deterministic finate state automaton)    for fast recognition of pipeline hazards.  No errors during    checking must be fixed before this function call.  */
end_comment

begin_function
specifier|static
name|void
name|generate
parameter_list|()
block|{
name|automata_num
operator|=
name|split_argument
expr_stmt|;
if|if
condition|(
name|description
operator|->
name|units_num
operator|<
name|automata_num
condition|)
name|automata_num
operator|=
name|description
operator|->
name|units_num
expr_stmt|;
name|initiate_states
argument_list|()
expr_stmt|;
name|initiate_arcs
argument_list|()
expr_stmt|;
name|initiate_automata_lists
argument_list|()
expr_stmt|;
name|initiate_pass_states
argument_list|()
expr_stmt|;
name|initiate_excl_sets
argument_list|()
expr_stmt|;
name|initiate_presence_absence_sets
argument_list|()
expr_stmt|;
name|automaton_generation_time
operator|=
name|create_ticker
argument_list|()
expr_stmt|;
name|create_automata
argument_list|()
expr_stmt|;
name|ticker_off
argument_list|(
operator|&
name|automaton_generation_time
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The following function creates insn attribute whose values are    number alternatives in insn reservations.  */
end_comment

begin_function
specifier|static
name|void
name|make_insn_alts_attr
parameter_list|()
block|{
name|int
name|i
decl_stmt|,
name|insn_num
decl_stmt|;
name|decl_t
name|decl
decl_stmt|;
name|rtx
name|condexp
decl_stmt|;
name|condexp
operator|=
name|rtx_alloc
argument_list|(
name|COND
argument_list|)
expr_stmt|;
name|XVEC
argument_list|(
name|condexp
argument_list|,
literal|0
argument_list|)
operator|=
name|rtvec_alloc
argument_list|(
operator|(
name|description
operator|->
name|insns_num
operator|-
literal|1
operator|)
operator|*
literal|2
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|condexp
argument_list|,
literal|1
argument_list|)
operator|=
name|make_numeric_value
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|insn_num
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_insn_reserv
operator|&&
name|decl
operator|!=
name|advance_cycle_insn_decl
condition|)
block|{
name|XVECEXP
argument_list|(
name|condexp
argument_list|,
literal|0
argument_list|,
literal|2
operator|*
name|insn_num
argument_list|)
operator|=
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|condexp
expr_stmt|;
name|XVECEXP
argument_list|(
name|condexp
argument_list|,
literal|0
argument_list|,
literal|2
operator|*
name|insn_num
operator|+
literal|1
argument_list|)
operator|=
name|make_numeric_value
argument_list|(
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|transformed_regexp
operator|->
name|mode
operator|!=
name|rm_oneof
condition|?
literal|1
else|:
name|REGEXP_ONEOF
argument_list|(
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|transformed_regexp
argument_list|)
operator|->
name|regexps_num
argument_list|)
expr_stmt|;
name|insn_num
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|description
operator|->
name|insns_num
operator|!=
name|insn_num
operator|+
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
name|make_internal_attr
argument_list|(
name|attr_printf
argument_list|(
sizeof|sizeof
argument_list|(
literal|"*"
argument_list|)
operator|+
name|strlen
argument_list|(
name|INSN_ALTS_FUNC_NAME
argument_list|)
operator|+
literal|1
argument_list|,
literal|"*%s"
argument_list|,
name|INSN_ALTS_FUNC_NAME
argument_list|)
argument_list|,
name|condexp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The following function creates attribute which is order number of    insn in pipeline hazard description translator.  */
end_comment

begin_function
specifier|static
name|void
name|make_internal_dfa_insn_code_attr
parameter_list|()
block|{
name|int
name|i
decl_stmt|,
name|insn_num
decl_stmt|;
name|decl_t
name|decl
decl_stmt|;
name|rtx
name|condexp
decl_stmt|;
name|condexp
operator|=
name|rtx_alloc
argument_list|(
name|COND
argument_list|)
expr_stmt|;
name|XVEC
argument_list|(
name|condexp
argument_list|,
literal|0
argument_list|)
operator|=
name|rtvec_alloc
argument_list|(
operator|(
name|description
operator|->
name|insns_num
operator|-
literal|1
operator|)
operator|*
literal|2
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|condexp
argument_list|,
literal|1
argument_list|)
operator|=
name|make_numeric_value
argument_list|(
name|DECL_INSN_RESERV
argument_list|(
name|advance_cycle_insn_decl
argument_list|)
operator|->
name|insn_num
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|insn_num
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_insn_reserv
operator|&&
name|decl
operator|!=
name|advance_cycle_insn_decl
condition|)
block|{
name|XVECEXP
argument_list|(
name|condexp
argument_list|,
literal|0
argument_list|,
literal|2
operator|*
name|insn_num
argument_list|)
operator|=
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|condexp
expr_stmt|;
name|XVECEXP
argument_list|(
name|condexp
argument_list|,
literal|0
argument_list|,
literal|2
operator|*
name|insn_num
operator|+
literal|1
argument_list|)
operator|=
name|make_numeric_value
argument_list|(
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|insn_num
argument_list|)
expr_stmt|;
name|insn_num
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|description
operator|->
name|insns_num
operator|!=
name|insn_num
operator|+
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
name|make_internal_attr
argument_list|(
name|attr_printf
argument_list|(
sizeof|sizeof
argument_list|(
literal|"*"
argument_list|)
operator|+
name|strlen
argument_list|(
name|INTERNAL_DFA_INSN_CODE_FUNC_NAME
argument_list|)
operator|+
literal|1
argument_list|,
literal|"*%s"
argument_list|,
name|INTERNAL_DFA_INSN_CODE_FUNC_NAME
argument_list|)
argument_list|,
name|condexp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The following function creates attribute which order number of insn    in pipeline hazard description translator.  */
end_comment

begin_function
specifier|static
name|void
name|make_default_insn_latency_attr
parameter_list|()
block|{
name|int
name|i
decl_stmt|,
name|insn_num
decl_stmt|;
name|decl_t
name|decl
decl_stmt|;
name|rtx
name|condexp
decl_stmt|;
name|condexp
operator|=
name|rtx_alloc
argument_list|(
name|COND
argument_list|)
expr_stmt|;
name|XVEC
argument_list|(
name|condexp
argument_list|,
literal|0
argument_list|)
operator|=
name|rtvec_alloc
argument_list|(
operator|(
name|description
operator|->
name|insns_num
operator|-
literal|1
operator|)
operator|*
literal|2
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|condexp
argument_list|,
literal|1
argument_list|)
operator|=
name|make_numeric_value
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|insn_num
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_insn_reserv
operator|&&
name|decl
operator|!=
name|advance_cycle_insn_decl
condition|)
block|{
name|XVECEXP
argument_list|(
name|condexp
argument_list|,
literal|0
argument_list|,
literal|2
operator|*
name|insn_num
argument_list|)
operator|=
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|condexp
expr_stmt|;
name|XVECEXP
argument_list|(
name|condexp
argument_list|,
literal|0
argument_list|,
literal|2
operator|*
name|insn_num
operator|+
literal|1
argument_list|)
operator|=
name|make_numeric_value
argument_list|(
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|default_latency
argument_list|)
expr_stmt|;
name|insn_num
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|description
operator|->
name|insns_num
operator|!=
name|insn_num
operator|+
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
name|make_internal_attr
argument_list|(
name|attr_printf
argument_list|(
sizeof|sizeof
argument_list|(
literal|"*"
argument_list|)
operator|+
name|strlen
argument_list|(
name|INSN_DEFAULT_LATENCY_FUNC_NAME
argument_list|)
operator|+
literal|1
argument_list|,
literal|"*%s"
argument_list|,
name|INSN_DEFAULT_LATENCY_FUNC_NAME
argument_list|)
argument_list|,
name|condexp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The following function creates attribute which returns 1 if given    output insn has bypassing and 0 otherwise.  */
end_comment

begin_function
specifier|static
name|void
name|make_bypass_attr
parameter_list|()
block|{
name|int
name|i
decl_stmt|,
name|bypass_insn
decl_stmt|;
name|int
name|bypass_insns_num
init|=
literal|0
decl_stmt|;
name|decl_t
name|decl
decl_stmt|;
name|rtx
name|result_rtx
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_insn_reserv
operator|&&
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|condexp
operator|!=
name|NULL
operator|&&
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|bypass_list
operator|!=
name|NULL
condition|)
name|bypass_insns_num
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|bypass_insns_num
operator|==
literal|0
condition|)
name|result_rtx
operator|=
name|make_numeric_value
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|result_rtx
operator|=
name|rtx_alloc
argument_list|(
name|COND
argument_list|)
expr_stmt|;
name|XVEC
argument_list|(
name|result_rtx
argument_list|,
literal|0
argument_list|)
operator|=
name|rtvec_alloc
argument_list|(
name|bypass_insns_num
operator|*
literal|2
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|result_rtx
argument_list|,
literal|1
argument_list|)
operator|=
name|make_numeric_value
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|bypass_insn
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_insn_reserv
operator|&&
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|condexp
operator|!=
name|NULL
operator|&&
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|bypass_list
operator|!=
name|NULL
condition|)
block|{
name|XVECEXP
argument_list|(
name|result_rtx
argument_list|,
literal|0
argument_list|,
literal|2
operator|*
name|bypass_insn
argument_list|)
operator|=
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|condexp
expr_stmt|;
name|XVECEXP
argument_list|(
name|result_rtx
argument_list|,
literal|0
argument_list|,
literal|2
operator|*
name|bypass_insn
operator|+
literal|1
argument_list|)
operator|=
name|make_numeric_value
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|bypass_insn
operator|++
expr_stmt|;
block|}
block|}
block|}
name|make_internal_attr
argument_list|(
name|attr_printf
argument_list|(
sizeof|sizeof
argument_list|(
literal|"*"
argument_list|)
operator|+
name|strlen
argument_list|(
name|BYPASS_P_FUNC_NAME
argument_list|)
operator|+
literal|1
argument_list|,
literal|"*%s"
argument_list|,
name|BYPASS_P_FUNC_NAME
argument_list|)
argument_list|,
name|result_rtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This page mainly contains top level functions of pipeline hazards    description translator.  */
end_comment

begin_comment
comment|/* The following macro value is suffix of name of description file of    pipeline hazards description translator.  */
end_comment

begin_define
define|#
directive|define
name|STANDARD_OUTPUT_DESCRIPTION_FILE_SUFFIX
value|".dfa"
end_define

begin_comment
comment|/* The function returns suffix of given file name.  The returned    string can not be changed.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|file_name_suffix
parameter_list|(
name|file_name
parameter_list|)
specifier|const
name|char
modifier|*
name|file_name
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|last_period
decl_stmt|;
for|for
control|(
name|last_period
operator|=
name|NULL
init|;
operator|*
name|file_name
operator|!=
literal|'\0'
condition|;
name|file_name
operator|++
control|)
if|if
condition|(
operator|*
name|file_name
operator|==
literal|'.'
condition|)
name|last_period
operator|=
name|file_name
expr_stmt|;
return|return
operator|(
name|last_period
operator|==
name|NULL
condition|?
name|file_name
else|:
name|last_period
operator|)
return|;
block|}
end_function

begin_comment
comment|/* The function returns base name of given file name, i.e. pointer to    first char after last `/' (or `\' for WIN32) in given file name,    given file name itself if the directory name is absent.  The    returned string can not be changed.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|base_file_name
parameter_list|(
name|file_name
parameter_list|)
specifier|const
name|char
modifier|*
name|file_name
decl_stmt|;
block|{
name|int
name|directory_name_length
decl_stmt|;
name|directory_name_length
operator|=
name|strlen
argument_list|(
name|file_name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|WIN32
while|while
condition|(
name|directory_name_length
operator|>=
literal|0
operator|&&
name|file_name
index|[
name|directory_name_length
index|]
operator|!=
literal|'/'
operator|&&
name|file_name
index|[
name|directory_name_length
index|]
operator|!=
literal|'\\'
condition|)
else|#
directive|else
while|while
condition|(
name|directory_name_length
operator|>=
literal|0
operator|&&
name|file_name
index|[
name|directory_name_length
index|]
operator|!=
literal|'/'
condition|)
endif|#
directive|endif
name|directory_name_length
operator|--
expr_stmt|;
return|return
name|file_name
operator|+
name|directory_name_length
operator|+
literal|1
return|;
block|}
end_function

begin_comment
comment|/* The following is top level function to initialize the work of    pipeline hazards description translator.  */
end_comment

begin_function
name|void
name|initiate_automaton_gen
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|base_name
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ndfa_flag
operator|=
literal|0
expr_stmt|;
name|split_argument
operator|=
literal|0
expr_stmt|;
comment|/* default value */
name|no_minimization_flag
operator|=
literal|0
expr_stmt|;
name|time_flag
operator|=
literal|0
expr_stmt|;
name|v_flag
operator|=
literal|0
expr_stmt|;
name|w_flag
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|NO_MINIMIZATION_OPTION
argument_list|)
operator|==
literal|0
condition|)
name|no_minimization_flag
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|TIME_OPTION
argument_list|)
operator|==
literal|0
condition|)
name|time_flag
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|V_OPTION
argument_list|)
operator|==
literal|0
condition|)
name|v_flag
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|W_OPTION
argument_list|)
operator|==
literal|0
condition|)
name|w_flag
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|NDFA_OPTION
argument_list|)
operator|==
literal|0
condition|)
name|ndfa_flag
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-split"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|+
literal|1
operator|>=
name|argc
condition|)
name|fatal
argument_list|(
literal|"-split has no argument."
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
literal|"option `-split' has not been implemented yet\n"
argument_list|)
expr_stmt|;
comment|/* split_argument = atoi (argument_vect [i + 1]); */
block|}
name|VLA_PTR_CREATE
argument_list|(
name|decls
argument_list|,
literal|150
argument_list|,
literal|"decls"
argument_list|)
expr_stmt|;
comment|/* Initialize IR storage.  */
name|obstack_init
argument_list|(
operator|&
name|irp
argument_list|)
expr_stmt|;
name|initiate_automaton_decl_table
argument_list|()
expr_stmt|;
name|initiate_insn_decl_table
argument_list|()
expr_stmt|;
name|initiate_decl_table
argument_list|()
expr_stmt|;
name|output_file
operator|=
name|stdout
expr_stmt|;
name|output_description_file
operator|=
name|NULL
expr_stmt|;
name|base_name
operator|=
name|base_file_name
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|irp
argument_list|,
name|base_name
argument_list|,
name|strlen
argument_list|(
name|base_name
argument_list|)
operator|-
name|strlen
argument_list|(
name|file_name_suffix
argument_list|(
name|base_name
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|irp
argument_list|,
name|STANDARD_OUTPUT_DESCRIPTION_FILE_SUFFIX
argument_list|,
name|strlen
argument_list|(
name|STANDARD_OUTPUT_DESCRIPTION_FILE_SUFFIX
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|irp
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
name|output_description_file_name
operator|=
name|obstack_base
argument_list|(
operator|&
name|irp
argument_list|)
expr_stmt|;
name|obstack_finish
argument_list|(
operator|&
name|irp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The following function checks existence at least one arc marked by    each insn.  */
end_comment

begin_function
specifier|static
name|void
name|check_automata_insn_issues
parameter_list|()
block|{
name|automaton_t
name|automaton
decl_stmt|;
name|ainsn_t
name|ainsn
decl_stmt|,
name|reserv_ainsn
decl_stmt|;
for|for
control|(
name|automaton
operator|=
name|description
operator|->
name|first_automaton
init|;
name|automaton
operator|!=
name|NULL
condition|;
name|automaton
operator|=
name|automaton
operator|->
name|next_automaton
control|)
block|{
for|for
control|(
name|ainsn
operator|=
name|automaton
operator|->
name|ainsn_list
init|;
name|ainsn
operator|!=
name|NULL
condition|;
name|ainsn
operator|=
name|ainsn
operator|->
name|next_ainsn
control|)
if|if
condition|(
name|ainsn
operator|->
name|first_insn_with_same_reservs
operator|&&
operator|!
name|ainsn
operator|->
name|arc_exists_p
condition|)
block|{
for|for
control|(
name|reserv_ainsn
operator|=
name|ainsn
init|;
name|reserv_ainsn
operator|!=
name|NULL
condition|;
name|reserv_ainsn
operator|=
name|reserv_ainsn
operator|->
name|next_same_reservs_insn
control|)
if|if
condition|(
name|automaton
operator|->
name|corresponding_automaton_decl
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|w_flag
condition|)
name|error
argument_list|(
literal|"Automaton `%s': Insn `%s' will never be issued"
argument_list|,
name|automaton
operator|->
name|corresponding_automaton_decl
operator|->
name|name
argument_list|,
name|reserv_ainsn
operator|->
name|insn_reserv_decl
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"Automaton `%s': Insn `%s' will never be issued"
argument_list|,
name|automaton
operator|->
name|corresponding_automaton_decl
operator|->
name|name
argument_list|,
name|reserv_ainsn
operator|->
name|insn_reserv_decl
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|w_flag
condition|)
name|error
argument_list|(
literal|"Insn `%s' will never be issued"
argument_list|,
name|reserv_ainsn
operator|->
name|insn_reserv_decl
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"Insn `%s' will never be issued"
argument_list|,
name|reserv_ainsn
operator|->
name|insn_reserv_decl
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* The following vla is used for storing pointers to all achieved    states.  */
end_comment

begin_decl_stmt
specifier|static
name|vla_ptr_t
name|automaton_states
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This function is called by function pass_states to add an achieved    STATE.  */
end_comment

begin_function
specifier|static
name|void
name|add_automaton_state
parameter_list|(
name|state
parameter_list|)
name|state_t
name|state
decl_stmt|;
block|{
name|VLA_PTR_ADD
argument_list|(
name|automaton_states
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The following function forms list of important automata (whose    states may be changed after the insn issue) for each insn.  */
end_comment

begin_function
specifier|static
name|void
name|form_important_insn_automata_lists
parameter_list|()
block|{
name|automaton_t
name|automaton
decl_stmt|;
name|state_t
modifier|*
name|state_ptr
decl_stmt|;
name|decl_t
name|decl
decl_stmt|;
name|ainsn_t
name|ainsn
decl_stmt|;
name|arc_t
name|arc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|VLA_PTR_CREATE
argument_list|(
name|automaton_states
argument_list|,
literal|1500
argument_list|,
literal|"automaton states for forming important insn automata sets"
argument_list|)
expr_stmt|;
comment|/* Mark important ainsns.  */
for|for
control|(
name|automaton
operator|=
name|description
operator|->
name|first_automaton
init|;
name|automaton
operator|!=
name|NULL
condition|;
name|automaton
operator|=
name|automaton
operator|->
name|next_automaton
control|)
block|{
name|VLA_PTR_NULLIFY
argument_list|(
name|automaton_states
argument_list|)
expr_stmt|;
name|pass_states
argument_list|(
name|automaton
argument_list|,
name|add_automaton_state
argument_list|)
expr_stmt|;
for|for
control|(
name|state_ptr
operator|=
name|VLA_PTR_BEGIN
argument_list|(
name|automaton_states
argument_list|)
init|;
name|state_ptr
operator|<=
operator|(
name|state_t
operator|*
operator|)
name|VLA_PTR_LAST
argument_list|(
name|automaton_states
argument_list|)
condition|;
name|state_ptr
operator|++
control|)
block|{
for|for
control|(
name|arc
operator|=
name|first_out_arc
argument_list|(
operator|*
name|state_ptr
argument_list|)
init|;
name|arc
operator|!=
name|NULL
condition|;
name|arc
operator|=
name|next_out_arc
argument_list|(
name|arc
argument_list|)
control|)
if|if
condition|(
name|arc
operator|->
name|to_state
operator|!=
operator|*
name|state_ptr
condition|)
block|{
if|if
condition|(
operator|!
name|arc
operator|->
name|insn
operator|->
name|first_insn_with_same_reservs
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|ainsn
operator|=
name|arc
operator|->
name|insn
init|;
name|ainsn
operator|!=
name|NULL
condition|;
name|ainsn
operator|=
name|ainsn
operator|->
name|next_same_reservs_insn
control|)
name|ainsn
operator|->
name|important_p
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
name|VLA_PTR_DELETE
argument_list|(
name|automaton_states
argument_list|)
expr_stmt|;
comment|/* Create automata sets for the insns.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|description
operator|->
name|decls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|decl
operator|->
name|mode
operator|==
name|dm_insn_reserv
condition|)
block|{
name|automata_list_start
argument_list|()
expr_stmt|;
for|for
control|(
name|automaton
operator|=
name|description
operator|->
name|first_automaton
init|;
name|automaton
operator|!=
name|NULL
condition|;
name|automaton
operator|=
name|automaton
operator|->
name|next_automaton
control|)
for|for
control|(
name|ainsn
operator|=
name|automaton
operator|->
name|ainsn_list
init|;
name|ainsn
operator|!=
name|NULL
condition|;
name|ainsn
operator|=
name|ainsn
operator|->
name|next_ainsn
control|)
if|if
condition|(
name|ainsn
operator|->
name|important_p
operator|&&
name|ainsn
operator|->
name|insn_reserv_decl
operator|==
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|automata_list_add
argument_list|(
name|automaton
argument_list|)
expr_stmt|;
break|break;
block|}
name|DECL_INSN_RESERV
argument_list|(
name|decl
argument_list|)
operator|->
name|important_automata_list
operator|=
name|automata_list_finish
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* The following is top level function to generate automat(a,on) for    fast recognition of pipeline hazards.  */
end_comment

begin_function
name|void
name|expand_automata
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|description
operator|=
name|create_node
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|description
argument_list|)
comment|/* One entry for cycle advancing insn.  */
operator|+
sizeof|sizeof
argument_list|(
name|decl_t
argument_list|)
operator|*
name|VLA_PTR_LENGTH
argument_list|(
name|decls
argument_list|)
argument_list|)
expr_stmt|;
name|description
operator|->
name|decls_num
operator|=
name|VLA_PTR_LENGTH
argument_list|(
name|decls
argument_list|)
expr_stmt|;
name|description
operator|->
name|query_units_num
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|description
operator|->
name|decls_num
condition|;
name|i
operator|++
control|)
block|{
name|description
operator|->
name|decls
index|[
name|i
index|]
operator|=
name|VLA_PTR
argument_list|(
name|decls
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|description
operator|->
name|decls
index|[
name|i
index|]
operator|->
name|mode
operator|==
name|dm_unit
operator|&&
name|DECL_UNIT
argument_list|(
name|description
operator|->
name|decls
index|[
name|i
index|]
argument_list|)
operator|->
name|query_p
condition|)
name|DECL_UNIT
argument_list|(
name|description
operator|->
name|decls
index|[
name|i
index|]
argument_list|)
operator|->
name|query_num
operator|=
name|description
operator|->
name|query_units_num
operator|++
expr_stmt|;
block|}
name|all_time
operator|=
name|create_ticker
argument_list|()
expr_stmt|;
name|check_time
operator|=
name|create_ticker
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Check description..."
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|check_all_description
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"done\n"
argument_list|)
expr_stmt|;
name|ticker_off
argument_list|(
operator|&
name|check_time
argument_list|)
expr_stmt|;
name|generation_time
operator|=
name|create_ticker
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|have_error
condition|)
block|{
name|transform_insn_regexps
argument_list|()
expr_stmt|;
name|check_unit_distributions_to_automata
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|have_error
condition|)
block|{
name|generate
argument_list|()
expr_stmt|;
name|check_automata_insn_issues
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|have_error
condition|)
block|{
name|form_important_insn_automata_lists
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Generation of attributes..."
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|make_internal_dfa_insn_code_attr
argument_list|()
expr_stmt|;
name|make_insn_alts_attr
argument_list|()
expr_stmt|;
name|make_default_insn_latency_attr
argument_list|()
expr_stmt|;
name|make_bypass_attr
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"done\n"
argument_list|)
expr_stmt|;
block|}
name|ticker_off
argument_list|(
operator|&
name|generation_time
argument_list|)
expr_stmt|;
name|ticker_off
argument_list|(
operator|&
name|all_time
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"All other genattrtab stuff..."
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The following is top level function to output PHR and to finish    work with pipeline description translator.  */
end_comment

begin_function
name|void
name|write_automata
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"done\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_error
condition|)
name|fatal
argument_list|(
literal|"Errors in DFA description"
argument_list|)
expr_stmt|;
name|ticker_on
argument_list|(
operator|&
name|all_time
argument_list|)
expr_stmt|;
name|output_time
operator|=
name|create_ticker
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Forming and outputing automata tables..."
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|output_dfa_max_issue_rate
argument_list|()
expr_stmt|;
name|output_tables
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"done\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Output functions to work with automata..."
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|output_chip_definitions
argument_list|()
expr_stmt|;
name|output_max_insn_queue_index_def
argument_list|()
expr_stmt|;
name|output_internal_min_issue_delay_func
argument_list|()
expr_stmt|;
name|output_internal_trans_func
argument_list|()
expr_stmt|;
comment|/* Cache of insn dfa codes: */
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\nstatic int *%s;\n"
argument_list|,
name|DFA_INSN_CODES_VARIABLE_NAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\nstatic int %s;\n\n"
argument_list|,
name|DFA_INSN_CODES_LENGTH_VARIABLE_NAME
argument_list|)
expr_stmt|;
name|output_dfa_insn_code_func
argument_list|()
expr_stmt|;
name|output_trans_func
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\n#if %s\n\n"
argument_list|,
name|AUTOMATON_STATE_ALTS_MACRO_NAME
argument_list|)
expr_stmt|;
name|output_internal_state_alts_func
argument_list|()
expr_stmt|;
name|output_state_alts_func
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\n#endif /* #if %s */\n\n"
argument_list|,
name|AUTOMATON_STATE_ALTS_MACRO_NAME
argument_list|)
expr_stmt|;
name|output_min_issue_delay_func
argument_list|()
expr_stmt|;
name|output_internal_dead_lock_func
argument_list|()
expr_stmt|;
name|output_dead_lock_func
argument_list|()
expr_stmt|;
name|output_size_func
argument_list|()
expr_stmt|;
name|output_internal_reset_func
argument_list|()
expr_stmt|;
name|output_reset_func
argument_list|()
expr_stmt|;
name|output_min_insn_conflict_delay_func
argument_list|()
expr_stmt|;
name|output_internal_insn_latency_func
argument_list|()
expr_stmt|;
name|output_insn_latency_func
argument_list|()
expr_stmt|;
name|output_print_reservation_func
argument_list|()
expr_stmt|;
if|if
condition|(
name|no_minimization_flag
condition|)
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\n#if %s\n\n"
argument_list|,
name|CPU_UNITS_QUERY_MACRO_NAME
argument_list|)
expr_stmt|;
name|output_get_cpu_unit_code_func
argument_list|()
expr_stmt|;
name|output_cpu_unit_reservation_p
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\n#endif /* #if %s */\n\n"
argument_list|,
name|CPU_UNITS_QUERY_MACRO_NAME
argument_list|)
expr_stmt|;
block|}
name|output_dfa_start_func
argument_list|()
expr_stmt|;
name|output_dfa_finish_func
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"done\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|v_flag
condition|)
block|{
name|output_description_file
operator|=
name|fopen
argument_list|(
name|output_description_file_name
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_description_file
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|output_description_file_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Output automata description..."
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|output_description
argument_list|()
expr_stmt|;
name|output_automaton_descriptions
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"done\n"
argument_list|)
expr_stmt|;
name|output_statistics
argument_list|(
name|output_description_file
argument_list|)
expr_stmt|;
block|}
name|output_statistics
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|ticker_off
argument_list|(
operator|&
name|output_time
argument_list|)
expr_stmt|;
name|output_time_statistics
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|finish_states
argument_list|()
expr_stmt|;
name|finish_arcs
argument_list|()
expr_stmt|;
name|finish_automata_lists
argument_list|()
expr_stmt|;
if|if
condition|(
name|time_flag
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Summary:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  check time "
argument_list|)
expr_stmt|;
name|print_active_time
argument_list|(
name|stderr
argument_list|,
name|check_time
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", generation time "
argument_list|)
expr_stmt|;
name|print_active_time
argument_list|(
name|stderr
argument_list|,
name|generation_time
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", all time "
argument_list|)
expr_stmt|;
name|print_active_time
argument_list|(
name|stderr
argument_list|,
name|all_time
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Finish all work.  */
if|if
condition|(
name|output_description_file
operator|!=
name|NULL
condition|)
block|{
name|fflush
argument_list|(
name|output_description_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stdout
argument_list|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|"Error in writing DFA description file %s"
argument_list|,
name|output_description_file_name
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|output_description_file
argument_list|)
expr_stmt|;
block|}
name|finish_automaton_decl_table
argument_list|()
expr_stmt|;
name|finish_insn_decl_table
argument_list|()
expr_stmt|;
name|finish_decl_table
argument_list|()
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|irp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_error
operator|&&
name|output_description_file
operator|!=
name|NULL
condition|)
name|remove
argument_list|(
name|output_description_file_name
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

