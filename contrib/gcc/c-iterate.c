begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Build expressions with type checking for C compiler.    Copyright (C) 1987, 88, 89, 92, 93, 96, 1997, 1998 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file is part of the C front end.    It is responsible for implementing iterators,    both their declarations and the expansion of statements using them.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"c-tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* 		KEEPING TRACK OF EXPANSIONS     In order to clean out expansions corresponding to statements inside    "{(...)}" constructs we have to keep track of all expansions.  The    cleanup is needed when an automatic, or implicit, expansion on    iterator, say X, happens to a statement which contains a {(...)}    form with a statement already expanded on X.  In this case we have    to go back and cleanup the inner expansion.  This can be further    complicated by the fact that {(...)} can be nested.     To make this cleanup possible, we keep lists of all expansions, and    to make it work for nested constructs, we keep a stack.  The list at    the top of the stack (ITER_STACK.CURRENT_LEVEL) corresponds to the    currently parsed level.  All expansions of the levels below the    current one are kept in one list whose head is pointed to by    ITER_STACK.SUBLEVEL_FIRST (SUBLEVEL_LAST is there for making merges    easy).  The process works as follows:     -- On "({"  a new node is added to the stack by PUSH_ITERATOR_STACK. 	       The sublevel list is not changed at this point.     -- On "})" the list for the current level is appended to the sublevel 	      list.      -- On ";"  sublevel lists are appended to the current level lists. 	      The reason is this: if they have not been superseded by the 	      expansion at the current level, they still might be 	      superseded later by the expansion on the higher level. 	      The levels do not have to distinguish levels below, so we 	      can merge the lists together.  */
end_comment

begin_struct
struct|struct
name|ixpansion
block|{
name|tree
name|ixdecl
decl_stmt|;
comment|/* Iterator decl */
name|rtx
name|ixprologue_start
decl_stmt|;
comment|/* First insn of epilogue. NULL means */
comment|/* explicit (FOR) expansion*/
name|rtx
name|ixprologue_end
decl_stmt|;
name|rtx
name|ixepilogue_start
decl_stmt|;
name|rtx
name|ixepilogue_end
decl_stmt|;
name|struct
name|ixpansion
modifier|*
name|next
decl_stmt|;
comment|/* Next in the list */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|iter_stack_node
block|{
name|struct
name|ixpansion
modifier|*
name|first
decl_stmt|;
comment|/* Head of list of ixpansions */
name|struct
name|ixpansion
modifier|*
name|last
decl_stmt|;
comment|/* Last node in list  of ixpansions */
name|struct
name|iter_stack_node
modifier|*
name|next
decl_stmt|;
comment|/* Next level iterator stack node  */
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|iter_stack_node
modifier|*
name|iter_stack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|iter_stack_node
name|sublevel_ixpansions
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A special obstack, and a pointer to the start of    all the data in it (so we can free everything easily).  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|ixp_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ixp_firstobj
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* During collect_iterators, a list of SAVE_EXPRs already scanned.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|save_exprs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|expand_stmt_with_iterators_1
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|collect_iterators
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|iterator_loop_prologue
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|rtx
operator|*
operator|,
name|rtx
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|iterator_loop_epilogue
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|rtx
operator|*
operator|,
name|rtx
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|top_level_ixpansion_p
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|isn_append
name|PROTO
argument_list|(
operator|(
expr|struct
name|iter_stack_node
operator|*
operator|,
expr|struct
name|iter_stack_node
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|istack_sublevel_to_current
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_ixpansion
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|delete_ixpansion
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Initialize our obstack once per compilation.  */
end_comment

begin_function
name|void
name|init_iterators
parameter_list|()
block|{
name|gcc_obstack_init
argument_list|(
operator|&
name|ixp_obstack
argument_list|)
expr_stmt|;
name|ixp_firstobj
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|ixp_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the start of an explicit `for' loop for iterator IDECL.  */
end_comment

begin_function
name|void
name|iterator_for_loop_start
parameter_list|(
name|idecl
parameter_list|)
name|tree
name|idecl
decl_stmt|;
block|{
name|ITERATOR_BOUND_P
argument_list|(
name|idecl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|add_ixpansion
argument_list|(
name|idecl
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|iterator_loop_prologue
argument_list|(
name|idecl
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the end of an explicit `for' loop for iterator IDECL.  */
end_comment

begin_function
name|void
name|iterator_for_loop_end
parameter_list|(
name|idecl
parameter_list|)
name|tree
name|idecl
decl_stmt|;
block|{
name|iterator_loop_epilogue
argument_list|(
name|idecl
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ITERATOR_BOUND_P
argument_list|(
name|idecl
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*   		ITERATOR RTL EXPANSIONS     Expanding simple statements with iterators is straightforward:    collect the list of all free iterators in the statement, and    generate a loop for each of them.     An iterator is "free" if it has not been "bound" by a FOR    operator.  The DECL_RTL of the iterator is the loop counter.  */
end_comment

begin_comment
comment|/* Expand a statement STMT, possibly containing iterator usage, into RTL.  */
end_comment

begin_function
name|void
name|iterator_expand
parameter_list|(
name|stmt
parameter_list|)
name|tree
name|stmt
decl_stmt|;
block|{
name|tree
name|iter_list
decl_stmt|;
name|save_exprs
operator|=
name|NULL_TREE
expr_stmt|;
name|iter_list
operator|=
name|collect_iterators
argument_list|(
name|stmt
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|expand_stmt_with_iterators_1
argument_list|(
name|stmt
argument_list|,
name|iter_list
argument_list|)
expr_stmt|;
name|istack_sublevel_to_current
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|expand_stmt_with_iterators_1
parameter_list|(
name|stmt
parameter_list|,
name|iter_list
parameter_list|)
name|tree
name|stmt
decl_stmt|,
name|iter_list
decl_stmt|;
block|{
if|if
condition|(
name|iter_list
operator|==
literal|0
condition|)
name|expand_expr_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|current_iterator
init|=
name|TREE_VALUE
argument_list|(
name|iter_list
argument_list|)
decl_stmt|;
name|tree
name|iter_list_tail
init|=
name|TREE_CHAIN
argument_list|(
name|iter_list
argument_list|)
decl_stmt|;
name|rtx
name|p_start
decl_stmt|,
name|p_end
decl_stmt|,
name|e_start
decl_stmt|,
name|e_end
decl_stmt|;
name|iterator_loop_prologue
argument_list|(
name|current_iterator
argument_list|,
operator|&
name|p_start
argument_list|,
operator|&
name|p_end
argument_list|)
expr_stmt|;
name|expand_stmt_with_iterators_1
argument_list|(
name|stmt
argument_list|,
name|iter_list_tail
argument_list|)
expr_stmt|;
name|iterator_loop_epilogue
argument_list|(
name|current_iterator
argument_list|,
operator|&
name|e_start
argument_list|,
operator|&
name|e_end
argument_list|)
expr_stmt|;
comment|/** Delete all inner expansions based on current_iterator **/
comment|/** before adding the outer one. **/
name|delete_ixpansion
argument_list|(
name|current_iterator
argument_list|)
expr_stmt|;
name|add_ixpansion
argument_list|(
name|current_iterator
argument_list|,
name|p_start
argument_list|,
name|p_end
argument_list|,
name|e_start
argument_list|,
name|e_end
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return a list containing all the free (i.e. not bound by a    containing `for' statement) iterators mentioned in EXP, plus those    in LIST.  Do not add duplicate entries to the list.  */
end_comment

begin_function
specifier|static
name|tree
name|collect_iterators
parameter_list|(
name|exp
parameter_list|,
name|list
parameter_list|)
name|tree
name|exp
decl_stmt|,
name|list
decl_stmt|;
block|{
if|if
condition|(
name|exp
operator|==
literal|0
condition|)
return|return
name|list
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|VAR_DECL
case|:
if|if
condition|(
operator|!
name|ITERATOR_P
argument_list|(
name|exp
argument_list|)
operator|||
name|ITERATOR_BOUND_P
argument_list|(
name|exp
argument_list|)
condition|)
return|return
name|list
return|;
if|if
condition|(
name|value_member
argument_list|(
name|exp
argument_list|,
name|list
argument_list|)
condition|)
return|return
name|list
return|;
return|return
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|exp
argument_list|,
name|list
argument_list|)
return|;
case|case
name|TREE_LIST
case|:
block|{
name|tree
name|tail
decl_stmt|;
for|for
control|(
name|tail
operator|=
name|exp
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
name|list
operator|=
name|collect_iterators
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|,
name|list
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
case|case
name|SAVE_EXPR
case|:
comment|/* In each scan, scan a given save_expr only once.  */
if|if
condition|(
name|value_member
argument_list|(
name|exp
argument_list|,
name|save_exprs
argument_list|)
condition|)
return|return
name|list
return|;
name|save_exprs
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|exp
argument_list|,
name|save_exprs
argument_list|)
expr_stmt|;
return|return
name|collect_iterators
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|list
argument_list|)
return|;
comment|/* we do not automatically iterate blocks -- one must */
comment|/* use the FOR construct to do that */
case|case
name|BLOCK
case|:
return|return
name|list
return|;
default|default:
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
block|{
case|case
literal|'1'
case|:
return|return
name|collect_iterators
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|list
argument_list|)
return|;
case|case
literal|'2'
case|:
case|case
literal|'<'
case|:
return|return
name|collect_iterators
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|collect_iterators
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|list
argument_list|)
argument_list|)
return|;
case|case
literal|'e'
case|:
case|case
literal|'r'
case|:
block|{
name|int
name|num_args
init|=
name|tree_code_length
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Some tree codes have RTL, not trees, as operands.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|CALL_EXPR
case|:
name|num_args
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|METHOD_CALL_EXPR
case|:
name|num_args
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|WITH_CLEANUP_EXPR
case|:
name|num_args
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|RTL_EXPR
case|:
return|return
name|list
return|;
default|default:
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_args
condition|;
name|i
operator|++
control|)
name|list
operator|=
name|collect_iterators
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
name|i
argument_list|)
argument_list|,
name|list
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
default|default:
return|return
name|list
return|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit rtl for the start of a loop for iterator IDECL.     If necessary, create loop counter rtx and store it as DECL_RTL of IDECL.     The prologue normally starts and ends with notes, which are returned    by this function in *START_NOTE and *END_NODE.    If START_NOTE and END_NODE are 0, we don't make those notes.  */
end_comment

begin_function
specifier|static
name|void
name|iterator_loop_prologue
parameter_list|(
name|idecl
parameter_list|,
name|start_note
parameter_list|,
name|end_note
parameter_list|)
name|tree
name|idecl
decl_stmt|;
name|rtx
modifier|*
name|start_note
decl_stmt|,
decl|*
name|end_note
decl_stmt|;
end_function

begin_block
block|{
name|tree
name|expr
decl_stmt|;
comment|/* Force the save_expr in DECL_INITIAL to be calculated      if it hasn't been calculated yet.  */
name|expand_expr
argument_list|(
name|DECL_INITIAL
argument_list|(
name|idecl
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_RTL
argument_list|(
name|idecl
argument_list|)
operator|==
literal|0
condition|)
name|expand_decl
argument_list|(
name|idecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_note
condition|)
operator|*
name|start_note
operator|=
name|emit_note
argument_list|(
literal|0
argument_list|,
name|NOTE_INSN_DELETED
argument_list|)
expr_stmt|;
comment|/* Initialize counter.  */
name|expr
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|idecl
argument_list|)
argument_list|,
name|idecl
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|expr
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|expr
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
name|expand_start_loop_continue_elsewhere
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ITERATOR_BOUND_P
argument_list|(
name|idecl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|end_note
condition|)
operator|*
name|end_note
operator|=
name|emit_note
argument_list|(
literal|0
argument_list|,
name|NOTE_INSN_DELETED
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Similar to the previous function, but for the end of the loop.     DECL_RTL is zeroed unless we are inside "({...})". The reason for that is    described below.     When we create two (or more) loops based on the same IDECL, and    both inside the same "({...})"  construct, we must be prepared to    delete both of the loops and create a single one on the level    above, i.e.  enclosing the "({...})". The new loop has to use the    same counter rtl because the references to the iterator decl    (IDECL) have already been expanded as references to the counter    rtl.     It is incorrect to use the same counter reg in different functions,    and it is desirable to use different counters in disjoint loops    when we know there's no need to combine them (because then they can    get allocated separately).  */
end_comment

begin_function
specifier|static
name|void
name|iterator_loop_epilogue
parameter_list|(
name|idecl
parameter_list|,
name|start_note
parameter_list|,
name|end_note
parameter_list|)
name|tree
name|idecl
decl_stmt|;
name|rtx
modifier|*
name|start_note
decl_stmt|,
decl|*
name|end_note
decl_stmt|;
end_function

begin_block
block|{
name|tree
name|test
decl_stmt|,
name|incr
decl_stmt|;
if|if
condition|(
name|start_note
condition|)
operator|*
name|start_note
operator|=
name|emit_note
argument_list|(
literal|0
argument_list|,
name|NOTE_INSN_DELETED
argument_list|)
expr_stmt|;
name|expand_loop_continue_here
argument_list|()
expr_stmt|;
name|incr
operator|=
name|build_binary_op
argument_list|(
name|PLUS_EXPR
argument_list|,
name|idecl
argument_list|,
name|integer_one_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|incr
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|idecl
argument_list|)
argument_list|,
name|idecl
argument_list|,
name|incr
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|incr
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|incr
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
name|test
operator|=
name|build_binary_op
argument_list|(
name|LT_EXPR
argument_list|,
name|idecl
argument_list|,
name|DECL_INITIAL
argument_list|(
name|idecl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_exit_loop_if_false
argument_list|(
literal|0
argument_list|,
name|test
argument_list|)
expr_stmt|;
name|expand_end_loop
argument_list|()
expr_stmt|;
name|ITERATOR_BOUND_P
argument_list|(
name|idecl
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* we can reset rtl since there is not chance that this expansion */
comment|/* would be superseded by a higher level one */
comment|/* but don't do this if the decl is static, since we need to share */
comment|/* the same decl in that case.  */
if|if
condition|(
name|top_level_ixpansion_p
argument_list|()
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|idecl
argument_list|)
condition|)
name|DECL_RTL
argument_list|(
name|idecl
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|end_note
condition|)
operator|*
name|end_note
operator|=
name|emit_note
argument_list|(
literal|0
argument_list|,
name|NOTE_INSN_DELETED
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Return true if we are not currently inside a "({...})" construct.  */
end_comment

begin_function
specifier|static
name|int
name|top_level_ixpansion_p
parameter_list|()
block|{
return|return
name|iter_stack
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Given two chains of iter_stack_nodes,    append the nodes in X into Y.  */
end_comment

begin_function
specifier|static
name|void
name|isn_append
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|struct
name|iter_stack_node
modifier|*
name|x
decl_stmt|,
decl|*
name|y
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|x
operator|->
name|first
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|y
operator|->
name|first
operator|==
literal|0
condition|)
block|{
name|y
operator|->
name|first
operator|=
name|x
operator|->
name|first
expr_stmt|;
name|y
operator|->
name|last
operator|=
name|x
operator|->
name|last
expr_stmt|;
block|}
else|else
block|{
name|y
operator|->
name|last
operator|->
name|next
operator|=
name|x
operator|->
name|first
expr_stmt|;
name|y
operator|->
name|last
operator|=
name|x
operator|->
name|last
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/** Make X empty **/
end_comment

begin_define
define|#
directive|define
name|ISN_ZERO
parameter_list|(
name|X
parameter_list|)
value|(X).first=(X).last=0
end_define

begin_escape
end_escape

begin_comment
comment|/* Move the ixpansions in sublevel_ixpansions into the current    node on the iter_stack, or discard them if the iter_stack is empty.    We do this at the end of a statement.  */
end_comment

begin_function
specifier|static
name|void
name|istack_sublevel_to_current
parameter_list|()
block|{
comment|/* At the top level we can throw away sublevel's expansions  **/
comment|/* because there is nobody above us to ask for a cleanup **/
if|if
condition|(
name|iter_stack
operator|!=
literal|0
condition|)
comment|/** Merging with empty sublevel list is a no-op **/
if|if
condition|(
name|sublevel_ixpansions
operator|.
name|last
condition|)
name|isn_append
argument_list|(
operator|&
name|sublevel_ixpansions
argument_list|,
name|iter_stack
argument_list|)
expr_stmt|;
if|if
condition|(
name|iter_stack
operator|==
literal|0
condition|)
name|obstack_free
argument_list|(
operator|&
name|ixp_obstack
argument_list|,
name|ixp_firstobj
argument_list|)
expr_stmt|;
name|ISN_ZERO
argument_list|(
name|sublevel_ixpansions
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Push a new node on the iter_stack, when we enter a ({...}).  */
end_comment

begin_function
name|void
name|push_iterator_stack
parameter_list|()
block|{
name|struct
name|iter_stack_node
modifier|*
name|new_top
init|=
operator|(
expr|struct
name|iter_stack_node
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|ixp_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|iter_stack_node
argument_list|)
argument_list|)
decl_stmt|;
name|new_top
operator|->
name|first
operator|=
literal|0
expr_stmt|;
name|new_top
operator|->
name|last
operator|=
literal|0
expr_stmt|;
name|new_top
operator|->
name|next
operator|=
name|iter_stack
expr_stmt|;
name|iter_stack
operator|=
name|new_top
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pop iter_stack, moving the ixpansions in the node being popped    into sublevel_ixpansions.  */
end_comment

begin_function
name|void
name|pop_iterator_stack
parameter_list|()
block|{
if|if
condition|(
name|iter_stack
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|isn_append
argument_list|(
name|iter_stack
argument_list|,
operator|&
name|sublevel_ixpansions
argument_list|)
expr_stmt|;
comment|/** Pop current level node: */
name|iter_stack
operator|=
name|iter_stack
operator|->
name|next
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Record an iterator expansion ("ixpansion") for IDECL.    The remaining parameters are the notes in the loop entry    and exit rtl.  */
end_comment

begin_function
specifier|static
name|void
name|add_ixpansion
parameter_list|(
name|idecl
parameter_list|,
name|pro_start
parameter_list|,
name|pro_end
parameter_list|,
name|epi_start
parameter_list|,
name|epi_end
parameter_list|)
name|tree
name|idecl
decl_stmt|;
name|rtx
name|pro_start
decl_stmt|,
name|pro_end
decl_stmt|,
name|epi_start
decl_stmt|,
name|epi_end
decl_stmt|;
block|{
name|struct
name|ixpansion
modifier|*
name|newix
decl_stmt|;
comment|/* Do nothing if we are not inside "({...})",      as in that case this expansion can't need subsequent RTL modification.  */
if|if
condition|(
name|iter_stack
operator|==
literal|0
condition|)
return|return;
name|newix
operator|=
operator|(
expr|struct
name|ixpansion
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|ixp_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ixpansion
argument_list|)
argument_list|)
expr_stmt|;
name|newix
operator|->
name|ixdecl
operator|=
name|idecl
expr_stmt|;
name|newix
operator|->
name|ixprologue_start
operator|=
name|pro_start
expr_stmt|;
name|newix
operator|->
name|ixprologue_end
operator|=
name|pro_end
expr_stmt|;
name|newix
operator|->
name|ixepilogue_start
operator|=
name|epi_start
expr_stmt|;
name|newix
operator|->
name|ixepilogue_end
operator|=
name|epi_end
expr_stmt|;
name|newix
operator|->
name|next
operator|=
name|iter_stack
operator|->
name|first
expr_stmt|;
name|iter_stack
operator|->
name|first
operator|=
name|newix
expr_stmt|;
if|if
condition|(
name|iter_stack
operator|->
name|last
operator|==
literal|0
condition|)
name|iter_stack
operator|->
name|last
operator|=
name|newix
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Delete the RTL for all ixpansions for iterator IDECL    in our sublevels.  We do this when we make a larger    containing expansion for IDECL.  */
end_comment

begin_function
specifier|static
name|void
name|delete_ixpansion
parameter_list|(
name|idecl
parameter_list|)
name|tree
name|idecl
decl_stmt|;
block|{
name|struct
name|ixpansion
modifier|*
name|previx
init|=
literal|0
decl_stmt|,
modifier|*
name|ix
decl_stmt|;
for|for
control|(
name|ix
operator|=
name|sublevel_ixpansions
operator|.
name|first
init|;
name|ix
condition|;
name|ix
operator|=
name|ix
operator|->
name|next
control|)
if|if
condition|(
name|ix
operator|->
name|ixdecl
operator|==
name|idecl
condition|)
block|{
comment|/** zero means that this is a mark for FOR -- **/
comment|/** we do not delete anything, just issue an error. **/
if|if
condition|(
name|ix
operator|->
name|ixprologue_start
operator|==
literal|0
condition|)
name|error_with_decl
argument_list|(
name|idecl
argument_list|,
literal|"`for (%s)' appears within implicit iteration"
argument_list|)
expr_stmt|;
else|else
block|{
name|rtx
name|insn
decl_stmt|;
comment|/* We delete all insns, including notes because leaving loop */
comment|/* notes and barriers produced by iterator expansion would */
comment|/* be misleading to other phases */
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|ix
operator|->
name|ixprologue_start
argument_list|)
init|;
name|insn
operator|!=
name|ix
operator|->
name|ixprologue_end
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|ix
operator|->
name|ixepilogue_start
argument_list|)
init|;
name|insn
operator|!=
name|ix
operator|->
name|ixepilogue_end
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* Delete this ixpansion from sublevel_ixpansions.  */
if|if
condition|(
name|previx
condition|)
name|previx
operator|->
name|next
operator|=
name|ix
operator|->
name|next
expr_stmt|;
else|else
name|sublevel_ixpansions
operator|.
name|first
operator|=
name|ix
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|sublevel_ixpansions
operator|.
name|last
operator|==
name|ix
condition|)
name|sublevel_ixpansions
operator|.
name|last
operator|=
name|previx
expr_stmt|;
block|}
else|else
name|previx
operator|=
name|ix
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_ITERATORS
end_ifdef

begin_comment
comment|/* The functions below are for use from source level debugger.    They print short forms of iterator lists and the iterator stack.  */
end_comment

begin_comment
comment|/* Print the name of the iterator D.  */
end_comment

begin_function
name|void
name|prdecl
parameter_list|(
name|d
parameter_list|)
name|tree
name|d
decl_stmt|;
block|{
if|if
condition|(
name|d
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|d
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
name|tree
name|tname
init|=
name|DECL_NAME
argument_list|(
name|d
argument_list|)
decl_stmt|;
name|char
modifier|*
name|dname
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|tname
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|dname
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"<<?>>"
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"<<0>>"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print Iterator List -- names only */
end_comment

begin_function
name|tree
name|pil
parameter_list|(
name|head
parameter_list|)
name|tree
name|head
decl_stmt|;
block|{
name|tree
name|current
decl_stmt|,
name|next
decl_stmt|;
for|for
control|(
name|current
operator|=
name|head
init|;
name|current
condition|;
name|current
operator|=
name|next
control|)
block|{
name|tree
name|node
init|=
name|TREE_VALUE
argument_list|(
name|current
argument_list|)
decl_stmt|;
name|prdecl
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|next
operator|=
name|TREE_CHAIN
argument_list|(
name|current
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|","
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print IXpansion List */
end_comment

begin_function
name|struct
name|ixpansion
modifier|*
name|pixl
parameter_list|(
name|head
parameter_list|)
name|struct
name|ixpansion
modifier|*
name|head
decl_stmt|;
block|{
name|struct
name|ixpansion
modifier|*
name|current
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"> "
argument_list|)
expr_stmt|;
if|if
condition|(
name|head
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"(empty)"
argument_list|)
expr_stmt|;
for|for
control|(
name|current
operator|=
name|head
init|;
name|current
condition|;
name|current
operator|=
name|next
control|)
block|{
name|tree
name|node
init|=
name|current
operator|->
name|ixdecl
decl_stmt|;
name|prdecl
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|next
operator|=
name|current
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|next
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|","
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
return|return
name|head
return|;
block|}
end_function

begin_comment
comment|/* Print Iterator Stack.  */
end_comment

begin_function
name|void
name|pis
parameter_list|()
block|{
name|struct
name|iter_stack_node
modifier|*
name|stack_node
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"--SubLevel: "
argument_list|)
expr_stmt|;
name|pixl
argument_list|(
name|sublevel_ixpansions
operator|.
name|first
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"--Stack:--\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|stack_node
operator|=
name|iter_stack
init|;
name|stack_node
condition|;
name|stack_node
operator|=
name|stack_node
operator|->
name|next
control|)
name|pixl
argument_list|(
name|stack_node
operator|->
name|first
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG_ITERATORS */
end_comment

end_unit

