begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Generate code from machine description to emit insns as rtl.    Copyright (C) 1987, 88, 91, 94, 95, 97, 1998 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"hconfig.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|obstack
modifier|*
name|rtl_obstack
init|=
operator|&
name|obstack
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_decl_stmt
name|char
modifier|*
name|xmalloc
name|PROTO
argument_list|(
operator|(
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fatal
name|PVPROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
name|ATTRIBUTE_PRINTF_1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|fancy_abort
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define this so we can link with print-rtl.o to get debug_rtx function.  */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|insn_name_ptr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|max_opno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|max_dup_opno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|register_constraints
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|insn_code_number
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|insn_index_number
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Data structure for recording the patterns of insns that have CLOBBERs.    We use this to output a function that adds these CLOBBERs to a     previously-allocated PARALLEL expression.  */
end_comment

begin_struct
struct|struct
name|clobber_pat
block|{
name|struct
name|clobber_ent
modifier|*
name|insns
decl_stmt|;
name|rtx
name|pattern
decl_stmt|;
name|int
name|first_clobber
decl_stmt|;
name|struct
name|clobber_pat
modifier|*
name|next
decl_stmt|;
block|}
modifier|*
name|clobber_list
struct|;
end_struct

begin_comment
comment|/* Records one insn that uses the clobber list.  */
end_comment

begin_struct
struct|struct
name|clobber_ent
block|{
name|int
name|code_number
decl_stmt|;
comment|/* Counts only insns.  */
name|struct
name|clobber_ent
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|void
name|max_operand_1
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|max_operand_vec
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_code
name|PROTO
argument_list|(
operator|(
name|RTX_CODE
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_exp
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_insn
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_expand
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_split
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_add_clobbers
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_init_mov_optab
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
specifier|static
name|void
name|max_operand_1
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|RTX_CODE
name|code
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|MATCH_OPERAND
operator|&&
name|XSTR
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
operator|&&
operator|*
name|XSTR
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
operator|!=
literal|'\0'
condition|)
name|register_constraints
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|MATCH_SCRATCH
operator|&&
name|XSTR
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
operator|&&
operator|*
name|XSTR
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|!=
literal|'\0'
condition|)
name|register_constraints
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|MATCH_OPERAND
operator|||
name|code
operator|==
name|MATCH_OPERATOR
operator|||
name|code
operator|==
name|MATCH_PARALLEL
condition|)
name|max_opno
operator|=
name|MAX
argument_list|(
name|max_opno
argument_list|,
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|MATCH_DUP
operator|||
name|code
operator|==
name|MATCH_OP_DUP
operator|||
name|code
operator|==
name|MATCH_PAR_DUP
condition|)
name|max_dup_opno
operator|=
name|MAX
argument_list|(
name|max_dup_opno
argument_list|,
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|len
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|||
name|fmt
index|[
name|i
index|]
operator|==
literal|'u'
condition|)
name|max_operand_1
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|max_operand_1
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|max_operand_vec
parameter_list|(
name|insn
parameter_list|,
name|arg
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|int
name|arg
decl_stmt|;
block|{
specifier|register
name|int
name|len
init|=
name|XVECLEN
argument_list|(
name|insn
argument_list|,
name|arg
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|max_opno
operator|=
operator|-
literal|1
expr_stmt|;
name|max_dup_opno
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|max_operand_1
argument_list|(
name|XVECEXP
argument_list|(
name|insn
argument_list|,
name|arg
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|max_opno
operator|+
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|print_code
parameter_list|(
name|code
parameter_list|)
name|RTX_CODE
name|code
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p1
decl_stmt|;
for|for
control|(
name|p1
operator|=
name|GET_RTX_NAME
argument_list|(
name|code
argument_list|)
init|;
operator|*
name|p1
condition|;
name|p1
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p1
operator|>=
literal|'a'
operator|&&
operator|*
name|p1
operator|<=
literal|'z'
condition|)
name|putchar
argument_list|(
operator|*
name|p1
operator|+
literal|'A'
operator|-
literal|'a'
argument_list|)
expr_stmt|;
else|else
name|putchar
argument_list|(
operator|*
name|p1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print a C expression to construct an RTX just like X,    substituting any operand references appearing within.  */
end_comment

begin_function
specifier|static
name|void
name|gen_exp
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|RTX_CODE
name|code
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"NULL_RTX"
argument_list|)
expr_stmt|;
return|return;
block|}
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|MATCH_OPERAND
case|:
case|case
name|MATCH_DUP
case|:
name|printf
argument_list|(
literal|"operand%d"
argument_list|,
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|MATCH_OP_DUP
case|:
name|printf
argument_list|(
literal|"gen_rtx (GET_CODE (operand%d), "
argument_list|,
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|VOIDmode
condition|)
name|printf
argument_list|(
literal|"GET_MODE (operand%d)"
argument_list|,
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%smode"
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|",\n\t\t"
argument_list|)
expr_stmt|;
name|gen_exp
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
return|return;
case|case
name|MATCH_OPERATOR
case|:
name|printf
argument_list|(
literal|"gen_rtx (GET_CODE (operand%d)"
argument_list|,
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", %smode"
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|",\n\t\t"
argument_list|)
expr_stmt|;
name|gen_exp
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
return|return;
case|case
name|MATCH_PARALLEL
case|:
case|case
name|MATCH_PAR_DUP
case|:
name|printf
argument_list|(
literal|"operand%d"
argument_list|,
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|MATCH_SCRATCH
case|:
name|printf
argument_list|(
literal|"gen_rtx_SCRATCH (%smode)"
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|ADDRESS
case|:
name|fatal
argument_list|(
literal|"ADDRESS expression code used in named instruction pattern"
argument_list|)
expr_stmt|;
case|case
name|PC
case|:
name|printf
argument_list|(
literal|"pc_rtx"
argument_list|)
expr_stmt|;
return|return;
case|case
name|CC0
case|:
name|printf
argument_list|(
literal|"cc0_rtx"
argument_list|)
expr_stmt|;
return|return;
case|case
name|CONST_INT
case|:
if|if
condition|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"const0_rtx"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|==
literal|1
condition|)
name|printf
argument_list|(
literal|"const1_rtx"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|printf
argument_list|(
literal|"constm1_rtx"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|==
name|STORE_FLAG_VALUE
condition|)
name|printf
argument_list|(
literal|"const_true_rtx"
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"GEN_INT ("
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|CONST_DOUBLE
case|:
comment|/* These shouldn't be written in MD files.  Instead, the appropriate 	 routines in varasm.c should be called.  */
name|abort
argument_list|()
expr_stmt|;
default|default:
break|break;
block|}
name|printf
argument_list|(
literal|"gen_rtx_"
argument_list|)
expr_stmt|;
name|print_code
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" (%smode"
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|len
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'0'
condition|)
break|break;
name|printf
argument_list|(
literal|",\n\t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|||
name|fmt
index|[
name|i
index|]
operator|==
literal|'u'
condition|)
name|gen_exp
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'i'
condition|)
name|printf
argument_list|(
literal|"%u"
argument_list|,
name|XINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'s'
condition|)
name|printf
argument_list|(
literal|"\"%s\""
argument_list|,
name|XSTR
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
name|printf
argument_list|(
literal|"gen_rtvec (%d"
argument_list|,
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|printf
argument_list|(
literal|",\n\t\t"
argument_list|)
expr_stmt|;
name|gen_exp
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
name|printf
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate the `gen_...' function for a DEFINE_INSN.  */
end_comment

begin_function
specifier|static
name|void
name|gen_insn
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|operands
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* See if the pattern for this insn ends with a group of CLOBBERs of (hard)      registers or MATCH_SCRATCHes.  If so, store away the information for      later.  */
if|if
condition|(
name|XVEC
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
argument_list|)
operator|!=
name|CLOBBER
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|MATCH_SCRATCH
operator|)
condition|)
break|break;
if|if
condition|(
name|i
operator|!=
name|XVECLEN
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
operator|-
literal|1
condition|)
block|{
specifier|register
name|struct
name|clobber_pat
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|clobber_ent
modifier|*
name|link
init|=
operator|(
expr|struct
name|clobber_ent
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|clobber_ent
argument_list|)
argument_list|)
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
name|link
operator|->
name|code_number
operator|=
name|insn_code_number
expr_stmt|;
comment|/* See if any previous CLOBBER_LIST entry is the same as this 	     one.  */
for|for
control|(
name|p
operator|=
name|clobber_list
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|first_clobber
operator|!=
name|i
operator|+
literal|1
operator|||
name|XVECLEN
argument_list|(
name|p
operator|->
name|pattern
argument_list|,
literal|1
argument_list|)
operator|!=
name|XVECLEN
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|rtx
name|old
init|=
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|p
operator|->
name|pattern
argument_list|,
literal|1
argument_list|,
name|j
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|new
init|=
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|,
name|j
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* OLD and NEW are the same if both are to be a SCRATCH 		     of the same mode,  		     or if both are registers of the same mode and number.  */
if|if
condition|(
operator|!
operator|(
name|GET_MODE
argument_list|(
name|old
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|new
argument_list|)
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|old
argument_list|)
operator|==
name|MATCH_SCRATCH
operator|&&
name|GET_CODE
argument_list|(
name|new
argument_list|)
operator|==
name|MATCH_SCRATCH
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|old
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|new
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|old
argument_list|)
operator|==
name|REGNO
argument_list|(
name|new
argument_list|)
operator|)
operator|)
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|j
operator|==
name|XVECLEN
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|p
operator|==
literal|0
condition|)
block|{
name|p
operator|=
operator|(
expr|struct
name|clobber_pat
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|clobber_pat
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|insns
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|pattern
operator|=
name|insn
expr_stmt|;
name|p
operator|->
name|first_clobber
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|clobber_list
expr_stmt|;
name|clobber_list
operator|=
name|p
expr_stmt|;
block|}
name|link
operator|->
name|next
operator|=
name|p
operator|->
name|insns
expr_stmt|;
name|p
operator|->
name|insns
operator|=
name|link
expr_stmt|;
block|}
block|}
comment|/* Don't mention instructions whose names are the null string      or begin with '*'.  They are in the machine description just      to be recognized.  */
if|if
condition|(
name|XSTR
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
index|[
literal|0
index|]
operator|==
literal|0
operator|||
name|XSTR
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
return|return;
comment|/* Find out how many operands this function has,      and also whether any of them have register constraints.  */
name|register_constraints
operator|=
literal|0
expr_stmt|;
name|operands
operator|=
name|max_operand_vec
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_dup_opno
operator|>=
name|operands
condition|)
name|fatal
argument_list|(
literal|"match_dup operand number has no match_operand"
argument_list|)
expr_stmt|;
comment|/* Output the function name and argument declarations.  */
name|printf
argument_list|(
literal|"rtx\ngen_%s ("
argument_list|,
name|XSTR
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|operands
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
name|i
condition|?
literal|", operand%d"
else|:
literal|"operand%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|operands
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"     rtx operand%d;\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"{\n"
argument_list|)
expr_stmt|;
comment|/* Output code to construct and return the rtl for the instruction body */
if|if
condition|(
name|XVECLEN
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
operator|==
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"  return "
argument_list|)
expr_stmt|;
name|gen_exp
argument_list|(
name|XVECEXP
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|";\n}\n\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"  return gen_rtx_PARALLEL (VOIDmode, gen_rtvec (%d"
argument_list|,
name|XVECLEN
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|",\n\t\t"
argument_list|)
expr_stmt|;
name|gen_exp
argument_list|(
name|XVECEXP
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"));\n}\n\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate the `gen_...' function for a DEFINE_EXPAND.  */
end_comment

begin_function
specifier|static
name|void
name|gen_expand
parameter_list|(
name|expand
parameter_list|)
name|rtx
name|expand
decl_stmt|;
block|{
name|int
name|operands
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|XSTR
argument_list|(
name|expand
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"define_expand lacks a name"
argument_list|)
expr_stmt|;
if|if
condition|(
name|XVEC
argument_list|(
name|expand
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"define_expand for %s lacks a pattern"
argument_list|,
name|XSTR
argument_list|(
name|expand
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Find out how many operands this function has,      and also whether any of them have register constraints.  */
name|register_constraints
operator|=
literal|0
expr_stmt|;
name|operands
operator|=
name|max_operand_vec
argument_list|(
name|expand
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Output the function name and argument declarations.  */
name|printf
argument_list|(
literal|"rtx\ngen_%s ("
argument_list|,
name|XSTR
argument_list|(
name|expand
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|operands
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
name|i
condition|?
literal|", operand%d"
else|:
literal|"operand%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|operands
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"     rtx operand%d;\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"{\n"
argument_list|)
expr_stmt|;
comment|/* If we don't have any C code to write, only one insn is being written,      and no MATCH_DUPs are present, we can just return the desired insn      like we do for a DEFINE_INSN.  This saves memory.  */
if|if
condition|(
operator|(
name|XSTR
argument_list|(
name|expand
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
operator|||
operator|*
name|XSTR
argument_list|(
name|expand
argument_list|,
literal|3
argument_list|)
operator|==
literal|'\0'
operator|)
operator|&&
name|operands
operator|>
name|max_dup_opno
operator|&&
name|XVECLEN
argument_list|(
name|expand
argument_list|,
literal|1
argument_list|)
operator|==
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"  return "
argument_list|)
expr_stmt|;
name|gen_exp
argument_list|(
name|XVECEXP
argument_list|(
name|expand
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|";\n}\n\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* For each operand referred to only with MATCH_DUPs,      make a local variable.  */
for|for
control|(
name|i
operator|=
name|operands
init|;
name|i
operator|<=
name|max_dup_opno
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"  rtx operand%d;\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|operands
operator|>
literal|0
operator|||
name|max_dup_opno
operator|>=
literal|0
condition|)
name|printf
argument_list|(
literal|"  rtx operands[%d];\n"
argument_list|,
name|MAX
argument_list|(
name|operands
argument_list|,
name|max_dup_opno
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  rtx _val = 0;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  start_sequence ();\n"
argument_list|)
expr_stmt|;
comment|/* The fourth operand of DEFINE_EXPAND is some code to be executed      before the actual construction.      This code expects to refer to `operands'      just as the output-code in a DEFINE_INSN does,      but here `operands' is an automatic array.      So copy the operand values there before executing it.  */
if|if
condition|(
name|XSTR
argument_list|(
name|expand
argument_list|,
literal|3
argument_list|)
operator|&&
operator|*
name|XSTR
argument_list|(
name|expand
argument_list|,
literal|3
argument_list|)
condition|)
block|{
comment|/* Output code to copy the arguments into `operands'.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|operands
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"  operands[%d] = operand%d;\n"
argument_list|,
name|i
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Output the special code to be executed before the sequence 	 is generated.  */
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|XSTR
argument_list|(
name|expand
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Output code to copy the arguments back out of `operands' 	 (unless we aren't going to use them at all).  */
if|if
condition|(
name|XVEC
argument_list|(
name|expand
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|operands
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"  operand%d = operands[%d];\n"
argument_list|,
name|i
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<=
name|max_dup_opno
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"  operand%d = operands[%d];\n"
argument_list|,
name|i
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Output code to construct the rtl for the instruction bodies.      Use emit_insn to add them to the sequence being accumulated.      But don't do this if the user's code has set `no_more' nonzero.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|expand
argument_list|,
literal|1
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|next
init|=
name|XVECEXP
argument_list|(
name|expand
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|PC
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|next
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|next
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|PC
operator|)
operator|||
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|RETURN
condition|)
name|printf
argument_list|(
literal|"  emit_jump_insn ("
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|CALL
operator|)
operator|||
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|CALL
operator|||
operator|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|next
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|next
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|CALL
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|next
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CALL
operator|)
condition|)
name|printf
argument_list|(
literal|"  emit_call_insn ("
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|printf
argument_list|(
literal|"  emit_label ("
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|MATCH_OPERAND
operator|||
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|MATCH_OPERATOR
operator|||
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|MATCH_PARALLEL
operator|||
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|MATCH_OP_DUP
operator|||
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|MATCH_DUP
operator|||
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|PARALLEL
condition|)
name|printf
argument_list|(
literal|"  emit ("
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"  emit_insn ("
argument_list|)
expr_stmt|;
name|gen_exp
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|");\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|PC
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|printf
argument_list|(
literal|"  emit_barrier ();"
argument_list|)
expr_stmt|;
block|}
comment|/* Call `gen_sequence' to make a SEQUENCE out of all the      insns emitted within this gen_... function.  */
name|printf
argument_list|(
literal|"  _val = gen_sequence ();\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  end_sequence ();\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  return _val;\n}\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Like gen_expand, but generates a SEQUENCE.  */
end_comment

begin_function
specifier|static
name|void
name|gen_split
parameter_list|(
name|split
parameter_list|)
name|rtx
name|split
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|operands
decl_stmt|;
if|if
condition|(
name|XVEC
argument_list|(
name|split
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"define_split (definition %d) lacks a pattern"
argument_list|,
name|insn_index_number
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|XVEC
argument_list|(
name|split
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"define_split (definition %d) lacks a replacement pattern"
argument_list|,
name|insn_index_number
argument_list|)
expr_stmt|;
comment|/* Find out how many operands this function has.  */
name|max_operand_vec
argument_list|(
name|split
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|operands
operator|=
name|MAX
argument_list|(
name|max_opno
argument_list|,
name|max_dup_opno
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* Output the function name and argument declarations.  */
name|printf
argument_list|(
literal|"rtx\ngen_split_%d (operands)\n     rtx *operands;\n"
argument_list|,
name|insn_code_number
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"{\n"
argument_list|)
expr_stmt|;
comment|/* Declare all local variables.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|operands
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"  rtx operand%d;\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  rtx _val = 0;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  start_sequence ();\n"
argument_list|)
expr_stmt|;
comment|/* The fourth operand of DEFINE_SPLIT is some code to be executed      before the actual construction.  */
if|if
condition|(
name|XSTR
argument_list|(
name|split
argument_list|,
literal|3
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|XSTR
argument_list|(
name|split
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Output code to copy the arguments back out of `operands'  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|operands
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"  operand%d = operands[%d];\n"
argument_list|,
name|i
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Output code to construct the rtl for the instruction bodies.      Use emit_insn to add them to the sequence being accumulated.      But don't do this if the user's code has set `no_more' nonzero.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|split
argument_list|,
literal|2
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|next
init|=
name|XVECEXP
argument_list|(
name|split
argument_list|,
literal|2
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|PC
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|next
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|next
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|PC
operator|)
operator|||
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|RETURN
condition|)
name|printf
argument_list|(
literal|"  emit_jump_insn ("
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|CALL
operator|)
operator|||
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|CALL
operator|||
operator|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|next
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|next
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|CALL
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|next
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CALL
operator|)
condition|)
name|printf
argument_list|(
literal|"  emit_call_insn ("
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|printf
argument_list|(
literal|"  emit_label ("
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|MATCH_OPERAND
operator|||
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|MATCH_OPERATOR
operator|||
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|MATCH_PARALLEL
operator|||
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|MATCH_OP_DUP
operator|||
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|MATCH_DUP
operator|||
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|PARALLEL
condition|)
name|printf
argument_list|(
literal|"  emit ("
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"  emit_insn ("
argument_list|)
expr_stmt|;
name|gen_exp
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|");\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|PC
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|printf
argument_list|(
literal|"  emit_barrier ();"
argument_list|)
expr_stmt|;
block|}
comment|/* Call `gen_sequence' to make a SEQUENCE out of all the      insns emitted within this gen_... function.  */
name|printf
argument_list|(
literal|"  _val = gen_sequence ();\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  end_sequence ();\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  return _val;\n}\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Write a function, `add_clobbers', that is given a PARALLEL of sufficient    size for the insn and an INSN_CODE, and inserts the required CLOBBERs at    the end of the vector.  */
end_comment

begin_function
specifier|static
name|void
name|output_add_clobbers
parameter_list|()
block|{
name|struct
name|clobber_pat
modifier|*
name|clobber
decl_stmt|;
name|struct
name|clobber_ent
modifier|*
name|ent
decl_stmt|;
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"\n\nvoid\nadd_clobbers (pattern, insn_code_number)\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"     rtx pattern;\n     int insn_code_number;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"{\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  switch (insn_code_number)\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|clobber
operator|=
name|clobber_list
init|;
name|clobber
condition|;
name|clobber
operator|=
name|clobber
operator|->
name|next
control|)
block|{
for|for
control|(
name|ent
operator|=
name|clobber
operator|->
name|insns
init|;
name|ent
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
name|printf
argument_list|(
literal|"    case %d:\n"
argument_list|,
name|ent
operator|->
name|code_number
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|clobber
operator|->
name|first_clobber
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|clobber
operator|->
name|pattern
argument_list|,
literal|1
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"      XVECEXP (pattern, 0, %d) = "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|gen_exp
argument_list|(
name|XVECEXP
argument_list|(
name|clobber
operator|->
name|pattern
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|";\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"      break;\n\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"    default:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"      abort ();\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    }\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"}\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Write a function, init_mov_optab, that is called to set up entries    in mov_optab for EXTRA_CC_MODES.  */
end_comment

begin_function
specifier|static
name|void
name|output_init_mov_optab
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|EXTRA_CC_NAMES
specifier|static
name|char
modifier|*
name|cc_names
index|[]
init|=
block|{
name|EXTRA_CC_NAMES
block|}
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"\nvoid\ninit_mov_optab ()\n{\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
name|cc_names
operator|/
sizeof|sizeof
name|cc_names
index|[
literal|0
index|]
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"#ifdef HAVE_mov"
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|cc_names
index|[
name|i
index|]
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
name|printf
argument_list|(
literal|"%c"
argument_list|,
operator|*
name|p
operator|>=
literal|'A'
operator|&&
operator|*
name|p
operator|<=
literal|'Z'
condition|?
operator|*
name|p
operator|-
literal|'A'
operator|+
literal|'a'
else|:
operator|*
name|p
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  if (HAVE_mov"
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|cc_names
index|[
name|i
index|]
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
name|printf
argument_list|(
literal|"%c"
argument_list|,
operator|*
name|p
operator|>=
literal|'A'
operator|&&
operator|*
name|p
operator|<=
literal|'Z'
condition|?
operator|*
name|p
operator|-
literal|'A'
operator|+
literal|'a'
else|:
operator|*
name|p
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    mov_optab->handlers[(int) %smode].insn_code = CODE_FOR_mov"
argument_list|,
name|cc_names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|cc_names
index|[
name|i
index|]
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
name|printf
argument_list|(
literal|"%c"
argument_list|,
operator|*
name|p
operator|>=
literal|'A'
operator|&&
operator|*
name|p
operator|<=
literal|'Z'
condition|?
operator|*
name|p
operator|-
literal|'A'
operator|+
literal|'a'
else|:
operator|*
name|p
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|";\n#endif\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"}\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_function
name|char
modifier|*
name|xmalloc
parameter_list|(
name|size
parameter_list|)
name|unsigned
name|size
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|val
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|xrealloc
parameter_list|(
name|ptr
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|unsigned
name|size
decl_stmt|;
block|{
name|char
modifier|*
name|result
init|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
name|fatal
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|fatal
name|VPROTO
argument_list|(
operator|(
name|char
operator|*
name|format
operator|,
operator|...
operator|)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|__STDC__
name|char
modifier|*
name|format
decl_stmt|;
endif|#
directive|endif
name|va_list
name|ap
decl_stmt|;
name|VA_START
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|__STDC__
name|format
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"genemit: "
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* More 'friendly' abort that prints the line and file.    config.h can #define abort fancy_abort if you like that sort of thing.  */
end_comment

begin_function
name|void
name|fancy_abort
parameter_list|()
block|{
name|fatal
argument_list|(
literal|"Internal gcc abort."
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|rtx
name|desc
decl_stmt|;
name|FILE
modifier|*
name|infile
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|obstack_init
argument_list|(
name|rtl_obstack
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|<=
literal|1
condition|)
name|fatal
argument_list|(
literal|"No input file name."
argument_list|)
expr_stmt|;
name|infile
operator|=
name|fopen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|infile
operator|==
literal|0
condition|)
block|{
name|perror
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
name|init_rtl
argument_list|()
expr_stmt|;
comment|/* Assign sequential codes to all entries in the machine description      in parallel with the tables in insn-output.c.  */
name|insn_code_number
operator|=
literal|0
expr_stmt|;
name|insn_index_number
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"/* Generated automatically by the program `genemit'\n\ from the machine description file `md'.  */\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"config.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"system.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"rtl.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"expr.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"real.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"flags.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"output.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"insn-config.h\"\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"insn-flags.h\"\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"insn-codes.h\"\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"reload.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"extern char *insn_operand_constraint[][MAX_RECOG_OPERANDS];\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"extern rtx recog_operand[];\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#define operands emit_operand\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#define FAIL do {end_sequence (); return _val;} while (0)\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#define DONE do {_val = gen_sequence (); end_sequence (); return _val;} while (0)\n"
argument_list|)
expr_stmt|;
comment|/* Read the machine description.  */
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
name|read_skip_spaces
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
name|ungetc
argument_list|(
name|c
argument_list|,
name|infile
argument_list|)
expr_stmt|;
name|desc
operator|=
name|read_rtx
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_INSN
condition|)
block|{
name|gen_insn
argument_list|(
name|desc
argument_list|)
expr_stmt|;
operator|++
name|insn_code_number
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_EXPAND
condition|)
block|{
name|gen_expand
argument_list|(
name|desc
argument_list|)
expr_stmt|;
operator|++
name|insn_code_number
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_SPLIT
condition|)
block|{
name|gen_split
argument_list|(
name|desc
argument_list|)
expr_stmt|;
operator|++
name|insn_code_number
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_PEEPHOLE
condition|)
block|{
operator|++
name|insn_code_number
expr_stmt|;
block|}
operator|++
name|insn_index_number
expr_stmt|;
block|}
comment|/* Write out the routine to add CLOBBERs to a pattern.  */
name|output_add_clobbers
argument_list|()
expr_stmt|;
comment|/* Write the routine to initialize mov_optab for the EXTRA_CC_MODES.  */
name|output_init_mov_optab
argument_list|()
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|ferror
argument_list|(
name|stdout
argument_list|)
operator|!=
literal|0
condition|?
name|FATAL_EXIT_CODE
else|:
name|SUCCESS_EXIT_CODE
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
literal|0
return|;
block|}
end_function

end_unit

