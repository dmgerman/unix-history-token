begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Generate code from machine description to emit insns as rtl.    Copyright (C) 1987, 1988, 1991, 1994, 1995, 1997, 1998, 1999, 2000, 2001    Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"hconfig.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"errors.h"
end_include

begin_include
include|#
directive|include
file|"gensupport.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|max_opno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|max_dup_opno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|max_scratch_opno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|register_constraints
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|insn_code_number
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|insn_index_number
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Data structure for recording the patterns of insns that have CLOBBERs.    We use this to output a function that adds these CLOBBERs to a     previously-allocated PARALLEL expression.  */
end_comment

begin_struct
struct|struct
name|clobber_pat
block|{
name|struct
name|clobber_ent
modifier|*
name|insns
decl_stmt|;
name|rtx
name|pattern
decl_stmt|;
name|int
name|first_clobber
decl_stmt|;
name|struct
name|clobber_pat
modifier|*
name|next
decl_stmt|;
name|int
name|has_hard_reg
decl_stmt|;
block|}
modifier|*
name|clobber_list
struct|;
end_struct

begin_comment
comment|/* Records one insn that uses the clobber list.  */
end_comment

begin_struct
struct|struct
name|clobber_ent
block|{
name|int
name|code_number
decl_stmt|;
comment|/* Counts only insns.  */
name|struct
name|clobber_ent
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|void
name|max_operand_1
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|max_operand_vec
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_code
name|PARAMS
argument_list|(
operator|(
name|RTX_CODE
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_exp
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
expr|enum
name|rtx_code
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_insn
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_expand
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_split
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_add_clobbers
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_added_clobbers_hard_reg_p
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_rtx_scratch
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
expr|enum
name|rtx_code
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_peephole2_scratches
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
specifier|static
name|void
name|max_operand_1
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|RTX_CODE
name|code
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|MATCH_OPERAND
operator|&&
name|XSTR
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
operator|&&
operator|*
name|XSTR
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
operator|!=
literal|'\0'
condition|)
name|register_constraints
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|MATCH_SCRATCH
operator|&&
name|XSTR
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
operator|&&
operator|*
name|XSTR
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|!=
literal|'\0'
condition|)
name|register_constraints
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|MATCH_OPERAND
operator|||
name|code
operator|==
name|MATCH_OPERATOR
operator|||
name|code
operator|==
name|MATCH_PARALLEL
condition|)
name|max_opno
operator|=
name|MAX
argument_list|(
name|max_opno
argument_list|,
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|MATCH_DUP
operator|||
name|code
operator|==
name|MATCH_OP_DUP
operator|||
name|code
operator|==
name|MATCH_PAR_DUP
condition|)
name|max_dup_opno
operator|=
name|MAX
argument_list|(
name|max_dup_opno
argument_list|,
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|MATCH_SCRATCH
condition|)
name|max_scratch_opno
operator|=
name|MAX
argument_list|(
name|max_scratch_opno
argument_list|,
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|len
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|||
name|fmt
index|[
name|i
index|]
operator|==
literal|'u'
condition|)
name|max_operand_1
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|max_operand_1
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|max_operand_vec
parameter_list|(
name|insn
parameter_list|,
name|arg
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|int
name|arg
decl_stmt|;
block|{
name|int
name|len
init|=
name|XVECLEN
argument_list|(
name|insn
argument_list|,
name|arg
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|max_opno
operator|=
operator|-
literal|1
expr_stmt|;
name|max_dup_opno
operator|=
operator|-
literal|1
expr_stmt|;
name|max_scratch_opno
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|max_operand_1
argument_list|(
name|XVECEXP
argument_list|(
name|insn
argument_list|,
name|arg
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|max_opno
operator|+
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|print_code
parameter_list|(
name|code
parameter_list|)
name|RTX_CODE
name|code
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|p1
decl_stmt|;
for|for
control|(
name|p1
operator|=
name|GET_RTX_NAME
argument_list|(
name|code
argument_list|)
init|;
operator|*
name|p1
condition|;
name|p1
operator|++
control|)
name|putchar
argument_list|(
name|TOUPPER
argument_list|(
operator|*
name|p1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gen_rtx_scratch
parameter_list|(
name|x
parameter_list|,
name|subroutine_type
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|enum
name|rtx_code
name|subroutine_type
decl_stmt|;
block|{
if|if
condition|(
name|subroutine_type
operator|==
name|DEFINE_PEEPHOLE2
condition|)
block|{
name|printf
argument_list|(
literal|"operand%d"
argument_list|,
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"gen_rtx_SCRATCH (%smode)"
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print a C expression to construct an RTX just like X,    substituting any operand references appearing within.  */
end_comment

begin_function
specifier|static
name|void
name|gen_exp
parameter_list|(
name|x
parameter_list|,
name|subroutine_type
parameter_list|,
name|used
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|enum
name|rtx_code
name|subroutine_type
decl_stmt|;
name|char
modifier|*
name|used
decl_stmt|;
block|{
name|RTX_CODE
name|code
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"NULL_RTX"
argument_list|)
expr_stmt|;
return|return;
block|}
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|MATCH_OPERAND
case|:
case|case
name|MATCH_DUP
case|:
if|if
condition|(
name|used
condition|)
block|{
if|if
condition|(
name|used
index|[
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"copy_rtx (operand%d)"
argument_list|,
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|used
index|[
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
index|]
operator|=
literal|1
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"operand%d"
argument_list|,
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|MATCH_OP_DUP
case|:
name|printf
argument_list|(
literal|"gen_rtx (GET_CODE (operand%d), "
argument_list|,
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|VOIDmode
condition|)
name|printf
argument_list|(
literal|"GET_MODE (operand%d)"
argument_list|,
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%smode"
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|",\n\t\t"
argument_list|)
expr_stmt|;
name|gen_exp
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
argument_list|,
name|subroutine_type
argument_list|,
name|used
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
return|return;
case|case
name|MATCH_OPERATOR
case|:
name|printf
argument_list|(
literal|"gen_rtx (GET_CODE (operand%d)"
argument_list|,
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", %smode"
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|",\n\t\t"
argument_list|)
expr_stmt|;
name|gen_exp
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|,
name|i
argument_list|)
argument_list|,
name|subroutine_type
argument_list|,
name|used
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
return|return;
case|case
name|MATCH_PARALLEL
case|:
case|case
name|MATCH_PAR_DUP
case|:
name|printf
argument_list|(
literal|"operand%d"
argument_list|,
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|MATCH_SCRATCH
case|:
name|gen_rtx_scratch
argument_list|(
name|x
argument_list|,
name|subroutine_type
argument_list|)
expr_stmt|;
return|return;
case|case
name|ADDRESS
case|:
name|fatal
argument_list|(
literal|"ADDRESS expression code used in named instruction pattern"
argument_list|)
expr_stmt|;
case|case
name|PC
case|:
name|printf
argument_list|(
literal|"pc_rtx"
argument_list|)
expr_stmt|;
return|return;
case|case
name|CC0
case|:
name|printf
argument_list|(
literal|"cc0_rtx"
argument_list|)
expr_stmt|;
return|return;
case|case
name|CONST_INT
case|:
if|if
condition|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"const0_rtx"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|==
literal|1
condition|)
name|printf
argument_list|(
literal|"const1_rtx"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|printf
argument_list|(
literal|"constm1_rtx"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|==
name|STORE_FLAG_VALUE
condition|)
name|printf
argument_list|(
literal|"const_true_rtx"
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"GEN_INT ("
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|CONST_DOUBLE
case|:
comment|/* These shouldn't be written in MD files.  Instead, the appropriate 	 routines in varasm.c should be called.  */
name|abort
argument_list|()
expr_stmt|;
default|default:
break|break;
block|}
name|printf
argument_list|(
literal|"gen_rtx_"
argument_list|)
expr_stmt|;
name|print_code
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" (%smode"
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|len
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'0'
condition|)
break|break;
name|printf
argument_list|(
literal|",\n\t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|||
name|fmt
index|[
name|i
index|]
operator|==
literal|'u'
condition|)
name|gen_exp
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|subroutine_type
argument_list|,
name|used
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'i'
condition|)
name|printf
argument_list|(
literal|"%u"
argument_list|,
name|XINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'s'
condition|)
name|printf
argument_list|(
literal|"\"%s\""
argument_list|,
name|XSTR
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
name|printf
argument_list|(
literal|"gen_rtvec (%d"
argument_list|,
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|printf
argument_list|(
literal|",\n\t\t"
argument_list|)
expr_stmt|;
name|gen_exp
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|subroutine_type
argument_list|,
name|used
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
name|printf
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate the `gen_...' function for a DEFINE_INSN.  */
end_comment

begin_function
specifier|static
name|void
name|gen_insn
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|operands
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* See if the pattern for this insn ends with a group of CLOBBERs of (hard)      registers or MATCH_SCRATCHes.  If so, store away the information for      later.  */
if|if
condition|(
name|XVEC
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|int
name|has_hard_reg
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
argument_list|)
operator|!=
name|CLOBBER
condition|)
break|break;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|has_hard_reg
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|MATCH_SCRATCH
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|!=
name|XVECLEN
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
operator|-
literal|1
condition|)
block|{
name|struct
name|clobber_pat
modifier|*
name|p
decl_stmt|;
name|struct
name|clobber_ent
modifier|*
name|link
init|=
operator|(
expr|struct
name|clobber_ent
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|clobber_ent
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|j
decl_stmt|;
name|link
operator|->
name|code_number
operator|=
name|insn_code_number
expr_stmt|;
comment|/* See if any previous CLOBBER_LIST entry is the same as this 	     one.  */
for|for
control|(
name|p
operator|=
name|clobber_list
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|first_clobber
operator|!=
name|i
operator|+
literal|1
operator|||
name|XVECLEN
argument_list|(
name|p
operator|->
name|pattern
argument_list|,
literal|1
argument_list|)
operator|!=
name|XVECLEN
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|rtx
name|old
init|=
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|p
operator|->
name|pattern
argument_list|,
literal|1
argument_list|,
name|j
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|new
init|=
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|,
name|j
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* OLD and NEW are the same if both are to be a SCRATCH 		     of the same mode,  		     or if both are registers of the same mode and number.  */
if|if
condition|(
operator|!
operator|(
name|GET_MODE
argument_list|(
name|old
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|new
argument_list|)
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|old
argument_list|)
operator|==
name|MATCH_SCRATCH
operator|&&
name|GET_CODE
argument_list|(
name|new
argument_list|)
operator|==
name|MATCH_SCRATCH
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|old
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|new
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|old
argument_list|)
operator|==
name|REGNO
argument_list|(
name|new
argument_list|)
operator|)
operator|)
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|j
operator|==
name|XVECLEN
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|p
operator|==
literal|0
condition|)
block|{
name|p
operator|=
operator|(
expr|struct
name|clobber_pat
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|clobber_pat
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|insns
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|pattern
operator|=
name|insn
expr_stmt|;
name|p
operator|->
name|first_clobber
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|clobber_list
expr_stmt|;
name|p
operator|->
name|has_hard_reg
operator|=
name|has_hard_reg
expr_stmt|;
name|clobber_list
operator|=
name|p
expr_stmt|;
block|}
name|link
operator|->
name|next
operator|=
name|p
operator|->
name|insns
expr_stmt|;
name|p
operator|->
name|insns
operator|=
name|link
expr_stmt|;
block|}
block|}
comment|/* Don't mention instructions whose names are the null string      or begin with '*'.  They are in the machine description just      to be recognized.  */
if|if
condition|(
name|XSTR
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
index|[
literal|0
index|]
operator|==
literal|0
operator|||
name|XSTR
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
return|return;
comment|/* Find out how many operands this function has,      and also whether any of them have register constraints.  */
name|register_constraints
operator|=
literal|0
expr_stmt|;
name|operands
operator|=
name|max_operand_vec
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_dup_opno
operator|>=
name|operands
condition|)
name|fatal
argument_list|(
literal|"match_dup operand number has no match_operand"
argument_list|)
expr_stmt|;
comment|/* Output the function name and argument declarations.  */
name|printf
argument_list|(
literal|"rtx\ngen_%s ("
argument_list|,
name|XSTR
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|operands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|i
condition|)
name|printf
argument_list|(
literal|", operand%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"operand%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|operands
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"     rtx operand%d;\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"{\n"
argument_list|)
expr_stmt|;
comment|/* Output code to construct and return the rtl for the instruction body */
if|if
condition|(
name|XVECLEN
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
operator|==
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"  return "
argument_list|)
expr_stmt|;
name|gen_exp
argument_list|(
name|XVECEXP
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|DEFINE_INSN
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|";\n}\n\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"  return gen_rtx_PARALLEL (VOIDmode, gen_rtvec (%d"
argument_list|,
name|XVECLEN
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|",\n\t\t"
argument_list|)
expr_stmt|;
name|gen_exp
argument_list|(
name|XVECEXP
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
argument_list|,
name|DEFINE_INSN
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"));\n}\n\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate the `gen_...' function for a DEFINE_EXPAND.  */
end_comment

begin_function
specifier|static
name|void
name|gen_expand
parameter_list|(
name|expand
parameter_list|)
name|rtx
name|expand
decl_stmt|;
block|{
name|int
name|operands
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|XSTR
argument_list|(
name|expand
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"define_expand lacks a name"
argument_list|)
expr_stmt|;
if|if
condition|(
name|XVEC
argument_list|(
name|expand
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"define_expand for %s lacks a pattern"
argument_list|,
name|XSTR
argument_list|(
name|expand
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Find out how many operands this function has,      and also whether any of them have register constraints.  */
name|register_constraints
operator|=
literal|0
expr_stmt|;
name|operands
operator|=
name|max_operand_vec
argument_list|(
name|expand
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Output the function name and argument declarations.  */
name|printf
argument_list|(
literal|"rtx\ngen_%s ("
argument_list|,
name|XSTR
argument_list|(
name|expand
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|operands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|i
condition|)
name|printf
argument_list|(
literal|", operand%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"operand%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|operands
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"     rtx operand%d;\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"{\n"
argument_list|)
expr_stmt|;
comment|/* If we don't have any C code to write, only one insn is being written,      and no MATCH_DUPs are present, we can just return the desired insn      like we do for a DEFINE_INSN.  This saves memory.  */
if|if
condition|(
operator|(
name|XSTR
argument_list|(
name|expand
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
operator|||
operator|*
name|XSTR
argument_list|(
name|expand
argument_list|,
literal|3
argument_list|)
operator|==
literal|'\0'
operator|)
operator|&&
name|operands
operator|>
name|max_dup_opno
operator|&&
name|XVECLEN
argument_list|(
name|expand
argument_list|,
literal|1
argument_list|)
operator|==
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"  return "
argument_list|)
expr_stmt|;
name|gen_exp
argument_list|(
name|XVECEXP
argument_list|(
name|expand
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|DEFINE_EXPAND
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|";\n}\n\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* For each operand referred to only with MATCH_DUPs,      make a local variable.  */
for|for
control|(
name|i
operator|=
name|operands
init|;
name|i
operator|<=
name|max_dup_opno
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"  rtx operand%d;\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<=
name|max_scratch_opno
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"  rtx operand%d ATTRIBUTE_UNUSED;\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  rtx _val = 0;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  start_sequence ();\n"
argument_list|)
expr_stmt|;
comment|/* The fourth operand of DEFINE_EXPAND is some code to be executed      before the actual construction.      This code expects to refer to `operands'      just as the output-code in a DEFINE_INSN does,      but here `operands' is an automatic array.      So copy the operand values there before executing it.  */
if|if
condition|(
name|XSTR
argument_list|(
name|expand
argument_list|,
literal|3
argument_list|)
operator|&&
operator|*
name|XSTR
argument_list|(
name|expand
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"  {\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|operands
operator|>
literal|0
operator|||
name|max_dup_opno
operator|>=
literal|0
operator|||
name|max_scratch_opno
operator|>=
literal|0
condition|)
name|printf
argument_list|(
literal|"    rtx operands[%d];\n"
argument_list|,
name|MAX
argument_list|(
name|operands
argument_list|,
name|MAX
argument_list|(
name|max_scratch_opno
argument_list|,
name|max_dup_opno
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Output code to copy the arguments into `operands'.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|operands
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"    operands[%d] = operand%d;\n"
argument_list|,
name|i
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Output the special code to be executed before the sequence 	 is generated.  */
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|XSTR
argument_list|(
name|expand
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Output code to copy the arguments back out of `operands' 	 (unless we aren't going to use them at all).  */
if|if
condition|(
name|XVEC
argument_list|(
name|expand
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|operands
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"    operand%d = operands[%d];\n"
argument_list|,
name|i
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<=
name|max_dup_opno
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"    operand%d = operands[%d];\n"
argument_list|,
name|i
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<=
name|max_scratch_opno
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"    operand%d = operands[%d];\n"
argument_list|,
name|i
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"  }\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Output code to construct the rtl for the instruction bodies.      Use emit_insn to add them to the sequence being accumulated.      But don't do this if the user's code has set `no_more' nonzero.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|expand
argument_list|,
literal|1
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|next
init|=
name|XVECEXP
argument_list|(
name|expand
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|PC
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|next
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|next
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|PC
operator|)
operator|||
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|RETURN
condition|)
name|printf
argument_list|(
literal|"  emit_jump_insn ("
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|CALL
operator|)
operator|||
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|CALL
operator|||
operator|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|next
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|next
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|CALL
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|next
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CALL
operator|)
condition|)
name|printf
argument_list|(
literal|"  emit_call_insn ("
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|printf
argument_list|(
literal|"  emit_label ("
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|MATCH_OPERAND
operator|||
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|MATCH_DUP
operator|||
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|MATCH_OPERATOR
operator|||
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|MATCH_OP_DUP
operator|||
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|MATCH_PARALLEL
operator|||
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|MATCH_PAR_DUP
operator|||
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|PARALLEL
condition|)
name|printf
argument_list|(
literal|"  emit ("
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"  emit_insn ("
argument_list|)
expr_stmt|;
name|gen_exp
argument_list|(
name|next
argument_list|,
name|DEFINE_EXPAND
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|");\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|PC
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|printf
argument_list|(
literal|"  emit_barrier ();"
argument_list|)
expr_stmt|;
block|}
comment|/* Call `gen_sequence' to make a SEQUENCE out of all the      insns emitted within this gen_... function.  */
name|printf
argument_list|(
literal|"  _val = gen_sequence ();\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  end_sequence ();\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  return _val;\n}\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Like gen_expand, but generates a SEQUENCE.  */
end_comment

begin_function
specifier|static
name|void
name|gen_split
parameter_list|(
name|split
parameter_list|)
name|rtx
name|split
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|operands
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|name
init|=
operator|(
operator|(
name|GET_CODE
argument_list|(
name|split
argument_list|)
operator|==
name|DEFINE_PEEPHOLE2
operator|)
condition|?
literal|"peephole2"
else|:
literal|"split"
operator|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|unused
decl_stmt|;
name|char
modifier|*
name|used
decl_stmt|;
if|if
condition|(
name|XVEC
argument_list|(
name|split
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"define_%s (definition %d) lacks a pattern"
argument_list|,
name|name
argument_list|,
name|insn_index_number
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|XVEC
argument_list|(
name|split
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"define_%s (definition %d) lacks a replacement pattern"
argument_list|,
name|name
argument_list|,
name|insn_index_number
argument_list|)
expr_stmt|;
comment|/* Find out how many operands this function has.  */
name|max_operand_vec
argument_list|(
name|split
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|operands
operator|=
name|MAX
argument_list|(
name|max_opno
argument_list|,
name|MAX
argument_list|(
name|max_dup_opno
argument_list|,
name|max_scratch_opno
argument_list|)
argument_list|)
operator|+
literal|1
expr_stmt|;
name|unused
operator|=
operator|(
name|operands
operator|==
literal|0
condition|?
literal|" ATTRIBUTE_UNUSED"
else|:
literal|""
operator|)
expr_stmt|;
name|used
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
name|operands
argument_list|)
expr_stmt|;
comment|/* Output the prototype, function name and argument declarations.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|split
argument_list|)
operator|==
name|DEFINE_PEEPHOLE2
condition|)
block|{
name|printf
argument_list|(
literal|"extern rtx gen_%s_%d PARAMS ((rtx, rtx *));\n"
argument_list|,
name|name
argument_list|,
name|insn_code_number
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"rtx\ngen_%s_%d (curr_insn, operands)\n"
argument_list|,
name|name
argument_list|,
name|insn_code_number
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"     rtx curr_insn ATTRIBUTE_UNUSED;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"     rtx *operands%s;\n"
argument_list|,
name|unused
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"extern rtx gen_split_%d PARAMS ((rtx *));\n"
argument_list|,
name|insn_code_number
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"rtx\ngen_%s_%d (operands)\n"
argument_list|,
name|name
argument_list|,
name|insn_code_number
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"      rtx *operands%s;\n"
argument_list|,
name|unused
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"{\n"
argument_list|)
expr_stmt|;
comment|/* Declare all local variables.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|operands
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"  rtx operand%d;\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  rtx _val = 0;\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|split
argument_list|)
operator|==
name|DEFINE_PEEPHOLE2
condition|)
name|output_peephole2_scratches
argument_list|(
name|split
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  start_sequence ();\n"
argument_list|)
expr_stmt|;
comment|/* The fourth operand of DEFINE_SPLIT is some code to be executed      before the actual construction.  */
if|if
condition|(
name|XSTR
argument_list|(
name|split
argument_list|,
literal|3
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|XSTR
argument_list|(
name|split
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Output code to copy the arguments back out of `operands'  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|operands
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"  operand%d = operands[%d];\n"
argument_list|,
name|i
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Output code to construct the rtl for the instruction bodies.      Use emit_insn to add them to the sequence being accumulated.      But don't do this if the user's code has set `no_more' nonzero.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|split
argument_list|,
literal|2
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|next
init|=
name|XVECEXP
argument_list|(
name|split
argument_list|,
literal|2
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|PC
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|next
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|next
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|PC
operator|)
operator|||
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|RETURN
condition|)
name|printf
argument_list|(
literal|"  emit_jump_insn ("
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|CALL
operator|)
operator|||
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|CALL
operator|||
operator|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|next
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|next
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|CALL
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|next
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CALL
operator|)
condition|)
name|printf
argument_list|(
literal|"  emit_call_insn ("
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|printf
argument_list|(
literal|"  emit_label ("
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|MATCH_OPERAND
operator|||
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|MATCH_OPERATOR
operator|||
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|MATCH_PARALLEL
operator|||
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|MATCH_OP_DUP
operator|||
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|MATCH_DUP
operator|||
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|PARALLEL
condition|)
name|printf
argument_list|(
literal|"  emit ("
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"  emit_insn ("
argument_list|)
expr_stmt|;
name|gen_exp
argument_list|(
name|next
argument_list|,
name|GET_CODE
argument_list|(
name|split
argument_list|)
argument_list|,
name|used
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|");\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|PC
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|printf
argument_list|(
literal|"  emit_barrier ();"
argument_list|)
expr_stmt|;
block|}
comment|/* Call `gen_sequence' to make a SEQUENCE out of all the      insns emitted within this gen_... function.  */
name|printf
argument_list|(
literal|"  _val = gen_sequence ();\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  end_sequence ();\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  return _val;\n}\n\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|used
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Write a function, `add_clobbers', that is given a PARALLEL of sufficient    size for the insn and an INSN_CODE, and inserts the required CLOBBERs at    the end of the vector.  */
end_comment

begin_function
specifier|static
name|void
name|output_add_clobbers
parameter_list|()
block|{
name|struct
name|clobber_pat
modifier|*
name|clobber
decl_stmt|;
name|struct
name|clobber_ent
modifier|*
name|ent
decl_stmt|;
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"\n\nvoid\nadd_clobbers (pattern, insn_code_number)\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"     rtx pattern ATTRIBUTE_UNUSED;\n     int insn_code_number;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"{\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  switch (insn_code_number)\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|clobber
operator|=
name|clobber_list
init|;
name|clobber
condition|;
name|clobber
operator|=
name|clobber
operator|->
name|next
control|)
block|{
for|for
control|(
name|ent
operator|=
name|clobber
operator|->
name|insns
init|;
name|ent
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
name|printf
argument_list|(
literal|"    case %d:\n"
argument_list|,
name|ent
operator|->
name|code_number
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|clobber
operator|->
name|first_clobber
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|clobber
operator|->
name|pattern
argument_list|,
literal|1
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"      XVECEXP (pattern, 0, %d) = "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|gen_exp
argument_list|(
name|XVECEXP
argument_list|(
name|clobber
operator|->
name|pattern
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
argument_list|,
name|GET_CODE
argument_list|(
name|clobber
operator|->
name|pattern
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|";\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"      break;\n\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"    default:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"      abort ();\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    }\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"}\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Write a function, `added_clobbers_hard_reg_p' this is given an insn_code    number that needs clobbers and returns 1 if they include a clobber of a    hard reg and 0 if they just clobber SCRATCH.  */
end_comment

begin_function
specifier|static
name|void
name|output_added_clobbers_hard_reg_p
parameter_list|()
block|{
name|struct
name|clobber_pat
modifier|*
name|clobber
decl_stmt|;
name|struct
name|clobber_ent
modifier|*
name|ent
decl_stmt|;
name|int
name|clobber_p
decl_stmt|,
name|used
decl_stmt|;
name|printf
argument_list|(
literal|"\n\nint\nadded_clobbers_hard_reg_p (insn_code_number)\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"     int insn_code_number;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"{\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  switch (insn_code_number)\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|clobber_p
operator|=
literal|0
init|;
name|clobber_p
operator|<=
literal|1
condition|;
name|clobber_p
operator|++
control|)
block|{
name|used
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|clobber
operator|=
name|clobber_list
init|;
name|clobber
condition|;
name|clobber
operator|=
name|clobber
operator|->
name|next
control|)
if|if
condition|(
name|clobber
operator|->
name|has_hard_reg
operator|==
name|clobber_p
condition|)
for|for
control|(
name|ent
operator|=
name|clobber
operator|->
name|insns
init|;
name|ent
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
block|{
name|printf
argument_list|(
literal|"    case %d:\n"
argument_list|,
name|ent
operator|->
name|code_number
argument_list|)
expr_stmt|;
name|used
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|used
condition|)
name|printf
argument_list|(
literal|"      return %d;\n\n"
argument_list|,
name|clobber_p
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"    default:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"      abort ();\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    }\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"}\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate code to invoke find_free_register () as needed for the    scratch registers used by the peephole2 pattern in SPLIT.  */
end_comment

begin_function
specifier|static
name|void
name|output_peephole2_scratches
parameter_list|(
name|split
parameter_list|)
name|rtx
name|split
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|insn_nr
init|=
literal|0
decl_stmt|;
name|printf
argument_list|(
literal|"  HARD_REG_SET _regs_allocated;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  CLEAR_HARD_REG_SET (_regs_allocated);\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|split
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|elt
init|=
name|XVECEXP
argument_list|(
name|split
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|elt
argument_list|)
operator|==
name|MATCH_SCRATCH
condition|)
block|{
name|int
name|last_insn_nr
init|=
name|insn_nr
decl_stmt|;
name|int
name|cur_insn_nr
init|=
name|insn_nr
decl_stmt|;
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|split
argument_list|,
literal|0
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|split
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
name|MATCH_DUP
condition|)
block|{
if|if
condition|(
name|XINT
argument_list|(
name|XVECEXP
argument_list|(
name|split
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|XINT
argument_list|(
name|elt
argument_list|,
literal|0
argument_list|)
condition|)
name|last_insn_nr
operator|=
name|cur_insn_nr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|split
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
operator|!=
name|MATCH_SCRATCH
condition|)
name|cur_insn_nr
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"  if ((operands[%d] = peep2_find_free_register (%d, %d, \"%s\", %smode,&_regs_allocated)) == NULL_RTX)\n\     return NULL;\n"
argument_list|,
name|XINT
argument_list|(
name|elt
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn_nr
argument_list|,
name|last_insn_nr
argument_list|,
name|XSTR
argument_list|(
name|elt
argument_list|,
literal|1
argument_list|)
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|GET_MODE
argument_list|(
name|elt
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|elt
argument_list|)
operator|!=
name|MATCH_DUP
condition|)
name|insn_nr
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|extern
name|int
decl|main
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|rtx
name|desc
decl_stmt|;
name|progname
operator|=
literal|"genemit"
expr_stmt|;
if|if
condition|(
name|argc
operator|<=
literal|1
condition|)
name|fatal
argument_list|(
literal|"no input file name"
argument_list|)
expr_stmt|;
if|if
condition|(
name|init_md_reader_args
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
operator|!=
name|SUCCESS_EXIT_CODE
condition|)
return|return
operator|(
name|FATAL_EXIT_CODE
operator|)
return|;
comment|/* Assign sequential codes to all entries in the machine description      in parallel with the tables in insn-output.c.  */
name|insn_code_number
operator|=
literal|0
expr_stmt|;
name|insn_index_number
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"/* Generated automatically by the program `genemit'\n\ from the machine description file `md'.  */\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"config.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"system.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"rtl.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"tm_p.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"function.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"expr.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"optabs.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"real.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"flags.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"output.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"insn-config.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"hard-reg-set.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"recog.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"resource.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"reload.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"toplev.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"ggc.h\"\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#define FAIL return (end_sequence (), _val)\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#define DONE return (_val = gen_sequence (), end_sequence (), _val)\n"
argument_list|)
expr_stmt|;
comment|/* Read the machine description.  */
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|line_no
decl_stmt|;
name|desc
operator|=
name|read_md_rtx
argument_list|(
operator|&
name|line_no
argument_list|,
operator|&
name|insn_code_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|==
name|NULL
condition|)
break|break;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|desc
argument_list|)
condition|)
block|{
case|case
name|DEFINE_INSN
case|:
name|gen_insn
argument_list|(
name|desc
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEFINE_EXPAND
case|:
name|gen_expand
argument_list|(
name|desc
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEFINE_SPLIT
case|:
name|gen_split
argument_list|(
name|desc
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEFINE_PEEPHOLE2
case|:
name|gen_split
argument_list|(
name|desc
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
operator|++
name|insn_index_number
expr_stmt|;
block|}
comment|/* Write out the routines to add CLOBBERs to a pattern and say whether they      clobber a hard reg.  */
name|output_add_clobbers
argument_list|()
expr_stmt|;
name|output_added_clobbers_hard_reg_p
argument_list|()
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
return|return
operator|(
name|ferror
argument_list|(
name|stdout
argument_list|)
operator|!=
literal|0
condition|?
name|FATAL_EXIT_CODE
else|:
name|SUCCESS_EXIT_CODE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Define this so we can link with print-rtl.o to get debug_rtx function.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|get_insn_name
parameter_list|(
name|code
parameter_list|)
name|int
name|code
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|NULL
return|;
block|}
end_function

end_unit

