begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Graph coloring register allocator    Copyright (C) 2001, 2002 Free Software Foundation, Inc.    Contributed by Michael Matz<matz@suse.de>    and Daniel Berlin<dan@cgsoftware.com>.     This file is part of GCC.     GCC is free software; you can redistribute it and/or modify it under the    terms of the GNU General Public License as published by the Free Software    Foundation; either version 2, or (at your option) any later version.     GCC is distributed in the hope that it will be useful, but WITHOUT ANY    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS    FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more    details.     You should have received a copy of the GNU General Public License along    with GCC; see the file COPYING.  If not, write to the Free Software    Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_include
include|#
directive|include
file|"integrate.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"df.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"ra.h"
end_include

begin_comment
comment|/* This is the toplevel file of a graph coloring register allocator.    It is able to act like a George& Appel allocator, i.e. with iterative    coalescing plus spill coalescing/propagation.    And it can act as a traditional Briggs allocator, although with    optimistic coalescing.  Additionally it has a custom pass, which    tries to reduce the overall cost of the colored graph.     We support two modes of spilling: spill-everywhere, which is extremely    fast, and interference region spilling, which reduces spill code to a    large extent, but is slower.     Helpful documents:     Briggs, P., Cooper, K. D., and Torczon, L. 1994. Improvements to graph    coloring register allocation. ACM Trans. Program. Lang. Syst. 16, 3 (May),    428-455.     Bergner, P., Dahl, P., Engebretsen, D., and O'Keefe, M. 1997. Spill code    minimization via interference region spilling. In Proc. ACM SIGPLAN '97    Conf. on Prog. Language Design and Implementation. ACM, 287-295.     George, L., Appel, A.W. 1996.  Iterated register coalescing.    ACM Trans. Program. Lang. Syst. 18, 3 (May), 300-324.  */
end_comment

begin_comment
comment|/* This file contains the main entry point (reg_alloc), some helper routines    used by more than one file of the register allocator, and the toplevel    driver procedure (one_pass).  */
end_comment

begin_comment
comment|/* Things, one might do somewhen:     * Lattice based rematerialization    * create definitions of ever-life regs at the beginning of      the insn chain    * insert loads as soon, stores as late as possile    * insert spill insns as outward as possible (either looptree, or LCM)    * reuse stack-slots    * delete coalesced insns.  Partly done.  The rest can only go, when we get      rid of reload.    * don't destroy coalescing information completely when spilling    * use the constraints from asms   */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|ra_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|create_insn_info
name|PARAMS
argument_list|(
operator|(
expr|struct
name|df
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_insn_info
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|alloc_mem
name|PARAMS
argument_list|(
operator|(
expr|struct
name|df
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_mem
name|PARAMS
argument_list|(
operator|(
expr|struct
name|df
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_all_mem
name|PARAMS
argument_list|(
operator|(
expr|struct
name|df
operator|*
name|df
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|one_pass
name|PARAMS
argument_list|(
operator|(
expr|struct
name|df
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|check_df
name|PARAMS
argument_list|(
operator|(
expr|struct
name|df
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_ra
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|reg_alloc
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These global variables are "internal" to the register allocator.    They are all documented at their declarations in ra.h.  */
end_comment

begin_comment
comment|/* Somewhen we want to get rid of one of those sbitmaps.    (for now I need the sup_igraph to note if there is any conflict between    parts of webs at all.  I can't use igraph for this, as there only the real    conflicts are noted.)  This is only used to prevent coalescing two    conflicting webs, were only parts of them are in conflict.  */
end_comment

begin_decl_stmt
name|sbitmap
name|igraph
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|sbitmap
name|sup_igraph
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Note the insns not inserted by the allocator, where we detected any    deaths of pseudos.  It is used to detect closeness of defs and uses.    In the first pass this is empty (we could initialize it from REG_DEAD    notes), in the other passes it is left from the pass before.  */
end_comment

begin_decl_stmt
name|sbitmap
name|insns_with_deaths
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|death_insns_max_uid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|web_part
modifier|*
name|web_parts
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|num_webs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|num_subwebs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|num_allwebs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|web
modifier|*
modifier|*
name|id2web
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|web
modifier|*
name|hardreg2web
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|web
modifier|*
modifier|*
name|def2web
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|web
modifier|*
modifier|*
name|use2web
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|move_list
modifier|*
name|wl_moves
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ra_max_regno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
modifier|*
name|ra_reg_renumber
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|df
modifier|*
name|df
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bitmap
modifier|*
name|live_at_end
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ra_pass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|max_normal_pseudo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|an_unusable_color
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The different lists on which a web can be (based on the type).  */
end_comment

begin_decl_stmt
name|struct
name|dlist
modifier|*
name|web_lists
index|[
operator|(
name|int
operator|)
name|LAST_NODE_TYPE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|last_def_id
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|last_use_id
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|last_num_webs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|last_max_uid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|sbitmap
name|last_check_uses
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|remember_conflicts
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|orig_max_uid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|HARD_REG_SET
name|never_use_colors
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|HARD_REG_SET
name|usable_regs
index|[
name|N_REG_CLASSES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|num_free_regs
index|[
name|N_REG_CLASSES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|HARD_REG_SET
name|hardregs_for_mode
index|[
name|NUM_MACHINE_MODES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
name|byte2bitcount
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|debug_new_regalloc
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag_ra_biased
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag_ra_improved_spilling
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag_ra_ir_spilling
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag_ra_optimistic_coalescing
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag_ra_break_aliases
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag_ra_merge_spill_costs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag_ra_spill_every_use
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag_ra_dump_notes
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Fast allocation of small objects, which live until the allocator    is done.  Allocate an object of SIZE bytes.  */
end_comment

begin_function
name|void
modifier|*
name|ra_alloc
parameter_list|(
name|size
parameter_list|)
name|size_t
name|size
decl_stmt|;
block|{
return|return
name|obstack_alloc
argument_list|(
operator|&
name|ra_obstack
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Like ra_alloc(), but clear the returned memory.  */
end_comment

begin_function
name|void
modifier|*
name|ra_calloc
parameter_list|(
name|size
parameter_list|)
name|size_t
name|size
decl_stmt|;
block|{
name|void
modifier|*
name|p
init|=
name|obstack_alloc
argument_list|(
operator|&
name|ra_obstack
argument_list|,
name|size
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Returns the number of hardregs in HARD_REG_SET RS.  */
end_comment

begin_function
name|int
name|hard_regs_count
parameter_list|(
name|rs
parameter_list|)
name|HARD_REG_SET
name|rs
decl_stmt|;
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|HARD_REG_SET
while|while
condition|(
name|rs
condition|)
block|{
name|unsigned
name|char
name|byte
init|=
name|rs
operator|&
literal|0xFF
decl_stmt|;
name|rs
operator|>>=
literal|8
expr_stmt|;
comment|/* Avoid memory access, if nothing is set.  */
if|if
condition|(
name|byte
condition|)
name|count
operator|+=
name|byte2bitcount
index|[
name|byte
index|]
expr_stmt|;
block|}
else|#
directive|else
name|unsigned
name|int
name|ofs
decl_stmt|;
for|for
control|(
name|ofs
operator|=
literal|0
init|;
name|ofs
operator|<
name|HARD_REG_SET_LONGS
condition|;
name|ofs
operator|++
control|)
block|{
name|HARD_REG_ELT_TYPE
name|elt
init|=
name|rs
index|[
name|ofs
index|]
decl_stmt|;
while|while
condition|(
name|elt
condition|)
block|{
name|unsigned
name|char
name|byte
init|=
name|elt
operator|&
literal|0xFF
decl_stmt|;
name|elt
operator|>>=
literal|8
expr_stmt|;
if|if
condition|(
name|byte
condition|)
name|count
operator|+=
name|byte2bitcount
index|[
name|byte
index|]
expr_stmt|;
block|}
block|}
endif|#
directive|endif
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/* Basically like emit_move_insn (i.e. validifies constants and such),    but also handle MODE_CC moves (but then the operands must already    be basically valid.  */
end_comment

begin_function
name|rtx
name|ra_emit_move_insn
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_CC
condition|)
return|return
name|emit_insn
argument_list|(
name|gen_move_insn
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
argument_list|)
return|;
else|else
return|return
name|emit_move_insn
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
name|int
name|insn_df_max_uid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ra_insn_info
modifier|*
name|insn_df
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ref
modifier|*
modifier|*
name|refs_for_insn_df
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Create the insn_df structure for each insn to have fast access to    all valid defs and uses in an insn.  */
end_comment

begin_function
specifier|static
name|void
name|create_insn_info
parameter_list|(
name|df
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
name|struct
name|ref
modifier|*
modifier|*
name|act_refs
decl_stmt|;
name|insn_df_max_uid
operator|=
name|get_max_uid
argument_list|()
expr_stmt|;
name|insn_df
operator|=
name|xcalloc
argument_list|(
name|insn_df_max_uid
argument_list|,
sizeof|sizeof
argument_list|(
name|insn_df
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|refs_for_insn_df
operator|=
name|xcalloc
argument_list|(
name|df
operator|->
name|def_id
operator|+
name|df
operator|->
name|use_id
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ref
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|act_refs
operator|=
name|refs_for_insn_df
expr_stmt|;
comment|/* We create those things backwards to mimic the order in which      the insns are visited in rewrite_program2() and live_in().  */
for|for
control|(
name|insn
operator|=
name|get_last_insn
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|int
name|uid
init|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|n
decl_stmt|;
name|struct
name|df_link
modifier|*
name|link
decl_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
for|for
control|(
name|n
operator|=
literal|0
operator|,
name|link
operator|=
name|DF_INSN_DEFS
argument_list|(
name|df
argument_list|,
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|link
operator|->
name|next
control|)
if|if
condition|(
name|link
operator|->
name|ref
operator|&&
operator|(
name|DF_REF_REGNO
argument_list|(
name|link
operator|->
name|ref
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|never_use_colors
argument_list|,
name|DF_REF_REGNO
argument_list|(
name|link
operator|->
name|ref
argument_list|)
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|n
operator|==
literal|0
condition|)
name|insn_df
index|[
name|uid
index|]
operator|.
name|defs
operator|=
name|act_refs
expr_stmt|;
name|insn_df
index|[
name|uid
index|]
operator|.
name|defs
index|[
name|n
operator|++
index|]
operator|=
name|link
operator|->
name|ref
expr_stmt|;
block|}
name|act_refs
operator|+=
name|n
expr_stmt|;
name|insn_df
index|[
name|uid
index|]
operator|.
name|num_defs
operator|=
name|n
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
operator|,
name|link
operator|=
name|DF_INSN_USES
argument_list|(
name|df
argument_list|,
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|link
operator|->
name|next
control|)
if|if
condition|(
name|link
operator|->
name|ref
operator|&&
operator|(
name|DF_REF_REGNO
argument_list|(
name|link
operator|->
name|ref
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|never_use_colors
argument_list|,
name|DF_REF_REGNO
argument_list|(
name|link
operator|->
name|ref
argument_list|)
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|n
operator|==
literal|0
condition|)
name|insn_df
index|[
name|uid
index|]
operator|.
name|uses
operator|=
name|act_refs
expr_stmt|;
name|insn_df
index|[
name|uid
index|]
operator|.
name|uses
index|[
name|n
operator|++
index|]
operator|=
name|link
operator|->
name|ref
expr_stmt|;
block|}
name|act_refs
operator|+=
name|n
expr_stmt|;
name|insn_df
index|[
name|uid
index|]
operator|.
name|num_uses
operator|=
name|n
expr_stmt|;
block|}
if|if
condition|(
name|refs_for_insn_df
operator|+
operator|(
name|df
operator|->
name|def_id
operator|+
name|df
operator|->
name|use_id
operator|)
operator|<
name|act_refs
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free the insn_df structures.  */
end_comment

begin_function
specifier|static
name|void
name|free_insn_info
parameter_list|()
block|{
name|free
argument_list|(
name|refs_for_insn_df
argument_list|)
expr_stmt|;
name|refs_for_insn_df
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|insn_df
argument_list|)
expr_stmt|;
name|insn_df
operator|=
name|NULL
expr_stmt|;
name|insn_df_max_uid
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Search WEB for a subweb, which represents REG.  REG needs to    be a SUBREG, and the inner reg of it needs to be the one which is    represented by WEB.  Returns the matching subweb or NULL.  */
end_comment

begin_function
name|struct
name|web
modifier|*
name|find_subweb
parameter_list|(
name|web
parameter_list|,
name|reg
parameter_list|)
name|struct
name|web
modifier|*
name|web
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
block|{
name|struct
name|web
modifier|*
name|w
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|!=
name|SUBREG
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|w
operator|=
name|web
operator|->
name|subreg_next
init|;
name|w
condition|;
name|w
operator|=
name|w
operator|->
name|subreg_next
control|)
if|if
condition|(
name|GET_MODE
argument_list|(
name|w
operator|->
name|orig_x
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|reg
argument_list|)
operator|&&
name|SUBREG_BYTE
argument_list|(
name|w
operator|->
name|orig_x
argument_list|)
operator|==
name|SUBREG_BYTE
argument_list|(
name|reg
argument_list|)
condition|)
return|return
name|w
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Similar to find_subweb(), but matches according to SIZE_WORD,    a collection of the needed size and offset (in bytes).  */
end_comment

begin_function
name|struct
name|web
modifier|*
name|find_subweb_2
parameter_list|(
name|web
parameter_list|,
name|size_word
parameter_list|)
name|struct
name|web
modifier|*
name|web
decl_stmt|;
name|unsigned
name|int
name|size_word
decl_stmt|;
block|{
name|struct
name|web
modifier|*
name|w
init|=
name|web
decl_stmt|;
if|if
condition|(
name|size_word
operator|==
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|web
operator|->
name|orig_x
argument_list|)
argument_list|)
condition|)
comment|/* size_word == size means BYTE_BEGIN(size_word) == 0.  */
return|return
name|web
return|;
for|for
control|(
name|w
operator|=
name|web
operator|->
name|subreg_next
init|;
name|w
condition|;
name|w
operator|=
name|w
operator|->
name|subreg_next
control|)
block|{
name|unsigned
name|int
name|bl
init|=
name|rtx_to_bits
argument_list|(
name|w
operator|->
name|orig_x
argument_list|)
decl_stmt|;
if|if
condition|(
name|size_word
operator|==
name|bl
condition|)
return|return
name|w
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Returns the superweb for SUBWEB.  */
end_comment

begin_function
name|struct
name|web
modifier|*
name|find_web_for_subweb_1
parameter_list|(
name|subweb
parameter_list|)
name|struct
name|web
modifier|*
name|subweb
decl_stmt|;
block|{
while|while
condition|(
name|subweb
operator|->
name|parent_web
condition|)
name|subweb
operator|=
name|subweb
operator|->
name|parent_web
expr_stmt|;
return|return
name|subweb
return|;
block|}
end_function

begin_comment
comment|/* Determine if two hard register sets intersect.    Return 1 if they do.  */
end_comment

begin_function
name|int
name|hard_regs_intersect_p
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|HARD_REG_SET
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|;
end_function

begin_block
block|{
name|HARD_REG_SET
name|c
decl_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|c
argument_list|,
operator|*
name|a
argument_list|)
expr_stmt|;
name|AND_HARD_REG_SET
argument_list|(
name|c
argument_list|,
operator|*
name|b
argument_list|)
expr_stmt|;
name|GO_IF_HARD_REG_SUBSET
argument_list|(
name|c
argument_list|,
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|NO_REGS
index|]
argument_list|,
name|lose
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
name|lose
label|:
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Allocate and initialize the memory necessary for one pass of the    register allocator.  */
end_comment

begin_function
specifier|static
name|void
name|alloc_mem
parameter_list|(
name|df
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|ra_build_realloc
argument_list|(
name|df
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|live_at_end
condition|)
block|{
name|live_at_end
operator|=
operator|(
name|bitmap
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|last_basic_block
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|bitmap
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|last_basic_block
operator|+
literal|2
condition|;
name|i
operator|++
control|)
name|live_at_end
index|[
name|i
index|]
operator|=
name|BITMAP_XMALLOC
argument_list|()
expr_stmt|;
name|live_at_end
operator|+=
literal|2
expr_stmt|;
block|}
name|create_insn_info
argument_list|(
name|df
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free the memory which isn't necessary for the next pass.  */
end_comment

begin_function
specifier|static
name|void
name|free_mem
parameter_list|(
name|df
parameter_list|)
name|struct
name|df
modifier|*
name|df
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|free_insn_info
argument_list|()
expr_stmt|;
name|ra_build_free
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free all memory allocated for the register allocator.  Used, when    it's done.  */
end_comment

begin_function
specifier|static
name|void
name|free_all_mem
parameter_list|(
name|df
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|live_at_end
operator|-=
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|unsigned
operator|)
name|last_basic_block
operator|+
literal|2
condition|;
name|i
operator|++
control|)
name|BITMAP_XFREE
argument_list|(
name|live_at_end
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|live_at_end
argument_list|)
expr_stmt|;
name|ra_colorize_free_all
argument_list|()
expr_stmt|;
name|ra_build_free_all
argument_list|(
name|df
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|ra_obstack
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|long
name|ticks_build
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|ticks_rebuild
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Perform one pass of allocation.  Returns nonzero, if some spill code    was added, i.e. if the allocator needs to rerun.  */
end_comment

begin_function
specifier|static
name|int
name|one_pass
parameter_list|(
name|df
parameter_list|,
name|rebuild
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
name|int
name|rebuild
decl_stmt|;
block|{
name|long
name|ticks
init|=
name|clock
argument_list|()
decl_stmt|;
name|int
name|something_spilled
decl_stmt|;
name|remember_conflicts
operator|=
literal|0
expr_stmt|;
comment|/* Build the complete interference graph, or if this is not the first      pass, rebuild it incrementally.  */
name|build_i_graph
argument_list|(
name|df
argument_list|)
expr_stmt|;
comment|/* From now on, if we create new conflicts, we need to remember the      initial list of conflicts per web.  */
name|remember_conflicts
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|rebuild
condition|)
name|dump_igraph_machine
argument_list|()
expr_stmt|;
comment|/* Colorize the I-graph.  This results in either a list of      spilled_webs, in which case we need to run the spill phase, and      rerun the allocator, or that list is empty, meaning we are done.  */
name|ra_colorize_graph
argument_list|(
name|df
argument_list|)
expr_stmt|;
name|last_max_uid
operator|=
name|get_max_uid
argument_list|()
expr_stmt|;
comment|/* actual_spill() might change WEBS(SPILLED) and even empty it,      so we need to remember it's state.  */
name|something_spilled
operator|=
operator|!
operator|!
name|WEBS
argument_list|(
name|SPILLED
argument_list|)
expr_stmt|;
comment|/* Add spill code if necessary.  */
if|if
condition|(
name|something_spilled
condition|)
name|actual_spill
argument_list|()
expr_stmt|;
name|ticks
operator|=
name|clock
argument_list|()
operator|-
name|ticks
expr_stmt|;
if|if
condition|(
name|rebuild
condition|)
name|ticks_rebuild
operator|+=
name|ticks
expr_stmt|;
else|else
name|ticks_build
operator|+=
name|ticks
expr_stmt|;
return|return
name|something_spilled
return|;
block|}
end_function

begin_comment
comment|/* Initialize various arrays for the register allocator.  */
end_comment

begin_function
specifier|static
name|void
name|init_ra
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|HARD_REG_SET
name|rs
decl_stmt|;
ifdef|#
directive|ifdef
name|ELIMINABLE_REGS
specifier|static
specifier|const
struct|struct
block|{
specifier|const
name|int
name|from
decl_stmt|,
name|to
decl_stmt|;
block|}
name|eliminables
index|[]
init|=
name|ELIMINABLE_REGS
struct|;
name|unsigned
name|int
name|j
decl_stmt|;
endif|#
directive|endif
name|int
name|need_fp
init|=
operator|(
operator|!
name|flag_omit_frame_pointer
ifdef|#
directive|ifdef
name|EXIT_IGNORE_STACK
operator|||
operator|(
name|current_function_calls_alloca
operator|&&
name|EXIT_IGNORE_STACK
operator|)
endif|#
directive|endif
operator|||
name|FRAME_POINTER_REQUIRED
operator|)
decl_stmt|;
name|ra_colorize_init
argument_list|()
expr_stmt|;
comment|/* We can't ever use any of the fixed regs.  */
name|COPY_HARD_REG_SET
argument_list|(
name|never_use_colors
argument_list|,
name|fixed_reg_set
argument_list|)
expr_stmt|;
comment|/* Additionally don't even try to use hardregs, which we already      know are not eliminable.  This includes also either the      hard framepointer or all regs which are eliminable into the      stack pointer, if need_fp is set.  */
ifdef|#
directive|ifdef
name|ELIMINABLE_REGS
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ARRAY_SIZE
argument_list|(
name|eliminables
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|CAN_ELIMINATE
argument_list|(
name|eliminables
index|[
name|j
index|]
operator|.
name|from
argument_list|,
name|eliminables
index|[
name|j
index|]
operator|.
name|to
argument_list|)
operator|||
operator|(
name|eliminables
index|[
name|j
index|]
operator|.
name|to
operator|==
name|STACK_POINTER_REGNUM
operator|&&
name|need_fp
operator|)
condition|)
for|for
control|(
name|i
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|eliminables
index|[
name|j
index|]
operator|.
name|from
argument_list|,
name|Pmode
argument_list|)
init|;
name|i
operator|--
condition|;
control|)
name|SET_HARD_REG_BIT
argument_list|(
name|never_use_colors
argument_list|,
name|eliminables
index|[
name|j
index|]
operator|.
name|from
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|HARD_FRAME_POINTER_REGNUM
if|if
condition|(
name|need_fp
condition|)
for|for
control|(
name|i
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|HARD_FRAME_POINTER_REGNUM
argument_list|,
name|Pmode
argument_list|)
init|;
name|i
operator|--
condition|;
control|)
name|SET_HARD_REG_BIT
argument_list|(
name|never_use_colors
argument_list|,
name|HARD_FRAME_POINTER_REGNUM
operator|+
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
if|if
condition|(
name|need_fp
condition|)
for|for
control|(
name|i
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|FRAME_POINTER_REGNUM
argument_list|,
name|Pmode
argument_list|)
init|;
name|i
operator|--
condition|;
control|)
name|SET_HARD_REG_BIT
argument_list|(
name|never_use_colors
argument_list|,
name|FRAME_POINTER_REGNUM
operator|+
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Stack and argument pointer are also rather useless to us.  */
for|for
control|(
name|i
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|STACK_POINTER_REGNUM
argument_list|,
name|Pmode
argument_list|)
init|;
name|i
operator|--
condition|;
control|)
name|SET_HARD_REG_BIT
argument_list|(
name|never_use_colors
argument_list|,
name|STACK_POINTER_REGNUM
operator|+
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|ARG_POINTER_REGNUM
argument_list|,
name|Pmode
argument_list|)
init|;
name|i
operator|--
condition|;
control|)
name|SET_HARD_REG_BIT
argument_list|(
name|never_use_colors
argument_list|,
name|ARG_POINTER_REGNUM
operator|+
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|char
name|byte
init|=
operator|(
operator|(
name|unsigned
operator|)
name|i
operator|)
operator|&
literal|0xFF
decl_stmt|;
name|unsigned
name|char
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|byte
condition|)
block|{
if|if
condition|(
name|byte
operator|&
literal|1
condition|)
name|count
operator|++
expr_stmt|;
name|byte
operator|>>=
literal|1
expr_stmt|;
block|}
name|byte2bitcount
index|[
name|i
index|]
operator|=
name|count
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_REG_CLASSES
condition|;
name|i
operator|++
control|)
block|{
name|int
name|size
decl_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|rs
argument_list|,
name|reg_class_contents
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|rs
argument_list|,
name|never_use_colors
argument_list|)
expr_stmt|;
name|size
operator|=
name|hard_regs_count
argument_list|(
name|rs
argument_list|)
expr_stmt|;
name|num_free_regs
index|[
name|i
index|]
operator|=
name|size
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|usable_regs
index|[
name|i
index|]
argument_list|,
name|rs
argument_list|)
expr_stmt|;
block|}
comment|/* Setup hardregs_for_mode[].      We are not interested only in the beginning of a multi-reg, but in      all the hardregs involved.  Maybe HARD_REGNO_MODE_OK() only ok's      for beginnings.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_MACHINE_MODES
condition|;
name|i
operator|++
control|)
block|{
name|int
name|reg
decl_stmt|,
name|size
decl_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|rs
argument_list|)
expr_stmt|;
for|for
control|(
name|reg
operator|=
literal|0
init|;
name|reg
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|reg
operator|++
control|)
if|if
condition|(
name|HARD_REGNO_MODE_OK
argument_list|(
name|reg
argument_list|,
name|i
argument_list|)
comment|/* Ignore VOIDmode and similar things.  */
operator|&&
operator|(
name|size
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|reg
argument_list|,
name|i
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|reg
operator|+
name|size
operator|)
operator|<=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
while|while
condition|(
name|size
operator|--
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|rs
argument_list|,
name|reg
operator|+
name|size
argument_list|)
expr_stmt|;
block|}
name|COPY_HARD_REG_SET
argument_list|(
name|hardregs_for_mode
index|[
name|i
index|]
argument_list|,
name|rs
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|an_unusable_color
operator|=
literal|0
init|;
name|an_unusable_color
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|an_unusable_color
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|never_use_colors
argument_list|,
name|an_unusable_color
argument_list|)
condition|)
break|break;
if|if
condition|(
name|an_unusable_color
operator|==
name|FIRST_PSEUDO_REGISTER
condition|)
name|abort
argument_list|()
expr_stmt|;
name|orig_max_uid
operator|=
name|get_max_uid
argument_list|()
expr_stmt|;
name|compute_bb_for_insn
argument_list|()
expr_stmt|;
name|ra_reg_renumber
operator|=
name|NULL
expr_stmt|;
name|insns_with_deaths
operator|=
name|sbitmap_alloc
argument_list|(
name|orig_max_uid
argument_list|)
expr_stmt|;
name|death_insns_max_uid
operator|=
name|orig_max_uid
expr_stmt|;
name|sbitmap_ones
argument_list|(
name|insns_with_deaths
argument_list|)
expr_stmt|;
name|gcc_obstack_init
argument_list|(
operator|&
name|ra_obstack
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check the consistency of DF.  This aborts if it violates some    invariances we expect.  */
end_comment

begin_function
specifier|static
name|void
name|check_df
parameter_list|(
name|df
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
block|{
name|struct
name|df_link
modifier|*
name|link
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|regno
decl_stmt|;
name|unsigned
name|int
name|ui
decl_stmt|;
name|bitmap
name|b
init|=
name|BITMAP_XMALLOC
argument_list|()
decl_stmt|;
name|bitmap
name|empty_defs
init|=
name|BITMAP_XMALLOC
argument_list|()
decl_stmt|;
name|bitmap
name|empty_uses
init|=
name|BITMAP_XMALLOC
argument_list|()
decl_stmt|;
comment|/* Collect all the IDs of NULL references in the ID->REF arrays,      as df.c leaves them when updating the df structure.  */
for|for
control|(
name|ui
operator|=
literal|0
init|;
name|ui
operator|<
name|df
operator|->
name|def_id
condition|;
name|ui
operator|++
control|)
if|if
condition|(
operator|!
name|df
operator|->
name|defs
index|[
name|ui
index|]
condition|)
name|bitmap_set_bit
argument_list|(
name|empty_defs
argument_list|,
name|ui
argument_list|)
expr_stmt|;
for|for
control|(
name|ui
operator|=
literal|0
init|;
name|ui
operator|<
name|df
operator|->
name|use_id
condition|;
name|ui
operator|++
control|)
if|if
condition|(
operator|!
name|df
operator|->
name|uses
index|[
name|ui
index|]
condition|)
name|bitmap_set_bit
argument_list|(
name|empty_uses
argument_list|,
name|ui
argument_list|)
expr_stmt|;
comment|/* For each insn we check if the chain of references contain each      ref only once, doesn't contain NULL refs, or refs whose ID is invalid      (it df->refs[id] element is NULL).  */
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|bitmap_clear
argument_list|(
name|b
argument_list|)
expr_stmt|;
for|for
control|(
name|link
operator|=
name|DF_INSN_DEFS
argument_list|(
name|df
argument_list|,
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|link
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|link
operator|->
name|ref
operator|||
name|bitmap_bit_p
argument_list|(
name|empty_defs
argument_list|,
name|DF_REF_ID
argument_list|(
name|link
operator|->
name|ref
argument_list|)
argument_list|)
operator|||
name|bitmap_bit_p
argument_list|(
name|b
argument_list|,
name|DF_REF_ID
argument_list|(
name|link
operator|->
name|ref
argument_list|)
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
name|bitmap_set_bit
argument_list|(
name|b
argument_list|,
name|DF_REF_ID
argument_list|(
name|link
operator|->
name|ref
argument_list|)
argument_list|)
expr_stmt|;
name|bitmap_clear
argument_list|(
name|b
argument_list|)
expr_stmt|;
for|for
control|(
name|link
operator|=
name|DF_INSN_USES
argument_list|(
name|df
argument_list|,
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|link
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|link
operator|->
name|ref
operator|||
name|bitmap_bit_p
argument_list|(
name|empty_uses
argument_list|,
name|DF_REF_ID
argument_list|(
name|link
operator|->
name|ref
argument_list|)
argument_list|)
operator|||
name|bitmap_bit_p
argument_list|(
name|b
argument_list|,
name|DF_REF_ID
argument_list|(
name|link
operator|->
name|ref
argument_list|)
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
name|bitmap_set_bit
argument_list|(
name|b
argument_list|,
name|DF_REF_ID
argument_list|(
name|link
operator|->
name|ref
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Now the same for the chains per register number.  */
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|max_reg_num
argument_list|()
condition|;
name|regno
operator|++
control|)
block|{
name|bitmap_clear
argument_list|(
name|b
argument_list|)
expr_stmt|;
for|for
control|(
name|link
operator|=
name|df
operator|->
name|regs
index|[
name|regno
index|]
operator|.
name|defs
init|;
name|link
condition|;
name|link
operator|=
name|link
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|link
operator|->
name|ref
operator|||
name|bitmap_bit_p
argument_list|(
name|empty_defs
argument_list|,
name|DF_REF_ID
argument_list|(
name|link
operator|->
name|ref
argument_list|)
argument_list|)
operator|||
name|bitmap_bit_p
argument_list|(
name|b
argument_list|,
name|DF_REF_ID
argument_list|(
name|link
operator|->
name|ref
argument_list|)
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
name|bitmap_set_bit
argument_list|(
name|b
argument_list|,
name|DF_REF_ID
argument_list|(
name|link
operator|->
name|ref
argument_list|)
argument_list|)
expr_stmt|;
name|bitmap_clear
argument_list|(
name|b
argument_list|)
expr_stmt|;
for|for
control|(
name|link
operator|=
name|df
operator|->
name|regs
index|[
name|regno
index|]
operator|.
name|uses
init|;
name|link
condition|;
name|link
operator|=
name|link
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|link
operator|->
name|ref
operator|||
name|bitmap_bit_p
argument_list|(
name|empty_uses
argument_list|,
name|DF_REF_ID
argument_list|(
name|link
operator|->
name|ref
argument_list|)
argument_list|)
operator|||
name|bitmap_bit_p
argument_list|(
name|b
argument_list|,
name|DF_REF_ID
argument_list|(
name|link
operator|->
name|ref
argument_list|)
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
name|bitmap_set_bit
argument_list|(
name|b
argument_list|,
name|DF_REF_ID
argument_list|(
name|link
operator|->
name|ref
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|BITMAP_XFREE
argument_list|(
name|empty_uses
argument_list|)
expr_stmt|;
name|BITMAP_XFREE
argument_list|(
name|empty_defs
argument_list|)
expr_stmt|;
name|BITMAP_XFREE
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Main register allocator entry point.  */
end_comment

begin_function
name|void
name|reg_alloc
parameter_list|()
block|{
name|int
name|changed
decl_stmt|;
name|FILE
modifier|*
name|ra_dump_file
init|=
name|rtl_dump_file
decl_stmt|;
name|rtx
name|last
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|last
argument_list|)
condition|)
name|last
operator|=
name|prev_real_insn
argument_list|(
name|last
argument_list|)
expr_stmt|;
comment|/* If this is an empty function we shouldn't do all the following,      but instead just setup what's necessary, and return.  */
comment|/* We currently rely on the existance of the return value USE as      one of the last insns.  Add it if it's not there anymore.  */
if|if
condition|(
name|last
condition|)
block|{
name|edge
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|EXIT_BLOCK_PTR
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
block|{
name|basic_block
name|bb
init|=
name|e
operator|->
name|src
decl_stmt|;
name|last
operator|=
name|bb
operator|->
name|end
expr_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|last
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|last
argument_list|)
argument_list|)
operator|!=
name|USE
condition|)
block|{
name|rtx
name|insns
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|use_return_register
argument_list|()
expr_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn_after
argument_list|(
name|insns
argument_list|,
name|last
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Setup debugging levels.  */
switch|switch
condition|(
literal|0
condition|)
block|{
comment|/* Some usefull presets of the debug level, I often use.  */
case|case
literal|0
case|:
name|debug_new_regalloc
operator|=
name|DUMP_EVER
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|debug_new_regalloc
operator|=
name|DUMP_COSTS
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|debug_new_regalloc
operator|=
name|DUMP_IGRAPH_M
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|debug_new_regalloc
operator|=
name|DUMP_COLORIZE
operator|+
name|DUMP_COSTS
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|debug_new_regalloc
operator|=
name|DUMP_COLORIZE
operator|+
name|DUMP_COSTS
operator|+
name|DUMP_WEBS
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|debug_new_regalloc
operator|=
name|DUMP_FINAL_RTL
operator|+
name|DUMP_COSTS
operator|+
name|DUMP_CONSTRAINTS
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|debug_new_regalloc
operator|=
name|DUMP_VALIDIFY
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|rtl_dump_file
condition|)
name|debug_new_regalloc
operator|=
literal|0
expr_stmt|;
comment|/* Run regclass first, so we know the preferred and alternate classes      for each pseudo.  Deactivate emitting of debug info, if it's not      explicitely requested.  */
if|if
condition|(
operator|(
name|debug_new_regalloc
operator|&
name|DUMP_REGCLASS
operator|)
operator|==
literal|0
condition|)
name|rtl_dump_file
operator|=
name|NULL
expr_stmt|;
name|regclass
argument_list|(
name|get_insns
argument_list|()
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|rtl_dump_file
operator|=
name|ra_dump_file
expr_stmt|;
comment|/* We don't use those NOTEs, and as we anyway change all registers,      they only make problems later.  */
name|count_or_remove_death_notes
argument_list|(
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Initialize the different global arrays and regsets.  */
name|init_ra
argument_list|()
expr_stmt|;
comment|/* And some global variables.  */
name|ra_pass
operator|=
literal|0
expr_stmt|;
name|no_new_pseudos
operator|=
literal|0
expr_stmt|;
name|max_normal_pseudo
operator|=
operator|(
name|unsigned
operator|)
name|max_reg_num
argument_list|()
expr_stmt|;
name|ra_rewrite_init
argument_list|()
expr_stmt|;
name|last_def_id
operator|=
literal|0
expr_stmt|;
name|last_use_id
operator|=
literal|0
expr_stmt|;
name|last_num_webs
operator|=
literal|0
expr_stmt|;
name|last_max_uid
operator|=
literal|0
expr_stmt|;
name|last_check_uses
operator|=
name|NULL
expr_stmt|;
name|live_at_end
operator|=
name|NULL
expr_stmt|;
name|WEBS
argument_list|(
name|INITIAL
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|WEBS
argument_list|(
name|FREE
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|memset
argument_list|(
name|hardreg2web
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hardreg2web
argument_list|)
argument_list|)
expr_stmt|;
name|ticks_build
operator|=
name|ticks_rebuild
operator|=
literal|0
expr_stmt|;
comment|/* The default is to use optimistic coalescing with interference      region spilling, without biased coloring.  */
name|flag_ra_biased
operator|=
literal|0
expr_stmt|;
name|flag_ra_spill_every_use
operator|=
literal|0
expr_stmt|;
name|flag_ra_improved_spilling
operator|=
literal|1
expr_stmt|;
name|flag_ra_ir_spilling
operator|=
literal|1
expr_stmt|;
name|flag_ra_break_aliases
operator|=
literal|0
expr_stmt|;
name|flag_ra_optimistic_coalescing
operator|=
literal|1
expr_stmt|;
name|flag_ra_merge_spill_costs
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|flag_ra_optimistic_coalescing
condition|)
name|flag_ra_break_aliases
operator|=
literal|1
expr_stmt|;
name|flag_ra_dump_notes
operator|=
literal|0
expr_stmt|;
comment|/* Allocate the global df structure.  */
name|df
operator|=
name|df_init
argument_list|()
expr_stmt|;
comment|/* This is the main loop, calling one_pass as long as there are still      some spilled webs.  */
do|do
block|{
name|ra_debug_msg
argument_list|(
name|DUMP_NEARLY_EVER
argument_list|,
literal|"RegAlloc Pass %d\n\n"
argument_list|,
name|ra_pass
argument_list|)
expr_stmt|;
if|if
condition|(
name|ra_pass
operator|++
operator|>
literal|40
condition|)
name|internal_error
argument_list|(
literal|"Didn't find a coloring.\n"
argument_list|)
expr_stmt|;
comment|/* First collect all the register refs and put them into 	 chains per insn, and per regno.  In later passes only update          that info from the new and modified insns.  */
name|df_analyse
argument_list|(
name|df
argument_list|,
operator|(
name|ra_pass
operator|==
literal|1
operator|)
condition|?
literal|0
else|:
operator|(
name|bitmap
operator|)
operator|-
literal|1
argument_list|,
name|DF_HARD_REGS
operator||
name|DF_RD_CHAIN
operator||
name|DF_RU_CHAIN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|debug_new_regalloc
operator|&
name|DUMP_DF
operator|)
operator|!=
literal|0
condition|)
block|{
name|rtx
name|insn
decl_stmt|;
name|df_dump
argument_list|(
name|df
argument_list|,
name|DF_HARD_REGS
argument_list|,
name|rtl_dump_file
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|df_insn_debug_regno
argument_list|(
name|df
argument_list|,
name|insn
argument_list|,
name|rtl_dump_file
argument_list|)
expr_stmt|;
block|}
name|check_df
argument_list|(
name|df
argument_list|)
expr_stmt|;
comment|/* Now allocate the memory needed for this pass, or (if it's not the 	 first pass), reallocate only additional memory.  */
name|alloc_mem
argument_list|(
name|df
argument_list|)
expr_stmt|;
comment|/* Build and colorize the interference graph, and possibly emit 	 spill insns.  This also might delete certain move insns.  */
name|changed
operator|=
name|one_pass
argument_list|(
name|df
argument_list|,
name|ra_pass
operator|>
literal|1
argument_list|)
expr_stmt|;
comment|/* If that produced no changes, the graph was colorizable.  */
if|if
condition|(
operator|!
name|changed
condition|)
block|{
comment|/* Change the insns to refer to the new pseudos (one per web).  */
name|emit_colors
argument_list|(
name|df
argument_list|)
expr_stmt|;
comment|/* Already setup a preliminary reg_renumber[] array, but don't 	     free our own version.  reg_renumber[] will again be destroyed 	     later.  We right now need it in dump_constraints() for 	     constrain_operands(1) whose subproc sometimes reference 	     it (because we are checking strictly, i.e. as if 	     after reload).  */
name|setup_renumber
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Delete some more of the coalesced moves.  */
name|delete_moves
argument_list|()
expr_stmt|;
name|dump_constraints
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* If there were changes, this means spill code was added, 	     therefore repeat some things, including some initialization 	     of global data structures.  */
if|if
condition|(
operator|(
name|debug_new_regalloc
operator|&
name|DUMP_REGCLASS
operator|)
operator|==
literal|0
condition|)
name|rtl_dump_file
operator|=
name|NULL
expr_stmt|;
comment|/* We have new pseudos (the stackwebs).  */
name|allocate_reg_info
argument_list|(
name|max_reg_num
argument_list|()
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* And new insns.  */
name|compute_bb_for_insn
argument_list|()
expr_stmt|;
comment|/* Some of them might be dead.  */
name|delete_trivially_dead_insns
argument_list|(
name|get_insns
argument_list|()
argument_list|,
name|max_reg_num
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Those new pseudos need to have their REFS count set.  */
name|reg_scan_update
argument_list|(
name|get_insns
argument_list|()
argument_list|,
name|NULL
argument_list|,
name|max_regno
argument_list|)
expr_stmt|;
name|max_regno
operator|=
name|max_reg_num
argument_list|()
expr_stmt|;
comment|/* And they need usefull classes too.  */
name|regclass
argument_list|(
name|get_insns
argument_list|()
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|rtl_dump_file
operator|=
name|ra_dump_file
expr_stmt|;
comment|/* Remember the number of defs and uses, so we can distinguish 	     new from old refs in the next pass.  */
name|last_def_id
operator|=
name|df
operator|->
name|def_id
expr_stmt|;
name|last_use_id
operator|=
name|df
operator|->
name|use_id
expr_stmt|;
block|}
comment|/* Output the graph, and possibly the current insn sequence.  */
name|dump_ra
argument_list|(
name|df
argument_list|)
expr_stmt|;
if|if
condition|(
name|changed
operator|&&
operator|(
name|debug_new_regalloc
operator|&
name|DUMP_RTL
operator|)
operator|!=
literal|0
condition|)
block|{
name|ra_print_rtl_with_bb
argument_list|(
name|rtl_dump_file
argument_list|,
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|rtl_dump_file
argument_list|)
expr_stmt|;
block|}
comment|/* Reset the web lists.  */
name|reset_lists
argument_list|()
expr_stmt|;
name|free_mem
argument_list|(
name|df
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|changed
condition|)
do|;
comment|/* We are done with allocation, free all memory and output some      debug info.  */
name|free_all_mem
argument_list|(
name|df
argument_list|)
expr_stmt|;
name|df_finish
argument_list|(
name|df
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|debug_new_regalloc
operator|&
name|DUMP_RESULTS
operator|)
operator|==
literal|0
condition|)
name|dump_cost
argument_list|(
name|DUMP_COSTS
argument_list|)
expr_stmt|;
name|ra_debug_msg
argument_list|(
name|DUMP_COSTS
argument_list|,
literal|"ticks for build-phase: %ld\n"
argument_list|,
name|ticks_build
argument_list|)
expr_stmt|;
name|ra_debug_msg
argument_list|(
name|DUMP_COSTS
argument_list|,
literal|"ticks for rebuild-phase: %ld\n"
argument_list|,
name|ticks_rebuild
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|debug_new_regalloc
operator|&
operator|(
name|DUMP_FINAL_RTL
operator||
name|DUMP_RTL
operator|)
operator|)
operator|!=
literal|0
condition|)
name|ra_print_rtl_with_bb
argument_list|(
name|rtl_dump_file
argument_list|,
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
comment|/* We might have new pseudos, so allocate the info arrays for them.  */
if|if
condition|(
operator|(
name|debug_new_regalloc
operator|&
name|DUMP_SM
operator|)
operator|==
literal|0
condition|)
name|rtl_dump_file
operator|=
name|NULL
expr_stmt|;
name|no_new_pseudos
operator|=
literal|0
expr_stmt|;
name|allocate_reg_info
argument_list|(
name|max_reg_num
argument_list|()
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|no_new_pseudos
operator|=
literal|1
expr_stmt|;
name|rtl_dump_file
operator|=
name|ra_dump_file
expr_stmt|;
comment|/* Some spill insns could've been inserted after trapping calls, i.e.      at the end of a basic block, which really ends at that call.      Fixup that breakages by adjusting basic block boundaries.  */
name|fixup_abnormal_edges
argument_list|()
expr_stmt|;
comment|/* Cleanup the flow graph.  */
if|if
condition|(
operator|(
name|debug_new_regalloc
operator|&
name|DUMP_LAST_FLOW
operator|)
operator|==
literal|0
condition|)
name|rtl_dump_file
operator|=
name|NULL
expr_stmt|;
name|life_analysis
argument_list|(
name|get_insns
argument_list|()
argument_list|,
name|rtl_dump_file
argument_list|,
name|PROP_DEATH_NOTES
operator||
name|PROP_LOG_LINKS
operator||
name|PROP_REG_INFO
argument_list|)
expr_stmt|;
name|cleanup_cfg
argument_list|(
name|CLEANUP_EXPENSIVE
argument_list|)
expr_stmt|;
name|recompute_reg_usage
argument_list|(
name|get_insns
argument_list|()
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|dump_flow_info
argument_list|(
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|rtl_dump_file
operator|=
name|ra_dump_file
expr_stmt|;
comment|/* update_equiv_regs() can't be called after register allocation.      It might delete some pseudos, and insert other insns setting      up those pseudos in different places.  This of course screws up      the allocation because that may destroy a hardreg for another      pseudo.      XXX we probably should do something like that on our own.  I.e.      creating REG_EQUIV notes.  */
comment|/*update_equiv_regs ();*/
comment|/* Setup the reg_renumber[] array for reload.  */
name|setup_renumber
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|insns_with_deaths
argument_list|)
expr_stmt|;
comment|/* Remove REG_DEAD notes which are incorrectly set.  See the docu      of that function.  */
name|remove_suspicious_death_notes
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|debug_new_regalloc
operator|&
name|DUMP_LAST_RTL
operator|)
operator|!=
literal|0
condition|)
name|ra_print_rtl_with_bb
argument_list|(
name|rtl_dump_file
argument_list|,
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
name|dump_static_insn_cost
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"after allocation/spilling, before reload"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Allocate the reg_equiv_memory_loc array for reload.  */
name|reg_equiv_memory_loc
operator|=
operator|(
name|rtx
operator|*
operator|)
name|xcalloc
argument_list|(
name|max_regno
argument_list|,
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* And possibly initialize it.  */
name|allocate_initial_values
argument_list|(
name|reg_equiv_memory_loc
argument_list|)
expr_stmt|;
comment|/* And one last regclass pass just before reload.  */
name|regclass
argument_list|(
name|get_insns
argument_list|()
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
name|rtl_dump_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* vim:cinoptions={.5s,g0,p5,t0,(0,^-0.5s,n-0.5s:tw=78:cindent:sw=4: */
end_comment

end_unit

