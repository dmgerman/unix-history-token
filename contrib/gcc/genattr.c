begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Generate attribute information (insn-attr.h) from machine description.    Copyright (C) 1991, 1994, 1996, 1998, 1999, 2000 Free Software Foundation, Inc.    Contributed by Richard Kenner (kenner@vlsi1.ultra.nyu.edu)  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"hconfig.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"errors.h"
end_include

begin_include
include|#
directive|include
file|"gensupport.h"
end_include

begin_comment
comment|/* A range of values.  */
end_comment

begin_struct
struct|struct
name|range
block|{
name|int
name|min
decl_stmt|;
name|int
name|max
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Record information about each function unit mentioned in a    DEFINE_FUNCTION_UNIT.  */
end_comment

begin_struct
struct|struct
name|function_unit
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Function unit name.  */
name|struct
name|function_unit
modifier|*
name|next
decl_stmt|;
comment|/* Next function unit.  */
name|int
name|multiplicity
decl_stmt|;
comment|/* Number of units of this type.  */
name|int
name|simultaneity
decl_stmt|;
comment|/* Maximum number of simultaneous insns 				   on this function unit or 0 if unlimited.  */
name|struct
name|range
name|ready_cost
decl_stmt|;
comment|/* Range of ready cost values.  */
name|struct
name|range
name|issue_delay
decl_stmt|;
comment|/* Range of issue delay values.  */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|void
name|extend_range
name|PARAMS
argument_list|(
operator|(
expr|struct
name|range
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_range
name|PARAMS
argument_list|(
operator|(
expr|struct
name|range
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_upcase
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_attr
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_units
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|range
operator|*
operator|,
expr|struct
name|range
operator|*
operator|,
expr|struct
name|range
operator|*
operator|,
expr|struct
name|range
operator|*
operator|,
expr|struct
name|range
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|extend_range
parameter_list|(
name|range
parameter_list|,
name|min
parameter_list|,
name|max
parameter_list|)
name|struct
name|range
modifier|*
name|range
decl_stmt|;
name|int
name|min
decl_stmt|;
name|int
name|max
decl_stmt|;
block|{
if|if
condition|(
name|range
operator|->
name|min
operator|>
name|min
condition|)
name|range
operator|->
name|min
operator|=
name|min
expr_stmt|;
if|if
condition|(
name|range
operator|->
name|max
operator|<
name|max
condition|)
name|range
operator|->
name|max
operator|=
name|max
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_range
parameter_list|(
name|range
parameter_list|)
name|struct
name|range
modifier|*
name|range
decl_stmt|;
block|{
name|range
operator|->
name|min
operator|=
literal|100000
expr_stmt|;
name|range
operator|->
name|max
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|write_upcase
parameter_list|(
name|str
parameter_list|)
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
block|{
for|for
control|(
init|;
operator|*
name|str
condition|;
name|str
operator|++
control|)
name|putchar
argument_list|(
name|TOUPPER
argument_list|(
operator|*
name|str
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gen_attr
parameter_list|(
name|attr
parameter_list|)
name|rtx
name|attr
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|is_const
init|=
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|attr
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|CONST
decl_stmt|;
name|printf
argument_list|(
literal|"#define HAVE_ATTR_%s\n"
argument_list|,
name|XSTR
argument_list|(
name|attr
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If numeric attribute, don't need to write an enum.  */
if|if
condition|(
operator|*
name|XSTR
argument_list|(
name|attr
argument_list|,
literal|1
argument_list|)
operator|==
literal|'\0'
condition|)
name|printf
argument_list|(
literal|"extern int get_attr_%s PARAMS ((%s));\n"
argument_list|,
name|XSTR
argument_list|(
name|attr
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|(
name|is_const
condition|?
literal|"void"
else|:
literal|"rtx"
operator|)
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"enum attr_%s {"
argument_list|,
name|XSTR
argument_list|(
name|attr
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|write_upcase
argument_list|(
name|XSTR
argument_list|(
name|attr
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"_"
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|XSTR
argument_list|(
name|attr
argument_list|,
literal|1
argument_list|)
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|','
condition|)
block|{
name|printf
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|write_upcase
argument_list|(
name|XSTR
argument_list|(
name|attr
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"_"
argument_list|)
expr_stmt|;
block|}
else|else
name|putchar
argument_list|(
name|TOUPPER
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"};\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"extern enum attr_%s get_attr_%s PARAMS ((%s));\n\n"
argument_list|,
name|XSTR
argument_list|(
name|attr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XSTR
argument_list|(
name|attr
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|(
name|is_const
condition|?
literal|"void"
else|:
literal|"rtx"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* If `length' attribute, write additional function definitions and define      variables used by `insn_current_length'.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|attr
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|"length"
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"extern void shorten_branches PARAMS ((rtx));\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"extern int insn_default_length PARAMS ((rtx));\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"extern int insn_variable_length_p PARAMS ((rtx));\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"extern int insn_current_length PARAMS ((rtx));\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"insn-addr.h\"\n\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|write_units
parameter_list|(
name|num_units
parameter_list|,
name|multiplicity
parameter_list|,
name|simultaneity
parameter_list|,
name|ready_cost
parameter_list|,
name|issue_delay
parameter_list|,
name|blockage
parameter_list|)
name|int
name|num_units
decl_stmt|;
name|struct
name|range
modifier|*
name|multiplicity
decl_stmt|;
name|struct
name|range
modifier|*
name|simultaneity
decl_stmt|;
name|struct
name|range
modifier|*
name|ready_cost
decl_stmt|;
name|struct
name|range
modifier|*
name|issue_delay
decl_stmt|;
name|struct
name|range
modifier|*
name|blockage
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|q_size
decl_stmt|;
name|printf
argument_list|(
literal|"#define INSN_SCHEDULING\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"extern int result_ready_cost PARAMS ((rtx));\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"extern int function_units_used PARAMS ((rtx));\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"extern const struct function_unit_desc\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"{\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  const char *const name;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  const int bitmask;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  const int multiplicity;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  const int simultaneity;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  const int default_cost;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  const int max_issue_delay;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  int (*const ready_cost_function) PARAMS ((rtx));\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  int (*const conflict_cost_function) PARAMS ((rtx, rtx));\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  const int max_blockage;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  unsigned int (*const blockage_range_function) PARAMS ((rtx));\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  int (*const blockage_function) PARAMS ((rtx, rtx));\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"} function_units[];\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#define FUNCTION_UNITS_SIZE %d\n"
argument_list|,
name|num_units
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#define MIN_MULTIPLICITY %d\n"
argument_list|,
name|multiplicity
operator|->
name|min
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#define MAX_MULTIPLICITY %d\n"
argument_list|,
name|multiplicity
operator|->
name|max
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#define MIN_SIMULTANEITY %d\n"
argument_list|,
name|simultaneity
operator|->
name|min
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#define MAX_SIMULTANEITY %d\n"
argument_list|,
name|simultaneity
operator|->
name|max
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#define MIN_READY_COST %d\n"
argument_list|,
name|ready_cost
operator|->
name|min
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#define MAX_READY_COST %d\n"
argument_list|,
name|ready_cost
operator|->
name|max
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#define MIN_ISSUE_DELAY %d\n"
argument_list|,
name|issue_delay
operator|->
name|min
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#define MAX_ISSUE_DELAY %d\n"
argument_list|,
name|issue_delay
operator|->
name|max
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#define MIN_BLOCKAGE %d\n"
argument_list|,
name|blockage
operator|->
name|min
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#define MAX_BLOCKAGE %d\n"
argument_list|,
name|blockage
operator|->
name|max
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
literal|1
operator|<<
name|i
operator|)
operator|<
name|blockage
operator|->
name|max
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|printf
argument_list|(
literal|"#define BLOCKAGE_BITS %d\n"
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* INSN_QUEUE_SIZE is a power of two larger than MAX_BLOCKAGE and      MAX_READY_COST.  This is the longest time an isnsn may be queued.  */
name|i
operator|=
name|MAX
argument_list|(
name|blockage
operator|->
name|max
argument_list|,
name|ready_cost
operator|->
name|max
argument_list|)
expr_stmt|;
for|for
control|(
name|q_size
operator|=
literal|1
init|;
name|q_size
operator|<=
name|i
condition|;
name|q_size
operator|<<=
literal|1
control|)
empty_stmt|;
name|printf
argument_list|(
literal|"#define INSN_QUEUE_SIZE %d\n"
argument_list|,
name|q_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|extern
name|int
decl|main
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|rtx
name|desc
decl_stmt|;
name|int
name|have_delay
init|=
literal|0
decl_stmt|;
name|int
name|have_annul_true
init|=
literal|0
decl_stmt|;
name|int
name|have_annul_false
init|=
literal|0
decl_stmt|;
name|int
name|num_units
init|=
literal|0
decl_stmt|;
name|struct
name|range
name|all_simultaneity
decl_stmt|,
name|all_multiplicity
decl_stmt|;
name|struct
name|range
name|all_ready_cost
decl_stmt|,
name|all_issue_delay
decl_stmt|,
name|all_blockage
decl_stmt|;
name|struct
name|function_unit
modifier|*
name|units
init|=
literal|0
decl_stmt|,
modifier|*
name|unit
decl_stmt|;
name|int
name|i
decl_stmt|;
name|init_range
argument_list|(
operator|&
name|all_multiplicity
argument_list|)
expr_stmt|;
name|init_range
argument_list|(
operator|&
name|all_simultaneity
argument_list|)
expr_stmt|;
name|init_range
argument_list|(
operator|&
name|all_ready_cost
argument_list|)
expr_stmt|;
name|init_range
argument_list|(
operator|&
name|all_issue_delay
argument_list|)
expr_stmt|;
name|init_range
argument_list|(
operator|&
name|all_blockage
argument_list|)
expr_stmt|;
name|progname
operator|=
literal|"genattr"
expr_stmt|;
if|if
condition|(
name|argc
operator|<=
literal|1
condition|)
name|fatal
argument_list|(
literal|"no input file name"
argument_list|)
expr_stmt|;
if|if
condition|(
name|init_md_reader_args
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
operator|!=
name|SUCCESS_EXIT_CODE
condition|)
return|return
operator|(
name|FATAL_EXIT_CODE
operator|)
return|;
name|puts
argument_list|(
literal|"/* Generated automatically by the program `genattr'"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"   from the machine description file `md'.  */\n"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"#ifndef GCC_INSN_ATTR_H"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"#define GCC_INSN_ATTR_H\n"
argument_list|)
expr_stmt|;
comment|/* For compatibility, define the attribute `alternative', which is just      a reference to the variable `which_alternative'.  */
name|puts
argument_list|(
literal|"#define HAVE_ATTR_alternative"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"#define get_attr_alternative(insn) which_alternative"
argument_list|)
expr_stmt|;
comment|/* Read the machine description.  */
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|line_no
decl_stmt|,
name|insn_code_number
decl_stmt|;
name|desc
operator|=
name|read_md_rtx
argument_list|(
operator|&
name|line_no
argument_list|,
operator|&
name|insn_code_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_ATTR
condition|)
name|gen_attr
argument_list|(
name|desc
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_DELAY
condition|)
block|{
if|if
condition|(
operator|!
name|have_delay
condition|)
block|{
name|printf
argument_list|(
literal|"#define DELAY_SLOTS\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"extern int num_delay_slots PARAMS ((rtx));\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"extern int eligible_for_delay PARAMS ((rtx, int, rtx, int));\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"extern int const_num_delay_slots PARAMS ((rtx));\n\n"
argument_list|)
expr_stmt|;
name|have_delay
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|desc
argument_list|,
literal|1
argument_list|)
condition|;
name|i
operator|+=
literal|3
control|)
block|{
if|if
condition|(
name|XVECEXP
argument_list|(
name|desc
argument_list|,
literal|1
argument_list|,
name|i
operator|+
literal|1
argument_list|)
operator|&&
operator|!
name|have_annul_true
condition|)
block|{
name|printf
argument_list|(
literal|"#define ANNUL_IFTRUE_SLOTS\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"extern int eligible_for_annul_true PARAMS ((rtx, int, rtx, int));\n"
argument_list|)
expr_stmt|;
name|have_annul_true
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|XVECEXP
argument_list|(
name|desc
argument_list|,
literal|1
argument_list|,
name|i
operator|+
literal|2
argument_list|)
operator|&&
operator|!
name|have_annul_false
condition|)
block|{
name|printf
argument_list|(
literal|"#define ANNUL_IFFALSE_SLOTS\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"extern int eligible_for_annul_false PARAMS ((rtx, int, rtx, int));\n"
argument_list|)
expr_stmt|;
name|have_annul_false
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_FUNCTION_UNIT
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|XSTR
argument_list|(
name|desc
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|multiplicity
init|=
name|XINT
argument_list|(
name|desc
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|int
name|simultaneity
init|=
name|XINT
argument_list|(
name|desc
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|int
name|ready_cost
init|=
name|MAX
argument_list|(
name|XINT
argument_list|(
name|desc
argument_list|,
literal|4
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|int
name|issue_delay
init|=
name|MAX
argument_list|(
name|XINT
argument_list|(
name|desc
argument_list|,
literal|5
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|int
name|issueexp_p
init|=
operator|(
name|XVEC
argument_list|(
name|desc
argument_list|,
literal|6
argument_list|)
operator|!=
literal|0
operator|)
decl_stmt|;
for|for
control|(
name|unit
operator|=
name|units
init|;
name|unit
condition|;
name|unit
operator|=
name|unit
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|unit
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|unit
operator|==
literal|0
condition|)
block|{
name|unit
operator|=
operator|(
expr|struct
name|function_unit
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|function_unit
argument_list|)
argument_list|)
expr_stmt|;
name|unit
operator|->
name|name
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|unit
operator|->
name|multiplicity
operator|=
name|multiplicity
expr_stmt|;
name|unit
operator|->
name|simultaneity
operator|=
name|simultaneity
expr_stmt|;
name|unit
operator|->
name|ready_cost
operator|.
name|min
operator|=
name|unit
operator|->
name|ready_cost
operator|.
name|max
operator|=
name|ready_cost
expr_stmt|;
name|unit
operator|->
name|issue_delay
operator|.
name|min
operator|=
name|unit
operator|->
name|issue_delay
operator|.
name|max
operator|=
name|issue_delay
expr_stmt|;
name|unit
operator|->
name|next
operator|=
name|units
expr_stmt|;
name|units
operator|=
name|unit
expr_stmt|;
name|num_units
operator|++
expr_stmt|;
name|extend_range
argument_list|(
operator|&
name|all_multiplicity
argument_list|,
name|multiplicity
argument_list|,
name|multiplicity
argument_list|)
expr_stmt|;
name|extend_range
argument_list|(
operator|&
name|all_simultaneity
argument_list|,
name|simultaneity
argument_list|,
name|simultaneity
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|unit
operator|->
name|multiplicity
operator|!=
name|multiplicity
operator|||
name|unit
operator|->
name|simultaneity
operator|!=
name|simultaneity
condition|)
name|fatal
argument_list|(
literal|"Differing specifications given for `%s' function unit"
argument_list|,
name|unit
operator|->
name|name
argument_list|)
expr_stmt|;
name|extend_range
argument_list|(
operator|&
name|unit
operator|->
name|ready_cost
argument_list|,
name|ready_cost
argument_list|,
name|ready_cost
argument_list|)
expr_stmt|;
name|extend_range
argument_list|(
operator|&
name|unit
operator|->
name|issue_delay
argument_list|,
name|issueexp_p
condition|?
literal|1
else|:
name|issue_delay
argument_list|,
name|issue_delay
argument_list|)
expr_stmt|;
name|extend_range
argument_list|(
operator|&
name|all_ready_cost
argument_list|,
name|unit
operator|->
name|ready_cost
operator|.
name|min
argument_list|,
name|unit
operator|->
name|ready_cost
operator|.
name|max
argument_list|)
expr_stmt|;
name|extend_range
argument_list|(
operator|&
name|all_issue_delay
argument_list|,
name|unit
operator|->
name|issue_delay
operator|.
name|min
argument_list|,
name|unit
operator|->
name|issue_delay
operator|.
name|max
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|num_units
operator|>
literal|0
condition|)
block|{
comment|/* Compute the range of blockage cost values.  See genattrtab.c 	 for the derivation.  BLOCKAGE (E,C) when SIMULTANEITY is zero is  	     MAX (ISSUE-DELAY (E,C), 		  READY-COST (E) - (READY-COST (C) - 1))  	 and otherwise  	     MAX (ISSUE-DELAY (E,C), 		  READY-COST (E) - (READY-COST (C) - 1), 		  READY-COST (E) - FILL-TIME)  */
for|for
control|(
name|unit
operator|=
name|units
init|;
name|unit
condition|;
name|unit
operator|=
name|unit
operator|->
name|next
control|)
block|{
name|struct
name|range
name|blockage
decl_stmt|;
name|blockage
operator|=
name|unit
operator|->
name|issue_delay
expr_stmt|;
name|blockage
operator|.
name|max
operator|=
name|MAX
argument_list|(
name|unit
operator|->
name|ready_cost
operator|.
name|max
operator|-
operator|(
name|unit
operator|->
name|ready_cost
operator|.
name|min
operator|-
literal|1
operator|)
argument_list|,
name|blockage
operator|.
name|max
argument_list|)
expr_stmt|;
name|blockage
operator|.
name|min
operator|=
name|MAX
argument_list|(
literal|1
argument_list|,
name|blockage
operator|.
name|min
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|->
name|simultaneity
operator|!=
literal|0
condition|)
block|{
name|int
name|fill_time
init|=
operator|(
operator|(
name|unit
operator|->
name|simultaneity
operator|-
literal|1
operator|)
operator|*
name|unit
operator|->
name|issue_delay
operator|.
name|min
operator|)
decl_stmt|;
name|blockage
operator|.
name|min
operator|=
name|MAX
argument_list|(
name|unit
operator|->
name|ready_cost
operator|.
name|min
operator|-
name|fill_time
argument_list|,
name|blockage
operator|.
name|min
argument_list|)
expr_stmt|;
name|blockage
operator|.
name|max
operator|=
name|MAX
argument_list|(
name|unit
operator|->
name|ready_cost
operator|.
name|max
operator|-
name|fill_time
argument_list|,
name|blockage
operator|.
name|max
argument_list|)
expr_stmt|;
block|}
name|extend_range
argument_list|(
operator|&
name|all_blockage
argument_list|,
name|blockage
operator|.
name|min
argument_list|,
name|blockage
operator|.
name|max
argument_list|)
expr_stmt|;
block|}
name|write_units
argument_list|(
name|num_units
argument_list|,
operator|&
name|all_multiplicity
argument_list|,
operator|&
name|all_simultaneity
argument_list|,
operator|&
name|all_ready_cost
argument_list|,
operator|&
name|all_issue_delay
argument_list|,
operator|&
name|all_blockage
argument_list|)
expr_stmt|;
block|}
comment|/* Output flag masks for use by reorg.         Flags are used to hold branch direction and prediction information      for use by eligible_for_...  */
name|printf
argument_list|(
literal|"\n#define ATTR_FLAG_forward\t0x1\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#define ATTR_FLAG_backward\t0x2\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#define ATTR_FLAG_likely\t0x4\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#define ATTR_FLAG_very_likely\t0x8\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#define ATTR_FLAG_unlikely\t0x10\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#define ATTR_FLAG_very_unlikely\t0x20\n"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"\n#endif /* GCC_INSN_ATTR_H */"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stdout
argument_list|)
operator|||
name|fflush
argument_list|(
name|stdout
argument_list|)
operator|||
name|fclose
argument_list|(
name|stdout
argument_list|)
condition|)
return|return
name|FATAL_EXIT_CODE
return|;
return|return
name|SUCCESS_EXIT_CODE
return|;
block|}
end_function

begin_comment
comment|/* Define this so we can link with print-rtl.o to get debug_rtx function.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|get_insn_name
parameter_list|(
name|code
parameter_list|)
name|int
name|code
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|NULL
return|;
block|}
end_function

end_unit

