begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Graph coloring register allocator    Copyright (C) 2001, 2002 Free Software Foundation, Inc.    Contributed by Michael Matz<matz@suse.de>    and Daniel Berlin<dan@cgsoftware.com>.     This file is part of GCC.     GCC is free software; you can redistribute it and/or modify it under the    terms of the GNU General Public License as published by the Free Software    Foundation; either version 2, or (at your option) any later version.     GCC is distributed in the hope that it will be useful, but WITHOUT ANY    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS    FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more    details.     You should have received a copy of the GNU General Public License along    with GCC; see the file COPYING.  If not, write to the Free Software    Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"df.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"ra.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_comment
comment|/* This file contains various dumping and debug functions for    the graph coloring register allocator.  */
end_comment

begin_function_decl
specifier|static
name|void
name|ra_print_rtx_1op
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ra_print_rtx_2op
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ra_print_rtx_3op
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ra_print_rtx_object
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* The hardregs as names, for debugging.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|reg_class_names
index|[]
init|=
name|REG_CLASS_NAMES
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print a message to the dump file, if debug_new_regalloc and LEVEL    have any bits in common.  */
end_comment

begin_function
name|void
name|ra_debug_msg
parameter_list|(
name|unsigned
name|int
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|debug_new_regalloc
operator|&
name|level
operator|)
operator|!=
literal|0
operator|&&
name|rtl_dump_file
operator|!=
name|NULL
condition|)
name|vfprintf
argument_list|(
name|rtl_dump_file
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The following ra_print_xxx() functions print RTL expressions    in concise infix form.  If the mode can be seen from context it's    left out.  Most operators are represented by their graphical    characters, e.g. LE as "<=".  Unknown constructs are currently    printed with print_inline_rtx(), which disrupts the nice layout.    Currently only the inline asm things are written this way.  */
end_comment

begin_comment
comment|/* Print rtx X, which is a one operand rtx (op:mode (Y)), as    "op(Y)" to FILE.  */
end_comment

begin_function
specifier|static
name|void
name|ra_print_rtx_1op
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|rtx
name|x
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
name|op0
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|NEG
case|:
case|case
name|NOT
case|:
name|fputs
argument_list|(
operator|(
name|code
operator|==
name|NEG
operator|)
condition|?
literal|"-("
else|:
literal|"~("
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|ra_print_rtx
argument_list|(
name|file
argument_list|,
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|")"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|HIGH
case|:
name|fputs
argument_list|(
literal|"hi("
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|ra_print_rtx
argument_list|(
name|file
argument_list|,
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|")"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|GET_RTX_NAME
argument_list|(
name|code
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|VOIDmode
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|":%s("
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
literal|"("
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|ra_print_rtx
argument_list|(
name|file
argument_list|,
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|")"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Print rtx X, which is a two operand rtx (op:mode (Y) (Z))    as "(Y op Z)", if the operand is know, or as "op(Y, Z)", if not,    to FILE.  */
end_comment

begin_function
specifier|static
name|void
name|ra_print_rtx_2op
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|rtx
name|x
parameter_list|)
block|{
name|int
name|infix
init|=
literal|1
decl_stmt|;
specifier|const
name|char
modifier|*
name|opname
init|=
literal|"shitop"
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
name|op0
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
comment|/* class '2' */
case|case
name|COMPARE
case|:
name|opname
operator|=
literal|"?"
expr_stmt|;
break|break;
case|case
name|MINUS
case|:
name|opname
operator|=
literal|"-"
expr_stmt|;
break|break;
case|case
name|DIV
case|:
name|opname
operator|=
literal|"/"
expr_stmt|;
break|break;
case|case
name|UDIV
case|:
name|opname
operator|=
literal|"u/"
expr_stmt|;
break|break;
case|case
name|MOD
case|:
name|opname
operator|=
literal|"%"
expr_stmt|;
break|break;
case|case
name|UMOD
case|:
name|opname
operator|=
literal|"u%"
expr_stmt|;
break|break;
case|case
name|ASHIFT
case|:
name|opname
operator|=
literal|"<<"
expr_stmt|;
break|break;
case|case
name|ASHIFTRT
case|:
name|opname
operator|=
literal|"a>>"
expr_stmt|;
break|break;
case|case
name|LSHIFTRT
case|:
name|opname
operator|=
literal|"l>>"
expr_stmt|;
break|break;
comment|/* class 'c' */
case|case
name|PLUS
case|:
name|opname
operator|=
literal|"+"
expr_stmt|;
break|break;
case|case
name|MULT
case|:
name|opname
operator|=
literal|"*"
expr_stmt|;
break|break;
case|case
name|AND
case|:
name|opname
operator|=
literal|"&"
expr_stmt|;
break|break;
case|case
name|IOR
case|:
name|opname
operator|=
literal|"|"
expr_stmt|;
break|break;
case|case
name|XOR
case|:
name|opname
operator|=
literal|"^"
expr_stmt|;
break|break;
comment|/* class '<' */
case|case
name|NE
case|:
name|opname
operator|=
literal|"!="
expr_stmt|;
break|break;
case|case
name|EQ
case|:
name|opname
operator|=
literal|"=="
expr_stmt|;
break|break;
case|case
name|GE
case|:
name|opname
operator|=
literal|"s>="
expr_stmt|;
break|break;
case|case
name|GT
case|:
name|opname
operator|=
literal|"s>"
expr_stmt|;
break|break;
case|case
name|LE
case|:
name|opname
operator|=
literal|"s<="
expr_stmt|;
break|break;
case|case
name|LT
case|:
name|opname
operator|=
literal|"s<"
expr_stmt|;
break|break;
case|case
name|GEU
case|:
name|opname
operator|=
literal|"u>="
expr_stmt|;
break|break;
case|case
name|GTU
case|:
name|opname
operator|=
literal|"u>"
expr_stmt|;
break|break;
case|case
name|LEU
case|:
name|opname
operator|=
literal|"u<="
expr_stmt|;
break|break;
case|case
name|LTU
case|:
name|opname
operator|=
literal|"u<"
expr_stmt|;
break|break;
default|default:
name|infix
operator|=
literal|0
expr_stmt|;
name|opname
operator|=
name|GET_RTX_NAME
argument_list|(
name|code
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|infix
condition|)
block|{
name|fputs
argument_list|(
literal|"("
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|ra_print_rtx
argument_list|(
name|file
argument_list|,
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %s "
argument_list|,
name|opname
argument_list|)
expr_stmt|;
name|ra_print_rtx
argument_list|(
name|file
argument_list|,
name|op1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|")"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s("
argument_list|,
name|opname
argument_list|)
expr_stmt|;
name|ra_print_rtx
argument_list|(
name|file
argument_list|,
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|", "
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|ra_print_rtx
argument_list|(
name|file
argument_list|,
name|op1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|")"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print rtx X, which a three operand rtx to FILE.    I.e. X is either an IF_THEN_ELSE, or a bitmap operation.  */
end_comment

begin_function
specifier|static
name|void
name|ra_print_rtx_3op
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|rtx
name|x
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
name|op0
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|op2
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|IF_THEN_ELSE
condition|)
block|{
name|ra_print_rtx
argument_list|(
name|file
argument_list|,
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|" ? "
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|ra_print_rtx
argument_list|(
name|file
argument_list|,
name|op1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|" : "
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|ra_print_rtx
argument_list|(
name|file
argument_list|,
name|op2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Bitmap-operation */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s:%s("
argument_list|,
name|GET_RTX_NAME
argument_list|(
name|code
argument_list|)
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ra_print_rtx
argument_list|(
name|file
argument_list|,
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|", "
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|ra_print_rtx
argument_list|(
name|file
argument_list|,
name|op1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|", "
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|ra_print_rtx
argument_list|(
name|file
argument_list|,
name|op2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|")"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print rtx X, which represents an object (class 'o' or some constructs    of class 'x' (e.g. subreg)), to FILE.    (reg XX) rtl is represented as "pXX", of XX was a pseudo,    as "name" it name is the nonnull hardreg name, or as "hXX", if XX    is a hardreg, whose name is NULL, or empty.  */
end_comment

begin_function
specifier|static
name|void
name|ra_print_rtx_object
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|rtx
name|x
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST_INT
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|XWINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_DOUBLE
case|:
block|{
name|int
name|i
decl_stmt|,
name|num
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|fputs
argument_list|(
literal|"dbl("
argument_list|,
name|file
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|num
condition|)
name|fputs
argument_list|(
literal|", "
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|)
comment|/* The MEM or other stuff */
block|{
name|ra_print_rtx
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|num
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'w'
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_HEX
argument_list|,
name|XWINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|num
operator|++
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|CONST_STRING
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\"%s\""
argument_list|,
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST
case|:
name|fputs
argument_list|(
literal|"const("
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|ra_print_rtx
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|")"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|PC
case|:
name|fputs
argument_list|(
literal|"pc"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG
case|:
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|i
decl_stmt|,
name|nregs
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
decl_stmt|;
if|if
condition|(
name|nregs
operator|>
literal|1
condition|)
name|fputs
argument_list|(
literal|"["
argument_list|,
name|file
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nregs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
condition|)
name|fputs
argument_list|(
literal|", "
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_names
index|[
name|regno
operator|+
name|i
index|]
operator|&&
operator|*
name|reg_names
index|[
name|regno
operator|+
name|i
index|]
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|regno
operator|+
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"h%d"
argument_list|,
name|regno
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nregs
operator|>
literal|1
condition|)
name|fputs
argument_list|(
literal|"]"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"p%d"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SUBREG
case|:
block|{
name|rtx
name|sub
init|=
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|ofs
init|=
name|SUBREG_BYTE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|sub
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|sub
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|sub
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nregs
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
decl_stmt|;
name|regno
operator|+=
name|subreg_regno_offset
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|sub
argument_list|)
argument_list|,
name|ofs
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|nregs
operator|>
literal|1
condition|)
name|fputs
argument_list|(
literal|"["
argument_list|,
name|file
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nregs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
condition|)
name|fputs
argument_list|(
literal|", "
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_names
index|[
name|regno
operator|+
name|i
index|]
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|regno
operator|+
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"h%d"
argument_list|,
name|regno
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nregs
operator|>
literal|1
condition|)
name|fputs
argument_list|(
literal|"]"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ra_print_rtx
argument_list|(
name|file
argument_list|,
name|sub
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|":[%s+%d]"
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|mode
argument_list|)
argument_list|,
name|ofs
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|SCRATCH
case|:
name|fputs
argument_list|(
literal|"scratch"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONCAT
case|:
name|ra_print_rtx_2op
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
break|break;
case|case
name|HIGH
case|:
name|ra_print_rtx_1op
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
break|break;
case|case
name|LO_SUM
case|:
name|fputs
argument_list|(
literal|"("
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|ra_print_rtx
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|" + lo("
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|ra_print_rtx
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"))"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEM
case|:
name|fputs
argument_list|(
literal|"["
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|ra_print_rtx
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"]:%s"
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX print alias set too ?? */
break|break;
case|case
name|LABEL_REF
case|:
block|{
name|rtx
name|sub
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|sub
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|sub
argument_list|)
operator|==
name|NOTE_INSN_DELETED_LABEL
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"(deleted uid=%d)"
argument_list|,
name|INSN_UID
argument_list|(
name|sub
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|sub
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"L%d"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|sub
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"(nonlabel uid=%d)"
argument_list|,
name|INSN_UID
argument_list|(
name|sub
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SYMBOL_REF
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"sym(\"%s\")"
argument_list|,
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CC0
case|:
name|fputs
argument_list|(
literal|"cc0"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
default|default:
name|print_inline_rtx
argument_list|(
name|file
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Print a general rtx X to FILE in nice infix form.    If WITH_PN is set, and X is one of the toplevel constructs    (insns, notes, labels or barriers), then print also the UIDs of    the preceding and following insn.  */
end_comment

begin_function
name|void
name|ra_print_rtx
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|rtx
name|x
parameter_list|,
name|int
name|with_pn
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
decl_stmt|;
name|char
name|class
decl_stmt|;
name|int
name|unhandled
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|x
condition|)
return|return;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|class
operator|=
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
expr_stmt|;
comment|/* First handle the insn like constructs.  */
if|if
condition|(
name|INSN_P
argument_list|(
name|x
argument_list|)
operator|||
name|code
operator|==
name|NOTE
operator|||
name|code
operator|==
name|CODE_LABEL
operator|||
name|code
operator|==
name|BARRIER
condition|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|x
argument_list|)
condition|)
name|fputs
argument_list|(
literal|"  "
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* Non-insns are prefixed by a ';'.  */
if|if
condition|(
name|code
operator|==
name|BARRIER
condition|)
name|fputs
argument_list|(
literal|"; "
argument_list|,
name|file
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|NOTE
condition|)
comment|/* But notes are indented very far right.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t\t\t\t\t; "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|CODE_LABEL
condition|)
comment|/* And labels have their Lxx name first, before the actual UID.  */
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"L%d:\t; "
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|LABEL_NAME
argument_list|(
name|x
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"(%s) "
argument_list|,
name|LABEL_NAME
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|LABEL_KIND
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|LABEL_NORMAL
case|:
break|break;
case|case
name|LABEL_STATIC_ENTRY
case|:
name|fputs
argument_list|(
literal|" (entry)"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|LABEL_GLOBAL_ENTRY
case|:
name|fputs
argument_list|(
literal|" (global entry)"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|LABEL_WEAK_ENTRY
case|:
name|fputs
argument_list|(
literal|" (weak entry)"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" [%d uses] uid=("
argument_list|,
name|LABEL_NUSES
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|INSN_UID
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|with_pn
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %d %d"
argument_list|,
name|PREV_INSN
argument_list|(
name|x
argument_list|)
condition|?
name|INSN_UID
argument_list|(
name|PREV_INSN
argument_list|(
name|x
argument_list|)
argument_list|)
else|:
literal|0
argument_list|,
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
condition|?
name|INSN_UID
argument_list|(
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
argument_list|)
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|BARRIER
condition|)
name|fputs
argument_list|(
literal|" -------- barrier ---------"
argument_list|,
name|file
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|CODE_LABEL
condition|)
name|fputs
argument_list|(
literal|")"
argument_list|,
name|file
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|NOTE
condition|)
block|{
name|int
name|ln
init|=
name|NOTE_LINE_NUMBER
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|ln
operator|>=
operator|(
name|int
operator|)
name|NOTE_INSN_BIAS
operator|&&
name|ln
operator|<
operator|(
name|int
operator|)
name|NOTE_INSN_MAX
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %s"
argument_list|,
name|GET_NOTE_INSN_NAME
argument_list|(
name|ln
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" line %d"
argument_list|,
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
name|NOTE_SOURCE_FILE
argument_list|(
name|x
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|":%s"
argument_list|,
name|NOTE_SOURCE_FILE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t"
argument_list|)
expr_stmt|;
name|ra_print_rtx
argument_list|(
name|file
argument_list|,
name|PATTERN
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
switch|switch
condition|(
name|code
condition|)
block|{
comment|/* Top-level stuff.  */
case|case
name|PARALLEL
case|:
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
condition|)
name|fputs
argument_list|(
literal|"\t;; "
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|ra_print_rtx
argument_list|(
name|file
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|UNSPEC
case|:
case|case
name|UNSPEC_VOLATILE
case|:
block|{
name|int
name|j
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"unspec%s(%d"
argument_list|,
operator|(
name|code
operator|==
name|UNSPEC
operator|)
condition|?
literal|""
else|:
literal|"_vol"
argument_list|,
name|XINT
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|fputs
argument_list|(
literal|", "
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|ra_print_rtx
argument_list|(
name|file
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|fputs
argument_list|(
literal|")"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SET
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|PC
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|IF_THEN_ELSE
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|PC
condition|)
block|{
name|fputs
argument_list|(
literal|"if "
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|ra_print_rtx
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|" jump "
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|ra_print_rtx
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fputs
argument_list|(
literal|"jump "
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|ra_print_rtx
argument_list|(
name|file
argument_list|,
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ra_print_rtx
argument_list|(
name|file
argument_list|,
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"<= "
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|ra_print_rtx
argument_list|(
name|file
argument_list|,
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|USE
case|:
name|fputs
argument_list|(
literal|"use<= "
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|ra_print_rtx
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|CLOBBER
case|:
name|ra_print_rtx
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"<= clobber"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|CALL
case|:
name|fputs
argument_list|(
literal|"call "
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|ra_print_rtx
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Address */
name|fputs
argument_list|(
literal|" numargs="
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|ra_print_rtx
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Num arguments */
break|break;
case|case
name|RETURN
case|:
name|fputs
argument_list|(
literal|"return"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRAP_IF
case|:
name|fputs
argument_list|(
literal|"if ("
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|ra_print_rtx
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|") trap "
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|ra_print_rtx
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|RESX
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"resx from region %d"
argument_list|,
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|/* Different things of class 'x' */
case|case
name|SUBREG
case|:
name|ra_print_rtx_object
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
break|break;
case|case
name|STRICT_LOW_PART
case|:
name|fputs
argument_list|(
literal|"low("
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|ra_print_rtx
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|")"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
default|default:
name|unhandled
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|unhandled
condition|)
return|return;
if|if
condition|(
name|class
operator|==
literal|'1'
condition|)
name|ra_print_rtx_1op
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|class
operator|==
literal|'2'
operator|||
name|class
operator|==
literal|'c'
operator|||
name|class
operator|==
literal|'<'
condition|)
name|ra_print_rtx_2op
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|class
operator|==
literal|'3'
operator|||
name|class
operator|==
literal|'b'
condition|)
name|ra_print_rtx_3op
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|class
operator|==
literal|'o'
condition|)
name|ra_print_rtx_object
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
else|else
name|print_inline_rtx
argument_list|(
name|file
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This only calls ra_print_rtx(), but emits a final newline.  */
end_comment

begin_function
name|void
name|ra_print_rtx_top
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|rtx
name|x
parameter_list|,
name|int
name|with_pn
parameter_list|)
block|{
name|ra_print_rtx
argument_list|(
name|file
argument_list|,
name|x
argument_list|,
name|with_pn
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Callable from gdb.  This prints rtx X onto stderr.  */
end_comment

begin_function
name|void
name|ra_debug_rtx
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|ra_print_rtx_top
argument_list|(
name|stderr
argument_list|,
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This prints the content of basic block with index BBI.    The first and last insn are emitted with UIDs of prev and next insns.  */
end_comment

begin_function
name|void
name|ra_debug_bbi
parameter_list|(
name|int
name|bbi
parameter_list|)
block|{
name|basic_block
name|bb
init|=
name|BASIC_BLOCK
argument_list|(
name|bbi
argument_list|)
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|ra_print_rtx_top
argument_list|(
name|stderr
argument_list|,
name|insn
argument_list|,
operator|(
name|insn
operator|==
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
operator|||
name|insn
operator|==
name|BB_END
argument_list|(
name|bb
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|BB_END
argument_list|(
name|bb
argument_list|)
condition|)
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Beginning from INSN, emit NUM insns (if NUM is non-negative)    or emit a window of NUM insns around INSN, to stderr.  */
end_comment

begin_function
name|void
name|ra_debug_insns
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|int
name|num
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|count
init|=
operator|(
name|num
operator|==
literal|0
condition|?
literal|1
else|:
name|num
operator|<
literal|0
condition|?
operator|-
name|num
else|:
name|num
operator|)
decl_stmt|;
if|if
condition|(
name|num
operator|<
literal|0
condition|)
for|for
control|(
name|i
operator|=
name|count
operator|/
literal|2
init|;
name|i
operator|>
literal|0
operator|&&
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
condition|;
name|i
operator|--
control|)
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|count
init|;
name|i
operator|>
literal|0
operator|&&
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|,
name|i
operator|--
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|ra_print_rtx_top
argument_list|(
name|stderr
argument_list|,
name|insn
argument_list|,
operator|(
name|i
operator|==
name|count
operator|||
name|i
operator|==
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Beginning with INSN, emit the whole insn chain into FILE.    This also outputs comments when basic blocks start or end and omits    some notes, if flag_ra_dump_notes is zero.  */
end_comment

begin_function
name|void
name|ra_print_rtl_with_bb
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|basic_block
name|last_bb
decl_stmt|,
name|bb
decl_stmt|;
name|unsigned
name|int
name|num
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|insn
condition|)
name|fputs
argument_list|(
literal|"nil"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|last_bb
operator|=
name|NULL
expr_stmt|;
for|for
control|(
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|BARRIER
condition|)
name|bb
operator|=
name|NULL
expr_stmt|;
else|else
name|bb
operator|=
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb
operator|!=
name|last_bb
condition|)
block|{
if|if
condition|(
name|last_bb
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";; End of basic block %d\n"
argument_list|,
name|last_bb
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";; Begin of basic block %d\n"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|last_bb
operator|=
name|bb
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
block|{
comment|/* Ignore basic block and maybe other notes not referencing 	     deleted things.  */
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_BASIC_BLOCK
operator|&&
operator|(
name|flag_ra_dump_notes
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_DELETED
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_DELETED_LABEL
operator|)
condition|)
block|{
name|ra_print_rtx_top
argument_list|(
name|file
argument_list|,
name|insn
argument_list|,
operator|(
name|num
operator|==
literal|0
operator|||
operator|!
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|num
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|ra_print_rtx_top
argument_list|(
name|file
argument_list|,
name|insn
argument_list|,
operator|(
name|num
operator|==
literal|0
operator|||
operator|!
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|num
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Count how many insns were seen how often, while building the interference    graph, and prints the findings.  */
end_comment

begin_function
name|void
name|dump_number_seen
parameter_list|(
name|void
parameter_list|)
block|{
define|#
directive|define
name|N
value|17
name|int
name|num
index|[
name|N
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N
condition|;
name|i
operator|++
control|)
name|num
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|get_max_uid
argument_list|()
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|number_seen
index|[
name|i
index|]
operator|<
name|N
operator|-
literal|1
condition|)
name|num
index|[
name|number_seen
index|[
name|i
index|]
index|]
operator|++
expr_stmt|;
else|else
name|num
index|[
name|N
operator|-
literal|1
index|]
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N
operator|-
literal|1
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|num
index|[
name|i
index|]
condition|)
name|ra_debug_msg
argument_list|(
name|DUMP_PROCESS
argument_list|,
literal|"%d insns seen %d times\n"
argument_list|,
name|num
index|[
name|i
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|num
index|[
name|N
operator|-
literal|1
index|]
condition|)
name|ra_debug_msg
argument_list|(
name|DUMP_PROCESS
argument_list|,
literal|"%d insns seen %d and more times\n"
argument_list|,
name|num
index|[
name|i
index|]
argument_list|,
name|N
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ra_debug_msg
argument_list|(
name|DUMP_PROCESS
argument_list|,
literal|"from overall %d insns\n"
argument_list|,
name|get_max_uid
argument_list|()
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|N
block|}
end_function

begin_comment
comment|/* Dump the interference graph, the move list and the webs.  */
end_comment

begin_function
name|void
name|dump_igraph
parameter_list|(
name|struct
name|df
modifier|*
name|df
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|struct
name|move_list
modifier|*
name|ml
decl_stmt|;
name|unsigned
name|int
name|def1
decl_stmt|,
name|def2
decl_stmt|;
name|int
name|num
init|=
literal|0
decl_stmt|;
name|int
name|num2
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|rtl_dump_file
operator|||
operator|(
name|debug_new_regalloc
operator|&
operator|(
name|DUMP_IGRAPH
operator||
name|DUMP_WEBS
operator|)
operator|)
operator|==
literal|0
condition|)
return|return;
name|ra_debug_msg
argument_list|(
name|DUMP_IGRAPH
argument_list|,
literal|"conflicts:\n  "
argument_list|)
expr_stmt|;
for|for
control|(
name|def1
operator|=
literal|0
init|;
name|def1
operator|<
name|num_webs
condition|;
name|def1
operator|++
control|)
block|{
name|int
name|num1
init|=
name|num
decl_stmt|;
name|num2
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|def2
operator|=
literal|0
init|;
name|def2
operator|<
name|num_webs
condition|;
name|def2
operator|++
control|)
if|if
condition|(
name|def1
operator|!=
name|def2
operator|&&
name|TEST_BIT
argument_list|(
name|igraph
argument_list|,
name|igraph_index
argument_list|(
name|def1
argument_list|,
name|def2
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|num1
operator|==
name|num
condition|)
block|{
if|if
condition|(
name|SUBWEB_P
argument_list|(
name|ID2WEB
argument_list|(
name|def1
argument_list|)
argument_list|)
condition|)
name|ra_debug_msg
argument_list|(
name|DUMP_IGRAPH
argument_list|,
literal|"%d (SUBREG %d, %d) with "
argument_list|,
name|def1
argument_list|,
name|ID2WEB
argument_list|(
name|def1
argument_list|)
operator|->
name|regno
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|ID2WEB
argument_list|(
name|def1
argument_list|)
operator|->
name|orig_x
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|ra_debug_msg
argument_list|(
name|DUMP_IGRAPH
argument_list|,
literal|"%d (REG %d) with "
argument_list|,
name|def1
argument_list|,
name|ID2WEB
argument_list|(
name|def1
argument_list|)
operator|->
name|regno
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|num2
operator|%
literal|9
operator|)
operator|==
literal|8
condition|)
name|ra_debug_msg
argument_list|(
name|DUMP_IGRAPH
argument_list|,
literal|"\n              "
argument_list|)
expr_stmt|;
name|num
operator|++
expr_stmt|;
name|num2
operator|++
expr_stmt|;
if|if
condition|(
name|SUBWEB_P
argument_list|(
name|ID2WEB
argument_list|(
name|def2
argument_list|)
argument_list|)
condition|)
name|ra_debug_msg
argument_list|(
name|DUMP_IGRAPH
argument_list|,
literal|"%d(%d,%d) "
argument_list|,
name|def2
argument_list|,
name|ID2WEB
argument_list|(
name|def2
argument_list|)
operator|->
name|regno
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|ID2WEB
argument_list|(
name|def2
argument_list|)
operator|->
name|orig_x
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|ra_debug_msg
argument_list|(
name|DUMP_IGRAPH
argument_list|,
literal|"%d(%d) "
argument_list|,
name|def2
argument_list|,
name|ID2WEB
argument_list|(
name|def2
argument_list|)
operator|->
name|regno
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|num1
operator|!=
name|num
condition|)
name|ra_debug_msg
argument_list|(
name|DUMP_IGRAPH
argument_list|,
literal|"\n  "
argument_list|)
expr_stmt|;
block|}
name|ra_debug_msg
argument_list|(
name|DUMP_IGRAPH
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|ml
operator|=
name|wl_moves
init|;
name|ml
condition|;
name|ml
operator|=
name|ml
operator|->
name|next
control|)
if|if
condition|(
name|ml
operator|->
name|move
condition|)
block|{
name|ra_debug_msg
argument_list|(
name|DUMP_IGRAPH
argument_list|,
literal|"move: insn %d: Web %d<-- Web %d\n"
argument_list|,
name|INSN_UID
argument_list|(
name|ml
operator|->
name|move
operator|->
name|insn
argument_list|)
argument_list|,
name|ml
operator|->
name|move
operator|->
name|target_web
operator|->
name|id
argument_list|,
name|ml
operator|->
name|move
operator|->
name|source_web
operator|->
name|id
argument_list|)
expr_stmt|;
block|}
name|ra_debug_msg
argument_list|(
name|DUMP_WEBS
argument_list|,
literal|"\nWebs:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_webs
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|web
modifier|*
name|web
init|=
name|ID2WEB
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|ra_debug_msg
argument_list|(
name|DUMP_WEBS
argument_list|,
literal|"  %4d : regno %3d"
argument_list|,
name|i
argument_list|,
name|web
operator|->
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|SUBWEB_P
argument_list|(
name|web
argument_list|)
condition|)
block|{
name|ra_debug_msg
argument_list|(
name|DUMP_WEBS
argument_list|,
literal|" sub %d"
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|web
operator|->
name|orig_x
argument_list|)
argument_list|)
expr_stmt|;
name|ra_debug_msg
argument_list|(
name|DUMP_WEBS
argument_list|,
literal|" par %d"
argument_list|,
name|find_web_for_subweb
argument_list|(
name|web
argument_list|)
operator|->
name|id
argument_list|)
expr_stmt|;
block|}
name|ra_debug_msg
argument_list|(
name|DUMP_WEBS
argument_list|,
literal|" +%d (span %d, cost "
name|HOST_WIDE_INT_PRINT_DEC
literal|") (%s)"
argument_list|,
name|web
operator|->
name|add_hardregs
argument_list|,
name|web
operator|->
name|span_deaths
argument_list|,
name|web
operator|->
name|spill_cost
argument_list|,
name|reg_class_names
index|[
name|web
operator|->
name|regclass
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|web
operator|->
name|spill_temp
operator|==
literal|1
condition|)
name|ra_debug_msg
argument_list|(
name|DUMP_WEBS
argument_list|,
literal|" (spilltemp)"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|web
operator|->
name|spill_temp
operator|==
literal|2
condition|)
name|ra_debug_msg
argument_list|(
name|DUMP_WEBS
argument_list|,
literal|" (spilltem2)"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|web
operator|->
name|spill_temp
operator|==
literal|3
condition|)
name|ra_debug_msg
argument_list|(
name|DUMP_WEBS
argument_list|,
literal|" (short)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|web
operator|->
name|type
operator|==
name|PRECOLORED
condition|)
name|ra_debug_msg
argument_list|(
name|DUMP_WEBS
argument_list|,
literal|" (precolored, color=%d)"
argument_list|,
name|web
operator|->
name|color
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|find_web_for_subweb
argument_list|(
name|web
argument_list|)
operator|->
name|num_uses
operator|==
literal|0
condition|)
name|ra_debug_msg
argument_list|(
name|DUMP_WEBS
argument_list|,
literal|" dead"
argument_list|)
expr_stmt|;
if|if
condition|(
name|web
operator|->
name|crosses_call
condition|)
name|ra_debug_msg
argument_list|(
name|DUMP_WEBS
argument_list|,
literal|" xcall"
argument_list|)
expr_stmt|;
if|if
condition|(
name|web
operator|->
name|regno
operator|>=
name|max_normal_pseudo
condition|)
name|ra_debug_msg
argument_list|(
name|DUMP_WEBS
argument_list|,
literal|" stack"
argument_list|)
expr_stmt|;
name|ra_debug_msg
argument_list|(
name|DUMP_WEBS
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Dump the interference graph and webs in a format easily    parsable by programs.  Used to emit real world interference graph    to my custom graph colorizer.  */
end_comment

begin_function
name|void
name|dump_igraph_machine
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|rtl_dump_file
operator|||
operator|(
name|debug_new_regalloc
operator|&
name|DUMP_IGRAPH_M
operator|)
operator|==
literal|0
condition|)
return|return;
name|ra_debug_msg
argument_list|(
name|DUMP_IGRAPH_M
argument_list|,
literal|"g %d %d\n"
argument_list|,
name|num_webs
operator|-
name|num_subwebs
argument_list|,
name|FIRST_PSEUDO_REGISTER
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_webs
operator|-
name|num_subwebs
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|web
modifier|*
name|web
init|=
name|ID2WEB
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|struct
name|conflict_link
modifier|*
name|cl
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
name|int
name|numc
init|=
literal|0
decl_stmt|;
name|int
name|col
init|=
literal|0
decl_stmt|;
name|flags
operator|=
name|web
operator|->
name|spill_temp
operator|&
literal|0xF
expr_stmt|;
name|flags
operator||=
operator|(
operator|(
name|web
operator|->
name|type
operator|==
name|PRECOLORED
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
operator|<<
literal|4
expr_stmt|;
name|flags
operator||=
operator|(
name|web
operator|->
name|add_hardregs
operator|&
literal|0xF
operator|)
operator|<<
literal|5
expr_stmt|;
for|for
control|(
name|cl
operator|=
name|web
operator|->
name|conflict_list
init|;
name|cl
condition|;
name|cl
operator|=
name|cl
operator|->
name|next
control|)
if|if
condition|(
name|cl
operator|->
name|t
operator|->
name|id
operator|<
name|web
operator|->
name|id
condition|)
name|numc
operator|++
expr_stmt|;
name|ra_debug_msg
argument_list|(
name|DUMP_IGRAPH_M
argument_list|,
literal|"n %d %d %d %d %d %d %d\n"
argument_list|,
name|web
operator|->
name|id
argument_list|,
name|web
operator|->
name|color
argument_list|,
name|flags
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|web
operator|->
name|spill_cost
argument_list|,
name|web
operator|->
name|num_defs
argument_list|,
name|web
operator|->
name|num_uses
argument_list|,
name|numc
argument_list|)
expr_stmt|;
if|if
condition|(
name|web
operator|->
name|type
operator|!=
name|PRECOLORED
condition|)
block|{
name|ra_debug_msg
argument_list|(
name|DUMP_IGRAPH_M
argument_list|,
literal|"s %d"
argument_list|,
name|web
operator|->
name|id
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|unsigned
name|int
name|u
init|=
literal|0
decl_stmt|;
name|int
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|32
operator|&&
name|col
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|n
operator|++
operator|,
name|col
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|web
operator|->
name|usable_regs
argument_list|,
name|col
argument_list|)
condition|)
name|u
operator||=
literal|1
operator|<<
name|n
expr_stmt|;
name|ra_debug_msg
argument_list|(
name|DUMP_IGRAPH_M
argument_list|,
literal|" %u"
argument_list|,
name|u
argument_list|)
expr_stmt|;
if|if
condition|(
name|col
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
break|break;
block|}
name|ra_debug_msg
argument_list|(
name|DUMP_IGRAPH_M
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|numc
condition|)
block|{
name|ra_debug_msg
argument_list|(
name|DUMP_IGRAPH_M
argument_list|,
literal|"c %d"
argument_list|,
name|web
operator|->
name|id
argument_list|)
expr_stmt|;
for|for
control|(
name|cl
operator|=
name|web
operator|->
name|conflict_list
init|;
name|cl
condition|;
name|cl
operator|=
name|cl
operator|->
name|next
control|)
block|{
if|if
condition|(
name|cl
operator|->
name|t
operator|->
name|id
operator|<
name|web
operator|->
name|id
condition|)
name|ra_debug_msg
argument_list|(
name|DUMP_IGRAPH_M
argument_list|,
literal|" %d"
argument_list|,
name|cl
operator|->
name|t
operator|->
name|id
argument_list|)
expr_stmt|;
block|}
name|ra_debug_msg
argument_list|(
name|DUMP_IGRAPH_M
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|ra_debug_msg
argument_list|(
name|DUMP_IGRAPH_M
argument_list|,
literal|"e\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This runs after colorization and changing the insn stream.    It temporarily replaces all pseudo registers with their colors,    and emits information, if the resulting insns are strictly valid.  */
end_comment

begin_function
name|void
name|dump_constraints
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|rtl_dump_file
operator|||
operator|(
name|debug_new_regalloc
operator|&
name|DUMP_CONSTRAINTS
operator|)
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|ra_max_regno
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regno_reg_rtx
index|[
name|i
index|]
operator|&&
name|GET_CODE
argument_list|(
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|)
operator|==
name|REG
condition|)
name|REGNO
argument_list|(
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|)
operator|=
name|ra_reg_renumber
index|[
name|i
index|]
operator|>=
literal|0
condition|?
name|ra_reg_renumber
index|[
name|i
index|]
else|:
name|i
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|int
name|code
decl_stmt|;
name|int
name|uid
init|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|o
decl_stmt|;
comment|/* Don't simply force rerecognition, as combine might left us 	   with some unrecognizable ones, which later leads to aborts 	   in regclass, if we now destroy the remembered INSN_CODE().  */
comment|/*INSN_CODE (insn) = -1;*/
name|code
operator|=
name|recog_memoized
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
block|{
name|ra_debug_msg
argument_list|(
name|DUMP_CONSTRAINTS
argument_list|,
literal|"%d: asm insn or not recognizable.\n"
argument_list|,
name|uid
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ra_debug_msg
argument_list|(
name|DUMP_CONSTRAINTS
argument_list|,
literal|"%d: code %d {%s}, %d operands, constraints: "
argument_list|,
name|uid
argument_list|,
name|code
argument_list|,
name|insn_data
index|[
name|code
index|]
operator|.
name|name
argument_list|,
name|recog_data
operator|.
name|n_operands
argument_list|)
expr_stmt|;
name|extract_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/*preprocess_constraints ();*/
for|for
control|(
name|o
operator|=
literal|0
init|;
name|o
operator|<
name|recog_data
operator|.
name|n_operands
condition|;
name|o
operator|++
control|)
block|{
name|ra_debug_msg
argument_list|(
name|DUMP_CONSTRAINTS
argument_list|,
literal|"%d:%s "
argument_list|,
name|o
argument_list|,
name|recog_data
operator|.
name|constraints
index|[
name|o
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|constrain_operands
argument_list|(
literal|1
argument_list|)
condition|)
name|ra_debug_msg
argument_list|(
name|DUMP_CONSTRAINTS
argument_list|,
literal|"matches strictly alternative %d"
argument_list|,
name|which_alternative
argument_list|)
expr_stmt|;
else|else
name|ra_debug_msg
argument_list|(
name|DUMP_CONSTRAINTS
argument_list|,
literal|"doesn't match strictly"
argument_list|)
expr_stmt|;
name|ra_debug_msg
argument_list|(
name|DUMP_CONSTRAINTS
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|ra_max_regno
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regno_reg_rtx
index|[
name|i
index|]
operator|&&
name|GET_CODE
argument_list|(
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|)
operator|==
name|REG
condition|)
name|REGNO
argument_list|(
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|)
operator|=
name|i
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This counts and emits the cumulated cost of all spilled webs,    preceded by a custom message MSG, with debug level LEVEL.  */
end_comment

begin_function
name|void
name|dump_graph_cost
parameter_list|(
name|unsigned
name|int
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|cost
decl_stmt|;
if|if
condition|(
operator|!
name|rtl_dump_file
operator|||
operator|(
name|debug_new_regalloc
operator|&
name|level
operator|)
operator|==
literal|0
condition|)
return|return;
name|cost
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_webs
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|web
modifier|*
name|web
init|=
name|id2web
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|alias
argument_list|(
name|web
argument_list|)
operator|->
name|type
operator|==
name|SPILLED
condition|)
name|cost
operator|+=
name|web
operator|->
name|orig_spill_cost
expr_stmt|;
block|}
name|ra_debug_msg
argument_list|(
name|level
argument_list|,
literal|" spill cost of graph (%s) = "
name|HOST_WIDE_INT_PRINT_UNSIGNED
literal|"\n"
argument_list|,
name|msg
condition|?
name|msg
else|:
literal|""
argument_list|,
name|cost
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump the color assignment per web, the coalesced and spilled webs.  */
end_comment

begin_function
name|void
name|dump_ra
parameter_list|(
name|struct
name|df
modifier|*
name|df
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|struct
name|web
modifier|*
name|web
decl_stmt|;
name|struct
name|dlist
modifier|*
name|d
decl_stmt|;
if|if
condition|(
operator|!
name|rtl_dump_file
operator|||
operator|(
name|debug_new_regalloc
operator|&
name|DUMP_RESULTS
operator|)
operator|==
literal|0
condition|)
return|return;
name|ra_debug_msg
argument_list|(
name|DUMP_RESULTS
argument_list|,
literal|"\nColored:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
name|WEBS
argument_list|(
name|COLORED
argument_list|)
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
name|web
operator|=
name|DLIST_WEB
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|ra_debug_msg
argument_list|(
name|DUMP_RESULTS
argument_list|,
literal|"  %4d : color %d\n"
argument_list|,
name|web
operator|->
name|id
argument_list|,
name|web
operator|->
name|color
argument_list|)
expr_stmt|;
block|}
name|ra_debug_msg
argument_list|(
name|DUMP_RESULTS
argument_list|,
literal|"\nCoalesced:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
name|WEBS
argument_list|(
name|COALESCED
argument_list|)
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
name|web
operator|=
name|DLIST_WEB
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|ra_debug_msg
argument_list|(
name|DUMP_RESULTS
argument_list|,
literal|"  %4d : to web %d, color %d\n"
argument_list|,
name|web
operator|->
name|id
argument_list|,
name|alias
argument_list|(
name|web
argument_list|)
operator|->
name|id
argument_list|,
name|web
operator|->
name|color
argument_list|)
expr_stmt|;
block|}
name|ra_debug_msg
argument_list|(
name|DUMP_RESULTS
argument_list|,
literal|"\nSpilled:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
name|WEBS
argument_list|(
name|SPILLED
argument_list|)
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
name|web
operator|=
name|DLIST_WEB
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|ra_debug_msg
argument_list|(
name|DUMP_RESULTS
argument_list|,
literal|"  %4d\n"
argument_list|,
name|web
operator|->
name|id
argument_list|)
expr_stmt|;
block|}
name|ra_debug_msg
argument_list|(
name|DUMP_RESULTS
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|dump_cost
argument_list|(
name|DUMP_RESULTS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Calculate and dump the cumulated costs of certain types of insns    (loads, stores and copies).  */
end_comment

begin_function
name|void
name|dump_static_insn_cost
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
specifier|const
name|char
modifier|*
name|message
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
struct|struct
name|cost
block|{
name|unsigned
name|HOST_WIDE_INT
name|cost
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
block|}
struct|;
name|basic_block
name|bb
decl_stmt|;
name|struct
name|cost
name|load
decl_stmt|,
name|store
decl_stmt|,
name|regcopy
decl_stmt|,
name|selfcopy
decl_stmt|,
name|overall
decl_stmt|;
name|memset
argument_list|(
operator|&
name|load
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|load
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|store
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|store
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|regcopy
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|regcopy
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|selfcopy
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|selfcopy
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|overall
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|overall
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file
condition|)
return|return;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|block_cost
init|=
name|bb
operator|->
name|frequency
decl_stmt|;
name|rtx
name|insn
decl_stmt|,
name|set
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
comment|/* Yes, yes.  We don't calculate the costs precisely. 	     Only for "simple enough" insns.  Those containing single 	     sets only.  */
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
operator|(
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
condition|)
block|{
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
decl_stmt|;
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
decl_stmt|;
name|struct
name|cost
modifier|*
name|pcost
init|=
name|NULL
decl_stmt|;
name|overall
operator|.
name|cost
operator|+=
name|block_cost
expr_stmt|;
name|overall
operator|.
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|src
argument_list|,
name|dest
argument_list|)
condition|)
name|pcost
operator|=
operator|&
name|selfcopy
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|REG
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|src
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
operator|)
condition|)
name|pcost
operator|=
operator|&
name|regcopy
expr_stmt|;
else|else
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|SUBREG
condition|)
name|src
operator|=
name|SUBREG_REG
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
condition|)
name|dest
operator|=
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|!=
name|MEM
operator|&&
name|memref_is_stack_slot
argument_list|(
name|src
argument_list|)
condition|)
name|pcost
operator|=
operator|&
name|load
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|!=
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
operator|&&
name|memref_is_stack_slot
argument_list|(
name|dest
argument_list|)
condition|)
name|pcost
operator|=
operator|&
name|store
expr_stmt|;
block|}
if|if
condition|(
name|pcost
condition|)
block|{
name|pcost
operator|->
name|cost
operator|+=
name|block_cost
expr_stmt|;
name|pcost
operator|->
name|count
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|insn
operator|==
name|BB_END
argument_list|(
name|bb
argument_list|)
condition|)
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|prefix
condition|)
name|prefix
operator|=
literal|""
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"static insn cost %s\n"
argument_list|,
name|message
condition|?
name|message
else|:
literal|""
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"  %soverall:\tnum=%6d\tcost=% 8"
name|HOST_WIDE_INT_PRINT
literal|"d\n"
argument_list|,
name|prefix
argument_list|,
name|overall
operator|.
name|count
argument_list|,
name|overall
operator|.
name|cost
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"  %sloads:\tnum=%6d\tcost=% 8"
name|HOST_WIDE_INT_PRINT
literal|"d\n"
argument_list|,
name|prefix
argument_list|,
name|load
operator|.
name|count
argument_list|,
name|load
operator|.
name|cost
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"  %sstores:\tnum=%6d\tcost=% 8"
name|HOST_WIDE_INT_PRINT
literal|"d\n"
argument_list|,
name|prefix
argument_list|,
name|store
operator|.
name|count
argument_list|,
name|store
operator|.
name|cost
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"  %sregcopy:\tnum=%6d\tcost=% 8"
name|HOST_WIDE_INT_PRINT
literal|"d\n"
argument_list|,
name|prefix
argument_list|,
name|regcopy
operator|.
name|count
argument_list|,
name|regcopy
operator|.
name|cost
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"  %sselfcpy:\tnum=%6d\tcost=% 8"
name|HOST_WIDE_INT_PRINT
literal|"d\n"
argument_list|,
name|prefix
argument_list|,
name|selfcopy
operator|.
name|count
argument_list|,
name|selfcopy
operator|.
name|cost
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns nonzero, if WEB1 and WEB2 have some possible    hardregs in common.  */
end_comment

begin_function
name|int
name|web_conflicts_p
parameter_list|(
name|struct
name|web
modifier|*
name|web1
parameter_list|,
name|struct
name|web
modifier|*
name|web2
parameter_list|)
block|{
if|if
condition|(
name|web1
operator|->
name|type
operator|==
name|PRECOLORED
operator|&&
name|web2
operator|->
name|type
operator|==
name|PRECOLORED
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|web1
operator|->
name|type
operator|==
name|PRECOLORED
condition|)
return|return
name|TEST_HARD_REG_BIT
argument_list|(
name|web2
operator|->
name|usable_regs
argument_list|,
name|web1
operator|->
name|regno
argument_list|)
return|;
if|if
condition|(
name|web2
operator|->
name|type
operator|==
name|PRECOLORED
condition|)
return|return
name|TEST_HARD_REG_BIT
argument_list|(
name|web1
operator|->
name|usable_regs
argument_list|,
name|web2
operator|->
name|regno
argument_list|)
return|;
return|return
name|hard_regs_intersect_p
argument_list|(
operator|&
name|web1
operator|->
name|usable_regs
argument_list|,
operator|&
name|web2
operator|->
name|usable_regs
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Dump all uids of insns in which WEB is mentioned.  */
end_comment

begin_function
name|void
name|dump_web_insns
parameter_list|(
name|struct
name|web
modifier|*
name|web
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|ra_debug_msg
argument_list|(
name|DUMP_EVER
argument_list|,
literal|"Web: %i(%i)+%i class: %s freedom: %i degree %i\n"
argument_list|,
name|web
operator|->
name|id
argument_list|,
name|web
operator|->
name|regno
argument_list|,
name|web
operator|->
name|add_hardregs
argument_list|,
name|reg_class_names
index|[
name|web
operator|->
name|regclass
index|]
argument_list|,
name|web
operator|->
name|num_freedom
argument_list|,
name|web
operator|->
name|num_conflicts
argument_list|)
expr_stmt|;
name|ra_debug_msg
argument_list|(
name|DUMP_EVER
argument_list|,
literal|"   def insns:"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|web
operator|->
name|num_defs
condition|;
operator|++
name|i
control|)
block|{
name|ra_debug_msg
argument_list|(
name|DUMP_EVER
argument_list|,
literal|" %d "
argument_list|,
name|INSN_UID
argument_list|(
name|web
operator|->
name|defs
index|[
name|i
index|]
operator|->
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ra_debug_msg
argument_list|(
name|DUMP_EVER
argument_list|,
literal|"\n   use insns:"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|web
operator|->
name|num_uses
condition|;
operator|++
name|i
control|)
block|{
name|ra_debug_msg
argument_list|(
name|DUMP_EVER
argument_list|,
literal|" %d "
argument_list|,
name|INSN_UID
argument_list|(
name|web
operator|->
name|uses
index|[
name|i
index|]
operator|->
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ra_debug_msg
argument_list|(
name|DUMP_EVER
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump conflicts for web WEB.  */
end_comment

begin_function
name|void
name|dump_web_conflicts
parameter_list|(
name|struct
name|web
modifier|*
name|web
parameter_list|)
block|{
name|int
name|num
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|def2
decl_stmt|;
name|ra_debug_msg
argument_list|(
name|DUMP_EVER
argument_list|,
literal|"Web: %i(%i)+%i class: %s freedom: %i degree %i\n"
argument_list|,
name|web
operator|->
name|id
argument_list|,
name|web
operator|->
name|regno
argument_list|,
name|web
operator|->
name|add_hardregs
argument_list|,
name|reg_class_names
index|[
name|web
operator|->
name|regclass
index|]
argument_list|,
name|web
operator|->
name|num_freedom
argument_list|,
name|web
operator|->
name|num_conflicts
argument_list|)
expr_stmt|;
for|for
control|(
name|def2
operator|=
literal|0
init|;
name|def2
operator|<
name|num_webs
condition|;
name|def2
operator|++
control|)
if|if
condition|(
name|TEST_BIT
argument_list|(
name|igraph
argument_list|,
name|igraph_index
argument_list|(
name|web
operator|->
name|id
argument_list|,
name|def2
argument_list|)
argument_list|)
operator|&&
name|web
operator|->
name|id
operator|!=
name|def2
condition|)
block|{
if|if
condition|(
operator|(
name|num
operator|%
literal|9
operator|)
operator|==
literal|5
condition|)
name|ra_debug_msg
argument_list|(
name|DUMP_EVER
argument_list|,
literal|"\n             "
argument_list|)
expr_stmt|;
name|num
operator|++
expr_stmt|;
name|ra_debug_msg
argument_list|(
name|DUMP_EVER
argument_list|,
literal|" %d(%d)"
argument_list|,
name|def2
argument_list|,
name|id2web
index|[
name|def2
index|]
operator|->
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|id2web
index|[
name|def2
index|]
operator|->
name|add_hardregs
condition|)
name|ra_debug_msg
argument_list|(
name|DUMP_EVER
argument_list|,
literal|"+%d"
argument_list|,
name|id2web
index|[
name|def2
index|]
operator|->
name|add_hardregs
argument_list|)
expr_stmt|;
if|if
condition|(
name|web_conflicts_p
argument_list|(
name|web
argument_list|,
name|id2web
index|[
name|def2
index|]
argument_list|)
condition|)
name|ra_debug_msg
argument_list|(
name|DUMP_EVER
argument_list|,
literal|"/x"
argument_list|)
expr_stmt|;
if|if
condition|(
name|id2web
index|[
name|def2
index|]
operator|->
name|type
operator|==
name|SELECT
condition|)
name|ra_debug_msg
argument_list|(
name|DUMP_EVER
argument_list|,
literal|"/s"
argument_list|)
expr_stmt|;
if|if
condition|(
name|id2web
index|[
name|def2
index|]
operator|->
name|type
operator|==
name|COALESCED
condition|)
name|ra_debug_msg
argument_list|(
name|DUMP_EVER
argument_list|,
literal|"/c/%d"
argument_list|,
name|alias
argument_list|(
name|id2web
index|[
name|def2
index|]
argument_list|)
operator|->
name|id
argument_list|)
expr_stmt|;
block|}
name|ra_debug_msg
argument_list|(
name|DUMP_EVER
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|{
name|struct
name|conflict_link
modifier|*
name|wl
decl_stmt|;
name|num
operator|=
literal|0
expr_stmt|;
name|ra_debug_msg
argument_list|(
name|DUMP_EVER
argument_list|,
literal|"By conflicts:     "
argument_list|)
expr_stmt|;
for|for
control|(
name|wl
operator|=
name|web
operator|->
name|conflict_list
init|;
name|wl
condition|;
name|wl
operator|=
name|wl
operator|->
name|next
control|)
block|{
name|struct
name|web
modifier|*
name|w
init|=
name|wl
operator|->
name|t
decl_stmt|;
if|if
condition|(
operator|(
name|num
operator|%
literal|9
operator|)
operator|==
literal|8
condition|)
name|ra_debug_msg
argument_list|(
name|DUMP_EVER
argument_list|,
literal|"\n              "
argument_list|)
expr_stmt|;
name|num
operator|++
expr_stmt|;
name|ra_debug_msg
argument_list|(
name|DUMP_EVER
argument_list|,
literal|"%d(%d)%s "
argument_list|,
name|w
operator|->
name|id
argument_list|,
name|w
operator|->
name|regno
argument_list|,
name|web_conflicts_p
argument_list|(
name|web
argument_list|,
name|w
argument_list|)
condition|?
literal|"+"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
name|ra_debug_msg
argument_list|(
name|DUMP_EVER
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output HARD_REG_SET to stderr.  */
end_comment

begin_function
name|void
name|debug_hard_reg_set
parameter_list|(
name|HARD_REG_SET
name|set
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|set
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s "
argument_list|,
name|reg_names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* vim:cinoptions={.5s,g0,p5,t0,(0,^-0.5s,n-0.5s:tw=78:cindent:sw=4: */
end_comment

end_unit

