begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Control flow optimization code for GNU compiler.    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* Try to match two basic blocks - or their ends - for structural equivalence.    We scan the blocks from their ends backwards, and expect that insns are    identical, except for certain cases involving registers.  A mismatch    We scan the blocks from their ends backwards, hoping to find a match, I.e.    insns are identical, except for certain cases involving registers.  A    mismatch between register number RX (used in block X) and RY (used in the    same way in block Y) can be handled in one of the following cases:    1. RX and RY are local to their respective blocks; they are set there and       die there.  If so, they can effectively be ignored.    2. RX and RY die in their blocks, but live at the start.  If any path       gets redirected through X instead of Y, the caller must emit       compensation code to move RY to RX.  If there are overlapping inputs,       the function resolve_input_conflict ensures that this can be done.       Information about these registers are tracked in the X_LOCAL, Y_LOCAL,       LOCAL_COUNT and LOCAL_RVALUE fields.    3. RX and RY live throughout their blocks, including the start and the end.       Either RX and RY must be identical, or we have to replace all uses in       block X with a new pseudo, which is stored in the INPUT_REG field.  The       caller can then use block X instead of block Y by copying RY to the new       pseudo.     The main entry point to this file is struct_equiv_block_eq.  This function    uses a struct equiv_info to accept some of its inputs, to keep track of its    internal state, to pass down to its helper functions, and to communicate    some of the results back to the caller.     Most scans will result in a failure to match a sufficient number of insns    to make any optimization worth while, therefore the process is geared more    to quick scanning rather than the ability to exactly backtrack when we    find a mismatch.  The information gathered is still meaningful to make a    preliminary decision if we want to do an optimization, we might only    slightly overestimate the number of matchable insns, and underestimate    the number of inputs an miss an input conflict.  Sufficient information    is gathered so that when we make another pass, we won't have to backtrack    at the same point.    Another issue is that information in memory attributes and/or REG_NOTES    might have to be merged or discarded to make a valid match.  We don't want    to discard such information when we are not certain that we want to merge    the two (partial) blocks.    For these reasons, struct_equiv_block_eq has to be called first with the    STRUCT_EQUIV_START bit set in the mode parameter.  This will calculate the    number of matched insns and the number and types of inputs.  If the    need_rerun field is set, the results are only tentative, and the caller    has to call again with STRUCT_EQUIV_RERUN till need_rerun is false in    order to get a reliable match.    To install the changes necessary for the match, the function has to be    called again with STRUCT_EQUIV_FINAL.     While scanning an insn, we process first all the SET_DESTs, then the    SET_SRCes, then the REG_NOTES, in order to keep the register liveness    information consistent.    If we were to mix up the order for sources / destinations in an insn where    a source is also a destination, we'd end up being mistaken to think that    the register is not live in the preceding insn.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"emit-rtl.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_function_decl
specifier|static
name|void
name|merge_memattrs
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|set_dest_equiv_p
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|y
parameter_list|,
name|struct
name|equiv_info
modifier|*
name|info
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|set_dest_addr_equiv_p
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|y
parameter_list|,
name|struct
name|equiv_info
modifier|*
name|info
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|find_dying_inputs
parameter_list|(
name|struct
name|equiv_info
modifier|*
name|info
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|resolve_input_conflict
parameter_list|(
name|struct
name|equiv_info
modifier|*
name|info
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* After reload, some moves, as indicated by SECONDARY_RELOAD_CLASS and    SECONDARY_MEMORY_NEEDED, cannot be done directly.  For our purposes, we    consider them impossible to generate after reload (even though some    might be synthesized when you throw enough code at them).    Since we don't know while processing a cross-jump if a local register    that is currently live will eventually be live and thus be an input,    we keep track of potential inputs that would require an impossible move    by using a prohibitively high cost for them.    This number, multiplied with the larger of STRUCT_EQUIV_MAX_LOCAL and    FIRST_PSEUDO_REGISTER, must fit in the input_cost field of    struct equiv_info.  */
end_comment

begin_define
define|#
directive|define
name|IMPOSSIBLE_MOVE_FACTOR
value|20000
end_define

begin_escape
end_escape

begin_comment
comment|/* Removes the memory attributes of MEM expression    if they are not equal.  */
end_comment

begin_function
name|void
name|merge_memattrs
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|y
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
name|y
condition|)
return|return;
if|if
condition|(
name|x
operator|==
literal|0
operator|||
name|y
operator|==
literal|0
condition|)
return|return;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|GET_CODE
argument_list|(
name|y
argument_list|)
condition|)
return|return;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|y
argument_list|)
condition|)
return|return;
if|if
condition|(
name|code
operator|==
name|MEM
operator|&&
name|MEM_ATTRS
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM_ATTRS
argument_list|(
name|y
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|MEM_ATTRS
argument_list|(
name|x
argument_list|)
condition|)
name|MEM_ATTRS
argument_list|(
name|y
argument_list|)
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|MEM_ATTRS
argument_list|(
name|y
argument_list|)
condition|)
name|MEM_ATTRS
argument_list|(
name|x
argument_list|)
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|rtx
name|mem_size
decl_stmt|;
if|if
condition|(
name|MEM_ALIAS_SET
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM_ALIAS_SET
argument_list|(
name|y
argument_list|)
condition|)
block|{
name|set_mem_alias_set
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|mem_expr_equal_p
argument_list|(
name|MEM_EXPR
argument_list|(
name|x
argument_list|)
argument_list|,
name|MEM_EXPR
argument_list|(
name|y
argument_list|)
argument_list|)
condition|)
block|{
name|set_mem_expr
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_mem_expr
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_mem_offset
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_mem_offset
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|MEM_OFFSET
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM_OFFSET
argument_list|(
name|y
argument_list|)
condition|)
block|{
name|set_mem_offset
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_mem_offset
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|MEM_SIZE
argument_list|(
name|x
argument_list|)
condition|)
name|mem_size
operator|=
name|NULL_RTX
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|MEM_SIZE
argument_list|(
name|y
argument_list|)
condition|)
name|mem_size
operator|=
name|NULL_RTX
expr_stmt|;
else|else
name|mem_size
operator|=
name|GEN_INT
argument_list|(
name|MAX
argument_list|(
name|INTVAL
argument_list|(
name|MEM_SIZE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|INTVAL
argument_list|(
name|MEM_SIZE
argument_list|(
name|y
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_size
argument_list|(
name|x
argument_list|,
name|mem_size
argument_list|)
expr_stmt|;
name|set_mem_size
argument_list|(
name|y
argument_list|,
name|mem_size
argument_list|)
expr_stmt|;
name|set_mem_align
argument_list|(
name|x
argument_list|,
name|MIN
argument_list|(
name|MEM_ALIGN
argument_list|(
name|x
argument_list|)
argument_list|,
name|MEM_ALIGN
argument_list|(
name|y
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_align
argument_list|(
name|y
argument_list|,
name|MEM_ALIGN
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
switch|switch
condition|(
name|fmt
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'E'
case|:
comment|/* Two vectors must have the same length.  */
if|if
condition|(
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XVECLEN
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|merge_memattrs
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|XVECEXP
argument_list|(
name|y
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|merge_memattrs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/* In SET, assign the bit for the register number of REG the value VALUE.    If REG is a hard register, do so for all its constituent registers.    Return the number of registers that have become included (as a positive    number) or excluded (as a negative number).  */
end_comment

begin_function
specifier|static
name|int
name|assign_reg_reg_set
parameter_list|(
name|regset
name|set
parameter_list|,
name|rtx
name|reg
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|unsigned
name|regno
init|=
name|REGNO
argument_list|(
name|reg
argument_list|)
decl_stmt|;
name|int
name|nregs
decl_stmt|,
name|i
decl_stmt|,
name|old
decl_stmt|;
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|reload_completed
argument_list|)
expr_stmt|;
name|nregs
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|nregs
operator|=
name|hard_regno_nregs
index|[
name|regno
index|]
index|[
name|GET_MODE
argument_list|(
name|reg
argument_list|)
index|]
expr_stmt|;
for|for
control|(
name|old
operator|=
literal|0
operator|,
name|i
operator|=
name|nregs
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|regno
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|value
operator|!=
literal|0
operator|)
operator|==
name|REGNO_REG_SET_P
argument_list|(
name|set
argument_list|,
name|regno
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|value
condition|)
name|old
operator|++
operator|,
name|SET_REGNO_REG_SET
argument_list|(
name|set
argument_list|,
name|regno
argument_list|)
expr_stmt|;
else|else
name|old
operator|--
operator|,
name|CLEAR_REGNO_REG_SET
argument_list|(
name|set
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
return|return
name|old
return|;
block|}
end_function

begin_comment
comment|/* Record state about current inputs / local registers / liveness    in *P.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|struct_equiv_make_checkpoint
parameter_list|(
name|struct
name|struct_equiv_checkpoint
modifier|*
name|p
parameter_list|,
name|struct
name|equiv_info
modifier|*
name|info
parameter_list|)
block|{
operator|*
name|p
operator|=
name|info
operator|->
name|cur
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Call struct_equiv_make_checkpoint (P, INFO) if the current partial block    is suitable to split off - i.e. there is no dangling cc0 user - and    if the current cost of the common instructions, minus the cost for    setting up the inputs, is higher than what has been recorded before    in CHECKPOINT[N].  Also, if we do so, confirm or cancel any pending    changes.  */
end_comment

begin_function
specifier|static
name|void
name|struct_equiv_improve_checkpoint
parameter_list|(
name|struct
name|struct_equiv_checkpoint
modifier|*
name|p
parameter_list|,
name|struct
name|equiv_info
modifier|*
name|info
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_cc0
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|cc0_rtx
argument_list|,
name|info
operator|->
name|cur
operator|.
name|x_start
argument_list|)
operator|&&
operator|!
name|sets_cc0_p
argument_list|(
name|info
operator|->
name|cur
operator|.
name|x_start
argument_list|)
condition|)
return|return;
endif|#
directive|endif
if|if
condition|(
name|info
operator|->
name|cur
operator|.
name|input_count
operator|>=
name|IMPOSSIBLE_MOVE_FACTOR
condition|)
return|return;
if|if
condition|(
name|info
operator|->
name|input_cost
operator|>=
literal|0
condition|?
operator|(
name|COSTS_N_INSNS
argument_list|(
name|info
operator|->
name|cur
operator|.
name|ninsns
operator|-
name|p
operator|->
name|ninsns
argument_list|)
operator|>
name|info
operator|->
name|input_cost
operator|*
operator|(
name|info
operator|->
name|cur
operator|.
name|input_count
operator|-
name|p
operator|->
name|input_count
operator|)
operator|)
else|:
name|info
operator|->
name|cur
operator|.
name|ninsns
operator|>
name|p
operator|->
name|ninsns
operator|&&
operator|!
name|info
operator|->
name|cur
operator|.
name|input_count
condition|)
block|{
if|if
condition|(
name|info
operator|->
name|check_input_conflict
operator|&&
operator|!
name|resolve_input_conflict
argument_list|(
name|info
argument_list|)
condition|)
return|return;
comment|/* We have a profitable set of changes.  If this is the final pass, 	 commit them now.  Otherwise, we don't know yet if we can make any 	 change, so put the old code back for now.  */
if|if
condition|(
name|info
operator|->
name|mode
operator|&
name|STRUCT_EQUIV_FINAL
condition|)
name|confirm_change_group
argument_list|()
expr_stmt|;
else|else
name|cancel_changes
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|struct_equiv_make_checkpoint
argument_list|(
name|p
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Restore state about current inputs / local registers / liveness    from P.  */
end_comment

begin_function
specifier|static
name|void
name|struct_equiv_restore_checkpoint
parameter_list|(
name|struct
name|struct_equiv_checkpoint
modifier|*
name|p
parameter_list|,
name|struct
name|equiv_info
modifier|*
name|info
parameter_list|)
block|{
name|info
operator|->
name|cur
operator|.
name|ninsns
operator|=
name|p
operator|->
name|ninsns
expr_stmt|;
name|info
operator|->
name|cur
operator|.
name|x_start
operator|=
name|p
operator|->
name|x_start
expr_stmt|;
name|info
operator|->
name|cur
operator|.
name|y_start
operator|=
name|p
operator|->
name|y_start
expr_stmt|;
name|info
operator|->
name|cur
operator|.
name|input_count
operator|=
name|p
operator|->
name|input_count
expr_stmt|;
name|info
operator|->
name|cur
operator|.
name|input_valid
operator|=
name|p
operator|->
name|input_valid
expr_stmt|;
while|while
condition|(
name|info
operator|->
name|cur
operator|.
name|local_count
operator|>
name|p
operator|->
name|local_count
condition|)
block|{
name|info
operator|->
name|cur
operator|.
name|local_count
operator|--
expr_stmt|;
name|info
operator|->
name|cur
operator|.
name|version
operator|--
expr_stmt|;
if|if
condition|(
name|REGNO_REG_SET_P
argument_list|(
name|info
operator|->
name|x_local_live
argument_list|,
name|REGNO
argument_list|(
name|info
operator|->
name|x_local
index|[
name|info
operator|->
name|cur
operator|.
name|local_count
index|]
argument_list|)
argument_list|)
condition|)
block|{
name|assign_reg_reg_set
argument_list|(
name|info
operator|->
name|x_local_live
argument_list|,
name|info
operator|->
name|x_local
index|[
name|info
operator|->
name|cur
operator|.
name|local_count
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assign_reg_reg_set
argument_list|(
name|info
operator|->
name|y_local_live
argument_list|,
name|info
operator|->
name|y_local
index|[
name|info
operator|->
name|cur
operator|.
name|local_count
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|info
operator|->
name|cur
operator|.
name|version
operator|--
expr_stmt|;
block|}
block|}
if|if
condition|(
name|info
operator|->
name|cur
operator|.
name|version
operator|!=
name|p
operator|->
name|version
condition|)
name|info
operator|->
name|need_rerun
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Update register liveness to reflect that X is now life (if rvalue is    nonzero) or dead (if rvalue is zero) in INFO->x_block, and likewise Y    in INFO->y_block.  Return the number of registers the liveness of which    changed in each block (as a negative number if registers became dead).  */
end_comment

begin_function
specifier|static
name|int
name|note_local_live
parameter_list|(
name|struct
name|equiv_info
modifier|*
name|info
parameter_list|,
name|rtx
name|x
parameter_list|,
name|rtx
name|y
parameter_list|,
name|int
name|rvalue
parameter_list|)
block|{
name|unsigned
name|x_regno
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|unsigned
name|y_regno
init|=
name|REGNO
argument_list|(
name|y
argument_list|)
decl_stmt|;
name|int
name|x_nominal_nregs
init|=
operator|(
name|x_regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|?
literal|1
else|:
name|hard_regno_nregs
index|[
name|x_regno
index|]
index|[
name|GET_MODE
argument_list|(
name|x
argument_list|)
index|]
operator|)
decl_stmt|;
name|int
name|y_nominal_nregs
init|=
operator|(
name|y_regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|?
literal|1
else|:
name|hard_regno_nregs
index|[
name|y_regno
index|]
index|[
name|GET_MODE
argument_list|(
name|y
argument_list|)
index|]
operator|)
decl_stmt|;
name|int
name|x_change
init|=
name|assign_reg_reg_set
argument_list|(
name|info
operator|->
name|x_local_live
argument_list|,
name|x
argument_list|,
name|rvalue
argument_list|)
decl_stmt|;
name|int
name|y_change
init|=
name|assign_reg_reg_set
argument_list|(
name|info
operator|->
name|y_local_live
argument_list|,
name|y
argument_list|,
name|rvalue
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|x_nominal_nregs
operator|&&
name|y_nominal_nregs
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|x_change
operator|*
name|y_nominal_nregs
operator|==
name|y_change
operator|*
name|x_nominal_nregs
argument_list|)
expr_stmt|;
if|if
condition|(
name|y_change
condition|)
block|{
if|if
condition|(
name|reload_completed
condition|)
block|{
name|unsigned
name|x_regno
name|ATTRIBUTE_UNUSED
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|unsigned
name|y_regno
init|=
name|REGNO
argument_list|(
name|y
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|x_mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|secondary_reload_class
argument_list|(
literal|0
argument_list|,
name|REGNO_REG_CLASS
argument_list|(
name|y_regno
argument_list|)
argument_list|,
name|x_mode
argument_list|,
name|x
argument_list|)
operator|!=
name|NO_REGS
ifdef|#
directive|ifdef
name|SECONDARY_MEMORY_NEEDED
operator|||
name|SECONDARY_MEMORY_NEEDED
argument_list|(
name|REGNO_REG_CLASS
argument_list|(
name|y_regno
argument_list|)
argument_list|,
name|REGNO_REG_CLASS
argument_list|(
name|x_regno
argument_list|)
argument_list|,
name|x_mode
argument_list|)
endif|#
directive|endif
condition|)
name|y_change
operator|*=
name|IMPOSSIBLE_MOVE_FACTOR
expr_stmt|;
block|}
name|info
operator|->
name|cur
operator|.
name|input_count
operator|+=
name|y_change
expr_stmt|;
name|info
operator|->
name|cur
operator|.
name|version
operator|++
expr_stmt|;
block|}
return|return
name|x_change
return|;
block|}
end_function

begin_comment
comment|/* Check if *XP is equivalent to Y.  Until an an unreconcilable difference is    found, use in-group changes with validate_change on *XP to make register    assignments agree.  It is the (not necessarily direct) callers    responsibility to verify / confirm / cancel these changes, as appropriate.    RVALUE indicates if the processed piece of rtl is used as a destination, in    which case we can't have different registers being an input.  Returns    nonzero if the two blocks have been identified as equivalent, zero otherwise.    RVALUE == 0: destination    RVALUE == 1: source    RVALUE == -1: source, ignore SET_DEST of SET / clobber.  */
end_comment

begin_function
name|bool
name|rtx_equiv_p
parameter_list|(
name|rtx
modifier|*
name|xp
parameter_list|,
name|rtx
name|y
parameter_list|,
name|int
name|rvalue
parameter_list|,
name|struct
name|equiv_info
modifier|*
name|info
parameter_list|)
block|{
name|rtx
name|x
init|=
operator|*
name|xp
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|int
name|length
decl_stmt|;
specifier|const
name|char
modifier|*
name|format
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|y
operator|||
operator|!
name|x
condition|)
return|return
name|x
operator|==
name|y
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|REG
operator|&&
name|x
operator|==
name|y
condition|)
return|return
name|true
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|code
operator|||
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|y
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* ??? could extend to allow CONST_INT inputs.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
block|{
name|unsigned
name|x_regno
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|unsigned
name|y_regno
init|=
name|REGNO
argument_list|(
name|y
argument_list|)
decl_stmt|;
name|int
name|x_common_live
decl_stmt|,
name|y_common_live
decl_stmt|;
if|if
condition|(
name|reload_completed
operator|&&
operator|(
name|x_regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
name|y_regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
block|{
comment|/* We should only see this in REG_NOTEs.  */
name|gcc_assert
argument_list|(
operator|!
name|info
operator|->
name|live_update
argument_list|)
expr_stmt|;
comment|/* Returning false will cause us to remove the notes.  */
return|return
name|false
return|;
block|}
ifdef|#
directive|ifdef
name|STACK_REGS
comment|/* After reg-stack, can only accept literal matches of stack regs.  */
if|if
condition|(
name|info
operator|->
name|mode
operator|&
name|CLEANUP_POST_REGSTACK
operator|&&
operator|(
name|IN_RANGE
argument_list|(
name|x_regno
argument_list|,
name|FIRST_STACK_REG
argument_list|,
name|LAST_STACK_REG
argument_list|)
operator|||
name|IN_RANGE
argument_list|(
name|y_regno
argument_list|,
name|FIRST_STACK_REG
argument_list|,
name|LAST_STACK_REG
argument_list|)
operator|)
condition|)
return|return
name|x_regno
operator|==
name|y_regno
return|;
endif|#
directive|endif
comment|/* If the register is a locally live one in one block, the 	   corresponding one must be locally live in the other, too, and 	   match of identical regnos doesn't apply.  */
if|if
condition|(
name|REGNO_REG_SET_P
argument_list|(
name|info
operator|->
name|x_local_live
argument_list|,
name|x_regno
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|REGNO_REG_SET_P
argument_list|(
name|info
operator|->
name|y_local_live
argument_list|,
name|y_regno
argument_list|)
condition|)
return|return
name|false
return|;
block|}
elseif|else
if|if
condition|(
name|REGNO_REG_SET_P
argument_list|(
name|info
operator|->
name|y_local_live
argument_list|,
name|y_regno
argument_list|)
condition|)
return|return
name|false
return|;
elseif|else
if|if
condition|(
name|x_regno
operator|==
name|y_regno
condition|)
block|{
if|if
condition|(
operator|!
name|rvalue
operator|&&
name|info
operator|->
name|cur
operator|.
name|input_valid
operator|&&
operator|(
name|reg_overlap_mentioned_p
argument_list|(
name|x
argument_list|,
name|info
operator|->
name|x_input
argument_list|)
operator|||
name|reg_overlap_mentioned_p
argument_list|(
name|x
argument_list|,
name|info
operator|->
name|y_input
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
comment|/* Update liveness information.  */
if|if
condition|(
name|info
operator|->
name|live_update
operator|&&
name|assign_reg_reg_set
argument_list|(
name|info
operator|->
name|common_live
argument_list|,
name|x
argument_list|,
name|rvalue
argument_list|)
condition|)
name|info
operator|->
name|cur
operator|.
name|version
operator|++
expr_stmt|;
return|return
name|true
return|;
block|}
name|x_common_live
operator|=
name|REGNO_REG_SET_P
argument_list|(
name|info
operator|->
name|common_live
argument_list|,
name|x_regno
argument_list|)
expr_stmt|;
name|y_common_live
operator|=
name|REGNO_REG_SET_P
argument_list|(
name|info
operator|->
name|common_live
argument_list|,
name|y_regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|x_common_live
operator|!=
name|y_common_live
condition|)
return|return
name|false
return|;
elseif|else
if|if
condition|(
name|x_common_live
condition|)
block|{
if|if
condition|(
operator|!
name|rvalue
operator|||
name|info
operator|->
name|input_cost
operator|<
literal|0
operator|||
name|no_new_pseudos
condition|)
return|return
name|false
return|;
comment|/* If info->live_update is not set, we are processing notes. 	       We then allow a match with x_input / y_input found in a 	       previous pass.  */
if|if
condition|(
name|info
operator|->
name|live_update
operator|&&
operator|!
name|info
operator|->
name|cur
operator|.
name|input_valid
condition|)
block|{
name|info
operator|->
name|cur
operator|.
name|input_valid
operator|=
name|true
expr_stmt|;
name|info
operator|->
name|x_input
operator|=
name|x
expr_stmt|;
name|info
operator|->
name|y_input
operator|=
name|y
expr_stmt|;
name|info
operator|->
name|cur
operator|.
name|input_count
operator|+=
name|optimize_size
condition|?
literal|2
else|:
literal|1
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|input_reg
operator|&&
name|GET_MODE
argument_list|(
name|info
operator|->
name|input_reg
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|info
operator|->
name|x_input
argument_list|)
condition|)
name|info
operator|->
name|input_reg
operator|=
name|NULL_RTX
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|input_reg
condition|)
name|info
operator|->
name|input_reg
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|info
operator|->
name|x_input
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|info
operator|->
name|live_update
condition|?
operator|!
name|info
operator|->
name|cur
operator|.
name|input_valid
else|:
operator|!
name|info
operator|->
name|x_input
operator|)
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|x
argument_list|,
name|info
operator|->
name|x_input
argument_list|)
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|y
argument_list|,
name|info
operator|->
name|y_input
argument_list|)
condition|)
return|return
name|false
return|;
name|validate_change
argument_list|(
name|info
operator|->
name|cur
operator|.
name|x_start
argument_list|,
name|xp
argument_list|,
name|info
operator|->
name|input_reg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|x_nregs
init|=
operator|(
name|x_regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|?
literal|1
else|:
name|hard_regno_nregs
index|[
name|x_regno
index|]
index|[
name|GET_MODE
argument_list|(
name|x
argument_list|)
index|]
operator|)
decl_stmt|;
name|int
name|y_nregs
init|=
operator|(
name|y_regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|?
literal|1
else|:
name|hard_regno_nregs
index|[
name|y_regno
index|]
index|[
name|GET_MODE
argument_list|(
name|y
argument_list|)
index|]
operator|)
decl_stmt|;
name|int
name|size
init|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|x_mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|unsigned
name|x_regno_i
decl_stmt|,
name|y_regno_i
decl_stmt|;
name|int
name|x_nregs_i
decl_stmt|,
name|y_nregs_i
decl_stmt|,
name|size_i
decl_stmt|;
name|int
name|local_count
init|=
name|info
operator|->
name|cur
operator|.
name|local_count
decl_stmt|;
comment|/* This might be a register local to each block.  See if we have 	       it already registered.  */
for|for
control|(
name|i
operator|=
name|local_count
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|x_regno_i
operator|=
name|REGNO
argument_list|(
name|info
operator|->
name|x_local
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|x_nregs_i
operator|=
operator|(
name|x_regno_i
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|?
literal|1
else|:
name|hard_regno_nregs
index|[
name|x_regno_i
index|]
index|[
name|GET_MODE
argument_list|(
name|x
argument_list|)
index|]
operator|)
expr_stmt|;
name|y_regno_i
operator|=
name|REGNO
argument_list|(
name|info
operator|->
name|y_local
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|y_nregs_i
operator|=
operator|(
name|y_regno_i
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|?
literal|1
else|:
name|hard_regno_nregs
index|[
name|y_regno_i
index|]
index|[
name|GET_MODE
argument_list|(
name|y
argument_list|)
index|]
operator|)
expr_stmt|;
name|size_i
operator|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|info
operator|->
name|x_local
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we have a new pair of registers that is wider than an 		   old pair and enclosing it with matching offsets, 		   remove the old pair.  If we find a matching, wider, old 		   pair, use the old one.  If the width is the same, use the 		   old one if the modes match, but the new if they don't. 		   We don't want to get too fancy with subreg_regno_offset 		   here, so we just test two straightforward cases each.  */
if|if
condition|(
name|info
operator|->
name|live_update
operator|&&
operator|(
name|x_mode
operator|!=
name|GET_MODE
argument_list|(
name|info
operator|->
name|x_local
index|[
name|i
index|]
argument_list|)
condition|?
name|size
operator|>=
name|size_i
else|:
name|size
operator|>
name|size_i
operator|)
condition|)
block|{
comment|/* If the new pair is fully enclosing a matching 		       existing pair, remove the old one.  N.B. because 		       we are removing one entry here, the check below 		       if we have space for a new entry will succeed.  */
if|if
condition|(
operator|(
name|x_regno
operator|<=
name|x_regno_i
operator|&&
name|x_regno
operator|+
name|x_nregs
operator|>=
name|x_regno_i
operator|+
name|x_nregs_i
operator|&&
name|x_nregs
operator|==
name|y_nregs
operator|&&
name|x_nregs_i
operator|==
name|y_nregs_i
operator|&&
name|x_regno
operator|-
name|x_regno_i
operator|==
name|y_regno
operator|-
name|y_regno_i
operator|)
operator|||
operator|(
name|x_regno
operator|==
name|x_regno_i
operator|&&
name|y_regno
operator|==
name|y_regno_i
operator|&&
name|x_nregs
operator|>=
name|x_nregs_i
operator|&&
name|y_nregs
operator|>=
name|y_nregs_i
operator|)
condition|)
block|{
name|info
operator|->
name|cur
operator|.
name|local_count
operator|=
operator|--
name|local_count
expr_stmt|;
name|info
operator|->
name|x_local
index|[
name|i
index|]
operator|=
name|info
operator|->
name|x_local
index|[
name|local_count
index|]
expr_stmt|;
name|info
operator|->
name|y_local
index|[
name|i
index|]
operator|=
name|info
operator|->
name|y_local
index|[
name|local_count
index|]
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
comment|/* If the new pair is fully enclosed within a matching 		       existing pair, succeed.  */
if|if
condition|(
name|x_regno
operator|>=
name|x_regno_i
operator|&&
name|x_regno
operator|+
name|x_nregs
operator|<=
name|x_regno_i
operator|+
name|x_nregs_i
operator|&&
name|x_nregs
operator|==
name|y_nregs
operator|&&
name|x_nregs_i
operator|==
name|y_nregs_i
operator|&&
name|x_regno
operator|-
name|x_regno_i
operator|==
name|y_regno
operator|-
name|y_regno_i
condition|)
break|break;
if|if
condition|(
name|x_regno
operator|==
name|x_regno_i
operator|&&
name|y_regno
operator|==
name|y_regno_i
operator|&&
name|x_nregs
operator|<=
name|x_nregs_i
operator|&&
name|y_nregs
operator|<=
name|y_nregs_i
condition|)
break|break;
block|}
comment|/* Any other overlap causes a match failure.  */
if|if
condition|(
name|x_regno
operator|+
name|x_nregs
operator|>
name|x_regno_i
operator|&&
name|x_regno_i
operator|+
name|x_nregs_i
operator|>
name|x_regno
condition|)
return|return
name|false
return|;
if|if
condition|(
name|y_regno
operator|+
name|y_nregs
operator|>
name|y_regno_i
operator|&&
name|y_regno_i
operator|+
name|y_nregs_i
operator|>
name|y_regno
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
comment|/* Not found.  Create a new entry if possible.  */
if|if
condition|(
operator|!
name|info
operator|->
name|live_update
operator|||
name|info
operator|->
name|cur
operator|.
name|local_count
operator|>=
name|STRUCT_EQUIV_MAX_LOCAL
condition|)
return|return
name|false
return|;
name|info
operator|->
name|x_local
index|[
name|info
operator|->
name|cur
operator|.
name|local_count
index|]
operator|=
name|x
expr_stmt|;
name|info
operator|->
name|y_local
index|[
name|info
operator|->
name|cur
operator|.
name|local_count
index|]
operator|=
name|y
expr_stmt|;
name|info
operator|->
name|cur
operator|.
name|local_count
operator|++
expr_stmt|;
name|info
operator|->
name|cur
operator|.
name|version
operator|++
expr_stmt|;
block|}
name|note_local_live
argument_list|(
name|info
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|rvalue
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
case|case
name|SET
case|:
name|gcc_assert
argument_list|(
name|rvalue
operator|<
literal|0
argument_list|)
expr_stmt|;
comment|/* Ignore the destinations role as a destination.  Still, we have 	 to consider input registers embedded in the addresses of a MEM. 	 N.B., we process the rvalue aspect of STRICT_LOW_PART / 	 ZERO_EXTEND / SIGN_EXTEND along with their lvalue aspect.  */
if|if
condition|(
operator|!
name|set_dest_addr_equiv_p
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|SET_DEST
argument_list|(
name|y
argument_list|)
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Process source.  */
return|return
name|rtx_equiv_p
argument_list|(
operator|&
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|y
argument_list|)
argument_list|,
literal|1
argument_list|,
name|info
argument_list|)
return|;
case|case
name|PRE_MODIFY
case|:
comment|/* Process destination.  */
if|if
condition|(
operator|!
name|rtx_equiv_p
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Process source.  */
return|return
name|rtx_equiv_p
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|,
name|info
argument_list|)
return|;
case|case
name|POST_MODIFY
case|:
block|{
name|rtx
name|x_dest0
decl_stmt|,
name|x_dest1
decl_stmt|;
comment|/* Process destination.  */
name|x_dest0
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|REG_P
argument_list|(
name|x_dest0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rtx_equiv_p
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|false
return|;
name|x_dest1
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* validate_change might have changed the destination.  Put it back 	   so that we can do a proper match for its role a an input.  */
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|x_dest0
expr_stmt|;
if|if
condition|(
operator|!
name|rtx_equiv_p
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|false
return|;
name|gcc_assert
argument_list|(
name|x_dest1
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Process source.  */
return|return
name|rtx_equiv_p
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|,
name|info
argument_list|)
return|;
block|}
case|case
name|CLOBBER
case|:
name|gcc_assert
argument_list|(
name|rvalue
operator|<
literal|0
argument_list|)
expr_stmt|;
return|return
name|true
return|;
comment|/* Some special forms are also rvalues when they appear in lvalue        positions.  However, we must ont try to match a register after we        have already altered it with validate_change, consider the rvalue        aspect while we process the lvalue.  */
case|case
name|STRICT_LOW_PART
case|:
case|case
name|ZERO_EXTEND
case|:
case|case
name|SIGN_EXTEND
case|:
block|{
name|rtx
name|x_inner
decl_stmt|,
name|y_inner
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|int
name|change
decl_stmt|;
if|if
condition|(
name|rvalue
condition|)
break|break;
name|x_inner
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|y_inner
operator|=
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x_inner
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|y_inner
argument_list|)
condition|)
return|return
name|false
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x_inner
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|GET_CODE
argument_list|(
name|y_inner
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* The address of a MEM is an input that will be processed during 	   rvalue == -1 processing.  */
if|if
condition|(
name|code
operator|==
name|SUBREG
condition|)
block|{
if|if
condition|(
name|SUBREG_BYTE
argument_list|(
name|x_inner
argument_list|)
operator|!=
name|SUBREG_BYTE
argument_list|(
name|y_inner
argument_list|)
condition|)
return|return
name|false
return|;
name|x
operator|=
name|x_inner
expr_stmt|;
name|x_inner
operator|=
name|SUBREG_REG
argument_list|(
name|x_inner
argument_list|)
expr_stmt|;
name|y_inner
operator|=
name|SUBREG_REG
argument_list|(
name|y_inner
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x_inner
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|y_inner
argument_list|)
condition|)
return|return
name|false
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x_inner
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|GET_CODE
argument_list|(
name|y_inner
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|code
operator|==
name|MEM
condition|)
return|return
name|true
return|;
name|gcc_assert
argument_list|(
name|code
operator|==
name|REG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rtx_equiv_p
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|y_inner
argument_list|,
name|rvalue
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|REGNO
argument_list|(
name|x_inner
argument_list|)
operator|==
name|REGNO
argument_list|(
name|y_inner
argument_list|)
condition|)
block|{
name|change
operator|=
name|assign_reg_reg_set
argument_list|(
name|info
operator|->
name|common_live
argument_list|,
name|x_inner
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|cur
operator|.
name|version
operator|++
expr_stmt|;
block|}
else|else
name|change
operator|=
name|note_local_live
argument_list|(
name|info
argument_list|,
name|x_inner
argument_list|,
name|y_inner
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|change
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* The AUTO_INC / POST_MODIFY / PRE_MODIFY sets are modelled to take        place during input processing, however, that is benign, since they        are paired with reads.  */
case|case
name|MEM
case|:
return|return
operator|!
name|rvalue
operator|||
name|rtx_equiv_p
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|,
name|rvalue
argument_list|,
name|info
argument_list|)
return|;
case|case
name|POST_INC
case|:
case|case
name|POST_DEC
case|:
case|case
name|PRE_INC
case|:
case|case
name|PRE_DEC
case|:
return|return
operator|(
name|rtx_equiv_p
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
name|info
argument_list|)
operator|&&
name|rtx_equiv_p
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|,
name|info
argument_list|)
operator|)
return|;
case|case
name|PARALLEL
case|:
comment|/* If this is a top-level PATTERN PARALLEL, we expect the caller to  	 have handled the SET_DESTs.  A complex or vector PARALLEL can be 	 identified by having a mode.  */
name|gcc_assert
argument_list|(
name|rvalue
operator|<
literal|0
operator|||
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|VOIDmode
argument_list|)
expr_stmt|;
break|break;
case|case
name|LABEL_REF
case|:
comment|/* Check special tablejump match case.  */
if|if
condition|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
operator|==
name|info
operator|->
name|y_label
condition|)
return|return
operator|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|info
operator|->
name|x_label
operator|)
return|;
comment|/* We can't assume nonlocal labels have their following insns yet.  */
if|if
condition|(
name|LABEL_REF_NONLOCAL_P
argument_list|(
name|x
argument_list|)
operator|||
name|LABEL_REF_NONLOCAL_P
argument_list|(
name|y
argument_list|)
condition|)
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
return|;
comment|/* Two label-refs are equivalent if they point at labels 	 in the same position in the instruction stream.  */
return|return
operator|(
name|next_real_insn
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|next_real_insn
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|SYMBOL_REF
case|:
return|return
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|XSTR
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
return|;
comment|/* Some rtl is guaranteed to be shared, or unique;  If we didn't match        EQ equality above, they aren't the same.  */
case|case
name|CONST_INT
case|:
case|case
name|CODE_LABEL
case|:
return|return
name|false
return|;
default|default:
break|break;
block|}
comment|/* For commutative operations, the RTX match if the operands match in any      order.  */
if|if
condition|(
name|targetm
operator|.
name|commutative_p
argument_list|(
name|x
argument_list|,
name|UNKNOWN
argument_list|)
condition|)
return|return
operator|(
operator|(
name|rtx_equiv_p
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|,
name|rvalue
argument_list|,
name|info
argument_list|)
operator|&&
name|rtx_equiv_p
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|,
name|rvalue
argument_list|,
name|info
argument_list|)
operator|)
operator|||
operator|(
name|rtx_equiv_p
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|,
name|rvalue
argument_list|,
name|info
argument_list|)
operator|&&
name|rtx_equiv_p
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|,
name|rvalue
argument_list|,
name|info
argument_list|)
operator|)
operator|)
return|;
comment|/* Process subexpressions - this is similar to rtx_equal_p.  */
name|length
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|format
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
operator|++
name|i
control|)
block|{
switch|switch
condition|(
name|format
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'w'
case|:
if|if
condition|(
name|XWINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XWINT
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
literal|'n'
case|:
case|case
literal|'i'
case|:
if|if
condition|(
name|XINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XINT
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
literal|'V'
case|:
case|case
literal|'E'
case|:
if|if
condition|(
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XVECLEN
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|XVEC
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
operator|!
name|rtx_equiv_p
argument_list|(
operator|&
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|XVECEXP
argument_list|(
name|y
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|rvalue
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
break|break;
case|case
literal|'e'
case|:
if|if
condition|(
operator|!
name|rtx_equiv_p
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
argument_list|,
name|rvalue
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
literal|'S'
case|:
case|case
literal|'s'
case|:
if|if
condition|(
operator|(
name|XSTR
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|||
name|XSTR
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|XSTR
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|||
operator|!
name|XSTR
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
operator|||
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|XSTR
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
break|break;
case|case
literal|'u'
case|:
comment|/* These are just backpointers, so they don't matter.  */
break|break;
case|case
literal|'0'
case|:
case|case
literal|'t'
case|:
break|break;
comment|/* It is believed that rtx's at this level will never 	     contain anything but integers and other rtx's, 	     except for within LABEL_REFs and SYMBOL_REFs.  */
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Do only the rtx_equiv_p SET_DEST processing for SETs and CLOBBERs.    Since we are scanning backwards, this the first step in processing each    insn.  Return true for success.  */
end_comment

begin_function
specifier|static
name|bool
name|set_dest_equiv_p
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|y
parameter_list|,
name|struct
name|equiv_info
modifier|*
name|info
parameter_list|)
block|{
if|if
condition|(
operator|!
name|x
operator|||
operator|!
name|y
condition|)
return|return
name|x
operator|==
name|y
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|GET_CODE
argument_list|(
name|y
argument_list|)
condition|)
return|return
name|false
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CLOBBER
condition|)
return|return
name|rtx_equiv_p
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
name|info
argument_list|)
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|j
decl_stmt|;
if|if
condition|(
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|!=
name|XVECLEN
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|;
operator|++
name|j
control|)
block|{
name|rtx
name|xe
init|=
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
decl_stmt|;
name|rtx
name|ye
init|=
name|XVECEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|xe
argument_list|)
operator|!=
name|GET_CODE
argument_list|(
name|ye
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|xe
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|xe
argument_list|)
operator|==
name|CLOBBER
operator|)
operator|&&
operator|!
name|rtx_equiv_p
argument_list|(
operator|&
name|XEXP
argument_list|(
name|xe
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|ye
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Process MEMs in SET_DEST destinations.  We must not process this together    with REG SET_DESTs, but must do it separately, lest when we see    [(set (reg:SI foo) (bar))     (set (mem:SI (reg:SI foo) (baz)))]    struct_equiv_block_eq could get confused to assume that (reg:SI foo)    is not live before this instruction.  */
end_comment

begin_function
specifier|static
name|bool
name|set_dest_addr_equiv_p
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|y
parameter_list|,
name|struct
name|equiv_info
modifier|*
name|info
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|length
decl_stmt|;
specifier|const
name|char
modifier|*
name|format
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|code
operator|!=
name|GET_CODE
argument_list|(
name|y
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|code
operator|==
name|MEM
condition|)
return|return
name|rtx_equiv_p
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|,
name|info
argument_list|)
return|;
comment|/* Process subexpressions.  */
name|length
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|format
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
operator|++
name|i
control|)
block|{
switch|switch
condition|(
name|format
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'V'
case|:
case|case
literal|'E'
case|:
if|if
condition|(
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XVECLEN
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|XVEC
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
operator|!
name|set_dest_addr_equiv_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|XVECEXP
argument_list|(
name|y
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
break|break;
case|case
literal|'e'
case|:
if|if
condition|(
operator|!
name|set_dest_addr_equiv_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
default|default:
break|break;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Check if the set of REG_DEAD notes attached to I1 and I2 allows us to    go ahead with merging I1 and I2, which otherwise look fine.    Inputs / local registers for the inputs of I1 and I2 have already been    set up.  */
end_comment

begin_function
specifier|static
name|bool
name|death_notes_match_p
parameter_list|(
name|rtx
name|i1
name|ATTRIBUTE_UNUSED
parameter_list|,
name|rtx
name|i2
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|equiv_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|STACK_REGS
comment|/* If cross_jump_death_matters is not 0, the insn's mode      indicates whether or not the insn contains any stack-like regs.  */
if|if
condition|(
operator|(
name|info
operator|->
name|mode
operator|&
name|CLEANUP_POST_REGSTACK
operator|)
operator|&&
name|stack_regs_mentioned
argument_list|(
name|i1
argument_list|)
condition|)
block|{
comment|/* If register stack conversion has already been done, then 	 death notes must also be compared before it is certain that 	 the two instruction streams match.  */
name|rtx
name|note
decl_stmt|;
name|HARD_REG_SET
name|i1_regset
decl_stmt|,
name|i2_regset
decl_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|i1_regset
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|i2_regset
argument_list|)
expr_stmt|;
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|i1
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_DEAD
operator|&&
name|STACK_REG_P
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|i1_regset
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|i2
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_DEAD
operator|&&
name|STACK_REG_P
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|unsigned
name|regno
init|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|info
operator|->
name|cur
operator|.
name|local_count
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|regno
operator|==
name|REGNO
argument_list|(
name|info
operator|->
name|y_local
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|regno
operator|=
name|REGNO
argument_list|(
name|info
operator|->
name|x_local
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
name|SET_HARD_REG_BIT
argument_list|(
name|i2_regset
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
name|GO_IF_HARD_REG_EQUAL
argument_list|(
name|i1_regset
argument_list|,
name|i2_regset
argument_list|,
name|done
argument_list|)
expr_stmt|;
return|return
name|false
return|;
name|done
label|:
empty_stmt|;
block|}
endif|#
directive|endif
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Return true if I1 and I2 are equivalent and thus can be crossjumped.  */
end_comment

begin_function
name|bool
name|insns_match_p
parameter_list|(
name|rtx
name|i1
parameter_list|,
name|rtx
name|i2
parameter_list|,
name|struct
name|equiv_info
modifier|*
name|info
parameter_list|)
block|{
name|int
name|rvalue_change_start
decl_stmt|;
name|struct
name|struct_equiv_checkpoint
name|before_rvalue_change
decl_stmt|;
comment|/* Verify that I1 and I2 are equivalent.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|i1
argument_list|)
operator|!=
name|GET_CODE
argument_list|(
name|i2
argument_list|)
condition|)
return|return
name|false
return|;
name|info
operator|->
name|cur
operator|.
name|x_start
operator|=
name|i1
expr_stmt|;
name|info
operator|->
name|cur
operator|.
name|y_start
operator|=
name|i2
expr_stmt|;
comment|/* If this is a CALL_INSN, compare register usage information.      If we don't check this on stack register machines, the two      CALL_INSNs might be merged leaving reg-stack.c with mismatching      numbers of stack registers in the same basic block.      If we don't check this on machines with delay slots, a delay slot may      be filled that clobbers a parameter expected by the subroutine.       ??? We take the simple route for now and assume that if they're      equal, they were constructed identically.  */
if|if
condition|(
name|CALL_P
argument_list|(
name|i1
argument_list|)
condition|)
block|{
if|if
condition|(
name|SIBLING_CALL_P
argument_list|(
name|i1
argument_list|)
operator|!=
name|SIBLING_CALL_P
argument_list|(
name|i2
argument_list|)
operator|||
operator|!
name|set_dest_equiv_p
argument_list|(
name|PATTERN
argument_list|(
name|i1
argument_list|)
argument_list|,
name|PATTERN
argument_list|(
name|i2
argument_list|)
argument_list|,
name|info
argument_list|)
operator|||
operator|!
name|set_dest_equiv_p
argument_list|(
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|i1
argument_list|)
argument_list|,
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|i2
argument_list|)
argument_list|,
name|info
argument_list|)
operator|||
operator|!
name|rtx_equiv_p
argument_list|(
operator|&
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|i1
argument_list|)
argument_list|,
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|i2
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
name|info
argument_list|)
condition|)
block|{
name|cancel_changes
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|INSN_P
argument_list|(
name|i1
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|set_dest_equiv_p
argument_list|(
name|PATTERN
argument_list|(
name|i1
argument_list|)
argument_list|,
name|PATTERN
argument_list|(
name|i2
argument_list|)
argument_list|,
name|info
argument_list|)
condition|)
block|{
name|cancel_changes
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
name|rvalue_change_start
operator|=
name|num_validated_changes
argument_list|()
expr_stmt|;
name|struct_equiv_make_checkpoint
argument_list|(
operator|&
name|before_rvalue_change
argument_list|,
name|info
argument_list|)
expr_stmt|;
comment|/* Check death_notes_match_p *after* the inputs have been processed,      so that local inputs will already have been set up.  */
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|i1
argument_list|)
operator|||
operator|(
operator|!
name|bitmap_bit_p
argument_list|(
name|info
operator|->
name|equiv_used
argument_list|,
name|info
operator|->
name|cur
operator|.
name|ninsns
argument_list|)
operator|&&
name|rtx_equiv_p
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|i1
argument_list|)
argument_list|,
name|PATTERN
argument_list|(
name|i2
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
name|info
argument_list|)
operator|&&
name|death_notes_match_p
argument_list|(
name|i1
argument_list|,
name|i2
argument_list|,
name|info
argument_list|)
operator|&&
name|verify_changes
argument_list|(
literal|0
argument_list|)
operator|)
condition|)
return|return
name|true
return|;
comment|/* Do not do EQUIV substitution after reload.  First, we're undoing the      work of reload_cse.  Second, we may be undoing the work of the post-      reload splitting pass.  */
comment|/* ??? Possibly add a new phase switch variable that can be used by      targets to disallow the troublesome insns after splitting.  */
if|if
condition|(
operator|!
name|reload_completed
condition|)
block|{
name|rtx
name|equiv1
decl_stmt|,
name|equiv2
decl_stmt|;
name|cancel_changes
argument_list|(
name|rvalue_change_start
argument_list|)
expr_stmt|;
name|struct_equiv_restore_checkpoint
argument_list|(
operator|&
name|before_rvalue_change
argument_list|,
name|info
argument_list|)
expr_stmt|;
comment|/* The following code helps take care of G++ cleanups.  */
name|equiv1
operator|=
name|find_reg_equal_equiv_note
argument_list|(
name|i1
argument_list|)
expr_stmt|;
name|equiv2
operator|=
name|find_reg_equal_equiv_note
argument_list|(
name|i2
argument_list|)
expr_stmt|;
if|if
condition|(
name|equiv1
operator|&&
name|equiv2
comment|/* If the equivalences are not to a constant, they may 	     reference pseudos that no longer exist, so we can't 	     use them.  */
operator|&&
operator|(
operator|!
name|reload_completed
operator|||
operator|(
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|equiv1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|equiv1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|equiv2
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
block|{
name|rtx
name|s1
init|=
name|single_set
argument_list|(
name|i1
argument_list|)
decl_stmt|;
name|rtx
name|s2
init|=
name|single_set
argument_list|(
name|i2
argument_list|)
decl_stmt|;
if|if
condition|(
name|s1
operator|!=
literal|0
operator|&&
name|s2
operator|!=
literal|0
condition|)
block|{
name|validate_change
argument_list|(
name|i1
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|s1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|equiv1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|validate_change
argument_list|(
name|i2
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|s2
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|equiv2
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Only inspecting the new SET_SRC is not good enough, 		 because there may also be bare USEs in a single_set 		 PARALLEL.  */
if|if
condition|(
name|rtx_equiv_p
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|i1
argument_list|)
argument_list|,
name|PATTERN
argument_list|(
name|i2
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
name|info
argument_list|)
operator|&&
name|death_notes_match_p
argument_list|(
name|i1
argument_list|,
name|i2
argument_list|,
name|info
argument_list|)
operator|&&
name|verify_changes
argument_list|(
literal|0
argument_list|)
condition|)
block|{
comment|/* Mark this insn so that we'll use the equivalence in 		     all subsequent passes.  */
name|bitmap_set_bit
argument_list|(
name|info
operator|->
name|equiv_used
argument_list|,
name|info
operator|->
name|cur
operator|.
name|ninsns
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
block|}
block|}
name|cancel_changes
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Set up mode and register information in INFO.  Return true for success.  */
end_comment

begin_function
name|bool
name|struct_equiv_init
parameter_list|(
name|int
name|mode
parameter_list|,
name|struct
name|equiv_info
modifier|*
name|info
parameter_list|)
block|{
if|if
condition|(
operator|(
name|info
operator|->
name|x_block
operator|->
name|flags
operator||
name|info
operator|->
name|y_block
operator|->
name|flags
operator|)
operator|&
name|BB_DIRTY
condition|)
name|update_life_info_in_dirty_blocks
argument_list|(
name|UPDATE_LIFE_GLOBAL_RM_NOTES
argument_list|,
operator|(
name|PROP_DEATH_NOTES
operator||
operator|(
operator|(
name|mode
operator|&
name|CLEANUP_POST_REGSTACK
operator|)
condition|?
name|PROP_POST_REGSTACK
else|:
literal|0
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|REG_SET_EQUAL_P
argument_list|(
name|info
operator|->
name|x_block
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_end
argument_list|,
name|info
operator|->
name|y_block
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_end
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|STACK_REGS
name|unsigned
name|rn
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|mode
operator|&
name|CLEANUP_POST_REGSTACK
operator|)
condition|)
return|return
name|false
return|;
comment|/* After reg-stack.  Remove bogus live info about stack regs.  N.B. 	 these regs are not necessarily all dead - we swap random bogosity 	 against constant bogosity.  However, clearing these bits at 	 least makes the regsets comparable.  */
for|for
control|(
name|rn
operator|=
name|FIRST_STACK_REG
init|;
name|rn
operator|<=
name|LAST_STACK_REG
condition|;
name|rn
operator|++
control|)
block|{
name|CLEAR_REGNO_REG_SET
argument_list|(
name|info
operator|->
name|x_block
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_end
argument_list|,
name|rn
argument_list|)
expr_stmt|;
name|CLEAR_REGNO_REG_SET
argument_list|(
name|info
operator|->
name|y_block
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_end
argument_list|,
name|rn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|REG_SET_EQUAL_P
argument_list|(
name|info
operator|->
name|x_block
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_end
argument_list|,
name|info
operator|->
name|y_block
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_end
argument_list|)
condition|)
endif|#
directive|endif
return|return
name|false
return|;
block|}
name|info
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|STRUCT_EQUIV_START
condition|)
block|{
name|info
operator|->
name|x_input
operator|=
name|info
operator|->
name|y_input
operator|=
name|info
operator|->
name|input_reg
operator|=
name|NULL_RTX
expr_stmt|;
name|info
operator|->
name|equiv_used
operator|=
name|ALLOC_REG_SET
argument_list|(
operator|&
name|reg_obstack
argument_list|)
expr_stmt|;
name|info
operator|->
name|check_input_conflict
operator|=
name|false
expr_stmt|;
block|}
name|info
operator|->
name|had_input_conflict
operator|=
name|false
expr_stmt|;
name|info
operator|->
name|cur
operator|.
name|ninsns
operator|=
name|info
operator|->
name|cur
operator|.
name|version
operator|=
literal|0
expr_stmt|;
name|info
operator|->
name|cur
operator|.
name|local_count
operator|=
name|info
operator|->
name|cur
operator|.
name|input_count
operator|=
literal|0
expr_stmt|;
name|info
operator|->
name|cur
operator|.
name|x_start
operator|=
name|info
operator|->
name|cur
operator|.
name|y_start
operator|=
name|NULL_RTX
expr_stmt|;
name|info
operator|->
name|x_label
operator|=
name|info
operator|->
name|y_label
operator|=
name|NULL_RTX
expr_stmt|;
name|info
operator|->
name|need_rerun
operator|=
name|false
expr_stmt|;
name|info
operator|->
name|live_update
operator|=
name|true
expr_stmt|;
name|info
operator|->
name|cur
operator|.
name|input_valid
operator|=
name|false
expr_stmt|;
name|info
operator|->
name|common_live
operator|=
name|ALLOC_REG_SET
argument_list|(
operator|&
name|reg_obstack
argument_list|)
expr_stmt|;
name|info
operator|->
name|x_local_live
operator|=
name|ALLOC_REG_SET
argument_list|(
operator|&
name|reg_obstack
argument_list|)
expr_stmt|;
name|info
operator|->
name|y_local_live
operator|=
name|ALLOC_REG_SET
argument_list|(
operator|&
name|reg_obstack
argument_list|)
expr_stmt|;
name|COPY_REG_SET
argument_list|(
name|info
operator|->
name|common_live
argument_list|,
name|info
operator|->
name|x_block
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_end
argument_list|)
expr_stmt|;
name|struct_equiv_make_checkpoint
argument_list|(
operator|&
name|info
operator|->
name|best_match
argument_list|,
name|info
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Insns XI and YI have been matched.  Merge memory attributes and reg    notes.  */
end_comment

begin_function
specifier|static
name|void
name|struct_equiv_merge
parameter_list|(
name|rtx
name|xi
parameter_list|,
name|rtx
name|yi
parameter_list|,
name|struct
name|equiv_info
modifier|*
name|info
parameter_list|)
block|{
name|rtx
name|equiv1
decl_stmt|,
name|equiv2
decl_stmt|;
name|merge_memattrs
argument_list|(
name|xi
argument_list|,
name|yi
argument_list|)
expr_stmt|;
comment|/* If the merged insns have different REG_EQUAL notes, then      remove them.  */
name|info
operator|->
name|live_update
operator|=
name|false
expr_stmt|;
name|equiv1
operator|=
name|find_reg_equal_equiv_note
argument_list|(
name|xi
argument_list|)
expr_stmt|;
name|equiv2
operator|=
name|find_reg_equal_equiv_note
argument_list|(
name|yi
argument_list|)
expr_stmt|;
if|if
condition|(
name|equiv1
operator|&&
operator|!
name|equiv2
condition|)
name|remove_note
argument_list|(
name|xi
argument_list|,
name|equiv1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|equiv1
operator|&&
name|equiv2
condition|)
name|remove_note
argument_list|(
name|yi
argument_list|,
name|equiv2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|equiv1
operator|&&
name|equiv2
operator|&&
operator|!
name|rtx_equiv_p
argument_list|(
operator|&
name|XEXP
argument_list|(
name|equiv1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|equiv2
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|,
name|info
argument_list|)
condition|)
block|{
name|remove_note
argument_list|(
name|xi
argument_list|,
name|equiv1
argument_list|)
expr_stmt|;
name|remove_note
argument_list|(
name|yi
argument_list|,
name|equiv2
argument_list|)
expr_stmt|;
block|}
name|info
operator|->
name|live_update
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return number of matched insns.    This function must be called up to three times for a successful cross-jump    match:    first to find out which instructions do match.  While trying to match    another instruction that doesn't match, we destroy information in info    about the actual inputs.  So if there have been any before the last    match attempt, we need to call this function again to recompute the    actual inputs up to the actual start of the matching sequence.    When we are then satisfied that the cross-jump is worthwhile, we    call this function a third time to make any changes needed to make the    sequences match: apply equivalences, remove non-matching    notes and merge memory attributes.  */
end_comment

begin_function
name|int
name|struct_equiv_block_eq
parameter_list|(
name|int
name|mode
parameter_list|,
name|struct
name|equiv_info
modifier|*
name|info
parameter_list|)
block|{
name|rtx
name|x_stop
decl_stmt|,
name|y_stop
decl_stmt|;
name|rtx
name|xi
decl_stmt|,
name|yi
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|mode
operator|&
name|STRUCT_EQUIV_START
condition|)
block|{
name|x_stop
operator|=
name|BB_HEAD
argument_list|(
name|info
operator|->
name|x_block
argument_list|)
expr_stmt|;
name|y_stop
operator|=
name|BB_HEAD
argument_list|(
name|info
operator|->
name|y_block
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|x_stop
operator|||
operator|!
name|y_stop
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
name|x_stop
operator|=
name|info
operator|->
name|cur
operator|.
name|x_start
expr_stmt|;
name|y_stop
operator|=
name|info
operator|->
name|cur
operator|.
name|y_start
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|struct_equiv_init
argument_list|(
name|mode
argument_list|,
name|info
argument_list|)
condition|)
name|gcc_unreachable
argument_list|()
expr_stmt|;
comment|/* Skip simple jumps at the end of the blocks.  Complex jumps still      need to be compared for equivalence, which we'll do below.  */
name|xi
operator|=
name|BB_END
argument_list|(
name|info
operator|->
name|x_block
argument_list|)
expr_stmt|;
if|if
condition|(
name|onlyjump_p
argument_list|(
name|xi
argument_list|)
operator|||
operator|(
name|returnjump_p
argument_list|(
name|xi
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|PATTERN
argument_list|(
name|xi
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|info
operator|->
name|cur
operator|.
name|x_start
operator|=
name|xi
expr_stmt|;
name|xi
operator|=
name|PREV_INSN
argument_list|(
name|xi
argument_list|)
expr_stmt|;
block|}
name|yi
operator|=
name|BB_END
argument_list|(
name|info
operator|->
name|y_block
argument_list|)
expr_stmt|;
if|if
condition|(
name|onlyjump_p
argument_list|(
name|yi
argument_list|)
operator|||
operator|(
name|returnjump_p
argument_list|(
name|yi
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|PATTERN
argument_list|(
name|yi
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|info
operator|->
name|cur
operator|.
name|y_start
operator|=
name|yi
expr_stmt|;
comment|/* Count everything except for unconditional jump as insn.  */
comment|/* ??? Is it right to count unconditional jumps with a clobber? 	 Should we count conditional returns?  */
if|if
condition|(
operator|!
name|simplejump_p
argument_list|(
name|yi
argument_list|)
operator|&&
operator|!
name|returnjump_p
argument_list|(
name|yi
argument_list|)
operator|&&
name|info
operator|->
name|cur
operator|.
name|x_start
condition|)
name|info
operator|->
name|cur
operator|.
name|ninsns
operator|++
expr_stmt|;
name|yi
operator|=
name|PREV_INSN
argument_list|(
name|yi
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|&
name|STRUCT_EQUIV_MATCH_JUMPS
condition|)
block|{
comment|/* The caller is expected to have compared the jumps already, but we 	 need to match them again to get any local registers and inputs.  */
name|gcc_assert
argument_list|(
operator|!
name|info
operator|->
name|cur
operator|.
name|x_start
operator|==
operator|!
name|info
operator|->
name|cur
operator|.
name|y_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|cur
operator|.
name|x_start
condition|)
block|{
if|if
condition|(
name|any_condjump_p
argument_list|(
name|info
operator|->
name|cur
operator|.
name|x_start
argument_list|)
condition|?
operator|!
name|condjump_equiv_p
argument_list|(
name|info
argument_list|,
name|false
argument_list|)
else|:
operator|!
name|insns_match_p
argument_list|(
name|info
operator|->
name|cur
operator|.
name|x_start
argument_list|,
name|info
operator|->
name|cur
operator|.
name|y_start
argument_list|,
name|info
argument_list|)
condition|)
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|any_condjump_p
argument_list|(
name|xi
argument_list|)
operator|&&
name|any_condjump_p
argument_list|(
name|yi
argument_list|)
condition|)
block|{
name|info
operator|->
name|cur
operator|.
name|x_start
operator|=
name|xi
expr_stmt|;
name|info
operator|->
name|cur
operator|.
name|y_start
operator|=
name|yi
expr_stmt|;
name|xi
operator|=
name|PREV_INSN
argument_list|(
name|xi
argument_list|)
expr_stmt|;
name|yi
operator|=
name|PREV_INSN
argument_list|(
name|yi
argument_list|)
expr_stmt|;
name|info
operator|->
name|cur
operator|.
name|ninsns
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|condjump_equiv_p
argument_list|(
name|info
argument_list|,
name|false
argument_list|)
condition|)
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|cur
operator|.
name|x_start
operator|&&
name|info
operator|->
name|mode
operator|&
name|STRUCT_EQUIV_FINAL
condition|)
name|struct_equiv_merge
argument_list|(
name|info
operator|->
name|cur
operator|.
name|x_start
argument_list|,
name|info
operator|->
name|cur
operator|.
name|y_start
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
name|struct_equiv_improve_checkpoint
argument_list|(
operator|&
name|info
operator|->
name|best_match
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|info
operator|->
name|x_end
operator|=
name|xi
expr_stmt|;
name|info
operator|->
name|y_end
operator|=
name|yi
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|cur
operator|.
name|x_start
operator|!=
name|x_stop
condition|)
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Ignore notes.  */
while|while
condition|(
operator|!
name|INSN_P
argument_list|(
name|xi
argument_list|)
operator|&&
name|xi
operator|!=
name|x_stop
condition|)
name|xi
operator|=
name|PREV_INSN
argument_list|(
name|xi
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|INSN_P
argument_list|(
name|yi
argument_list|)
operator|&&
name|yi
operator|!=
name|y_stop
condition|)
name|yi
operator|=
name|PREV_INSN
argument_list|(
name|yi
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insns_match_p
argument_list|(
name|xi
argument_list|,
name|yi
argument_list|,
name|info
argument_list|)
condition|)
break|break;
if|if
condition|(
name|INSN_P
argument_list|(
name|xi
argument_list|)
condition|)
block|{
if|if
condition|(
name|info
operator|->
name|mode
operator|&
name|STRUCT_EQUIV_FINAL
condition|)
name|struct_equiv_merge
argument_list|(
name|xi
argument_list|,
name|yi
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|info
operator|->
name|cur
operator|.
name|ninsns
operator|++
expr_stmt|;
name|struct_equiv_improve_checkpoint
argument_list|(
operator|&
name|info
operator|->
name|best_match
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xi
operator|==
name|x_stop
operator|||
name|yi
operator|==
name|y_stop
condition|)
block|{
comment|/* If we reached the start of at least one of the blocks, but 	       best_match hasn't been advanced back to the first valid insn 	       yet, represent the increased benefit of completing the block 	       as an increased instruction count.  */
if|if
condition|(
name|info
operator|->
name|best_match
operator|.
name|x_start
operator|!=
name|info
operator|->
name|cur
operator|.
name|x_start
operator|&&
operator|(
name|xi
operator|==
name|BB_HEAD
argument_list|(
name|info
operator|->
name|x_block
argument_list|)
operator|||
name|yi
operator|==
name|BB_HEAD
argument_list|(
name|info
operator|->
name|y_block
argument_list|)
operator|)
condition|)
block|{
name|info
operator|->
name|cur
operator|.
name|ninsns
operator|++
expr_stmt|;
name|struct_equiv_improve_checkpoint
argument_list|(
operator|&
name|info
operator|->
name|best_match
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|info
operator|->
name|cur
operator|.
name|ninsns
operator|--
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|best_match
operator|.
name|ninsns
operator|>
name|info
operator|->
name|cur
operator|.
name|ninsns
condition|)
name|info
operator|->
name|best_match
operator|.
name|ninsns
operator|=
name|info
operator|->
name|cur
operator|.
name|ninsns
expr_stmt|;
block|}
break|break;
block|}
name|xi
operator|=
name|PREV_INSN
argument_list|(
name|xi
argument_list|)
expr_stmt|;
name|yi
operator|=
name|PREV_INSN
argument_list|(
name|yi
argument_list|)
expr_stmt|;
block|}
comment|/* If we failed to match an insn, but had some changes registered from      trying to make the insns match, we need to cancel these changes now.  */
name|cancel_changes
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Restore to best_match to get the sequence with the best known-so-far      cost-benefit difference.  */
name|struct_equiv_restore_checkpoint
argument_list|(
operator|&
name|info
operator|->
name|best_match
argument_list|,
name|info
argument_list|)
expr_stmt|;
comment|/* Include preceding notes and labels in the cross-jump / if-conversion.      One, this may bring us to the head of the blocks.      Two, it keeps line number notes as matched as may be.  */
if|if
condition|(
name|info
operator|->
name|cur
operator|.
name|ninsns
condition|)
block|{
name|xi
operator|=
name|info
operator|->
name|cur
operator|.
name|x_start
expr_stmt|;
name|yi
operator|=
name|info
operator|->
name|cur
operator|.
name|y_start
expr_stmt|;
while|while
condition|(
name|xi
operator|!=
name|x_stop
operator|&&
operator|!
name|INSN_P
argument_list|(
name|PREV_INSN
argument_list|(
name|xi
argument_list|)
argument_list|)
condition|)
name|xi
operator|=
name|PREV_INSN
argument_list|(
name|xi
argument_list|)
expr_stmt|;
while|while
condition|(
name|yi
operator|!=
name|y_stop
operator|&&
operator|!
name|INSN_P
argument_list|(
name|PREV_INSN
argument_list|(
name|yi
argument_list|)
argument_list|)
condition|)
name|yi
operator|=
name|PREV_INSN
argument_list|(
name|yi
argument_list|)
expr_stmt|;
name|info
operator|->
name|cur
operator|.
name|x_start
operator|=
name|xi
expr_stmt|;
name|info
operator|->
name|cur
operator|.
name|y_start
operator|=
name|yi
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|info
operator|->
name|cur
operator|.
name|input_valid
condition|)
name|info
operator|->
name|x_input
operator|=
name|info
operator|->
name|y_input
operator|=
name|info
operator|->
name|input_reg
operator|=
name|NULL_RTX
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|need_rerun
condition|)
block|{
name|find_dying_inputs
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|mode
operator|&
name|STRUCT_EQUIV_FINAL
condition|)
block|{
if|if
condition|(
name|info
operator|->
name|check_input_conflict
operator|&&
operator|!
name|resolve_input_conflict
argument_list|(
name|info
argument_list|)
condition|)
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|bool
name|input_conflict
init|=
name|info
operator|->
name|had_input_conflict
decl_stmt|;
if|if
condition|(
operator|!
name|input_conflict
operator|&&
name|info
operator|->
name|dying_inputs
operator|>
literal|1
operator|&&
name|bitmap_intersect_p
argument_list|(
name|info
operator|->
name|x_local_live
argument_list|,
name|info
operator|->
name|y_local_live
argument_list|)
condition|)
block|{
name|regset_head
name|clobbered_regs
decl_stmt|;
name|INIT_REG_SET
argument_list|(
operator|&
name|clobbered_regs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|info
operator|->
name|cur
operator|.
name|local_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|assign_reg_reg_set
argument_list|(
operator|&
name|clobbered_regs
argument_list|,
name|info
operator|->
name|y_local
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|input_conflict
operator|=
name|true
expr_stmt|;
break|break;
block|}
name|assign_reg_reg_set
argument_list|(
operator|&
name|clobbered_regs
argument_list|,
name|info
operator|->
name|x_local
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|CLEAR_REG_SET
argument_list|(
operator|&
name|clobbered_regs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|input_conflict
operator|&&
operator|!
name|info
operator|->
name|check_input_conflict
condition|)
name|info
operator|->
name|need_rerun
operator|=
name|true
expr_stmt|;
name|info
operator|->
name|check_input_conflict
operator|=
name|input_conflict
expr_stmt|;
block|}
block|}
if|if
condition|(
name|info
operator|->
name|mode
operator|&
name|STRUCT_EQUIV_NEED_FULL_BLOCK
operator|&&
operator|(
name|info
operator|->
name|cur
operator|.
name|x_start
operator|!=
name|x_stop
operator|||
name|info
operator|->
name|cur
operator|.
name|y_start
operator|!=
name|y_stop
operator|)
condition|)
return|return
literal|0
return|;
return|return
name|info
operator|->
name|cur
operator|.
name|ninsns
return|;
block|}
end_function

begin_comment
comment|/* For each local register, set info->local_rvalue to true iff the register    is a dying input.  Store the total number of these in info->dying_inputs.  */
end_comment

begin_function
specifier|static
name|void
name|find_dying_inputs
parameter_list|(
name|struct
name|equiv_info
modifier|*
name|info
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|info
operator|->
name|dying_inputs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|info
operator|->
name|cur
operator|.
name|local_count
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|rtx
name|x
init|=
name|info
operator|->
name|x_local
index|[
name|i
index|]
decl_stmt|;
name|unsigned
name|regno
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|nregs
init|=
operator|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|?
literal|1
else|:
name|hard_regno_nregs
index|[
name|regno
index|]
index|[
name|GET_MODE
argument_list|(
name|x
argument_list|)
index|]
operator|)
decl_stmt|;
for|for
control|(
name|info
operator|->
name|local_rvalue
index|[
name|i
index|]
operator|=
name|false
init|;
name|nregs
operator|>
literal|0
condition|;
name|regno
operator|++
operator|,
operator|--
name|nregs
control|)
if|if
condition|(
name|REGNO_REG_SET_P
argument_list|(
name|info
operator|->
name|x_local_live
argument_list|,
name|regno
argument_list|)
condition|)
block|{
name|info
operator|->
name|dying_inputs
operator|++
expr_stmt|;
name|info
operator|->
name|local_rvalue
index|[
name|i
index|]
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* For each local register that is a dying input, y_local[i] will be    copied to x_local[i].  We'll do this in ascending order.  Try to    re-order the locals to avoid conflicts like r3 = r2; r4 = r3; .    Return true iff the re-ordering is successful, or not necessary.  */
end_comment

begin_function
specifier|static
name|bool
name|resolve_input_conflict
parameter_list|(
name|struct
name|equiv_info
modifier|*
name|info
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|end
decl_stmt|;
name|int
name|nswaps
init|=
literal|0
decl_stmt|;
name|rtx
name|save_x_local
index|[
name|STRUCT_EQUIV_MAX_LOCAL
index|]
decl_stmt|;
name|rtx
name|save_y_local
index|[
name|STRUCT_EQUIV_MAX_LOCAL
index|]
decl_stmt|;
name|find_dying_inputs
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|dying_inputs
operator|<=
literal|1
condition|)
return|return
name|true
return|;
name|memcpy
argument_list|(
name|save_x_local
argument_list|,
name|info
operator|->
name|x_local
argument_list|,
sizeof|sizeof
name|save_x_local
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|save_y_local
argument_list|,
name|info
operator|->
name|y_local
argument_list|,
sizeof|sizeof
name|save_y_local
argument_list|)
expr_stmt|;
name|end
operator|=
name|info
operator|->
name|cur
operator|.
name|local_count
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|end
condition|;
name|i
operator|++
control|)
block|{
comment|/* Cycle detection with regsets is expensive, so we just check that 	 we don't exceed the maximum number of swaps needed in the acyclic 	 case.  */
name|int
name|max_swaps
init|=
name|end
operator|-
name|i
decl_stmt|;
comment|/* Check if x_local[i] will be clobbered.  */
if|if
condition|(
operator|!
name|info
operator|->
name|local_rvalue
index|[
name|i
index|]
condition|)
continue|continue;
comment|/* Check if any later value needs to be copied earlier.  */
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<=
name|end
condition|;
name|j
operator|++
control|)
block|{
name|rtx
name|tmp
decl_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|local_rvalue
index|[
name|j
index|]
condition|)
continue|continue;
if|if
condition|(
operator|!
name|reg_overlap_mentioned_p
argument_list|(
name|info
operator|->
name|x_local
index|[
name|i
index|]
argument_list|,
name|info
operator|->
name|y_local
index|[
name|j
index|]
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|--
name|max_swaps
operator|<
literal|0
condition|)
block|{
name|memcpy
argument_list|(
name|info
operator|->
name|x_local
argument_list|,
name|save_x_local
argument_list|,
sizeof|sizeof
name|save_x_local
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|info
operator|->
name|y_local
argument_list|,
name|save_y_local
argument_list|,
sizeof|sizeof
name|save_y_local
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|nswaps
operator|++
expr_stmt|;
name|tmp
operator|=
name|info
operator|->
name|x_local
index|[
name|i
index|]
expr_stmt|;
name|info
operator|->
name|x_local
index|[
name|i
index|]
operator|=
name|info
operator|->
name|x_local
index|[
name|j
index|]
expr_stmt|;
name|info
operator|->
name|x_local
index|[
name|j
index|]
operator|=
name|tmp
expr_stmt|;
name|tmp
operator|=
name|info
operator|->
name|y_local
index|[
name|i
index|]
expr_stmt|;
name|info
operator|->
name|y_local
index|[
name|i
index|]
operator|=
name|info
operator|->
name|y_local
index|[
name|j
index|]
expr_stmt|;
name|info
operator|->
name|y_local
index|[
name|j
index|]
operator|=
name|tmp
expr_stmt|;
name|j
operator|=
name|i
expr_stmt|;
block|}
block|}
name|info
operator|->
name|had_input_conflict
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
name|nswaps
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Resolved input conflict, %d %s.\n"
argument_list|,
name|nswaps
argument_list|,
name|nswaps
operator|==
literal|1
condition|?
literal|"swap"
else|:
literal|"swaps"
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

end_unit

