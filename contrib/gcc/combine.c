begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Optimize by combining instructions for GNU compiler.    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This module is essentially the "combiner" phase of the U. of Arizona    Portable Optimizer, but redone to work on our list-structured    representation for RTL instead of their string representation.     The LOG_LINKS of each insn identify the most recent assignment    to each REG used in the insn.  It is a list of previous insns,    each of which contains a SET for a REG that is used in this insn    and not used or set in between.  LOG_LINKs never cross basic blocks.    They were set up by the preceding pass (lifetime analysis).     We try to combine each pair of insns joined by a logical link.    We also try to combine triples of insns A, B and C when    C has a link back to B and B has a link back to A.     LOG_LINKS does not have links for use of the CC0.  They don't    need to, because the insn that sets the CC0 is always immediately    before the insn that tests it.  So we always regard a branch    insn as having a logical link to the preceding insn.  The same is true    for an insn explicitly using CC0.     We check (with use_crosses_set_p) to avoid combining in such a way    as to move a computation to a place where its value would be different.     Combination is done by mathematically substituting the previous    insn(s) values for the regs they set into the expressions in    the later insns that refer to these regs.  If the result is a valid insn    for our target machine, according to the machine description,    we install it, delete the earlier insns, and update the data flow    information (LOG_LINKS and REG_NOTES) for what we did.     There are a few exceptions where the dataflow information created by    flow.c aren't completely updated:     - reg_live_length is not updated    - reg_n_refs is not adjusted in the rare case when a register is      no longer required in a computation    - there are extremely rare cases (see distribute_regnotes) when a      REG_DEAD note is lost    - a LOG_LINKS entry that refers to an insn with multiple SETs may be      removed because there is no way to know which register it was      linking     To simplify substitution, we combine only when the earlier insn(s)    consist of only a single assignment.  To simplify updating afterward,    we never combine when a subroutine call appears in the middle.     Since we do not represent assignments to CC0 explicitly except when that    is all an insn does, there is no LOG_LINKS entry in an insn that uses    the condition code for the insn that set the condition code.    Fortunately, these two insns must be consecutive.    Therefore, every JUMP_INSN is taken to have an implicit logical link    to the preceding insn.  This is not quite right, since non-jumps can    also use the condition code; but in practice such insns would not    combine anyway.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_comment
comment|/* Include expr.h after insn-config.h so we get HAVE_conditional_move.  */
end_comment

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_comment
comment|/* It is not safe to use ordinary gen_lowpart in combine.    Use gen_lowpart_for_combine instead.  See comments there.  */
end_comment

begin_define
define|#
directive|define
name|gen_lowpart
value|dont_use_gen_lowpart_you_dummy
end_define

begin_comment
comment|/* Number of attempts to combine instructions in this function.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|combine_attempts
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of attempts that got as far as substitution in this function.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|combine_merges
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of instructions combined with added SETs in this function.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|combine_extras
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of instructions combined in this function.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|combine_successes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Totals over entire compilation.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|total_attempts
decl_stmt|,
name|total_merges
decl_stmt|,
name|total_extras
decl_stmt|,
name|total_successes
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Vector mapping INSN_UIDs to cuids.    The cuids are like uids but increase monotonically always.    Combine always uses cuids so that it can compare them.    But actually renumbering the uids, which we used to do,    proves to be a bad idea because it makes it hard to compare    the dumps produced by earlier passes with those from later passes.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|uid_cuid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|max_uid_cuid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Get the cuid of an insn.  */
end_comment

begin_define
define|#
directive|define
name|INSN_CUID
parameter_list|(
name|INSN
parameter_list|)
define|\
value|(INSN_UID (INSN)> max_uid_cuid ? insn_cuid (INSN) : uid_cuid[INSN_UID (INSN)])
end_define

begin_comment
comment|/* In case BITS_PER_WORD == HOST_BITS_PER_WIDE_INT, shifting by    BITS_PER_WORD would invoke undefined behavior.  Work around it.  */
end_comment

begin_define
define|#
directive|define
name|UWIDE_SHIFT_LEFT_BY_BITS_PER_WORD
parameter_list|(
name|val
parameter_list|)
define|\
value|(((unsigned HOST_WIDE_INT) (val)<< (BITS_PER_WORD - 1))<< 1)
end_define

begin_define
define|#
directive|define
name|nonzero_bits
parameter_list|(
name|X
parameter_list|,
name|M
parameter_list|)
define|\
value|cached_nonzero_bits (X, M, NULL_RTX, VOIDmode, 0)
end_define

begin_define
define|#
directive|define
name|num_sign_bit_copies
parameter_list|(
name|X
parameter_list|,
name|M
parameter_list|)
define|\
value|cached_num_sign_bit_copies (X, M, NULL_RTX, VOIDmode, 0)
end_define

begin_comment
comment|/* Maximum register number, which is the size of the tables below.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|combine_max_regno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record last point of death of (hard or pseudo) register n.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|reg_last_death
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record last point of modification of (hard or pseudo) register n.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|reg_last_set
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record the cuid of the last insn that invalidated memory    (anything that writes memory, and subroutine calls, but not pushes).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mem_last_set
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record the cuid of the last CALL_INSN    so we can tell whether a potential combination crosses any calls.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|last_call_cuid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When `subst' is called, this is the insn that is being modified    (by combining in a previous insn).  The PATTERN of this insn    is still the old pattern partially modified and it should not be    looked at, but this may be used to examine the successors of the insn    to judge whether a simplification is valid.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|subst_insn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is an insn that belongs before subst_insn, but is not currently    on the insn chain.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|subst_prev_insn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the lowest CUID that `subst' is currently dealing with.    get_last_value will not return a value if the register was set at or    after this CUID.  If not for this mechanism, we could get confused if    I2 or I1 in try_combine were an insn that used the old value of a register    to obtain a new value.  In that case, we might erroneously get the    new value of the register when we wanted the old one.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|subst_low_cuid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This contains any hard registers that are used in newpat; reg_dead_at_p    must consider all these registers to be always live.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|newpat_used_regs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is an insn to which a LOG_LINKS entry has been added.  If this    insn is the earlier than I2 or I3, combine should rescan starting at    that location.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|added_links_insn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Basic block in which we are performing combines.  */
end_comment

begin_decl_stmt
specifier|static
name|basic_block
name|this_basic_block
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A bitmap indicating which blocks had registers go dead at entry.    After combine, we'll need to re-do global life analysis with    those blocks as starting points.  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
name|refresh_blocks
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|need_refresh
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* The next group of arrays allows the recording of the last value assigned    to (hard or pseudo) register n.  We use this information to see if an    operation being processed is redundant given a prior operation performed    on the register.  For example, an `and' with a constant is redundant if    all the zero bits are already known to be turned off.     We use an approach similar to that used by cse, but change it in the    following ways:     (1) We do not want to reinitialize at each label.    (2) It is useful, but not critical, to know the actual value assigned        to a register.  Often just its form is helpful.     Therefore, we maintain the following arrays:     reg_last_set_value		the last value assigned    reg_last_set_label		records the value of label_tick when the 				register was assigned    reg_last_set_table_tick	records the value of label_tick when a 				value using the register is assigned    reg_last_set_invalid		set to nonzero when it is not valid 				to use the value of this register in some 				register's value     To understand the usage of these tables, it is important to understand    the distinction between the value in reg_last_set_value being valid    and the register being validly contained in some other expression in the    table.     Entry I in reg_last_set_value is valid if it is nonzero, and either    reg_n_sets[i] is 1 or reg_last_set_label[i] == label_tick.     Register I may validly appear in any expression returned for the value    of another register if reg_n_sets[i] is 1.  It may also appear in the    value for register J if reg_last_set_label[i]< reg_last_set_label[j] or    reg_last_set_invalid[j] is zero.     If an expression is found in the table containing a register which may    not validly appear in an expression, the register is replaced by    something that won't match, (clobber (const_int 0)).     reg_last_set_invalid[i] is set nonzero when register I is being assigned    to and reg_last_set_table_tick[i] == label_tick.  */
end_comment

begin_comment
comment|/* Record last value assigned to (hard or pseudo) register n.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|reg_last_set_value
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record the value of label_tick when the value for register n is placed in    reg_last_set_value[n].  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|reg_last_set_label
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record the value of label_tick when an expression involving register n    is placed in reg_last_set_value.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|reg_last_set_table_tick
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set nonzero if references to register n in expressions should not be    used.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|reg_last_set_invalid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Incremented for each label.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|label_tick
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Some registers that are set more than once and used in more than one    basic block are nevertheless always set in similar ways.  For example,    a QImode register may be loaded from memory in two places on a machine    where byte loads zero extend.     We record in the following array what we know about the nonzero    bits of a register, specifically which bits are known to be zero.     If an entry is zero, it means that we don't know anything special.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|HOST_WIDE_INT
modifier|*
name|reg_nonzero_bits
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mode used to compute significance in reg_nonzero_bits.  It is the largest    integer mode that can fit in HOST_BITS_PER_WIDE_INT.  */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|machine_mode
name|nonzero_bits_mode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we know that a register has some leading bits that are always    equal to the sign bit.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
modifier|*
name|reg_sign_bit_copies
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero when reg_nonzero_bits and reg_sign_bit_copies can be safely used.    It is zero while computing them and after combine has completed.  This    former test prevents propagating values based on previously set values,    which can be incorrect if a variable is modified in a loop.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nonzero_sign_valid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These arrays are maintained in parallel with reg_last_set_value    and are used to store the mode in which the register was last set,    the bits that were known to be zero when it was last set, and the    number of sign bits copies it was known to have when it was last set.  */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|machine_mode
modifier|*
name|reg_last_set_mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|HOST_WIDE_INT
modifier|*
name|reg_last_set_nonzero_bits
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|reg_last_set_sign_bit_copies
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Record one modification to rtl structure    to be undone by storing old_contents into *where.    is_int is 1 if the contents are an int.  */
end_comment

begin_struct
struct|struct
name|undo
block|{
name|struct
name|undo
modifier|*
name|next
decl_stmt|;
name|int
name|is_int
decl_stmt|;
union|union
block|{
name|rtx
name|r
decl_stmt|;
name|int
name|i
decl_stmt|;
block|}
name|old_contents
union|;
union|union
block|{
name|rtx
modifier|*
name|r
decl_stmt|;
name|int
modifier|*
name|i
decl_stmt|;
block|}
name|where
union|;
block|}
struct|;
end_struct

begin_comment
comment|/* Record a bunch of changes to be undone, up to MAX_UNDO of them.    num_undo says how many are currently recorded.     other_insn is nonzero if we have modified some other insn in the process    of working on subst_insn.  It must be verified too.  */
end_comment

begin_struct
struct|struct
name|undobuf
block|{
name|struct
name|undo
modifier|*
name|undos
decl_stmt|;
name|struct
name|undo
modifier|*
name|frees
decl_stmt|;
name|rtx
name|other_insn
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|undobuf
name|undobuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of times the pseudo being substituted for    was found and replaced.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|n_occurrences
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_SUBST
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|*
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_SUBST_INT
name|PARAMS
argument_list|(
operator|(
name|int
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_reg_last_arrays
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|setup_incoming_promotions
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_nonzero_bits_and_sign_copies
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cant_combine_insn_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|can_combine_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|*
operator|,
name|rtx
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sets_function_arg_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|combinable_i3pat
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|*
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|,
name|rtx
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|contains_muldiv
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|try_combine
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|undo_all
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|undo_commit
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|find_split_point
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|*
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|subst
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|combine_simplify_rtx
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
expr|enum
name|machine_mode
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|simplify_if_then_else
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|simplify_set
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|simplify_logical
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|expand_compound_operation
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|expand_field_assignment
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|make_extraction
name|PARAMS
argument_list|(
operator|(
expr|enum
name|machine_mode
operator|,
name|rtx
operator|,
name|HOST_WIDE_INT
operator|,
name|rtx
operator|,
name|unsigned
name|HOST_WIDE_INT
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|extract_left_shift
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|make_compound_operation
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
expr|enum
name|rtx_code
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_pos_from_mask
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|,
name|unsigned
name|HOST_WIDE_INT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|force_to_mode
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
expr|enum
name|machine_mode
operator|,
name|unsigned
name|HOST_WIDE_INT
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|if_then_else_cond
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|*
operator|,
name|rtx
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|known_cond
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
expr|enum
name|rtx_code
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rtx_equal_for_field_assignment_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|make_field_assignment
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|apply_distributive_law
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|simplify_and_const_int
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
expr|enum
name|machine_mode
operator|,
name|rtx
operator|,
name|unsigned
name|HOST_WIDE_INT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|HOST_WIDE_INT
name|cached_nonzero_bits
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
expr|enum
name|machine_mode
operator|,
name|rtx
operator|,
expr|enum
name|machine_mode
operator|,
name|unsigned
name|HOST_WIDE_INT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|HOST_WIDE_INT
name|nonzero_bits1
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
expr|enum
name|machine_mode
operator|,
name|rtx
operator|,
expr|enum
name|machine_mode
operator|,
name|unsigned
name|HOST_WIDE_INT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|cached_num_sign_bit_copies
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
expr|enum
name|machine_mode
operator|,
name|rtx
operator|,
expr|enum
name|machine_mode
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|num_sign_bit_copies1
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
expr|enum
name|machine_mode
operator|,
name|rtx
operator|,
expr|enum
name|machine_mode
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|merge_outer_ops
name|PARAMS
argument_list|(
operator|(
expr|enum
name|rtx_code
operator|*
operator|,
name|HOST_WIDE_INT
operator|*
operator|,
expr|enum
name|rtx_code
operator|,
name|HOST_WIDE_INT
operator|,
expr|enum
name|machine_mode
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|simplify_shift_const
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
expr|enum
name|rtx_code
operator|,
expr|enum
name|machine_mode
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|recog_for_combine
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|*
operator|,
name|rtx
operator|,
name|rtx
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|gen_lowpart_for_combine
name|PARAMS
argument_list|(
operator|(
expr|enum
name|machine_mode
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|gen_binary
name|PARAMS
argument_list|(
operator|(
expr|enum
name|rtx_code
operator|,
expr|enum
name|machine_mode
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|rtx_code
name|simplify_comparison
name|PARAMS
argument_list|(
operator|(
expr|enum
name|rtx_code
operator|,
name|rtx
operator|*
operator|,
name|rtx
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|update_table_tick
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|record_value_for_reg
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|check_promoted_subreg
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|record_dead_and_set_regs_1
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|record_dead_and_set_regs
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_last_value_validate
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|*
operator|,
name|rtx
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|get_last_value
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|use_crosses_set_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reg_dead_at_p_1
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reg_dead_at_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|move_deaths
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|,
name|rtx
operator|,
name|rtx
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reg_bitfield_target_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|distribute_notes
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|distribute_links
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_used_regs_combine
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|insn_cuid
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|record_promoted_value
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|reversed_comparison
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
expr|enum
name|machine_mode
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|rtx_code
name|combine_reversed_comparison_code
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Substitute NEWVAL, an rtx expression, into INTO, a place in some    insn.  The substitution can be undone by undo_all.  If INTO is already    set to NEWVAL, do not record this change.  Because computing NEWVAL might    also call SUBST, we have to compute it before we put anything into    the undo table.  */
end_comment

begin_function
specifier|static
name|void
name|do_SUBST
parameter_list|(
name|into
parameter_list|,
name|newval
parameter_list|)
name|rtx
modifier|*
name|into
decl_stmt|,
name|newval
decl_stmt|;
block|{
name|struct
name|undo
modifier|*
name|buf
decl_stmt|;
name|rtx
name|oldval
init|=
operator|*
name|into
decl_stmt|;
if|if
condition|(
name|oldval
operator|==
name|newval
condition|)
return|return;
comment|/* We'd like to catch as many invalid transformations here as      possible.  Unfortunately, there are way too many mode changes      that are perfectly valid, so we'd waste too much effort for      little gain doing the checks here.  Focus on catching invalid      transformations involving integer constants.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|oldval
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|GET_CODE
argument_list|(
name|newval
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
comment|/* Sanity check that we're replacing oldval with a CONST_INT 	 that is a valid sign-extension for the original mode.  */
if|if
condition|(
name|INTVAL
argument_list|(
name|newval
argument_list|)
operator|!=
name|trunc_int_for_mode
argument_list|(
name|INTVAL
argument_list|(
name|newval
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|oldval
argument_list|)
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Replacing the operand of a SUBREG or a ZERO_EXTEND with a 	 CONST_INT is not valid, because after the replacement, the 	 original mode would be gone.  Unfortunately, we can't tell 	 when do_SUBST is called to replace the operand thereof, so we 	 perform this test on oldval instead, checking whether an 	 invalid replacement took place before we got here.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|oldval
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|oldval
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|oldval
argument_list|)
operator|==
name|ZERO_EXTEND
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|oldval
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|undobuf
operator|.
name|frees
condition|)
name|buf
operator|=
name|undobuf
operator|.
name|frees
operator|,
name|undobuf
operator|.
name|frees
operator|=
name|buf
operator|->
name|next
expr_stmt|;
else|else
name|buf
operator|=
operator|(
expr|struct
name|undo
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|undo
argument_list|)
argument_list|)
expr_stmt|;
name|buf
operator|->
name|is_int
operator|=
literal|0
expr_stmt|;
name|buf
operator|->
name|where
operator|.
name|r
operator|=
name|into
expr_stmt|;
name|buf
operator|->
name|old_contents
operator|.
name|r
operator|=
name|oldval
expr_stmt|;
operator|*
name|into
operator|=
name|newval
expr_stmt|;
name|buf
operator|->
name|next
operator|=
name|undobuf
operator|.
name|undos
operator|,
name|undobuf
operator|.
name|undos
operator|=
name|buf
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|SUBST
parameter_list|(
name|INTO
parameter_list|,
name|NEWVAL
parameter_list|)
value|do_SUBST(&(INTO), (NEWVAL))
end_define

begin_comment
comment|/* Similar to SUBST, but NEWVAL is an int expression.  Note that substitution    for the value of a HOST_WIDE_INT value (including CONST_INT) is    not safe.  */
end_comment

begin_function
specifier|static
name|void
name|do_SUBST_INT
parameter_list|(
name|into
parameter_list|,
name|newval
parameter_list|)
name|int
modifier|*
name|into
decl_stmt|,
name|newval
decl_stmt|;
block|{
name|struct
name|undo
modifier|*
name|buf
decl_stmt|;
name|int
name|oldval
init|=
operator|*
name|into
decl_stmt|;
if|if
condition|(
name|oldval
operator|==
name|newval
condition|)
return|return;
if|if
condition|(
name|undobuf
operator|.
name|frees
condition|)
name|buf
operator|=
name|undobuf
operator|.
name|frees
operator|,
name|undobuf
operator|.
name|frees
operator|=
name|buf
operator|->
name|next
expr_stmt|;
else|else
name|buf
operator|=
operator|(
expr|struct
name|undo
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|undo
argument_list|)
argument_list|)
expr_stmt|;
name|buf
operator|->
name|is_int
operator|=
literal|1
expr_stmt|;
name|buf
operator|->
name|where
operator|.
name|i
operator|=
name|into
expr_stmt|;
name|buf
operator|->
name|old_contents
operator|.
name|i
operator|=
name|oldval
expr_stmt|;
operator|*
name|into
operator|=
name|newval
expr_stmt|;
name|buf
operator|->
name|next
operator|=
name|undobuf
operator|.
name|undos
operator|,
name|undobuf
operator|.
name|undos
operator|=
name|buf
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|SUBST_INT
parameter_list|(
name|INTO
parameter_list|,
name|NEWVAL
parameter_list|)
value|do_SUBST_INT(&(INTO), (NEWVAL))
end_define

begin_escape
end_escape

begin_comment
comment|/* Main entry point for combiner.  F is the first insn of the function.    NREGS is the first unused pseudo-reg number.     Return nonzero if the combiner has turned an indirect jump    instruction into a direct jump.  */
end_comment

begin_function
name|int
name|combine_instructions
parameter_list|(
name|f
parameter_list|,
name|nregs
parameter_list|)
name|rtx
name|f
decl_stmt|;
name|unsigned
name|int
name|nregs
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|,
name|next
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
name|rtx
name|prev
decl_stmt|;
endif|#
directive|endif
name|int
name|i
decl_stmt|;
name|rtx
name|links
decl_stmt|,
name|nextlinks
decl_stmt|;
name|int
name|new_direct_jump_p
init|=
literal|0
decl_stmt|;
name|combine_attempts
operator|=
literal|0
expr_stmt|;
name|combine_merges
operator|=
literal|0
expr_stmt|;
name|combine_extras
operator|=
literal|0
expr_stmt|;
name|combine_successes
operator|=
literal|0
expr_stmt|;
name|combine_max_regno
operator|=
name|nregs
expr_stmt|;
name|reg_nonzero_bits
operator|=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|*
operator|)
name|xcalloc
argument_list|(
name|nregs
argument_list|,
expr|sizeof
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
argument_list|)
operator|)
expr_stmt|;
name|reg_sign_bit_copies
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xcalloc
argument_list|(
name|nregs
argument_list|,
expr|sizeof
operator|(
name|unsigned
name|char
operator|)
argument_list|)
expr_stmt|;
name|reg_last_death
operator|=
operator|(
name|rtx
operator|*
operator|)
name|xmalloc
argument_list|(
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|reg_last_set
operator|=
operator|(
name|rtx
operator|*
operator|)
name|xmalloc
argument_list|(
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|reg_last_set_value
operator|=
operator|(
name|rtx
operator|*
operator|)
name|xmalloc
argument_list|(
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|reg_last_set_table_tick
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|reg_last_set_label
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|reg_last_set_invalid
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|reg_last_set_mode
operator|=
operator|(
expr|enum
name|machine_mode
operator|*
operator|)
name|xmalloc
argument_list|(
name|nregs
operator|*
sizeof|sizeof
argument_list|(
expr|enum
name|machine_mode
argument_list|)
argument_list|)
expr_stmt|;
name|reg_last_set_nonzero_bits
operator|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|*
operator|)
name|xmalloc
argument_list|(
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|HOST_WIDE_INT
argument_list|)
argument_list|)
expr_stmt|;
name|reg_last_set_sign_bit_copies
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|init_reg_last_arrays
argument_list|()
expr_stmt|;
name|init_recog_no_volatile
argument_list|()
expr_stmt|;
comment|/* Compute maximum uid value so uid_cuid can be allocated.  */
for|for
control|(
name|insn
operator|=
name|f
operator|,
name|i
operator|=
literal|0
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|>
name|i
condition|)
name|i
operator|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|uid_cuid
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|max_uid_cuid
operator|=
name|i
expr_stmt|;
name|nonzero_bits_mode
operator|=
name|mode_for_size
argument_list|(
name|HOST_BITS_PER_WIDE_INT
argument_list|,
name|MODE_INT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Don't use reg_nonzero_bits when computing it.  This can cause problems      when, for example, we have j<<= 1 in a loop.  */
name|nonzero_sign_valid
operator|=
literal|0
expr_stmt|;
comment|/* Compute the mapping from uids to cuids.      Cuids are numbers assigned to insns, like uids,      except that cuids increase monotonically through the code.       Scan all SETs and see if we can deduce anything about what      bits are known to be zero for some registers and how many copies      of the sign bit are known to exist for those registers.       Also set any known values so that we can use it while searching      for what bits are known to be set.  */
name|label_tick
operator|=
literal|1
expr_stmt|;
comment|/* We need to initialize it here, because record_dead_and_set_regs may call      get_last_value.  */
name|subst_prev_insn
operator|=
name|NULL_RTX
expr_stmt|;
name|setup_incoming_promotions
argument_list|()
expr_stmt|;
name|refresh_blocks
operator|=
name|sbitmap_alloc
argument_list|(
name|last_basic_block
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|refresh_blocks
argument_list|)
expr_stmt|;
name|need_refresh
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|f
operator|,
name|i
operator|=
literal|0
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|uid_cuid
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
operator|=
operator|++
name|i
expr_stmt|;
name|subst_low_cuid
operator|=
name|i
expr_stmt|;
name|subst_insn
operator|=
name|insn
expr_stmt|;
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|set_nonzero_bits_and_sign_copies
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|record_dead_and_set_regs
argument_list|(
name|insn
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
for|for
control|(
name|links
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|links
condition|;
name|links
operator|=
name|XEXP
argument_list|(
name|links
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|links
argument_list|)
operator|==
name|REG_INC
condition|)
name|set_nonzero_bits_and_sign_copies
argument_list|(
name|XEXP
argument_list|(
name|links
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|label_tick
operator|++
expr_stmt|;
block|}
name|nonzero_sign_valid
operator|=
literal|1
expr_stmt|;
comment|/* Now scan all the insns in forward order.  */
name|label_tick
operator|=
literal|1
expr_stmt|;
name|last_call_cuid
operator|=
literal|0
expr_stmt|;
name|mem_last_set
operator|=
literal|0
expr_stmt|;
name|init_reg_last_arrays
argument_list|()
expr_stmt|;
name|setup_incoming_promotions
argument_list|()
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|this_basic_block
argument_list|)
block|{
for|for
control|(
name|insn
operator|=
name|this_basic_block
operator|->
name|head
init|;
name|insn
operator|!=
name|NEXT_INSN
argument_list|(
name|this_basic_block
operator|->
name|end
argument_list|)
condition|;
name|insn
operator|=
name|next
condition|?
name|next
else|:
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|next
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|label_tick
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
comment|/* See if we know about function return values before this 		 insn based upon SUBREG flags.  */
name|check_promoted_subreg
argument_list|(
name|insn
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Try this insn with each insn it links back to.  */
for|for
control|(
name|links
operator|=
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
init|;
name|links
condition|;
name|links
operator|=
name|XEXP
argument_list|(
name|links
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
operator|(
name|next
operator|=
name|try_combine
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|links
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
operator|&
name|new_direct_jump_p
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|retry
goto|;
comment|/* Try each sequence of three linked insns ending with this one.  */
for|for
control|(
name|links
operator|=
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
init|;
name|links
condition|;
name|links
operator|=
name|XEXP
argument_list|(
name|links
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|rtx
name|link
init|=
name|XEXP
argument_list|(
name|links
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* If the linked insn has been replaced by a note, then there 		     is no point in pursuing this chain any further.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|link
argument_list|)
operator|==
name|NOTE
condition|)
continue|continue;
for|for
control|(
name|nextlinks
operator|=
name|LOG_LINKS
argument_list|(
name|link
argument_list|)
init|;
name|nextlinks
condition|;
name|nextlinks
operator|=
name|XEXP
argument_list|(
name|nextlinks
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
operator|(
name|next
operator|=
name|try_combine
argument_list|(
name|insn
argument_list|,
name|link
argument_list|,
name|XEXP
argument_list|(
name|nextlinks
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|new_direct_jump_p
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|retry
goto|;
block|}
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* Try to combine a jump insn that uses CC0 		 with a preceding insn that sets CC0, and maybe with its 		 logical predecessor as well. 		 This is how we make decrement-and-branch insns. 		 We need this special code because data flow connections 		 via CC0 do not get entered in LOG_LINKS.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|prev
operator|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|prev
argument_list|)
operator|==
name|INSN
operator|&&
name|sets_cc0_p
argument_list|(
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|next
operator|=
name|try_combine
argument_list|(
name|insn
argument_list|,
name|prev
argument_list|,
name|NULL_RTX
argument_list|,
operator|&
name|new_direct_jump_p
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|retry
goto|;
for|for
control|(
name|nextlinks
operator|=
name|LOG_LINKS
argument_list|(
name|prev
argument_list|)
init|;
name|nextlinks
condition|;
name|nextlinks
operator|=
name|XEXP
argument_list|(
name|nextlinks
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
operator|(
name|next
operator|=
name|try_combine
argument_list|(
name|insn
argument_list|,
name|prev
argument_list|,
name|XEXP
argument_list|(
name|nextlinks
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|new_direct_jump_p
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|retry
goto|;
block|}
comment|/* Do the same for an insn that explicitly references CC0.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
operator|(
name|prev
operator|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|prev
argument_list|)
operator|==
name|INSN
operator|&&
name|sets_cc0_p
argument_list|(
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|reg_mentioned_p
argument_list|(
name|cc0_rtx
argument_list|,
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|next
operator|=
name|try_combine
argument_list|(
name|insn
argument_list|,
name|prev
argument_list|,
name|NULL_RTX
argument_list|,
operator|&
name|new_direct_jump_p
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|retry
goto|;
for|for
control|(
name|nextlinks
operator|=
name|LOG_LINKS
argument_list|(
name|prev
argument_list|)
init|;
name|nextlinks
condition|;
name|nextlinks
operator|=
name|XEXP
argument_list|(
name|nextlinks
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
operator|(
name|next
operator|=
name|try_combine
argument_list|(
name|insn
argument_list|,
name|prev
argument_list|,
name|XEXP
argument_list|(
name|nextlinks
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|new_direct_jump_p
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|retry
goto|;
block|}
comment|/* Finally, see if any of the insns that this insn links to 		 explicitly references CC0.  If so, try this insn, that insn, 		 and its predecessor if it sets CC0.  */
for|for
control|(
name|links
operator|=
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
init|;
name|links
condition|;
name|links
operator|=
name|XEXP
argument_list|(
name|links
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|links
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|XEXP
argument_list|(
name|links
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|reg_mentioned_p
argument_list|(
name|cc0_rtx
argument_list|,
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|XEXP
argument_list|(
name|links
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|(
name|prev
operator|=
name|prev_nonnote_insn
argument_list|(
name|XEXP
argument_list|(
name|links
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|prev
argument_list|)
operator|==
name|INSN
operator|&&
name|sets_cc0_p
argument_list|(
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|)
operator|&&
operator|(
name|next
operator|=
name|try_combine
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|links
argument_list|,
literal|0
argument_list|)
argument_list|,
name|prev
argument_list|,
operator|&
name|new_direct_jump_p
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|retry
goto|;
endif|#
directive|endif
comment|/* Try combining an insn with two different insns whose results it 		 uses.  */
for|for
control|(
name|links
operator|=
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
init|;
name|links
condition|;
name|links
operator|=
name|XEXP
argument_list|(
name|links
argument_list|,
literal|1
argument_list|)
control|)
for|for
control|(
name|nextlinks
operator|=
name|XEXP
argument_list|(
name|links
argument_list|,
literal|1
argument_list|)
init|;
name|nextlinks
condition|;
name|nextlinks
operator|=
name|XEXP
argument_list|(
name|nextlinks
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
operator|(
name|next
operator|=
name|try_combine
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|links
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|nextlinks
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|new_direct_jump_p
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|retry
goto|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
condition|)
name|record_dead_and_set_regs
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|retry
label|:
empty_stmt|;
block|}
block|}
block|}
name|clear_bb_flags
argument_list|()
expr_stmt|;
name|EXECUTE_IF_SET_IN_SBITMAP
argument_list|(
name|refresh_blocks
argument_list|,
literal|0
argument_list|,
name|i
argument_list|,
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
operator|->
name|flags
operator||=
name|BB_DIRTY
argument_list|)
expr_stmt|;
name|new_direct_jump_p
operator||=
name|purge_all_dead_edges
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|delete_noop_moves
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|update_life_info_in_dirty_blocks
argument_list|(
name|UPDATE_LIFE_GLOBAL_RM_NOTES
argument_list|,
name|PROP_DEATH_NOTES
operator||
name|PROP_SCAN_DEAD_CODE
operator||
name|PROP_KILL_DEAD_CODE
argument_list|)
expr_stmt|;
comment|/* Clean up.  */
name|sbitmap_free
argument_list|(
name|refresh_blocks
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reg_nonzero_bits
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reg_sign_bit_copies
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reg_last_death
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reg_last_set
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reg_last_set_value
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reg_last_set_table_tick
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reg_last_set_label
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reg_last_set_invalid
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reg_last_set_mode
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reg_last_set_nonzero_bits
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reg_last_set_sign_bit_copies
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|uid_cuid
argument_list|)
expr_stmt|;
block|{
name|struct
name|undo
modifier|*
name|undo
decl_stmt|,
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|undo
operator|=
name|undobuf
operator|.
name|frees
init|;
name|undo
condition|;
name|undo
operator|=
name|next
control|)
block|{
name|next
operator|=
name|undo
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|undo
argument_list|)
expr_stmt|;
block|}
name|undobuf
operator|.
name|frees
operator|=
literal|0
expr_stmt|;
block|}
name|total_attempts
operator|+=
name|combine_attempts
expr_stmt|;
name|total_merges
operator|+=
name|combine_merges
expr_stmt|;
name|total_extras
operator|+=
name|combine_extras
expr_stmt|;
name|total_successes
operator|+=
name|combine_successes
expr_stmt|;
name|nonzero_sign_valid
operator|=
literal|0
expr_stmt|;
comment|/* Make recognizer allow volatile MEMs again.  */
name|init_recog
argument_list|()
expr_stmt|;
return|return
name|new_direct_jump_p
return|;
block|}
end_function

begin_comment
comment|/* Wipe the reg_last_xxx arrays in preparation for another pass.  */
end_comment

begin_function
specifier|static
name|void
name|init_reg_last_arrays
parameter_list|()
block|{
name|unsigned
name|int
name|nregs
init|=
name|combine_max_regno
decl_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_last_death
argument_list|,
literal|0
argument_list|,
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_last_set
argument_list|,
literal|0
argument_list|,
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_last_set_value
argument_list|,
literal|0
argument_list|,
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_last_set_table_tick
argument_list|,
literal|0
argument_list|,
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_last_set_label
argument_list|,
literal|0
argument_list|,
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|reg_last_set_invalid
argument_list|,
literal|0
argument_list|,
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_last_set_mode
argument_list|,
literal|0
argument_list|,
name|nregs
operator|*
sizeof|sizeof
argument_list|(
expr|enum
name|machine_mode
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_last_set_nonzero_bits
argument_list|,
literal|0
argument_list|,
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|HOST_WIDE_INT
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|reg_last_set_sign_bit_copies
argument_list|,
literal|0
argument_list|,
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set up any promoted values for incoming argument registers.  */
end_comment

begin_function
specifier|static
name|void
name|setup_incoming_promotions
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|PROMOTE_FUNCTION_ARGS
name|unsigned
name|int
name|regno
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|rtx
name|first
init|=
name|get_insns
argument_list|()
decl_stmt|;
ifndef|#
directive|ifndef
name|OUTGOING_REGNO
define|#
directive|define
name|OUTGOING_REGNO
parameter_list|(
name|N
parameter_list|)
value|N
endif|#
directive|endif
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
comment|/* Check whether this register can hold an incoming pointer        argument.  FUNCTION_ARG_REGNO_P tests outgoing register        numbers, so translate if necessary due to register windows.  */
if|if
condition|(
name|FUNCTION_ARG_REGNO_P
argument_list|(
name|OUTGOING_REGNO
argument_list|(
name|regno
argument_list|)
argument_list|)
operator|&&
operator|(
name|reg
operator|=
name|promoted_input_arg
argument_list|(
name|regno
argument_list|,
operator|&
name|mode
argument_list|,
operator|&
name|unsignedp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|record_value_for_reg
argument_list|(
name|reg
argument_list|,
name|first
argument_list|,
name|gen_rtx_fmt_e
argument_list|(
operator|(
name|unsignedp
condition|?
name|ZERO_EXTEND
else|:
name|SIGN_EXTEND
operator|)
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|gen_rtx_CLOBBER
argument_list|(
name|mode
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Called via note_stores.  If X is a pseudo that is narrower than    HOST_BITS_PER_WIDE_INT and is being set, record what bits are known zero.     If we are setting only a portion of X and we can't figure out what    portion, assume all bits will be used since we don't know what will    be happening.     Similarly, set how many bits of X are known to be copies of the sign bit    at all locations in the function.  This is the smallest number implied    by any set of X.  */
end_comment

begin_function
specifier|static
name|void
name|set_nonzero_bits_and_sign_copies
parameter_list|(
name|x
parameter_list|,
name|set
parameter_list|,
name|data
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|set
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|unsigned
name|int
name|num
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
comment|/* If this register is undefined at the start of the file, we can't 	 say what its contents were.  */
operator|&&
operator|!
name|REGNO_REG_SET_P
argument_list|(
name|ENTRY_BLOCK_PTR
operator|->
name|next_bb
operator|->
name|global_live_at_start
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
if|if
condition|(
name|set
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|set
argument_list|)
operator|==
name|CLOBBER
condition|)
block|{
name|reg_nonzero_bits
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
operator|=
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|reg_sign_bit_copies
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
operator|=
literal|1
expr_stmt|;
return|return;
block|}
comment|/* If this is a complex assignment, see if we can convert it into a 	 simple assignment.  */
name|set
operator|=
name|expand_field_assignment
argument_list|(
name|set
argument_list|)
expr_stmt|;
comment|/* If this is a simple assignment, or we have a paradoxical SUBREG, 	 set what we know about X.  */
if|if
condition|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|==
name|x
operator|||
operator|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|x
operator|)
condition|)
block|{
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|SHORT_IMMEDIATES_SIGN_EXTEND
comment|/* If X is narrower than a word and SRC is a non-negative 	     constant that would appear negative in the mode of X, 	     sign-extend it for use in reg_nonzero_bits because some 	     machines (maybe most) will actually do the sign-extension 	     and this is the conservative approach.  	     ??? For 2.5, try to tighten up the MD files in this regard 	     instead of this kludge.  */
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<
name|BITS_PER_WORD
operator|&&
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|src
argument_list|)
operator|>
literal|0
operator|&&
literal|0
operator|!=
operator|(
name|INTVAL
argument_list|(
name|src
argument_list|)
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
name|src
operator|=
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|src
argument_list|)
operator||
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Don't call nonzero_bits if it cannot change anything.  */
if|if
condition|(
name|reg_nonzero_bits
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
operator|!=
operator|~
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0
condition|)
name|reg_nonzero_bits
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
operator||=
name|nonzero_bits
argument_list|(
name|src
argument_list|,
name|nonzero_bits_mode
argument_list|)
expr_stmt|;
name|num
operator|=
name|num_sign_bit_copies
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_sign_bit_copies
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
operator|==
literal|0
operator|||
name|reg_sign_bit_copies
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
operator|>
name|num
condition|)
name|reg_sign_bit_copies
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
operator|=
name|num
expr_stmt|;
block|}
else|else
block|{
name|reg_nonzero_bits
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
operator|=
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|reg_sign_bit_copies
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* See if INSN can be combined into I3.  PRED and SUCC are optionally    insns that were previously combined into I3 or that will be combined    into the merger of INSN and I3.     Return 0 if the combination is not allowed for any reason.     If the combination is allowed, *PDEST will be set to the single    destination of INSN and *PSRC to the single source, and this function    will return 1.  */
end_comment

begin_function
specifier|static
name|int
name|can_combine_p
parameter_list|(
name|insn
parameter_list|,
name|i3
parameter_list|,
name|pred
parameter_list|,
name|succ
parameter_list|,
name|pdest
parameter_list|,
name|psrc
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|i3
decl_stmt|;
name|rtx
name|pred
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|rtx
name|succ
decl_stmt|;
name|rtx
modifier|*
name|pdest
decl_stmt|,
decl|*
name|psrc
decl_stmt|;
end_function

begin_block
block|{
name|int
name|i
decl_stmt|;
name|rtx
name|set
init|=
literal|0
decl_stmt|,
name|src
decl_stmt|,
name|dest
decl_stmt|;
name|rtx
name|p
decl_stmt|;
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
name|rtx
name|link
decl_stmt|;
endif|#
directive|endif
name|int
name|all_adjacent
init|=
operator|(
name|succ
condition|?
operator|(
name|next_active_insn
argument_list|(
name|insn
argument_list|)
operator|==
name|succ
operator|&&
name|next_active_insn
argument_list|(
name|succ
argument_list|)
operator|==
name|i3
operator|)
else|:
name|next_active_insn
argument_list|(
name|insn
argument_list|)
operator|==
name|i3
operator|)
decl_stmt|;
comment|/* Can combine only if previous insn is a SET of a REG, a SUBREG or CC0.      or a PARALLEL consisting of such a SET and CLOBBERs.       If INSN has CLOBBER parallel parts, ignore them for our processing.      By definition, these happen during the execution of the insn.  When it      is merged with another insn, all bets are off.  If they are, in fact,      needed and aren't also supplied in I3, they may be added by      recog_for_combine.  Otherwise, it won't match.       We can also ignore a SET whose SET_DEST is mentioned in a REG_UNUSED      note.       Get the source and destination of INSN.  If more than one, can't      combine.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
name|set
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|elt
init|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|elt
argument_list|)
condition|)
block|{
comment|/* This is important to combine floating point insns 	       for the SH4 port.  */
case|case
name|USE
case|:
comment|/* Combining an isolated USE doesn't make sense. 		 We depend here on combinable_i3pat to reject them.  */
comment|/* The code below this loop only verifies that the inputs of 		 the SET in INSN do not change.  We call reg_set_between_p 		 to verify that the REG in the USE does not change between 		 I3 and INSN. 		 If the USE in INSN was for a pseudo register, the matching 		 insn pattern will likely match any register; combining this 		 with any other USE would only be safe if we knew that the 		 used registers have identical values, or if there was 		 something to tell them apart, e.g. different modes.  For 		 now, we forgo such complicated tests and simply disallow 		 combining of USES of pseudo registers with any other USE.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|elt
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|rtx
name|i3pat
init|=
name|PATTERN
argument_list|(
name|i3
argument_list|)
decl_stmt|;
name|int
name|i
init|=
name|XVECLEN
argument_list|(
name|i3pat
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
decl_stmt|;
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|elt
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
do|do
block|{
name|rtx
name|i3elt
init|=
name|XVECEXP
argument_list|(
name|i3pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|i3elt
argument_list|)
operator|==
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|i3elt
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|i3elt
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|regno
condition|?
name|reg_set_between_p
argument_list|(
name|XEXP
argument_list|(
name|elt
argument_list|,
literal|0
argument_list|)
argument_list|,
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|i3
argument_list|)
else|:
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
return|return
literal|0
return|;
block|}
do|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
do|;
block|}
break|break;
comment|/* We can ignore CLOBBERs.  */
case|case
name|CLOBBER
case|:
break|break;
case|case
name|SET
case|:
comment|/* Ignore SETs whose result isn't used but not those that 		 have side-effects.  */
if|if
condition|(
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_UNUSED
argument_list|,
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|elt
argument_list|)
condition|)
break|break;
comment|/* If we have already found a SET, this is a second one and 		 so we cannot combine with this insn.  */
if|if
condition|(
name|set
condition|)
return|return
literal|0
return|;
name|set
operator|=
name|elt
expr_stmt|;
break|break;
default|default:
comment|/* Anything else means we can't combine.  */
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
name|set
operator|==
literal|0
comment|/* If SET_SRC is an ASM_OPERANDS we can't throw away these CLOBBERs, 	     so don't do anything with it.  */
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
return|return
literal|0
return|;
block|}
else|else
return|return
literal|0
return|;
if|if
condition|(
name|set
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|set
operator|=
name|expand_field_assignment
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|src
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
operator|,
name|dest
operator|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
expr_stmt|;
comment|/* Don't eliminate a store in the stack pointer.  */
if|if
condition|(
name|dest
operator|==
name|stack_pointer_rtx
comment|/* If we couldn't eliminate a field assignment, we can't combine.  */
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
comment|/* Don't combine with an insn that sets a register to itself if it has 	 a REG_EQUAL note.  This may be part of a REG_NO_CONFLICT sequence.  */
operator|||
operator|(
name|rtx_equal_p
argument_list|(
name|src
argument_list|,
name|dest
argument_list|)
operator|&&
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
comment|/* Can't merge an ASM_OPERANDS.  */
operator|||
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|ASM_OPERANDS
comment|/* Can't merge a function call.  */
operator|||
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|CALL
comment|/* Don't eliminate a function call argument.  */
operator|||
operator|(
name|GET_CODE
argument_list|(
name|i3
argument_list|)
operator|==
name|CALL_INSN
operator|&&
operator|(
name|find_reg_fusage
argument_list|(
name|i3
argument_list|,
name|USE
argument_list|,
name|dest
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|global_regs
index|[
name|REGNO
argument_list|(
name|dest
argument_list|)
index|]
operator|)
operator|)
operator|)
comment|/* Don't substitute into an incremented register.  */
operator|||
name|FIND_REG_INC_NOTE
argument_list|(
name|i3
argument_list|,
name|dest
argument_list|)
operator|||
operator|(
name|succ
operator|&&
name|FIND_REG_INC_NOTE
argument_list|(
name|succ
argument_list|,
name|dest
argument_list|)
operator|)
if|#
directive|if
literal|0
comment|/* Don't combine the end of a libcall into anything.  */
comment|/* ??? This gives worse code, and appears to be unnecessary, since no 	 pass after flow uses REG_LIBCALL/REG_RETVAL notes.  Local-alloc does 	 use REG_RETVAL notes for noconflict blocks, but other code here 	 makes sure that those insns don't disappear.  */
expr||| find_reg_note (insn, REG_RETVAL, NULL_RTX)
endif|#
directive|endif
comment|/* Make sure that DEST is not used after SUCC but before I3.  */
operator|||
operator|(
name|succ
operator|&&
operator|!
name|all_adjacent
operator|&&
name|reg_used_between_p
argument_list|(
name|dest
argument_list|,
name|succ
argument_list|,
name|i3
argument_list|)
operator|)
comment|/* Make sure that the value that is to be substituted for the register 	 does not use any registers whose values alter in between.  However, 	 If the insns are adjacent, a use can't cross a set even though we 	 think it might (this can happen for a sequence of insns each setting 	 the same destination; reg_last_set of that register might point to 	 a NOTE).  If INSN has a REG_EQUIV note, the register is always 	 equivalent to the memory so the substitution is valid even if there 	 are intervening stores.  Also, don't move a volatile asm or 	 UNSPEC_VOLATILE across any other insns.  */
operator|||
operator|(
operator|!
name|all_adjacent
operator|&&
operator|(
operator|(
operator|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|!=
name|MEM
operator|||
operator|!
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUIV
argument_list|,
name|src
argument_list|)
operator|)
operator|&&
name|use_crosses_set_p
argument_list|(
name|src
argument_list|,
name|INSN_CUID
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|ASM_OPERANDS
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|src
argument_list|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|UNSPEC_VOLATILE
operator|)
operator|)
comment|/* If there is a REG_NO_CONFLICT note for DEST in I3 or SUCC, we get 	 better register allocation by not doing the combine.  */
operator|||
name|find_reg_note
argument_list|(
name|i3
argument_list|,
name|REG_NO_CONFLICT
argument_list|,
name|dest
argument_list|)
operator|||
operator|(
name|succ
operator|&&
name|find_reg_note
argument_list|(
name|succ
argument_list|,
name|REG_NO_CONFLICT
argument_list|,
name|dest
argument_list|)
operator|)
comment|/* Don't combine across a CALL_INSN, because that would possibly 	 change whether the life span of some REGs crosses calls or not, 	 and it is a pain to update that information. 	 Exception: if source is a constant, moving it later can't hurt. 	 Accept that special case, because it helps -fforce-addr a lot.  */
operator|||
operator|(
name|INSN_CUID
argument_list|(
name|insn
argument_list|)
operator|<
name|last_call_cuid
operator|&&
operator|!
name|CONSTANT_P
argument_list|(
name|src
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* DEST must either be a REG or CC0.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
condition|)
block|{
comment|/* If register alignment is being enforced for multi-word items in all 	 cases except for parameters, it is possible to have a register copy 	 insn referencing a hard register that is not allowed to contain the 	 mode being copied and which would not be valid as an operand of most 	 insns.  Eliminate this problem by not combining with such an insn.  	 Also, on some machines we don't want to extend the life of a hard 	 register.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|REG
operator|&&
operator|(
operator|(
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|!
name|HARD_REGNO_MODE_OK
argument_list|(
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|)
comment|/* Don't extend the life of a hard register unless it is 		 user variable (if we have few registers) or it can't 		 fit into the desired register (meaning something special 		 is going on). 		 Also avoid substituting a return register into I3, because 		 reload can't handle a conflict with constraints of other 		 inputs.  */
operator|||
operator|(
name|REGNO
argument_list|(
name|src
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|!
name|HARD_REGNO_MODE_OK
argument_list|(
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|!=
name|CC0
condition|)
return|return
literal|0
return|;
comment|/* Don't substitute for a register intended as a clobberable operand.      Similarly, don't substitute an expression containing a register that      will be clobbered in I3.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|)
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|CLOBBER
operator|&&
operator|(
name|reg_overlap_mentioned_p
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|src
argument_list|)
operator|||
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|dest
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* If INSN contains anything volatile, or is an `asm' (whether volatile      or not), reject, unless nothing volatile comes between it and I3 */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|ASM_OPERANDS
operator|||
name|volatile_refs_p
argument_list|(
name|src
argument_list|)
condition|)
block|{
comment|/* Make sure succ doesn't contain a volatile reference.  */
if|if
condition|(
name|succ
operator|!=
literal|0
operator|&&
name|volatile_refs_p
argument_list|(
name|PATTERN
argument_list|(
name|succ
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
init|;
name|p
operator|!=
name|i3
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|p
argument_list|)
operator|&&
name|p
operator|!=
name|succ
operator|&&
name|volatile_refs_p
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
comment|/* If INSN is an asm, and DEST is a hard register, reject, since it has      to be an explicit register variable, and was chosen for a reason.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|ASM_OPERANDS
operator|&&
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
return|return
literal|0
return|;
comment|/* If there are any volatile insns between INSN and I3, reject, because      they might affect machine state.  */
for|for
control|(
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
init|;
name|p
operator|!=
name|i3
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|p
argument_list|)
operator|&&
name|p
operator|!=
name|succ
operator|&&
name|volatile_insn_p
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If INSN or I2 contains an autoincrement or autodecrement,      make sure that register is not used between there and I3,      and not already used in I3 either.      Also insist that I3 not be a jump; if it were one      and the incremented register were spilled, we would lose.  */
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_INC
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|i3
argument_list|)
operator|==
name|JUMP_INSN
operator|||
name|reg_used_between_p
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|,
name|i3
argument_list|)
operator|||
name|reg_overlap_mentioned_p
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* Don't combine an insn that follows a CC0-setting insn.      An insn that uses CC0 must not be separated from the one that sets it.      We do, however, allow I2 to follow a CC0-setting insn if that insn      is passed as I1; in that case it will be deleted also.      We also allow combining in this case if all the insns are adjacent      because that would leave the two CC0 insns adjacent as well.      It would be more logical to test whether CC0 occurs inside I1 or I2,      but that would be much slower, and this ought to be equivalent.  */
name|p
operator|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|&&
name|p
operator|!=
name|pred
operator|&&
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|INSN
operator|&&
name|sets_cc0_p
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
operator|&&
operator|!
name|all_adjacent
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* If we get here, we have passed all the tests and the combination is      to be allowed.  */
operator|*
name|pdest
operator|=
name|dest
expr_stmt|;
operator|*
name|psrc
operator|=
name|src
expr_stmt|;
return|return
literal|1
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Check if PAT is an insn - or a part of it - used to set up an    argument for a function in a hard register.  */
end_comment

begin_function
specifier|static
name|int
name|sets_function_arg_p
parameter_list|(
name|pat
parameter_list|)
name|rtx
name|pat
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|rtx
name|inner_dest
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
condition|)
block|{
case|case
name|INSN
case|:
return|return
name|sets_function_arg_p
argument_list|(
name|PATTERN
argument_list|(
name|pat
argument_list|)
argument_list|)
return|;
case|case
name|PARALLEL
case|:
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
if|if
condition|(
name|sets_function_arg_p
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|SET
case|:
name|inner_dest
operator|=
name|SET_DEST
argument_list|(
name|pat
argument_list|)
expr_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|inner_dest
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|inner_dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|inner_dest
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
name|inner_dest
operator|=
name|XEXP
argument_list|(
name|inner_dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|GET_CODE
argument_list|(
name|inner_dest
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|inner_dest
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|FUNCTION_ARG_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|inner_dest
argument_list|)
argument_list|)
operator|)
return|;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* LOC is the location within I3 that contains its pattern or the component    of a PARALLEL of the pattern.  We validate that it is valid for combining.     One problem is if I3 modifies its output, as opposed to replacing it    entirely, we can't allow the output to contain I2DEST or I1DEST as doing    so would produce an insn that is not equivalent to the original insns.     Consider:           (set (reg:DI 101) (reg:DI 100)) 	 (set (subreg:SI (reg:DI 101) 0)<foo>)     This is NOT equivalent to:           (parallel [(set (subreg:SI (reg:DI 100) 0)<foo>) 		    (set (reg:DI 101) (reg:DI 100))])     Not only does this modify 100 (in which case it might still be valid    if 100 were dead in I2), it sets 101 to the ORIGINAL value of 100.     We can also run into a problem if I2 sets a register that I1    uses and I1 gets directly substituted into I3 (not via I2).  In that    case, we would be getting the wrong value of I2DEST into I3, so we    must reject the combination.  This case occurs when I2 and I1 both    feed into I3, rather than when I1 feeds into I2, which feeds into I3.    If I1_NOT_IN_SRC is nonzero, it means that finding I1 in the source    of a SET must prevent combination from occurring.     Before doing the above check, we first try to expand a field assignment    into a set of logical operations.     If PI3_DEST_KILLED is nonzero, it is a pointer to a location in which    we place a register that is both set and used within I3.  If more than one    such register is detected, we fail.     Return 1 if the combination is valid, zero otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|combinable_i3pat
parameter_list|(
name|i3
parameter_list|,
name|loc
parameter_list|,
name|i2dest
parameter_list|,
name|i1dest
parameter_list|,
name|i1_not_in_src
parameter_list|,
name|pi3dest_killed
parameter_list|)
name|rtx
name|i3
decl_stmt|;
name|rtx
modifier|*
name|loc
decl_stmt|;
name|rtx
name|i2dest
decl_stmt|;
name|rtx
name|i1dest
decl_stmt|;
name|int
name|i1_not_in_src
decl_stmt|;
name|rtx
modifier|*
name|pi3dest_killed
decl_stmt|;
block|{
name|rtx
name|x
init|=
operator|*
name|loc
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
condition|)
block|{
name|rtx
name|set
init|=
name|expand_field_assignment
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
decl_stmt|;
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
decl_stmt|;
name|rtx
name|inner_dest
init|=
name|dest
decl_stmt|;
if|#
directive|if
literal|0
block|rtx inner_src = src;
endif|#
directive|endif
name|SUBST
argument_list|(
operator|*
name|loc
argument_list|,
name|set
argument_list|)
expr_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|inner_dest
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|inner_dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|inner_dest
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
name|inner_dest
operator|=
name|XEXP
argument_list|(
name|inner_dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* We probably don't need this any more now that LIMIT_RELOAD_CLASS      was added.  */
if|#
directive|if
literal|0
block|while (GET_CODE (inner_src) == STRICT_LOW_PART 	     || GET_CODE (inner_src) == SUBREG 	     || GET_CODE (inner_src) == ZERO_EXTRACT) 	inner_src = XEXP (inner_src, 0);
comment|/* If it is better that two different modes keep two different pseudos, 	 avoid combining them.  This avoids producing the following pattern 	 on a 386: 	  (set (subreg:SI (reg/v:QI 21) 0) 	       (lshiftrt:SI (reg/v:SI 20) 	           (const_int 24))) 	 If that were made, reload could not handle the pair of 	 reg 20/21, since it would try to get any GENERAL_REGS 	 but some of them don't handle QImode.  */
block|if (rtx_equal_p (inner_src, i2dest)&& GET_CODE (inner_dest) == REG&& ! MODES_TIEABLE_P (GET_MODE (i2dest), GET_MODE (inner_dest))) 	return 0;
endif|#
directive|endif
comment|/* Check for the case where I3 modifies its output, as 	 discussed above.  */
if|if
condition|(
operator|(
name|inner_dest
operator|!=
name|dest
operator|&&
operator|(
name|reg_overlap_mentioned_p
argument_list|(
name|i2dest
argument_list|,
name|inner_dest
argument_list|)
operator|||
operator|(
name|i1dest
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|i1dest
argument_list|,
name|inner_dest
argument_list|)
operator|)
operator|)
operator|)
comment|/* This is the same test done in can_combine_p except we can't test 	     all_adjacent; we don't have to, since this instruction will stay 	     in place, thus we are not considering increasing the lifetime of 	     INNER_DEST.  	     Also, if this insn sets a function argument, combining it with 	     something that might need a spill could clobber a previous 	     function argument; the all_adjacent test in can_combine_p also 	     checks this; here, we do a more specific test for this case.  */
operator|||
operator|(
name|GET_CODE
argument_list|(
name|inner_dest
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|inner_dest
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|(
operator|!
name|HARD_REGNO_MODE_OK
argument_list|(
name|REGNO
argument_list|(
name|inner_dest
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|inner_dest
argument_list|)
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|i1_not_in_src
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|i1dest
argument_list|,
name|src
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* If DEST is used in I3, it is being killed in this insn, 	 so record that for later. 	 Never add REG_DEAD notes for the FRAME_POINTER_REGNUM or the 	 STACK_POINTER_REGNUM, since these are always considered to be 	 live.  Similarly for ARG_POINTER_REGNUM if it is fixed.  */
if|if
condition|(
name|pi3dest_killed
operator|&&
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
operator|&&
name|reg_referenced_p
argument_list|(
name|dest
argument_list|,
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|!=
name|FRAME_POINTER_REGNUM
if|#
directive|if
name|HARD_FRAME_POINTER_REGNUM
operator|!=
name|FRAME_POINTER_REGNUM
operator|&&
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|!=
name|HARD_FRAME_POINTER_REGNUM
endif|#
directive|endif
if|#
directive|if
name|ARG_POINTER_REGNUM
operator|!=
name|FRAME_POINTER_REGNUM
operator|&&
operator|(
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|!=
name|ARG_POINTER_REGNUM
operator|||
operator|!
name|fixed_regs
index|[
name|REGNO
argument_list|(
name|dest
argument_list|)
index|]
operator|)
endif|#
directive|endif
operator|&&
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|!=
name|STACK_POINTER_REGNUM
condition|)
block|{
if|if
condition|(
operator|*
name|pi3dest_killed
condition|)
return|return
literal|0
return|;
operator|*
name|pi3dest_killed
operator|=
name|dest
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|combinable_i3pat
argument_list|(
name|i3
argument_list|,
operator|&
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|i2dest
argument_list|,
name|i1dest
argument_list|,
name|i1_not_in_src
argument_list|,
name|pi3dest_killed
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if X is an arithmetic expression that contains a multiplication    and division.  We don't count multiplications by powers of two here.  */
end_comment

begin_function
specifier|static
name|int
name|contains_muldiv
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|MOD
case|:
case|case
name|DIV
case|:
case|case
name|UMOD
case|:
case|case
name|UDIV
case|:
return|return
literal|1
return|;
case|case
name|MULT
case|:
return|return
operator|!
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|>=
literal|0
operator|)
return|;
default|default:
switch|switch
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
case|case
literal|'c'
case|:
case|case
literal|'<'
case|:
case|case
literal|'2'
case|:
return|return
name|contains_muldiv
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|contains_muldiv
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
literal|'1'
case|:
return|return
name|contains_muldiv
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Determine whether INSN can be used in a combination.  Return nonzero if    not.  This is used in try_combine to detect early some cases where we    can't perform combinations.  */
end_comment

begin_function
specifier|static
name|int
name|cant_combine_insn_p
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|set
decl_stmt|;
name|rtx
name|src
decl_stmt|,
name|dest
decl_stmt|;
comment|/* If this isn't really an insn, we can't do anything.      This can occur when flow deletes an insn that it has merged into an      auto-increment address.  */
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Never combine loads and stores involving hard regs.  The register      allocator can usually handle such reg-reg moves by tying.  If we allow      the combiner to make substitutions of hard regs, we risk aborting in      reload on machines that have SMALL_REGISTER_CLASSES.      As an exception, we allow combinations involving fixed regs; these are      not available to the register allocator so there's no risk involved.  */
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set
condition|)
return|return
literal|0
return|;
name|src
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|dest
operator|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|SUBREG
condition|)
name|src
operator|=
name|SUBREG_REG
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
condition|)
name|dest
operator|=
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|src
argument_list|)
operator|&&
name|REG_P
argument_list|(
name|dest
argument_list|)
operator|&&
operator|(
operator|(
name|REGNO
argument_list|(
name|src
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|!
name|fixed_regs
index|[
name|REGNO
argument_list|(
name|src
argument_list|)
index|]
operator|)
operator|||
operator|(
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|!
name|fixed_regs
index|[
name|REGNO
argument_list|(
name|dest
argument_list|)
index|]
operator|)
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Try to combine the insns I1 and I2 into I3.    Here I1 and I2 appear earlier than I3.    I1 can be zero; then we combine just I2 into I3.     If we are combining three insns and the resulting insn is not recognized,    try splitting it into two insns.  If that happens, I2 and I3 are retained    and I1 is pseudo-deleted by turning it into a NOTE.  Otherwise, I1 and I2    are pseudo-deleted.     Return 0 if the combination does not work.  Then nothing is changed.    If we did the combination, return the insn at which combine should    resume scanning.     Set NEW_DIRECT_JUMP_P to a nonzero value if try_combine creates a    new direct jump instruction.  */
end_comment

begin_function
specifier|static
name|rtx
name|try_combine
parameter_list|(
name|i3
parameter_list|,
name|i2
parameter_list|,
name|i1
parameter_list|,
name|new_direct_jump_p
parameter_list|)
name|rtx
name|i3
decl_stmt|,
name|i2
decl_stmt|,
name|i1
decl_stmt|;
name|int
modifier|*
name|new_direct_jump_p
decl_stmt|;
block|{
comment|/* New patterns for I3 and I2, respectively.  */
name|rtx
name|newpat
decl_stmt|,
name|newi2pat
init|=
literal|0
decl_stmt|;
name|int
name|substed_i2
init|=
literal|0
decl_stmt|,
name|substed_i1
init|=
literal|0
decl_stmt|;
comment|/* Indicates need to preserve SET in I1 or I2 in I3 if it is not dead.  */
name|int
name|added_sets_1
decl_stmt|,
name|added_sets_2
decl_stmt|;
comment|/* Total number of SETs to put into I3.  */
name|int
name|total_sets
decl_stmt|;
comment|/* Nonzero is I2's body now appears in I3.  */
name|int
name|i2_is_used
decl_stmt|;
comment|/* INSN_CODEs for new I3, new I2, and user of condition code.  */
name|int
name|insn_code_number
decl_stmt|,
name|i2_code_number
init|=
literal|0
decl_stmt|,
name|other_code_number
init|=
literal|0
decl_stmt|;
comment|/* Contains I3 if the destination of I3 is used in its source, which means      that the old life of I3 is being killed.  If that usage is placed into      I2 and not in I3, a REG_DEAD note must be made.  */
name|rtx
name|i3dest_killed
init|=
literal|0
decl_stmt|;
comment|/* SET_DEST and SET_SRC of I2 and I1.  */
name|rtx
name|i2dest
decl_stmt|,
name|i2src
decl_stmt|,
name|i1dest
init|=
literal|0
decl_stmt|,
name|i1src
init|=
literal|0
decl_stmt|;
comment|/* PATTERN (I2), or a copy of it in certain cases.  */
name|rtx
name|i2pat
decl_stmt|;
comment|/* Indicates if I2DEST or I1DEST is in I2SRC or I1_SRC.  */
name|int
name|i2dest_in_i2src
init|=
literal|0
decl_stmt|,
name|i1dest_in_i1src
init|=
literal|0
decl_stmt|,
name|i2dest_in_i1src
init|=
literal|0
decl_stmt|;
name|int
name|i1_feeds_i3
init|=
literal|0
decl_stmt|;
comment|/* Notes that must be added to REG_NOTES in I3 and I2.  */
name|rtx
name|new_i3_notes
decl_stmt|,
name|new_i2_notes
decl_stmt|;
comment|/* Notes that we substituted I3 into I2 instead of the normal case.  */
name|int
name|i3_subst_into_i2
init|=
literal|0
decl_stmt|;
comment|/* Notes that I1, I2 or I3 is a MULT operation.  */
name|int
name|have_mult
init|=
literal|0
decl_stmt|;
name|int
name|maxreg
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
name|rtx
name|link
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Exit early if one of the insns involved can't be used for      combinations.  */
if|if
condition|(
name|cant_combine_insn_p
argument_list|(
name|i3
argument_list|)
operator|||
name|cant_combine_insn_p
argument_list|(
name|i2
argument_list|)
operator|||
operator|(
name|i1
operator|&&
name|cant_combine_insn_p
argument_list|(
name|i1
argument_list|)
operator|)
comment|/* We also can't do anything if I3 has a 	 REG_LIBCALL note since we don't want to disrupt the contiguity of a 	 libcall.  */
if|#
directive|if
literal|0
comment|/* ??? This gives worse code, and appears to be unnecessary, since no 	 pass after flow uses REG_LIBCALL/REG_RETVAL notes.  */
condition||| find_reg_note (i3, REG_LIBCALL, NULL_RTX)
endif|#
directive|endif
condition|)
return|return
literal|0
return|;
name|combine_attempts
operator|++
expr_stmt|;
name|undobuf
operator|.
name|other_insn
operator|=
literal|0
expr_stmt|;
comment|/* Reset the hard register usage information.  */
name|CLEAR_HARD_REG_SET
argument_list|(
name|newpat_used_regs
argument_list|)
expr_stmt|;
comment|/* If I1 and I2 both feed I3, they can be in any order.  To simplify the      code below, set I1 to be the earlier of the two insns.  */
if|if
condition|(
name|i1
operator|&&
name|INSN_CUID
argument_list|(
name|i1
argument_list|)
operator|>
name|INSN_CUID
argument_list|(
name|i2
argument_list|)
condition|)
name|temp
operator|=
name|i1
operator|,
name|i1
operator|=
name|i2
operator|,
name|i2
operator|=
name|temp
expr_stmt|;
name|added_links_insn
operator|=
literal|0
expr_stmt|;
comment|/* First check for one important special-case that the code below will      not handle.  Namely, the case where I1 is zero, I2 is a PARALLEL      and I3 is a SET whose SET_SRC is a SET_DEST in I2.  In that case,      we may be able to replace that destination with the destination of I3.      This occurs in the common code where we compute both a quotient and      remainder into a structure, in which case we want to do the computation      directly into the structure to avoid register-register copies.       Note that this case handles both multiple sets in I2 and also      cases where I2 has a number of CLOBBER or PARALLELs.       We make very conservative checks below and only try to handle the      most common cases of this.  For example, we only handle the case      where I2 and I3 are adjacent to avoid making difficult register      usage tests.  */
if|if
condition|(
name|i1
operator|==
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|i3
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|find_reg_note
argument_list|(
name|i3
argument_list|,
name|REG_DEAD
argument_list|,
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|i2
argument_list|)
argument_list|)
operator|==
name|PARALLEL
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|)
argument_list|)
comment|/* If the dest of I3 is a ZERO_EXTRACT or STRICT_LOW_PART, the code 	 below would need to check what is inside (and reg_overlap_mentioned_p 	 doesn't support those codes anyway).  Don't allow those destinations; 	 the resulting insn isn't likely to be recognized anyway.  */
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|ZERO_EXTRACT
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|STRICT_LOW_PART
operator|&&
operator|!
name|reg_overlap_mentioned_p
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|)
argument_list|,
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|next_real_insn
argument_list|(
name|i2
argument_list|)
operator|==
name|i3
condition|)
block|{
name|rtx
name|p2
init|=
name|PATTERN
argument_list|(
name|i2
argument_list|)
decl_stmt|;
comment|/* Make sure that the destination of I3, 	 which we are going to substitute into one output of I2, 	 is not used within another output of I2.  We must avoid making this: 	 (parallel [(set (mem (reg 69)) ...) 		    (set (reg 69) ...)]) 	 which is not well-defined as to order of actions. 	 (Besides, reload can't handle output reloads for this.)  	 The problem can also happen if the dest of I3 is a memory ref, 	 if another dest in I2 is an indirect memory ref.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|p2
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|p2
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|p2
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|CLOBBER
operator|)
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|)
argument_list|,
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|p2
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|XVECLEN
argument_list|(
name|p2
argument_list|,
literal|0
argument_list|)
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|p2
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|p2
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|p2
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|CLOBBER
operator|)
operator|&&
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|p2
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|)
condition|)
block|{
name|combine_merges
operator|++
expr_stmt|;
name|subst_insn
operator|=
name|i3
expr_stmt|;
name|subst_low_cuid
operator|=
name|INSN_CUID
argument_list|(
name|i2
argument_list|)
expr_stmt|;
name|added_sets_2
operator|=
name|added_sets_1
operator|=
literal|0
expr_stmt|;
name|i2dest
operator|=
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Replace the dest in I2 with our dest and make the resulting 		 insn the new pattern for I3.  Then skip to where we 		 validate the pattern.  Everything was set up above.  */
name|SUBST
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|p2
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|,
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|newpat
operator|=
name|p2
expr_stmt|;
name|i3_subst_into_i2
operator|=
literal|1
expr_stmt|;
goto|goto
name|validate_replacement
goto|;
block|}
block|}
comment|/* If I2 is setting a double-word pseudo to a constant and I3 is setting      one of those words to another constant, merge them by making a new      constant.  */
if|if
condition|(
name|i1
operator|==
literal|0
operator|&&
operator|(
name|temp
operator|=
name|single_set
argument_list|(
name|i2
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|==
name|CONST_DOUBLE
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|temp
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|temp
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|2
operator|*
name|UNITS_PER_WORD
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|)
argument_list|)
operator|==
name|SET_DEST
argument_list|(
name|temp
argument_list|)
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|==
name|UNITS_PER_WORD
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|HOST_WIDE_INT
name|lo
decl_stmt|,
name|hi
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|lo
operator|=
name|INTVAL
argument_list|(
name|SET_SRC
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|,
name|hi
operator|=
name|lo
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
literal|0
expr_stmt|;
else|else
block|{
name|lo
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|SET_SRC
argument_list|(
name|temp
argument_list|)
argument_list|)
expr_stmt|;
name|hi
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|SET_SRC
argument_list|(
name|temp
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|subreg_lowpart_p
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
comment|/* We don't handle the case of the target word being wider 	     than a host wide int.  */
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|<
name|BITS_PER_WORD
condition|)
name|abort
argument_list|()
expr_stmt|;
name|lo
operator|&=
operator|~
operator|(
name|UWIDE_SHIFT_LEFT_BY_BITS_PER_WORD
argument_list|(
literal|1
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
name|lo
operator||=
operator|(
name|INTVAL
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|)
argument_list|)
operator|&
operator|(
name|UWIDE_SHIFT_LEFT_BY_BITS_PER_WORD
argument_list|(
literal|1
argument_list|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|==
name|BITS_PER_WORD
condition|)
name|hi
operator|=
name|INTVAL
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|2
operator|*
name|BITS_PER_WORD
condition|)
block|{
name|int
name|sign
init|=
operator|-
call|(
name|int
call|)
argument_list|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|lo
operator|>>
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
argument_list|)
decl_stmt|;
name|lo
operator|&=
operator|~
operator|(
name|UWIDE_SHIFT_LEFT_BY_BITS_PER_WORD
argument_list|(
name|UWIDE_SHIFT_LEFT_BY_BITS_PER_WORD
argument_list|(
literal|1
argument_list|)
operator|-
literal|1
argument_list|)
operator|)
expr_stmt|;
name|lo
operator||=
operator|(
name|UWIDE_SHIFT_LEFT_BY_BITS_PER_WORD
argument_list|(
name|INTVAL
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|hi
operator|==
name|sign
condition|)
name|hi
operator|=
name|lo
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
literal|0
expr_stmt|;
block|}
else|else
comment|/* We don't handle the case of the higher word not fitting 	   entirely in either hi or lo.  */
name|abort
argument_list|()
expr_stmt|;
name|combine_merges
operator|++
expr_stmt|;
name|subst_insn
operator|=
name|i3
expr_stmt|;
name|subst_low_cuid
operator|=
name|INSN_CUID
argument_list|(
name|i2
argument_list|)
expr_stmt|;
name|added_sets_2
operator|=
name|added_sets_1
operator|=
literal|0
expr_stmt|;
name|i2dest
operator|=
name|SET_DEST
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|SUBST
argument_list|(
name|SET_SRC
argument_list|(
name|temp
argument_list|)
argument_list|,
name|immed_double_const
argument_list|(
name|lo
argument_list|,
name|hi
argument_list|,
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|temp
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|newpat
operator|=
name|PATTERN
argument_list|(
name|i2
argument_list|)
expr_stmt|;
goto|goto
name|validate_replacement
goto|;
block|}
ifndef|#
directive|ifndef
name|HAVE_cc0
comment|/* If we have no I1 and I2 looks like: 	(parallel [(set (reg:CC X) (compare:CC OP (const_int 0))) 		   (set Y OP)])      make up a dummy I1 that is 	(set Y OP)      and change I2 to be         (set (reg:CC X) (compare:CC Y (const_int 0)))       (We can ignore any trailing CLOBBERs.)       This undoes a previous combination and allows us to match a branch-and-      decrement insn.  */
if|if
condition|(
name|i1
operator|==
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|i2
argument_list|)
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|i2
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|>=
literal|2
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|i2
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
operator|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|i2
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MODE_CC
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|i2
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|COMPARE
operator|&&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|i2
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|const0_rtx
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|i2
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|i2
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|i2
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|i2
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|i2
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|2
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|i2
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|!=
name|CLOBBER
condition|)
break|break;
if|if
condition|(
name|i
operator|==
literal|1
condition|)
block|{
comment|/* We make I1 with the same INSN_UID as I2.  This gives it 	     the same INSN_CUID for value tracking.  Our fake I1 will 	     never appear in the insn stream so giving it the same INSN_UID 	     as I2 will not cause a problem.  */
name|subst_prev_insn
operator|=
name|i1
operator|=
name|gen_rtx_INSN
argument_list|(
name|VOIDmode
argument_list|,
name|INSN_UID
argument_list|(
name|i2
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|i2
argument_list|,
name|BLOCK_FOR_INSN
argument_list|(
name|i2
argument_list|)
argument_list|,
name|INSN_SCOPE
argument_list|(
name|i2
argument_list|)
argument_list|,
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|i2
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|SUBST
argument_list|(
name|PATTERN
argument_list|(
name|i2
argument_list|)
argument_list|,
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|i2
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|SUBST
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|i2
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|i1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* Verify that I2 and I1 are valid for combining.  */
if|if
condition|(
operator|!
name|can_combine_p
argument_list|(
name|i2
argument_list|,
name|i3
argument_list|,
name|i1
argument_list|,
name|NULL_RTX
argument_list|,
operator|&
name|i2dest
argument_list|,
operator|&
name|i2src
argument_list|)
operator|||
operator|(
name|i1
operator|&&
operator|!
name|can_combine_p
argument_list|(
name|i1
argument_list|,
name|i3
argument_list|,
name|NULL_RTX
argument_list|,
name|i2
argument_list|,
operator|&
name|i1dest
argument_list|,
operator|&
name|i1src
argument_list|)
operator|)
condition|)
block|{
name|undo_all
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Record whether I2DEST is used in I2SRC and similarly for the other      cases.  Knowing this will help in register status updating below.  */
name|i2dest_in_i2src
operator|=
name|reg_overlap_mentioned_p
argument_list|(
name|i2dest
argument_list|,
name|i2src
argument_list|)
expr_stmt|;
name|i1dest_in_i1src
operator|=
name|i1
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|i1dest
argument_list|,
name|i1src
argument_list|)
expr_stmt|;
name|i2dest_in_i1src
operator|=
name|i1
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|i2dest
argument_list|,
name|i1src
argument_list|)
expr_stmt|;
comment|/* See if I1 directly feeds into I3.  It does if I1DEST is not used      in I2SRC.  */
name|i1_feeds_i3
operator|=
name|i1
operator|&&
operator|!
name|reg_overlap_mentioned_p
argument_list|(
name|i1dest
argument_list|,
name|i2src
argument_list|)
expr_stmt|;
comment|/* Ensure that I3's pattern can be the destination of combines.  */
if|if
condition|(
operator|!
name|combinable_i3pat
argument_list|(
name|i3
argument_list|,
operator|&
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|,
name|i2dest
argument_list|,
name|i1dest
argument_list|,
name|i1
operator|&&
name|i2dest_in_i1src
operator|&&
name|i1_feeds_i3
argument_list|,
operator|&
name|i3dest_killed
argument_list|)
condition|)
block|{
name|undo_all
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* See if any of the insns is a MULT operation.  Unless one is, we will      reject a combination that is, since it must be slower.  Be conservative      here.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|i2src
argument_list|)
operator|==
name|MULT
operator|||
operator|(
name|i1
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|i1src
argument_list|)
operator|==
name|MULT
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MULT
operator|)
condition|)
name|have_mult
operator|=
literal|1
expr_stmt|;
comment|/* If I3 has an inc, then give up if I1 or I2 uses the reg that is inc'd.      We used to do this EXCEPT in one case: I3 has a post-inc in an      output operand.  However, that exception can give rise to insns like 	mov r3,(r3)+      which is a famous insn on the PDP-11 where the value of r3 used as the      source was model-dependent.  Avoid this sort of thing.  */
if|#
directive|if
literal|0
block|if (!(GET_CODE (PATTERN (i3)) == SET&& GET_CODE (SET_SRC (PATTERN (i3))) == REG&& GET_CODE (SET_DEST (PATTERN (i3))) == MEM&& (GET_CODE (XEXP (SET_DEST (PATTERN (i3)), 0)) == POST_INC 	    || GET_CODE (XEXP (SET_DEST (PATTERN (i3)), 0)) == POST_DEC)))
comment|/* It's not the exception.  */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|i3
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_INC
operator|&&
operator|(
name|reg_overlap_mentioned_p
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
name|PATTERN
argument_list|(
name|i2
argument_list|)
argument_list|)
operator|||
operator|(
name|i1
operator|!=
literal|0
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
name|PATTERN
argument_list|(
name|i1
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
block|{
name|undo_all
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|/* See if the SETs in I1 or I2 need to be kept around in the merged      instruction: whenever the value set there is still needed past I3.      For the SETs in I2, this is easy: we see if I2DEST dies or is set in I3.       For the SET in I1, we have two cases:  If I1 and I2 independently      feed into I3, the set in I1 needs to be kept around if I1DEST dies      or is set in I3.  Otherwise (if I1 feeds I2 which feeds I3), the set      in I1 needs to be kept around unless I1DEST dies or is set in either      I2 or I3.  We can distinguish these cases by seeing if I2SRC mentions      I1DEST.  If so, we know I1 feeds into I2.  */
name|added_sets_2
operator|=
operator|!
name|dead_or_set_p
argument_list|(
name|i3
argument_list|,
name|i2dest
argument_list|)
expr_stmt|;
name|added_sets_1
operator|=
name|i1
operator|&&
operator|!
operator|(
name|i1_feeds_i3
condition|?
name|dead_or_set_p
argument_list|(
name|i3
argument_list|,
name|i1dest
argument_list|)
else|:
operator|(
name|dead_or_set_p
argument_list|(
name|i3
argument_list|,
name|i1dest
argument_list|)
operator|||
name|dead_or_set_p
argument_list|(
name|i2
argument_list|,
name|i1dest
argument_list|)
operator|)
operator|)
expr_stmt|;
comment|/* If the set in I2 needs to be kept around, we must make a copy of      PATTERN (I2), so that when we substitute I1SRC for I1DEST in      PATTERN (I2), we are only substituting for the original I1DEST, not into      an already-substituted copy.  This also prevents making self-referential      rtx.  If I2 is a PARALLEL, we just need the piece that assigns I2SRC to      I2DEST.  */
name|i2pat
operator|=
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|i2
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|?
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|i2dest
argument_list|,
name|i2src
argument_list|)
else|:
name|PATTERN
argument_list|(
name|i2
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|added_sets_2
condition|)
name|i2pat
operator|=
name|copy_rtx
argument_list|(
name|i2pat
argument_list|)
expr_stmt|;
name|combine_merges
operator|++
expr_stmt|;
comment|/* Substitute in the latest insn for the regs set by the earlier ones.  */
name|maxreg
operator|=
name|max_reg_num
argument_list|()
expr_stmt|;
name|subst_insn
operator|=
name|i3
expr_stmt|;
comment|/* It is possible that the source of I2 or I1 may be performing an      unneeded operation, such as a ZERO_EXTEND of something that is known      to have the high part zero.  Handle that case by letting subst look at      the innermost one of them.       Another way to do this would be to have a function that tries to      simplify a single insn instead of merging two or more insns.  We don't      do this because of the potential of infinite loops and because      of the potential extra memory required.  However, doing it the way      we are is a bit of a kludge and doesn't catch all cases.       But only do this if -fexpensive-optimizations since it slows things down      and doesn't usually win.  */
if|if
condition|(
name|flag_expensive_optimizations
condition|)
block|{
comment|/* Pass pc_rtx so no substitutions are done, just simplifications. 	 The cases that we are interested in here do not involve the few 	 cases were is_replaced is checked.  */
if|if
condition|(
name|i1
condition|)
block|{
name|subst_low_cuid
operator|=
name|INSN_CUID
argument_list|(
name|i1
argument_list|)
expr_stmt|;
name|i1src
operator|=
name|subst
argument_list|(
name|i1src
argument_list|,
name|pc_rtx
argument_list|,
name|pc_rtx
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|subst_low_cuid
operator|=
name|INSN_CUID
argument_list|(
name|i2
argument_list|)
expr_stmt|;
name|i2src
operator|=
name|subst
argument_list|(
name|i2src
argument_list|,
name|pc_rtx
argument_list|,
name|pc_rtx
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
ifndef|#
directive|ifndef
name|HAVE_cc0
comment|/* Many machines that don't use CC0 have insns that can both perform an      arithmetic operation and set the condition code.  These operations will      be represented as a PARALLEL with the first element of the vector      being a COMPARE of an arithmetic operation with the constant zero.      The second element of the vector will set some pseudo to the result      of the same arithmetic operation.  If we simplify the COMPARE, we won't      match such a pattern and so will generate an extra insn.   Here we test      for this case, where both the comparison and the operation result are      needed, and make the PARALLEL by just replacing I2DEST in I3SRC with      I2SRC.  Later we will make the PARALLEL that contains I2.  */
if|if
condition|(
name|i1
operator|==
literal|0
operator|&&
name|added_sets_2
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|)
argument_list|)
operator|==
name|COMPARE
operator|&&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|const0_rtx
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|i2dest
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|EXTRA_CC_MODES
name|rtx
modifier|*
name|cc_use
decl_stmt|;
name|enum
name|machine_mode
name|compare_mode
decl_stmt|;
endif|#
directive|endif
name|newpat
operator|=
name|PATTERN
argument_list|(
name|i3
argument_list|)
expr_stmt|;
name|SUBST
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|newpat
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|i2src
argument_list|)
expr_stmt|;
name|i2_is_used
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|EXTRA_CC_MODES
comment|/* See if a COMPARE with the operand we substituted in should be done 	 with the mode that is currently being used.  If not, do the same 	 processing we do in `subst' for a SET; namely, if the destination 	 is used only once, try to replace it with a register of the proper 	 mode and also replace the COMPARE.  */
if|if
condition|(
name|undobuf
operator|.
name|other_insn
operator|==
literal|0
operator|&&
operator|(
name|cc_use
operator|=
name|find_single_use
argument_list|(
name|SET_DEST
argument_list|(
name|newpat
argument_list|)
argument_list|,
name|i3
argument_list|,
operator|&
name|undobuf
operator|.
name|other_insn
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|compare_mode
operator|=
name|SELECT_CC_MODE
argument_list|(
name|GET_CODE
argument_list|(
operator|*
name|cc_use
argument_list|)
argument_list|,
name|i2src
argument_list|,
name|const0_rtx
argument_list|)
operator|)
operator|!=
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|newpat
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|newpat
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|new_dest
init|=
name|gen_rtx_REG
argument_list|(
name|compare_mode
argument_list|,
name|regno
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|||
operator|(
name|REG_N_SETS
argument_list|(
name|regno
argument_list|)
operator|==
literal|1
operator|&&
operator|!
name|added_sets_2
operator|&&
operator|!
name|REG_USERVAR_P
argument_list|(
name|SET_DEST
argument_list|(
name|newpat
argument_list|)
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|SUBST
argument_list|(
name|regno_reg_rtx
index|[
name|regno
index|]
argument_list|,
name|new_dest
argument_list|)
expr_stmt|;
name|SUBST
argument_list|(
name|SET_DEST
argument_list|(
name|newpat
argument_list|)
argument_list|,
name|new_dest
argument_list|)
expr_stmt|;
name|SUBST
argument_list|(
name|XEXP
argument_list|(
operator|*
name|cc_use
argument_list|,
literal|0
argument_list|)
argument_list|,
name|new_dest
argument_list|)
expr_stmt|;
name|SUBST
argument_list|(
name|SET_SRC
argument_list|(
name|newpat
argument_list|)
argument_list|,
name|gen_rtx_COMPARE
argument_list|(
name|compare_mode
argument_list|,
name|i2src
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|undobuf
operator|.
name|other_insn
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
endif|#
directive|endif
block|{
name|n_occurrences
operator|=
literal|0
expr_stmt|;
comment|/* `subst' counts here */
comment|/* If I1 feeds into I2 (not into I3) and I1DEST is in I1SRC, we 	 need to make a unique copy of I2SRC each time we substitute it 	 to avoid self-referential rtl.  */
name|subst_low_cuid
operator|=
name|INSN_CUID
argument_list|(
name|i2
argument_list|)
expr_stmt|;
name|newpat
operator|=
name|subst
argument_list|(
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|,
name|i2dest
argument_list|,
name|i2src
argument_list|,
literal|0
argument_list|,
operator|!
name|i1_feeds_i3
operator|&&
name|i1dest_in_i1src
argument_list|)
expr_stmt|;
name|substed_i2
operator|=
literal|1
expr_stmt|;
comment|/* Record whether i2's body now appears within i3's body.  */
name|i2_is_used
operator|=
name|n_occurrences
expr_stmt|;
block|}
comment|/* If we already got a failure, don't try to do more.  Otherwise,      try to substitute in I1 if we have it.  */
if|if
condition|(
name|i1
operator|&&
name|GET_CODE
argument_list|(
name|newpat
argument_list|)
operator|!=
name|CLOBBER
condition|)
block|{
comment|/* Before we can do this substitution, we must redo the test done 	 above (see detailed comments there) that ensures  that I1DEST 	 isn't mentioned in any SETs in NEWPAT that are field assignments.  */
if|if
condition|(
operator|!
name|combinable_i3pat
argument_list|(
name|NULL_RTX
argument_list|,
operator|&
name|newpat
argument_list|,
name|i1dest
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
operator|(
name|rtx
operator|*
operator|)
literal|0
argument_list|)
condition|)
block|{
name|undo_all
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
name|n_occurrences
operator|=
literal|0
expr_stmt|;
name|subst_low_cuid
operator|=
name|INSN_CUID
argument_list|(
name|i1
argument_list|)
expr_stmt|;
name|newpat
operator|=
name|subst
argument_list|(
name|newpat
argument_list|,
name|i1dest
argument_list|,
name|i1src
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|substed_i1
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Fail if an autoincrement side-effect has been duplicated.  Be careful      to count all the ways that I2SRC and I1SRC can be used.  */
if|if
condition|(
operator|(
name|FIND_REG_INC_NOTE
argument_list|(
name|i2
argument_list|,
name|NULL_RTX
argument_list|)
operator|!=
literal|0
operator|&&
name|i2_is_used
operator|+
name|added_sets_2
operator|>
literal|1
operator|)
operator|||
operator|(
name|i1
operator|!=
literal|0
operator|&&
name|FIND_REG_INC_NOTE
argument_list|(
name|i1
argument_list|,
name|NULL_RTX
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|n_occurrences
operator|+
name|added_sets_1
operator|+
operator|(
name|added_sets_2
operator|&&
operator|!
name|i1_feeds_i3
operator|)
operator|>
literal|1
operator|)
operator|)
comment|/* Fail if we tried to make a new register (we used to abort, but there's 	 really no reason to).  */
operator|||
name|max_reg_num
argument_list|()
operator|!=
name|maxreg
comment|/* Fail if we couldn't do something and have a CLOBBER.  */
operator|||
name|GET_CODE
argument_list|(
name|newpat
argument_list|)
operator|==
name|CLOBBER
comment|/* Fail if this new pattern is a MULT and we didn't have one before 	 at the outer level.  */
operator|||
operator|(
name|GET_CODE
argument_list|(
name|newpat
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|newpat
argument_list|)
argument_list|)
operator|==
name|MULT
operator|&&
operator|!
name|have_mult
operator|)
condition|)
block|{
name|undo_all
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* If the actions of the earlier insns must be kept      in addition to substituting them into the latest one,      we must make a new PARALLEL for the latest insn      to hold additional the SETs.  */
if|if
condition|(
name|added_sets_1
operator|||
name|added_sets_2
condition|)
block|{
name|combine_extras
operator|++
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|newpat
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|rtvec
name|old
init|=
name|XVEC
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|total_sets
operator|=
name|XVECLEN
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|)
operator|+
name|added_sets_1
operator|+
name|added_sets_2
expr_stmt|;
name|newpat
operator|=
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|rtvec_alloc
argument_list|(
name|total_sets
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|XVEC
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|)
operator|->
name|elem
argument_list|,
operator|&
name|old
operator|->
name|elem
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|old
operator|->
name|elem
index|[
literal|0
index|]
argument_list|)
operator|*
name|old
operator|->
name|num_elem
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|old
init|=
name|newpat
decl_stmt|;
name|total_sets
operator|=
literal|1
operator|+
name|added_sets_1
operator|+
name|added_sets_2
expr_stmt|;
name|newpat
operator|=
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|rtvec_alloc
argument_list|(
name|total_sets
argument_list|)
argument_list|)
expr_stmt|;
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|=
name|old
expr_stmt|;
block|}
if|if
condition|(
name|added_sets_1
condition|)
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
operator|--
name|total_sets
argument_list|)
operator|=
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|i1
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|?
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|i1dest
argument_list|,
name|i1src
argument_list|)
else|:
name|PATTERN
argument_list|(
name|i1
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|added_sets_2
condition|)
block|{
comment|/* If there is no I1, use I2's body as is.  We used to also not do 	     the subst call below if I2 was substituted into I3, 	     but that could lose a simplification.  */
if|if
condition|(
name|i1
operator|==
literal|0
condition|)
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
operator|--
name|total_sets
argument_list|)
operator|=
name|i2pat
expr_stmt|;
else|else
comment|/* See comment where i2pat is assigned.  */
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
operator|--
name|total_sets
argument_list|)
operator|=
name|subst
argument_list|(
name|i2pat
argument_list|,
name|i1dest
argument_list|,
name|i1src
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* We come here when we are replacing a destination in I2 with the      destination of I3.  */
name|validate_replacement
label|:
comment|/* Note which hard regs this insn has as inputs.  */
name|mark_used_regs_combine
argument_list|(
name|newpat
argument_list|)
expr_stmt|;
comment|/* Is the result of combination a valid instruction?  */
name|insn_code_number
operator|=
name|recog_for_combine
argument_list|(
operator|&
name|newpat
argument_list|,
name|i3
argument_list|,
operator|&
name|new_i3_notes
argument_list|)
expr_stmt|;
comment|/* If the result isn't valid, see if it is a PARALLEL of two SETs where      the second SET's destination is a register that is unused.  In that case,      we just need the first SET.   This can occur when simplifying a divmod      insn.  We *must* test for this case here because the code below that      splits two independent SETs doesn't handle this case correctly when it      updates the register status.  Also check the case where the first      SET's destination is unused.  That would not cause incorrect code, but      does cause an unneeded insn to remain.  */
if|if
condition|(
name|insn_code_number
operator|<
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|newpat
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|XVECLEN
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|)
operator|==
literal|2
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|find_reg_note
argument_list|(
name|i3
argument_list|,
name|REG_UNUSED
argument_list|,
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|asm_noperands
argument_list|(
name|newpat
argument_list|)
operator|<
literal|0
condition|)
block|{
name|newpat
operator|=
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|insn_code_number
operator|=
name|recog_for_combine
argument_list|(
operator|&
name|newpat
argument_list|,
name|i3
argument_list|,
operator|&
name|new_i3_notes
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|insn_code_number
operator|<
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|newpat
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|XVECLEN
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|)
operator|==
literal|2
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|find_reg_note
argument_list|(
name|i3
argument_list|,
name|REG_UNUSED
argument_list|,
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|asm_noperands
argument_list|(
name|newpat
argument_list|)
operator|<
literal|0
condition|)
block|{
name|newpat
operator|=
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|insn_code_number
operator|=
name|recog_for_combine
argument_list|(
operator|&
name|newpat
argument_list|,
name|i3
argument_list|,
operator|&
name|new_i3_notes
argument_list|)
expr_stmt|;
block|}
comment|/* If we were combining three insns and the result is a simple SET      with no ASM_OPERANDS that wasn't recognized, try to split it into two      insns.  There are two ways to do this.  It can be split using a      machine-specific method (like when you have an addition of a large      constant) or by combine in the function find_split_point.  */
if|if
condition|(
name|i1
operator|&&
name|insn_code_number
operator|<
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|newpat
argument_list|)
operator|==
name|SET
operator|&&
name|asm_noperands
argument_list|(
name|newpat
argument_list|)
operator|<
literal|0
condition|)
block|{
name|rtx
name|m_split
decl_stmt|,
modifier|*
name|split
decl_stmt|;
name|rtx
name|ni2dest
init|=
name|i2dest
decl_stmt|;
comment|/* See if the MD file can split NEWPAT.  If it can't, see if letting it 	 use I2DEST as a scratch register will help.  In the latter case, 	 convert I2DEST to the mode of the source of NEWPAT if we can.  */
name|m_split
operator|=
name|split_insns
argument_list|(
name|newpat
argument_list|,
name|i3
argument_list|)
expr_stmt|;
comment|/* We can only use I2DEST as a scratch reg if it doesn't overlap any 	 inputs of NEWPAT.  */
comment|/* ??? If I2DEST is not safe, and I1DEST exists, then it would be 	 possible to try that as a scratch reg.  This would require adding 	 more code to make it work though.  */
if|if
condition|(
name|m_split
operator|==
literal|0
operator|&&
operator|!
name|reg_overlap_mentioned_p
argument_list|(
name|ni2dest
argument_list|,
name|newpat
argument_list|)
condition|)
block|{
comment|/* If I2DEST is a hard register or the only use of a pseudo, 	     we can change its mode.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|newpat
argument_list|)
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|i2dest
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|newpat
argument_list|)
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|GET_CODE
argument_list|(
name|i2dest
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|REGNO
argument_list|(
name|i2dest
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|||
operator|(
name|REG_N_SETS
argument_list|(
name|REGNO
argument_list|(
name|i2dest
argument_list|)
argument_list|)
operator|==
literal|1
operator|&&
operator|!
name|added_sets_2
operator|&&
operator|!
name|REG_USERVAR_P
argument_list|(
name|i2dest
argument_list|)
operator|)
operator|)
condition|)
name|ni2dest
operator|=
name|gen_rtx_REG
argument_list|(
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|newpat
argument_list|)
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|i2dest
argument_list|)
argument_list|)
expr_stmt|;
name|m_split
operator|=
name|split_insns
argument_list|(
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|newpat
argument_list|,
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|ni2dest
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|i3
argument_list|)
expr_stmt|;
comment|/* If the split with the mode-changed register didn't work, try 	     the original register.  */
if|if
condition|(
operator|!
name|m_split
operator|&&
name|ni2dest
operator|!=
name|i2dest
condition|)
block|{
name|ni2dest
operator|=
name|i2dest
expr_stmt|;
name|m_split
operator|=
name|split_insns
argument_list|(
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|newpat
argument_list|,
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|i2dest
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|i3
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|m_split
operator|&&
name|NEXT_INSN
argument_list|(
name|m_split
argument_list|)
operator|==
name|NULL_RTX
condition|)
block|{
name|m_split
operator|=
name|PATTERN
argument_list|(
name|m_split
argument_list|)
expr_stmt|;
name|insn_code_number
operator|=
name|recog_for_combine
argument_list|(
operator|&
name|m_split
argument_list|,
name|i3
argument_list|,
operator|&
name|new_i3_notes
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn_code_number
operator|>=
literal|0
condition|)
name|newpat
operator|=
name|m_split
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m_split
operator|&&
name|NEXT_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|m_split
argument_list|)
argument_list|)
operator|==
name|NULL_RTX
operator|&&
operator|(
name|next_real_insn
argument_list|(
name|i2
argument_list|)
operator|==
name|i3
operator|||
operator|!
name|use_crosses_set_p
argument_list|(
name|PATTERN
argument_list|(
name|m_split
argument_list|)
argument_list|,
name|INSN_CUID
argument_list|(
name|i2
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|i2set
decl_stmt|,
name|i3set
decl_stmt|;
name|rtx
name|newi3pat
init|=
name|PATTERN
argument_list|(
name|NEXT_INSN
argument_list|(
name|m_split
argument_list|)
argument_list|)
decl_stmt|;
name|newi2pat
operator|=
name|PATTERN
argument_list|(
name|m_split
argument_list|)
expr_stmt|;
name|i3set
operator|=
name|single_set
argument_list|(
name|NEXT_INSN
argument_list|(
name|m_split
argument_list|)
argument_list|)
expr_stmt|;
name|i2set
operator|=
name|single_set
argument_list|(
name|m_split
argument_list|)
expr_stmt|;
comment|/* In case we changed the mode of I2DEST, replace it in the 	     pseudo-register table here.  We can't do it above in case this 	     code doesn't get executed and we do a split the other way.  */
if|if
condition|(
name|REGNO
argument_list|(
name|i2dest
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|SUBST
argument_list|(
name|regno_reg_rtx
index|[
name|REGNO
argument_list|(
name|i2dest
argument_list|)
index|]
argument_list|,
name|ni2dest
argument_list|)
expr_stmt|;
name|i2_code_number
operator|=
name|recog_for_combine
argument_list|(
operator|&
name|newi2pat
argument_list|,
name|i2
argument_list|,
operator|&
name|new_i2_notes
argument_list|)
expr_stmt|;
comment|/* If I2 or I3 has multiple SETs, we won't know how to track 	     register status, so don't use these insns.  If I2's destination 	     is used between I2 and I3, we also can't use these insns.  */
if|if
condition|(
name|i2_code_number
operator|>=
literal|0
operator|&&
name|i2set
operator|&&
name|i3set
operator|&&
operator|(
name|next_real_insn
argument_list|(
name|i2
argument_list|)
operator|==
name|i3
operator|||
operator|!
name|reg_used_between_p
argument_list|(
name|SET_DEST
argument_list|(
name|i2set
argument_list|)
argument_list|,
name|i2
argument_list|,
name|i3
argument_list|)
operator|)
condition|)
name|insn_code_number
operator|=
name|recog_for_combine
argument_list|(
operator|&
name|newi3pat
argument_list|,
name|i3
argument_list|,
operator|&
name|new_i3_notes
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn_code_number
operator|>=
literal|0
condition|)
name|newpat
operator|=
name|newi3pat
expr_stmt|;
comment|/* It is possible that both insns now set the destination of I3. 	     If so, we must show an extra use of it.  */
if|if
condition|(
name|insn_code_number
operator|>=
literal|0
condition|)
block|{
name|rtx
name|new_i3_dest
init|=
name|SET_DEST
argument_list|(
name|i3set
argument_list|)
decl_stmt|;
name|rtx
name|new_i2_dest
init|=
name|SET_DEST
argument_list|(
name|i2set
argument_list|)
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|new_i3_dest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|new_i3_dest
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|new_i3_dest
argument_list|)
operator|==
name|SUBREG
condition|)
name|new_i3_dest
operator|=
name|XEXP
argument_list|(
name|new_i3_dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|new_i2_dest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|new_i2_dest
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|new_i2_dest
argument_list|)
operator|==
name|SUBREG
condition|)
name|new_i2_dest
operator|=
name|XEXP
argument_list|(
name|new_i2_dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|new_i3_dest
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|new_i2_dest
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|new_i3_dest
argument_list|)
operator|==
name|REGNO
argument_list|(
name|new_i2_dest
argument_list|)
condition|)
name|REG_N_SETS
argument_list|(
name|REGNO
argument_list|(
name|new_i2_dest
argument_list|)
argument_list|)
operator|++
expr_stmt|;
block|}
block|}
comment|/* If we can split it and use I2DEST, go ahead and see if that 	 helps things be recognized.  Verify that none of the registers 	 are set between I2 and I3.  */
if|if
condition|(
name|insn_code_number
operator|<
literal|0
operator|&&
operator|(
name|split
operator|=
name|find_split_point
argument_list|(
operator|&
name|newpat
argument_list|,
name|i3
argument_list|)
operator|)
operator|!=
literal|0
ifdef|#
directive|ifdef
name|HAVE_cc0
operator|&&
name|GET_CODE
argument_list|(
name|i2dest
argument_list|)
operator|==
name|REG
endif|#
directive|endif
comment|/* We need I2DEST in the proper mode.  If it is a hard register 	     or the only use of a pseudo, we can change its mode.  */
operator|&&
operator|(
name|GET_MODE
argument_list|(
operator|*
name|split
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|i2dest
argument_list|)
operator|||
name|GET_MODE
argument_list|(
operator|*
name|split
argument_list|)
operator|==
name|VOIDmode
operator|||
name|REGNO
argument_list|(
name|i2dest
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|||
operator|(
name|REG_N_SETS
argument_list|(
name|REGNO
argument_list|(
name|i2dest
argument_list|)
argument_list|)
operator|==
literal|1
operator|&&
operator|!
name|added_sets_2
operator|&&
operator|!
name|REG_USERVAR_P
argument_list|(
name|i2dest
argument_list|)
operator|)
operator|)
operator|&&
operator|(
name|next_real_insn
argument_list|(
name|i2
argument_list|)
operator|==
name|i3
operator|||
operator|!
name|use_crosses_set_p
argument_list|(
operator|*
name|split
argument_list|,
name|INSN_CUID
argument_list|(
name|i2
argument_list|)
argument_list|)
operator|)
comment|/* We can't overwrite I2DEST if its value is still used by 	     NEWPAT.  */
operator|&&
operator|!
name|reg_referenced_p
argument_list|(
name|i2dest
argument_list|,
name|newpat
argument_list|)
condition|)
block|{
name|rtx
name|newdest
init|=
name|i2dest
decl_stmt|;
name|enum
name|rtx_code
name|split_code
init|=
name|GET_CODE
argument_list|(
operator|*
name|split
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|split_mode
init|=
name|GET_MODE
argument_list|(
operator|*
name|split
argument_list|)
decl_stmt|;
comment|/* Get NEWDEST as a register in the proper mode.  We have already 	     validated that we can do this.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|i2dest
argument_list|)
operator|!=
name|split_mode
operator|&&
name|split_mode
operator|!=
name|VOIDmode
condition|)
block|{
name|newdest
operator|=
name|gen_rtx_REG
argument_list|(
name|split_mode
argument_list|,
name|REGNO
argument_list|(
name|i2dest
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|REGNO
argument_list|(
name|i2dest
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|SUBST
argument_list|(
name|regno_reg_rtx
index|[
name|REGNO
argument_list|(
name|i2dest
argument_list|)
index|]
argument_list|,
name|newdest
argument_list|)
expr_stmt|;
block|}
comment|/* If *SPLIT is a (mult FOO (const_int pow2)), convert it to 	     an ASHIFT.  This can occur if it was inside a PLUS and hence 	     appeared to be a memory address.  This is a kludge.  */
if|if
condition|(
name|split_code
operator|==
name|MULT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
operator|*
name|split
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
operator|*
name|split
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>
literal|0
operator|&&
operator|(
name|i
operator|=
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
operator|*
name|split
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|SUBST
argument_list|(
operator|*
name|split
argument_list|,
name|gen_rtx_ASHIFT
argument_list|(
name|split_mode
argument_list|,
name|XEXP
argument_list|(
operator|*
name|split
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Update split_code because we may not have a multiply 		 anymore.  */
name|split_code
operator|=
name|GET_CODE
argument_list|(
operator|*
name|split
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|INSN_SCHEDULING
comment|/* If *SPLIT is a paradoxical SUBREG, when we split it, it should 	     be written as a ZERO_EXTEND.  */
if|if
condition|(
name|split_code
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
operator|*
name|split
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
block|{
ifdef|#
directive|ifdef
name|LOAD_EXTEND_OP
comment|/* Or as a SIGN_EXTEND if LOAD_EXTEND_OP says that that's 		 what it really is.  */
if|if
condition|(
name|LOAD_EXTEND_OP
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
operator|*
name|split
argument_list|)
argument_list|)
argument_list|)
operator|==
name|SIGN_EXTEND
condition|)
name|SUBST
argument_list|(
operator|*
name|split
argument_list|,
name|gen_rtx_SIGN_EXTEND
argument_list|(
name|split_mode
argument_list|,
name|SUBREG_REG
argument_list|(
operator|*
name|split
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|SUBST
argument_list|(
operator|*
name|split
argument_list|,
name|gen_rtx_ZERO_EXTEND
argument_list|(
name|split_mode
argument_list|,
name|SUBREG_REG
argument_list|(
operator|*
name|split
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|newi2pat
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|newdest
argument_list|,
operator|*
name|split
argument_list|)
expr_stmt|;
name|SUBST
argument_list|(
operator|*
name|split
argument_list|,
name|newdest
argument_list|)
expr_stmt|;
name|i2_code_number
operator|=
name|recog_for_combine
argument_list|(
operator|&
name|newi2pat
argument_list|,
name|i2
argument_list|,
operator|&
name|new_i2_notes
argument_list|)
expr_stmt|;
comment|/* If the split point was a MULT and we didn't have one before, 	     don't use one now.  */
if|if
condition|(
name|i2_code_number
operator|>=
literal|0
operator|&&
operator|!
operator|(
name|split_code
operator|==
name|MULT
operator|&&
operator|!
name|have_mult
operator|)
condition|)
name|insn_code_number
operator|=
name|recog_for_combine
argument_list|(
operator|&
name|newpat
argument_list|,
name|i3
argument_list|,
operator|&
name|new_i3_notes
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Check for a case where we loaded from memory in a narrow mode and      then sign extended it, but we need both registers.  In that case,      we have a PARALLEL with both loads from the same memory location.      We can split this into a load from memory followed by a register-register      copy.  This saves at least one insn, more if register allocation can      eliminate the copy.       We cannot do this if the destination of the first assignment is a      condition code register or cc0.  We eliminate this case by making sure      the SET_DEST and SET_SRC have the same mode.       We cannot do this if the destination of the second assignment is      a register that we have already assumed is zero-extended.  Similarly      for a SUBREG of such a register.  */
elseif|else
if|if
condition|(
name|i1
operator|&&
name|insn_code_number
operator|<
literal|0
operator|&&
name|asm_noperands
argument_list|(
name|newpat
argument_list|)
operator|<
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|newpat
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|XVECLEN
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|)
operator|==
literal|2
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|SIGN_EXTEND
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|!
name|use_crosses_set_p
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|INSN_CUID
argument_list|(
name|i2
argument_list|)
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|ZERO_EXTRACT
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|STRICT_LOW_PART
operator|&&
operator|!
operator|(
name|temp
operator|=
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|,
operator|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|REG
operator|&&
name|reg_nonzero_bits
index|[
name|REGNO
argument_list|(
name|temp
argument_list|)
index|]
operator|!=
literal|0
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|<
name|BITS_PER_WORD
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|<
name|HOST_BITS_PER_INT
operator|&&
operator|(
name|reg_nonzero_bits
index|[
name|REGNO
argument_list|(
name|temp
argument_list|)
index|]
operator|!=
name|GET_MODE_MASK
argument_list|(
name|word_mode
argument_list|)
operator|)
operator|)
operator|)
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
name|temp
operator|=
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|,
operator|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|REG
operator|&&
name|reg_nonzero_bits
index|[
name|REGNO
argument_list|(
name|temp
argument_list|)
index|]
operator|!=
literal|0
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|<
name|BITS_PER_WORD
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|<
name|HOST_BITS_PER_INT
operator|&&
operator|(
name|reg_nonzero_bits
index|[
name|REGNO
argument_list|(
name|temp
argument_list|)
index|]
operator|!=
name|GET_MODE_MASK
argument_list|(
name|word_mode
argument_list|)
operator|)
operator|)
operator|)
operator|)
operator|&&
operator|!
name|reg_overlap_mentioned_p
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|!
name|find_reg_note
argument_list|(
name|i3
argument_list|,
name|REG_UNUSED
argument_list|,
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|ni2dest
decl_stmt|;
name|newi2pat
operator|=
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ni2dest
operator|=
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|newpat
operator|=
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SUBST
argument_list|(
name|SET_SRC
argument_list|(
name|newpat
argument_list|)
argument_list|,
name|gen_lowpart_for_combine
argument_list|(
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|newpat
argument_list|)
argument_list|)
argument_list|,
name|ni2dest
argument_list|)
argument_list|)
expr_stmt|;
name|i2_code_number
operator|=
name|recog_for_combine
argument_list|(
operator|&
name|newi2pat
argument_list|,
name|i2
argument_list|,
operator|&
name|new_i2_notes
argument_list|)
expr_stmt|;
if|if
condition|(
name|i2_code_number
operator|>=
literal|0
condition|)
name|insn_code_number
operator|=
name|recog_for_combine
argument_list|(
operator|&
name|newpat
argument_list|,
name|i3
argument_list|,
operator|&
name|new_i3_notes
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn_code_number
operator|>=
literal|0
condition|)
block|{
name|rtx
name|insn
decl_stmt|;
name|rtx
name|link
decl_stmt|;
comment|/* If we will be able to accept this, we have made a change to the 	     destination of I3.  This can invalidate a LOG_LINKS pointing 	     to I3.  No other part of combine.c makes such a transformation.  	     The new I3 will have a destination that was previously the 	     destination of I1 or I2 and which was used in i2 or I3.  Call 	     distribute_links to make a LOG_LINK from the next use of 	     that destination.  */
name|PATTERN
argument_list|(
name|i3
argument_list|)
operator|=
name|newpat
expr_stmt|;
name|distribute_links
argument_list|(
name|gen_rtx_INSN_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|i3
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|)
expr_stmt|;
comment|/* I3 now uses what used to be its destination and which is 	     now I2's destination.  That means we need a LOG_LINK from 	     I3 to I2.  But we used to have one, so we still will.  	     However, some later insn might be using I2's dest and have 	     a LOG_LINK pointing at I3.  We must remove this link. 	     The simplest way to remove the link is to point it at I1, 	     which we know will be a NOTE.  */
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|i3
argument_list|)
init|;
name|insn
operator|&&
operator|(
name|this_basic_block
operator|->
name|next_bb
operator|==
name|EXIT_BLOCK_PTR
operator|||
name|insn
operator|!=
name|this_basic_block
operator|->
name|next_bb
operator|->
name|head
operator|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|reg_referenced_p
argument_list|(
name|ni2dest
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
block|{
for|for
control|(
name|link
operator|=
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
operator|==
name|i3
condition|)
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
operator|=
name|i1
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
comment|/* Similarly, check for a case where we have a PARALLEL of two independent      SETs but we started with three insns.  In this case, we can do the sets      as two separate insns.  This case occurs when some SET allows two      other insns to combine, but the destination of that SET is still live.  */
elseif|else
if|if
condition|(
name|i1
operator|&&
name|insn_code_number
operator|<
literal|0
operator|&&
name|asm_noperands
argument_list|(
name|newpat
argument_list|)
operator|<
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|newpat
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|XVECLEN
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|)
operator|==
literal|2
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|ZERO_EXTRACT
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|STRICT_LOW_PART
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|ZERO_EXTRACT
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|STRICT_LOW_PART
operator|&&
operator|!
name|use_crosses_set_p
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|INSN_CUID
argument_list|(
name|i2
argument_list|)
argument_list|)
comment|/* Don't pass sets with (USE (MEM ...)) dests to the following.  */
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|USE
operator|&&
operator|!
name|reg_referenced_p
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|!
name|reg_referenced_p
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
operator|!
operator|(
name|contains_muldiv
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|contains_muldiv
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/* Normally, it doesn't matter which of the two is done first, 	 but it does if one references cc0.  In that case, it has to 	 be first.  */
ifdef|#
directive|ifdef
name|HAVE_cc0
if|if
condition|(
name|reg_referenced_p
argument_list|(
name|cc0_rtx
argument_list|,
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|newi2pat
operator|=
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|newpat
operator|=
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|newi2pat
operator|=
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|newpat
operator|=
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|i2_code_number
operator|=
name|recog_for_combine
argument_list|(
operator|&
name|newi2pat
argument_list|,
name|i2
argument_list|,
operator|&
name|new_i2_notes
argument_list|)
expr_stmt|;
if|if
condition|(
name|i2_code_number
operator|>=
literal|0
condition|)
name|insn_code_number
operator|=
name|recog_for_combine
argument_list|(
operator|&
name|newpat
argument_list|,
name|i3
argument_list|,
operator|&
name|new_i3_notes
argument_list|)
expr_stmt|;
block|}
comment|/* If it still isn't recognized, fail and change things back the way they      were.  */
if|if
condition|(
operator|(
name|insn_code_number
operator|<
literal|0
comment|/* Is the result a reasonable ASM_OPERANDS?  */
operator|&&
operator|(
operator|!
name|check_asm_operands
argument_list|(
name|newpat
argument_list|)
operator|||
name|added_sets_1
operator|||
name|added_sets_2
operator|)
operator|)
condition|)
block|{
name|undo_all
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* If we had to change another insn, make sure it is valid also.  */
if|if
condition|(
name|undobuf
operator|.
name|other_insn
condition|)
block|{
name|rtx
name|other_pat
init|=
name|PATTERN
argument_list|(
name|undobuf
operator|.
name|other_insn
argument_list|)
decl_stmt|;
name|rtx
name|new_other_notes
decl_stmt|;
name|rtx
name|note
decl_stmt|,
name|next
decl_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|newpat_used_regs
argument_list|)
expr_stmt|;
name|other_code_number
operator|=
name|recog_for_combine
argument_list|(
operator|&
name|other_pat
argument_list|,
name|undobuf
operator|.
name|other_insn
argument_list|,
operator|&
name|new_other_notes
argument_list|)
expr_stmt|;
if|if
condition|(
name|other_code_number
operator|<
literal|0
operator|&&
operator|!
name|check_asm_operands
argument_list|(
name|other_pat
argument_list|)
condition|)
block|{
name|undo_all
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
name|PATTERN
argument_list|(
name|undobuf
operator|.
name|other_insn
argument_list|)
operator|=
name|other_pat
expr_stmt|;
comment|/* If any of the notes in OTHER_INSN were REG_UNUSED, ensure that they 	 are still valid.  Then add any non-duplicate notes added by 	 recog_for_combine.  */
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|undobuf
operator|.
name|other_insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|next
control|)
block|{
name|next
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_UNUSED
operator|&&
operator|!
name|reg_set_p
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|PATTERN
argument_list|(
name|undobuf
operator|.
name|other_insn
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|REG_N_DEATHS
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|--
expr_stmt|;
name|remove_note
argument_list|(
name|undobuf
operator|.
name|other_insn
argument_list|,
name|note
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|note
operator|=
name|new_other_notes
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|REG_N_DEATHS
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|++
expr_stmt|;
name|distribute_notes
argument_list|(
name|new_other_notes
argument_list|,
name|undobuf
operator|.
name|other_insn
argument_list|,
name|undobuf
operator|.
name|other_insn
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* If I2 is the setter CC0 and I3 is the user CC0 then check whether      they are adjacent to each other or not.  */
block|{
name|rtx
name|p
init|=
name|prev_nonnote_insn
argument_list|(
name|i3
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|&&
name|p
operator|!=
name|i2
operator|&&
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|INSN
operator|&&
name|newi2pat
operator|&&
name|sets_cc0_p
argument_list|(
name|newi2pat
argument_list|)
condition|)
block|{
name|undo_all
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
endif|#
directive|endif
comment|/* We now know that we can do this combination.  Merge the insns and      update the status of registers and LOG_LINKS.  */
block|{
name|rtx
name|i3notes
decl_stmt|,
name|i2notes
decl_stmt|,
name|i1notes
init|=
literal|0
decl_stmt|;
name|rtx
name|i3links
decl_stmt|,
name|i2links
decl_stmt|,
name|i1links
init|=
literal|0
decl_stmt|;
name|rtx
name|midnotes
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|regno
decl_stmt|;
comment|/* Compute which registers we expect to eliminate.  newi2pat may be setting        either i3dest or i2dest, so we must check it.  Also, i1dest may be the        same as i3dest, in which case newi2pat may be setting i1dest.  */
name|rtx
name|elim_i2
init|=
operator|(
operator|(
name|newi2pat
operator|&&
name|reg_set_p
argument_list|(
name|i2dest
argument_list|,
name|newi2pat
argument_list|)
operator|)
operator|||
name|i2dest_in_i2src
operator|||
name|i2dest_in_i1src
condition|?
literal|0
else|:
name|i2dest
operator|)
decl_stmt|;
name|rtx
name|elim_i1
init|=
operator|(
name|i1
operator|==
literal|0
operator|||
name|i1dest_in_i1src
operator|||
operator|(
name|newi2pat
operator|&&
name|reg_set_p
argument_list|(
name|i1dest
argument_list|,
name|newi2pat
argument_list|)
operator|)
condition|?
literal|0
else|:
name|i1dest
operator|)
decl_stmt|;
comment|/* Get the old REG_NOTES and LOG_LINKS from all our insns and        clear them.  */
name|i3notes
operator|=
name|REG_NOTES
argument_list|(
name|i3
argument_list|)
operator|,
name|i3links
operator|=
name|LOG_LINKS
argument_list|(
name|i3
argument_list|)
expr_stmt|;
name|i2notes
operator|=
name|REG_NOTES
argument_list|(
name|i2
argument_list|)
operator|,
name|i2links
operator|=
name|LOG_LINKS
argument_list|(
name|i2
argument_list|)
expr_stmt|;
if|if
condition|(
name|i1
condition|)
name|i1notes
operator|=
name|REG_NOTES
argument_list|(
name|i1
argument_list|)
operator|,
name|i1links
operator|=
name|LOG_LINKS
argument_list|(
name|i1
argument_list|)
expr_stmt|;
comment|/* Ensure that we do not have something that should not be shared but        occurs multiple times in the new insns.  Check this by first        resetting all the `used' flags and then copying anything is shared.  */
name|reset_used_flags
argument_list|(
name|i3notes
argument_list|)
expr_stmt|;
name|reset_used_flags
argument_list|(
name|i2notes
argument_list|)
expr_stmt|;
name|reset_used_flags
argument_list|(
name|i1notes
argument_list|)
expr_stmt|;
name|reset_used_flags
argument_list|(
name|newpat
argument_list|)
expr_stmt|;
name|reset_used_flags
argument_list|(
name|newi2pat
argument_list|)
expr_stmt|;
if|if
condition|(
name|undobuf
operator|.
name|other_insn
condition|)
name|reset_used_flags
argument_list|(
name|PATTERN
argument_list|(
name|undobuf
operator|.
name|other_insn
argument_list|)
argument_list|)
expr_stmt|;
name|i3notes
operator|=
name|copy_rtx_if_shared
argument_list|(
name|i3notes
argument_list|)
expr_stmt|;
name|i2notes
operator|=
name|copy_rtx_if_shared
argument_list|(
name|i2notes
argument_list|)
expr_stmt|;
name|i1notes
operator|=
name|copy_rtx_if_shared
argument_list|(
name|i1notes
argument_list|)
expr_stmt|;
name|newpat
operator|=
name|copy_rtx_if_shared
argument_list|(
name|newpat
argument_list|)
expr_stmt|;
name|newi2pat
operator|=
name|copy_rtx_if_shared
argument_list|(
name|newi2pat
argument_list|)
expr_stmt|;
if|if
condition|(
name|undobuf
operator|.
name|other_insn
condition|)
name|reset_used_flags
argument_list|(
name|PATTERN
argument_list|(
name|undobuf
operator|.
name|other_insn
argument_list|)
argument_list|)
expr_stmt|;
name|INSN_CODE
argument_list|(
name|i3
argument_list|)
operator|=
name|insn_code_number
expr_stmt|;
name|PATTERN
argument_list|(
name|i3
argument_list|)
operator|=
name|newpat
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|i3
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|i3
argument_list|)
condition|)
block|{
name|rtx
name|call_usage
init|=
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|i3
argument_list|)
decl_stmt|;
name|reset_used_flags
argument_list|(
name|call_usage
argument_list|)
expr_stmt|;
name|call_usage
operator|=
name|copy_rtx
argument_list|(
name|call_usage
argument_list|)
expr_stmt|;
if|if
condition|(
name|substed_i2
condition|)
name|replace_rtx
argument_list|(
name|call_usage
argument_list|,
name|i2dest
argument_list|,
name|i2src
argument_list|)
expr_stmt|;
if|if
condition|(
name|substed_i1
condition|)
name|replace_rtx
argument_list|(
name|call_usage
argument_list|,
name|i1dest
argument_list|,
name|i1src
argument_list|)
expr_stmt|;
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|i3
argument_list|)
operator|=
name|call_usage
expr_stmt|;
block|}
if|if
condition|(
name|undobuf
operator|.
name|other_insn
condition|)
name|INSN_CODE
argument_list|(
name|undobuf
operator|.
name|other_insn
argument_list|)
operator|=
name|other_code_number
expr_stmt|;
comment|/* We had one special case above where I2 had more than one set and        we replaced a destination of one of those sets with the destination        of I3.  In that case, we have to update LOG_LINKS of insns later        in this basic block.  Note that this (expensive) case is rare.         Also, in this case, we must pretend that all REG_NOTEs for I2        actually came from I3, so that REG_UNUSED notes from I2 will be        properly handled.  */
if|if
condition|(
name|i3_subst_into_i2
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|i2
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|i2
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|!=
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|i2
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|i2
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|!=
name|i2dest
operator|&&
operator|!
name|find_reg_note
argument_list|(
name|i2
argument_list|,
name|REG_UNUSED
argument_list|,
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|i2
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
condition|)
for|for
control|(
name|temp
operator|=
name|NEXT_INSN
argument_list|(
name|i2
argument_list|)
init|;
name|temp
operator|&&
operator|(
name|this_basic_block
operator|->
name|next_bb
operator|==
name|EXIT_BLOCK_PTR
operator|||
name|this_basic_block
operator|->
name|head
operator|!=
name|temp
operator|)
condition|;
name|temp
operator|=
name|NEXT_INSN
argument_list|(
name|temp
argument_list|)
control|)
if|if
condition|(
name|temp
operator|!=
name|i3
operator|&&
name|INSN_P
argument_list|(
name|temp
argument_list|)
condition|)
for|for
control|(
name|link
operator|=
name|LOG_LINKS
argument_list|(
name|temp
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
operator|==
name|i2
condition|)
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
operator|=
name|i3
expr_stmt|;
if|if
condition|(
name|i3notes
condition|)
block|{
name|rtx
name|link
init|=
name|i3notes
decl_stmt|;
while|while
condition|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
condition|)
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
operator|=
name|i2notes
expr_stmt|;
block|}
else|else
name|i3notes
operator|=
name|i2notes
expr_stmt|;
name|i2notes
operator|=
literal|0
expr_stmt|;
block|}
name|LOG_LINKS
argument_list|(
name|i3
argument_list|)
operator|=
literal|0
expr_stmt|;
name|REG_NOTES
argument_list|(
name|i3
argument_list|)
operator|=
literal|0
expr_stmt|;
name|LOG_LINKS
argument_list|(
name|i2
argument_list|)
operator|=
literal|0
expr_stmt|;
name|REG_NOTES
argument_list|(
name|i2
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|newi2pat
condition|)
block|{
name|INSN_CODE
argument_list|(
name|i2
argument_list|)
operator|=
name|i2_code_number
expr_stmt|;
name|PATTERN
argument_list|(
name|i2
argument_list|)
operator|=
name|newi2pat
expr_stmt|;
block|}
else|else
block|{
name|PUT_CODE
argument_list|(
name|i2
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|i2
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|i2
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|i1
condition|)
block|{
name|LOG_LINKS
argument_list|(
name|i1
argument_list|)
operator|=
literal|0
expr_stmt|;
name|REG_NOTES
argument_list|(
name|i1
argument_list|)
operator|=
literal|0
expr_stmt|;
name|PUT_CODE
argument_list|(
name|i1
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|i1
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|i1
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Get death notes for everything that is now used in either I3 or        I2 and used to die in a previous insn.  If we built two new        patterns, move from I1 to I2 then I2 to I3 so that we get the        proper movement on registers that I2 modifies.  */
if|if
condition|(
name|newi2pat
condition|)
block|{
name|move_deaths
argument_list|(
name|newi2pat
argument_list|,
name|NULL_RTX
argument_list|,
name|INSN_CUID
argument_list|(
name|i1
argument_list|)
argument_list|,
name|i2
argument_list|,
operator|&
name|midnotes
argument_list|)
expr_stmt|;
name|move_deaths
argument_list|(
name|newpat
argument_list|,
name|newi2pat
argument_list|,
name|INSN_CUID
argument_list|(
name|i1
argument_list|)
argument_list|,
name|i3
argument_list|,
operator|&
name|midnotes
argument_list|)
expr_stmt|;
block|}
else|else
name|move_deaths
argument_list|(
name|newpat
argument_list|,
name|NULL_RTX
argument_list|,
name|i1
condition|?
name|INSN_CUID
argument_list|(
name|i1
argument_list|)
else|:
name|INSN_CUID
argument_list|(
name|i2
argument_list|)
argument_list|,
name|i3
argument_list|,
operator|&
name|midnotes
argument_list|)
expr_stmt|;
comment|/* Distribute all the LOG_LINKS and REG_NOTES from I1, I2, and I3.  */
if|if
condition|(
name|i3notes
condition|)
name|distribute_notes
argument_list|(
name|i3notes
argument_list|,
name|i3
argument_list|,
name|i3
argument_list|,
name|newi2pat
condition|?
name|i2
else|:
name|NULL_RTX
argument_list|,
name|elim_i2
argument_list|,
name|elim_i1
argument_list|)
expr_stmt|;
if|if
condition|(
name|i2notes
condition|)
name|distribute_notes
argument_list|(
name|i2notes
argument_list|,
name|i2
argument_list|,
name|i3
argument_list|,
name|newi2pat
condition|?
name|i2
else|:
name|NULL_RTX
argument_list|,
name|elim_i2
argument_list|,
name|elim_i1
argument_list|)
expr_stmt|;
if|if
condition|(
name|i1notes
condition|)
name|distribute_notes
argument_list|(
name|i1notes
argument_list|,
name|i1
argument_list|,
name|i3
argument_list|,
name|newi2pat
condition|?
name|i2
else|:
name|NULL_RTX
argument_list|,
name|elim_i2
argument_list|,
name|elim_i1
argument_list|)
expr_stmt|;
if|if
condition|(
name|midnotes
condition|)
name|distribute_notes
argument_list|(
name|midnotes
argument_list|,
name|NULL_RTX
argument_list|,
name|i3
argument_list|,
name|newi2pat
condition|?
name|i2
else|:
name|NULL_RTX
argument_list|,
name|elim_i2
argument_list|,
name|elim_i1
argument_list|)
expr_stmt|;
comment|/* Distribute any notes added to I2 or I3 by recog_for_combine.  We        know these are REG_UNUSED and want them to go to the desired insn,        so we always pass it as i3.  We have not counted the notes in        reg_n_deaths yet, so we need to do so now.  */
if|if
condition|(
name|newi2pat
operator|&&
name|new_i2_notes
condition|)
block|{
for|for
control|(
name|temp
operator|=
name|new_i2_notes
init|;
name|temp
condition|;
name|temp
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|REG_N_DEATHS
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|++
expr_stmt|;
name|distribute_notes
argument_list|(
name|new_i2_notes
argument_list|,
name|i2
argument_list|,
name|i2
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|new_i3_notes
condition|)
block|{
for|for
control|(
name|temp
operator|=
name|new_i3_notes
init|;
name|temp
condition|;
name|temp
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|REG_N_DEATHS
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|++
expr_stmt|;
name|distribute_notes
argument_list|(
name|new_i3_notes
argument_list|,
name|i3
argument_list|,
name|i3
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
comment|/* If I3DEST was used in I3SRC, it really died in I3.  We may need to        put a REG_DEAD note for it somewhere.  If NEWI2PAT exists and sets        I3DEST, the death must be somewhere before I2, not I3.  If we passed I3        in that case, it might delete I2.  Similarly for I2 and I1.        Show an additional death due to the REG_DEAD note we make here.  If        we discard it in distribute_notes, we will decrement it again.  */
if|if
condition|(
name|i3dest_killed
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|i3dest_killed
argument_list|)
operator|==
name|REG
condition|)
name|REG_N_DEATHS
argument_list|(
name|REGNO
argument_list|(
name|i3dest_killed
argument_list|)
argument_list|)
operator|++
expr_stmt|;
if|if
condition|(
name|newi2pat
operator|&&
name|reg_set_p
argument_list|(
name|i3dest_killed
argument_list|,
name|newi2pat
argument_list|)
condition|)
name|distribute_notes
argument_list|(
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_DEAD
argument_list|,
name|i3dest_killed
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|i2
argument_list|,
name|NULL_RTX
argument_list|,
name|elim_i2
argument_list|,
name|elim_i1
argument_list|)
expr_stmt|;
else|else
name|distribute_notes
argument_list|(
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_DEAD
argument_list|,
name|i3dest_killed
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|i3
argument_list|,
name|newi2pat
condition|?
name|i2
else|:
name|NULL_RTX
argument_list|,
name|elim_i2
argument_list|,
name|elim_i1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i2dest_in_i2src
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|i2dest
argument_list|)
operator|==
name|REG
condition|)
name|REG_N_DEATHS
argument_list|(
name|REGNO
argument_list|(
name|i2dest
argument_list|)
argument_list|)
operator|++
expr_stmt|;
if|if
condition|(
name|newi2pat
operator|&&
name|reg_set_p
argument_list|(
name|i2dest
argument_list|,
name|newi2pat
argument_list|)
condition|)
name|distribute_notes
argument_list|(
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_DEAD
argument_list|,
name|i2dest
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|i2
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
else|else
name|distribute_notes
argument_list|(
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_DEAD
argument_list|,
name|i2dest
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|i3
argument_list|,
name|newi2pat
condition|?
name|i2
else|:
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i1dest_in_i1src
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|i1dest
argument_list|)
operator|==
name|REG
condition|)
name|REG_N_DEATHS
argument_list|(
name|REGNO
argument_list|(
name|i1dest
argument_list|)
argument_list|)
operator|++
expr_stmt|;
if|if
condition|(
name|newi2pat
operator|&&
name|reg_set_p
argument_list|(
name|i1dest
argument_list|,
name|newi2pat
argument_list|)
condition|)
name|distribute_notes
argument_list|(
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_DEAD
argument_list|,
name|i1dest
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|i2
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
else|else
name|distribute_notes
argument_list|(
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_DEAD
argument_list|,
name|i1dest
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|i3
argument_list|,
name|newi2pat
condition|?
name|i2
else|:
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
name|distribute_links
argument_list|(
name|i3links
argument_list|)
expr_stmt|;
name|distribute_links
argument_list|(
name|i2links
argument_list|)
expr_stmt|;
name|distribute_links
argument_list|(
name|i1links
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|i2dest
argument_list|)
operator|==
name|REG
condition|)
block|{
name|rtx
name|link
decl_stmt|;
name|rtx
name|i2_insn
init|=
literal|0
decl_stmt|,
name|i2_val
init|=
literal|0
decl_stmt|,
name|set
decl_stmt|;
comment|/* The insn that used to set this register doesn't exist, and 	   this life of the register may not exist either.  See if one of 	   I3's links points to an insn that sets I2DEST.  If it does, 	   that is now the last known value for I2DEST. If we don't update 	   this and I2 set the register to a value that depended on its old 	   contents, we will get confused.  If this insn is used, thing 	   will be set correctly in combine_instructions.  */
for|for
control|(
name|link
operator|=
name|LOG_LINKS
argument_list|(
name|i3
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|rtx_equal_p
argument_list|(
name|i2dest
argument_list|,
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
condition|)
name|i2_insn
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
operator|,
name|i2_val
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|record_value_for_reg
argument_list|(
name|i2dest
argument_list|,
name|i2_insn
argument_list|,
name|i2_val
argument_list|)
expr_stmt|;
comment|/* If the reg formerly set in I2 died only once and that was in I3, 	   zero its use count so it won't make `reload' do any work.  */
if|if
condition|(
operator|!
name|added_sets_2
operator|&&
operator|(
name|newi2pat
operator|==
literal|0
operator|||
operator|!
name|reg_mentioned_p
argument_list|(
name|i2dest
argument_list|,
name|newi2pat
argument_list|)
operator|)
operator|&&
operator|!
name|i2dest_in_i2src
condition|)
block|{
name|regno
operator|=
name|REGNO
argument_list|(
name|i2dest
argument_list|)
expr_stmt|;
name|REG_N_SETS
argument_list|(
name|regno
argument_list|)
operator|--
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i1
operator|&&
name|GET_CODE
argument_list|(
name|i1dest
argument_list|)
operator|==
name|REG
condition|)
block|{
name|rtx
name|link
decl_stmt|;
name|rtx
name|i1_insn
init|=
literal|0
decl_stmt|,
name|i1_val
init|=
literal|0
decl_stmt|,
name|set
decl_stmt|;
for|for
control|(
name|link
operator|=
name|LOG_LINKS
argument_list|(
name|i3
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|rtx_equal_p
argument_list|(
name|i1dest
argument_list|,
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
condition|)
name|i1_insn
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
operator|,
name|i1_val
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|record_value_for_reg
argument_list|(
name|i1dest
argument_list|,
name|i1_insn
argument_list|,
name|i1_val
argument_list|)
expr_stmt|;
name|regno
operator|=
name|REGNO
argument_list|(
name|i1dest
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|added_sets_1
operator|&&
operator|!
name|i1dest_in_i1src
condition|)
name|REG_N_SETS
argument_list|(
name|regno
argument_list|)
operator|--
expr_stmt|;
block|}
comment|/* Update reg_nonzero_bits et al for any changes that may have been made        to this insn.  The order of set_nonzero_bits_and_sign_copies() is        important.  Because newi2pat can affect nonzero_bits of newpat */
if|if
condition|(
name|newi2pat
condition|)
name|note_stores
argument_list|(
name|newi2pat
argument_list|,
name|set_nonzero_bits_and_sign_copies
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|note_stores
argument_list|(
name|newpat
argument_list|,
name|set_nonzero_bits_and_sign_copies
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Set new_direct_jump_p if a new return or simple jump instruction        has been created.         If I3 is now an unconditional jump, ensure that it has a        BARRIER following it since it may have initially been a        conditional jump.  It may also be the last nonnote insn.  */
if|if
condition|(
name|returnjump_p
argument_list|(
name|i3
argument_list|)
operator|||
name|any_uncondjump_p
argument_list|(
name|i3
argument_list|)
condition|)
block|{
operator|*
name|new_direct_jump_p
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|temp
operator|=
name|next_nonnote_insn
argument_list|(
name|i3
argument_list|)
operator|)
operator|==
name|NULL_RTX
operator|||
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|!=
name|BARRIER
condition|)
name|emit_barrier_after
argument_list|(
name|i3
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|undobuf
operator|.
name|other_insn
operator|!=
name|NULL_RTX
operator|&&
operator|(
name|returnjump_p
argument_list|(
name|undobuf
operator|.
name|other_insn
argument_list|)
operator|||
name|any_uncondjump_p
argument_list|(
name|undobuf
operator|.
name|other_insn
argument_list|)
operator|)
condition|)
block|{
operator|*
name|new_direct_jump_p
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|temp
operator|=
name|next_nonnote_insn
argument_list|(
name|undobuf
operator|.
name|other_insn
argument_list|)
operator|)
operator|==
name|NULL_RTX
operator|||
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|!=
name|BARRIER
condition|)
name|emit_barrier_after
argument_list|(
name|undobuf
operator|.
name|other_insn
argument_list|)
expr_stmt|;
block|}
comment|/* An NOOP jump does not need barrier, but it does need cleaning up        of CFG.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|newpat
argument_list|)
operator|==
name|SET
operator|&&
name|SET_SRC
argument_list|(
name|newpat
argument_list|)
operator|==
name|pc_rtx
operator|&&
name|SET_DEST
argument_list|(
name|newpat
argument_list|)
operator|==
name|pc_rtx
condition|)
operator|*
name|new_direct_jump_p
operator|=
literal|1
expr_stmt|;
block|}
name|combine_successes
operator|++
expr_stmt|;
name|undo_commit
argument_list|()
expr_stmt|;
comment|/* Clear this here, so that subsequent get_last_value calls are not      affected.  */
name|subst_prev_insn
operator|=
name|NULL_RTX
expr_stmt|;
if|if
condition|(
name|added_links_insn
operator|&&
operator|(
name|newi2pat
operator|==
literal|0
operator|||
name|INSN_CUID
argument_list|(
name|added_links_insn
argument_list|)
operator|<
name|INSN_CUID
argument_list|(
name|i2
argument_list|)
operator|)
operator|&&
name|INSN_CUID
argument_list|(
name|added_links_insn
argument_list|)
operator|<
name|INSN_CUID
argument_list|(
name|i3
argument_list|)
condition|)
return|return
name|added_links_insn
return|;
else|else
return|return
name|newi2pat
condition|?
name|i2
else|:
name|i3
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Undo all the modifications recorded in undobuf.  */
end_comment

begin_function
specifier|static
name|void
name|undo_all
parameter_list|()
block|{
name|struct
name|undo
modifier|*
name|undo
decl_stmt|,
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|undo
operator|=
name|undobuf
operator|.
name|undos
init|;
name|undo
condition|;
name|undo
operator|=
name|next
control|)
block|{
name|next
operator|=
name|undo
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|undo
operator|->
name|is_int
condition|)
operator|*
name|undo
operator|->
name|where
operator|.
name|i
operator|=
name|undo
operator|->
name|old_contents
operator|.
name|i
expr_stmt|;
else|else
operator|*
name|undo
operator|->
name|where
operator|.
name|r
operator|=
name|undo
operator|->
name|old_contents
operator|.
name|r
expr_stmt|;
name|undo
operator|->
name|next
operator|=
name|undobuf
operator|.
name|frees
expr_stmt|;
name|undobuf
operator|.
name|frees
operator|=
name|undo
expr_stmt|;
block|}
name|undobuf
operator|.
name|undos
operator|=
literal|0
expr_stmt|;
comment|/* Clear this here, so that subsequent get_last_value calls are not      affected.  */
name|subst_prev_insn
operator|=
name|NULL_RTX
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We've committed to accepting the changes we made.  Move all    of the undos to the free list.  */
end_comment

begin_function
specifier|static
name|void
name|undo_commit
parameter_list|()
block|{
name|struct
name|undo
modifier|*
name|undo
decl_stmt|,
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|undo
operator|=
name|undobuf
operator|.
name|undos
init|;
name|undo
condition|;
name|undo
operator|=
name|next
control|)
block|{
name|next
operator|=
name|undo
operator|->
name|next
expr_stmt|;
name|undo
operator|->
name|next
operator|=
name|undobuf
operator|.
name|frees
expr_stmt|;
name|undobuf
operator|.
name|frees
operator|=
name|undo
expr_stmt|;
block|}
name|undobuf
operator|.
name|undos
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find the innermost point within the rtx at LOC, possibly LOC itself,    where we have an arithmetic expression and return that point.  LOC will    be inside INSN.     try_combine will call this function to see if an insn can be split into    two insns.  */
end_comment

begin_function
specifier|static
name|rtx
modifier|*
name|find_split_point
parameter_list|(
name|loc
parameter_list|,
name|insn
parameter_list|)
name|rtx
modifier|*
name|loc
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|x
init|=
operator|*
name|loc
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
modifier|*
name|split
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|len
init|=
literal|0
decl_stmt|;
name|HOST_WIDE_INT
name|pos
init|=
literal|0
decl_stmt|;
name|int
name|unsignedp
init|=
literal|0
decl_stmt|;
name|rtx
name|inner
init|=
name|NULL_RTX
decl_stmt|;
comment|/* First special-case some codes.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|SUBREG
case|:
ifdef|#
directive|ifdef
name|INSN_SCHEDULING
comment|/* If we are making a paradoxical SUBREG invalid, it becomes a split 	 point.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
return|return
name|loc
return|;
endif|#
directive|endif
return|return
name|find_split_point
argument_list|(
operator|&
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
name|insn
argument_list|)
return|;
case|case
name|MEM
case|:
ifdef|#
directive|ifdef
name|HAVE_lo_sum
comment|/* If we have (mem (const ..)) or (mem (symbol_ref ...)), split it 	 using LO_SUM and HIGH.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
block|{
name|SUBST
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|gen_rtx_LO_SUM
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_HIGH
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
block|}
endif|#
directive|endif
comment|/* If we have a PLUS whose second operand is a constant and the 	 address is not valid, perhaps will can split it up using 	 the machine-specific way to split large constants.  We use 	 the first pseudo-reg (one of the virtual regs) as a placeholder; 	 it will not remain in the result.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|!
name|memory_address_p
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|reg
init|=
name|regno_reg_rtx
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
name|rtx
name|seq
init|=
name|split_insns
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|subst_insn
argument_list|)
decl_stmt|;
comment|/* This should have produced two insns, each of which sets our 	     placeholder.  If the source of the second is a valid address, 	     we can make put both sources together and make a split point 	     in the middle.  */
if|if
condition|(
name|seq
operator|&&
name|NEXT_INSN
argument_list|(
name|seq
argument_list|)
operator|!=
name|NULL_RTX
operator|&&
name|NEXT_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|seq
argument_list|)
argument_list|)
operator|==
name|NULL_RTX
operator|&&
name|GET_CODE
argument_list|(
name|seq
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|seq
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|seq
argument_list|)
argument_list|)
operator|==
name|reg
operator|&&
operator|!
name|reg_mentioned_p
argument_list|(
name|reg
argument_list|,
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|seq
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|seq
argument_list|)
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|NEXT_INSN
argument_list|(
name|seq
argument_list|)
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|NEXT_INSN
argument_list|(
name|seq
argument_list|)
argument_list|)
argument_list|)
operator|==
name|reg
operator|&&
name|memory_address_p
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|NEXT_INSN
argument_list|(
name|seq
argument_list|)
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|src1
init|=
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|seq
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|src2
init|=
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|NEXT_INSN
argument_list|(
name|seq
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Replace the placeholder in SRC2 with SRC1.  If we can 		 find where in SRC2 it was placed, that can become our 		 split point and we can replace this address with SRC2. 		 Just try two obvious places.  */
name|src2
operator|=
name|replace_rtx
argument_list|(
name|src2
argument_list|,
name|reg
argument_list|,
name|src1
argument_list|)
expr_stmt|;
name|split
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|XEXP
argument_list|(
name|src2
argument_list|,
literal|0
argument_list|)
operator|==
name|src1
condition|)
name|split
operator|=
operator|&
name|XEXP
argument_list|(
name|src2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src2
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'e'
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|src2
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|src1
condition|)
name|split
operator|=
operator|&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|src2
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|split
condition|)
block|{
name|SUBST
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|src2
argument_list|)
expr_stmt|;
return|return
name|split
return|;
block|}
block|}
comment|/* If that didn't work, perhaps the first operand is complex and 	     needs to be computed separately, so make a split point there. 	     This will occur on machines that just support REG + CONST 	     and have a constant moved through some previous computation.  */
elseif|else
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
literal|'o'
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'o'
operator|)
operator|)
condition|)
return|return
operator|&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
block|}
break|break;
case|case
name|SET
case|:
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* If SET_DEST is CC0 and SET_SRC is not an operand, a COMPARE, or a 	 ZERO_EXTRACT, the most likely reason why this doesn't match is that 	 we need to put the operand into a register.  So split at that 	 point.  */
if|if
condition|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|==
name|cc0_rtx
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|COMPARE
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|ZERO_EXTRACT
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|!=
literal|'o'
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'o'
operator|)
condition|)
return|return
operator|&
name|SET_SRC
argument_list|(
name|x
argument_list|)
return|;
endif|#
directive|endif
comment|/* See if we can split SET_SRC as it stands.  */
name|split
operator|=
name|find_split_point
argument_list|(
operator|&
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|split
operator|&&
name|split
operator|!=
operator|&
name|SET_SRC
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|split
return|;
comment|/* See if we can split SET_DEST as it stands.  */
name|split
operator|=
name|find_split_point
argument_list|(
operator|&
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|split
operator|&&
name|split
operator|!=
operator|&
name|SET_DEST
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|split
return|;
comment|/* See if this is a bitfield assignment with everything constant.  If 	 so, this is an IOR of an AND, so split it into that.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|&&
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|+
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|)
operator|<=
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|HOST_WIDE_INT
name|pos
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|len
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|src
init|=
name|INTVAL
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|dest
init|=
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|mask
init|=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|len
operator|)
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|BITS_BIG_ENDIAN
condition|)
name|pos
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
name|len
operator|-
name|pos
expr_stmt|;
if|if
condition|(
name|src
operator|==
name|mask
condition|)
name|SUBST
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|gen_binary
argument_list|(
name|IOR
argument_list|,
name|mode
argument_list|,
name|dest
argument_list|,
name|GEN_INT
argument_list|(
name|src
operator|<<
name|pos
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SUBST
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|gen_binary
argument_list|(
name|IOR
argument_list|,
name|mode
argument_list|,
name|gen_binary
argument_list|(
name|AND
argument_list|,
name|mode
argument_list|,
name|dest
argument_list|,
name|gen_int_mode
argument_list|(
operator|~
operator|(
name|mask
operator|<<
name|pos
operator|)
argument_list|,
name|mode
argument_list|)
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|src
operator|<<
name|pos
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SUBST
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|split
operator|=
name|find_split_point
argument_list|(
operator|&
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|split
operator|&&
name|split
operator|!=
operator|&
name|SET_SRC
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|split
return|;
block|}
comment|/* Otherwise, see if this is an operation that we can split into two. 	 If so, try to split that.  */
name|code
operator|=
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|AND
case|:
comment|/* If we are AND'ing with a large constant that is only a single 	     bit and the result is only being used in a context where we 	     need to know if it is zero or nonzero, replace it with a bit 	     extraction.  This will avoid the large constant, which might 	     have taken more than one insn to make.  If the constant were 	     not a valid argument to the AND but took only one insn to make, 	     this is no worse, but if it took more than one insn, it will 	     be better.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|pos
operator|=
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|>=
literal|7
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|split
operator|=
name|find_single_use
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|insn
argument_list|,
operator|(
name|rtx
operator|*
operator|)
literal|0
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|GET_CODE
argument_list|(
operator|*
name|split
argument_list|)
operator|==
name|EQ
operator|||
name|GET_CODE
argument_list|(
operator|*
name|split
argument_list|)
operator|==
name|NE
operator|)
operator|&&
name|XEXP
argument_list|(
operator|*
name|split
argument_list|,
literal|0
argument_list|)
operator|==
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|&&
name|XEXP
argument_list|(
operator|*
name|split
argument_list|,
literal|1
argument_list|)
operator|==
name|const0_rtx
condition|)
block|{
name|rtx
name|extraction
init|=
name|make_extraction
argument_list|(
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|pos
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|extraction
operator|!=
literal|0
condition|)
block|{
name|SUBST
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|extraction
argument_list|)
expr_stmt|;
return|return
name|find_split_point
argument_list|(
name|loc
argument_list|,
name|insn
argument_list|)
return|;
block|}
block|}
break|break;
case|case
name|NE
case|:
comment|/* if STORE_FLAG_VALUE is -1, this is (NE X 0) and only one bit of X 	     is known to be on, this can be converted into a NEG of a shift.  */
if|if
condition|(
name|STORE_FLAG_VALUE
operator|==
operator|-
literal|1
operator|&&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|const0_rtx
operator|&&
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
literal|1
operator|<=
operator|(
name|pos
operator|=
name|exact_log2
argument_list|(
name|nonzero_bits
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|SUBST
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|gen_rtx_NEG
argument_list|(
name|mode
argument_list|,
name|gen_rtx_LSHIFTRT
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|pos
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|split
operator|=
name|find_split_point
argument_list|(
operator|&
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|split
operator|&&
name|split
operator|!=
operator|&
name|SET_SRC
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|split
return|;
block|}
break|break;
case|case
name|SIGN_EXTEND
case|:
name|inner
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* We can't optimize if either mode is a partial integer 	     mode as we don't know how many bits are significant 	     in those modes.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|inner
argument_list|)
argument_list|)
operator|==
name|MODE_PARTIAL_INT
operator|||
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MODE_PARTIAL_INT
condition|)
break|break;
name|pos
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|inner
argument_list|)
argument_list|)
expr_stmt|;
name|unsignedp
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SIGN_EXTRACT
case|:
case|case
name|ZERO_EXTRACT
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|inner
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|len
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|pos
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|BITS_BIG_ENDIAN
condition|)
name|pos
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|inner
argument_list|)
argument_list|)
operator|-
name|len
operator|-
name|pos
expr_stmt|;
name|unsignedp
operator|=
operator|(
name|code
operator|==
name|ZERO_EXTRACT
operator|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|len
operator|&&
name|pos
operator|>=
literal|0
operator|&&
name|pos
operator|+
name|len
operator|<=
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|inner
argument_list|)
argument_list|)
condition|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
comment|/* For unsigned, we have a choice of a shift followed by an 	     AND or two shifts.  Use two shifts for field sizes where the 	     constant might be too large.  We assume here that we can 	     always at least get 8-bit constants in an AND insn, which is 	     true for every current RISC.  */
if|if
condition|(
name|unsignedp
operator|&&
name|len
operator|<=
literal|8
condition|)
block|{
name|SUBST
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|gen_rtx_AND
argument_list|(
name|mode
argument_list|,
name|gen_rtx_LSHIFTRT
argument_list|(
name|mode
argument_list|,
name|gen_lowpart_for_combine
argument_list|(
name|mode
argument_list|,
name|inner
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|pos
argument_list|)
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|len
operator|)
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|split
operator|=
name|find_split_point
argument_list|(
operator|&
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|split
operator|&&
name|split
operator|!=
operator|&
name|SET_SRC
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|split
return|;
block|}
else|else
block|{
name|SUBST
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|unsignedp
condition|?
name|LSHIFTRT
else|:
name|ASHIFTRT
argument_list|,
name|mode
argument_list|,
name|gen_rtx_ASHIFT
argument_list|(
name|mode
argument_list|,
name|gen_lowpart_for_combine
argument_list|(
name|mode
argument_list|,
name|inner
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
name|len
operator|-
name|pos
argument_list|)
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
name|len
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|split
operator|=
name|find_split_point
argument_list|(
operator|&
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|split
operator|&&
name|split
operator|!=
operator|&
name|SET_SRC
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|split
return|;
block|}
block|}
comment|/* See if this is a simple operation with a constant as the second 	 operand.  It might be that this constant is out of range and hence 	 could be used as a split point.  */
if|if
condition|(
operator|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'2'
operator|||
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'c'
operator|||
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|)
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
operator|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'o'
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'o'
operator|)
operator|)
operator|)
condition|)
return|return
operator|&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|)
return|;
comment|/* Finally, see if this is a simple operation with its first operand 	 not in a register.  The operation might require this operand in a 	 register, so return it as a split point.  We can always do this 	 because if the first operand were another operation, we would have 	 already found it as a split point.  */
if|if
condition|(
operator|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'2'
operator|||
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'c'
operator|||
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|||
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'1'
operator|)
operator|&&
operator|!
name|register_operand
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
condition|)
return|return
operator|&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
return|return
literal|0
return|;
case|case
name|AND
case|:
case|case
name|IOR
case|:
comment|/* We write NOR as (and (not A) (not B)), but if we don't have a NOR, 	 it is better to write this as (not (ior A B)) so we can split it. 	 Similarly for IOR.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NOT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|NOT
condition|)
block|{
name|SUBST
argument_list|(
operator|*
name|loc
argument_list|,
name|gen_rtx_NOT
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|code
operator|==
name|IOR
condition|?
name|AND
else|:
name|IOR
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|find_split_point
argument_list|(
name|loc
argument_list|,
name|insn
argument_list|)
return|;
block|}
comment|/* Many RISC machines have a large set of logical insns.  If the 	 second operand is a NOT, put it first so we will try to split the 	 other operand first.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|NOT
condition|)
block|{
name|rtx
name|tem
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|SUBST
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|SUBST
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|tem
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
comment|/* Otherwise, select our actions depending on our rtx class.  */
switch|switch
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
literal|'b'
case|:
comment|/* This is ZERO_EXTRACT and SIGN_EXTRACT.  */
case|case
literal|'3'
case|:
name|split
operator|=
name|find_split_point
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|split
condition|)
return|return
name|split
return|;
comment|/* ... fall through ...  */
case|case
literal|'2'
case|:
case|case
literal|'c'
case|:
case|case
literal|'<'
case|:
name|split
operator|=
name|find_split_point
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|split
condition|)
return|return
name|split
return|;
comment|/* ... fall through ...  */
case|case
literal|'1'
case|:
comment|/* Some machines have (and (shift ...) ...) insns.  If X is not 	 an AND, but XEXP (X, 0) is, use it as our split point.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|AND
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|AND
condition|)
return|return
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
return|;
name|split
operator|=
name|find_split_point
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|split
condition|)
return|return
name|split
return|;
return|return
name|loc
return|;
block|}
comment|/* Otherwise, we don't have a split point.  */
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Throughout X, replace FROM with TO, and return the result.    The result is TO if X is FROM;    otherwise the result is X, but its contents may have been modified.    If they were modified, a record was made in undobuf so that    undo_all will (among other things) return X to its original state.     If the number of changes necessary is too much to record to undo,    the excess changes are not made, so the result is invalid.    The changes already made can still be undone.    undobuf.num_undo is incremented for such changes, so by testing that    the caller can tell whether the result is valid.     `n_occurrences' is incremented each time FROM is replaced.     IN_DEST is nonzero if we are processing the SET_DEST of a SET.     UNIQUE_COPY is nonzero if each substitution must be unique.  We do this    by copying if `n_occurrences' is nonzero.  */
end_comment

begin_function
specifier|static
name|rtx
name|subst
parameter_list|(
name|x
parameter_list|,
name|from
parameter_list|,
name|to
parameter_list|,
name|in_dest
parameter_list|,
name|unique_copy
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|from
decl_stmt|,
name|to
decl_stmt|;
name|int
name|in_dest
decl_stmt|;
name|int
name|unique_copy
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|op0_mode
init|=
name|VOIDmode
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|len
decl_stmt|,
name|i
decl_stmt|;
name|rtx
name|new
decl_stmt|;
comment|/* Two expressions are equal if they are identical copies of a shared    RTX or if they are both registers with the same register number    and mode.  */
define|#
directive|define
name|COMBINE_RTX_EQUAL_P
parameter_list|(
name|X
parameter_list|,
name|Y
parameter_list|)
define|\
value|((X) == (Y)						\    || (GET_CODE (X) == REG&& GET_CODE (Y) == REG	\&& REGNO (X) == REGNO (Y)&& GET_MODE (X) == GET_MODE (Y)))
if|if
condition|(
operator|!
name|in_dest
operator|&&
name|COMBINE_RTX_EQUAL_P
argument_list|(
name|x
argument_list|,
name|from
argument_list|)
condition|)
block|{
name|n_occurrences
operator|++
expr_stmt|;
return|return
operator|(
name|unique_copy
operator|&&
name|n_occurrences
operator|>
literal|1
condition|?
name|copy_rtx
argument_list|(
name|to
argument_list|)
else|:
name|to
operator|)
return|;
block|}
comment|/* If X and FROM are the same register but different modes, they will      not have been seen as equal above.  However, flow.c will make a      LOG_LINKS entry for that case.  If we do nothing, we will try to      rerecognize our original insn and, when it succeeds, we will      delete the feeding insn, which is incorrect.       So force this insn not to match in this (rare) case.  */
if|if
condition|(
operator|!
name|in_dest
operator|&&
name|code
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|==
name|REGNO
argument_list|(
name|from
argument_list|)
condition|)
return|return
name|gen_rtx_CLOBBER
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
return|;
comment|/* If this is an object, we are done unless it is a MEM or LO_SUM, both      of which may contain things that can be combined.  */
if|if
condition|(
name|code
operator|!=
name|MEM
operator|&&
name|code
operator|!=
name|LO_SUM
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'o'
condition|)
return|return
name|x
return|;
comment|/* It is possible to have a subexpression appear twice in the insn.      Suppose that FROM is a register that appears within TO.      Then, after that subexpression has been scanned once by `subst',      the second time it is scanned, TO may be found.  If we were      to scan TO here, we would find FROM within it and create a      self-referent rtl structure which is completely wrong.  */
if|if
condition|(
name|COMBINE_RTX_EQUAL_P
argument_list|(
name|x
argument_list|,
name|to
argument_list|)
condition|)
return|return
name|to
return|;
comment|/* Parallel asm_operands need special attention because all of the      inputs are shared across the arms.  Furthermore, unsharing the      rtl results in recognition failures.  Failure to handle this case      specially can result in circular rtl.       Solve this by doing a normal pass across the first entry of the      parallel, and only processing the SET_DESTs of the subsequent      entries.  Ug.  */
if|if
condition|(
name|code
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
block|{
name|new
operator|=
name|subst
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
literal|0
argument_list|,
name|unique_copy
argument_list|)
expr_stmt|;
comment|/* If this substitution failed, this whole thing fails.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|new
argument_list|)
operator|==
name|CLOBBER
operator|&&
name|XEXP
argument_list|(
name|new
argument_list|,
literal|0
argument_list|)
operator|==
name|const0_rtx
condition|)
return|return
name|new
return|;
name|SUBST
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|new
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|1
condition|;
name|i
operator|--
control|)
block|{
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|!=
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|!=
name|CC0
operator|&&
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|!=
name|PC
condition|)
block|{
name|new
operator|=
name|subst
argument_list|(
name|dest
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
literal|0
argument_list|,
name|unique_copy
argument_list|)
expr_stmt|;
comment|/* If this substitution failed, this whole thing fails.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|new
argument_list|)
operator|==
name|CLOBBER
operator|&&
name|XEXP
argument_list|(
name|new
argument_list|,
literal|0
argument_list|)
operator|==
name|const0_rtx
condition|)
return|return
name|new
return|;
name|SUBST
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|,
name|new
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|len
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
comment|/* We don't need to process a SET_DEST that is a register, CC0, 	 or PC, so set up to skip this common case.  All other cases 	 where we want to suppress replacing something inside a 	 SET_SRC are handled via the IN_DEST operand.  */
if|if
condition|(
name|code
operator|==
name|SET
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|CC0
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|PC
operator|)
condition|)
name|fmt
operator|=
literal|"ie"
expr_stmt|;
comment|/* Get the mode of operand 0 in case X is now a SIGN_EXTEND of a 	 constant.  */
if|if
condition|(
name|fmt
index|[
literal|0
index|]
operator|==
literal|'e'
condition|)
name|op0_mode
operator|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
if|if
condition|(
name|COMBINE_RTX_EQUAL_P
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|from
argument_list|)
condition|)
block|{
name|new
operator|=
operator|(
name|unique_copy
operator|&&
name|n_occurrences
condition|?
name|copy_rtx
argument_list|(
name|to
argument_list|)
else|:
name|to
operator|)
expr_stmt|;
name|n_occurrences
operator|++
expr_stmt|;
block|}
else|else
block|{
name|new
operator|=
name|subst
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
literal|0
argument_list|,
name|unique_copy
argument_list|)
expr_stmt|;
comment|/* If this substitution failed, this whole thing 			 fails.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|new
argument_list|)
operator|==
name|CLOBBER
operator|&&
name|XEXP
argument_list|(
name|new
argument_list|,
literal|0
argument_list|)
operator|==
name|const0_rtx
condition|)
return|return
name|new
return|;
block|}
name|SUBST
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|new
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
comment|/* If this is a register being set, ignore it.  */
name|new
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_dest
operator|&&
operator|(
name|code
operator|==
name|SUBREG
operator|||
name|code
operator|==
name|STRICT_LOW_PART
operator|||
name|code
operator|==
name|ZERO_EXTRACT
operator|)
operator|&&
name|i
operator|==
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|new
argument_list|)
operator|==
name|REG
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|COMBINE_RTX_EQUAL_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|from
argument_list|)
condition|)
block|{
comment|/* In general, don't install a subreg involving two 		     modes not tieable.  It can worsen register 		     allocation, and can even make invalid reload 		     insns, since the reg inside may need to be copied 		     from in the outside mode, and that may be invalid 		     if it is an fp reg copied in integer mode.  		     We allow two exceptions to this: It is valid if 		     it is inside another SUBREG and the mode of that 		     SUBREG and the mode of the inside of TO is 		     tieable and it is valid if X is a SET that copies 		     FROM to CC0.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|!
name|MODES_TIEABLE_P
argument_list|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|to
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|!
operator|(
name|code
operator|==
name|SUBREG
operator|&&
name|MODES_TIEABLE_P
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|to
argument_list|)
argument_list|)
argument_list|)
operator|)
ifdef|#
directive|ifdef
name|HAVE_cc0
operator|&&
operator|!
operator|(
name|code
operator|==
name|SET
operator|&&
name|i
operator|==
literal|1
operator|&&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|cc0_rtx
operator|)
endif|#
directive|endif
condition|)
return|return
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|const0_rtx
argument_list|)
return|;
ifdef|#
directive|ifdef
name|CANNOT_CHANGE_MODE_CLASS
if|if
condition|(
name|code
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|to
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|REG_CANNOT_CHANGE_MODE_P
argument_list|(
name|REGNO
argument_list|(
name|to
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
return|return
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|const0_rtx
argument_list|)
return|;
endif|#
directive|endif
name|new
operator|=
operator|(
name|unique_copy
operator|&&
name|n_occurrences
condition|?
name|copy_rtx
argument_list|(
name|to
argument_list|)
else|:
name|to
operator|)
expr_stmt|;
name|n_occurrences
operator|++
expr_stmt|;
block|}
else|else
comment|/* If we are in a SET_DEST, suppress most cases unless we 		   have gone inside a MEM, in which case we want to 		   simplify the address.  We assume here that things that 		   are actually part of the destination have their inner 		   parts in the first expression.  This is true for SUBREG, 		   STRICT_LOW_PART, and ZERO_EXTRACT, which are the only 		   things aside from REG and MEM that should appear in a 		   SET_DEST.  */
name|new
operator|=
name|subst
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
operator|(
operator|(
operator|(
name|in_dest
operator|&&
operator|(
name|code
operator|==
name|SUBREG
operator|||
name|code
operator|==
name|STRICT_LOW_PART
operator|||
name|code
operator|==
name|ZERO_EXTRACT
operator|)
operator|)
operator|||
name|code
operator|==
name|SET
operator|)
operator|&&
name|i
operator|==
literal|0
operator|)
argument_list|,
name|unique_copy
argument_list|)
expr_stmt|;
comment|/* If we found that we will have to reject this combination, 		 indicate that by returning the CLOBBER ourselves, rather than 		 an expression containing it.  This will speed things up as 		 well as prevent accidents where two CLOBBERs are considered 		 to be equal, thus producing an incorrect simplification.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|new
argument_list|)
operator|==
name|CLOBBER
operator|&&
name|XEXP
argument_list|(
name|new
argument_list|,
literal|0
argument_list|)
operator|==
name|const0_rtx
condition|)
return|return
name|new
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|new
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|x
operator|=
name|simplify_subreg
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|new
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|x
condition|)
name|x
operator|=
name|gen_rtx_CLOBBER
argument_list|(
name|mode
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|new
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ZERO_EXTEND
condition|)
block|{
name|x
operator|=
name|simplify_unary_operation
argument_list|(
name|ZERO_EXTEND
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|new
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|x
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
name|SUBST
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|new
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Try to simplify X.  If the simplification changed the code, it is likely      that further simplification will help, so loop, but limit the number      of repetitions that will be performed.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
comment|/* If X is sufficiently simple, don't bother trying to do anything 	 with it.  */
if|if
condition|(
name|code
operator|!=
name|CONST_INT
operator|&&
name|code
operator|!=
name|REG
operator|&&
name|code
operator|!=
name|CLOBBER
condition|)
name|x
operator|=
name|combine_simplify_rtx
argument_list|(
name|x
argument_list|,
name|op0_mode
argument_list|,
name|i
operator|==
literal|3
argument_list|,
name|in_dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|code
condition|)
break|break;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* We no longer know the original mode of operand 0 since we 	 have changed the form of X)  */
name|op0_mode
operator|=
name|VOIDmode
expr_stmt|;
block|}
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Simplify X, a piece of RTL.  We just operate on the expression at the    outer level; call `subst' to simplify recursively.  Return the new    expression.     OP0_MODE is the original mode of XEXP (x, 0); LAST is nonzero if this    will be the iteration even if an expression with a code different from    X is returned; IN_DEST is nonzero if we are inside a SET_DEST.  */
end_comment

begin_function
specifier|static
name|rtx
name|combine_simplify_rtx
parameter_list|(
name|x
parameter_list|,
name|op0_mode
parameter_list|,
name|last
parameter_list|,
name|in_dest
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|enum
name|machine_mode
name|op0_mode
decl_stmt|;
name|int
name|last
decl_stmt|;
name|int
name|in_dest
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
name|rtx
name|reversed
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* If this is a commutative operation, put a constant last and a complex      expression first.  We don't need to do this for comparisons here.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'c'
operator|&&
name|swap_commutative_operands_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|temp
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SUBST
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|SUBST
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
comment|/* If this is a PLUS, MINUS, or MULT, and the first operand is the      sign extension of a PLUS with a constant, reverse the order of the sign      extension and the addition. Note that this not the same as the original      code, but overflow is undefined for signed values.  Also note that the      PLUS will have been partially moved "inside" the sign-extension, so that      the first operand of X will really look like:          (ashiftrt (plus (ashift A C4) C5) C4).      We convert this to          (plus (ashiftrt (ashift A C4) C2) C4)      and replace the first operand of X with that expression.  Later parts      of this function may simplify the expression further.       For example, if we start with (mult (sign_extend (plus A C1)) C2),      we swap the SIGN_EXTEND and PLUS.  Later code will apply the      distributive law to produce (plus (mult (sign_extend X) C1) C3).       We do this to simplify address expressions.  */
if|if
condition|(
operator|(
name|code
operator|==
name|PLUS
operator|||
name|code
operator|==
name|MINUS
operator|||
name|code
operator|==
name|MULT
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ASHIFTRT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ASHIFT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|temp
operator|=
name|simplify_binary_operation
argument_list|(
name|ASHIFTRT
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|rtx
name|new
init|=
name|simplify_shift_const
argument_list|(
name|NULL_RTX
argument_list|,
name|ASHIFT
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|new
operator|=
name|simplify_shift_const
argument_list|(
name|NULL_RTX
argument_list|,
name|ASHIFTRT
argument_list|,
name|mode
argument_list|,
name|new
argument_list|,
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SUBST
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|gen_binary
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|new
argument_list|,
name|temp
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If this is a simple operation applied to an IF_THEN_ELSE, try      applying it to the arms of the IF_THEN_ELSE.  This often simplifies      things.  Check for cases where both arms are testing the same      condition.       Don't do anything if all operands are very simple.  */
if|if
condition|(
operator|(
operator|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'2'
operator|||
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'c'
operator|||
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'<'
operator|)
operator|&&
operator|(
operator|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
literal|'o'
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'o'
operator|)
operator|)
operator|)
operator|||
operator|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|!=
literal|'o'
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'o'
operator|)
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'1'
operator|&&
operator|(
operator|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
literal|'o'
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'o'
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
name|rtx
name|cond
decl_stmt|,
name|true_rtx
decl_stmt|,
name|false_rtx
decl_stmt|;
name|cond
operator|=
name|if_then_else_cond
argument_list|(
name|x
argument_list|,
operator|&
name|true_rtx
argument_list|,
operator|&
name|false_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|cond
operator|!=
literal|0
comment|/* If everything is a comparison, what we have is highly unlikely 	     to be simpler, so don't use it.  */
operator|&&
operator|!
operator|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'<'
operator|&&
operator|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|true_rtx
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|||
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|false_rtx
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|)
operator|)
condition|)
block|{
name|rtx
name|cop1
init|=
name|const0_rtx
decl_stmt|;
name|enum
name|rtx_code
name|cond_code
init|=
name|simplify_comparison
argument_list|(
name|NE
argument_list|,
operator|&
name|cond
argument_list|,
operator|&
name|cop1
argument_list|)
decl_stmt|;
if|if
condition|(
name|cond_code
operator|==
name|NE
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|cond
argument_list|)
argument_list|)
operator|==
literal|'<'
condition|)
return|return
name|x
return|;
comment|/* Simplify the alternative arms; this may collapse the true and 	     false arms to store-flag values.  */
name|true_rtx
operator|=
name|subst
argument_list|(
name|true_rtx
argument_list|,
name|pc_rtx
argument_list|,
name|pc_rtx
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|false_rtx
operator|=
name|subst
argument_list|(
name|false_rtx
argument_list|,
name|pc_rtx
argument_list|,
name|pc_rtx
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If true_rtx and false_rtx are not general_operands, an if_then_else 	     is unlikely to be simpler.  */
if|if
condition|(
name|general_operand
argument_list|(
name|true_rtx
argument_list|,
name|VOIDmode
argument_list|)
operator|&&
name|general_operand
argument_list|(
name|false_rtx
argument_list|,
name|VOIDmode
argument_list|)
condition|)
block|{
comment|/* Restarting if we generate a store-flag expression will cause 		 us to loop.  Just drop through in this case.  */
comment|/* If the result values are STORE_FLAG_VALUE and zero, we can 		 just make the comparison operation.  */
if|if
condition|(
name|true_rtx
operator|==
name|const_true_rtx
operator|&&
name|false_rtx
operator|==
name|const0_rtx
condition|)
name|x
operator|=
name|gen_binary
argument_list|(
name|cond_code
argument_list|,
name|mode
argument_list|,
name|cond
argument_list|,
name|cop1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|true_rtx
operator|==
name|const0_rtx
operator|&&
name|false_rtx
operator|==
name|const_true_rtx
operator|&&
name|reverse_condition
argument_list|(
name|cond_code
argument_list|)
operator|!=
name|UNKNOWN
condition|)
name|x
operator|=
name|gen_binary
argument_list|(
name|reverse_condition
argument_list|(
name|cond_code
argument_list|)
argument_list|,
name|mode
argument_list|,
name|cond
argument_list|,
name|cop1
argument_list|)
expr_stmt|;
comment|/* Likewise, we can make the negate of a comparison operation 		 if the result values are - STORE_FLAG_VALUE and zero.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|true_rtx
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|true_rtx
argument_list|)
operator|==
operator|-
name|STORE_FLAG_VALUE
operator|&&
name|false_rtx
operator|==
name|const0_rtx
condition|)
name|x
operator|=
name|simplify_gen_unary
argument_list|(
name|NEG
argument_list|,
name|mode
argument_list|,
name|gen_binary
argument_list|(
name|cond_code
argument_list|,
name|mode
argument_list|,
name|cond
argument_list|,
name|cop1
argument_list|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|false_rtx
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|false_rtx
argument_list|)
operator|==
operator|-
name|STORE_FLAG_VALUE
operator|&&
name|true_rtx
operator|==
name|const0_rtx
condition|)
name|x
operator|=
name|simplify_gen_unary
argument_list|(
name|NEG
argument_list|,
name|mode
argument_list|,
name|gen_binary
argument_list|(
name|reverse_condition
argument_list|(
name|cond_code
argument_list|)
argument_list|,
name|mode
argument_list|,
name|cond
argument_list|,
name|cop1
argument_list|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
else|else
return|return
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|mode
argument_list|,
name|gen_binary
argument_list|(
name|cond_code
argument_list|,
name|VOIDmode
argument_list|,
name|cond
argument_list|,
name|cop1
argument_list|)
argument_list|,
name|true_rtx
argument_list|,
name|false_rtx
argument_list|)
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|op0_mode
operator|=
name|VOIDmode
expr_stmt|;
block|}
block|}
block|}
comment|/* Try to fold this expression in case we have constants that weren't      present before.  */
name|temp
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
literal|'1'
case|:
name|temp
operator|=
name|simplify_unary_operation
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op0_mode
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
block|{
name|enum
name|machine_mode
name|cmp_mode
init|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp_mode
operator|==
name|VOIDmode
condition|)
block|{
name|cmp_mode
operator|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp_mode
operator|==
name|VOIDmode
condition|)
name|cmp_mode
operator|=
name|op0_mode
expr_stmt|;
block|}
name|temp
operator|=
name|simplify_relational_operation
argument_list|(
name|code
argument_list|,
name|cmp_mode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|FLOAT_STORE_FLAG_VALUE
if|if
condition|(
name|temp
operator|!=
literal|0
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
block|{
if|if
condition|(
name|temp
operator|==
name|const0_rtx
condition|)
name|temp
operator|=
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
expr_stmt|;
else|else
name|temp
operator|=
name|CONST_DOUBLE_FROM_REAL_VALUE
argument_list|(
name|FLOAT_STORE_FLAG_VALUE
argument_list|(
name|mode
argument_list|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
case|case
literal|'c'
case|:
case|case
literal|'2'
case|:
name|temp
operator|=
name|simplify_binary_operation
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
case|case
literal|'3'
case|:
name|temp
operator|=
name|simplify_ternary_operation
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op0_mode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|temp
condition|)
block|{
name|x
operator|=
name|temp
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|op0_mode
operator|=
name|VOIDmode
expr_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
comment|/* First see if we can apply the inverse distributive law.  */
if|if
condition|(
name|code
operator|==
name|PLUS
operator|||
name|code
operator|==
name|MINUS
operator|||
name|code
operator|==
name|AND
operator|||
name|code
operator|==
name|IOR
operator|||
name|code
operator|==
name|XOR
condition|)
block|{
name|x
operator|=
name|apply_distributive_law
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|op0_mode
operator|=
name|VOIDmode
expr_stmt|;
block|}
comment|/* If CODE is an associative operation not otherwise handled, see if we      can associate some operands.  This can win if they are constants or      if they are logically related (i.e. (a& b)& a).  */
if|if
condition|(
operator|(
name|code
operator|==
name|PLUS
operator|||
name|code
operator|==
name|MINUS
operator|||
name|code
operator|==
name|MULT
operator|||
name|code
operator|==
name|DIV
operator|||
name|code
operator|==
name|AND
operator|||
name|code
operator|==
name|IOR
operator|||
name|code
operator|==
name|XOR
operator|||
name|code
operator|==
name|SMAX
operator|||
name|code
operator|==
name|SMIN
operator|||
name|code
operator|==
name|UMAX
operator|||
name|code
operator|==
name|UMIN
operator|)
operator|&&
operator|(
operator|(
name|INTEGRAL_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
name|code
operator|!=
name|DIV
operator|)
operator|||
operator|(
name|flag_unsafe_math_optimizations
operator|&&
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|code
condition|)
block|{
name|rtx
name|other
init|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|inner_op0
init|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|inner_op1
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|inner
decl_stmt|;
comment|/* Make sure we pass the constant operand if any as the second 	     one if this is a commutative operation.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|inner_op0
argument_list|)
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'c'
condition|)
block|{
name|rtx
name|tem
init|=
name|inner_op0
decl_stmt|;
name|inner_op0
operator|=
name|inner_op1
expr_stmt|;
name|inner_op1
operator|=
name|tem
expr_stmt|;
block|}
name|inner
operator|=
name|simplify_binary_operation
argument_list|(
name|code
operator|==
name|MINUS
condition|?
name|PLUS
else|:
name|code
operator|==
name|DIV
condition|?
name|MULT
else|:
name|code
argument_list|,
name|mode
argument_list|,
name|inner_op0
argument_list|,
name|inner_op1
argument_list|)
expr_stmt|;
comment|/* For commutative operations, try the other pair if that one 	     didn't simplify.  */
if|if
condition|(
name|inner
operator|==
literal|0
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'c'
condition|)
block|{
name|other
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|inner
operator|=
name|simplify_binary_operation
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inner
condition|)
return|return
name|gen_binary
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|other
argument_list|,
name|inner
argument_list|)
return|;
block|}
block|}
comment|/* A little bit of algebraic simplification here.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|MEM
case|:
comment|/* Ensure that our address has any ASHIFTs converted to MULT in case 	 address-recognizing predicates are called later.  */
name|temp
operator|=
name|make_compound_operation
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|MEM
argument_list|)
expr_stmt|;
name|SUBST
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUBREG
case|:
if|if
condition|(
name|op0_mode
operator|==
name|VOIDmode
condition|)
name|op0_mode
operator|=
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
comment|/* simplify_subreg can't use gen_lowpart_for_combine.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&&
name|subreg_lowpart_offset
argument_list|(
name|mode
argument_list|,
name|op0_mode
argument_list|)
operator|==
name|SUBREG_BYTE
argument_list|(
name|x
argument_list|)
comment|/* Don't call gen_lowpart_for_combine if the inner mode 		is VOIDmode and we cannot simplify it, as SUBREG without 		inner mode is invalid.  */
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|VOIDmode
operator|||
name|gen_lowpart_common
argument_list|(
name|mode
argument_list|,
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|gen_lowpart_for_combine
argument_list|(
name|mode
argument_list|,
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MODE_CC
condition|)
break|break;
block|{
name|rtx
name|temp
decl_stmt|;
name|temp
operator|=
name|simplify_subreg
argument_list|(
name|mode
argument_list|,
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
name|op0_mode
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
return|return
name|temp
return|;
block|}
comment|/* Don't change the mode of the MEM if that would change the meaning 	 of the address.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
name|MEM_VOLATILE_P
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|||
name|mode_dependent_address_p
argument_list|(
name|XEXP
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|gen_rtx_CLOBBER
argument_list|(
name|mode
argument_list|,
name|const0_rtx
argument_list|)
return|;
comment|/* Note that we cannot do any narrowing for non-constants since 	 we might have been counting on using the fact that some bits were 	 zero.  We now do this in the SET.  */
break|break;
case|case
name|NOT
case|:
comment|/* (not (plus X -1)) can become (neg X).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|constm1_rtx
condition|)
return|return
name|gen_rtx_NEG
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
comment|/* Similarly, (not (neg X)) is (plus X -1).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NEG
condition|)
return|return
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|constm1_rtx
argument_list|)
return|;
comment|/* (not (xor X C)) for C constant is (xor X D) with D = ~C.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|XOR
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|temp
operator|=
name|simplify_unary_operation
argument_list|(
name|NOT
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|gen_binary
argument_list|(
name|XOR
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|temp
argument_list|)
return|;
comment|/* (not (ashift 1 X)) is (rotate ~1 X).  We used to do this for operands 	 other than 1, but that is not valid.  We could do a similar 	 simplification for (not (lshiftrt C X)) where C is just the sign bit, 	 but this doesn't seem common enough to bother with.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ASHIFT
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|const1_rtx
condition|)
return|return
name|gen_rtx_ROTATE
argument_list|(
name|mode
argument_list|,
name|simplify_gen_unary
argument_list|(
name|NOT
argument_list|,
name|mode
argument_list|,
name|const1_rtx
argument_list|,
name|mode
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|subreg_lowpart_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|ASHIFT
operator|&&
name|XEXP
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|const1_rtx
condition|)
block|{
name|enum
name|machine_mode
name|inner_mode
init|=
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|x
operator|=
name|gen_rtx_ROTATE
argument_list|(
name|inner_mode
argument_list|,
name|simplify_gen_unary
argument_list|(
name|NOT
argument_list|,
name|inner_mode
argument_list|,
name|const1_rtx
argument_list|,
name|inner_mode
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|gen_lowpart_for_combine
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
return|;
block|}
comment|/* If STORE_FLAG_VALUE is -1, (not (comparison foo bar)) can be done by 	 reversing the comparison code if valid.  */
if|if
condition|(
name|STORE_FLAG_VALUE
operator|==
operator|-
literal|1
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|&&
operator|(
name|reversed
operator|=
name|reversed_comparison
argument_list|(
name|x
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|reversed
return|;
comment|/* (not (ashiftrt foo C)) where C is the number of bits in FOO minus 1 	 is (ge foo (const_int 0)) if STORE_FLAG_VALUE is -1, so we can 	 perform the above simplification.  */
if|if
condition|(
name|STORE_FLAG_VALUE
operator|==
operator|-
literal|1
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ASHIFTRT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
condition|)
return|return
name|gen_rtx_GE
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
return|;
comment|/* Apply De Morgan's laws to reduce number of patterns for machines 	 with negating logical insns (and-not, nand, etc.).  If result has 	 only one NOT, put it first, since that is how the patterns are 	 coded.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|IOR
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|AND
condition|)
block|{
name|rtx
name|in1
init|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|,
name|in2
init|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|op_mode
decl_stmt|;
name|op_mode
operator|=
name|GET_MODE
argument_list|(
name|in1
argument_list|)
expr_stmt|;
name|in1
operator|=
name|simplify_gen_unary
argument_list|(
name|NOT
argument_list|,
name|op_mode
argument_list|,
name|in1
argument_list|,
name|op_mode
argument_list|)
expr_stmt|;
name|op_mode
operator|=
name|GET_MODE
argument_list|(
name|in2
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_mode
operator|==
name|VOIDmode
condition|)
name|op_mode
operator|=
name|mode
expr_stmt|;
name|in2
operator|=
name|simplify_gen_unary
argument_list|(
name|NOT
argument_list|,
name|op_mode
argument_list|,
name|in2
argument_list|,
name|op_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|in2
argument_list|)
operator|==
name|NOT
operator|&&
name|GET_CODE
argument_list|(
name|in1
argument_list|)
operator|!=
name|NOT
condition|)
block|{
name|rtx
name|tem
init|=
name|in2
decl_stmt|;
name|in2
operator|=
name|in1
expr_stmt|;
name|in1
operator|=
name|tem
expr_stmt|;
block|}
return|return
name|gen_rtx_fmt_ee
argument_list|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|IOR
condition|?
name|AND
else|:
name|IOR
argument_list|,
name|mode
argument_list|,
name|in1
argument_list|,
name|in2
argument_list|)
return|;
block|}
break|break;
case|case
name|NEG
case|:
comment|/* (neg (plus X 1)) can become (not X).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|const1_rtx
condition|)
return|return
name|gen_rtx_NOT
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
comment|/* Similarly, (neg (not X)) is (plus X 1).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NOT
condition|)
return|return
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
return|;
comment|/* (neg (minus X Y)) can become (minus Y X).  This transformation 	 isn't safe for modes with signed zeros, since if X and Y are 	 both +0, (minus Y X) is the same as (minus X Y).  If the rounding 	 mode is towards +infinity (or -infinity) then the two expressions 	 will be rounded differently.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MINUS
operator|&&
operator|!
name|HONOR_SIGNED_ZEROS
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
name|HONOR_SIGN_DEPENDENT_ROUNDING
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|gen_binary
argument_list|(
name|MINUS
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
comment|/* (neg (plus A B)) is canonicalized to (minus (neg A) B).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
operator|!
name|HONOR_SIGNED_ZEROS
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
name|HONOR_SIGN_DEPENDENT_ROUNDING
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|temp
operator|=
name|simplify_gen_unary
argument_list|(
name|NEG
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|temp
operator|=
name|combine_simplify_rtx
argument_list|(
name|temp
argument_list|,
name|mode
argument_list|,
name|last
argument_list|,
name|in_dest
argument_list|)
expr_stmt|;
return|return
name|gen_binary
argument_list|(
name|MINUS
argument_list|,
name|mode
argument_list|,
name|temp
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
comment|/* (neg (mult A B)) becomes (mult (neg A) B).            This works even for floating-point values.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|temp
operator|=
name|simplify_gen_unary
argument_list|(
name|NEG
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
name|gen_binary
argument_list|(
name|MULT
argument_list|,
name|mode
argument_list|,
name|temp
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
comment|/* (neg (xor A 1)) is (plus A -1) if A is known to be either 0 or 1.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|XOR
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|const1_rtx
operator|&&
name|nonzero_bits
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|==
literal|1
condition|)
return|return
name|gen_binary
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|constm1_rtx
argument_list|)
return|;
comment|/* NEG commutes with ASHIFT since it is multiplication.  Only do this 	 if we can then eliminate the NEG (e.g., 	 if the operand is a constant).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ASHIFT
condition|)
block|{
name|temp
operator|=
name|simplify_unary_operation
argument_list|(
name|NEG
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
return|return
name|gen_binary
argument_list|(
name|ASHIFT
argument_list|,
name|mode
argument_list|,
name|temp
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
name|temp
operator|=
name|expand_compound_operation
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For C equal to the width of MODE minus 1, (neg (ashiftrt X C)) can be 	 replaced by (lshiftrt X C).  This will convert 	 (neg (sign_extract X 1 Y)) to (zero_extract X 1 Y).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|ASHIFTRT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
condition|)
return|return
name|simplify_shift_const
argument_list|(
name|temp
argument_list|,
name|LSHIFTRT
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* If X has only a single bit that might be nonzero, say, bit I, convert 	 (neg X) to (ashiftrt (ashift X C-I) C-I) where C is the bitsize of 	 MODE minus 1.  This will convert (neg (zero_extract X 1 Y)) to 	 (sign_extract X 1 Y).  But only do this if TEMP isn't a register 	 or a SUBREG of one since we'd be making the expression more 	 complex if it was just a register.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|!=
name|REG
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
operator|&&
operator|(
name|i
operator|=
name|exact_log2
argument_list|(
name|nonzero_bits
argument_list|(
name|temp
argument_list|,
name|mode
argument_list|)
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|rtx
name|temp1
init|=
name|simplify_shift_const
argument_list|(
name|NULL_RTX
argument_list|,
name|ASHIFTRT
argument_list|,
name|mode
argument_list|,
name|simplify_shift_const
argument_list|(
name|NULL_RTX
argument_list|,
name|ASHIFT
argument_list|,
name|mode
argument_list|,
name|temp
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
operator|-
name|i
argument_list|)
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
operator|-
name|i
argument_list|)
decl_stmt|;
comment|/* If all we did was surround TEMP with the two shifts, we 	     haven't improved anything, so don't use it.  Otherwise, 	     we are better off with TEMP1.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp1
argument_list|)
operator|!=
name|ASHIFTRT
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|temp1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|ASHIFT
operator|||
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|temp1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|!=
name|temp
condition|)
return|return
name|temp1
return|;
block|}
break|break;
case|case
name|TRUNCATE
case|:
comment|/* We can't handle truncation to a partial integer mode here 	 because we don't know the real bitsize of the partial 	 integer mode.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_PARTIAL_INT
condition|)
break|break;
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|TRULY_NOOP_TRUNCATION
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
condition|)
name|SUBST
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|force_to_mode
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* (truncate:SI ({sign,zero}_extend:DI foo:SI)) == foo:SI.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SIGN_EXTEND
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ZERO_EXTEND
operator|)
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|mode
condition|)
return|return
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
comment|/* (truncate:SI (OP:DI ({sign,zero}_extend:DI foo:SI))) is 	 (OP:SI foo:SI) if OP is NEG or ABS.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ABS
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NEG
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SIGN_EXTEND
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ZERO_EXTEND
operator|)
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|mode
condition|)
return|return
name|simplify_gen_unary
argument_list|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
return|;
comment|/* (truncate:SI (subreg:DI (truncate:SI X) 0)) is 	 (truncate:SI x).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TRUNCATE
operator|&&
name|subreg_lowpart_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
comment|/* If we know that the value is already truncated, we can          replace the TRUNCATE with a SUBREG if TRULY_NOOP_TRUNCATION          is nonzero for the corresponding modes.  But don't do this          for an (LSHIFTRT (MULT ...)) since this will cause problems          with the umulXi3_highpart patterns.  */
if|if
condition|(
name|TRULY_NOOP_TRUNCATION
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|num_sign_bit_copies
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|>=
call|(
name|unsigned
name|int
call|)
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|+
literal|1
argument_list|)
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LSHIFTRT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MULT
operator|)
condition|)
return|return
name|gen_lowpart_for_combine
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
comment|/* A truncate of a comparison can be replaced with a subreg if          STORE_FLAG_VALUE permits.  This is like the previous test,          but it works even if the comparison is done in a mode larger          than HOST_BITS_PER_WIDE_INT.  */
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|&&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
name|STORE_FLAG_VALUE
operator|&
operator|~
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
name|gen_lowpart_for_combine
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
comment|/* Similarly, a truncate of a register whose value is a          comparison can be replaced with a subreg if STORE_FLAG_VALUE          permits.  */
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
name|STORE_FLAG_VALUE
operator|&
operator|~
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|)
operator|==
literal|0
operator|&&
operator|(
name|temp
operator|=
name|get_last_value
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|==
literal|'<'
condition|)
return|return
name|gen_lowpart_for_combine
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|FLOAT_TRUNCATE
case|:
comment|/* (float_truncate:SF (float_extend:DF foo:SF)) = foo:SF.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FLOAT_EXTEND
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|mode
condition|)
return|return
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
comment|/* (float_truncate:SF (OP:DF (float_extend:DF foo:sf))) is 	 (OP:SF foo:SF) if OP is NEG or ABS.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ABS
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NEG
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FLOAT_EXTEND
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|mode
condition|)
return|return
name|simplify_gen_unary
argument_list|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
return|;
comment|/* (float_truncate:SF (subreg:DF (float_truncate:SF X) 0)) 	 is (float_truncate:SF x).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|subreg_lowpart_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|FLOAT_TRUNCATE
condition|)
return|return
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
break|break;
ifdef|#
directive|ifdef
name|HAVE_cc0
case|case
name|COMPARE
case|:
comment|/* Convert (compare FOO (const_int 0)) to FOO unless we aren't 	 using cc0, in which case we want to leave it as a COMPARE 	 so we can distinguish it from a register-register-copy.  */
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|const0_rtx
condition|)
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
return|;
comment|/* x - 0 is the same as x unless x's mode has signed zeros and 	 allows rounding towards -infinity.  Under those conditions, 	 0 - 0 is -0.  */
if|if
condition|(
operator|!
operator|(
name|HONOR_SIGNED_ZEROS
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|HONOR_SIGN_DEPENDENT_ROUNDING
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
return|;
break|break;
endif|#
directive|endif
case|case
name|CONST
case|:
comment|/* (const (const X)) can become (const X).  Do it this way rather than 	 returning the inner CONST since CONST can be shared with a 	 REG_EQUAL note.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST
condition|)
name|SUBST
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|HAVE_lo_sum
case|case
name|LO_SUM
case|:
comment|/* Convert (lo_sum (high FOO) FOO) to FOO.  This is necessary so we 	 can add in an offset.  find_split_point will split this address up 	 again if it doesn't match.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|HIGH
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
return|;
break|break;
endif|#
directive|endif
case|case
name|PLUS
case|:
comment|/* Canonicalize (plus (mult (neg B) C) A) to (minus A (mult B C)).        */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MULT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NEG
condition|)
block|{
name|rtx
name|in1
decl_stmt|,
name|in2
decl_stmt|;
name|in1
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|in2
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|gen_binary
argument_list|(
name|MINUS
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|gen_binary
argument_list|(
name|MULT
argument_list|,
name|mode
argument_list|,
name|in1
argument_list|,
name|in2
argument_list|)
argument_list|)
return|;
block|}
comment|/* If we have (plus (plus (A const) B)), associate it so that CONST is 	 outermost.  That's because that's the way indexed addresses are 	 supposed to appear.  This code used to check many more cases, but 	 they are now checked elsewhere.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|gen_binary
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|gen_binary
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
comment|/* (plus (xor (and<foo> (const_int pow2 - 1))<c>)<-c>) 	 when c is (const_int (pow2 + 1) / 2) is a sign extension of a 	 bit-field and can be replaced by either a sign_extend or a 	 sign_extract.  The `and' may be a zero_extend and the two<c>, -<c> constants may be reversed.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|XOR
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
operator|(
operator|(
name|i
operator|=
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|>=
literal|0
operator|||
operator|(
name|i
operator|=
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|>=
literal|0
operator|)
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|AND
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|i
operator|+
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ZERO_EXTEND
operator|&&
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
operator|(
name|unsigned
name|int
operator|)
name|i
operator|+
literal|1
operator|)
operator|)
operator|)
condition|)
return|return
name|simplify_shift_const
argument_list|(
name|NULL_RTX
argument_list|,
name|ASHIFTRT
argument_list|,
name|mode
argument_list|,
name|simplify_shift_const
argument_list|(
name|NULL_RTX
argument_list|,
name|ASHIFT
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
operator|(
name|i
operator|+
literal|1
operator|)
argument_list|)
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
operator|(
name|i
operator|+
literal|1
operator|)
argument_list|)
return|;
comment|/* (plus (comparison A B) C) can become (neg (rev-comp A B)) if 	 C is 1 and STORE_FLAG_VALUE is -1 or if C is -1 and STORE_FLAG_VALUE 	 is 1.  This produces better code than the alternative immediately 	 below.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|&&
operator|(
operator|(
name|STORE_FLAG_VALUE
operator|==
operator|-
literal|1
operator|&&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|const1_rtx
operator|)
operator|||
operator|(
name|STORE_FLAG_VALUE
operator|==
literal|1
operator|&&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|constm1_rtx
operator|)
operator|)
operator|&&
operator|(
name|reversed
operator|=
name|reversed_comparison
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|simplify_gen_unary
argument_list|(
name|NEG
argument_list|,
name|mode
argument_list|,
name|reversed
argument_list|,
name|mode
argument_list|)
return|;
comment|/* If only the low-order bit of X is possibly nonzero, (plus x -1) 	 can become (ashiftrt (ashift (xor x 1) C) C) where C is 	 the bitsize of the mode - 1.  This allows simplification of 	 "a = (b& 8) == 0;"  */
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|constm1_rtx
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
operator|&&
name|nonzero_bits
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|==
literal|1
condition|)
return|return
name|simplify_shift_const
argument_list|(
name|NULL_RTX
argument_list|,
name|ASHIFTRT
argument_list|,
name|mode
argument_list|,
name|simplify_shift_const
argument_list|(
name|NULL_RTX
argument_list|,
name|ASHIFT
argument_list|,
name|mode
argument_list|,
name|gen_rtx_XOR
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|const1_rtx
argument_list|)
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
argument_list|)
return|;
comment|/* If we are adding two things that have no bits in common, convert 	 the addition into an IOR.  This will often be further simplified, 	 for example in cases like ((a& 1) + (a& 2)), which can 	 become a& 3.  */
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
name|nonzero_bits
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|&
name|nonzero_bits
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Try to simplify the expression further.  */
name|rtx
name|tor
init|=
name|gen_binary
argument_list|(
name|IOR
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|temp
operator|=
name|combine_simplify_rtx
argument_list|(
name|tor
argument_list|,
name|mode
argument_list|,
name|last
argument_list|,
name|in_dest
argument_list|)
expr_stmt|;
comment|/* If we could, great.  If not, do not go ahead with the IOR 	     replacement, since PLUS appears in many special purpose 	     address arithmetic instructions.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|!=
name|CLOBBER
operator|&&
name|temp
operator|!=
name|tor
condition|)
return|return
name|temp
return|;
block|}
break|break;
case|case
name|MINUS
case|:
comment|/* If STORE_FLAG_VALUE is 1, (minus 1 (comparison foo bar)) can be done 	 by reversing the comparison code if valid.  */
if|if
condition|(
name|STORE_FLAG_VALUE
operator|==
literal|1
operator|&&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|const1_rtx
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|&&
operator|(
name|reversed
operator|=
name|reversed_comparison
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|reversed
return|;
comment|/* (minus<foo> (and<foo> (const_int -pow2))) becomes 	 (and<foo> (const_int pow2-1))  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|AND
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|exact_log2
argument_list|(
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|>=
literal|0
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|simplify_and_const_int
argument_list|(
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|-
literal|1
argument_list|)
return|;
comment|/* Canonicalize (minus A (mult (neg B) C)) to (plus (mult B C) A).        */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|MULT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NEG
condition|)
block|{
name|rtx
name|in1
decl_stmt|,
name|in2
decl_stmt|;
name|in1
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|in2
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|gen_binary
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|gen_binary
argument_list|(
name|MULT
argument_list|,
name|mode
argument_list|,
name|in1
argument_list|,
name|in2
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
comment|/* Canonicalize (minus (neg A) (mult B C)) to  	  (minus (mult (neg B) C) A). */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|MULT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NEG
condition|)
block|{
name|rtx
name|in1
decl_stmt|,
name|in2
decl_stmt|;
name|in1
operator|=
name|simplify_gen_unary
argument_list|(
name|NEG
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|in2
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|gen_binary
argument_list|(
name|MINUS
argument_list|,
name|mode
argument_list|,
name|gen_binary
argument_list|(
name|MULT
argument_list|,
name|mode
argument_list|,
name|in1
argument_list|,
name|in2
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
comment|/* Canonicalize (minus A (plus B C)) to (minus (minus A B) C) for 	 integers.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|INTEGRAL_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|gen_binary
argument_list|(
name|MINUS
argument_list|,
name|mode
argument_list|,
name|gen_binary
argument_list|(
name|MINUS
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|MULT
case|:
comment|/* If we have (mult (plus A B) C), apply the distributive law and then 	 the inverse distributive law to see if things simplify.  This 	 occurs mostly in addresses, often when unrolling loops.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|x
operator|=
name|apply_distributive_law
argument_list|(
name|gen_binary
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|gen_binary
argument_list|(
name|MULT
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|gen_binary
argument_list|(
name|MULT
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MULT
condition|)
return|return
name|x
return|;
block|}
comment|/* Try simplify a*(b/c) as (a*b)/c.  */
if|if
condition|(
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
name|flag_unsafe_math_optimizations
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|DIV
condition|)
block|{
name|rtx
name|tem
init|=
name|simplify_binary_operation
argument_list|(
name|MULT
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|tem
condition|)
return|return
name|gen_binary
argument_list|(
name|DIV
argument_list|,
name|mode
argument_list|,
name|tem
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
break|break;
case|case
name|UDIV
case|:
comment|/* If this is a divide by a power of two, treat it as a shift if 	 its first operand is a shift.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|i
operator|=
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|>=
literal|0
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ASHIFT
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LSHIFTRT
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ASHIFTRT
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ROTATE
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ROTATERT
operator|)
condition|)
return|return
name|simplify_shift_const
argument_list|(
name|NULL_RTX
argument_list|,
name|LSHIFTRT
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|i
argument_list|)
return|;
break|break;
case|case
name|EQ
case|:
case|case
name|NE
case|:
case|case
name|GT
case|:
case|case
name|GTU
case|:
case|case
name|GE
case|:
case|case
name|GEU
case|:
case|case
name|LT
case|:
case|case
name|LTU
case|:
case|case
name|LE
case|:
case|case
name|LEU
case|:
case|case
name|UNEQ
case|:
case|case
name|LTGT
case|:
case|case
name|UNGT
case|:
case|case
name|UNGE
case|:
case|case
name|UNLT
case|:
case|case
name|UNLE
case|:
case|case
name|UNORDERED
case|:
case|case
name|ORDERED
case|:
comment|/* If the first operand is a condition code, we can't do anything 	 with it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|COMPARE
operator|||
operator|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|MODE_CC
ifdef|#
directive|ifdef
name|HAVE_cc0
operator|&&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|!=
name|cc0_rtx
endif|#
directive|endif
operator|)
condition|)
block|{
name|rtx
name|op0
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|new_code
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|COMPARE
condition|)
name|op1
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
operator|,
name|op0
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Simplify our comparison, if possible.  */
name|new_code
operator|=
name|simplify_comparison
argument_list|(
name|code
argument_list|,
operator|&
name|op0
argument_list|,
operator|&
name|op1
argument_list|)
expr_stmt|;
comment|/* If STORE_FLAG_VALUE is 1, we can convert (ne x 0) to simply X 	     if only the low-order bit is possibly nonzero in X (such as when 	     X is a ZERO_EXTRACT of one bit).  Similarly, we can convert EQ to 	     (xor X 1) or (minus 1 X); we use the former.  Finally, if X is 	     known to be either 0 or -1, NE becomes a NEG and EQ becomes 	     (plus X 1).  	     Remove any ZERO_EXTRACT we made when thinking this was a 	     comparison.  It may now be simpler to use, e.g., an AND.  If a 	     ZERO_EXTRACT is indeed appropriate, it will be placed back by 	     the call to make_compound_operation in the SET case.  */
if|if
condition|(
name|STORE_FLAG_VALUE
operator|==
literal|1
operator|&&
name|new_code
operator|==
name|NE
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|op1
operator|==
name|const0_rtx
operator|&&
name|mode
operator|==
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|&&
name|nonzero_bits
argument_list|(
name|op0
argument_list|,
name|mode
argument_list|)
operator|==
literal|1
condition|)
return|return
name|gen_lowpart_for_combine
argument_list|(
name|mode
argument_list|,
name|expand_compound_operation
argument_list|(
name|op0
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|STORE_FLAG_VALUE
operator|==
literal|1
operator|&&
name|new_code
operator|==
name|NE
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|op1
operator|==
name|const0_rtx
operator|&&
name|mode
operator|==
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|&&
operator|(
name|num_sign_bit_copies
argument_list|(
name|op0
argument_list|,
name|mode
argument_list|)
operator|==
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|)
condition|)
block|{
name|op0
operator|=
name|expand_compound_operation
argument_list|(
name|op0
argument_list|)
expr_stmt|;
return|return
name|simplify_gen_unary
argument_list|(
name|NEG
argument_list|,
name|mode
argument_list|,
name|gen_lowpart_for_combine
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
argument_list|,
name|mode
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|STORE_FLAG_VALUE
operator|==
literal|1
operator|&&
name|new_code
operator|==
name|EQ
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|op1
operator|==
name|const0_rtx
operator|&&
name|mode
operator|==
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|&&
name|nonzero_bits
argument_list|(
name|op0
argument_list|,
name|mode
argument_list|)
operator|==
literal|1
condition|)
block|{
name|op0
operator|=
name|expand_compound_operation
argument_list|(
name|op0
argument_list|)
expr_stmt|;
return|return
name|gen_binary
argument_list|(
name|XOR
argument_list|,
name|mode
argument_list|,
name|gen_lowpart_for_combine
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
argument_list|,
name|const1_rtx
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|STORE_FLAG_VALUE
operator|==
literal|1
operator|&&
name|new_code
operator|==
name|EQ
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|op1
operator|==
name|const0_rtx
operator|&&
name|mode
operator|==
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|&&
operator|(
name|num_sign_bit_copies
argument_list|(
name|op0
argument_list|,
name|mode
argument_list|)
operator|==
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|)
condition|)
block|{
name|op0
operator|=
name|expand_compound_operation
argument_list|(
name|op0
argument_list|)
expr_stmt|;
return|return
name|plus_constant
argument_list|(
name|gen_lowpart_for_combine
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
argument_list|,
literal|1
argument_list|)
return|;
block|}
comment|/* If STORE_FLAG_VALUE is -1, we have cases similar to 	     those above.  */
if|if
condition|(
name|STORE_FLAG_VALUE
operator|==
operator|-
literal|1
operator|&&
name|new_code
operator|==
name|NE
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|op1
operator|==
name|const0_rtx
operator|&&
operator|(
name|num_sign_bit_copies
argument_list|(
name|op0
argument_list|,
name|mode
argument_list|)
operator|==
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|)
condition|)
return|return
name|gen_lowpart_for_combine
argument_list|(
name|mode
argument_list|,
name|expand_compound_operation
argument_list|(
name|op0
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|STORE_FLAG_VALUE
operator|==
operator|-
literal|1
operator|&&
name|new_code
operator|==
name|NE
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|op1
operator|==
name|const0_rtx
operator|&&
name|mode
operator|==
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|&&
name|nonzero_bits
argument_list|(
name|op0
argument_list|,
name|mode
argument_list|)
operator|==
literal|1
condition|)
block|{
name|op0
operator|=
name|expand_compound_operation
argument_list|(
name|op0
argument_list|)
expr_stmt|;
return|return
name|simplify_gen_unary
argument_list|(
name|NEG
argument_list|,
name|mode
argument_list|,
name|gen_lowpart_for_combine
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
argument_list|,
name|mode
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|STORE_FLAG_VALUE
operator|==
operator|-
literal|1
operator|&&
name|new_code
operator|==
name|EQ
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|op1
operator|==
name|const0_rtx
operator|&&
name|mode
operator|==
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|&&
operator|(
name|num_sign_bit_copies
argument_list|(
name|op0
argument_list|,
name|mode
argument_list|)
operator|==
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|)
condition|)
block|{
name|op0
operator|=
name|expand_compound_operation
argument_list|(
name|op0
argument_list|)
expr_stmt|;
return|return
name|simplify_gen_unary
argument_list|(
name|NOT
argument_list|,
name|mode
argument_list|,
name|gen_lowpart_for_combine
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
argument_list|,
name|mode
argument_list|)
return|;
block|}
comment|/* If X is 0/1, (eq X 0) is X-1.  */
elseif|else
if|if
condition|(
name|STORE_FLAG_VALUE
operator|==
operator|-
literal|1
operator|&&
name|new_code
operator|==
name|EQ
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|op1
operator|==
name|const0_rtx
operator|&&
name|mode
operator|==
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|&&
name|nonzero_bits
argument_list|(
name|op0
argument_list|,
name|mode
argument_list|)
operator|==
literal|1
condition|)
block|{
name|op0
operator|=
name|expand_compound_operation
argument_list|(
name|op0
argument_list|)
expr_stmt|;
return|return
name|plus_constant
argument_list|(
name|gen_lowpart_for_combine
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
comment|/* If STORE_FLAG_VALUE says to just test the sign bit and X has just 	     one bit that might be nonzero, we can convert (ne x 0) to 	     (ashift x c) where C puts the bit in the sign bit.  Remove any 	     AND with STORE_FLAG_VALUE when we are done, since we are only 	     going to test the sign bit.  */
if|if
condition|(
name|new_code
operator|==
name|NE
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
operator|(
name|STORE_FLAG_VALUE
operator|&
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|)
operator|==
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|&&
name|op1
operator|==
name|const0_rtx
operator|&&
name|mode
operator|==
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|&&
operator|(
name|i
operator|=
name|exact_log2
argument_list|(
name|nonzero_bits
argument_list|(
name|op0
argument_list|,
name|mode
argument_list|)
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|x
operator|=
name|simplify_shift_const
argument_list|(
name|NULL_RTX
argument_list|,
name|ASHIFT
argument_list|,
name|mode
argument_list|,
name|expand_compound_operation
argument_list|(
name|op0
argument_list|)
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
operator|-
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|AND
operator|&&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|const_true_rtx
condition|)
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
return|;
else|else
return|return
name|x
return|;
block|}
comment|/* If the code changed, return a whole new comparison.  */
if|if
condition|(
name|new_code
operator|!=
name|code
condition|)
return|return
name|gen_rtx_fmt_ee
argument_list|(
name|new_code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
comment|/* Otherwise, keep this operation, but maybe change its operands. 	     This also converts (ne (compare FOO BAR) 0) to (ne FOO BAR).  */
name|SUBST
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|SUBST
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IF_THEN_ELSE
case|:
return|return
name|simplify_if_then_else
argument_list|(
name|x
argument_list|)
return|;
case|case
name|ZERO_EXTRACT
case|:
case|case
name|SIGN_EXTRACT
case|:
case|case
name|ZERO_EXTEND
case|:
case|case
name|SIGN_EXTEND
case|:
comment|/* If we are processing SET_DEST, we are done.  */
if|if
condition|(
name|in_dest
condition|)
return|return
name|x
return|;
return|return
name|expand_compound_operation
argument_list|(
name|x
argument_list|)
return|;
case|case
name|SET
case|:
return|return
name|simplify_set
argument_list|(
name|x
argument_list|)
return|;
case|case
name|AND
case|:
case|case
name|IOR
case|:
case|case
name|XOR
case|:
return|return
name|simplify_logical
argument_list|(
name|x
argument_list|,
name|last
argument_list|)
return|;
case|case
name|ABS
case|:
comment|/* (abs (neg<foo>)) -> (abs<foo>) */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NEG
condition|)
name|SUBST
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the mode of the operand is VOIDmode (i.e. if it is ASM_OPERANDS),          do nothing.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|VOIDmode
condition|)
break|break;
comment|/* If operand is something known to be positive, ignore the ABS.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FFS
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ABS
operator|||
operator|(
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|&&
operator|(
operator|(
name|nonzero_bits
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|)
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
return|;
comment|/* If operand is known to be only -1 or 0, convert ABS to NEG.  */
if|if
condition|(
name|num_sign_bit_copies
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|==
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|gen_rtx_NEG
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|FFS
case|:
comment|/* (ffs (*_extend<X>)) = (ffs<X>) */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SIGN_EXTEND
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ZERO_EXTEND
condition|)
name|SUBST
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FLOAT
case|:
comment|/* (float (sign_extend<X>)) = (float<X>).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SIGN_EXTEND
condition|)
name|SUBST
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASHIFT
case|:
case|case
name|LSHIFTRT
case|:
case|case
name|ASHIFTRT
case|:
case|case
name|ROTATE
case|:
case|case
name|ROTATERT
case|:
comment|/* If this is a shift by a constant amount, simplify it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|simplify_shift_const
argument_list|(
name|x
argument_list|,
name|code
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
ifdef|#
directive|ifdef
name|SHIFT_COUNT_TRUNCATED
elseif|else
if|if
condition|(
name|SHIFT_COUNT_TRUNCATED
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
name|SUBST
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|force_to_mode
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|exact_log2
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|-
literal|1
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|VEC_SELECT
case|:
block|{
name|rtx
name|op0
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|PARALLEL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|len
operator|=
name|XVECLEN
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|1
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|VEC_CONCAT
condition|)
block|{
name|int
name|offset
init|=
name|INTVAL
argument_list|(
name|XVECEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|*
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Try to find the element in the VEC_CONCAT.  */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|op0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|VEC_CONCAT
condition|)
block|{
name|HOST_WIDE_INT
name|op0_size
init|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|op0_size
operator|<
name|offset
condition|)
name|op0
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|offset
operator|-=
name|op0_size
expr_stmt|;
name|op0
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
break|break;
block|}
block|}
block|}
break|break;
default|default:
break|break;
block|}
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Simplify X, an IF_THEN_ELSE expression.  Return the new expression.  */
end_comment

begin_function
specifier|static
name|rtx
name|simplify_if_then_else
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
name|cond
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|true_rtx
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|false_rtx
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|true_code
init|=
name|GET_CODE
argument_list|(
name|cond
argument_list|)
decl_stmt|;
name|int
name|comparison_p
init|=
name|GET_RTX_CLASS
argument_list|(
name|true_code
argument_list|)
operator|==
literal|'<'
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|enum
name|rtx_code
name|false_code
decl_stmt|;
name|rtx
name|reversed
decl_stmt|;
comment|/* Simplify storing of the truth value.  */
if|if
condition|(
name|comparison_p
operator|&&
name|true_rtx
operator|==
name|const_true_rtx
operator|&&
name|false_rtx
operator|==
name|const0_rtx
condition|)
return|return
name|gen_binary
argument_list|(
name|true_code
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
comment|/* Also when the truth value has to be reversed.  */
if|if
condition|(
name|comparison_p
operator|&&
name|true_rtx
operator|==
name|const0_rtx
operator|&&
name|false_rtx
operator|==
name|const_true_rtx
operator|&&
operator|(
name|reversed
operator|=
name|reversed_comparison
argument_list|(
name|cond
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|reversed
return|;
comment|/* Sometimes we can simplify the arm of an IF_THEN_ELSE if a register used      in it is being compared against certain values.  Get the true and false      comparisons and see if that says anything about the value of each arm.  */
if|if
condition|(
name|comparison_p
operator|&&
operator|(
operator|(
name|false_code
operator|=
name|combine_reversed_comparison_code
argument_list|(
name|cond
argument_list|)
operator|)
operator|!=
name|UNKNOWN
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|HOST_WIDE_INT
name|nzb
decl_stmt|;
name|rtx
name|from
init|=
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|true_val
init|=
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|false_val
init|=
name|true_val
decl_stmt|;
name|int
name|swapped
init|=
literal|0
decl_stmt|;
comment|/* If FALSE_CODE is EQ, swap the codes and arms.  */
if|if
condition|(
name|false_code
operator|==
name|EQ
condition|)
block|{
name|swapped
operator|=
literal|1
operator|,
name|true_code
operator|=
name|EQ
operator|,
name|false_code
operator|=
name|NE
expr_stmt|;
name|temp
operator|=
name|true_rtx
operator|,
name|true_rtx
operator|=
name|false_rtx
operator|,
name|false_rtx
operator|=
name|temp
expr_stmt|;
block|}
comment|/* If we are comparing against zero and the expression being tested has 	 only a single bit that might be nonzero, that is its value when it is 	 not equal to zero.  Similarly if it is known to be -1 or 0.  */
if|if
condition|(
name|true_code
operator|==
name|EQ
operator|&&
name|true_val
operator|==
name|const0_rtx
operator|&&
name|exact_log2
argument_list|(
name|nzb
operator|=
name|nonzero_bits
argument_list|(
name|from
argument_list|,
name|GET_MODE
argument_list|(
name|from
argument_list|)
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
name|false_code
operator|=
name|EQ
operator|,
name|false_val
operator|=
name|GEN_INT
argument_list|(
name|nzb
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|true_code
operator|==
name|EQ
operator|&&
name|true_val
operator|==
name|const0_rtx
operator|&&
operator|(
name|num_sign_bit_copies
argument_list|(
name|from
argument_list|,
name|GET_MODE
argument_list|(
name|from
argument_list|)
argument_list|)
operator|==
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|from
argument_list|)
argument_list|)
operator|)
condition|)
name|false_code
operator|=
name|EQ
operator|,
name|false_val
operator|=
name|constm1_rtx
expr_stmt|;
comment|/* Now simplify an arm if we know the value of the register in the 	 branch and it is used in the arm.  Be careful due to the potential 	 of locally-shared RTL.  */
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|from
argument_list|,
name|true_rtx
argument_list|)
condition|)
name|true_rtx
operator|=
name|subst
argument_list|(
name|known_cond
argument_list|(
name|copy_rtx
argument_list|(
name|true_rtx
argument_list|)
argument_list|,
name|true_code
argument_list|,
name|from
argument_list|,
name|true_val
argument_list|)
argument_list|,
name|pc_rtx
argument_list|,
name|pc_rtx
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|from
argument_list|,
name|false_rtx
argument_list|)
condition|)
name|false_rtx
operator|=
name|subst
argument_list|(
name|known_cond
argument_list|(
name|copy_rtx
argument_list|(
name|false_rtx
argument_list|)
argument_list|,
name|false_code
argument_list|,
name|from
argument_list|,
name|false_val
argument_list|)
argument_list|,
name|pc_rtx
argument_list|,
name|pc_rtx
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SUBST
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|swapped
condition|?
name|false_rtx
else|:
name|true_rtx
argument_list|)
expr_stmt|;
name|SUBST
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|,
name|swapped
condition|?
name|true_rtx
else|:
name|false_rtx
argument_list|)
expr_stmt|;
name|true_rtx
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|false_rtx
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|true_code
operator|=
name|GET_CODE
argument_list|(
name|cond
argument_list|)
expr_stmt|;
block|}
comment|/* If we have (if_then_else FOO (pc) (label_ref BAR)) and FOO can be      reversed, do so to avoid needing two sets of patterns for      subtract-and-branch insns.  Similarly if we have a constant in the true      arm, the false arm is the same as the first operand of the comparison, or      the false arm is more complicated than the true arm.  */
if|if
condition|(
name|comparison_p
operator|&&
name|combine_reversed_comparison_code
argument_list|(
name|cond
argument_list|)
operator|!=
name|UNKNOWN
operator|&&
operator|(
name|true_rtx
operator|==
name|pc_rtx
operator|||
operator|(
name|CONSTANT_P
argument_list|(
name|true_rtx
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|false_rtx
argument_list|)
operator|!=
name|CONST_INT
operator|&&
name|false_rtx
operator|!=
name|pc_rtx
operator|)
operator|||
name|true_rtx
operator|==
name|const0_rtx
operator|||
operator|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|true_rtx
argument_list|)
argument_list|)
operator|==
literal|'o'
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|false_rtx
argument_list|)
argument_list|)
operator|!=
literal|'o'
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|true_rtx
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|true_rtx
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'o'
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|false_rtx
argument_list|)
argument_list|)
operator|!=
literal|'o'
operator|)
operator|||
name|reg_mentioned_p
argument_list|(
name|true_rtx
argument_list|,
name|false_rtx
argument_list|)
operator|||
name|rtx_equal_p
argument_list|(
name|false_rtx
argument_list|,
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|true_code
operator|=
name|reversed_comparison_code
argument_list|(
name|cond
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SUBST
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|reversed_comparison
argument_list|(
name|cond
argument_list|,
name|GET_MODE
argument_list|(
name|cond
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SUBST
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|false_rtx
argument_list|)
expr_stmt|;
name|SUBST
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|,
name|true_rtx
argument_list|)
expr_stmt|;
name|temp
operator|=
name|true_rtx
operator|,
name|true_rtx
operator|=
name|false_rtx
operator|,
name|false_rtx
operator|=
name|temp
expr_stmt|;
name|cond
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* It is possible that the conditional has been simplified out.  */
name|true_code
operator|=
name|GET_CODE
argument_list|(
name|cond
argument_list|)
expr_stmt|;
name|comparison_p
operator|=
name|GET_RTX_CLASS
argument_list|(
name|true_code
argument_list|)
operator|==
literal|'<'
expr_stmt|;
block|}
comment|/* If the two arms are identical, we don't need the comparison.  */
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|true_rtx
argument_list|,
name|false_rtx
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|cond
argument_list|)
condition|)
return|return
name|true_rtx
return|;
comment|/* Convert a == b ? b : a to "a".  */
if|if
condition|(
name|true_code
operator|==
name|EQ
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|cond
argument_list|)
operator|&&
operator|!
name|HONOR_NANS
argument_list|(
name|mode
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|,
name|false_rtx
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|,
name|true_rtx
argument_list|)
condition|)
return|return
name|false_rtx
return|;
elseif|else
if|if
condition|(
name|true_code
operator|==
name|NE
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|cond
argument_list|)
operator|&&
operator|!
name|HONOR_NANS
argument_list|(
name|mode
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|,
name|true_rtx
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|,
name|false_rtx
argument_list|)
condition|)
return|return
name|true_rtx
return|;
comment|/* Look for cases where we have (abs x) or (neg (abs X)).  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|GET_CODE
argument_list|(
name|false_rtx
argument_list|)
operator|==
name|NEG
operator|&&
name|rtx_equal_p
argument_list|(
name|true_rtx
argument_list|,
name|XEXP
argument_list|(
name|false_rtx
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|comparison_p
operator|&&
name|rtx_equal_p
argument_list|(
name|true_rtx
argument_list|,
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|true_rtx
argument_list|)
condition|)
switch|switch
condition|(
name|true_code
condition|)
block|{
case|case
name|GT
case|:
case|case
name|GE
case|:
return|return
name|simplify_gen_unary
argument_list|(
name|ABS
argument_list|,
name|mode
argument_list|,
name|true_rtx
argument_list|,
name|mode
argument_list|)
return|;
case|case
name|LT
case|:
case|case
name|LE
case|:
return|return
name|simplify_gen_unary
argument_list|(
name|NEG
argument_list|,
name|mode
argument_list|,
name|simplify_gen_unary
argument_list|(
name|ABS
argument_list|,
name|mode
argument_list|,
name|true_rtx
argument_list|,
name|mode
argument_list|)
argument_list|,
name|mode
argument_list|)
return|;
default|default:
break|break;
block|}
comment|/* Look for MIN or MAX.  */
if|if
condition|(
operator|(
operator|!
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
operator|||
name|flag_unsafe_math_optimizations
operator|)
operator|&&
name|comparison_p
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|,
name|true_rtx
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|,
name|false_rtx
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|cond
argument_list|)
condition|)
switch|switch
condition|(
name|true_code
condition|)
block|{
case|case
name|GE
case|:
case|case
name|GT
case|:
return|return
name|gen_binary
argument_list|(
name|SMAX
argument_list|,
name|mode
argument_list|,
name|true_rtx
argument_list|,
name|false_rtx
argument_list|)
return|;
case|case
name|LE
case|:
case|case
name|LT
case|:
return|return
name|gen_binary
argument_list|(
name|SMIN
argument_list|,
name|mode
argument_list|,
name|true_rtx
argument_list|,
name|false_rtx
argument_list|)
return|;
case|case
name|GEU
case|:
case|case
name|GTU
case|:
return|return
name|gen_binary
argument_list|(
name|UMAX
argument_list|,
name|mode
argument_list|,
name|true_rtx
argument_list|,
name|false_rtx
argument_list|)
return|;
case|case
name|LEU
case|:
case|case
name|LTU
case|:
return|return
name|gen_binary
argument_list|(
name|UMIN
argument_list|,
name|mode
argument_list|,
name|true_rtx
argument_list|,
name|false_rtx
argument_list|)
return|;
default|default:
break|break;
block|}
comment|/* If we have (if_then_else COND (OP Z C1) Z) and OP is an identity when its      second operand is zero, this can be done as (OP Z (mult COND C2)) where      C2 = C1 * STORE_FLAG_VALUE. Similarly if OP has an outer ZERO_EXTEND or      SIGN_EXTEND as long as Z is already extended (so we don't destroy it).      We can do this kind of thing in some cases when STORE_FLAG_VALUE is      neither 1 or -1, but it isn't worth checking for.  */
if|if
condition|(
operator|(
name|STORE_FLAG_VALUE
operator|==
literal|1
operator|||
name|STORE_FLAG_VALUE
operator|==
operator|-
literal|1
operator|)
operator|&&
name|comparison_p
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|rtx
name|t
init|=
name|make_compound_operation
argument_list|(
name|true_rtx
argument_list|,
name|SET
argument_list|)
decl_stmt|;
name|rtx
name|f
init|=
name|make_compound_operation
argument_list|(
name|false_rtx
argument_list|,
name|SET
argument_list|)
decl_stmt|;
name|rtx
name|cond_op0
init|=
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|cond_op1
init|=
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|op
init|=
name|NIL
decl_stmt|,
name|extend_op
init|=
name|NIL
decl_stmt|;
name|enum
name|machine_mode
name|m
init|=
name|mode
decl_stmt|;
name|rtx
name|z
init|=
literal|0
decl_stmt|,
name|c1
init|=
name|NULL_RTX
decl_stmt|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|MINUS
operator|||
name|GET_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|IOR
operator|||
name|GET_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|XOR
operator|||
name|GET_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ASHIFT
operator|||
name|GET_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|LSHIFTRT
operator|||
name|GET_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ASHIFTRT
operator|)
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|f
argument_list|)
condition|)
name|c1
operator|=
name|XEXP
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
operator|,
name|op
operator|=
name|GET_CODE
argument_list|(
name|t
argument_list|)
operator|,
name|z
operator|=
name|f
expr_stmt|;
comment|/* If an identity-zero op is commutative, check whether there 	 would be a match if we swapped the operands.  */
elseif|else
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|IOR
operator|||
name|GET_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|XOR
operator|)
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|f
argument_list|)
condition|)
name|c1
operator|=
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|,
name|op
operator|=
name|GET_CODE
argument_list|(
name|t
argument_list|)
operator|,
name|z
operator|=
name|f
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|SIGN_EXTEND
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MINUS
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|IOR
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|XOR
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ASHIFT
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LSHIFTRT
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ASHIFTRT
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|subreg_lowpart_p
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|f
argument_list|)
operator|&&
operator|(
name|num_sign_bit_copies
argument_list|(
name|f
argument_list|,
name|GET_MODE
argument_list|(
name|f
argument_list|)
argument_list|)
operator|>
call|(
name|unsigned
name|int
call|)
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|c1
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|z
operator|=
name|f
expr_stmt|;
name|op
operator|=
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|extend_op
operator|=
name|SIGN_EXTEND
expr_stmt|;
name|m
operator|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|SIGN_EXTEND
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|IOR
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|XOR
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|subreg_lowpart_p
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|f
argument_list|)
operator|&&
operator|(
name|num_sign_bit_copies
argument_list|(
name|f
argument_list|,
name|GET_MODE
argument_list|(
name|f
argument_list|)
argument_list|)
operator|>
call|(
name|unsigned
name|int
call|)
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|c1
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|z
operator|=
name|f
expr_stmt|;
name|op
operator|=
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|extend_op
operator|=
name|SIGN_EXTEND
expr_stmt|;
name|m
operator|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ZERO_EXTEND
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MINUS
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|IOR
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|XOR
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ASHIFT
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LSHIFTRT
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ASHIFTRT
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|subreg_lowpart_p
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|f
argument_list|)
operator|&&
operator|(
operator|(
name|nonzero_bits
argument_list|(
name|f
argument_list|,
name|GET_MODE
argument_list|(
name|f
argument_list|)
argument_list|)
operator|&
operator|~
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|c1
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|z
operator|=
name|f
expr_stmt|;
name|op
operator|=
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|extend_op
operator|=
name|ZERO_EXTEND
expr_stmt|;
name|m
operator|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ZERO_EXTEND
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|IOR
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|XOR
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|subreg_lowpart_p
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|f
argument_list|)
operator|&&
operator|(
operator|(
name|nonzero_bits
argument_list|(
name|f
argument_list|,
name|GET_MODE
argument_list|(
name|f
argument_list|)
argument_list|)
operator|&
operator|~
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|c1
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|z
operator|=
name|f
expr_stmt|;
name|op
operator|=
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|extend_op
operator|=
name|ZERO_EXTEND
expr_stmt|;
name|m
operator|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|z
condition|)
block|{
name|temp
operator|=
name|subst
argument_list|(
name|gen_binary
argument_list|(
name|true_code
argument_list|,
name|m
argument_list|,
name|cond_op0
argument_list|,
name|cond_op1
argument_list|)
argument_list|,
name|pc_rtx
argument_list|,
name|pc_rtx
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|temp
operator|=
name|gen_binary
argument_list|(
name|MULT
argument_list|,
name|m
argument_list|,
name|temp
argument_list|,
name|gen_binary
argument_list|(
name|MULT
argument_list|,
name|m
argument_list|,
name|c1
argument_list|,
name|const_true_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|=
name|subst
argument_list|(
name|temp
argument_list|,
name|pc_rtx
argument_list|,
name|pc_rtx
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|temp
operator|=
name|gen_binary
argument_list|(
name|op
argument_list|,
name|m
argument_list|,
name|gen_lowpart_for_combine
argument_list|(
name|m
argument_list|,
name|z
argument_list|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|extend_op
operator|!=
name|NIL
condition|)
name|temp
operator|=
name|simplify_gen_unary
argument_list|(
name|extend_op
argument_list|,
name|mode
argument_list|,
name|temp
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
block|}
comment|/* If we have (if_then_else (ne A 0) C1 0) and either A is known to be 0 or      1 and C1 is a single bit or A is known to be 0 or -1 and C1 is the      negation of a single bit, we can convert this operation to a shift.  We      can actually do this more generally, but it doesn't seem worth it.  */
if|if
condition|(
name|true_code
operator|==
name|NE
operator|&&
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
operator|==
name|const0_rtx
operator|&&
name|false_rtx
operator|==
name|const0_rtx
operator|&&
name|GET_CODE
argument_list|(
name|true_rtx
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
operator|(
literal|1
operator|==
name|nonzero_bits
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|&&
operator|(
name|i
operator|=
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|true_rtx
argument_list|)
argument_list|)
operator|)
operator|>=
literal|0
operator|)
operator|||
operator|(
operator|(
name|num_sign_bit_copies
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|==
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|)
operator|&&
operator|(
name|i
operator|=
name|exact_log2
argument_list|(
operator|-
name|INTVAL
argument_list|(
name|true_rtx
argument_list|)
argument_list|)
operator|)
operator|>=
literal|0
operator|)
operator|)
condition|)
return|return
name|simplify_shift_const
argument_list|(
name|NULL_RTX
argument_list|,
name|ASHIFT
argument_list|,
name|mode
argument_list|,
name|gen_lowpart_for_combine
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|i
argument_list|)
return|;
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Simplify X, a SET expression.  Return the new expression.  */
end_comment

begin_function
specifier|static
name|rtx
name|simplify_set
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|src
argument_list|)
operator|!=
name|VOIDmode
condition|?
name|GET_MODE
argument_list|(
name|src
argument_list|)
else|:
name|GET_MODE
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|rtx
name|other_insn
decl_stmt|;
name|rtx
modifier|*
name|cc_use
decl_stmt|;
comment|/* (set (pc) (return)) gets written as (return).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|PC
operator|&&
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|RETURN
condition|)
return|return
name|src
return|;
comment|/* Now that we know for sure which bits of SRC we are using, see if we can      simplify the expression for the object knowing that we only need the      low-order bits.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|src
operator|=
name|force_to_mode
argument_list|(
name|src
argument_list|,
name|mode
argument_list|,
operator|~
operator|(
name|HOST_WIDE_INT
operator|)
literal|0
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SUBST
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
comment|/* If we are setting CC0 or if the source is a COMPARE, look for the use of      the comparison result and try to simplify it unless we already have used      undobuf.other_insn.  */
if|if
condition|(
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_CC
operator|||
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|COMPARE
operator|||
name|CC0_P
argument_list|(
name|dest
argument_list|)
operator|)
operator|&&
operator|(
name|cc_use
operator|=
name|find_single_use
argument_list|(
name|dest
argument_list|,
name|subst_insn
argument_list|,
operator|&
name|other_insn
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|undobuf
operator|.
name|other_insn
operator|==
literal|0
operator|||
name|other_insn
operator|==
name|undobuf
operator|.
name|other_insn
operator|)
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
operator|*
name|cc_use
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
operator|*
name|cc_use
argument_list|,
literal|0
argument_list|)
argument_list|,
name|dest
argument_list|)
condition|)
block|{
name|enum
name|rtx_code
name|old_code
init|=
name|GET_CODE
argument_list|(
operator|*
name|cc_use
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|new_code
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|,
name|tmp
decl_stmt|;
name|int
name|other_changed
init|=
literal|0
decl_stmt|;
name|enum
name|machine_mode
name|compare_mode
init|=
name|GET_MODE
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|tmp_mode
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|COMPARE
condition|)
name|op0
operator|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
operator|,
name|op1
operator|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|op0
operator|=
name|src
operator|,
name|op1
operator|=
name|const0_rtx
expr_stmt|;
comment|/* Check whether the comparison is known at compile time.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|VOIDmode
condition|)
name|tmp_mode
operator|=
name|GET_MODE
argument_list|(
name|op0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|VOIDmode
condition|)
name|tmp_mode
operator|=
name|GET_MODE
argument_list|(
name|op1
argument_list|)
expr_stmt|;
else|else
name|tmp_mode
operator|=
name|compare_mode
expr_stmt|;
name|tmp
operator|=
name|simplify_relational_operation
argument_list|(
name|old_code
argument_list|,
name|tmp_mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|NULL_RTX
condition|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|other_insn
argument_list|)
decl_stmt|;
name|undobuf
operator|.
name|other_insn
operator|=
name|other_insn
expr_stmt|;
name|SUBST
argument_list|(
operator|*
name|cc_use
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* Attempt to simplify CC user.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
condition|)
block|{
name|rtx
name|new
init|=
name|simplify_rtx
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|new
operator|!=
name|NULL_RTX
condition|)
name|SUBST
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
name|new
argument_list|)
expr_stmt|;
block|}
comment|/* Convert X into a no-op move.  */
name|SUBST
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|pc_rtx
argument_list|)
expr_stmt|;
name|SUBST
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|pc_rtx
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
comment|/* Simplify our comparison, if possible.  */
name|new_code
operator|=
name|simplify_comparison
argument_list|(
name|old_code
argument_list|,
operator|&
name|op0
argument_list|,
operator|&
name|op1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EXTRA_CC_MODES
comment|/* If this machine has CC modes other than CCmode, check to see if we 	 need to use a different CC mode here.  */
name|compare_mode
operator|=
name|SELECT_CC_MODE
argument_list|(
name|new_code
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* EXTRA_CC_MODES */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_cc0
argument_list|)
operator|&&
name|defined
argument_list|(
name|EXTRA_CC_MODES
argument_list|)
comment|/* If the mode changed, we have to change SET_DEST, the mode in the 	 compare, and the mode in the place SET_DEST is used.  If SET_DEST is 	 a hard register, just build new versions with the proper mode.  If it 	 is a pseudo, we lose unless it is only time we set the pseudo, in 	 which case we can safely change its mode.  */
if|if
condition|(
name|compare_mode
operator|!=
name|GET_MODE
argument_list|(
name|dest
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|rtx
name|new_dest
init|=
name|gen_rtx_REG
argument_list|(
name|compare_mode
argument_list|,
name|regno
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|||
operator|(
name|REG_N_SETS
argument_list|(
name|regno
argument_list|)
operator|==
literal|1
operator|&&
operator|!
name|REG_USERVAR_P
argument_list|(
name|dest
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|SUBST
argument_list|(
name|regno_reg_rtx
index|[
name|regno
index|]
argument_list|,
name|new_dest
argument_list|)
expr_stmt|;
name|SUBST
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|new_dest
argument_list|)
expr_stmt|;
name|SUBST
argument_list|(
name|XEXP
argument_list|(
operator|*
name|cc_use
argument_list|,
literal|0
argument_list|)
argument_list|,
name|new_dest
argument_list|)
expr_stmt|;
name|other_changed
operator|=
literal|1
expr_stmt|;
name|dest
operator|=
name|new_dest
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* If the code changed, we have to build a new comparison in 	 undobuf.other_insn.  */
if|if
condition|(
name|new_code
operator|!=
name|old_code
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|mask
decl_stmt|;
name|SUBST
argument_list|(
operator|*
name|cc_use
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|new_code
argument_list|,
name|GET_MODE
argument_list|(
operator|*
name|cc_use
argument_list|)
argument_list|,
name|dest
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the only change we made was to change an EQ into an NE or 	     vice versa, OP0 has only one bit that might be nonzero, and OP1 	     is zero, check if changing the user of the condition code will 	     produce a valid insn.  If it won't, we can keep the original code 	     in that insn by surrounding our operation with an XOR.  */
if|if
condition|(
operator|(
operator|(
name|old_code
operator|==
name|NE
operator|&&
name|new_code
operator|==
name|EQ
operator|)
operator|||
operator|(
name|old_code
operator|==
name|EQ
operator|&&
name|new_code
operator|==
name|NE
operator|)
operator|)
operator|&&
operator|!
name|other_changed
operator|&&
name|op1
operator|==
name|const0_rtx
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|exact_log2
argument_list|(
name|mask
operator|=
name|nonzero_bits
argument_list|(
name|op0
argument_list|,
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|other_insn
argument_list|)
decl_stmt|,
name|note
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|recog_for_combine
argument_list|(
operator|&
name|pat
argument_list|,
name|other_insn
argument_list|,
operator|&
name|note
argument_list|)
operator|<
literal|0
operator|&&
operator|!
name|check_asm_operands
argument_list|(
name|pat
argument_list|)
operator|)
condition|)
block|{
name|PUT_CODE
argument_list|(
operator|*
name|cc_use
argument_list|,
name|old_code
argument_list|)
expr_stmt|;
name|other_insn
operator|=
literal|0
expr_stmt|;
name|op0
operator|=
name|gen_binary
argument_list|(
name|XOR
argument_list|,
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|,
name|op0
argument_list|,
name|GEN_INT
argument_list|(
name|mask
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|other_changed
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|other_changed
condition|)
name|undobuf
operator|.
name|other_insn
operator|=
name|other_insn
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* If we are now comparing against zero, change our source if 	 needed.  If we do not use cc0, we always have a COMPARE.  */
if|if
condition|(
name|op1
operator|==
name|const0_rtx
operator|&&
name|dest
operator|==
name|cc0_rtx
condition|)
block|{
name|SUBST
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|src
operator|=
name|op0
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
comment|/* Otherwise, if we didn't previously have a COMPARE in the 	 correct mode, we need one.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|!=
name|COMPARE
operator|||
name|GET_MODE
argument_list|(
name|src
argument_list|)
operator|!=
name|compare_mode
condition|)
block|{
name|SUBST
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|gen_rtx_COMPARE
argument_list|(
name|compare_mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|src
operator|=
name|SET_SRC
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Otherwise, update the COMPARE if needed.  */
name|SUBST
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|SUBST
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Get SET_SRC in a form where we have placed back any 	 compound expressions.  Then do the checks below.  */
name|src
operator|=
name|make_compound_operation
argument_list|(
name|src
argument_list|,
name|SET
argument_list|)
expr_stmt|;
name|SUBST
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
comment|/* If we have (set x (subreg:m1 (op:m2 ...) 0)) with OP being some operation,      and X being a REG or (subreg (reg)), we may be able to convert this to      (set (subreg:m2 x) (op)).       We can always do this if M1 is narrower than M2 because that means that      we only care about the low bits of the result.       However, on machines without WORD_REGISTER_OPERATIONS defined, we cannot      perform a narrower operation than requested since the high-order bits will      be undefined.  On machine where it is defined, this transformation is safe      as long as M1 and M2 have the same number of words.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|SUBREG
operator|&&
name|subreg_lowpart_p
argument_list|(
name|src
argument_list|)
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|src
argument_list|)
argument_list|)
argument_list|)
operator|!=
literal|'o'
operator|&&
operator|(
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
operator|+
operator|(
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|==
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|src
argument_list|)
argument_list|)
argument_list|)
operator|+
operator|(
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|)
ifndef|#
directive|ifndef
name|WORD_REGISTER_OPERATIONS
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|src
argument_list|)
argument_list|)
argument_list|)
operator|)
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CANNOT_CHANGE_MODE_CLASS
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|REG_CANNOT_CHANGE_MODE_P
argument_list|(
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|src
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
operator|)
endif|#
directive|endif
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
operator|||
operator|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
operator|)
condition|)
block|{
name|SUBST
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|gen_lowpart_for_combine
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|src
argument_list|)
argument_list|)
argument_list|,
name|dest
argument_list|)
argument_list|)
expr_stmt|;
name|SUBST
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|SUBREG_REG
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|src
operator|=
name|SET_SRC
argument_list|(
name|x
argument_list|)
operator|,
name|dest
operator|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* If we have (set (cc0) (subreg ...)), we try to remove the subreg      in SRC.  */
if|if
condition|(
name|dest
operator|==
name|cc0_rtx
operator|&&
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|SUBREG
operator|&&
name|subreg_lowpart_p
argument_list|(
name|src
argument_list|)
operator|&&
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
operator|<
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|src
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|inner
init|=
name|SUBREG_REG
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|inner_mode
init|=
name|GET_MODE
argument_list|(
name|inner
argument_list|)
decl_stmt|;
comment|/* Here we make sure that we don't have a sign bit on.  */
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|inner_mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
name|nonzero_bits
argument_list|(
name|inner
argument_list|,
name|inner_mode
argument_list|)
operator|<
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
block|{
name|SUBST
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|inner
argument_list|)
expr_stmt|;
name|src
operator|=
name|SET_SRC
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LOAD_EXTEND_OP
comment|/* If we have (set FOO (subreg:M (mem:N BAR) 0)) with M wider than N, this      would require a paradoxical subreg.  Replace the subreg with a      zero_extend to avoid the reload that would otherwise be required.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|SUBREG
operator|&&
name|subreg_lowpart_p
argument_list|(
name|src
argument_list|)
operator|&&
name|LOAD_EXTEND_OP
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|src
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|NIL
operator|&&
name|SUBREG_BYTE
argument_list|(
name|src
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|src
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|src
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|SUBST
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|LOAD_EXTEND_OP
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|src
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|,
name|SUBREG_REG
argument_list|(
name|src
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|src
operator|=
name|SET_SRC
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* If we don't have a conditional move, SET_SRC is an IF_THEN_ELSE, and we      are comparing an item known to be 0 or -1 against 0, use a logical      operation instead. Check for one of the arms being an IOR of the other      arm with some value.  We compute three terms to be IOR'ed together.  In      practice, at most two will be nonzero.  Then we do the IOR's.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|!=
name|PC
operator|&&
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|IF_THEN_ELSE
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|EQ
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NE
operator|)
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|const0_rtx
operator|&&
name|GET_MODE
argument_list|(
name|src
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
ifdef|#
directive|ifdef
name|HAVE_conditional_move
operator|&&
operator|!
name|can_conditionally_move_p
argument_list|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
endif|#
directive|endif
operator|&&
operator|(
name|num_sign_bit_copies
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|src
argument_list|)
condition|)
block|{
name|rtx
name|true_rtx
init|=
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NE
condition|?
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
else|:
name|XEXP
argument_list|(
name|src
argument_list|,
literal|2
argument_list|)
operator|)
decl_stmt|;
name|rtx
name|false_rtx
init|=
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NE
condition|?
name|XEXP
argument_list|(
name|src
argument_list|,
literal|2
argument_list|)
else|:
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
operator|)
decl_stmt|;
name|rtx
name|term1
init|=
name|const0_rtx
decl_stmt|,
name|term2
decl_stmt|,
name|term3
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|true_rtx
argument_list|)
operator|==
name|IOR
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|true_rtx
argument_list|,
literal|0
argument_list|)
argument_list|,
name|false_rtx
argument_list|)
condition|)
name|term1
operator|=
name|false_rtx
operator|,
name|true_rtx
operator|=
name|XEXP
argument_list|(
name|true_rtx
argument_list|,
literal|1
argument_list|)
operator|,
name|false_rtx
operator|=
name|const0_rtx
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|true_rtx
argument_list|)
operator|==
name|IOR
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|true_rtx
argument_list|,
literal|1
argument_list|)
argument_list|,
name|false_rtx
argument_list|)
condition|)
name|term1
operator|=
name|false_rtx
operator|,
name|true_rtx
operator|=
name|XEXP
argument_list|(
name|true_rtx
argument_list|,
literal|0
argument_list|)
operator|,
name|false_rtx
operator|=
name|const0_rtx
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|false_rtx
argument_list|)
operator|==
name|IOR
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|false_rtx
argument_list|,
literal|0
argument_list|)
argument_list|,
name|true_rtx
argument_list|)
condition|)
name|term1
operator|=
name|true_rtx
operator|,
name|false_rtx
operator|=
name|XEXP
argument_list|(
name|false_rtx
argument_list|,
literal|1
argument_list|)
operator|,
name|true_rtx
operator|=
name|const0_rtx
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|false_rtx
argument_list|)
operator|==
name|IOR
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|false_rtx
argument_list|,
literal|1
argument_list|)
argument_list|,
name|true_rtx
argument_list|)
condition|)
name|term1
operator|=
name|true_rtx
operator|,
name|false_rtx
operator|=
name|XEXP
argument_list|(
name|false_rtx
argument_list|,
literal|0
argument_list|)
operator|,
name|true_rtx
operator|=
name|const0_rtx
expr_stmt|;
name|term2
operator|=
name|gen_binary
argument_list|(
name|AND
argument_list|,
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|true_rtx
argument_list|)
expr_stmt|;
name|term3
operator|=
name|gen_binary
argument_list|(
name|AND
argument_list|,
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|,
name|simplify_gen_unary
argument_list|(
name|NOT
argument_list|,
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
argument_list|,
name|false_rtx
argument_list|)
expr_stmt|;
name|SUBST
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|gen_binary
argument_list|(
name|IOR
argument_list|,
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|,
name|gen_binary
argument_list|(
name|IOR
argument_list|,
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|,
name|term1
argument_list|,
name|term2
argument_list|)
argument_list|,
name|term3
argument_list|)
argument_list|)
expr_stmt|;
name|src
operator|=
name|SET_SRC
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
comment|/* If either SRC or DEST is a CLOBBER of (const_int 0), make this      whole thing fail.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|CLOBBER
operator|&&
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
operator|==
name|const0_rtx
condition|)
return|return
name|src
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|CLOBBER
operator|&&
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
operator|==
name|const0_rtx
condition|)
return|return
name|dest
return|;
else|else
comment|/* Convert this into a field assignment operation, if possible.  */
return|return
name|make_field_assignment
argument_list|(
name|x
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Simplify, X, and AND, IOR, or XOR operation, and return the simplified    result.  LAST is nonzero if this is the last retry.  */
end_comment

begin_function
specifier|static
name|rtx
name|simplify_logical
parameter_list|(
name|x
parameter_list|,
name|last
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|int
name|last
decl_stmt|;
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
name|op0
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|reversed
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|AND
case|:
comment|/* Convert (A ^ B)& A to A& (~B) since the latter is often a single 	 insn (and may simplify more).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|XOR
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op1
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op1
argument_list|)
condition|)
name|x
operator|=
name|gen_binary
argument_list|(
name|AND
argument_list|,
name|mode
argument_list|,
name|simplify_gen_unary
argument_list|(
name|NOT
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mode
argument_list|)
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|XOR
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|op1
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op1
argument_list|)
condition|)
name|x
operator|=
name|gen_binary
argument_list|(
name|AND
argument_list|,
name|mode
argument_list|,
name|simplify_gen_unary
argument_list|(
name|NOT
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
argument_list|,
name|op1
argument_list|)
expr_stmt|;
comment|/* Similarly for (~(A ^ B))& A.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|NOT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|XOR
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op1
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op1
argument_list|)
condition|)
name|x
operator|=
name|gen_binary
argument_list|(
name|AND
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|NOT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|XOR
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|op1
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op1
argument_list|)
condition|)
name|x
operator|=
name|gen_binary
argument_list|(
name|AND
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op1
argument_list|)
expr_stmt|;
comment|/* We can call simplify_and_const_int only if we don't lose 	 any (sign) bits when converting INTVAL (op1) to 	 "unsigned HOST_WIDE_INT".  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|||
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|>
literal|0
operator|)
condition|)
block|{
name|x
operator|=
name|simplify_and_const_int
argument_list|(
name|x
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|INTVAL
argument_list|(
name|op1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we have (ior (and (X C1) C2)) and the next restart would be 	     the last, simplify this by making C1 as small as possible 	     and then exit.  */
if|if
condition|(
name|last
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|IOR
operator|&&
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|AND
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|gen_binary
argument_list|(
name|IOR
argument_list|,
name|mode
argument_list|,
name|gen_binary
argument_list|(
name|AND
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&
operator|~
name|INTVAL
argument_list|(
name|op1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|op1
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|AND
condition|)
return|return
name|x
return|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
literal|'c'
operator|||
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
literal|'2'
condition|)
name|op0
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|,
name|op1
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Convert (A | B)& A to A.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|IOR
operator|&&
operator|(
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op1
argument_list|)
operator|||
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|op1
argument_list|)
operator|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|op1
return|;
comment|/* In the following group of tests (and those in case IOR below), 	 we start with some combination of logical operations and apply 	 the distributive law followed by the inverse distributive law. 	 Most of the time, this results in no change.  However, if some of 	 the operands are the same or inverses of each other, simplifications 	 will result.  	 For example, (and (ior A B) (not B)) can occur as the result of 	 expanding a bit field assignment.  When we apply the distributive 	 law to this, we get (ior (and (A (not B))) (and (B (not B)))), 	 which then simplifies to (and (A (not B))).  	 If we have (and (ior A B) C), apply the distributive law and then 	 the inverse distributive law to see if things simplify.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|IOR
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|XOR
condition|)
block|{
name|x
operator|=
name|apply_distributive_law
argument_list|(
name|gen_binary
argument_list|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
argument_list|,
name|mode
argument_list|,
name|gen_binary
argument_list|(
name|AND
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op1
argument_list|)
argument_list|,
name|gen_binary
argument_list|(
name|AND
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|op1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|AND
condition|)
return|return
name|x
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|IOR
operator|||
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|XOR
condition|)
return|return
name|apply_distributive_law
argument_list|(
name|gen_binary
argument_list|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
argument_list|,
name|mode
argument_list|,
name|gen_binary
argument_list|(
name|AND
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op0
argument_list|)
argument_list|,
name|gen_binary
argument_list|(
name|AND
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|op0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* Similarly, taking advantage of the fact that 	 (and (not A) (xor B C)) == (xor (ior A B) (ior A C))  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|NOT
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|XOR
condition|)
return|return
name|apply_distributive_law
argument_list|(
name|gen_binary
argument_list|(
name|XOR
argument_list|,
name|mode
argument_list|,
name|gen_binary
argument_list|(
name|IOR
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|gen_binary
argument_list|(
name|IOR
argument_list|,
name|mode
argument_list|,
name|copy_rtx
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|NOT
operator|&&
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|XOR
condition|)
return|return
name|apply_distributive_law
argument_list|(
name|gen_binary
argument_list|(
name|XOR
argument_list|,
name|mode
argument_list|,
name|gen_binary
argument_list|(
name|IOR
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|gen_binary
argument_list|(
name|IOR
argument_list|,
name|mode
argument_list|,
name|copy_rtx
argument_list|(
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|IOR
case|:
comment|/* (ior A C) is C if all bits of A that might be nonzero are on in C.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
name|nonzero_bits
argument_list|(
name|op0
argument_list|,
name|mode
argument_list|)
operator|&
operator|~
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
name|op1
return|;
comment|/* Convert (A& B) | A to A.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|AND
operator|&&
operator|(
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op1
argument_list|)
operator|||
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|op1
argument_list|)
operator|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|op1
return|;
comment|/* If we have (ior (and A B) C), apply the distributive law and then 	 the inverse distributive law to see if things simplify.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|AND
condition|)
block|{
name|x
operator|=
name|apply_distributive_law
argument_list|(
name|gen_binary
argument_list|(
name|AND
argument_list|,
name|mode
argument_list|,
name|gen_binary
argument_list|(
name|IOR
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op1
argument_list|)
argument_list|,
name|gen_binary
argument_list|(
name|IOR
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|op1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|IOR
condition|)
return|return
name|x
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|AND
condition|)
block|{
name|x
operator|=
name|apply_distributive_law
argument_list|(
name|gen_binary
argument_list|(
name|AND
argument_list|,
name|mode
argument_list|,
name|gen_binary
argument_list|(
name|IOR
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op0
argument_list|)
argument_list|,
name|gen_binary
argument_list|(
name|IOR
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|op0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|IOR
condition|)
return|return
name|x
return|;
block|}
comment|/* Convert (ior (ashift A CX) (lshiftrt A CY)) where CX+CY equals the 	 mode size to (rotate A CX).  */
if|if
condition|(
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|ASHIFT
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|LSHIFTRT
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|ASHIFT
operator|&&
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|LSHIFTRT
operator|)
operator|)
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|+
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|)
condition|)
return|return
name|gen_rtx_ROTATE
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|ASHIFT
condition|?
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
else|:
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
operator|)
argument_list|)
return|;
comment|/* If OP0 is (ashiftrt (plus ...) C), it might actually be 	 a (sign_extend (plus ...)).  If so, OP1 is a CONST_INT, and the PLUS 	 does not affect any of the bits in OP1, it can really be done 	 as a PLUS and we can associate.  We do this by seeing if OP1 	 can be safely shifted left C bits.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|ASHIFTRT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|int
name|count
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|mask
init|=
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|<<
name|count
decl_stmt|;
if|if
condition|(
name|mask
operator|>>
name|count
operator|==
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|&&
operator|(
name|mask
operator|&
name|nonzero_bits
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|SUBST
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator||
name|mask
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|op0
return|;
block|}
block|}
break|break;
case|case
name|XOR
case|:
comment|/* If we are XORing two things that have no bits in common, 	 convert them into an IOR.  This helps to detect rotation encoded 	 using those methods and possibly other simplifications.  */
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
name|nonzero_bits
argument_list|(
name|op0
argument_list|,
name|mode
argument_list|)
operator|&
name|nonzero_bits
argument_list|(
name|op1
argument_list|,
name|mode
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|gen_binary
argument_list|(
name|IOR
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
operator|)
return|;
comment|/* Convert (XOR (NOT x) (NOT y)) to (XOR x y). 	 Also convert (XOR (NOT x) y) to (NOT (XOR x y)), similarly for 	 (NOT y).  */
block|{
name|int
name|num_negated
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|NOT
condition|)
name|num_negated
operator|++
operator|,
name|op0
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|NOT
condition|)
name|num_negated
operator|++
operator|,
name|op1
operator|=
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_negated
operator|==
literal|2
condition|)
block|{
name|SUBST
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|SUBST
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|num_negated
operator|==
literal|1
condition|)
return|return
name|simplify_gen_unary
argument_list|(
name|NOT
argument_list|,
name|mode
argument_list|,
name|gen_binary
argument_list|(
name|XOR
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|,
name|mode
argument_list|)
return|;
block|}
comment|/* Convert (xor (and A B) B) to (and (not A) B).  The latter may 	 correspond to a machine insn or result in further simplifications 	 if B is a constant.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|AND
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|op1
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op1
argument_list|)
condition|)
return|return
name|gen_binary
argument_list|(
name|AND
argument_list|,
name|mode
argument_list|,
name|simplify_gen_unary
argument_list|(
name|NOT
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
argument_list|,
name|op1
argument_list|)
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|AND
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op1
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op1
argument_list|)
condition|)
return|return
name|gen_binary
argument_list|(
name|AND
argument_list|,
name|mode
argument_list|,
name|simplify_gen_unary
argument_list|(
name|NOT
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mode
argument_list|)
argument_list|,
name|op1
argument_list|)
return|;
comment|/* (xor (comparison foo bar) (const_int 1)) can become the reversed 	 comparison if STORE_FLAG_VALUE is 1.  */
if|if
condition|(
name|STORE_FLAG_VALUE
operator|==
literal|1
operator|&&
name|op1
operator|==
name|const1_rtx
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|&&
operator|(
name|reversed
operator|=
name|reversed_comparison
argument_list|(
name|op0
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|reversed
return|;
comment|/* (lshiftrt foo C) where C is the number of bits in FOO minus 1 	 is (lt foo (const_int 0)), so we can perform the above 	 simplification if STORE_FLAG_VALUE is 1.  */
if|if
condition|(
name|STORE_FLAG_VALUE
operator|==
literal|1
operator|&&
name|op1
operator|==
name|const1_rtx
operator|&&
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|LSHIFTRT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
condition|)
return|return
name|gen_rtx_GE
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
return|;
comment|/* (xor (comparison foo bar) (const_int sign-bit)) 	 when STORE_FLAG_VALUE is the sign bit.  */
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
operator|(
name|STORE_FLAG_VALUE
operator|&
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|)
operator|==
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|&&
name|op1
operator|==
name|const_true_rtx
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|&&
operator|(
name|reversed
operator|=
name|reversed_comparison
argument_list|(
name|op0
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|reversed
return|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* We consider ZERO_EXTRACT, SIGN_EXTRACT, and SIGN_EXTEND as "compound    operations" because they can be replaced with two more basic operations.    ZERO_EXTEND is also considered "compound" because it can be replaced with    an AND operation, which is simpler, though only one operation.     The function expand_compound_operation is called with an rtx expression    and will convert it to the appropriate shifts and AND operations,    simplifying at each stage.     The function make_compound_operation is called to convert an expression    consisting of shifts and ANDs into the equivalent compound expression.    It is the inverse of this function, loosely speaking.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_compound_operation
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|unsigned
name|HOST_WIDE_INT
name|pos
init|=
literal|0
decl_stmt|,
name|len
decl_stmt|;
name|int
name|unsignedp
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|modewidth
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|ZERO_EXTEND
case|:
name|unsignedp
operator|=
literal|1
expr_stmt|;
case|case
name|SIGN_EXTEND
case|:
comment|/* We can't necessarily use a const_int for a multiword mode; 	 it depends on implicitly extending the value. 	 Since we don't know the right way to extend it, 	 we can't tell whether the implicit way is right.  	 Even for a mode that is no wider than a const_int, 	 we can't win, because we need to sign extend one of its bits through 	 the rest of it, and we don't know which bit.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|x
return|;
comment|/* Return if (subreg:MODE FROM 0) is not a safe replacement for 	 (zero_extend:MODE FROM) or (sign_extend:MODE FROM).  It is for any MEM 	 because (SUBREG (MEM...)) is guaranteed to cause the MEM to be 	 reloaded. If not for that, MEM's would very rarely be safe.  	 Reject MODEs bigger than a word, because we might not be able 	 to reference a two-register group starting with an arbitrary register 	 (and currently gen_lowpart might crash for a SUBREG).  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|>
name|UNITS_PER_WORD
condition|)
return|return
name|x
return|;
comment|/* Reject MODEs that aren't scalar integers because turning vector 	 or complex modes into shifts causes problems.  */
if|if
condition|(
operator|!
name|SCALAR_INT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|x
return|;
name|len
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the inner object has VOIDmode (the only way this can happen 	 is if it is an ASM_OPERANDS), we can't do anything since we don't 	 know how much masking to do.  */
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
name|x
return|;
break|break;
case|case
name|ZERO_EXTRACT
case|:
name|unsignedp
operator|=
literal|1
expr_stmt|;
case|case
name|SIGN_EXTRACT
case|:
comment|/* If the operand is a CLOBBER, just return it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|VOIDmode
condition|)
return|return
name|x
return|;
comment|/* Reject MODEs that aren't scalar integers because turning vector 	 or complex modes into shifts causes problems.  */
if|if
condition|(
operator|!
name|SCALAR_INT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|x
return|;
name|len
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|pos
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this goes outside the object being extracted, replace the object 	 with a (use (mem ...)) construct that only combine understands 	 and is used only for this purpose.  */
if|if
condition|(
name|len
operator|+
name|pos
operator|>
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
name|SUBST
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|gen_rtx_USE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|BITS_BIG_ENDIAN
condition|)
name|pos
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|-
name|len
operator|-
name|pos
expr_stmt|;
break|break;
default|default:
return|return
name|x
return|;
block|}
comment|/* Convert sign extension to zero extension, if we know that the high      bit is not set, as this is easier to optimize.  It will be converted      back to cheaper alternative in make_extraction.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SIGN_EXTEND
operator|&&
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
operator|(
name|nonzero_bits
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|&
operator|~
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|>>
literal|1
operator|)
operator|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|rtx
name|temp
init|=
name|gen_rtx_ZERO_EXTEND
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|expand_compound_operation
argument_list|(
name|temp
argument_list|)
return|;
block|}
comment|/* We can optimize some special cases of ZERO_EXTEND.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ZERO_EXTEND
condition|)
block|{
comment|/* (zero_extend:DI (truncate:SI foo:DI)) is just foo:DI if we          know that the last value didn't have any inappropriate bits          set.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|TRUNCATE
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
name|nonzero_bits
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&
operator|~
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
comment|/* Likewise for (zero_extend:DI (subreg:SI foo:DI 0)).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|&&
name|subreg_lowpart_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
name|nonzero_bits
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&
operator|~
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
comment|/* (zero_extend:DI (truncate:SI foo:DI)) is just foo:DI when foo          is a comparison and STORE_FLAG_VALUE permits.  This is like          the first case, but it works even when GET_MODE (x) is larger          than HOST_WIDE_INT.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|TRUNCATE
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|&&
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|&&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
name|STORE_FLAG_VALUE
operator|&
operator|~
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
comment|/* Likewise for (zero_extend:DI (subreg:SI foo:DI 0)).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|&&
name|subreg_lowpart_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|&&
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|&&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
name|STORE_FLAG_VALUE
operator|&
operator|~
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
comment|/* If we reach here, we want to return a pair of shifts.  The inner      shift is a left shift of BITSIZE - POS - LEN bits.  The outer      shift is a right shift of BITSIZE - LEN bits.  It is arithmetic or      logical depending on the value of UNSIGNEDP.       If this was a ZERO_EXTEND or ZERO_EXTRACT, this pair of shifts will be      converted into an AND of a shift.       We must check for the case where the left shift would have a negative      count.  This can happen in a case like (x>> 31)& 255 on machines      that can't shift by a constant.  On those machines, we would first      combine the shift with the AND to produce a variable-position      extraction.  Then the constant of 31 would be substituted in to produce      a such a position.  */
name|modewidth
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|modewidth
operator|+
name|len
operator|>=
name|pos
condition|)
name|tem
operator|=
name|simplify_shift_const
argument_list|(
name|NULL_RTX
argument_list|,
name|unsignedp
condition|?
name|LSHIFTRT
else|:
name|ASHIFTRT
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|simplify_shift_const
argument_list|(
name|NULL_RTX
argument_list|,
name|ASHIFT
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|modewidth
operator|-
name|pos
operator|-
name|len
argument_list|)
argument_list|,
name|modewidth
operator|-
name|len
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|unsignedp
operator|&&
name|len
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
name|tem
operator|=
name|simplify_and_const_int
argument_list|(
name|NULL_RTX
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|simplify_shift_const
argument_list|(
name|NULL_RTX
argument_list|,
name|LSHIFTRT
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|pos
argument_list|)
argument_list|,
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|len
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
comment|/* Any other cases we can't handle.  */
return|return
name|x
return|;
comment|/* If we couldn't do this for some reason, return the original      expression.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|CLOBBER
condition|)
return|return
name|x
return|;
return|return
name|tem
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* X is a SET which contains an assignment of one object into    a part of another (such as a bit-field assignment, STRICT_LOW_PART,    or certain SUBREGS). If possible, convert it into a series of    logical operations.     We half-heartedly support variable positions, but do not at all    support variable lengths.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_field_assignment
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|rtx
name|inner
decl_stmt|;
name|rtx
name|pos
decl_stmt|;
comment|/* Always counts from low bit.  */
name|int
name|len
decl_stmt|;
name|rtx
name|mask
decl_stmt|;
name|enum
name|machine_mode
name|compute_mode
decl_stmt|;
comment|/* Loop until we find something we can't simplify.  */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|inner
operator|=
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|pos
operator|=
name|GEN_INT
argument_list|(
name|subreg_lsb
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|inner
operator|=
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|len
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|pos
operator|=
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* If the position is constant and spans the width of INNER, 	     surround INNER  with a USE to indicate this.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|pos
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|pos
argument_list|)
operator|+
name|len
operator|>
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|inner
argument_list|)
argument_list|)
condition|)
name|inner
operator|=
name|gen_rtx_USE
argument_list|(
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|inner
argument_list|)
expr_stmt|;
if|if
condition|(
name|BITS_BIG_ENDIAN
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|pos
argument_list|)
operator|==
name|CONST_INT
condition|)
name|pos
operator|=
name|GEN_INT
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|inner
argument_list|)
argument_list|)
operator|-
name|len
operator|-
name|INTVAL
argument_list|(
name|pos
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pos
argument_list|)
operator|==
name|MINUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|pos
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|pos
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|inner
argument_list|)
argument_list|)
operator|-
name|len
operator|)
condition|)
comment|/* If position is ADJUST - X, new position is X.  */
name|pos
operator|=
name|XEXP
argument_list|(
name|pos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|pos
operator|=
name|gen_binary
argument_list|(
name|MINUS
argument_list|,
name|GET_MODE
argument_list|(
name|pos
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|inner
argument_list|)
argument_list|)
operator|-
name|len
argument_list|)
argument_list|,
name|pos
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* A SUBREG between two modes that occupy the same numbers of words 	 can be done by moving the SUBREG to the source.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|SUBREG
comment|/* We need SUBREGs to compute nonzero_bits properly.  */
operator|&&
name|nonzero_sign_valid
operator|&&
operator|(
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|+
operator|(
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|==
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|+
operator|(
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|)
condition|)
block|{
name|x
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|gen_lowpart_for_combine
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
break|break;
while|while
condition|(
name|GET_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|SUBREG
operator|&&
name|subreg_lowpart_p
argument_list|(
name|inner
argument_list|)
condition|)
name|inner
operator|=
name|SUBREG_REG
argument_list|(
name|inner
argument_list|)
expr_stmt|;
name|compute_mode
operator|=
name|GET_MODE
argument_list|(
name|inner
argument_list|)
expr_stmt|;
comment|/* Don't attempt bitwise arithmetic on non scalar integer modes.  */
if|if
condition|(
operator|!
name|SCALAR_INT_MODE_P
argument_list|(
name|compute_mode
argument_list|)
condition|)
block|{
name|enum
name|machine_mode
name|imode
decl_stmt|;
comment|/* Don't do anything for vector or complex integral types.  */
if|if
condition|(
operator|!
name|FLOAT_MODE_P
argument_list|(
name|compute_mode
argument_list|)
condition|)
break|break;
comment|/* Try to find an integral mode to pun with.  */
name|imode
operator|=
name|mode_for_size
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|compute_mode
argument_list|)
argument_list|,
name|MODE_INT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|imode
operator|==
name|BLKmode
condition|)
break|break;
name|compute_mode
operator|=
name|imode
expr_stmt|;
name|inner
operator|=
name|gen_lowpart_for_combine
argument_list|(
name|imode
argument_list|,
name|inner
argument_list|)
expr_stmt|;
block|}
comment|/* Compute a mask of LEN bits, if we can do this on the host machine.  */
if|if
condition|(
name|len
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
name|mask
operator|=
name|GEN_INT
argument_list|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|len
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
break|break;
comment|/* Now compute the equivalent expression.  Make a copy of INNER 	 for the SET_DEST in case it is a MEM into which we will substitute; 	 we don't want shared RTL in that case.  */
name|x
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|copy_rtx
argument_list|(
name|inner
argument_list|)
argument_list|,
name|gen_binary
argument_list|(
name|IOR
argument_list|,
name|compute_mode
argument_list|,
name|gen_binary
argument_list|(
name|AND
argument_list|,
name|compute_mode
argument_list|,
name|simplify_gen_unary
argument_list|(
name|NOT
argument_list|,
name|compute_mode
argument_list|,
name|gen_binary
argument_list|(
name|ASHIFT
argument_list|,
name|compute_mode
argument_list|,
name|mask
argument_list|,
name|pos
argument_list|)
argument_list|,
name|compute_mode
argument_list|)
argument_list|,
name|inner
argument_list|)
argument_list|,
name|gen_binary
argument_list|(
name|ASHIFT
argument_list|,
name|compute_mode
argument_list|,
name|gen_binary
argument_list|(
name|AND
argument_list|,
name|compute_mode
argument_list|,
name|gen_lowpart_for_combine
argument_list|(
name|compute_mode
argument_list|,
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|mask
argument_list|)
argument_list|,
name|pos
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return an RTX for a reference to LEN bits of INNER.  If POS_RTX is nonzero,    it is an RTX that represents a variable starting position; otherwise,    POS is the (constant) starting bit position (counted from the LSB).     INNER may be a USE.  This will occur when we started with a bitfield    that went outside the boundary of the object in memory, which is    allowed on most machines.  To isolate this case, we produce a USE    whose mode is wide enough and surround the MEM with it.  The only    code that understands the USE is this routine.  If it is not removed,    it will cause the resulting insn not to match.     UNSIGNEDP is nonzero for an unsigned reference and zero for a    signed reference.     IN_DEST is nonzero if this is a reference in the destination of a    SET.  This is used when a ZERO_ or SIGN_EXTRACT isn't needed.  If nonzero,    a STRICT_LOW_PART will be used, if zero, ZERO_EXTEND or SIGN_EXTEND will    be used.     IN_COMPARE is nonzero if we are in a COMPARE.  This means that a    ZERO_EXTRACT should be built even for bits starting at bit 0.     MODE is the desired mode of the result (if IN_DEST == 0).     The result is an RTX for the extraction or NULL_RTX if the target    can't handle it.  */
end_comment

begin_function
specifier|static
name|rtx
name|make_extraction
parameter_list|(
name|mode
parameter_list|,
name|inner
parameter_list|,
name|pos
parameter_list|,
name|pos_rtx
parameter_list|,
name|len
parameter_list|,
name|unsignedp
parameter_list|,
name|in_dest
parameter_list|,
name|in_compare
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|inner
decl_stmt|;
name|HOST_WIDE_INT
name|pos
decl_stmt|;
name|rtx
name|pos_rtx
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|len
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|int
name|in_dest
decl_stmt|,
name|in_compare
decl_stmt|;
block|{
comment|/* This mode describes the size of the storage area      to fetch the overall value from.  Within that, we      ignore the POS lowest bits, etc.  */
name|enum
name|machine_mode
name|is_mode
init|=
name|GET_MODE
argument_list|(
name|inner
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|inner_mode
decl_stmt|;
name|enum
name|machine_mode
name|wanted_inner_mode
init|=
name|byte_mode
decl_stmt|;
name|enum
name|machine_mode
name|wanted_inner_reg_mode
init|=
name|word_mode
decl_stmt|;
name|enum
name|machine_mode
name|pos_mode
init|=
name|word_mode
decl_stmt|;
name|enum
name|machine_mode
name|extraction_mode
init|=
name|word_mode
decl_stmt|;
name|enum
name|machine_mode
name|tmode
init|=
name|mode_for_size
argument_list|(
name|len
argument_list|,
name|MODE_INT
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|int
name|spans_byte
init|=
literal|0
decl_stmt|;
name|rtx
name|new
init|=
literal|0
decl_stmt|;
name|rtx
name|orig_pos_rtx
init|=
name|pos_rtx
decl_stmt|;
name|HOST_WIDE_INT
name|orig_pos
decl_stmt|;
comment|/* Get some information about INNER and get the innermost object.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|USE
condition|)
comment|/* (use:SI (mem:QI foo)) stands for (mem:SI foo).  */
comment|/* We don't need to adjust the position because we set up the USE        to pretend that it was a full-word object.  */
name|spans_byte
operator|=
literal|1
operator|,
name|inner
operator|=
name|XEXP
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|SUBREG
operator|&&
name|subreg_lowpart_p
argument_list|(
name|inner
argument_list|)
condition|)
block|{
comment|/* If going from (subreg:SI (mem:QI ...)) to (mem:QI ...), 	 consider just the QI as the memory to extract from. 	 The subreg adds or removes high bits; its mode is 	 irrelevant to the meaning of this extraction, 	 since POS and LEN count from the lsb.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|inner
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
name|is_mode
operator|=
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|inner
argument_list|)
argument_list|)
expr_stmt|;
name|inner
operator|=
name|SUBREG_REG
argument_list|(
name|inner
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|ASHIFT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|inner
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|pos_rtx
operator|==
literal|0
operator|&&
name|pos
operator|==
literal|0
operator|&&
name|len
operator|>
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|inner
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
comment|/* We're extracting the least significant bits of an rtx 	 (ashift X (const_int C)), where LEN> C.  Extract the 	 least significant (LEN - C) bits of X, giving an rtx 	 whose mode is MODE, then shift it left C times.  */
name|new
operator|=
name|make_extraction
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|len
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|inner
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|unsignedp
argument_list|,
name|in_dest
argument_list|,
name|in_compare
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|!=
literal|0
condition|)
return|return
name|gen_rtx_ASHIFT
argument_list|(
name|mode
argument_list|,
name|new
argument_list|,
name|XEXP
argument_list|(
name|inner
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
name|inner_mode
operator|=
name|GET_MODE
argument_list|(
name|inner
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos_rtx
operator|&&
name|GET_CODE
argument_list|(
name|pos_rtx
argument_list|)
operator|==
name|CONST_INT
condition|)
name|pos
operator|=
name|INTVAL
argument_list|(
name|pos_rtx
argument_list|)
operator|,
name|pos_rtx
operator|=
literal|0
expr_stmt|;
comment|/* See if this can be done without an extraction.  We never can if the      width of the field is not the same as that of some integer mode. For      registers, we can only avoid the extraction if the position is at the      low-order bit and this is either not in the destination or we have the      appropriate STRICT_LOW_PART operation available.       For MEM, we can avoid an extract if the field starts on an appropriate      boundary and we can change the mode of the memory reference.  However,      we cannot directly access the MEM if we have a USE and the underlying      MEM is not TMODE.  This combination means that MEM was being used in a      context where bits outside its mode were being referenced; that is only      valid in bit-field insns.  */
if|if
condition|(
name|tmode
operator|!=
name|BLKmode
operator|&&
operator|!
operator|(
name|spans_byte
operator|&&
name|inner_mode
operator|!=
name|tmode
operator|)
operator|&&
operator|(
operator|(
name|pos_rtx
operator|==
literal|0
operator|&&
operator|(
name|pos
operator|%
name|BITS_PER_WORD
operator|)
operator|==
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|inner
argument_list|)
operator|!=
name|MEM
operator|&&
operator|(
operator|!
name|in_dest
operator|||
operator|(
name|GET_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|REG
operator|&&
name|have_insn_for
argument_list|(
name|STRICT_LOW_PART
argument_list|,
name|tmode
argument_list|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|MEM
operator|&&
name|pos_rtx
operator|==
literal|0
operator|&&
operator|(
name|pos
operator|%
operator|(
name|STRICT_ALIGNMENT
condition|?
name|GET_MODE_ALIGNMENT
argument_list|(
name|tmode
argument_list|)
else|:
name|BITS_PER_UNIT
operator|)
operator|)
operator|==
literal|0
comment|/* We can't do this if we are widening INNER_MODE (it 		 may not be aligned, for one thing).  */
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|inner_mode
argument_list|)
operator|>=
name|GET_MODE_BITSIZE
argument_list|(
name|tmode
argument_list|)
operator|&&
operator|(
name|inner_mode
operator|==
name|tmode
operator|||
operator|(
operator|!
name|mode_dependent_address_p
argument_list|(
name|XEXP
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|!
name|MEM_VOLATILE_P
argument_list|(
name|inner
argument_list|)
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* If INNER is a MEM, make a new MEM that encompasses just the desired 	 field.  If the original and current mode are the same, we need not 	 adjust the offset.  Otherwise, we do if bytes big endian.  	 If INNER is not a MEM, get a piece consisting of just the field 	 of interest (in this case POS % BITS_PER_WORD must be 0).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|HOST_WIDE_INT
name|offset
decl_stmt|;
comment|/* POS counts from lsb, but make OFFSET count in memory order.  */
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
name|offset
operator|=
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|is_mode
argument_list|)
operator|-
name|len
operator|-
name|pos
operator|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
else|else
name|offset
operator|=
name|pos
operator|/
name|BITS_PER_UNIT
expr_stmt|;
name|new
operator|=
name|adjust_address_nv
argument_list|(
name|inner
argument_list|,
name|tmode
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|REG
condition|)
block|{
comment|/* We can't call gen_lowpart_for_combine here since we always want 	     a SUBREG and it would sometimes return a new hard register.  */
if|if
condition|(
name|tmode
operator|!=
name|inner_mode
condition|)
block|{
name|HOST_WIDE_INT
name|final_word
init|=
name|pos
operator|/
name|BITS_PER_WORD
decl_stmt|;
if|if
condition|(
name|WORDS_BIG_ENDIAN
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|inner_mode
argument_list|)
operator|>
name|UNITS_PER_WORD
condition|)
name|final_word
operator|=
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|inner_mode
argument_list|)
operator|-
name|GET_MODE_SIZE
argument_list|(
name|tmode
argument_list|)
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|-
name|final_word
expr_stmt|;
name|final_word
operator|*=
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|inner_mode
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|tmode
argument_list|)
condition|)
name|final_word
operator|+=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|inner_mode
argument_list|)
operator|-
name|GET_MODE_SIZE
argument_list|(
name|tmode
argument_list|)
operator|)
operator|%
name|UNITS_PER_WORD
expr_stmt|;
comment|/* Avoid creating invalid subregs, for example when 		 simplifying (x>>32)&255.  */
if|if
condition|(
name|final_word
operator|>=
name|GET_MODE_SIZE
argument_list|(
name|inner_mode
argument_list|)
condition|)
return|return
name|NULL_RTX
return|;
name|new
operator|=
name|gen_rtx_SUBREG
argument_list|(
name|tmode
argument_list|,
name|inner
argument_list|,
name|final_word
argument_list|)
expr_stmt|;
block|}
else|else
name|new
operator|=
name|inner
expr_stmt|;
block|}
else|else
name|new
operator|=
name|force_to_mode
argument_list|(
name|inner
argument_list|,
name|tmode
argument_list|,
name|len
operator|>=
name|HOST_BITS_PER_WIDE_INT
condition|?
operator|~
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0
else|:
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|len
operator|)
operator|-
literal|1
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If this extraction is going into the destination of a SET, 	 make a STRICT_LOW_PART unless we made a MEM.  */
if|if
condition|(
name|in_dest
condition|)
return|return
operator|(
name|GET_CODE
argument_list|(
name|new
argument_list|)
operator|==
name|MEM
condition|?
name|new
else|:
operator|(
name|GET_CODE
argument_list|(
name|new
argument_list|)
operator|!=
name|SUBREG
condition|?
name|gen_rtx_CLOBBER
argument_list|(
name|tmode
argument_list|,
name|const0_rtx
argument_list|)
else|:
name|gen_rtx_STRICT_LOW_PART
argument_list|(
name|VOIDmode
argument_list|,
name|new
argument_list|)
operator|)
operator|)
return|;
if|if
condition|(
name|mode
operator|==
name|tmode
condition|)
return|return
name|new
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|new
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|gen_int_mode
argument_list|(
name|INTVAL
argument_list|(
name|new
argument_list|)
argument_list|,
name|mode
argument_list|)
return|;
comment|/* If we know that no extraneous bits are set, and that the high 	 bit is not set, convert the extraction to the cheaper of 	 sign and zero extension, that are equivalent in these cases.  */
if|if
condition|(
name|flag_expensive_optimizations
operator|&&
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|tmode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
operator|(
name|nonzero_bits
argument_list|(
name|new
argument_list|,
name|tmode
argument_list|)
operator|&
operator|~
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|GET_MODE_MASK
argument_list|(
name|tmode
argument_list|)
operator|)
operator|>>
literal|1
operator|)
operator|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|rtx
name|temp
init|=
name|gen_rtx_ZERO_EXTEND
argument_list|(
name|mode
argument_list|,
name|new
argument_list|)
decl_stmt|;
name|rtx
name|temp1
init|=
name|gen_rtx_SIGN_EXTEND
argument_list|(
name|mode
argument_list|,
name|new
argument_list|)
decl_stmt|;
comment|/* Prefer ZERO_EXTENSION, since it gives more information to 	     backends.  */
if|if
condition|(
name|rtx_cost
argument_list|(
name|temp
argument_list|,
name|SET
argument_list|)
operator|<=
name|rtx_cost
argument_list|(
name|temp1
argument_list|,
name|SET
argument_list|)
condition|)
return|return
name|temp
return|;
return|return
name|temp1
return|;
block|}
comment|/* Otherwise, sign- or zero-extend unless we already are in the 	 proper mode.  */
return|return
operator|(
name|gen_rtx_fmt_e
argument_list|(
name|unsignedp
condition|?
name|ZERO_EXTEND
else|:
name|SIGN_EXTEND
argument_list|,
name|mode
argument_list|,
name|new
argument_list|)
operator|)
return|;
block|}
comment|/* Unless this is a COMPARE or we have a funny memory reference,      don't do anything with zero-extending field extracts starting at      the low-order bit since they are simple AND operations.  */
if|if
condition|(
name|pos_rtx
operator|==
literal|0
operator|&&
name|pos
operator|==
literal|0
operator|&&
operator|!
name|in_dest
operator|&&
operator|!
name|in_compare
operator|&&
operator|!
name|spans_byte
operator|&&
name|unsignedp
condition|)
return|return
literal|0
return|;
comment|/* Unless we are allowed to span bytes or INNER is not MEM, reject this if      we would be spanning bytes or if the position is not a constant and the      length is not 1.  In all other cases, we would only be going outside      our object in cases when an original shift would have been      undefined.  */
if|if
condition|(
operator|!
name|spans_byte
operator|&&
name|GET_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
operator|(
name|pos_rtx
operator|==
literal|0
operator|&&
name|pos
operator|+
name|len
operator|>
name|GET_MODE_BITSIZE
argument_list|(
name|is_mode
argument_list|)
operator|)
operator|||
operator|(
name|pos_rtx
operator|!=
literal|0
operator|&&
name|len
operator|!=
literal|1
operator|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Get the mode to use should INNER not be a MEM, the mode for the position,      and the mode for the result.  */
if|if
condition|(
name|in_dest
operator|&&
name|mode_for_extraction
argument_list|(
name|EP_insv
argument_list|,
operator|-
literal|1
argument_list|)
operator|!=
name|MAX_MACHINE_MODE
condition|)
block|{
name|wanted_inner_reg_mode
operator|=
name|mode_for_extraction
argument_list|(
name|EP_insv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pos_mode
operator|=
name|mode_for_extraction
argument_list|(
name|EP_insv
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|extraction_mode
operator|=
name|mode_for_extraction
argument_list|(
name|EP_insv
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|in_dest
operator|&&
name|unsignedp
operator|&&
name|mode_for_extraction
argument_list|(
name|EP_extzv
argument_list|,
operator|-
literal|1
argument_list|)
operator|!=
name|MAX_MACHINE_MODE
condition|)
block|{
name|wanted_inner_reg_mode
operator|=
name|mode_for_extraction
argument_list|(
name|EP_extzv
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pos_mode
operator|=
name|mode_for_extraction
argument_list|(
name|EP_extzv
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|extraction_mode
operator|=
name|mode_for_extraction
argument_list|(
name|EP_extzv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|in_dest
operator|&&
operator|!
name|unsignedp
operator|&&
name|mode_for_extraction
argument_list|(
name|EP_extv
argument_list|,
operator|-
literal|1
argument_list|)
operator|!=
name|MAX_MACHINE_MODE
condition|)
block|{
name|wanted_inner_reg_mode
operator|=
name|mode_for_extraction
argument_list|(
name|EP_extv
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pos_mode
operator|=
name|mode_for_extraction
argument_list|(
name|EP_extv
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|extraction_mode
operator|=
name|mode_for_extraction
argument_list|(
name|EP_extv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Never narrow an object, since that might not be safe.  */
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|extraction_mode
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
condition|)
name|extraction_mode
operator|=
name|mode
expr_stmt|;
if|if
condition|(
name|pos_rtx
operator|&&
name|GET_MODE
argument_list|(
name|pos_rtx
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|pos_mode
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|pos_rtx
argument_list|)
argument_list|)
condition|)
name|pos_mode
operator|=
name|GET_MODE
argument_list|(
name|pos_rtx
argument_list|)
expr_stmt|;
comment|/* If this is not from memory, the desired mode is wanted_inner_reg_mode;      if we have to change the mode of memory and cannot, the desired mode is      EXTRACTION_MODE.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|inner
argument_list|)
operator|!=
name|MEM
condition|)
name|wanted_inner_mode
operator|=
name|wanted_inner_reg_mode
expr_stmt|;
elseif|else
if|if
condition|(
name|inner_mode
operator|!=
name|wanted_inner_mode
operator|&&
operator|(
name|mode_dependent_address_p
argument_list|(
name|XEXP
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|MEM_VOLATILE_P
argument_list|(
name|inner
argument_list|)
operator|)
condition|)
name|wanted_inner_mode
operator|=
name|extraction_mode
expr_stmt|;
name|orig_pos
operator|=
name|pos
expr_stmt|;
if|if
condition|(
name|BITS_BIG_ENDIAN
condition|)
block|{
comment|/* POS is passed as if BITS_BIG_ENDIAN == 0, so we need to convert it to 	 BITS_BIG_ENDIAN style.  If position is constant, compute new 	 position.  Otherwise, build subtraction. 	 Note that POS is relative to the mode of the original argument. 	 If it's a MEM we need to recompute POS relative to that. 	 However, if we're extracting from (or inserting into) a register, 	 we want to recompute POS relative to wanted_inner_mode.  */
name|int
name|width
init|=
operator|(
name|GET_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|MEM
condition|?
name|GET_MODE_BITSIZE
argument_list|(
name|is_mode
argument_list|)
else|:
name|GET_MODE_BITSIZE
argument_list|(
name|wanted_inner_mode
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|pos_rtx
operator|==
literal|0
condition|)
name|pos
operator|=
name|width
operator|-
name|len
operator|-
name|pos
expr_stmt|;
else|else
name|pos_rtx
operator|=
name|gen_rtx_MINUS
argument_list|(
name|GET_MODE
argument_list|(
name|pos_rtx
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|width
operator|-
name|len
argument_list|)
argument_list|,
name|pos_rtx
argument_list|)
expr_stmt|;
comment|/* POS may be less than 0 now, but we check for that below. 	 Note that it can only be less than 0 if GET_CODE (inner) != MEM.  */
block|}
comment|/* If INNER has a wider mode, make it smaller.  If this is a constant      extract, try to adjust the byte to point to the byte containing      the value.  */
if|if
condition|(
name|wanted_inner_mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|wanted_inner_mode
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|is_mode
argument_list|)
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
name|inner_mode
operator|==
name|wanted_inner_mode
operator|||
operator|(
operator|!
name|mode_dependent_address_p
argument_list|(
name|XEXP
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|!
name|MEM_VOLATILE_P
argument_list|(
name|inner
argument_list|)
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
name|int
name|offset
init|=
literal|0
decl_stmt|;
comment|/* The computations below will be correct if the machine is big 	 endian in both bits and bytes or little endian in bits and bytes. 	 If it is mixed, we must adjust.  */
comment|/* If bytes are big endian and we had a paradoxical SUBREG, we must 	 adjust OFFSET to compensate.  */
if|if
condition|(
name|BYTES_BIG_ENDIAN
operator|&&
operator|!
name|spans_byte
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|inner_mode
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|is_mode
argument_list|)
condition|)
name|offset
operator|-=
name|GET_MODE_SIZE
argument_list|(
name|is_mode
argument_list|)
operator|-
name|GET_MODE_SIZE
argument_list|(
name|inner_mode
argument_list|)
expr_stmt|;
comment|/* If this is a constant position, we can move to the desired byte.  */
if|if
condition|(
name|pos_rtx
operator|==
literal|0
condition|)
block|{
name|offset
operator|+=
name|pos
operator|/
name|BITS_PER_UNIT
expr_stmt|;
name|pos
operator|%=
name|GET_MODE_BITSIZE
argument_list|(
name|wanted_inner_mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|BYTES_BIG_ENDIAN
operator|!=
name|BITS_BIG_ENDIAN
operator|&&
operator|!
name|spans_byte
operator|&&
name|is_mode
operator|!=
name|wanted_inner_mode
condition|)
name|offset
operator|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|is_mode
argument_list|)
operator|-
name|GET_MODE_SIZE
argument_list|(
name|wanted_inner_mode
argument_list|)
operator|-
name|offset
operator|)
expr_stmt|;
if|if
condition|(
name|offset
operator|!=
literal|0
operator|||
name|inner_mode
operator|!=
name|wanted_inner_mode
condition|)
name|inner
operator|=
name|adjust_address_nv
argument_list|(
name|inner
argument_list|,
name|wanted_inner_mode
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
comment|/* If INNER is not memory, we can always get it into the proper mode.  If we      are changing its mode, POS must be a constant and smaller than the size      of the new mode.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|inner
argument_list|)
operator|!=
name|MEM
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|inner
argument_list|)
operator|!=
name|wanted_inner_mode
operator|&&
operator|(
name|pos_rtx
operator|!=
literal|0
operator|||
name|orig_pos
operator|+
name|len
operator|>
name|GET_MODE_BITSIZE
argument_list|(
name|wanted_inner_mode
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
name|inner
operator|=
name|force_to_mode
argument_list|(
name|inner
argument_list|,
name|wanted_inner_mode
argument_list|,
name|pos_rtx
operator|||
name|len
operator|+
name|orig_pos
operator|>=
name|HOST_BITS_PER_WIDE_INT
condition|?
operator|~
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0
else|:
operator|(
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|len
operator|)
operator|-
literal|1
operator|)
operator|<<
name|orig_pos
operator|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Adjust mode of POS_RTX, if needed.  If we want a wider mode, we      have to zero extend.  Otherwise, we can just use a SUBREG.  */
if|if
condition|(
name|pos_rtx
operator|!=
literal|0
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|pos_mode
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|pos_rtx
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|temp
init|=
name|gen_rtx_ZERO_EXTEND
argument_list|(
name|pos_mode
argument_list|,
name|pos_rtx
argument_list|)
decl_stmt|;
comment|/* If we know that no extraneous bits are set, and that the high 	 bit is not set, convert extraction to cheaper one - either 	 SIGN_EXTENSION or ZERO_EXTENSION, that are equivalent in these 	 cases.  */
if|if
condition|(
name|flag_expensive_optimizations
operator|&&
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|pos_rtx
argument_list|)
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
operator|(
name|nonzero_bits
argument_list|(
name|pos_rtx
argument_list|,
name|GET_MODE
argument_list|(
name|pos_rtx
argument_list|)
argument_list|)
operator|&
operator|~
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|pos_rtx
argument_list|)
argument_list|)
operator|)
operator|>>
literal|1
operator|)
operator|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|rtx
name|temp1
init|=
name|gen_rtx_SIGN_EXTEND
argument_list|(
name|pos_mode
argument_list|,
name|pos_rtx
argument_list|)
decl_stmt|;
comment|/* Prefer ZERO_EXTENSION, since it gives more information to 	     backends.  */
if|if
condition|(
name|rtx_cost
argument_list|(
name|temp1
argument_list|,
name|SET
argument_list|)
operator|<
name|rtx_cost
argument_list|(
name|temp
argument_list|,
name|SET
argument_list|)
condition|)
name|temp
operator|=
name|temp1
expr_stmt|;
block|}
name|pos_rtx
operator|=
name|temp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pos_rtx
operator|!=
literal|0
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|pos_mode
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|pos_rtx
argument_list|)
argument_list|)
condition|)
name|pos_rtx
operator|=
name|gen_lowpart_for_combine
argument_list|(
name|pos_mode
argument_list|,
name|pos_rtx
argument_list|)
expr_stmt|;
comment|/* Make POS_RTX unless we already have it and it is correct.  If we don't      have a POS_RTX but we do have an ORIG_POS_RTX, the latter must      be a CONST_INT.  */
if|if
condition|(
name|pos_rtx
operator|==
literal|0
operator|&&
name|orig_pos_rtx
operator|!=
literal|0
operator|&&
name|INTVAL
argument_list|(
name|orig_pos_rtx
argument_list|)
operator|==
name|pos
condition|)
name|pos_rtx
operator|=
name|orig_pos_rtx
expr_stmt|;
elseif|else
if|if
condition|(
name|pos_rtx
operator|==
literal|0
condition|)
name|pos_rtx
operator|=
name|GEN_INT
argument_list|(
name|pos
argument_list|)
expr_stmt|;
comment|/* Make the required operation.  See if we can use existing rtx.  */
name|new
operator|=
name|gen_rtx_fmt_eee
argument_list|(
name|unsignedp
condition|?
name|ZERO_EXTRACT
else|:
name|SIGN_EXTRACT
argument_list|,
name|extraction_mode
argument_list|,
name|inner
argument_list|,
name|GEN_INT
argument_list|(
name|len
argument_list|)
argument_list|,
name|pos_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|in_dest
condition|)
name|new
operator|=
name|gen_lowpart_for_combine
argument_list|(
name|mode
argument_list|,
name|new
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* See if X contains an ASHIFT of COUNT or more bits that can be commuted    with any other operations in X.  Return X without that shift if so.  */
end_comment

begin_function
specifier|static
name|rtx
name|extract_left_shift
parameter_list|(
name|x
parameter_list|,
name|count
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|ASHIFT
case|:
comment|/* This is the shift itself.  If it is wide enough, we will return 	 either the value being shifted if the shift count is equal to 	 COUNT or a shift for the difference.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>=
name|count
condition|)
return|return
name|simplify_shift_const
argument_list|(
name|NULL_RTX
argument_list|,
name|ASHIFT
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|-
name|count
argument_list|)
return|;
break|break;
case|case
name|NEG
case|:
case|case
name|NOT
case|:
if|if
condition|(
operator|(
name|tem
operator|=
name|extract_left_shift
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|count
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|simplify_gen_unary
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|tem
argument_list|,
name|mode
argument_list|)
return|;
break|break;
case|case
name|PLUS
case|:
case|case
name|IOR
case|:
case|case
name|XOR
case|:
case|case
name|AND
case|:
comment|/* If we can safely shift this constant and we find the inner shift, 	 make a new operation.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&
operator|(
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|count
operator|)
operator|)
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
operator|&&
operator|(
name|tem
operator|=
name|extract_left_shift
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|count
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|gen_binary
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|tem
argument_list|,
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>>
name|count
argument_list|)
argument_list|)
return|;
break|break;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Look at the expression rooted at X.  Look for expressions    equivalent to ZERO_EXTRACT, SIGN_EXTRACT, ZERO_EXTEND, SIGN_EXTEND.    Form these expressions.     Return the new rtx, usually just X.     Also, for machines like the VAX that don't have logical shift insns,    try to convert logical to arithmetic shift operations in cases where    they are equivalent.  This undoes the canonicalizations to logical    shifts done elsewhere.     We try, as much as possible, to re-use rtl expressions to save memory.     IN_CODE says what kind of expression we are processing.  Normally, it is    SET.  In a memory address (inside a MEM, PLUS or minus, the latter two    being kludges), it is MEM.  When processing the arguments of a comparison    or a COMPARE against zero, it is COMPARE.  */
end_comment

begin_function
specifier|static
name|rtx
name|make_compound_operation
parameter_list|(
name|x
parameter_list|,
name|in_code
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|enum
name|rtx_code
name|in_code
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|mode_width
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|rtx
name|rhs
decl_stmt|,
name|lhs
decl_stmt|;
name|enum
name|rtx_code
name|next_code
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rtx
name|new
init|=
literal|0
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
comment|/* Select the code to be used in recursive calls.  Once we are inside an      address, we stay there.  If we have a comparison, set to COMPARE,      but once inside, go back to our default of SET.  */
name|next_code
operator|=
operator|(
name|code
operator|==
name|MEM
operator|||
name|code
operator|==
name|PLUS
operator|||
name|code
operator|==
name|MINUS
condition|?
name|MEM
else|:
operator|(
operator|(
name|code
operator|==
name|COMPARE
operator|||
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'<'
operator|)
operator|&&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|const0_rtx
operator|)
condition|?
name|COMPARE
else|:
name|in_code
operator|==
name|COMPARE
condition|?
name|SET
else|:
name|in_code
operator|)
expr_stmt|;
comment|/* Process depending on the code of this operation.  If NEW is set      nonzero, it will be returned.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|ASHIFT
case|:
comment|/* Convert shifts by constants into multiplications if inside 	 an address.  */
if|if
condition|(
name|in_code
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|new
operator|=
name|make_compound_operation
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|next_code
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_MULT
argument_list|(
name|mode
argument_list|,
name|new
argument_list|,
name|GEN_INT
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|AND
case|:
comment|/* If the second operand is not a constant, we can't do anything 	 with it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
break|break;
comment|/* If the constant is a power of two minus one and the first operand 	 is a logical right shift, make an extraction.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LSHIFTRT
operator|&&
operator|(
name|i
operator|=
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|new
operator|=
name|make_compound_operation
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|next_code
argument_list|)
expr_stmt|;
name|new
operator|=
name|make_extraction
argument_list|(
name|mode
argument_list|,
name|new
argument_list|,
literal|0
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|i
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|in_code
operator|==
name|COMPARE
argument_list|)
expr_stmt|;
block|}
comment|/* Same as previous, but for (subreg (lshiftrt ...)) in first op.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|subreg_lowpart_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|LSHIFTRT
operator|&&
operator|(
name|i
operator|=
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|new
operator|=
name|make_compound_operation
argument_list|(
name|XEXP
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|next_code
argument_list|)
expr_stmt|;
name|new
operator|=
name|make_extraction
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|new
argument_list|,
literal|0
argument_list|,
name|XEXP
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|i
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|in_code
operator|==
name|COMPARE
argument_list|)
expr_stmt|;
block|}
comment|/* Same as previous, but for (xor/ior (lshiftrt...) (lshiftrt...)).  */
elseif|else
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|XOR
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|IOR
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LSHIFTRT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|LSHIFTRT
operator|&&
operator|(
name|i
operator|=
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
comment|/* Apply the distributive law, and then try to make extractions.  */
name|new
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|mode
argument_list|,
name|gen_rtx_AND
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|gen_rtx_AND
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|=
name|make_compound_operation
argument_list|(
name|new
argument_list|,
name|in_code
argument_list|)
expr_stmt|;
block|}
comment|/* If we are have (and (rotate X C) M) and C is larger than the number 	 of bits in M, this is an extraction.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ROTATE
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|i
operator|=
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
operator|>=
literal|0
operator|&&
name|i
operator|<=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|new
operator|=
name|make_compound_operation
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|next_code
argument_list|)
expr_stmt|;
name|new
operator|=
name|make_extraction
argument_list|(
name|mode
argument_list|,
name|new
argument_list|,
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
argument_list|,
name|NULL_RTX
argument_list|,
name|i
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|in_code
operator|==
name|COMPARE
argument_list|)
expr_stmt|;
block|}
comment|/* On machines without logical shifts, if the operand of the AND is 	 a logical shift and our mask turns off all the propagated sign 	 bits, we can replace the logical shift with an arithmetic shift.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LSHIFTRT
operator|&&
operator|!
name|have_insn_for
argument_list|(
name|LSHIFTRT
argument_list|,
name|mode
argument_list|)
operator|&&
name|have_insn_for
argument_list|(
name|ASHIFTRT
argument_list|,
name|mode
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>=
literal|0
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|mode_width
operator|<=
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|mask
init|=
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|mask
operator|>>=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&
operator|~
name|mask
operator|)
operator|==
literal|0
condition|)
name|SUBST
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|gen_rtx_ASHIFTRT
argument_list|(
name|mode
argument_list|,
name|make_compound_operation
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|next_code
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If the constant is one less than a power of two, this might be 	 representable by an extraction even if no shift is present. 	 If it doesn't end up being a ZERO_EXTEND, we will ignore it unless 	 we are in a COMPARE.  */
elseif|else
if|if
condition|(
operator|(
name|i
operator|=
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
operator|>=
literal|0
condition|)
name|new
operator|=
name|make_extraction
argument_list|(
name|mode
argument_list|,
name|make_compound_operation
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|next_code
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL_RTX
argument_list|,
name|i
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|in_code
operator|==
name|COMPARE
argument_list|)
expr_stmt|;
comment|/* If we are in a comparison and this is an AND with a power of two, 	 convert this into the appropriate bit extract.  */
elseif|else
if|if
condition|(
name|in_code
operator|==
name|COMPARE
operator|&&
operator|(
name|i
operator|=
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|>=
literal|0
condition|)
name|new
operator|=
name|make_extraction
argument_list|(
name|mode
argument_list|,
name|make_compound_operation
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|next_code
argument_list|)
argument_list|,
name|i
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|LSHIFTRT
case|:
comment|/* If the sign bit is known to be zero, replace this with an 	 arithmetic shift.  */
if|if
condition|(
name|have_insn_for
argument_list|(
name|ASHIFTRT
argument_list|,
name|mode
argument_list|)
operator|&&
operator|!
name|have_insn_for
argument_list|(
name|LSHIFTRT
argument_list|,
name|mode
argument_list|)
operator|&&
name|mode_width
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
name|nonzero_bits
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|&
operator|(
literal|1
operator|<<
operator|(
name|mode_width
operator|-
literal|1
operator|)
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|new
operator|=
name|gen_rtx_ASHIFTRT
argument_list|(
name|mode
argument_list|,
name|make_compound_operation
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|next_code
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* ... fall through ...  */
case|case
name|ASHIFTRT
case|:
name|lhs
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rhs
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If we have (ashiftrt (ashift foo C1) C2) with C2>= C1, 	 this is a SIGN_EXTRACT.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|ASHIFT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|rhs
argument_list|)
operator|>=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|new
operator|=
name|make_compound_operation
argument_list|(
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|next_code
argument_list|)
expr_stmt|;
name|new
operator|=
name|make_extraction
argument_list|(
name|mode
argument_list|,
name|new
argument_list|,
name|INTVAL
argument_list|(
name|rhs
argument_list|)
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|mode_width
operator|-
name|INTVAL
argument_list|(
name|rhs
argument_list|)
argument_list|,
name|code
operator|==
name|LSHIFTRT
argument_list|,
literal|0
argument_list|,
name|in_code
operator|==
name|COMPARE
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* See if we have operations between an ASHIFTRT and an ASHIFT. 	 If so, try to merge the shifts into a SIGN_EXTEND.  We could 	 also do this for some cases of SIGN_EXTRACT, but it doesn't 	 seem worth the effort; the case checked for occurs on Alpha.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|lhs
argument_list|)
argument_list|)
operator|!=
literal|'o'
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|lhs
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'o'
operator|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|rhs
argument_list|)
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
name|new
operator|=
name|extract_left_shift
argument_list|(
name|lhs
argument_list|,
name|INTVAL
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|new
operator|=
name|make_extraction
argument_list|(
name|mode
argument_list|,
name|make_compound_operation
argument_list|(
name|new
argument_list|,
name|next_code
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL_RTX
argument_list|,
name|mode_width
operator|-
name|INTVAL
argument_list|(
name|rhs
argument_list|)
argument_list|,
name|code
operator|==
name|LSHIFTRT
argument_list|,
literal|0
argument_list|,
name|in_code
operator|==
name|COMPARE
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUBREG
case|:
comment|/* Call ourselves recursively on the inner expression.  If we are 	 narrowing the object and it has a different RTL code from 	 what it originally did, do this SUBREG as a force_to_mode.  */
name|tem
operator|=
name|make_compound_operation
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
name|in_code
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|!=
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|&&
name|subreg_lowpart_p
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|rtx
name|newer
init|=
name|force_to_mode
argument_list|(
name|tem
argument_list|,
name|mode
argument_list|,
operator|~
operator|(
name|HOST_WIDE_INT
operator|)
literal|0
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* If we have something other than a SUBREG, we might have 	     done an expansion, so rerun ourselves.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|newer
argument_list|)
operator|!=
name|SUBREG
condition|)
name|newer
operator|=
name|make_compound_operation
argument_list|(
name|newer
argument_list|,
name|in_code
argument_list|)
expr_stmt|;
return|return
name|newer
return|;
block|}
comment|/* If this is a paradoxical subreg, and the new code is a sign or 	 zero extension, omit the subreg and widen the extension.  If it 	 is a regular subreg, we can still get rid of the subreg by not 	 widening so much, or in fact removing the extension entirely.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|SIGN_EXTEND
operator|||
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|ZERO_EXTEND
operator|)
operator|&&
name|subreg_lowpart_p
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|||
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|SCALAR_INT_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
break|break;
name|tem
operator|=
name|gen_rtx_fmt_e
argument_list|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|tem
operator|=
name|gen_lowpart_for_combine
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|tem
return|;
block|}
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|new
condition|)
block|{
name|x
operator|=
name|gen_lowpart_for_combine
argument_list|(
name|mode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
comment|/* Now recursively process each operand of this operation.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
name|new
operator|=
name|make_compound_operation
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|next_code
argument_list|)
expr_stmt|;
name|SUBST
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|new
argument_list|)
expr_stmt|;
block|}
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given M see if it is a value that would select a field of bits    within an item, but not the entire word.  Return -1 if not.    Otherwise, return the starting position of the field, where 0 is the    low-order bit.     *PLEN is set to the length of the field.  */
end_comment

begin_function
specifier|static
name|int
name|get_pos_from_mask
parameter_list|(
name|m
parameter_list|,
name|plen
parameter_list|)
name|unsigned
name|HOST_WIDE_INT
name|m
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
modifier|*
name|plen
decl_stmt|;
block|{
comment|/* Get the bit number of the first 1 bit from the right, -1 if none.  */
name|int
name|pos
init|=
name|exact_log2
argument_list|(
name|m
operator|&
operator|-
name|m
argument_list|)
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Now shift off the low-order zero bits and see if we have a power of      two minus 1.  */
name|len
operator|=
name|exact_log2
argument_list|(
operator|(
name|m
operator|>>
name|pos
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
operator|*
name|plen
operator|=
name|len
expr_stmt|;
return|return
name|pos
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* See if X can be simplified knowing that we will only refer to it in    MODE and will only refer to those bits that are nonzero in MASK.    If other bits are being computed or if masking operations are done    that select a superset of the bits in MASK, they can sometimes be    ignored.     Return a possibly simplified expression, but always convert X to    MODE.  If X is a CONST_INT, AND the CONST_INT with MASK.     Also, if REG is nonzero and X is a register equal in value to REG,    replace X with REG.     If JUST_SELECT is nonzero, don't optimize by noticing that bits in MASK    are all off in X.  This is used when X will be complemented, by either    NOT, NEG, or XOR.  */
end_comment

begin_function
specifier|static
name|rtx
name|force_to_mode
parameter_list|(
name|x
parameter_list|,
name|mode
parameter_list|,
name|mask
parameter_list|,
name|reg
parameter_list|,
name|just_select
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|mask
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
name|int
name|just_select
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|next_select
init|=
name|just_select
operator|||
name|code
operator|==
name|XOR
operator|||
name|code
operator|==
name|NOT
operator|||
name|code
operator|==
name|NEG
decl_stmt|;
name|enum
name|machine_mode
name|op_mode
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|fuller_mask
decl_stmt|,
name|nonzero
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|,
name|temp
decl_stmt|;
comment|/* If this is a CALL or ASM_OPERANDS, don't do anything.  Some of the      code below will do the wrong thing since the mode of such an      expression is VOIDmode.       Also do nothing if X is a CLOBBER; this can happen if X was      the return value from a call to gen_lowpart_for_combine.  */
if|if
condition|(
name|code
operator|==
name|CALL
operator|||
name|code
operator|==
name|ASM_OPERANDS
operator|||
name|code
operator|==
name|CLOBBER
condition|)
return|return
name|x
return|;
comment|/* We want to perform the operation is its present mode unless we know      that the operation is valid in MODE, in which case we do the operation      in MODE.  */
name|op_mode
operator|=
operator|(
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&&
name|have_insn_for
argument_list|(
name|code
argument_list|,
name|mode
argument_list|)
operator|)
condition|?
name|mode
else|:
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|)
expr_stmt|;
comment|/* It is not valid to do a right-shift in a narrower mode      than the one it came in with.  */
if|if
condition|(
operator|(
name|code
operator|==
name|LSHIFTRT
operator|||
name|code
operator|==
name|ASHIFTRT
operator|)
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|op_mode
operator|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* Truncate MASK to fit OP_MODE.  */
if|if
condition|(
name|op_mode
condition|)
name|mask
operator|&=
name|GET_MODE_MASK
argument_list|(
name|op_mode
argument_list|)
expr_stmt|;
comment|/* When we have an arithmetic operation, or a shift whose count we      do not know, we need to assume that all bit the up to the highest-order      bit in MASK will be needed.  This is how we form such a mask.  */
if|if
condition|(
name|op_mode
condition|)
name|fuller_mask
operator|=
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|op_mode
argument_list|)
operator|>=
name|HOST_BITS_PER_WIDE_INT
condition|?
name|GET_MODE_MASK
argument_list|(
name|op_mode
argument_list|)
else|:
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|floor_log2
argument_list|(
name|mask
argument_list|)
operator|+
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
else|else
name|fuller_mask
operator|=
operator|~
operator|(
name|HOST_WIDE_INT
operator|)
literal|0
expr_stmt|;
comment|/* Determine what bits of X are guaranteed to be (non)zero.  */
name|nonzero
operator|=
name|nonzero_bits
argument_list|(
name|x
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* If none of the bits in X are needed, return a zero.  */
if|if
condition|(
operator|!
name|just_select
operator|&&
operator|(
name|nonzero
operator|&
name|mask
operator|)
operator|==
literal|0
condition|)
name|x
operator|=
name|const0_rtx
expr_stmt|;
comment|/* If X is a CONST_INT, return a new one.  Do this here since the      test below will fail.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|SCALAR_INT_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|gen_int_mode
argument_list|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
name|mask
argument_list|,
name|mode
argument_list|)
return|;
else|else
block|{
name|x
operator|=
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
name|mask
argument_list|)
expr_stmt|;
return|return
name|gen_lowpart_common
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
return|;
block|}
block|}
comment|/* If X is narrower than MODE and we want all the bits in X's mode, just      get X in the proper mode.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|&&
operator|(
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&
operator|~
name|mask
operator|)
operator|==
literal|0
condition|)
return|return
name|gen_lowpart_for_combine
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
return|;
comment|/* If we aren't changing the mode, X is not a SUBREG, and all zero bits in      MASK are already known to be zero in X, we need not do anything.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|mode
operator|&&
name|code
operator|!=
name|SUBREG
operator|&&
operator|(
operator|~
name|mask
operator|&
name|nonzero
operator|)
operator|==
literal|0
condition|)
return|return
name|x
return|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CLOBBER
case|:
comment|/* If X is a (clobber (const_int)), return it since we know we are 	 generating something that won't match.  */
return|return
name|x
return|;
case|case
name|USE
case|:
comment|/* X is a (use (mem ..)) that was made from a bit-field extraction that 	 spanned the boundary of the MEM.  If we are now masking so it is 	 within that boundary, we don't need the USE any more.  */
if|if
condition|(
operator|!
name|BITS_BIG_ENDIAN
operator|&&
operator|(
name|mask
operator|&
operator|~
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
name|force_to_mode
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|,
name|mask
argument_list|,
name|reg
argument_list|,
name|next_select
argument_list|)
return|;
break|break;
case|case
name|SIGN_EXTEND
case|:
case|case
name|ZERO_EXTEND
case|:
case|case
name|ZERO_EXTRACT
case|:
case|case
name|SIGN_EXTRACT
case|:
name|x
operator|=
name|expand_compound_operation
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|code
condition|)
return|return
name|force_to_mode
argument_list|(
name|x
argument_list|,
name|mode
argument_list|,
name|mask
argument_list|,
name|reg
argument_list|,
name|next_select
argument_list|)
return|;
break|break;
case|case
name|REG
case|:
if|if
condition|(
name|reg
operator|!=
literal|0
operator|&&
operator|(
name|rtx_equal_p
argument_list|(
name|get_last_value
argument_list|(
name|reg
argument_list|)
argument_list|,
name|x
argument_list|)
operator|||
name|rtx_equal_p
argument_list|(
name|reg
argument_list|,
name|get_last_value
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
condition|)
name|x
operator|=
name|reg
expr_stmt|;
break|break;
case|case
name|SUBREG
case|:
if|if
condition|(
name|subreg_lowpart_p
argument_list|(
name|x
argument_list|)
comment|/* We can ignore the effect of this SUBREG if it narrows the mode or 	     if the constant masks to zero all the bits the mode doesn't 	     have.  */
operator|&&
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
literal|0
operator|==
operator|(
name|mask
operator|&
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&
operator|~
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
condition|)
return|return
name|force_to_mode
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
name|mode
argument_list|,
name|mask
argument_list|,
name|reg
argument_list|,
name|next_select
argument_list|)
return|;
break|break;
case|case
name|AND
case|:
comment|/* If this is an AND with a constant, convert it into an AND 	 whose constant is the AND of that constant with MASK.  If it 	 remains an AND of MASK, delete it since it is redundant.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|x
operator|=
name|simplify_and_const_int
argument_list|(
name|x
argument_list|,
name|op_mode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mask
operator|&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If X is still an AND, see if it is an AND with a mask that 	     is just some low-order bits.  If so, and it is MASK, we don't 	     need it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|AND
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
operator|==
name|mask
operator|)
condition|)
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If it remains an AND, try making another AND with the bits 	     in the mode mask that aren't in MASK turned on.  If the 	     constant in the AND is wide enough, this might make a 	     cheaper constant.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|AND
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|mask
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|HOST_WIDE_INT
name|cval
init|=
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator||
operator|(
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&
operator|~
name|mask
operator|)
operator|)
decl_stmt|;
name|int
name|width
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|y
decl_stmt|;
comment|/* If MODE is narrower that HOST_WIDE_INT and CVAL is a negative 		 number, sign extend it.  */
if|if
condition|(
name|width
operator|>
literal|0
operator|&&
name|width
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
name|cval
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
operator|)
operator|!=
literal|0
condition|)
name|cval
operator||=
operator|(
name|HOST_WIDE_INT
operator|)
operator|-
literal|1
operator|<<
name|width
expr_stmt|;
name|y
operator|=
name|gen_binary
argument_list|(
name|AND
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|cval
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtx_cost
argument_list|(
name|y
argument_list|,
name|SET
argument_list|)
operator|<
name|rtx_cost
argument_list|(
name|x
argument_list|,
name|SET
argument_list|)
condition|)
name|x
operator|=
name|y
expr_stmt|;
block|}
break|break;
block|}
goto|goto
name|binop
goto|;
case|case
name|PLUS
case|:
comment|/* In (and (plus FOO C1) M), if M is a mask that just turns off 	 low-order bits (as in an alignment operation) and FOO is already 	 aligned to that boundary, mask C1 to that boundary as well. 	 This may eliminate that PLUS and, later, the AND.  */
block|{
name|unsigned
name|int
name|width
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|smask
init|=
name|mask
decl_stmt|;
comment|/* If MODE is narrower than HOST_WIDE_INT and mask is a negative 	   number, sign extend it.  */
if|if
condition|(
name|width
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
name|smask
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
operator|)
operator|!=
literal|0
condition|)
name|smask
operator||=
operator|(
name|HOST_WIDE_INT
operator|)
operator|-
literal|1
operator|<<
name|width
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|exact_log2
argument_list|(
operator|-
name|smask
argument_list|)
operator|>=
literal|0
operator|&&
operator|(
name|nonzero_bits
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|&
operator|~
name|smask
operator|)
operator|==
literal|0
operator|&&
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&
operator|~
name|smask
operator|)
operator|!=
literal|0
condition|)
return|return
name|force_to_mode
argument_list|(
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&
name|smask
operator|)
argument_list|)
argument_list|,
name|mode
argument_list|,
name|smask
argument_list|,
name|reg
argument_list|,
name|next_select
argument_list|)
return|;
block|}
comment|/* ... fall through ...  */
case|case
name|MULT
case|:
comment|/* For PLUS, MINUS and MULT, we need any bits less significant than the 	 most significant bit in MASK since carries from those bits will 	 affect the bits we are interested in.  */
name|mask
operator|=
name|fuller_mask
expr_stmt|;
goto|goto
name|binop
goto|;
case|case
name|MINUS
case|:
comment|/* If X is (minus C Y) where C's least set bit is larger than any bit 	 in the mask, then we may replace with (neg Y).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
operator|(
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|>
name|mask
operator|)
condition|)
block|{
name|x
operator|=
name|simplify_gen_unary
argument_list|(
name|NEG
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|force_to_mode
argument_list|(
name|x
argument_list|,
name|mode
argument_list|,
name|mask
argument_list|,
name|reg
argument_list|,
name|next_select
argument_list|)
return|;
block|}
comment|/* Similarly, if C contains every bit in the fuller_mask, then we may 	 replace with (not Y).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator||
operator|(
name|HOST_WIDE_INT
operator|)
name|fuller_mask
operator|)
operator|==
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|x
operator|=
name|simplify_gen_unary
argument_list|(
name|NOT
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|force_to_mode
argument_list|(
name|x
argument_list|,
name|mode
argument_list|,
name|mask
argument_list|,
name|reg
argument_list|,
name|next_select
argument_list|)
return|;
block|}
name|mask
operator|=
name|fuller_mask
expr_stmt|;
goto|goto
name|binop
goto|;
case|case
name|IOR
case|:
case|case
name|XOR
case|:
comment|/* If X is (ior (lshiftrt FOO C1) C2), try to commute the IOR and 	 LSHIFTRT so we end up with an (and (lshiftrt (ior ...) ...) ...) 	 operation which may be a bitfield extraction.  Ensure that the 	 constant we form is not wider than the mode of X.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LSHIFTRT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>=
literal|0
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|+
name|floor_log2
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|<
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&
operator|~
name|nonzero_bits
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|temp
operator|=
name|GEN_INT
argument_list|(
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&
name|mask
operator|)
operator|<<
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|=
name|gen_binary
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_binary
argument_list|(
name|LSHIFTRT
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|temp
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|force_to_mode
argument_list|(
name|x
argument_list|,
name|mode
argument_list|,
name|mask
argument_list|,
name|reg
argument_list|,
name|next_select
argument_list|)
return|;
block|}
name|binop
label|:
comment|/* For most binary operations, just propagate into the operation and 	 change the mode if we have an operation of that mode.  */
name|op0
operator|=
name|gen_lowpart_for_combine
argument_list|(
name|op_mode
argument_list|,
name|force_to_mode
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|,
name|mask
argument_list|,
name|reg
argument_list|,
name|next_select
argument_list|)
argument_list|)
expr_stmt|;
name|op1
operator|=
name|gen_lowpart_for_combine
argument_list|(
name|op_mode
argument_list|,
name|force_to_mode
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mode
argument_list|,
name|mask
argument_list|,
name|reg
argument_list|,
name|next_select
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_mode
operator|!=
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|||
name|op0
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|||
name|op1
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
name|x
operator|=
name|gen_binary
argument_list|(
name|code
argument_list|,
name|op_mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASHIFT
case|:
comment|/* For left shifts, do the same, but just for the first operand. 	 However, we cannot do anything with shifts where we cannot 	 guarantee that the counts are smaller than the size of the mode 	 because such a count will have a different meaning in a 	 wider mode.  */
if|if
condition|(
operator|!
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>=
literal|0
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|)
operator|&&
operator|!
operator|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|VOIDmode
operator|&&
operator|(
name|nonzero_bits
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|<
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|)
operator|)
condition|)
break|break;
comment|/* If the shift count is a constant and we can do arithmetic in 	 the mode of the shift, refine which bits we need.  Otherwise, use the 	 conservative form of the mask.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>=
literal|0
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
name|GET_MODE_BITSIZE
argument_list|(
name|op_mode
argument_list|)
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|op_mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
condition|)
name|mask
operator|>>=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|mask
operator|=
name|fuller_mask
expr_stmt|;
name|op0
operator|=
name|gen_lowpart_for_combine
argument_list|(
name|op_mode
argument_list|,
name|force_to_mode
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op_mode
argument_list|,
name|mask
argument_list|,
name|reg
argument_list|,
name|next_select
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_mode
operator|!=
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|||
name|op0
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|)
name|x
operator|=
name|gen_binary
argument_list|(
name|code
argument_list|,
name|op_mode
argument_list|,
name|op0
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LSHIFTRT
case|:
comment|/* Here we can only do something if the shift count is a constant, 	 this shift constant is valid for the host, and we can do arithmetic 	 in OP_MODE.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|op_mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|rtx
name|inner
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|inner_mask
decl_stmt|;
comment|/* Select the mask of the bits we need for the shift operand.  */
name|inner_mask
operator|=
name|mask
operator|<<
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We can only change the mode of the shift if we can do arithmetic 	     in the mode of the shift and INNER_MASK is no wider than the 	     width of OP_MODE.  */
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|op_mode
argument_list|)
operator|>
name|HOST_BITS_PER_WIDE_INT
operator|||
operator|(
name|inner_mask
operator|&
operator|~
name|GET_MODE_MASK
argument_list|(
name|op_mode
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|op_mode
operator|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|inner
operator|=
name|force_to_mode
argument_list|(
name|inner
argument_list|,
name|op_mode
argument_list|,
name|inner_mask
argument_list|,
name|reg
argument_list|,
name|next_select
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|op_mode
operator|||
name|inner
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|)
name|x
operator|=
name|gen_binary
argument_list|(
name|LSHIFTRT
argument_list|,
name|op_mode
argument_list|,
name|inner
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If we have (and (lshiftrt FOO C1) C2) where the combination of the 	 shift and AND produces only copies of the sign bit (C2 is one less 	 than a power of two), we can do this with just a shift.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LSHIFTRT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
comment|/* The shift puts one of the sign bit copies in the least significant 	     bit.  */
operator|&&
operator|(
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|+
name|num_sign_bit_copies
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|>=
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
operator|&&
name|exact_log2
argument_list|(
name|mask
operator|+
literal|1
argument_list|)
operator|>=
literal|0
comment|/* Number of bits left after the shift must be more than the mask 	     needs.  */
operator|&&
operator|(
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|+
name|exact_log2
argument_list|(
name|mask
operator|+
literal|1
argument_list|)
operator|)
operator|<=
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
comment|/* Must be more sign bit copies than the mask needs.  */
operator|&&
operator|(
operator|(
name|int
operator|)
name|num_sign_bit_copies
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|>=
name|exact_log2
argument_list|(
name|mask
operator|+
literal|1
argument_list|)
operator|)
condition|)
name|x
operator|=
name|gen_binary
argument_list|(
name|LSHIFTRT
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|-
name|exact_log2
argument_list|(
name|mask
operator|+
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|shiftrt
goto|;
case|case
name|ASHIFTRT
case|:
comment|/* If we are just looking for the sign bit, we don't need this shift at 	 all, even if it has a variable count.  */
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
name|mask
operator|==
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
return|return
name|force_to_mode
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|,
name|mask
argument_list|,
name|reg
argument_list|,
name|next_select
argument_list|)
return|;
comment|/* If this is a shift by a constant, get a mask that contains those bits 	 that are not copies of the sign bit.  We then have two cases:  If 	 MASK only includes those bits, this can be a logical shift, which may 	 allow simplifications.  If MASK is a single-bit field not within 	 those bits, we are requesting a copy of the sign bit and hence can 	 shift the sign bit to the appropriate location.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>=
literal|0
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|int
name|i
init|=
operator|-
literal|1
decl_stmt|;
comment|/* If the considered data is wider than HOST_WIDE_INT, we can't 	     represent a mask for all its bits in a single scalar. 	     But we only care about the lower bits, so calculate these.  */
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|nonzero
operator|=
operator|~
operator|(
name|HOST_WIDE_INT
operator|)
literal|0
expr_stmt|;
comment|/* GET_MODE_BITSIZE (GET_MODE (x)) - INTVAL (XEXP (x, 1)) 		 is the number of bits a full-width mask would have set. 		 We need only shift if these are fewer than nonzero can 		 hold.  If not, we must keep all bits set in nonzero.  */
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
name|nonzero
operator|>>=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|+
name|HOST_BITS_PER_WIDE_INT
operator|-
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nonzero
operator|=
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|nonzero
operator|>>=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mask
operator|&
operator|~
name|nonzero
operator|)
operator|==
literal|0
operator|||
operator|(
name|i
operator|=
name|exact_log2
argument_list|(
name|mask
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|x
operator|=
name|simplify_shift_const
argument_list|(
name|x
argument_list|,
name|LSHIFTRT
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|i
operator|<
literal|0
condition|?
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
else|:
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|-
literal|1
operator|-
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|ASHIFTRT
condition|)
return|return
name|force_to_mode
argument_list|(
name|x
argument_list|,
name|mode
argument_list|,
name|mask
argument_list|,
name|reg
argument_list|,
name|next_select
argument_list|)
return|;
block|}
block|}
comment|/* If MASK is 1, convert this to an LSHIFTRT.  This can be done 	 even if the shift count isn't a constant.  */
if|if
condition|(
name|mask
operator|==
literal|1
condition|)
name|x
operator|=
name|gen_binary
argument_list|(
name|LSHIFTRT
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|shiftrt
label|:
comment|/* If this is a zero- or sign-extension operation that just affects bits 	 we don't care about, remove it.  Be sure the call above returned 	 something that is still a shift.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LSHIFTRT
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ASHIFTRT
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>=
literal|0
operator|&&
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<=
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|-
operator|(
name|floor_log2
argument_list|(
name|mask
argument_list|)
operator|+
literal|1
operator|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ASHIFT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|force_to_mode
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|,
name|mask
argument_list|,
name|reg
argument_list|,
name|next_select
argument_list|)
return|;
break|break;
case|case
name|ROTATE
case|:
case|case
name|ROTATERT
case|:
comment|/* If the shift count is constant and we can do computations 	 in the mode of X, compute where the bits we care about are. 	 Otherwise, we can't do anything.  Don't change the mode of 	 the shift or propagate MODE into the shift, though.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|temp
operator|=
name|simplify_binary_operation
argument_list|(
name|code
operator|==
name|ROTATE
condition|?
name|ROTATERT
else|:
name|ROTATE
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|mask
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|&&
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|CONST_INT
condition|)
name|SUBST
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|force_to_mode
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|INTVAL
argument_list|(
name|temp
argument_list|)
argument_list|,
name|reg
argument_list|,
name|next_select
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|NEG
case|:
comment|/* If we just want the low-order bit, the NEG isn't needed since it 	 won't change the low-order bit.  */
if|if
condition|(
name|mask
operator|==
literal|1
condition|)
return|return
name|force_to_mode
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|,
name|mask
argument_list|,
name|reg
argument_list|,
name|just_select
argument_list|)
return|;
comment|/* We need any bits less significant than the most significant bit in 	 MASK since carries from those bits will affect the bits we are 	 interested in.  */
name|mask
operator|=
name|fuller_mask
expr_stmt|;
goto|goto
name|unop
goto|;
case|case
name|NOT
case|:
comment|/* (not FOO) is (xor FOO CONST), so if FOO is an LSHIFTRT, we can do the 	 same as the XOR case above.  Ensure that the constant we form is not 	 wider than the mode of X.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LSHIFTRT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>=
literal|0
operator|&&
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|+
name|floor_log2
argument_list|(
name|mask
argument_list|)
operator|<
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|temp
operator|=
name|gen_int_mode
argument_list|(
name|mask
operator|<<
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|=
name|gen_binary
argument_list|(
name|XOR
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_binary
argument_list|(
name|LSHIFTRT
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|temp
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|force_to_mode
argument_list|(
name|x
argument_list|,
name|mode
argument_list|,
name|mask
argument_list|,
name|reg
argument_list|,
name|next_select
argument_list|)
return|;
block|}
comment|/* (and (not FOO) CONST) is (not (or FOO (not CONST))), so we must 	 use the full mask inside the NOT.  */
name|mask
operator|=
name|fuller_mask
expr_stmt|;
name|unop
label|:
name|op0
operator|=
name|gen_lowpart_for_combine
argument_list|(
name|op_mode
argument_list|,
name|force_to_mode
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|,
name|mask
argument_list|,
name|reg
argument_list|,
name|next_select
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_mode
operator|!=
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|||
name|op0
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|)
name|x
operator|=
name|simplify_gen_unary
argument_list|(
name|code
argument_list|,
name|op_mode
argument_list|,
name|op0
argument_list|,
name|op_mode
argument_list|)
expr_stmt|;
break|break;
case|case
name|NE
case|:
comment|/* (and (ne FOO 0) CONST) can be (and FOO CONST) if CONST is included 	 in STORE_FLAG_VALUE and FOO has a single bit that might be nonzero, 	 which is equal to STORE_FLAG_VALUE.  */
if|if
condition|(
operator|(
name|mask
operator|&
operator|~
name|STORE_FLAG_VALUE
operator|)
operator|==
literal|0
operator|&&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|const0_rtx
operator|&&
name|exact_log2
argument_list|(
name|nonzero_bits
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
argument_list|)
operator|>=
literal|0
operator|&&
name|nonzero_bits
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|==
name|STORE_FLAG_VALUE
condition|)
return|return
name|force_to_mode
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|,
name|mask
argument_list|,
name|reg
argument_list|,
name|next_select
argument_list|)
return|;
break|break;
case|case
name|IF_THEN_ELSE
case|:
comment|/* We have no way of knowing if the IF_THEN_ELSE can itself be 	 written in a narrower mode.  We play it safe and do not do so.  */
name|SUBST
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|gen_lowpart_for_combine
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|force_to_mode
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mode
argument_list|,
name|mask
argument_list|,
name|reg
argument_list|,
name|next_select
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SUBST
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gen_lowpart_for_combine
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|force_to_mode
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|,
name|mode
argument_list|,
name|mask
argument_list|,
name|reg
argument_list|,
name|next_select
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* Ensure we return a value of the proper mode.  */
return|return
name|gen_lowpart_for_combine
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if X is an expression that has one of two values depending on    whether some other value is zero or nonzero.  In that case, we return the    value that is being tested, *PTRUE is set to the value if the rtx being    returned has a nonzero value, and *PFALSE is set to the other alternative.     If we return zero, we set *PTRUE and *PFALSE to X.  */
end_comment

begin_function
specifier|static
name|rtx
name|if_then_else_cond
parameter_list|(
name|x
parameter_list|,
name|ptrue
parameter_list|,
name|pfalse
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
modifier|*
name|ptrue
decl_stmt|,
decl|*
name|pfalse
decl_stmt|;
end_function

begin_block
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
name|cond0
decl_stmt|,
name|cond1
decl_stmt|,
name|true0
decl_stmt|,
name|true1
decl_stmt|,
name|false0
decl_stmt|,
name|false1
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|nz
decl_stmt|;
comment|/* If we are comparing a value against zero, we are done.  */
if|if
condition|(
operator|(
name|code
operator|==
name|NE
operator|||
name|code
operator|==
name|EQ
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|ptrue
operator|=
operator|(
name|code
operator|==
name|NE
operator|)
condition|?
name|const_true_rtx
else|:
name|const0_rtx
expr_stmt|;
operator|*
name|pfalse
operator|=
operator|(
name|code
operator|==
name|NE
operator|)
condition|?
name|const0_rtx
else|:
name|const_true_rtx
expr_stmt|;
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/* If this is a unary operation whose operand has one of two values, apply      our opcode to compute those values.  */
elseif|else
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'1'
operator|&&
operator|(
name|cond0
operator|=
name|if_then_else_cond
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|true0
argument_list|,
operator|&
name|false0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|ptrue
operator|=
name|simplify_gen_unary
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|true0
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|pfalse
operator|=
name|simplify_gen_unary
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|false0
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cond0
return|;
block|}
comment|/* If this is a COMPARE, do nothing, since the IF_THEN_ELSE we would      make can't possibly match and would suppress other optimizations.  */
elseif|else
if|if
condition|(
name|code
operator|==
name|COMPARE
condition|)
empty_stmt|;
comment|/* If this is a binary operation, see if either side has only one of two      values.  If either one does or if both do and they are conditional on      the same value, compute the new true and false values.  */
elseif|else
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'c'
operator|||
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'2'
operator|||
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'<'
condition|)
block|{
name|cond0
operator|=
name|if_then_else_cond
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|true0
argument_list|,
operator|&
name|false0
argument_list|)
expr_stmt|;
name|cond1
operator|=
name|if_then_else_cond
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|&
name|true1
argument_list|,
operator|&
name|false1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cond0
operator|!=
literal|0
operator|||
name|cond1
operator|!=
literal|0
operator|)
operator|&&
operator|!
operator|(
name|cond0
operator|!=
literal|0
operator|&&
name|cond1
operator|!=
literal|0
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|cond0
argument_list|,
name|cond1
argument_list|)
operator|)
condition|)
block|{
comment|/* If if_then_else_cond returned zero, then true/false are the 	     same rtl.  We must copy one of them to prevent invalid rtl 	     sharing.  */
if|if
condition|(
name|cond0
operator|==
literal|0
condition|)
name|true0
operator|=
name|copy_rtx
argument_list|(
name|true0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cond1
operator|==
literal|0
condition|)
name|true1
operator|=
name|copy_rtx
argument_list|(
name|true1
argument_list|)
expr_stmt|;
operator|*
name|ptrue
operator|=
name|gen_binary
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|true0
argument_list|,
name|true1
argument_list|)
expr_stmt|;
operator|*
name|pfalse
operator|=
name|gen_binary
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|false0
argument_list|,
name|false1
argument_list|)
expr_stmt|;
return|return
name|cond0
condition|?
name|cond0
else|:
name|cond1
return|;
block|}
comment|/* See if we have PLUS, IOR, XOR, MINUS or UMAX, where one of the 	 operands is zero when the other is nonzero, and vice-versa, 	 and STORE_FLAG_VALUE is 1 or -1.  */
if|if
condition|(
operator|(
name|STORE_FLAG_VALUE
operator|==
literal|1
operator|||
name|STORE_FLAG_VALUE
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|code
operator|==
name|PLUS
operator|||
name|code
operator|==
name|IOR
operator|||
name|code
operator|==
name|XOR
operator|||
name|code
operator|==
name|MINUS
operator|||
name|code
operator|==
name|UMAX
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MULT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|rtx
name|op0
init|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|cond0
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cond1
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|cond0
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|cond1
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|cond0
argument_list|)
operator|==
name|combine_reversed_comparison_code
argument_list|(
name|cond1
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|cond0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|cond1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|cond0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|cond1
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|swap_condition
argument_list|(
name|GET_CODE
argument_list|(
name|cond0
argument_list|)
argument_list|)
operator|==
name|combine_reversed_comparison_code
argument_list|(
name|cond1
argument_list|)
operator|)
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|cond0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|cond1
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|cond0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|cond1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|x
argument_list|)
condition|)
block|{
operator|*
name|ptrue
operator|=
name|gen_binary
argument_list|(
name|MULT
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|const_true_rtx
argument_list|)
expr_stmt|;
operator|*
name|pfalse
operator|=
name|gen_binary
argument_list|(
name|MULT
argument_list|,
name|mode
argument_list|,
operator|(
name|code
operator|==
name|MINUS
condition|?
name|simplify_gen_unary
argument_list|(
name|NEG
argument_list|,
name|mode
argument_list|,
name|op1
argument_list|,
name|mode
argument_list|)
else|:
name|op1
operator|)
argument_list|,
name|const_true_rtx
argument_list|)
expr_stmt|;
return|return
name|cond0
return|;
block|}
block|}
comment|/* Similarly for MULT, AND and UMIN, except that for these the result 	 is always zero.  */
if|if
condition|(
operator|(
name|STORE_FLAG_VALUE
operator|==
literal|1
operator|||
name|STORE_FLAG_VALUE
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|code
operator|==
name|MULT
operator|||
name|code
operator|==
name|AND
operator|||
name|code
operator|==
name|UMIN
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MULT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|cond0
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cond1
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|cond0
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|cond1
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|cond0
argument_list|)
operator|==
name|combine_reversed_comparison_code
argument_list|(
name|cond1
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|cond0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|cond1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|cond0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|cond1
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|swap_condition
argument_list|(
name|GET_CODE
argument_list|(
name|cond0
argument_list|)
argument_list|)
operator|==
name|combine_reversed_comparison_code
argument_list|(
name|cond1
argument_list|)
operator|)
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|cond0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|cond1
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|cond0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|cond1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|x
argument_list|)
condition|)
block|{
operator|*
name|ptrue
operator|=
operator|*
name|pfalse
operator|=
name|const0_rtx
expr_stmt|;
return|return
name|cond0
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|IF_THEN_ELSE
condition|)
block|{
comment|/* If we have IF_THEN_ELSE already, extract the condition and 	 canonicalize it if it is NE or EQ.  */
name|cond0
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|ptrue
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|,
operator|*
name|pfalse
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|cond0
argument_list|)
operator|==
name|NE
operator|&&
name|XEXP
argument_list|(
name|cond0
argument_list|,
literal|1
argument_list|)
operator|==
name|const0_rtx
condition|)
return|return
name|XEXP
argument_list|(
name|cond0
argument_list|,
literal|0
argument_list|)
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|cond0
argument_list|)
operator|==
name|EQ
operator|&&
name|XEXP
argument_list|(
name|cond0
argument_list|,
literal|1
argument_list|)
operator|==
name|const0_rtx
condition|)
block|{
operator|*
name|ptrue
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
operator|,
operator|*
name|pfalse
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|XEXP
argument_list|(
name|cond0
argument_list|,
literal|0
argument_list|)
return|;
block|}
else|else
return|return
name|cond0
return|;
block|}
comment|/* If X is a SUBREG, we can narrow both the true and false values      if the inner expression, if there is a condition.  */
elseif|else
if|if
condition|(
name|code
operator|==
name|SUBREG
operator|&&
literal|0
operator|!=
operator|(
name|cond0
operator|=
name|if_then_else_cond
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
operator|&
name|true0
argument_list|,
operator|&
name|false0
argument_list|)
operator|)
condition|)
block|{
operator|*
name|ptrue
operator|=
name|simplify_gen_subreg
argument_list|(
name|mode
argument_list|,
name|true0
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|pfalse
operator|=
name|simplify_gen_subreg
argument_list|(
name|mode
argument_list|,
name|false0
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cond0
return|;
block|}
comment|/* If X is a constant, this isn't special and will cause confusions      if we treat it as such.  Likewise if it is equivalent to a constant.  */
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
operator|||
operator|(
operator|(
name|cond0
operator|=
name|get_last_value
argument_list|(
name|x
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|CONSTANT_P
argument_list|(
name|cond0
argument_list|)
operator|)
condition|)
empty_stmt|;
comment|/* If we're in BImode, canonicalize on 0 and STORE_FLAG_VALUE, as that      will be least confusing to the rest of the compiler.  */
elseif|else
if|if
condition|(
name|mode
operator|==
name|BImode
condition|)
block|{
operator|*
name|ptrue
operator|=
name|GEN_INT
argument_list|(
name|STORE_FLAG_VALUE
argument_list|)
operator|,
operator|*
name|pfalse
operator|=
name|const0_rtx
expr_stmt|;
return|return
name|x
return|;
block|}
comment|/* If X is known to be either 0 or -1, those are the true and      false values when testing X.  */
elseif|else
if|if
condition|(
name|x
operator|==
name|constm1_rtx
operator|||
name|x
operator|==
name|const0_rtx
operator|||
operator|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|num_sign_bit_copies
argument_list|(
name|x
argument_list|,
name|mode
argument_list|)
operator|==
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|)
condition|)
block|{
operator|*
name|ptrue
operator|=
name|constm1_rtx
operator|,
operator|*
name|pfalse
operator|=
name|const0_rtx
expr_stmt|;
return|return
name|x
return|;
block|}
comment|/* Likewise for 0 or a single bit.  */
elseif|else
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|exact_log2
argument_list|(
name|nz
operator|=
name|nonzero_bits
argument_list|(
name|x
argument_list|,
name|mode
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
block|{
operator|*
name|ptrue
operator|=
name|gen_int_mode
argument_list|(
name|nz
argument_list|,
name|mode
argument_list|)
operator|,
operator|*
name|pfalse
operator|=
name|const0_rtx
expr_stmt|;
return|return
name|x
return|;
block|}
comment|/* Otherwise fail; show no condition with true and false values the same.  */
operator|*
name|ptrue
operator|=
operator|*
name|pfalse
operator|=
name|x
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Return the value of expression X given the fact that condition COND    is known to be true when applied to REG as its first operand and VAL    as its second.  X is known to not be shared and so can be modified in    place.     We only handle the simplest cases, and specifically those cases that    arise with IF_THEN_ELSE expressions.  */
end_comment

begin_function
specifier|static
name|rtx
name|known_cond
parameter_list|(
name|x
parameter_list|,
name|cond
parameter_list|,
name|reg
parameter_list|,
name|val
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|enum
name|rtx_code
name|cond
decl_stmt|;
name|rtx
name|reg
decl_stmt|,
name|val
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|side_effects_p
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|x
return|;
comment|/* If either operand of the condition is a floating point value,      then we have to avoid collapsing an EQ comparison.  */
if|if
condition|(
name|cond
operator|==
name|EQ
operator|&&
name|rtx_equal_p
argument_list|(
name|x
argument_list|,
name|reg
argument_list|)
operator|&&
operator|!
name|FLOAT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&&
operator|!
name|FLOAT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|val
argument_list|)
argument_list|)
condition|)
return|return
name|val
return|;
if|if
condition|(
name|cond
operator|==
name|UNEQ
operator|&&
name|rtx_equal_p
argument_list|(
name|x
argument_list|,
name|reg
argument_list|)
condition|)
return|return
name|val
return|;
comment|/* If X is (abs REG) and we know something about REG's relationship      with zero, we may be able to simplify this.  */
if|if
condition|(
name|code
operator|==
name|ABS
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|reg
argument_list|)
operator|&&
name|val
operator|==
name|const0_rtx
condition|)
switch|switch
condition|(
name|cond
condition|)
block|{
case|case
name|GE
case|:
case|case
name|GT
case|:
case|case
name|EQ
case|:
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|LT
case|:
case|case
name|LE
case|:
return|return
name|simplify_gen_unary
argument_list|(
name|NEG
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
default|default:
break|break;
block|}
comment|/* The only other cases we handle are MIN, MAX, and comparisons if the      operands are the same as REG and VAL.  */
elseif|else
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'<'
operator|||
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'c'
condition|)
block|{
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|val
argument_list|)
condition|)
name|cond
operator|=
name|swap_condition
argument_list|(
name|cond
argument_list|)
operator|,
name|temp
operator|=
name|val
operator|,
name|val
operator|=
name|reg
operator|,
name|reg
operator|=
name|temp
expr_stmt|;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|reg
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|val
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'<'
condition|)
block|{
if|if
condition|(
name|comparison_dominates_p
argument_list|(
name|cond
argument_list|,
name|code
argument_list|)
condition|)
return|return
name|const_true_rtx
return|;
name|code
operator|=
name|combine_reversed_comparison_code
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|UNKNOWN
operator|&&
name|comparison_dominates_p
argument_list|(
name|cond
argument_list|,
name|code
argument_list|)
condition|)
return|return
name|const0_rtx
return|;
else|else
return|return
name|x
return|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|SMAX
operator|||
name|code
operator|==
name|SMIN
operator|||
name|code
operator|==
name|UMIN
operator|||
name|code
operator|==
name|UMAX
condition|)
block|{
name|int
name|unsignedp
init|=
operator|(
name|code
operator|==
name|UMIN
operator|||
name|code
operator|==
name|UMAX
operator|)
decl_stmt|;
comment|/* Do not reverse the condition when it is NE or EQ. 		 This is because we cannot conclude anything about 		 the value of 'SMAX (x, y)' when x is not equal to y, 		 but we can when x equals y.  */
if|if
condition|(
operator|(
name|code
operator|==
name|SMAX
operator|||
name|code
operator|==
name|UMAX
operator|)
operator|&&
operator|!
operator|(
name|cond
operator|==
name|EQ
operator|||
name|cond
operator|==
name|NE
operator|)
condition|)
name|cond
operator|=
name|reverse_condition
argument_list|(
name|cond
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cond
condition|)
block|{
case|case
name|GE
case|:
case|case
name|GT
case|:
return|return
name|unsignedp
condition|?
name|x
else|:
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
return|;
case|case
name|LE
case|:
case|case
name|LT
case|:
return|return
name|unsignedp
condition|?
name|x
else|:
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|GEU
case|:
case|case
name|GTU
case|:
return|return
name|unsignedp
condition|?
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
else|:
name|x
return|;
case|case
name|LEU
case|:
case|case
name|LTU
case|:
return|return
name|unsignedp
condition|?
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
else|:
name|x
return|;
default|default:
break|break;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|SUBREG
condition|)
block|{
name|enum
name|machine_mode
name|inner_mode
init|=
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|new
decl_stmt|,
name|r
init|=
name|known_cond
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
name|cond
argument_list|,
name|reg
argument_list|,
name|val
argument_list|)
decl_stmt|;
if|if
condition|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
operator|!=
name|r
condition|)
block|{
comment|/* We must simplify subreg here, before we lose track of the 	     original inner_mode.  */
name|new
operator|=
name|simplify_subreg
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|r
argument_list|,
name|inner_mode
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
condition|)
return|return
name|new
return|;
else|else
name|SUBST
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
return|return
name|x
return|;
block|}
comment|/* We don't have to handle SIGN_EXTEND here, because even in the      case of replacing something with a modeless CONST_INT, a      CONST_INT is already (supposed to be) a valid sign extension for      its narrower mode, which implies it's already properly      sign-extended for the wider mode.  Now, for ZERO_EXTEND, the      story is different.  */
elseif|else
if|if
condition|(
name|code
operator|==
name|ZERO_EXTEND
condition|)
block|{
name|enum
name|machine_mode
name|inner_mode
init|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|new
decl_stmt|,
name|r
init|=
name|known_cond
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|cond
argument_list|,
name|reg
argument_list|,
name|val
argument_list|)
decl_stmt|;
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|!=
name|r
condition|)
block|{
comment|/* We must simplify the zero_extend here, before we lose              track of the original inner_mode.  */
name|new
operator|=
name|simplify_unary_operation
argument_list|(
name|ZERO_EXTEND
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|r
argument_list|,
name|inner_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
condition|)
return|return
name|new
return|;
else|else
name|SUBST
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
return|return
name|x
return|;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|SUBST
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|known_cond
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|cond
argument_list|,
name|reg
argument_list|,
name|val
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|SUBST
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|known_cond
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|cond
argument_list|,
name|reg
argument_list|,
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* See if X and Y are equal for the purposes of seeing if we can rewrite an    assignment as a field assignment.  */
end_comment

begin_function
specifier|static
name|int
name|rtx_equal_for_field_assignment_p
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|y
decl_stmt|;
block|{
if|if
condition|(
name|x
operator|==
name|y
operator|||
name|rtx_equal_p
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|x
operator|==
literal|0
operator|||
name|y
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Check for a paradoxical SUBREG of a MEM compared with the MEM.      Note that all SUBREGs of MEM are paradoxical; otherwise they      would have been rewritten.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|y
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|rtx_equal_p
argument_list|(
name|SUBREG_REG
argument_list|(
name|y
argument_list|)
argument_list|,
name|gen_lowpart_for_combine
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|y
argument_list|)
argument_list|)
argument_list|,
name|x
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|rtx_equal_p
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
name|gen_lowpart_for_combine
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|y
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* We used to see if get_last_value of X and Y were the same but that's      not correct.  In one direction, we'll cause the assignment to have      the wrong destination and in the case, we'll import a register into this      insn that might have already have been dead.   So fail if none of the      above cases are true.  */
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* See if X, a SET operation, can be rewritten as a bit-field assignment.    Return that assignment if so.     We only handle the most common cases.  */
end_comment

begin_function
specifier|static
name|rtx
name|make_field_assignment
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
name|assign
decl_stmt|;
name|rtx
name|rhs
decl_stmt|,
name|lhs
decl_stmt|;
name|HOST_WIDE_INT
name|c1
decl_stmt|;
name|HOST_WIDE_INT
name|pos
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|len
decl_stmt|;
name|rtx
name|other
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
comment|/* If SRC was (and (not (ashift (const_int 1) POS)) DEST), this is      a clear of a one-bit field.  We will have changed it to      (and (rotate (const_int -2) POS) DEST), so check for that.  Also check      for a SUBREG.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|AND
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ROTATE
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
operator|-
literal|2
operator|&&
name|rtx_equal_for_field_assignment_p
argument_list|(
name|dest
argument_list|,
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|assign
operator|=
name|make_extraction
argument_list|(
name|VOIDmode
argument_list|,
name|dest
argument_list|,
literal|0
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|assign
operator|!=
literal|0
condition|)
return|return
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|assign
argument_list|,
name|const0_rtx
argument_list|)
return|;
return|return
name|x
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|AND
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|subreg_lowpart_p
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|ROTATE
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
operator|-
literal|2
operator|&&
name|rtx_equal_for_field_assignment_p
argument_list|(
name|dest
argument_list|,
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|assign
operator|=
name|make_extraction
argument_list|(
name|VOIDmode
argument_list|,
name|dest
argument_list|,
literal|0
argument_list|,
name|XEXP
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|assign
operator|!=
literal|0
condition|)
return|return
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|assign
argument_list|,
name|const0_rtx
argument_list|)
return|;
return|return
name|x
return|;
block|}
comment|/* If SRC is (ior (ashift (const_int 1) POS) DEST), this is a set of a      one-bit field.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|IOR
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ASHIFT
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|const1_rtx
operator|&&
name|rtx_equal_for_field_assignment_p
argument_list|(
name|dest
argument_list|,
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|assign
operator|=
name|make_extraction
argument_list|(
name|VOIDmode
argument_list|,
name|dest
argument_list|,
literal|0
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|assign
operator|!=
literal|0
condition|)
return|return
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|assign
argument_list|,
name|const1_rtx
argument_list|)
return|;
return|return
name|x
return|;
block|}
comment|/* The other case we handle is assignments into a constant-position      field.  They look like (ior/xor (and DEST C1) OTHER).  If C1 represents      a mask that has all one bits except for a group of zero bits and      OTHER is known to have zeros where C1 has ones, this is such an      assignment.  Compute the position and length from C1.  Shift OTHER      to the appropriate position, force it to the required mode, and      make the extraction.  Check for the AND in both operands.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|!=
name|IOR
operator|&&
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|!=
name|XOR
condition|)
return|return
name|x
return|;
name|rhs
operator|=
name|expand_compound_operation
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|lhs
operator|=
name|expand_compound_operation
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|AND
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|rtx_equal_for_field_assignment_p
argument_list|(
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|dest
argument_list|)
condition|)
name|c1
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|,
name|other
operator|=
name|lhs
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|AND
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|rtx_equal_for_field_assignment_p
argument_list|(
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|dest
argument_list|)
condition|)
name|c1
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|,
name|other
operator|=
name|rhs
expr_stmt|;
else|else
return|return
name|x
return|;
name|pos
operator|=
name|get_pos_from_mask
argument_list|(
operator|(
operator|~
name|c1
operator|)
operator|&
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0
operator|||
name|pos
operator|+
name|len
operator|>
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|||
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|>
name|HOST_BITS_PER_WIDE_INT
operator|||
operator|(
name|c1
operator|&
name|nonzero_bits
argument_list|(
name|other
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|x
return|;
name|assign
operator|=
name|make_extraction
argument_list|(
name|VOIDmode
argument_list|,
name|dest
argument_list|,
name|pos
argument_list|,
name|NULL_RTX
argument_list|,
name|len
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|assign
operator|==
literal|0
condition|)
return|return
name|x
return|;
comment|/* The mode to use for the source is the mode of the assignment, or of      what is inside a possible STRICT_LOW_PART.  */
name|mode
operator|=
operator|(
name|GET_CODE
argument_list|(
name|assign
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|?
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|assign
argument_list|,
literal|0
argument_list|)
argument_list|)
else|:
name|GET_MODE
argument_list|(
name|assign
argument_list|)
operator|)
expr_stmt|;
comment|/* Shift OTHER right POS places and make it the source, restricting it      to the proper length and mode.  */
name|src
operator|=
name|force_to_mode
argument_list|(
name|simplify_shift_const
argument_list|(
name|NULL_RTX
argument_list|,
name|LSHIFTRT
argument_list|,
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|,
name|other
argument_list|,
name|pos
argument_list|)
argument_list|,
name|mode
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|>=
name|HOST_BITS_PER_WIDE_INT
condition|?
operator|~
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0
else|:
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|len
operator|)
operator|-
literal|1
argument_list|,
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|assign
argument_list|,
name|src
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* See if X is of the form (+ (* a c) (* b c)) and convert to (* (+ a b) c)    if so.  */
end_comment

begin_function
specifier|static
name|rtx
name|apply_distributive_law
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
name|lhs
decl_stmt|,
name|rhs
decl_stmt|,
name|other
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
name|enum
name|rtx_code
name|inner_code
decl_stmt|;
comment|/* Distributivity is not true for floating point.      It can change the value.  So don't do it.      -- rms and moshier@world.std.com.  */
if|if
condition|(
name|FLOAT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
return|return
name|x
return|;
comment|/* The outer operation can only be one of the following:  */
if|if
condition|(
name|code
operator|!=
name|IOR
operator|&&
name|code
operator|!=
name|AND
operator|&&
name|code
operator|!=
name|XOR
operator|&&
name|code
operator|!=
name|PLUS
operator|&&
name|code
operator|!=
name|MINUS
condition|)
return|return
name|x
return|;
name|lhs
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|,
name|rhs
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If either operand is a primitive we can't do anything, so get out      fast.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|lhs
argument_list|)
argument_list|)
operator|==
literal|'o'
operator|||
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|==
literal|'o'
condition|)
return|return
name|x
return|;
name|lhs
operator|=
name|expand_compound_operation
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
name|rhs
operator|=
name|expand_compound_operation
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
name|inner_code
operator|=
name|GET_CODE
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|inner_code
operator|!=
name|GET_CODE
argument_list|(
name|rhs
argument_list|)
condition|)
return|return
name|x
return|;
comment|/* See if the inner and outer operations distribute.  */
switch|switch
condition|(
name|inner_code
condition|)
block|{
case|case
name|LSHIFTRT
case|:
case|case
name|ASHIFTRT
case|:
case|case
name|AND
case|:
case|case
name|IOR
case|:
comment|/* These all distribute except over PLUS.  */
if|if
condition|(
name|code
operator|==
name|PLUS
operator|||
name|code
operator|==
name|MINUS
condition|)
return|return
name|x
return|;
break|break;
case|case
name|MULT
case|:
if|if
condition|(
name|code
operator|!=
name|PLUS
operator|&&
name|code
operator|!=
name|MINUS
condition|)
return|return
name|x
return|;
break|break;
case|case
name|ASHIFT
case|:
comment|/* This is also a multiply, so it distributes over everything.  */
break|break;
case|case
name|SUBREG
case|:
comment|/* Non-paradoxical SUBREGs distributes over all operations, provided 	 the inner modes and byte offsets are the same, this is an extraction 	 of a low-order part, we don't convert an fp operation to int or 	 vice versa, and we would not be converting a single-word 	 operation into a multi-word operation.  The latter test is not 	 required, but it prevents generating unneeded multi-word operations. 	 Some of the previous tests are redundant given the latter test, but 	 are retained because they are required for correctness.  	 We produce the result slightly differently in this case.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|lhs
argument_list|)
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|||
name|SUBREG_BYTE
argument_list|(
name|lhs
argument_list|)
operator|!=
name|SUBREG_BYTE
argument_list|(
name|rhs
argument_list|)
operator|||
operator|!
name|subreg_lowpart_p
argument_list|(
name|lhs
argument_list|)
operator|||
operator|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|lhs
argument_list|)
argument_list|)
operator|!=
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|lhs
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|lhs
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|lhs
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|||
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|lhs
argument_list|)
argument_list|)
argument_list|)
operator|>
name|UNITS_PER_WORD
condition|)
return|return
name|x
return|;
name|tem
operator|=
name|gen_binary
argument_list|(
name|code
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|lhs
argument_list|)
argument_list|)
argument_list|,
name|SUBREG_REG
argument_list|(
name|lhs
argument_list|)
argument_list|,
name|SUBREG_REG
argument_list|(
name|rhs
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|gen_lowpart_for_combine
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|tem
argument_list|)
return|;
default|default:
return|return
name|x
return|;
block|}
comment|/* Set LHS and RHS to the inner operands (A and B in the example      above) and set OTHER to the common operand (C in the example).      These is only one way to do this unless the inner operation is      commutative.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|inner_code
argument_list|)
operator|==
literal|'c'
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|other
operator|=
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
operator|,
name|lhs
operator|=
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
operator|,
name|rhs
operator|=
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|inner_code
argument_list|)
operator|==
literal|'c'
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|other
operator|=
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
operator|,
name|lhs
operator|=
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
operator|,
name|rhs
operator|=
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|inner_code
argument_list|)
operator|==
literal|'c'
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|other
operator|=
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
operator|,
name|lhs
operator|=
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
operator|,
name|rhs
operator|=
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|other
operator|=
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
operator|,
name|lhs
operator|=
name|XEXP
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
operator|,
name|rhs
operator|=
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
return|return
name|x
return|;
comment|/* Form the new inner operation, seeing if it simplifies first.  */
name|tem
operator|=
name|gen_binary
argument_list|(
name|code
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|lhs
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
comment|/* There is one exception to the general way of distributing:      (a ^ b) | (a ^ c) -> (~a)& (b ^ c)  */
if|if
condition|(
name|code
operator|==
name|XOR
operator|&&
name|inner_code
operator|==
name|IOR
condition|)
block|{
name|inner_code
operator|=
name|AND
expr_stmt|;
name|other
operator|=
name|simplify_gen_unary
argument_list|(
name|NOT
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|other
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* We may be able to continuing distributing the result, so call      ourselves recursively on the inner operation before forming the      outer operation, which we return.  */
return|return
name|gen_binary
argument_list|(
name|inner_code
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|apply_distributive_law
argument_list|(
name|tem
argument_list|)
argument_list|,
name|other
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* We have X, a logical `and' of VAROP with the constant CONSTOP, to be done    in MODE.     Return an equivalent form, if different from X.  Otherwise, return X.  If    X is zero, we are to always construct the equivalent form.  */
end_comment

begin_function
specifier|static
name|rtx
name|simplify_and_const_int
parameter_list|(
name|x
parameter_list|,
name|mode
parameter_list|,
name|varop
parameter_list|,
name|constop
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|varop
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|constop
decl_stmt|;
block|{
name|unsigned
name|HOST_WIDE_INT
name|nonzero
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Simplify VAROP knowing that we will be only looking at some of the      bits in it.       Note by passing in CONSTOP, we guarantee that the bits not set in      CONSTOP are not significant and will never be examined.  We must      ensure that is the case by explicitly masking out those bits      before returning.  */
name|varop
operator|=
name|force_to_mode
argument_list|(
name|varop
argument_list|,
name|mode
argument_list|,
name|constop
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If VAROP is a CLOBBER, we will fail so return it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|varop
argument_list|)
operator|==
name|CLOBBER
condition|)
return|return
name|varop
return|;
comment|/* If VAROP is a CONST_INT, then we need to apply the mask in CONSTOP      to VAROP and return the new constant.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|varop
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|GEN_INT
argument_list|(
name|trunc_int_for_mode
argument_list|(
name|INTVAL
argument_list|(
name|varop
argument_list|)
operator|&
name|constop
argument_list|,
name|mode
argument_list|)
argument_list|)
return|;
comment|/* See what bits may be nonzero in VAROP.  Unlike the general case of      a call to nonzero_bits, here we don't care about bits outside      MODE.  */
name|nonzero
operator|=
name|nonzero_bits
argument_list|(
name|varop
argument_list|,
name|mode
argument_list|)
operator|&
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* Turn off all bits in the constant that are known to already be zero.      Thus, if the AND isn't needed at all, we will have CONSTOP == NONZERO_BITS      which is tested below.  */
name|constop
operator|&=
name|nonzero
expr_stmt|;
comment|/* If we don't have any bits left, return zero.  */
if|if
condition|(
name|constop
operator|==
literal|0
condition|)
return|return
name|const0_rtx
return|;
comment|/* If VAROP is a NEG of something known to be zero or 1 and CONSTOP is      a power of two, we can replace this with an ASHIFT.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|varop
argument_list|)
operator|==
name|NEG
operator|&&
name|nonzero_bits
argument_list|(
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|==
literal|1
operator|&&
operator|(
name|i
operator|=
name|exact_log2
argument_list|(
name|constop
argument_list|)
operator|)
operator|>=
literal|0
condition|)
return|return
name|simplify_shift_const
argument_list|(
name|NULL_RTX
argument_list|,
name|ASHIFT
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|0
argument_list|)
argument_list|,
name|i
argument_list|)
return|;
comment|/* If VAROP is an IOR or XOR, apply the AND to both branches of the IOR      or XOR, then try to apply the distributive law.  This may eliminate      operations if either branch can be simplified because of the AND.      It may also make some cases more complex, but those cases probably      won't match a pattern either with or without this.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|varop
argument_list|)
operator|==
name|IOR
operator|||
name|GET_CODE
argument_list|(
name|varop
argument_list|)
operator|==
name|XOR
condition|)
return|return
name|gen_lowpart_for_combine
argument_list|(
name|mode
argument_list|,
name|apply_distributive_law
argument_list|(
name|gen_binary
argument_list|(
name|GET_CODE
argument_list|(
name|varop
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|varop
argument_list|)
argument_list|,
name|simplify_and_const_int
argument_list|(
name|NULL_RTX
argument_list|,
name|GET_MODE
argument_list|(
name|varop
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|0
argument_list|)
argument_list|,
name|constop
argument_list|)
argument_list|,
name|simplify_and_const_int
argument_list|(
name|NULL_RTX
argument_list|,
name|GET_MODE
argument_list|(
name|varop
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|1
argument_list|)
argument_list|,
name|constop
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* If VAROP is PLUS, and the constant is a mask of low bite, distribute      the AND and see if one of the operands simplifies to zero.  If so, we      may eliminate it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|varop
argument_list|)
operator|==
name|PLUS
operator|&&
name|exact_log2
argument_list|(
name|constop
operator|+
literal|1
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|rtx
name|o0
decl_stmt|,
name|o1
decl_stmt|;
name|o0
operator|=
name|simplify_and_const_int
argument_list|(
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|0
argument_list|)
argument_list|,
name|constop
argument_list|)
expr_stmt|;
name|o1
operator|=
name|simplify_and_const_int
argument_list|(
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|1
argument_list|)
argument_list|,
name|constop
argument_list|)
expr_stmt|;
if|if
condition|(
name|o0
operator|==
name|const0_rtx
condition|)
return|return
name|o1
return|;
if|if
condition|(
name|o1
operator|==
name|const0_rtx
condition|)
return|return
name|o0
return|;
block|}
comment|/* Get VAROP in MODE.  Try to get a SUBREG if not.  Don't make a new SUBREG      if we already had one (just check for the simplest cases).  */
if|if
condition|(
name|x
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|mode
operator|&&
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|varop
condition|)
name|varop
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|varop
operator|=
name|gen_lowpart_for_combine
argument_list|(
name|mode
argument_list|,
name|varop
argument_list|)
expr_stmt|;
comment|/* If we can't make the SUBREG, try to return what we were given.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|varop
argument_list|)
operator|==
name|CLOBBER
condition|)
return|return
name|x
condition|?
name|x
else|:
name|varop
return|;
comment|/* If we are only masking insignificant bits, return VAROP.  */
if|if
condition|(
name|constop
operator|==
name|nonzero
condition|)
name|x
operator|=
name|varop
expr_stmt|;
else|else
block|{
comment|/* Otherwise, return an AND.  */
name|constop
operator|=
name|trunc_int_for_mode
argument_list|(
name|constop
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* See how much, if any, of X we can use.  */
if|if
condition|(
name|x
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|AND
operator|||
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|mode
condition|)
name|x
operator|=
name|gen_binary
argument_list|(
name|AND
argument_list|,
name|mode
argument_list|,
name|varop
argument_list|,
name|GEN_INT
argument_list|(
name|constop
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|||
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|constop
condition|)
name|SUBST
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|constop
argument_list|)
argument_list|)
expr_stmt|;
name|SUBST
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|varop
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|nonzero_bits_with_known
parameter_list|(
name|X
parameter_list|,
name|MODE
parameter_list|)
define|\
value|cached_nonzero_bits (X, MODE, known_x, known_mode, known_ret)
end_define

begin_comment
comment|/* The function cached_nonzero_bits is a wrapper around nonzero_bits1.    It avoids exponential behavior in nonzero_bits1 when X has    identical subexpressions on the first or the second level.  */
end_comment

begin_function
specifier|static
name|unsigned
name|HOST_WIDE_INT
name|cached_nonzero_bits
parameter_list|(
name|x
parameter_list|,
name|mode
parameter_list|,
name|known_x
parameter_list|,
name|known_mode
parameter_list|,
name|known_ret
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|known_x
decl_stmt|;
name|enum
name|machine_mode
name|known_mode
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|known_ret
decl_stmt|;
block|{
if|if
condition|(
name|x
operator|==
name|known_x
operator|&&
name|mode
operator|==
name|known_mode
condition|)
return|return
name|known_ret
return|;
comment|/* Try to find identical subexpressions.  If found call      nonzero_bits1 on X with the subexpressions as KNOWN_X and the      precomputed value for the subexpression as KNOWN_RET.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
literal|'2'
operator|||
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
literal|'c'
condition|)
block|{
name|rtx
name|x0
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|x1
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* Check the first level.  */
if|if
condition|(
name|x0
operator|==
name|x1
condition|)
return|return
name|nonzero_bits1
argument_list|(
name|x
argument_list|,
name|mode
argument_list|,
name|x0
argument_list|,
name|mode
argument_list|,
name|nonzero_bits_with_known
argument_list|(
name|x0
argument_list|,
name|mode
argument_list|)
argument_list|)
return|;
comment|/* Check the second level.  */
if|if
condition|(
operator|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|x0
argument_list|)
argument_list|)
operator|==
literal|'2'
operator|||
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|x0
argument_list|)
argument_list|)
operator|==
literal|'c'
operator|)
operator|&&
operator|(
name|x1
operator|==
name|XEXP
argument_list|(
name|x0
argument_list|,
literal|0
argument_list|)
operator|||
name|x1
operator|==
name|XEXP
argument_list|(
name|x0
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
return|return
name|nonzero_bits1
argument_list|(
name|x
argument_list|,
name|mode
argument_list|,
name|x1
argument_list|,
name|mode
argument_list|,
name|nonzero_bits_with_known
argument_list|(
name|x1
argument_list|,
name|mode
argument_list|)
argument_list|)
return|;
if|if
condition|(
operator|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|x1
argument_list|)
argument_list|)
operator|==
literal|'2'
operator|||
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|x1
argument_list|)
argument_list|)
operator|==
literal|'c'
operator|)
operator|&&
operator|(
name|x0
operator|==
name|XEXP
argument_list|(
name|x1
argument_list|,
literal|0
argument_list|)
operator|||
name|x0
operator|==
name|XEXP
argument_list|(
name|x1
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
return|return
name|nonzero_bits1
argument_list|(
name|x
argument_list|,
name|mode
argument_list|,
name|x0
argument_list|,
name|mode
argument_list|,
name|nonzero_bits_with_known
argument_list|(
name|x0
argument_list|,
name|mode
argument_list|)
argument_list|)
return|;
block|}
return|return
name|nonzero_bits1
argument_list|(
name|x
argument_list|,
name|mode
argument_list|,
name|known_x
argument_list|,
name|known_mode
argument_list|,
name|known_ret
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* We let num_sign_bit_copies recur into nonzero_bits as that is useful.    We don't let nonzero_bits recur into num_sign_bit_copies, because that    is less useful.  We can't allow both, because that results in exponential    run time recursion.  There is a nullstone testcase that triggered    this.  This macro avoids accidental uses of num_sign_bit_copies.  */
end_comment

begin_define
define|#
directive|define
name|cached_num_sign_bit_copies
parameter_list|()
end_define

begin_comment
comment|/* Given an expression, X, compute which bits in X can be nonzero.    We don't care about bits outside of those defined in MODE.     For most X this is simply GET_MODE_MASK (GET_MODE (MODE)), but if X is    a shift, AND, or zero_extract, we can do better.  */
end_comment

begin_function
specifier|static
name|unsigned
name|HOST_WIDE_INT
name|nonzero_bits1
parameter_list|(
name|x
parameter_list|,
name|mode
parameter_list|,
name|known_x
parameter_list|,
name|known_mode
parameter_list|,
name|known_ret
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|known_x
decl_stmt|;
name|enum
name|machine_mode
name|known_mode
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|known_ret
decl_stmt|;
block|{
name|unsigned
name|HOST_WIDE_INT
name|nonzero
init|=
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|inner_nz
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|unsigned
name|int
name|mode_width
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
comment|/* For floating-point values, assume all bits are needed.  */
if|if
condition|(
name|FLOAT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|||
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|nonzero
return|;
comment|/* If X is wider than MODE, use its mode instead.  */
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|>
name|mode_width
condition|)
block|{
name|mode
operator|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|nonzero
operator|=
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|mode_width
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mode_width
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
comment|/* Our only callers in this case look for single bit values.  So        just return the mode mask.  Those tests will then be false.  */
return|return
name|nonzero
return|;
ifndef|#
directive|ifndef
name|WORD_REGISTER_OPERATIONS
comment|/* If MODE is wider than X, but both are a single word for both the host      and target machines, we can compute this from which bits of the      object might be nonzero in its own mode, taking into account the fact      that on many CISC machines, accessing an object in a wider mode      causes the high-order bits to become undefined.  So they are      not known to be zero.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|mode
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<=
name|BITS_PER_WORD
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|>
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
name|nonzero
operator|&=
name|nonzero_bits_with_known
argument_list|(
name|x
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|nonzero
operator||=
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|&
operator|~
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|nonzero
return|;
block|}
endif|#
directive|endif
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
if|#
directive|if
name|defined
argument_list|(
name|POINTERS_EXTEND_UNSIGNED
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAVE_ptr_extend
argument_list|)
comment|/* If pointers extend unsigned and this is a pointer in Pmode, say that 	 all the bits above ptr_mode are known to be zero.  */
if|if
condition|(
name|POINTERS_EXTEND_UNSIGNED
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|Pmode
operator|&&
name|REG_POINTER
argument_list|(
name|x
argument_list|)
condition|)
name|nonzero
operator|&=
name|GET_MODE_MASK
argument_list|(
name|ptr_mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Include declared information about alignment of pointers.  */
comment|/* ??? We don't properly preserve REG_POINTER changes across 	 pointer-to-integer casts, so we can't trust it except for 	 things that we know must be pointers.  See execute/960116-1.c.  */
if|if
condition|(
operator|(
name|x
operator|==
name|stack_pointer_rtx
operator|||
name|x
operator|==
name|frame_pointer_rtx
operator|||
name|x
operator|==
name|arg_pointer_rtx
operator|)
operator|&&
name|REGNO_POINTER_ALIGN
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|alignment
init|=
name|REGNO_POINTER_ALIGN
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
decl_stmt|;
ifdef|#
directive|ifdef
name|PUSH_ROUNDING
comment|/* If PUSH_ROUNDING is defined, it is possible for the 	     stack to be momentarily aligned only to that amount, 	     so we pick the least alignment.  */
if|if
condition|(
name|x
operator|==
name|stack_pointer_rtx
operator|&&
name|PUSH_ARGS
condition|)
name|alignment
operator|=
name|MIN
argument_list|(
name|PUSH_ROUNDING
argument_list|(
literal|1
argument_list|)
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|nonzero
operator|&=
operator|~
operator|(
name|alignment
operator|-
literal|1
operator|)
expr_stmt|;
block|}
comment|/* If X is a register whose nonzero bits value is current, use it. 	 Otherwise, if X is a register whose value we can find, use that 	 value.  Otherwise, use the previously-computed global nonzero bits 	 for this register.  */
if|if
condition|(
name|reg_last_set_value
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
operator|!=
literal|0
operator|&&
operator|(
name|reg_last_set_mode
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
operator|==
name|mode
operator|||
operator|(
name|GET_MODE_CLASS
argument_list|(
name|reg_last_set_mode
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|)
operator|)
operator|&&
operator|(
name|reg_last_set_label
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
operator|==
name|label_tick
operator|||
operator|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|REG_N_SETS
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
literal|1
operator|&&
operator|!
name|REGNO_REG_SET_P
argument_list|(
name|ENTRY_BLOCK_PTR
operator|->
name|next_bb
operator|->
name|global_live_at_start
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
operator|)
operator|&&
name|INSN_CUID
argument_list|(
name|reg_last_set
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|)
operator|<
name|subst_low_cuid
condition|)
return|return
name|reg_last_set_nonzero_bits
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
operator|&
name|nonzero
return|;
name|tem
operator|=
name|get_last_value
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
block|{
ifdef|#
directive|ifdef
name|SHORT_IMMEDIATES_SIGN_EXTEND
comment|/* If X is narrower than MODE and TEM is a non-negative 	     constant that would appear negative in the mode of X, 	     sign-extend it for use in reg_nonzero_bits because some 	     machines (maybe most) will actually do the sign-extension 	     and this is the conservative approach.  	     ??? For 2.5, try to tighten up the MD files in this regard 	     instead of this kludge.  */
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<
name|mode_width
operator|&&
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|tem
argument_list|)
operator|>
literal|0
operator|&&
literal|0
operator|!=
operator|(
name|INTVAL
argument_list|(
name|tem
argument_list|)
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
name|tem
operator|=
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|tem
argument_list|)
operator||
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|nonzero_bits_with_known
argument_list|(
name|tem
argument_list|,
name|mode
argument_list|)
operator|&
name|nonzero
return|;
block|}
elseif|else
if|if
condition|(
name|nonzero_sign_valid
operator|&&
name|reg_nonzero_bits
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|mask
init|=
name|reg_nonzero_bits
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<
name|mode_width
condition|)
comment|/* We don't know anything about the upper bits.  */
name|mask
operator||=
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|^
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|nonzero
operator|&
name|mask
return|;
block|}
else|else
return|return
name|nonzero
return|;
case|case
name|CONST_INT
case|:
ifdef|#
directive|ifdef
name|SHORT_IMMEDIATES_SIGN_EXTEND
comment|/* If X is negative in MODE, sign-extend the value.  */
if|if
condition|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|>
literal|0
operator|&&
name|mode_width
operator|<
name|BITS_PER_WORD
operator|&&
literal|0
operator|!=
operator|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|mode_width
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
return|return
operator|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator||
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
name|mode_width
operator|)
operator|)
return|;
endif|#
directive|endif
return|return
name|INTVAL
argument_list|(
name|x
argument_list|)
return|;
case|case
name|MEM
case|:
ifdef|#
directive|ifdef
name|LOAD_EXTEND_OP
comment|/* In many, if not most, RISC machines, reading a byte from memory 	 zeros the rest of the register.  Noticing that fact saves a lot 	 of extra zero-extends.  */
if|if
condition|(
name|LOAD_EXTEND_OP
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|ZERO_EXTEND
condition|)
name|nonzero
operator|&=
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|EQ
case|:
case|case
name|NE
case|:
case|case
name|UNEQ
case|:
case|case
name|LTGT
case|:
case|case
name|GT
case|:
case|case
name|GTU
case|:
case|case
name|UNGT
case|:
case|case
name|LT
case|:
case|case
name|LTU
case|:
case|case
name|UNLT
case|:
case|case
name|GE
case|:
case|case
name|GEU
case|:
case|case
name|UNGE
case|:
case|case
name|LE
case|:
case|case
name|LEU
case|:
case|case
name|UNLE
case|:
case|case
name|UNORDERED
case|:
case|case
name|ORDERED
case|:
comment|/* If this produces an integer result, we know which bits are set. 	 Code here used to clear bits outside the mode of X, but that is 	 now done above.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|mode_width
operator|<=
name|HOST_BITS_PER_WIDE_INT
condition|)
name|nonzero
operator|=
name|STORE_FLAG_VALUE
expr_stmt|;
break|break;
case|case
name|NEG
case|:
if|#
directive|if
literal|0
comment|/* Disabled to avoid exponential mutual recursion between nonzero_bits 	 and num_sign_bit_copies.  */
block|if (num_sign_bit_copies (XEXP (x, 0), GET_MODE (x)) 	  == GET_MODE_BITSIZE (GET_MODE (x))) 	nonzero = 1;
endif|#
directive|endif
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<
name|mode_width
condition|)
name|nonzero
operator||=
operator|(
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|&
operator|~
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
expr_stmt|;
break|break;
case|case
name|ABS
case|:
if|#
directive|if
literal|0
comment|/* Disabled to avoid exponential mutual recursion between nonzero_bits 	 and num_sign_bit_copies.  */
block|if (num_sign_bit_copies (XEXP (x, 0), GET_MODE (x)) 	  == GET_MODE_BITSIZE (GET_MODE (x))) 	nonzero = 1;
endif|#
directive|endif
break|break;
case|case
name|TRUNCATE
case|:
name|nonzero
operator|&=
operator|(
name|nonzero_bits_with_known
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|&
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|)
expr_stmt|;
break|break;
case|case
name|ZERO_EXTEND
case|:
name|nonzero
operator|&=
name|nonzero_bits_with_known
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|VOIDmode
condition|)
name|nonzero
operator|&=
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIGN_EXTEND
case|:
comment|/* If the sign bit is known clear, this is the same as ZERO_EXTEND. 	 Otherwise, show all the bits in the outer mode but not the inner 	 may be nonzero.  */
name|inner_nz
operator|=
name|nonzero_bits_with_known
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|VOIDmode
condition|)
block|{
name|inner_nz
operator|&=
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inner_nz
operator|&
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
name|inner_nz
operator||=
operator|(
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|&
operator|~
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
name|nonzero
operator|&=
name|inner_nz
expr_stmt|;
break|break;
case|case
name|AND
case|:
name|nonzero
operator|&=
operator|(
name|nonzero_bits_with_known
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|&
name|nonzero_bits_with_known
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|)
expr_stmt|;
break|break;
case|case
name|XOR
case|:
case|case
name|IOR
case|:
case|case
name|UMIN
case|:
case|case
name|UMAX
case|:
case|case
name|SMIN
case|:
case|case
name|SMAX
case|:
block|{
name|unsigned
name|HOST_WIDE_INT
name|nonzero0
init|=
name|nonzero_bits_with_known
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
decl_stmt|;
comment|/* Don't call nonzero_bits for the second time if it cannot change 	   anything.  */
if|if
condition|(
operator|(
name|nonzero
operator|&
name|nonzero0
operator|)
operator|!=
name|nonzero
condition|)
name|nonzero
operator|&=
operator|(
name|nonzero0
operator||
name|nonzero_bits_with_known
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
case|case
name|MULT
case|:
case|case
name|DIV
case|:
case|case
name|UDIV
case|:
case|case
name|MOD
case|:
case|case
name|UMOD
case|:
comment|/* We can apply the rules of arithmetic to compute the number of 	 high- and low-order zero bits of these operations.  We start by 	 computing the width (position of the highest-order nonzero bit) 	 and the number of low-order zero bits for each value.  */
block|{
name|unsigned
name|HOST_WIDE_INT
name|nz0
init|=
name|nonzero_bits_with_known
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|nz1
init|=
name|nonzero_bits_with_known
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mode
argument_list|)
decl_stmt|;
name|int
name|width0
init|=
name|floor_log2
argument_list|(
name|nz0
argument_list|)
operator|+
literal|1
decl_stmt|;
name|int
name|width1
init|=
name|floor_log2
argument_list|(
name|nz1
argument_list|)
operator|+
literal|1
decl_stmt|;
name|int
name|low0
init|=
name|floor_log2
argument_list|(
name|nz0
operator|&
operator|-
name|nz0
argument_list|)
decl_stmt|;
name|int
name|low1
init|=
name|floor_log2
argument_list|(
name|nz1
operator|&
operator|-
name|nz1
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|op0_maybe_minusp
init|=
operator|(
name|nz0
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|mode_width
operator|-
literal|1
operator|)
operator|)
operator|)
decl_stmt|;
name|HOST_WIDE_INT
name|op1_maybe_minusp
init|=
operator|(
name|nz1
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|mode_width
operator|-
literal|1
operator|)
operator|)
operator|)
decl_stmt|;
name|unsigned
name|int
name|result_width
init|=
name|mode_width
decl_stmt|;
name|int
name|result_low
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS
case|:
name|result_width
operator|=
name|MAX
argument_list|(
name|width0
argument_list|,
name|width1
argument_list|)
operator|+
literal|1
expr_stmt|;
name|result_low
operator|=
name|MIN
argument_list|(
name|low0
argument_list|,
name|low1
argument_list|)
expr_stmt|;
break|break;
case|case
name|MINUS
case|:
name|result_low
operator|=
name|MIN
argument_list|(
name|low0
argument_list|,
name|low1
argument_list|)
expr_stmt|;
break|break;
case|case
name|MULT
case|:
name|result_width
operator|=
name|width0
operator|+
name|width1
expr_stmt|;
name|result_low
operator|=
name|low0
operator|+
name|low1
expr_stmt|;
break|break;
case|case
name|DIV
case|:
if|if
condition|(
name|width1
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|!
name|op0_maybe_minusp
operator|&&
operator|!
name|op1_maybe_minusp
condition|)
name|result_width
operator|=
name|width0
expr_stmt|;
break|break;
case|case
name|UDIV
case|:
if|if
condition|(
name|width1
operator|==
literal|0
condition|)
break|break;
name|result_width
operator|=
name|width0
expr_stmt|;
break|break;
case|case
name|MOD
case|:
if|if
condition|(
name|width1
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|!
name|op0_maybe_minusp
operator|&&
operator|!
name|op1_maybe_minusp
condition|)
name|result_width
operator|=
name|MIN
argument_list|(
name|width0
argument_list|,
name|width1
argument_list|)
expr_stmt|;
name|result_low
operator|=
name|MIN
argument_list|(
name|low0
argument_list|,
name|low1
argument_list|)
expr_stmt|;
break|break;
case|case
name|UMOD
case|:
if|if
condition|(
name|width1
operator|==
literal|0
condition|)
break|break;
name|result_width
operator|=
name|MIN
argument_list|(
name|width0
argument_list|,
name|width1
argument_list|)
expr_stmt|;
name|result_low
operator|=
name|MIN
argument_list|(
name|low0
argument_list|,
name|low1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|result_width
operator|<
name|mode_width
condition|)
name|nonzero
operator|&=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|result_width
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|result_low
operator|>
literal|0
condition|)
name|nonzero
operator|&=
operator|~
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|result_low
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|POINTERS_EXTEND_UNSIGNED
comment|/* If pointers extend unsigned and this is an addition or subtraction 	   to a pointer in Pmode, all the bits above ptr_mode are known to be 	   zero.  */
if|if
condition|(
name|POINTERS_EXTEND_UNSIGNED
operator|>
literal|0
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|Pmode
operator|&&
operator|(
name|code
operator|==
name|PLUS
operator|||
name|code
operator|==
name|MINUS
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REG_POINTER
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|nonzero
operator|&=
name|GET_MODE_MASK
argument_list|(
name|ptr_mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
break|break;
case|case
name|ZERO_EXTRACT
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
name|nonzero
operator|&=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|SUBREG
case|:
comment|/* If this is a SUBREG formed for a promoted variable that has 	 been zero-extended, we know that at least the high-order bits 	 are zero, though others might be too.  */
if|if
condition|(
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|x
argument_list|)
operator|&&
name|SUBREG_PROMOTED_UNSIGNED_P
argument_list|(
name|x
argument_list|)
operator|>
literal|0
condition|)
name|nonzero
operator|=
operator|(
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&
name|nonzero_bits_with_known
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
expr_stmt|;
comment|/* If the inner mode is a single word for both the host and target 	 machines, we can compute this from which bits of the inner 	 object might be nonzero.  */
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|<=
name|BITS_PER_WORD
operator|&&
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|)
condition|)
block|{
name|nonzero
operator|&=
name|nonzero_bits_with_known
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|WORD_REGISTER_OPERATIONS
argument_list|)
operator|&&
name|defined
argument_list|(
name|LOAD_EXTEND_OP
argument_list|)
comment|/* If this is a typical RISC machine, we only have to worry 	     about the way loads are extended.  */
if|if
condition|(
operator|(
name|LOAD_EXTEND_OP
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|==
name|SIGN_EXTEND
condition|?
operator|(
operator|(
operator|(
name|nonzero
operator|&
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|)
operator|)
operator|!=
literal|0
operator|)
operator|)
else|:
name|LOAD_EXTEND_OP
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|ZERO_EXTEND
operator|)
operator|||
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|MEM
condition|)
endif|#
directive|endif
block|{
comment|/* On many CISC machines, accessing an object in a wider mode 		 causes the high-order bits to become undefined.  So they are 		 not known to be zero.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
condition|)
name|nonzero
operator||=
operator|(
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&
operator|~
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|ASHIFTRT
case|:
case|case
name|LSHIFTRT
case|:
case|case
name|ASHIFT
case|:
case|case
name|ROTATE
case|:
comment|/* The nonzero bits are in two classes: any bits within MODE 	 that aren't in GET_MODE (x) are always significant.  The rest of the 	 nonzero bits are those that are significant in the operand of 	 the shift when shifted the appropriate number of bits.  This 	 shows that high-order bits are cleared by the right shift and 	 low-order bits by left shifts.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>=
literal|0
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|enum
name|machine_mode
name|inner_mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|width
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|inner_mode
argument_list|)
decl_stmt|;
name|int
name|count
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|mode_mask
init|=
name|GET_MODE_MASK
argument_list|(
name|inner_mode
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|op_nonzero
init|=
name|nonzero_bits_with_known
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|inner
init|=
name|op_nonzero
operator|&
name|mode_mask
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|outer
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|mode_width
operator|>
name|width
condition|)
name|outer
operator|=
operator|(
name|op_nonzero
operator|&
name|nonzero
operator|&
operator|~
name|mode_mask
operator|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|LSHIFTRT
condition|)
name|inner
operator|>>=
name|count
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|ASHIFTRT
condition|)
block|{
name|inner
operator|>>=
name|count
expr_stmt|;
comment|/* If the sign bit may have been nonzero before the shift, we 		 need to mark all the places it could have been copied to 		 by the shift as possibly nonzero.  */
if|if
condition|(
name|inner
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|width
operator|-
literal|1
operator|-
name|count
operator|)
operator|)
condition|)
name|inner
operator||=
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|count
operator|)
operator|-
literal|1
operator|)
operator|<<
operator|(
name|width
operator|-
name|count
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|ASHIFT
condition|)
name|inner
operator|<<=
name|count
expr_stmt|;
else|else
name|inner
operator|=
operator|(
operator|(
name|inner
operator|<<
operator|(
name|count
operator|%
name|width
operator|)
operator||
operator|(
name|inner
operator|>>
operator|(
name|width
operator|-
operator|(
name|count
operator|%
name|width
operator|)
operator|)
operator|)
operator|)
operator|&
name|mode_mask
operator|)
expr_stmt|;
name|nonzero
operator|&=
operator|(
name|outer
operator||
name|inner
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|FFS
case|:
comment|/* This is at most the number of bits in the mode.  */
name|nonzero
operator|=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|floor_log2
argument_list|(
name|mode_width
argument_list|)
operator|+
literal|1
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|IF_THEN_ELSE
case|:
name|nonzero
operator|&=
operator|(
name|nonzero_bits_with_known
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mode
argument_list|)
operator||
name|nonzero_bits_with_known
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|nonzero
return|;
block|}
end_function

begin_comment
comment|/* See the macro definition above.  */
end_comment

begin_undef
undef|#
directive|undef
name|cached_num_sign_bit_copies
end_undef

begin_escape
end_escape

begin_define
define|#
directive|define
name|num_sign_bit_copies_with_known
parameter_list|(
name|X
parameter_list|,
name|M
parameter_list|)
define|\
value|cached_num_sign_bit_copies (X, M, known_x, known_mode, known_ret)
end_define

begin_comment
comment|/* The function cached_num_sign_bit_copies is a wrapper around    num_sign_bit_copies1.  It avoids exponential behavior in    num_sign_bit_copies1 when X has identical subexpressions on the    first or the second level.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|cached_num_sign_bit_copies
parameter_list|(
name|x
parameter_list|,
name|mode
parameter_list|,
name|known_x
parameter_list|,
name|known_mode
parameter_list|,
name|known_ret
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|known_x
decl_stmt|;
name|enum
name|machine_mode
name|known_mode
decl_stmt|;
name|unsigned
name|int
name|known_ret
decl_stmt|;
block|{
if|if
condition|(
name|x
operator|==
name|known_x
operator|&&
name|mode
operator|==
name|known_mode
condition|)
return|return
name|known_ret
return|;
comment|/* Try to find identical subexpressions.  If found call      num_sign_bit_copies1 on X with the subexpressions as KNOWN_X and      the precomputed value for the subexpression as KNOWN_RET.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
literal|'2'
operator|||
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
literal|'c'
condition|)
block|{
name|rtx
name|x0
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|x1
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* Check the first level.  */
if|if
condition|(
name|x0
operator|==
name|x1
condition|)
return|return
name|num_sign_bit_copies1
argument_list|(
name|x
argument_list|,
name|mode
argument_list|,
name|x0
argument_list|,
name|mode
argument_list|,
name|num_sign_bit_copies_with_known
argument_list|(
name|x0
argument_list|,
name|mode
argument_list|)
argument_list|)
return|;
comment|/* Check the second level.  */
if|if
condition|(
operator|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|x0
argument_list|)
argument_list|)
operator|==
literal|'2'
operator|||
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|x0
argument_list|)
argument_list|)
operator|==
literal|'c'
operator|)
operator|&&
operator|(
name|x1
operator|==
name|XEXP
argument_list|(
name|x0
argument_list|,
literal|0
argument_list|)
operator|||
name|x1
operator|==
name|XEXP
argument_list|(
name|x0
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
return|return
name|num_sign_bit_copies1
argument_list|(
name|x
argument_list|,
name|mode
argument_list|,
name|x1
argument_list|,
name|mode
argument_list|,
name|num_sign_bit_copies_with_known
argument_list|(
name|x1
argument_list|,
name|mode
argument_list|)
argument_list|)
return|;
if|if
condition|(
operator|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|x1
argument_list|)
argument_list|)
operator|==
literal|'2'
operator|||
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|x1
argument_list|)
argument_list|)
operator|==
literal|'c'
operator|)
operator|&&
operator|(
name|x0
operator|==
name|XEXP
argument_list|(
name|x1
argument_list|,
literal|0
argument_list|)
operator|||
name|x0
operator|==
name|XEXP
argument_list|(
name|x1
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
return|return
name|num_sign_bit_copies1
argument_list|(
name|x
argument_list|,
name|mode
argument_list|,
name|x0
argument_list|,
name|mode
argument_list|,
name|num_sign_bit_copies_with_known
argument_list|(
name|x0
argument_list|,
name|mode
argument_list|)
argument_list|)
return|;
block|}
return|return
name|num_sign_bit_copies1
argument_list|(
name|x
argument_list|,
name|mode
argument_list|,
name|known_x
argument_list|,
name|known_mode
argument_list|,
name|known_ret
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the number of bits at the high-order end of X that are known to    be equal to the sign bit.  X will be used in mode MODE; if MODE is    VOIDmode, X will be used in its own mode.  The returned value  will always    be between 1 and the number of bits in MODE.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|num_sign_bit_copies1
parameter_list|(
name|x
parameter_list|,
name|mode
parameter_list|,
name|known_x
parameter_list|,
name|known_mode
parameter_list|,
name|known_ret
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|known_x
decl_stmt|;
name|enum
name|machine_mode
name|known_mode
decl_stmt|;
name|unsigned
name|int
name|known_ret
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|bitwidth
decl_stmt|;
name|int
name|num0
decl_stmt|,
name|num1
decl_stmt|,
name|result
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|nonzero
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
comment|/* If we weren't given a mode, use the mode of X.  If the mode is still      VOIDmode, we don't know anything.  Likewise if one of the modes is      floating-point.  */
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|mode
operator|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
operator|||
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
operator|||
name|FLOAT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
name|bitwidth
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* For a smaller object, just ignore the high bits.  */
if|if
condition|(
name|bitwidth
operator|<
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
name|num0
operator|=
name|num_sign_bit_copies_with_known
argument_list|(
name|x
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|MAX
argument_list|(
literal|1
argument_list|,
name|num0
operator|-
call|(
name|int
call|)
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|-
name|bitwidth
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|bitwidth
operator|>
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|WORD_REGISTER_OPERATIONS
comment|/* If this machine does not do all register operations on the entire      register and MODE is wider than the mode of X, we can say nothing      at all about the high-order bits.  */
return|return
literal|1
return|;
else|#
directive|else
comment|/* Likewise on machines that do, if the mode of the object is smaller 	 than a word and loads of that size don't sign extend, we can say 	 nothing about the high order bits.  */
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<
name|BITS_PER_WORD
ifdef|#
directive|ifdef
name|LOAD_EXTEND_OP
operator|&&
name|LOAD_EXTEND_OP
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|SIGN_EXTEND
endif|#
directive|endif
condition|)
return|return
literal|1
return|;
endif|#
directive|endif
block|}
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
if|#
directive|if
name|defined
argument_list|(
name|POINTERS_EXTEND_UNSIGNED
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAVE_ptr_extend
argument_list|)
comment|/* If pointers extend signed and this is a pointer in Pmode, say that 	 all the bits above ptr_mode are known to be sign bit copies.  */
if|if
condition|(
operator|!
name|POINTERS_EXTEND_UNSIGNED
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|Pmode
operator|&&
name|mode
operator|==
name|Pmode
operator|&&
name|REG_POINTER
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|GET_MODE_BITSIZE
argument_list|(
name|Pmode
argument_list|)
operator|-
name|GET_MODE_BITSIZE
argument_list|(
name|ptr_mode
argument_list|)
operator|+
literal|1
return|;
endif|#
directive|endif
if|if
condition|(
name|reg_last_set_value
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
operator|!=
literal|0
operator|&&
name|reg_last_set_mode
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
operator|==
name|mode
operator|&&
operator|(
name|reg_last_set_label
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
operator|==
name|label_tick
operator|||
operator|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|REG_N_SETS
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
literal|1
operator|&&
operator|!
name|REGNO_REG_SET_P
argument_list|(
name|ENTRY_BLOCK_PTR
operator|->
name|next_bb
operator|->
name|global_live_at_start
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
operator|)
operator|&&
name|INSN_CUID
argument_list|(
name|reg_last_set
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|)
operator|<
name|subst_low_cuid
condition|)
return|return
name|reg_last_set_sign_bit_copies
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
return|;
name|tem
operator|=
name|get_last_value
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|!=
literal|0
condition|)
return|return
name|num_sign_bit_copies_with_known
argument_list|(
name|tem
argument_list|,
name|mode
argument_list|)
return|;
if|if
condition|(
name|nonzero_sign_valid
operator|&&
name|reg_sign_bit_copies
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
operator|!=
literal|0
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|bitwidth
condition|)
return|return
name|reg_sign_bit_copies
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
return|;
break|break;
case|case
name|MEM
case|:
ifdef|#
directive|ifdef
name|LOAD_EXTEND_OP
comment|/* Some RISC machines sign-extend all loads of smaller than a word.  */
if|if
condition|(
name|LOAD_EXTEND_OP
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|SIGN_EXTEND
condition|)
return|return
name|MAX
argument_list|(
literal|1
argument_list|,
operator|(
operator|(
name|int
operator|)
name|bitwidth
operator|-
operator|(
name|int
operator|)
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|+
literal|1
operator|)
argument_list|)
return|;
endif|#
directive|endif
break|break;
case|case
name|CONST_INT
case|:
comment|/* If the constant is negative, take its 1's complement and remask. 	 Then see how many zero bits we have.  */
name|nonzero
operator|=
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitwidth
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
name|nonzero
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|bitwidth
operator|-
literal|1
operator|)
operator|)
operator|)
operator|!=
literal|0
condition|)
name|nonzero
operator|=
operator|(
operator|~
name|nonzero
operator|)
operator|&
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
expr_stmt|;
return|return
operator|(
name|nonzero
operator|==
literal|0
condition|?
name|bitwidth
else|:
name|bitwidth
operator|-
name|floor_log2
argument_list|(
name|nonzero
argument_list|)
operator|-
literal|1
operator|)
return|;
case|case
name|SUBREG
case|:
comment|/* If this is a SUBREG for a promoted object that is sign-extended 	 and we are looking at it in a wider mode, we know that at least the 	 high-order bits are known to be sign bit copies.  */
if|if
condition|(
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|SUBREG_PROMOTED_UNSIGNED_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|num0
operator|=
name|num_sign_bit_copies_with_known
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
name|MAX
argument_list|(
operator|(
name|int
operator|)
name|bitwidth
operator|-
operator|(
name|int
operator|)
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|+
literal|1
argument_list|,
name|num0
argument_list|)
return|;
block|}
comment|/* For a smaller object, just ignore the high bits.  */
if|if
condition|(
name|bitwidth
operator|<=
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|num0
operator|=
name|num_sign_bit_copies_with_known
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
return|return
name|MAX
argument_list|(
literal|1
argument_list|,
operator|(
name|num0
operator|-
call|(
name|int
call|)
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|-
name|bitwidth
argument_list|)
operator|)
argument_list|)
return|;
block|}
ifdef|#
directive|ifdef
name|WORD_REGISTER_OPERATIONS
ifdef|#
directive|ifdef
name|LOAD_EXTEND_OP
comment|/* For paradoxical SUBREGs on machines where all register operations 	 affect the entire register, just look inside.  Note that we are 	 passing MODE to the recursive call, so the number of sign bit copies 	 will remain relative to that mode, not the inner mode.  */
comment|/* This works only if loads sign extend.  Otherwise, if we get a 	 reload for the inner part, it may be loaded from the stack, and 	 then we lose all sign bit copies that existed before the store 	 to the stack.  */
if|if
condition|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
name|LOAD_EXTEND_OP
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|==
name|SIGN_EXTEND
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
return|return
name|num_sign_bit_copies_with_known
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
name|mode
argument_list|)
return|;
endif|#
directive|endif
endif|#
directive|endif
break|break;
case|case
name|SIGN_EXTRACT
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|MAX
argument_list|(
literal|1
argument_list|,
operator|(
name|int
operator|)
name|bitwidth
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|SIGN_EXTEND
case|:
return|return
operator|(
name|bitwidth
operator|-
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|+
name|num_sign_bit_copies_with_known
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
operator|)
return|;
case|case
name|TRUNCATE
case|:
comment|/* For a smaller object, just ignore the high bits.  */
name|num0
operator|=
name|num_sign_bit_copies_with_known
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
return|return
name|MAX
argument_list|(
literal|1
argument_list|,
operator|(
name|num0
operator|-
call|(
name|int
call|)
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|-
name|bitwidth
argument_list|)
operator|)
argument_list|)
return|;
case|case
name|NOT
case|:
return|return
name|num_sign_bit_copies_with_known
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
return|;
case|case
name|ROTATE
case|:
case|case
name|ROTATERT
case|:
comment|/* If we are rotating left by a number of bits less than the number 	 of sign bit copies, we can just subtract that amount from the 	 number.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>=
literal|0
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
operator|(
name|int
operator|)
name|bitwidth
condition|)
block|{
name|num0
operator|=
name|num_sign_bit_copies_with_known
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
name|MAX
argument_list|(
literal|1
argument_list|,
name|num0
operator|-
operator|(
name|code
operator|==
name|ROTATE
condition|?
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
else|:
operator|(
name|int
operator|)
name|bitwidth
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
argument_list|)
return|;
block|}
break|break;
case|case
name|NEG
case|:
comment|/* In general, this subtracts one sign bit copy.  But if the value 	 is known to be positive, the number of sign bit copies is the 	 same as that of the input.  Finally, if the input has just one bit 	 that might be nonzero, all the bits are copies of the sign bit.  */
name|num0
operator|=
name|num_sign_bit_copies_with_known
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitwidth
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
return|return
name|num0
operator|>
literal|1
condition|?
name|num0
operator|-
literal|1
else|:
literal|1
return|;
name|nonzero
operator|=
name|nonzero_bits
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|nonzero
operator|==
literal|1
condition|)
return|return
name|bitwidth
return|;
if|if
condition|(
name|num0
operator|>
literal|1
operator|&&
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|bitwidth
operator|-
literal|1
operator|)
operator|)
operator|&
name|nonzero
operator|)
condition|)
name|num0
operator|--
expr_stmt|;
return|return
name|num0
return|;
case|case
name|IOR
case|:
case|case
name|AND
case|:
case|case
name|XOR
case|:
case|case
name|SMIN
case|:
case|case
name|SMAX
case|:
case|case
name|UMIN
case|:
case|case
name|UMAX
case|:
comment|/* Logical operations will preserve the number of sign-bit copies. 	 MIN and MAX operations always return one of the operands.  */
name|num0
operator|=
name|num_sign_bit_copies_with_known
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|num1
operator|=
name|num_sign_bit_copies_with_known
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
name|MIN
argument_list|(
name|num0
argument_list|,
name|num1
argument_list|)
return|;
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
comment|/* For addition and subtraction, we can have a 1-bit carry.  However, 	 if we are subtracting 1 from a positive number, there will not 	 be such a carry.  Furthermore, if the positive number is known to 	 be 0 or 1, we know the result is either -1 or 0.  */
if|if
condition|(
name|code
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|constm1_rtx
operator|&&
name|bitwidth
operator|<=
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|nonzero
operator|=
name|nonzero_bits
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|bitwidth
operator|-
literal|1
operator|)
operator|)
operator|&
name|nonzero
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|nonzero
operator|==
literal|1
operator|||
name|nonzero
operator|==
literal|0
condition|?
name|bitwidth
else|:
name|bitwidth
operator|-
name|floor_log2
argument_list|(
name|nonzero
argument_list|)
operator|-
literal|1
operator|)
return|;
block|}
name|num0
operator|=
name|num_sign_bit_copies_with_known
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|num1
operator|=
name|num_sign_bit_copies_with_known
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|result
operator|=
name|MAX
argument_list|(
literal|1
argument_list|,
name|MIN
argument_list|(
name|num0
argument_list|,
name|num1
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|POINTERS_EXTEND_UNSIGNED
comment|/* If pointers extend signed and this is an addition or subtraction 	 to a pointer in Pmode, all the bits above ptr_mode are known to be 	 sign bit copies.  */
if|if
condition|(
operator|!
name|POINTERS_EXTEND_UNSIGNED
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|Pmode
operator|&&
operator|(
name|code
operator|==
name|PLUS
operator|||
name|code
operator|==
name|MINUS
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REG_POINTER
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|result
operator|=
name|MAX
argument_list|(
call|(
name|int
call|)
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|Pmode
argument_list|)
operator|-
name|GET_MODE_BITSIZE
argument_list|(
name|ptr_mode
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|,
name|result
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|result
return|;
case|case
name|MULT
case|:
comment|/* The number of bits of the product is the sum of the number of 	 bits of both terms.  However, unless one of the terms if known 	 to be positive, we must allow for an additional bit since negating 	 a negative number can remove one sign bit copy.  */
name|num0
operator|=
name|num_sign_bit_copies_with_known
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|num1
operator|=
name|num_sign_bit_copies_with_known
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|result
operator|=
name|bitwidth
operator|-
operator|(
name|bitwidth
operator|-
name|num0
operator|)
operator|-
operator|(
name|bitwidth
operator|-
name|num1
operator|)
expr_stmt|;
if|if
condition|(
name|result
operator|>
literal|0
operator|&&
operator|(
name|bitwidth
operator|>
name|HOST_BITS_PER_WIDE_INT
operator|||
operator|(
operator|(
operator|(
name|nonzero_bits
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|bitwidth
operator|-
literal|1
operator|)
operator|)
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|nonzero_bits
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|bitwidth
operator|-
literal|1
operator|)
operator|)
operator|)
operator|!=
literal|0
operator|)
operator|)
operator|)
condition|)
name|result
operator|--
expr_stmt|;
return|return
name|MAX
argument_list|(
literal|1
argument_list|,
name|result
argument_list|)
return|;
case|case
name|UDIV
case|:
comment|/* The result must be<= the first operand.  If the first operand          has the high bit set, we know nothing about the number of sign          bit copies.  */
if|if
condition|(
name|bitwidth
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
operator|(
name|nonzero_bits
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|bitwidth
operator|-
literal|1
operator|)
operator|)
operator|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
else|else
return|return
name|num_sign_bit_copies_with_known
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
return|;
case|case
name|UMOD
case|:
comment|/* The result must be<= the second operand.  */
return|return
name|num_sign_bit_copies_with_known
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mode
argument_list|)
return|;
case|case
name|DIV
case|:
comment|/* Similar to unsigned division, except that we have to worry about 	 the case where the divisor is negative, in which case we have 	 to add 1.  */
name|result
operator|=
name|num_sign_bit_copies_with_known
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|>
literal|1
operator|&&
operator|(
name|bitwidth
operator|>
name|HOST_BITS_PER_WIDE_INT
operator|||
operator|(
name|nonzero_bits
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|bitwidth
operator|-
literal|1
operator|)
operator|)
operator|)
operator|!=
literal|0
operator|)
condition|)
name|result
operator|--
expr_stmt|;
return|return
name|result
return|;
case|case
name|MOD
case|:
name|result
operator|=
name|num_sign_bit_copies_with_known
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|>
literal|1
operator|&&
operator|(
name|bitwidth
operator|>
name|HOST_BITS_PER_WIDE_INT
operator|||
operator|(
name|nonzero_bits
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|bitwidth
operator|-
literal|1
operator|)
operator|)
operator|)
operator|!=
literal|0
operator|)
condition|)
name|result
operator|--
expr_stmt|;
return|return
name|result
return|;
case|case
name|ASHIFTRT
case|:
comment|/* Shifts by a constant add to the number of bits equal to the 	 sign bit.  */
name|num0
operator|=
name|num_sign_bit_copies_with_known
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>
literal|0
condition|)
name|num0
operator|=
name|MIN
argument_list|(
operator|(
name|int
operator|)
name|bitwidth
argument_list|,
name|num0
operator|+
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|num0
return|;
case|case
name|ASHIFT
case|:
comment|/* Left shifts destroy copies.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
literal|0
operator|||
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>=
operator|(
name|int
operator|)
name|bitwidth
condition|)
return|return
literal|1
return|;
name|num0
operator|=
name|num_sign_bit_copies_with_known
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
name|MAX
argument_list|(
literal|1
argument_list|,
name|num0
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|IF_THEN_ELSE
case|:
name|num0
operator|=
name|num_sign_bit_copies_with_known
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|num1
operator|=
name|num_sign_bit_copies_with_known
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
name|MIN
argument_list|(
name|num0
argument_list|,
name|num1
argument_list|)
return|;
case|case
name|EQ
case|:
case|case
name|NE
case|:
case|case
name|GE
case|:
case|case
name|GT
case|:
case|case
name|LE
case|:
case|case
name|LT
case|:
case|case
name|UNEQ
case|:
case|case
name|LTGT
case|:
case|case
name|UNGE
case|:
case|case
name|UNGT
case|:
case|case
name|UNLE
case|:
case|case
name|UNLT
case|:
case|case
name|GEU
case|:
case|case
name|GTU
case|:
case|case
name|LEU
case|:
case|case
name|LTU
case|:
case|case
name|UNORDERED
case|:
case|case
name|ORDERED
case|:
comment|/* If the constant is negative, take its 1's complement and remask. 	 Then see how many zero bits we have.  */
name|nonzero
operator|=
name|STORE_FLAG_VALUE
expr_stmt|;
if|if
condition|(
name|bitwidth
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
name|nonzero
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|bitwidth
operator|-
literal|1
operator|)
operator|)
operator|)
operator|!=
literal|0
condition|)
name|nonzero
operator|=
operator|(
operator|~
name|nonzero
operator|)
operator|&
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
expr_stmt|;
return|return
operator|(
name|nonzero
operator|==
literal|0
condition|?
name|bitwidth
else|:
name|bitwidth
operator|-
name|floor_log2
argument_list|(
name|nonzero
argument_list|)
operator|-
literal|1
operator|)
return|;
break|break;
default|default:
break|break;
block|}
comment|/* If we haven't been able to figure it out by one of the above rules,      see if some of the high-order bits are known to be zero.  If so,      count those bits and return one less than that amount.  If we can't      safely compute the mask for this mode, always return BITWIDTH.  */
if|if
condition|(
name|bitwidth
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
return|return
literal|1
return|;
name|nonzero
operator|=
name|nonzero_bits
argument_list|(
name|x
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
operator|(
name|nonzero
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|bitwidth
operator|-
literal|1
operator|)
operator|)
condition|?
literal|1
else|:
name|bitwidth
operator|-
name|floor_log2
argument_list|(
name|nonzero
argument_list|)
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the number of "extended" bits there are in X, when interpreted    as a quantity in MODE whose signedness is indicated by UNSIGNEDP.  For    unsigned quantities, this is the number of high-order zero bits.    For signed quantities, this is the number of copies of the sign bit    minus 1.  In both case, this function returns the number of "spare"    bits.  For example, if two quantities for which this function returns    at least 1 are added, the addition is known not to overflow.     This function will always return 0 unless called during combine, which    implies that it must be called from a define_split.  */
end_comment

begin_function
name|unsigned
name|int
name|extended_count
parameter_list|(
name|x
parameter_list|,
name|mode
parameter_list|,
name|unsignedp
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
if|if
condition|(
name|nonzero_sign_valid
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|unsignedp
condition|?
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
condition|?
call|(
name|unsigned
name|int
call|)
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
operator|-
name|floor_log2
argument_list|(
name|nonzero_bits
argument_list|(
name|x
argument_list|,
name|mode
argument_list|)
argument_list|)
argument_list|)
else|:
literal|0
operator|)
else|:
name|num_sign_bit_copies
argument_list|(
name|x
argument_list|,
name|mode
argument_list|)
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This function is called from `simplify_shift_const' to merge two    outer operations.  Specifically, we have already found that we need    to perform operation *POP0 with constant *PCONST0 at the outermost    position.  We would now like to also perform OP1 with constant CONST1    (with *POP0 being done last).     Return 1 if we can do the operation and update *POP0 and *PCONST0 with    the resulting operation.  *PCOMP_P is set to 1 if we would need to    complement the innermost operand, otherwise it is unchanged.     MODE is the mode in which the operation will be done.  No bits outside    the width of this mode matter.  It is assumed that the width of this mode    is smaller than or equal to HOST_BITS_PER_WIDE_INT.     If *POP0 or OP1 are NIL, it means no operation is required.  Only NEG, PLUS,    IOR, XOR, and AND are supported.  We may set *POP0 to SET if the proper    result is simply *PCONST0.     If the resulting operation cannot be expressed as one operation, we    return 0 and do not change *POP0, *PCONST0, and *PCOMP_P.  */
end_comment

begin_function
specifier|static
name|int
name|merge_outer_ops
parameter_list|(
name|pop0
parameter_list|,
name|pconst0
parameter_list|,
name|op1
parameter_list|,
name|const1
parameter_list|,
name|mode
parameter_list|,
name|pcomp_p
parameter_list|)
name|enum
name|rtx_code
modifier|*
name|pop0
decl_stmt|;
name|HOST_WIDE_INT
modifier|*
name|pconst0
decl_stmt|;
name|enum
name|rtx_code
name|op1
decl_stmt|;
name|HOST_WIDE_INT
name|const1
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
modifier|*
name|pcomp_p
decl_stmt|;
block|{
name|enum
name|rtx_code
name|op0
init|=
operator|*
name|pop0
decl_stmt|;
name|HOST_WIDE_INT
name|const0
init|=
operator|*
name|pconst0
decl_stmt|;
name|const0
operator|&=
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|const1
operator|&=
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* If OP0 is an AND, clear unimportant bits in CONST1.  */
if|if
condition|(
name|op0
operator|==
name|AND
condition|)
name|const1
operator|&=
name|const0
expr_stmt|;
comment|/* If OP0 or OP1 is NIL, this is easy.  Similarly if they are the same or      if OP0 is SET.  */
if|if
condition|(
name|op1
operator|==
name|NIL
operator|||
name|op0
operator|==
name|SET
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|op0
operator|==
name|NIL
condition|)
name|op0
operator|=
name|op1
operator|,
name|const0
operator|=
name|const1
expr_stmt|;
elseif|else
if|if
condition|(
name|op0
operator|==
name|op1
condition|)
block|{
switch|switch
condition|(
name|op0
condition|)
block|{
case|case
name|AND
case|:
name|const0
operator|&=
name|const1
expr_stmt|;
break|break;
case|case
name|IOR
case|:
name|const0
operator||=
name|const1
expr_stmt|;
break|break;
case|case
name|XOR
case|:
name|const0
operator|^=
name|const1
expr_stmt|;
break|break;
case|case
name|PLUS
case|:
name|const0
operator|+=
name|const1
expr_stmt|;
break|break;
case|case
name|NEG
case|:
name|op0
operator|=
name|NIL
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
comment|/* Otherwise, if either is a PLUS or NEG, we can't do anything.  */
elseif|else
if|if
condition|(
name|op0
operator|==
name|PLUS
operator|||
name|op1
operator|==
name|PLUS
operator|||
name|op0
operator|==
name|NEG
operator|||
name|op1
operator|==
name|NEG
condition|)
return|return
literal|0
return|;
comment|/* If the two constants aren't the same, we can't do anything.  The      remaining six cases can all be done.  */
elseif|else
if|if
condition|(
name|const0
operator|!=
name|const1
condition|)
return|return
literal|0
return|;
else|else
switch|switch
condition|(
name|op0
condition|)
block|{
case|case
name|IOR
case|:
if|if
condition|(
name|op1
operator|==
name|AND
condition|)
comment|/* (a& b) | b == b */
name|op0
operator|=
name|SET
expr_stmt|;
else|else
comment|/* op1 == XOR */
comment|/* (a ^ b) | b == a | b */
block|{
empty_stmt|;
block|}
break|break;
case|case
name|XOR
case|:
if|if
condition|(
name|op1
operator|==
name|AND
condition|)
comment|/* (a& b) ^ b == (~a)& b */
name|op0
operator|=
name|AND
operator|,
operator|*
name|pcomp_p
operator|=
literal|1
expr_stmt|;
else|else
comment|/* op1 == IOR */
comment|/* (a | b) ^ b == a& ~b */
name|op0
operator|=
name|AND
operator|,
operator|*
name|pconst0
operator|=
operator|~
name|const0
expr_stmt|;
break|break;
case|case
name|AND
case|:
if|if
condition|(
name|op1
operator|==
name|IOR
condition|)
comment|/* (a | b)& b == b */
name|op0
operator|=
name|SET
expr_stmt|;
else|else
comment|/* op1 == XOR */
comment|/* (a ^ b)& b) == (~a)& b */
operator|*
name|pcomp_p
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* Check for NO-OP cases.  */
name|const0
operator|&=
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|const0
operator|==
literal|0
operator|&&
operator|(
name|op0
operator|==
name|IOR
operator|||
name|op0
operator|==
name|XOR
operator|||
name|op0
operator|==
name|PLUS
operator|)
condition|)
name|op0
operator|=
name|NIL
expr_stmt|;
elseif|else
if|if
condition|(
name|const0
operator|==
literal|0
operator|&&
name|op0
operator|==
name|AND
condition|)
name|op0
operator|=
name|SET
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|const0
operator|==
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|&&
name|op0
operator|==
name|AND
condition|)
name|op0
operator|=
name|NIL
expr_stmt|;
comment|/* ??? Slightly redundant with the above mask, but not entirely.      Moving this above means we'd have to sign-extend the mode mask      for the final test.  */
name|const0
operator|=
name|trunc_int_for_mode
argument_list|(
name|const0
argument_list|,
name|mode
argument_list|)
expr_stmt|;
operator|*
name|pop0
operator|=
name|op0
expr_stmt|;
operator|*
name|pconst0
operator|=
name|const0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Simplify a shift of VAROP by COUNT bits.  CODE says what kind of shift.    The result of the shift is RESULT_MODE.  X, if nonzero, is an expression    that we started with.     The shift is normally computed in the widest mode we find in VAROP, as    long as it isn't a different number of words than RESULT_MODE.  Exceptions    are ASHIFTRT and ROTATE, which are always done in their original mode,  */
end_comment

begin_function
specifier|static
name|rtx
name|simplify_shift_const
parameter_list|(
name|x
parameter_list|,
name|code
parameter_list|,
name|result_mode
parameter_list|,
name|varop
parameter_list|,
name|orig_count
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|enum
name|machine_mode
name|result_mode
decl_stmt|;
name|rtx
name|varop
decl_stmt|;
name|int
name|orig_count
decl_stmt|;
block|{
name|enum
name|rtx_code
name|orig_code
init|=
name|code
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
name|int
name|signed_count
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|result_mode
decl_stmt|;
name|enum
name|machine_mode
name|shift_mode
decl_stmt|,
name|tmode
decl_stmt|;
name|unsigned
name|int
name|mode_words
init|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|+
operator|(
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|)
operator|/
name|UNITS_PER_WORD
decl_stmt|;
comment|/* We form (outer_op (code varop count) (outer_const)).  */
name|enum
name|rtx_code
name|outer_op
init|=
name|NIL
decl_stmt|;
name|HOST_WIDE_INT
name|outer_const
init|=
literal|0
decl_stmt|;
name|rtx
name|const_rtx
decl_stmt|;
name|int
name|complement_p
init|=
literal|0
decl_stmt|;
name|rtx
name|new
decl_stmt|;
comment|/* Make sure and truncate the "natural" shift on the way in.  We don't      want to do this inside the loop as it makes it more difficult to      combine shifts.  */
ifdef|#
directive|ifdef
name|SHIFT_COUNT_TRUNCATED
if|if
condition|(
name|SHIFT_COUNT_TRUNCATED
condition|)
name|orig_count
operator|&=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* If we were given an invalid count, don't do anything except exactly      what was requested.  */
if|if
condition|(
name|orig_count
operator|<
literal|0
operator|||
name|orig_count
operator|>=
operator|(
name|int
operator|)
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|x
condition|)
return|return
name|x
return|;
return|return
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|varop
argument_list|,
name|GEN_INT
argument_list|(
name|orig_count
argument_list|)
argument_list|)
return|;
block|}
name|count
operator|=
name|orig_count
expr_stmt|;
comment|/* Unless one of the branches of the `if' in this loop does a `continue',      we will `break' the loop after the `if'.  */
while|while
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
comment|/* If we have an operand of (clobber (const_int 0)), just return that 	 value.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|varop
argument_list|)
operator|==
name|CLOBBER
condition|)
return|return
name|varop
return|;
comment|/* If we discovered we had to complement VAROP, leave.  Making a NOT 	 here would cause an infinite loop.  */
if|if
condition|(
name|complement_p
condition|)
break|break;
comment|/* Convert ROTATERT to ROTATE.  */
if|if
condition|(
name|code
operator|==
name|ROTATERT
condition|)
block|{
name|unsigned
name|int
name|bitsize
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|result_mode
argument_list|)
decl_stmt|;
empty_stmt|;
name|code
operator|=
name|ROTATE
expr_stmt|;
if|if
condition|(
name|VECTOR_MODE_P
argument_list|(
name|result_mode
argument_list|)
condition|)
name|count
operator|=
name|bitsize
operator|/
name|GET_MODE_NUNITS
argument_list|(
name|result_mode
argument_list|)
operator|-
name|count
expr_stmt|;
else|else
name|count
operator|=
name|bitsize
operator|-
name|count
expr_stmt|;
block|}
comment|/* We need to determine what mode we will do the shift in.  If the 	 shift is a right shift or a ROTATE, we must always do it in the mode 	 it was originally done in.  Otherwise, we can do it in MODE, the 	 widest mode encountered.  */
name|shift_mode
operator|=
operator|(
name|code
operator|==
name|ASHIFTRT
operator|||
name|code
operator|==
name|LSHIFTRT
operator|||
name|code
operator|==
name|ROTATE
condition|?
name|result_mode
else|:
name|mode
operator|)
expr_stmt|;
comment|/* Handle cases where the count is greater than the size of the mode 	 minus 1.  For ASHIFT, use the size minus one as the count (this can 	 occur when simplifying (lshiftrt (ashiftrt ..))).  For rotates, 	 take the count modulo the size.  For other shifts, the result is 	 zero.  	 Since these shifts are being produced by the compiler by combining 	 multiple operations, each of which are defined, we know what the 	 result is supposed to be.  */
if|if
condition|(
name|count
operator|>
call|(
name|unsigned
name|int
call|)
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|shift_mode
argument_list|)
operator|-
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|ASHIFTRT
condition|)
name|count
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|shift_mode
argument_list|)
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|ROTATE
operator|||
name|code
operator|==
name|ROTATERT
condition|)
name|count
operator|%=
name|GET_MODE_BITSIZE
argument_list|(
name|shift_mode
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* We can't simply return zero because there may be an 		 outer op.  */
name|varop
operator|=
name|const0_rtx
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
comment|/* An arithmetic right shift of a quantity known to be -1 or 0 	 is a no-op.  */
if|if
condition|(
name|code
operator|==
name|ASHIFTRT
operator|&&
operator|(
name|num_sign_bit_copies
argument_list|(
name|varop
argument_list|,
name|shift_mode
argument_list|)
operator|==
name|GET_MODE_BITSIZE
argument_list|(
name|shift_mode
argument_list|)
operator|)
condition|)
block|{
name|count
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* If we are doing an arithmetic right shift and discarding all but 	 the sign bit copies, this is equivalent to doing a shift by the 	 bitsize minus one.  Convert it into that shift because it will often 	 allow other simplifications.  */
if|if
condition|(
name|code
operator|==
name|ASHIFTRT
operator|&&
operator|(
name|count
operator|+
name|num_sign_bit_copies
argument_list|(
name|varop
argument_list|,
name|shift_mode
argument_list|)
operator|>=
name|GET_MODE_BITSIZE
argument_list|(
name|shift_mode
argument_list|)
operator|)
condition|)
name|count
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|shift_mode
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* We simplify the tests below and elsewhere by converting 	 ASHIFTRT to LSHIFTRT if we know the sign bit is clear. 	 `make_compound_operation' will convert it to an ASHIFTRT for 	 those machines (such as VAX) that don't have an LSHIFTRT.  */
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|shift_mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|code
operator|==
name|ASHIFTRT
operator|&&
operator|(
operator|(
name|nonzero_bits
argument_list|(
name|varop
argument_list|,
name|shift_mode
argument_list|)
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|shift_mode
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|)
operator|==
literal|0
operator|)
condition|)
name|code
operator|=
name|LSHIFTRT
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|varop
argument_list|)
condition|)
block|{
case|case
name|SIGN_EXTEND
case|:
case|case
name|ZERO_EXTEND
case|:
case|case
name|SIGN_EXTRACT
case|:
case|case
name|ZERO_EXTRACT
case|:
name|new
operator|=
name|expand_compound_operation
argument_list|(
name|varop
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|!=
name|varop
condition|)
block|{
name|varop
operator|=
name|new
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
name|MEM
case|:
comment|/* If we have (xshiftrt (mem ...) C) and C is MODE_WIDTH 	     minus the width of a smaller mode, we can do this with a 	     SIGN_EXTEND or ZERO_EXTEND from the narrower memory location.  */
if|if
condition|(
operator|(
name|code
operator|==
name|ASHIFTRT
operator|||
name|code
operator|==
name|LSHIFTRT
operator|)
operator|&&
operator|!
name|mode_dependent_address_p
argument_list|(
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|!
name|MEM_VOLATILE_P
argument_list|(
name|varop
argument_list|)
operator|&&
operator|(
name|tmode
operator|=
name|mode_for_size
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
name|count
argument_list|,
name|MODE_INT
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
name|BLKmode
condition|)
block|{
name|new
operator|=
name|adjust_address_nv
argument_list|(
name|varop
argument_list|,
name|tmode
argument_list|,
name|BYTES_BIG_ENDIAN
condition|?
literal|0
else|:
name|count
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|varop
operator|=
name|gen_rtx_fmt_e
argument_list|(
name|code
operator|==
name|ASHIFTRT
condition|?
name|SIGN_EXTEND
else|:
name|ZERO_EXTEND
argument_list|,
name|mode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
name|USE
case|:
comment|/* Similar to the case above, except that we can only do this if 	     the resulting mode is the same as that of the underlying 	     MEM and adjust the address depending on the *bits* endianness 	     because of the way that bit-field extract insns are defined.  */
if|if
condition|(
operator|(
name|code
operator|==
name|ASHIFTRT
operator|||
name|code
operator|==
name|LSHIFTRT
operator|)
operator|&&
operator|(
name|tmode
operator|=
name|mode_for_size
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
name|count
argument_list|,
name|MODE_INT
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
name|BLKmode
operator|&&
name|tmode
operator|==
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|BITS_BIG_ENDIAN
condition|)
name|new
operator|=
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|new
operator|=
name|copy_rtx
argument_list|(
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|SUBST
argument_list|(
name|XEXP
argument_list|(
name|new
argument_list|,
literal|0
argument_list|)
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|new
argument_list|,
literal|0
argument_list|)
argument_list|,
name|count
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|varop
operator|=
name|gen_rtx_fmt_e
argument_list|(
name|code
operator|==
name|ASHIFTRT
condition|?
name|SIGN_EXTEND
else|:
name|ZERO_EXTEND
argument_list|,
name|mode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
name|SUBREG
case|:
comment|/* If VAROP is a SUBREG, strip it as long as the inner operand has 	     the same number of words as what we've seen so far.  Then store 	     the widest mode in MODE.  */
if|if
condition|(
name|subreg_lowpart_p
argument_list|(
name|varop
argument_list|)
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|varop
argument_list|)
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|varop
argument_list|)
argument_list|)
operator|)
operator|&&
call|(
name|unsigned
name|int
call|)
argument_list|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|varop
argument_list|)
argument_list|)
argument_list|)
operator|+
operator|(
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|)
operator|/
name|UNITS_PER_WORD
argument_list|)
operator|==
name|mode_words
condition|)
block|{
name|varop
operator|=
name|SUBREG_REG
argument_list|(
name|varop
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|varop
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
condition|)
name|mode
operator|=
name|GET_MODE
argument_list|(
name|varop
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
name|MULT
case|:
comment|/* Some machines use MULT instead of ASHIFT because MULT 	     is cheaper.  But it is still better on those machines to 	     merge two shifts into one.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|varop
operator|=
name|gen_binary
argument_list|(
name|ASHIFT
argument_list|,
name|GET_MODE
argument_list|(
name|varop
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
name|UDIV
case|:
comment|/* Similar, for when divides are cheaper.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|varop
operator|=
name|gen_binary
argument_list|(
name|LSHIFTRT
argument_list|,
name|GET_MODE
argument_list|(
name|varop
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
name|ASHIFTRT
case|:
comment|/* If we are extracting just the sign bit of an arithmetic 	     right shift, that shift is not needed.  However, the sign 	     bit of a wider mode may be different from what would be 	     interpreted as the sign bit in a narrower mode, so, if 	     the result is narrower, don't discard the shift.  */
if|if
condition|(
name|code
operator|==
name|LSHIFTRT
operator|&&
name|count
operator|==
call|(
name|unsigned
name|int
call|)
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|result_mode
argument_list|)
operator|-
literal|1
argument_list|)
operator|&&
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|result_mode
argument_list|)
operator|>=
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|varop
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|varop
operator|=
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* ... fall through ...  */
case|case
name|LSHIFTRT
case|:
case|case
name|ASHIFT
case|:
case|case
name|ROTATE
case|:
comment|/* Here we have two nested shifts.  The result is usually the 	     AND of a new shift with a mask.  We compute the result below.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>=
literal|0
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|varop
argument_list|)
argument_list|)
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|result_mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|enum
name|rtx_code
name|first_code
init|=
name|GET_CODE
argument_list|(
name|varop
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|first_count
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|mask
decl_stmt|;
name|rtx
name|mask_rtx
decl_stmt|;
comment|/* We have one common special case.  We can't do any merging if 		 the inner code is an ASHIFTRT of a smaller mode.  However, if 		 we have (ashift:M1 (subreg:M1 (ashiftrt:M2 FOO C1) 0) C2) 		 with C2 == GET_MODE_BITSIZE (M1) - GET_MODE_BITSIZE (M2), 		 we can convert it to 		 (ashiftrt:M1 (ashift:M1 (and:M1 (subreg:M1 FOO 0 C2) C3) C1). 		 This simplifies certain SIGN_EXTEND operations.  */
if|if
condition|(
name|code
operator|==
name|ASHIFT
operator|&&
name|first_code
operator|==
name|ASHIFTRT
operator|&&
name|count
operator|==
call|(
name|unsigned
name|int
call|)
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|result_mode
argument_list|)
operator|-
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|varop
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
comment|/* C3 has the low-order C1 bits zero.  */
name|mask
operator|=
operator|(
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|&
operator|~
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|first_count
operator|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|varop
operator|=
name|simplify_and_const_int
argument_list|(
name|NULL_RTX
argument_list|,
name|result_mode
argument_list|,
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|varop
operator|=
name|simplify_shift_const
argument_list|(
name|NULL_RTX
argument_list|,
name|ASHIFT
argument_list|,
name|result_mode
argument_list|,
name|varop
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|count
operator|=
name|first_count
expr_stmt|;
name|code
operator|=
name|ASHIFTRT
expr_stmt|;
continue|continue;
block|}
comment|/* If this was (ashiftrt (ashift foo C1) C2) and FOO has more 		 than C1 high-order bits equal to the sign bit, we can convert 		 this to either an ASHIFT or an ASHIFTRT depending on the 		 two counts.  		 We cannot do this if VAROP's mode is not SHIFT_MODE.  */
if|if
condition|(
name|code
operator|==
name|ASHIFTRT
operator|&&
name|first_code
operator|==
name|ASHIFT
operator|&&
name|GET_MODE
argument_list|(
name|varop
argument_list|)
operator|==
name|shift_mode
operator|&&
operator|(
name|num_sign_bit_copies
argument_list|(
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|0
argument_list|)
argument_list|,
name|shift_mode
argument_list|)
operator|>
name|first_count
operator|)
condition|)
block|{
name|varop
operator|=
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|signed_count
operator|=
name|count
operator|-
name|first_count
expr_stmt|;
if|if
condition|(
name|signed_count
operator|<
literal|0
condition|)
name|count
operator|=
operator|-
name|signed_count
operator|,
name|code
operator|=
name|ASHIFT
expr_stmt|;
else|else
name|count
operator|=
name|signed_count
expr_stmt|;
continue|continue;
block|}
comment|/* There are some cases we can't do.  If CODE is ASHIFTRT, 		 we can only do this if FIRST_CODE is also ASHIFTRT.  		 We can't do the case when CODE is ROTATE and FIRST_CODE is 		 ASHIFTRT.  		 If the mode of this shift is not the mode of the outer shift, 		 we can't do this if either shift is a right shift or ROTATE.  		 Finally, we can't do any of these if the mode is too wide 		 unless the codes are the same.  		 Handle the case where the shift codes are the same 		 first.  */
if|if
condition|(
name|code
operator|==
name|first_code
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|varop
argument_list|)
operator|!=
name|result_mode
operator|&&
operator|(
name|code
operator|==
name|ASHIFTRT
operator|||
name|code
operator|==
name|LSHIFTRT
operator|||
name|code
operator|==
name|ROTATE
operator|)
condition|)
break|break;
name|count
operator|+=
name|first_count
expr_stmt|;
name|varop
operator|=
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|code
operator|==
name|ASHIFTRT
operator|||
operator|(
name|code
operator|==
name|ROTATE
operator|&&
name|first_code
operator|==
name|ASHIFTRT
operator|)
operator|||
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|>
name|HOST_BITS_PER_WIDE_INT
operator|||
operator|(
name|GET_MODE
argument_list|(
name|varop
argument_list|)
operator|!=
name|result_mode
operator|&&
operator|(
name|first_code
operator|==
name|ASHIFTRT
operator|||
name|first_code
operator|==
name|LSHIFTRT
operator|||
name|first_code
operator|==
name|ROTATE
operator|||
name|code
operator|==
name|ROTATE
operator|)
operator|)
condition|)
break|break;
comment|/* To compute the mask to apply after the shift, shift the 		 nonzero bits of the inner shift the same way the 		 outer shift will.  */
name|mask_rtx
operator|=
name|GEN_INT
argument_list|(
name|nonzero_bits
argument_list|(
name|varop
argument_list|,
name|GET_MODE
argument_list|(
name|varop
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|mask_rtx
operator|=
name|simplify_binary_operation
argument_list|(
name|code
argument_list|,
name|result_mode
argument_list|,
name|mask_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|count
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Give up if we can't compute an outer operation to use.  */
if|if
condition|(
name|mask_rtx
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|mask_rtx
argument_list|)
operator|!=
name|CONST_INT
operator|||
operator|!
name|merge_outer_ops
argument_list|(
operator|&
name|outer_op
argument_list|,
operator|&
name|outer_const
argument_list|,
name|AND
argument_list|,
name|INTVAL
argument_list|(
name|mask_rtx
argument_list|)
argument_list|,
name|result_mode
argument_list|,
operator|&
name|complement_p
argument_list|)
condition|)
break|break;
comment|/* If the shifts are in the same direction, we add the 		 counts.  Otherwise, we subtract them.  */
name|signed_count
operator|=
name|count
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|==
name|ASHIFTRT
operator|||
name|code
operator|==
name|LSHIFTRT
operator|)
operator|==
operator|(
name|first_code
operator|==
name|ASHIFTRT
operator|||
name|first_code
operator|==
name|LSHIFTRT
operator|)
condition|)
name|signed_count
operator|+=
name|first_count
expr_stmt|;
else|else
name|signed_count
operator|-=
name|first_count
expr_stmt|;
comment|/* If COUNT is positive, the new shift is usually CODE, 		 except for the two exceptions below, in which case it is 		 FIRST_CODE.  If the count is negative, FIRST_CODE should 		 always be used  */
if|if
condition|(
name|signed_count
operator|>
literal|0
operator|&&
operator|(
operator|(
name|first_code
operator|==
name|ROTATE
operator|&&
name|code
operator|==
name|ASHIFT
operator|)
operator|||
operator|(
name|first_code
operator|==
name|ASHIFTRT
operator|&&
name|code
operator|==
name|LSHIFTRT
operator|)
operator|)
condition|)
name|code
operator|=
name|first_code
operator|,
name|count
operator|=
name|signed_count
expr_stmt|;
elseif|else
if|if
condition|(
name|signed_count
operator|<
literal|0
condition|)
name|code
operator|=
name|first_code
operator|,
name|count
operator|=
operator|-
name|signed_count
expr_stmt|;
else|else
name|count
operator|=
name|signed_count
expr_stmt|;
name|varop
operator|=
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* If we have (A<< B<< C) for any shift, we can convert this to 	     (A<< C<< B).  This wins if A is a constant.  Only try this if 	     B is not a constant.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|varop
argument_list|)
operator|==
name|code
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|&&
literal|0
operator|!=
operator|(
name|new
operator|=
name|simplify_binary_operation
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|count
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|varop
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|new
argument_list|,
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
name|NOT
case|:
comment|/* Make this fit the case below.  */
name|varop
operator|=
name|gen_rtx_XOR
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|IOR
case|:
case|case
name|AND
case|:
case|case
name|XOR
case|:
comment|/* If we have (xshiftrt (ior (plus X (const_int -1)) X) C) 	     with C the size of VAROP - 1 and the shift is logical if 	     STORE_FLAG_VALUE is 1 and arithmetic if STORE_FLAG_VALUE is -1, 	     we have an (le X 0) operation.   If we have an arithmetic shift 	     and STORE_FLAG_VALUE is 1 or we have a logical shift with 	     STORE_FLAG_VALUE of -1, we have a (neg (le X 0)) operation.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|varop
argument_list|)
operator|==
name|IOR
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|constm1_rtx
operator|&&
operator|(
name|STORE_FLAG_VALUE
operator|==
literal|1
operator|||
name|STORE_FLAG_VALUE
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|code
operator|==
name|LSHIFTRT
operator|||
name|code
operator|==
name|ASHIFTRT
operator|)
operator|&&
name|count
operator|==
call|(
name|unsigned
name|int
call|)
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|varop
argument_list|)
argument_list|)
operator|-
literal|1
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|count
operator|=
literal|0
expr_stmt|;
name|varop
operator|=
name|gen_rtx_LE
argument_list|(
name|GET_MODE
argument_list|(
name|varop
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|1
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|STORE_FLAG_VALUE
operator|==
literal|1
condition|?
name|code
operator|==
name|ASHIFTRT
else|:
name|code
operator|==
name|LSHIFTRT
condition|)
name|varop
operator|=
name|gen_rtx_NEG
argument_list|(
name|GET_MODE
argument_list|(
name|varop
argument_list|)
argument_list|,
name|varop
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* If we have (shift (logical)), move the logical to the outside 	     to allow it to possibly combine with another logical and the 	     shift to combine with another shift.  This also canonicalizes to 	     what a ZERO_EXTRACT looks like.  Also, some machines have 	     (and (shift)) insns.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|new
operator|=
name|simplify_binary_operation
argument_list|(
name|code
argument_list|,
name|result_mode
argument_list|,
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|1
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|count
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|new
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|merge_outer_ops
argument_list|(
operator|&
name|outer_op
argument_list|,
operator|&
name|outer_const
argument_list|,
name|GET_CODE
argument_list|(
name|varop
argument_list|)
argument_list|,
name|INTVAL
argument_list|(
name|new
argument_list|)
argument_list|,
name|result_mode
argument_list|,
operator|&
name|complement_p
argument_list|)
condition|)
block|{
name|varop
operator|=
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* If we can't do that, try to simplify the shift in each arm of the 	     logical expression, make a new logical expression, and apply 	     the inverse distributive law.  */
block|{
name|rtx
name|lhs
init|=
name|simplify_shift_const
argument_list|(
name|NULL_RTX
argument_list|,
name|code
argument_list|,
name|shift_mode
argument_list|,
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|0
argument_list|)
argument_list|,
name|count
argument_list|)
decl_stmt|;
name|rtx
name|rhs
init|=
name|simplify_shift_const
argument_list|(
name|NULL_RTX
argument_list|,
name|code
argument_list|,
name|shift_mode
argument_list|,
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|1
argument_list|)
argument_list|,
name|count
argument_list|)
decl_stmt|;
name|varop
operator|=
name|gen_binary
argument_list|(
name|GET_CODE
argument_list|(
name|varop
argument_list|)
argument_list|,
name|shift_mode
argument_list|,
name|lhs
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
name|varop
operator|=
name|apply_distributive_law
argument_list|(
name|varop
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|EQ
case|:
comment|/* convert (lshiftrt (eq FOO 0) C) to (xor FOO 1) if STORE_FLAG_VALUE 	     says that the sign bit can be tested, FOO has mode MODE, C is 	     GET_MODE_BITSIZE (MODE) - 1, and FOO has only its low-order bit 	     that may be nonzero.  */
if|if
condition|(
name|code
operator|==
name|LSHIFTRT
operator|&&
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|1
argument_list|)
operator|==
name|const0_rtx
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|result_mode
operator|&&
name|count
operator|==
call|(
name|unsigned
name|int
call|)
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|result_mode
argument_list|)
operator|-
literal|1
argument_list|)
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|result_mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
operator|(
name|STORE_FLAG_VALUE
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|result_mode
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|)
operator|)
operator|&&
name|nonzero_bits
argument_list|(
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|0
argument_list|)
argument_list|,
name|result_mode
argument_list|)
operator|==
literal|1
operator|&&
name|merge_outer_ops
argument_list|(
operator|&
name|outer_op
argument_list|,
operator|&
name|outer_const
argument_list|,
name|XOR
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
argument_list|,
name|result_mode
argument_list|,
operator|&
name|complement_p
argument_list|)
condition|)
block|{
name|varop
operator|=
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
name|NEG
case|:
comment|/* (lshiftrt (neg A) C) where A is either 0 or 1 and C is one less 	     than the number of bits in the mode is equivalent to A.  */
if|if
condition|(
name|code
operator|==
name|LSHIFTRT
operator|&&
name|count
operator|==
call|(
name|unsigned
name|int
call|)
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|result_mode
argument_list|)
operator|-
literal|1
argument_list|)
operator|&&
name|nonzero_bits
argument_list|(
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|0
argument_list|)
argument_list|,
name|result_mode
argument_list|)
operator|==
literal|1
condition|)
block|{
name|varop
operator|=
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
comment|/* NEG commutes with ASHIFT since it is multiplication.  Move the 	     NEG outside to allow shifts to combine.  */
if|if
condition|(
name|code
operator|==
name|ASHIFT
operator|&&
name|merge_outer_ops
argument_list|(
operator|&
name|outer_op
argument_list|,
operator|&
name|outer_const
argument_list|,
name|NEG
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
literal|0
argument_list|,
name|result_mode
argument_list|,
operator|&
name|complement_p
argument_list|)
condition|)
block|{
name|varop
operator|=
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
name|PLUS
case|:
comment|/* (lshiftrt (plus A -1) C) where A is either 0 or 1 and C 	     is one less than the number of bits in the mode is 	     equivalent to (xor A 1).  */
if|if
condition|(
name|code
operator|==
name|LSHIFTRT
operator|&&
name|count
operator|==
call|(
name|unsigned
name|int
call|)
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|result_mode
argument_list|)
operator|-
literal|1
argument_list|)
operator|&&
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|1
argument_list|)
operator|==
name|constm1_rtx
operator|&&
name|nonzero_bits
argument_list|(
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|0
argument_list|)
argument_list|,
name|result_mode
argument_list|)
operator|==
literal|1
operator|&&
name|merge_outer_ops
argument_list|(
operator|&
name|outer_op
argument_list|,
operator|&
name|outer_const
argument_list|,
name|XOR
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
argument_list|,
name|result_mode
argument_list|,
operator|&
name|complement_p
argument_list|)
condition|)
block|{
name|count
operator|=
literal|0
expr_stmt|;
name|varop
operator|=
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* If we have (xshiftrt (plus FOO BAR) C), and the only bits 	     that might be nonzero in BAR are those being shifted out and those 	     bits are known zero in FOO, we can replace the PLUS with FOO. 	     Similarly in the other operand order.  This code occurs when 	     we are computing the size of a variable-size array.  */
if|if
condition|(
operator|(
name|code
operator|==
name|ASHIFTRT
operator|||
name|code
operator|==
name|LSHIFTRT
operator|)
operator|&&
name|count
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|nonzero_bits
argument_list|(
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|1
argument_list|)
argument_list|,
name|result_mode
argument_list|)
operator|>>
name|count
operator|==
literal|0
operator|&&
operator|(
name|nonzero_bits
argument_list|(
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|1
argument_list|)
argument_list|,
name|result_mode
argument_list|)
operator|&
name|nonzero_bits
argument_list|(
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|0
argument_list|)
argument_list|,
name|result_mode
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|varop
operator|=
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|(
name|code
operator|==
name|ASHIFTRT
operator|||
name|code
operator|==
name|LSHIFTRT
operator|)
operator|&&
name|count
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|result_mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
literal|0
operator|==
operator|(
name|nonzero_bits
argument_list|(
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|0
argument_list|)
argument_list|,
name|result_mode
argument_list|)
operator|>>
name|count
operator|)
operator|&&
literal|0
operator|==
operator|(
name|nonzero_bits
argument_list|(
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|0
argument_list|)
argument_list|,
name|result_mode
argument_list|)
operator|&
name|nonzero_bits
argument_list|(
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|1
argument_list|)
argument_list|,
name|result_mode
argument_list|)
operator|)
condition|)
block|{
name|varop
operator|=
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* (ashift (plus foo C) N) is (plus (ashift foo N) C').  */
if|if
condition|(
name|code
operator|==
name|ASHIFT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|new
operator|=
name|simplify_binary_operation
argument_list|(
name|ASHIFT
argument_list|,
name|result_mode
argument_list|,
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|1
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|count
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|new
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|merge_outer_ops
argument_list|(
operator|&
name|outer_op
argument_list|,
operator|&
name|outer_const
argument_list|,
name|PLUS
argument_list|,
name|INTVAL
argument_list|(
name|new
argument_list|)
argument_list|,
name|result_mode
argument_list|,
operator|&
name|complement_p
argument_list|)
condition|)
block|{
name|varop
operator|=
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
name|MINUS
case|:
comment|/* If we have (xshiftrt (minus (ashiftrt X C)) X) C) 	     with C the size of VAROP - 1 and the shift is logical if 	     STORE_FLAG_VALUE is 1 and arithmetic if STORE_FLAG_VALUE is -1, 	     we have a (gt X 0) operation.  If the shift is arithmetic with 	     STORE_FLAG_VALUE of 1 or logical with STORE_FLAG_VALUE == -1, 	     we have a (neg (gt X 0)) operation.  */
if|if
condition|(
operator|(
name|STORE_FLAG_VALUE
operator|==
literal|1
operator|||
name|STORE_FLAG_VALUE
operator|==
operator|-
literal|1
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ASHIFTRT
operator|&&
name|count
operator|==
call|(
name|unsigned
name|int
call|)
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|varop
argument_list|)
argument_list|)
operator|-
literal|1
argument_list|)
operator|&&
operator|(
name|code
operator|==
name|LSHIFTRT
operator|||
name|code
operator|==
name|ASHIFTRT
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|count
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|count
operator|=
literal|0
expr_stmt|;
name|varop
operator|=
name|gen_rtx_GT
argument_list|(
name|GET_MODE
argument_list|(
name|varop
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|1
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|STORE_FLAG_VALUE
operator|==
literal|1
condition|?
name|code
operator|==
name|ASHIFTRT
else|:
name|code
operator|==
name|LSHIFTRT
condition|)
name|varop
operator|=
name|gen_rtx_NEG
argument_list|(
name|GET_MODE
argument_list|(
name|varop
argument_list|)
argument_list|,
name|varop
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
name|TRUNCATE
case|:
comment|/* Change (lshiftrt (truncate (lshiftrt))) to (truncate (lshiftrt)) 	     if the truncate does not affect the value.  */
if|if
condition|(
name|code
operator|==
name|LSHIFTRT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LSHIFTRT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>=
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|-
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|varop
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
block|{
name|rtx
name|varop_inner
init|=
name|XEXP
argument_list|(
name|varop
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|varop_inner
operator|=
name|gen_rtx_LSHIFTRT
argument_list|(
name|GET_MODE
argument_list|(
name|varop_inner
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|varop_inner
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|count
operator|+
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|varop_inner
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|varop
operator|=
name|gen_rtx_TRUNCATE
argument_list|(
name|GET_MODE
argument_list|(
name|varop
argument_list|)
argument_list|,
name|varop_inner
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
break|break;
default|default:
break|break;
block|}
break|break;
block|}
comment|/* We need to determine what mode to do the shift in.  If the shift is      a right shift or ROTATE, we must always do it in the mode it was      originally done in.  Otherwise, we can do it in MODE, the widest mode      encountered.  The code we care about is that of the shift that will      actually be done, not the shift that was originally requested.  */
name|shift_mode
operator|=
operator|(
name|code
operator|==
name|ASHIFTRT
operator|||
name|code
operator|==
name|LSHIFTRT
operator|||
name|code
operator|==
name|ROTATE
condition|?
name|result_mode
else|:
name|mode
operator|)
expr_stmt|;
comment|/* We have now finished analyzing the shift.  The result should be      a shift of type CODE with SHIFT_MODE shifting VAROP COUNT places.  If      OUTER_OP is non-NIL, it is an operation that needs to be applied      to the result of the shift.  OUTER_CONST is the relevant constant,      but we must turn off all bits turned off in the shift.       If we were passed a value for X, see if we can use any pieces of      it.  If not, make new rtx.  */
if|if
condition|(
name|x
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
literal|'2'
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|count
condition|)
name|const_rtx
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|const_rtx
operator|=
name|GEN_INT
argument_list|(
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|shift_mode
operator|&&
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|varop
condition|)
name|varop
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|varop
argument_list|)
operator|!=
name|shift_mode
condition|)
name|varop
operator|=
name|gen_lowpart_for_combine
argument_list|(
name|shift_mode
argument_list|,
name|varop
argument_list|)
expr_stmt|;
comment|/* If we can't make the SUBREG, try to return what we were given.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|varop
argument_list|)
operator|==
name|CLOBBER
condition|)
return|return
name|x
condition|?
name|x
else|:
name|varop
return|;
name|new
operator|=
name|simplify_binary_operation
argument_list|(
name|code
argument_list|,
name|shift_mode
argument_list|,
name|varop
argument_list|,
name|const_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|!=
literal|0
condition|)
name|x
operator|=
name|new
expr_stmt|;
else|else
name|x
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|shift_mode
argument_list|,
name|varop
argument_list|,
name|const_rtx
argument_list|)
expr_stmt|;
comment|/* If we have an outer operation and we just made a shift, it is      possible that we could have simplified the shift were it not      for the outer operation.  So try to do the simplification      recursively.  */
if|if
condition|(
name|outer_op
operator|!=
name|NIL
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|code
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|x
operator|=
name|simplify_shift_const
argument_list|(
name|x
argument_list|,
name|code
argument_list|,
name|shift_mode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we were doing an LSHIFTRT in a wider mode than it was originally,      turn off all the bits that the shift would have turned off.  */
if|if
condition|(
name|orig_code
operator|==
name|LSHIFTRT
operator|&&
name|result_mode
operator|!=
name|shift_mode
condition|)
name|x
operator|=
name|simplify_and_const_int
argument_list|(
name|NULL_RTX
argument_list|,
name|shift_mode
argument_list|,
name|x
argument_list|,
name|GET_MODE_MASK
argument_list|(
name|result_mode
argument_list|)
operator|>>
name|orig_count
argument_list|)
expr_stmt|;
comment|/* Do the remainder of the processing in RESULT_MODE.  */
name|x
operator|=
name|gen_lowpart_for_combine
argument_list|(
name|result_mode
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* If COMPLEMENT_P is set, we have to complement X before doing the outer      operation.  */
if|if
condition|(
name|complement_p
condition|)
name|x
operator|=
name|simplify_gen_unary
argument_list|(
name|NOT
argument_list|,
name|result_mode
argument_list|,
name|x
argument_list|,
name|result_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|outer_op
operator|!=
name|NIL
condition|)
block|{
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|result_mode
argument_list|)
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
name|outer_const
operator|=
name|trunc_int_for_mode
argument_list|(
name|outer_const
argument_list|,
name|result_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|outer_op
operator|==
name|AND
condition|)
name|x
operator|=
name|simplify_and_const_int
argument_list|(
name|NULL_RTX
argument_list|,
name|result_mode
argument_list|,
name|x
argument_list|,
name|outer_const
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|outer_op
operator|==
name|SET
condition|)
comment|/* This means that we have determined that the result is 	   equivalent to a constant.  This should be rare.  */
name|x
operator|=
name|GEN_INT
argument_list|(
name|outer_const
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|outer_op
argument_list|)
operator|==
literal|'1'
condition|)
name|x
operator|=
name|simplify_gen_unary
argument_list|(
name|outer_op
argument_list|,
name|result_mode
argument_list|,
name|x
argument_list|,
name|result_mode
argument_list|)
expr_stmt|;
else|else
name|x
operator|=
name|gen_binary
argument_list|(
name|outer_op
argument_list|,
name|result_mode
argument_list|,
name|x
argument_list|,
name|GEN_INT
argument_list|(
name|outer_const
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Like recog, but we receive the address of a pointer to a new pattern.    We try to match the rtx that the pointer points to.    If that fails, we may try to modify or replace the pattern,    storing the replacement into the same pointer object.     Modifications include deletion or addition of CLOBBERs.     PNOTES is a pointer to a location where any REG_UNUSED notes added for    the CLOBBERs are placed.     The value is the final insn code from the pattern ultimately matched,    or -1.  */
end_comment

begin_function
specifier|static
name|int
name|recog_for_combine
parameter_list|(
name|pnewpat
parameter_list|,
name|insn
parameter_list|,
name|pnotes
parameter_list|)
name|rtx
modifier|*
name|pnewpat
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|rtx
modifier|*
name|pnotes
decl_stmt|;
block|{
name|rtx
name|pat
init|=
operator|*
name|pnewpat
decl_stmt|;
name|int
name|insn_code_number
decl_stmt|;
name|int
name|num_clobbers_to_add
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rtx
name|notes
init|=
literal|0
decl_stmt|;
name|rtx
name|dummy_insn
decl_stmt|;
comment|/* If PAT is a PARALLEL, check to see if it contains the CLOBBER      we use to indicate that something didn't match.  If we find such a      thing, force rejection.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
condition|)
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|CLOBBER
operator|&&
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|const0_rtx
condition|)
return|return
operator|-
literal|1
return|;
comment|/* *pnewpat does not have to be actual PATTERN (insn), so make a dummy      instruction for pattern recognition.  */
name|dummy_insn
operator|=
name|shallow_copy_rtx
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|PATTERN
argument_list|(
name|dummy_insn
argument_list|)
operator|=
name|pat
expr_stmt|;
name|REG_NOTES
argument_list|(
name|dummy_insn
argument_list|)
operator|=
literal|0
expr_stmt|;
name|insn_code_number
operator|=
name|recog
argument_list|(
name|pat
argument_list|,
name|dummy_insn
argument_list|,
operator|&
name|num_clobbers_to_add
argument_list|)
expr_stmt|;
comment|/* If it isn't, there is the possibility that we previously had an insn      that clobbered some register as a side effect, but the combined      insn doesn't need to do that.  So try once more without the clobbers      unless this represents an ASM insn.  */
if|if
condition|(
name|insn_code_number
operator|<
literal|0
operator|&&
operator|!
name|check_asm_operands
argument_list|(
name|pat
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|pos
decl_stmt|;
for|for
control|(
name|pos
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|!=
name|CLOBBER
condition|)
block|{
if|if
condition|(
name|i
operator|!=
name|pos
condition|)
name|SUBST
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|pos
argument_list|)
argument_list|,
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|pos
operator|++
expr_stmt|;
block|}
name|SUBST_INT
argument_list|(
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
argument_list|,
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|==
literal|1
condition|)
name|pat
operator|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PATTERN
argument_list|(
name|dummy_insn
argument_list|)
operator|=
name|pat
expr_stmt|;
name|insn_code_number
operator|=
name|recog
argument_list|(
name|pat
argument_list|,
name|dummy_insn
argument_list|,
operator|&
name|num_clobbers_to_add
argument_list|)
expr_stmt|;
block|}
comment|/* Recognize all noop sets, these will be killed by followup pass.  */
if|if
condition|(
name|insn_code_number
operator|<
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
operator|&&
name|set_noop_p
argument_list|(
name|pat
argument_list|)
condition|)
name|insn_code_number
operator|=
name|NOOP_MOVE_INSN_CODE
operator|,
name|num_clobbers_to_add
operator|=
literal|0
expr_stmt|;
comment|/* If we had any clobbers to add, make a new pattern than contains      them.  Then check to make sure that all of them are dead.  */
if|if
condition|(
name|num_clobbers_to_add
condition|)
block|{
name|rtx
name|newpat
init|=
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|rtvec_alloc
argument_list|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
condition|?
operator|(
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
operator|+
name|num_clobbers_to_add
operator|)
else|:
name|num_clobbers_to_add
operator|+
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
operator|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|=
name|pat
expr_stmt|;
name|add_clobbers
argument_list|(
name|newpat
argument_list|,
name|insn_code_number
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|)
operator|-
name|num_clobbers_to_add
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|!
name|reg_dead_at_p
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|notes
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_UNUSED
argument_list|,
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|notes
argument_list|)
expr_stmt|;
block|}
name|pat
operator|=
name|newpat
expr_stmt|;
block|}
operator|*
name|pnewpat
operator|=
name|pat
expr_stmt|;
operator|*
name|pnotes
operator|=
name|notes
expr_stmt|;
return|return
name|insn_code_number
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Like gen_lowpart but for use by combine.  In combine it is not possible    to create any new pseudoregs.  However, it is safe to create    invalid memory addresses, because combine will try to recognize    them and all they will do is make the combine attempt fail.     If for some reason this cannot do its job, an rtx    (clobber (const_int 0)) is returned.    An insn containing that will not be recognized.  */
end_comment

begin_undef
undef|#
directive|undef
name|gen_lowpart
end_undef

begin_function
specifier|static
name|rtx
name|gen_lowpart_for_combine
parameter_list|(
name|mode
parameter_list|,
name|x
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
name|rtx
name|result
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|mode
condition|)
return|return
name|x
return|;
comment|/* We can only support MODE being wider than a word if X is a      constant integer or has a mode the same size.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>
name|UNITS_PER_WORD
operator|&&
operator|!
operator|(
operator|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|VOIDmode
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|)
operator|)
operator|||
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|)
condition|)
return|return
name|gen_rtx_CLOBBER
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
return|;
comment|/* X might be a paradoxical (subreg (mem)).  In that case, gen_lowpart      won't know what to do.  So we will strip off the SUBREG here and      process normally.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|x
operator|=
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|mode
condition|)
return|return
name|x
return|;
block|}
name|result
operator|=
name|gen_lowpart_common
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CANNOT_CHANGE_MODE_CLASS
if|if
condition|(
name|result
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|result
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|result
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|result
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|bitmap_set_bit
argument_list|(
operator|&
name|subregs_of_mode
argument_list|,
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|result
argument_list|)
argument_list|)
operator|*
name|MAX_MACHINE_MODE
operator|+
name|GET_MODE
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|result
condition|)
return|return
name|result
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|int
name|offset
init|=
literal|0
decl_stmt|;
comment|/* Refuse to work on a volatile memory ref or one with a mode-dependent 	 address.  */
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
operator|||
name|mode_dependent_address_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|gen_rtx_CLOBBER
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
return|;
comment|/* If we want to refer to something bigger than the original memref, 	 generate a perverse subreg instead.  That will force a reload 	 of the original memref X.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|gen_rtx_SUBREG
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
return|;
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
name|offset
operator|=
operator|(
name|MAX
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|UNITS_PER_WORD
argument_list|)
operator|-
name|MAX
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
name|UNITS_PER_WORD
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
block|{
comment|/* Adjust the address so that the address-after-the-data is 	     unchanged.  */
name|offset
operator|-=
operator|(
name|MIN
argument_list|(
name|UNITS_PER_WORD
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
operator|-
name|MIN
argument_list|(
name|UNITS_PER_WORD
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
return|return
name|adjust_address_nv
argument_list|(
name|x
argument_list|,
name|mode
argument_list|,
name|offset
argument_list|)
return|;
block|}
comment|/* If X is a comparison operator, rewrite it in a new mode.  This      probably won't match, but may allow further simplifications.  */
elseif|else
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
literal|'<'
condition|)
return|return
name|gen_rtx_fmt_ee
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
comment|/* If we couldn't simplify X any other way, just enclose it in a      SUBREG.  Normally, this SUBREG won't match, but some patterns may      include an explicit SUBREG or we may simplify it further in combine.  */
else|else
block|{
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|rtx
name|res
decl_stmt|;
name|enum
name|machine_mode
name|sub_mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|offset
operator|=
name|subreg_lowpart_offset
argument_list|(
name|mode
argument_list|,
name|sub_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|sub_mode
operator|==
name|VOIDmode
condition|)
block|{
name|sub_mode
operator|=
name|int_mode_for_mode
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_lowpart_common
argument_list|(
name|sub_mode
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
name|res
operator|=
name|simplify_gen_subreg
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|sub_mode
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
return|return
name|res
return|;
return|return
name|gen_rtx_CLOBBER
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* These routines make binary and unary operations by first seeing if they    fold; if not, a new expression is allocated.  */
end_comment

begin_function
specifier|static
name|rtx
name|gen_binary
parameter_list|(
name|code
parameter_list|,
name|mode
parameter_list|,
name|op0
parameter_list|,
name|op1
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
block|{
name|rtx
name|result
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'c'
operator|&&
name|swap_commutative_operands_p
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
condition|)
name|tem
operator|=
name|op0
operator|,
name|op0
operator|=
name|op1
operator|,
name|op1
operator|=
name|tem
expr_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'<'
condition|)
block|{
name|enum
name|machine_mode
name|op_mode
init|=
name|GET_MODE
argument_list|(
name|op0
argument_list|)
decl_stmt|;
comment|/* Strip the COMPARE from (REL_OP (compare X Y) 0) to get 	 just (REL_OP X Y).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|COMPARE
operator|&&
name|op1
operator|==
name|const0_rtx
condition|)
block|{
name|op1
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|op0
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op_mode
operator|=
name|GET_MODE
argument_list|(
name|op0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|op_mode
operator|==
name|VOIDmode
condition|)
name|op_mode
operator|=
name|GET_MODE
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|result
operator|=
name|simplify_relational_operation
argument_list|(
name|code
argument_list|,
name|op_mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
else|else
name|result
operator|=
name|simplify_binary_operation
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
return|return
name|result
return|;
comment|/* Put complex operands first and constants second.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'c'
operator|&&
name|swap_commutative_operands_p
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
condition|)
return|return
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op1
argument_list|,
name|op0
argument_list|)
return|;
comment|/* If we are turning off bits already known off in OP0, we need not do      an AND.  */
elseif|else
if|if
condition|(
name|code
operator|==
name|AND
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
name|nonzero_bits
argument_list|(
name|op0
argument_list|,
name|mode
argument_list|)
operator|&
operator|~
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
name|op0
return|;
return|return
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Simplify a comparison between *POP0 and *POP1 where CODE is the    comparison code that will be tested.     The result is a possibly different comparison code to use.  *POP0 and    *POP1 may be updated.     It is possible that we might detect that a comparison is either always    true or always false.  However, we do not perform general constant    folding in combine, so this knowledge isn't useful.  Such tautologies    should have been detected earlier.  Hence we ignore all such cases.  */
end_comment

begin_function
specifier|static
name|enum
name|rtx_code
name|simplify_comparison
parameter_list|(
name|code
parameter_list|,
name|pop0
parameter_list|,
name|pop1
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
name|rtx
modifier|*
name|pop0
decl_stmt|;
name|rtx
modifier|*
name|pop1
decl_stmt|;
block|{
name|rtx
name|op0
init|=
operator|*
name|pop0
decl_stmt|;
name|rtx
name|op1
init|=
operator|*
name|pop1
decl_stmt|;
name|rtx
name|tem
decl_stmt|,
name|tem1
decl_stmt|;
name|int
name|i
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|,
name|tmode
decl_stmt|;
comment|/* Try a few ways of applying the same transformation to both operands.  */
while|while
condition|(
literal|1
condition|)
block|{
ifndef|#
directive|ifndef
name|WORD_REGISTER_OPERATIONS
comment|/* The test below this one won't handle SIGN_EXTENDs on these machines, 	 so check specially.  */
if|if
condition|(
name|code
operator|!=
name|GTU
operator|&&
name|code
operator|!=
name|GEU
operator|&&
name|code
operator|!=
name|LTU
operator|&&
name|code
operator|!=
name|LEU
operator|&&
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|ASHIFTRT
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|ASHIFTRT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ASHIFT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ASHIFT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|-
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
condition|)
block|{
name|op0
operator|=
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|op1
operator|=
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* If both operands are the same constant shift, see if we can ignore the 	 shift.  We can if the shift is a rotate or if the bits shifted out of 	 this shift are known to be zero for both inputs and if the type of 	 comparison is compatible with the shift.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|ROTATE
operator|&&
operator|(
name|code
operator|==
name|NE
operator|||
name|code
operator|==
name|EQ
operator|)
operator|)
operator|||
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|LSHIFTRT
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|ASHIFT
operator|)
operator|&&
operator|(
name|code
operator|!=
name|GT
operator|&&
name|code
operator|!=
name|LT
operator|&&
name|code
operator|!=
name|GE
operator|&&
name|code
operator|!=
name|LE
operator|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|ASHIFTRT
operator|&&
operator|(
name|code
operator|!=
name|GTU
operator|&&
name|code
operator|!=
name|LTU
operator|&&
name|code
operator|!=
name|GEU
operator|&&
name|code
operator|!=
name|LEU
operator|)
operator|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>=
literal|0
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
operator|==
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|op0
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|mask
init|=
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|int
name|shift_count
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|LSHIFTRT
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|ASHIFTRT
condition|)
name|mask
operator|&=
operator|(
name|mask
operator|>>
name|shift_count
operator|)
operator|<<
name|shift_count
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|ASHIFT
condition|)
name|mask
operator|=
operator|(
name|mask
operator|&
operator|(
name|mask
operator|<<
name|shift_count
operator|)
operator|)
operator|>>
name|shift_count
expr_stmt|;
if|if
condition|(
operator|(
name|nonzero_bits
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|&
operator|~
name|mask
operator|)
operator|==
literal|0
operator|&&
operator|(
name|nonzero_bits
argument_list|(
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|&
operator|~
name|mask
operator|)
operator|==
literal|0
condition|)
name|op0
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
operator|,
name|op1
operator|=
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
comment|/* If both operands are AND's of a paradoxical SUBREG by constant, the 	 SUBREGs are of the same mode, and, in both cases, the AND would 	 be redundant if the comparison was done in the narrower mode, 	 do the comparison in the narrower mode (e.g., we are AND'ing with 1 	 and the operand's possibly nonzero bits are 0xffffff01; in that case 	 if we only care about QImode, we don't need the AND).  This case 	 occurs if the output mode of an scc insn is not SImode and 	 STORE_FLAG_VALUE == 1 (e.g., the 386).  	 Similarly, check for a case where the AND's are ZERO_EXTEND 	 operations from some narrower mode even though a SUBREG is not 	 present.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|AND
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|AND
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|rtx
name|inner_op0
init|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|inner_op1
init|=
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|c0
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|c1
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|changed
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|inner_op0
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|inner_op1
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|inner_op0
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|inner_op0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|inner_op0
argument_list|)
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|inner_op1
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|inner_op0
argument_list|)
argument_list|)
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|&&
operator|(
literal|0
operator|==
operator|(
operator|(
operator|~
name|c0
operator|)
operator|&
name|nonzero_bits
argument_list|(
name|SUBREG_REG
argument_list|(
name|inner_op0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|inner_op0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|)
operator|&&
operator|(
literal|0
operator|==
operator|(
operator|(
operator|~
name|c1
operator|)
operator|&
name|nonzero_bits
argument_list|(
name|SUBREG_REG
argument_list|(
name|inner_op1
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|inner_op1
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
block|{
name|op0
operator|=
name|SUBREG_REG
argument_list|(
name|inner_op0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|SUBREG_REG
argument_list|(
name|inner_op1
argument_list|)
expr_stmt|;
comment|/* The resulting comparison is always unsigned since we masked 		 off the original sign bit.  */
name|code
operator|=
name|unsigned_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c0
operator|==
name|c1
condition|)
for|for
control|(
name|tmode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
argument_list|)
init|;
name|tmode
operator|!=
name|GET_MODE
argument_list|(
name|op0
argument_list|)
condition|;
name|tmode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|tmode
argument_list|)
control|)
if|if
condition|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|c0
operator|==
name|GET_MODE_MASK
argument_list|(
name|tmode
argument_list|)
condition|)
block|{
name|op0
operator|=
name|gen_lowpart_for_combine
argument_list|(
name|tmode
argument_list|,
name|inner_op0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|gen_lowpart_for_combine
argument_list|(
name|tmode
argument_list|,
name|inner_op1
argument_list|)
expr_stmt|;
name|code
operator|=
name|unsigned_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|changed
condition|)
break|break;
block|}
comment|/* If both operands are NOT, we can strip off the outer operation 	 and adjust the comparison code for swapped operands; similarly for 	 NEG, except that this must be an equality comparison.  */
elseif|else
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|NOT
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|NOT
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|NEG
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|NEG
operator|&&
operator|(
name|code
operator|==
name|EQ
operator|||
name|code
operator|==
name|NE
operator|)
operator|)
condition|)
name|op0
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
operator|,
name|op1
operator|=
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
operator|,
name|code
operator|=
name|swap_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
comment|/* If the first operand is a constant, swap the operands and adjust the      comparison code appropriately, but don't do this if the second operand      is already a constant integer.  */
if|if
condition|(
name|swap_commutative_operands_p
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
condition|)
block|{
name|tem
operator|=
name|op0
operator|,
name|op0
operator|=
name|op1
operator|,
name|op1
operator|=
name|tem
expr_stmt|;
name|code
operator|=
name|swap_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
comment|/* We now enter a loop during which we will try to simplify the comparison.      For the most part, we only are concerned with comparisons with zero,      but some things may really be comparisons with zero but not start      out looking that way.  */
while|while
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|op0
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|mode_width
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|mask
init|=
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|int
name|equality_comparison_p
decl_stmt|;
name|int
name|sign_bit_comparison_p
decl_stmt|;
name|int
name|unsigned_comparison_p
decl_stmt|;
name|HOST_WIDE_INT
name|const_op
decl_stmt|;
comment|/* We only want to handle integral modes.  This catches VOIDmode, 	 CCmode, and the floating-point modes.  An exception is that we 	 can handle VOIDmode if OP0 is a COMPARE or a comparison 	 operation.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_INT
operator|&&
operator|!
operator|(
name|mode
operator|==
name|VOIDmode
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|COMPARE
operator|||
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|)
operator|)
condition|)
break|break;
comment|/* Get the constant we are comparing against and turn off all bits 	 not on in our mode.  */
name|const_op
operator|=
name|INTVAL
argument_list|(
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
condition|)
name|const_op
operator|=
name|trunc_int_for_mode
argument_list|(
name|const_op
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|op1
operator|=
name|GEN_INT
argument_list|(
name|const_op
argument_list|)
expr_stmt|;
comment|/* If we are comparing against a constant power of two and the value 	 being compared can only have that single bit nonzero (e.g., it was 	 `and'ed with that bit), we can replace this with a comparison 	 with zero.  */
if|if
condition|(
name|const_op
operator|&&
operator|(
name|code
operator|==
name|EQ
operator|||
name|code
operator|==
name|NE
operator|||
name|code
operator|==
name|GE
operator|||
name|code
operator|==
name|GEU
operator|||
name|code
operator|==
name|LT
operator|||
name|code
operator|==
name|LTU
operator|)
operator|&&
name|mode_width
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|exact_log2
argument_list|(
name|const_op
argument_list|)
operator|>=
literal|0
operator|&&
name|nonzero_bits
argument_list|(
name|op0
argument_list|,
name|mode
argument_list|)
operator|==
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|const_op
condition|)
block|{
name|code
operator|=
operator|(
name|code
operator|==
name|EQ
operator|||
name|code
operator|==
name|GE
operator|||
name|code
operator|==
name|GEU
condition|?
name|NE
else|:
name|EQ
operator|)
expr_stmt|;
name|op1
operator|=
name|const0_rtx
operator|,
name|const_op
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Similarly, if we are comparing a value known to be either -1 or 	 0 with -1, change it to the opposite comparison against zero.  */
if|if
condition|(
name|const_op
operator|==
operator|-
literal|1
operator|&&
operator|(
name|code
operator|==
name|EQ
operator|||
name|code
operator|==
name|NE
operator|||
name|code
operator|==
name|GT
operator|||
name|code
operator|==
name|LE
operator|||
name|code
operator|==
name|GEU
operator|||
name|code
operator|==
name|LTU
operator|)
operator|&&
name|num_sign_bit_copies
argument_list|(
name|op0
argument_list|,
name|mode
argument_list|)
operator|==
name|mode_width
condition|)
block|{
name|code
operator|=
operator|(
name|code
operator|==
name|EQ
operator|||
name|code
operator|==
name|LE
operator|||
name|code
operator|==
name|GEU
condition|?
name|NE
else|:
name|EQ
operator|)
expr_stmt|;
name|op1
operator|=
name|const0_rtx
operator|,
name|const_op
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Do some canonicalizations based on the comparison code.  We prefer 	 comparisons against zero and then prefer equality comparisons. 	 If we can reduce the size of a constant, we will do that too.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LT
case|:
comment|/*< C is equivalent to<= (C - 1) */
if|if
condition|(
name|const_op
operator|>
literal|0
condition|)
block|{
name|const_op
operator|-=
literal|1
expr_stmt|;
name|op1
operator|=
name|GEN_INT
argument_list|(
name|const_op
argument_list|)
expr_stmt|;
name|code
operator|=
name|LE
expr_stmt|;
comment|/* ... fall through to LE case below.  */
block|}
else|else
break|break;
case|case
name|LE
case|:
comment|/*<= C is equivalent to< (C + 1); we do this for C< 0  */
if|if
condition|(
name|const_op
operator|<
literal|0
condition|)
block|{
name|const_op
operator|+=
literal|1
expr_stmt|;
name|op1
operator|=
name|GEN_INT
argument_list|(
name|const_op
argument_list|)
expr_stmt|;
name|code
operator|=
name|LT
expr_stmt|;
block|}
comment|/* If we are doing a<= 0 comparison on a value known to have 	     a zero sign bit, we can replace this with == 0.  */
elseif|else
if|if
condition|(
name|const_op
operator|==
literal|0
operator|&&
name|mode_width
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
name|nonzero_bits
argument_list|(
name|op0
argument_list|,
name|mode
argument_list|)
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|mode_width
operator|-
literal|1
operator|)
operator|)
operator|)
operator|==
literal|0
condition|)
name|code
operator|=
name|EQ
expr_stmt|;
break|break;
case|case
name|GE
case|:
comment|/*>= C is equivalent to> (C - 1).  */
if|if
condition|(
name|const_op
operator|>
literal|0
condition|)
block|{
name|const_op
operator|-=
literal|1
expr_stmt|;
name|op1
operator|=
name|GEN_INT
argument_list|(
name|const_op
argument_list|)
expr_stmt|;
name|code
operator|=
name|GT
expr_stmt|;
comment|/* ... fall through to GT below.  */
block|}
else|else
break|break;
case|case
name|GT
case|:
comment|/*> C is equivalent to>= (C + 1); we do this for C< 0.  */
if|if
condition|(
name|const_op
operator|<
literal|0
condition|)
block|{
name|const_op
operator|+=
literal|1
expr_stmt|;
name|op1
operator|=
name|GEN_INT
argument_list|(
name|const_op
argument_list|)
expr_stmt|;
name|code
operator|=
name|GE
expr_stmt|;
block|}
comment|/* If we are doing a> 0 comparison on a value known to have 	     a zero sign bit, we can replace this with != 0.  */
elseif|else
if|if
condition|(
name|const_op
operator|==
literal|0
operator|&&
name|mode_width
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
name|nonzero_bits
argument_list|(
name|op0
argument_list|,
name|mode
argument_list|)
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|mode_width
operator|-
literal|1
operator|)
operator|)
operator|)
operator|==
literal|0
condition|)
name|code
operator|=
name|NE
expr_stmt|;
break|break;
case|case
name|LTU
case|:
comment|/*< C is equivalent to<= (C - 1).  */
if|if
condition|(
name|const_op
operator|>
literal|0
condition|)
block|{
name|const_op
operator|-=
literal|1
expr_stmt|;
name|op1
operator|=
name|GEN_INT
argument_list|(
name|const_op
argument_list|)
expr_stmt|;
name|code
operator|=
name|LEU
expr_stmt|;
comment|/* ... fall through ...  */
block|}
comment|/* (unsigned)< 0x80000000 is equivalent to>= 0.  */
elseif|else
if|if
condition|(
operator|(
name|mode_width
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|&&
operator|(
name|const_op
operator|==
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|mode_width
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|const_op
operator|=
literal|0
operator|,
name|op1
operator|=
name|const0_rtx
expr_stmt|;
name|code
operator|=
name|GE
expr_stmt|;
break|break;
block|}
else|else
break|break;
case|case
name|LEU
case|:
comment|/* unsigned<= 0 is equivalent to == 0 */
if|if
condition|(
name|const_op
operator|==
literal|0
condition|)
name|code
operator|=
name|EQ
expr_stmt|;
comment|/* (unsigned)<= 0x7fffffff is equivalent to>= 0.  */
elseif|else
if|if
condition|(
operator|(
name|mode_width
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|&&
operator|(
name|const_op
operator|==
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|mode_width
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
condition|)
block|{
name|const_op
operator|=
literal|0
operator|,
name|op1
operator|=
name|const0_rtx
expr_stmt|;
name|code
operator|=
name|GE
expr_stmt|;
block|}
break|break;
case|case
name|GEU
case|:
comment|/*>= C is equivalent to< (C - 1).  */
if|if
condition|(
name|const_op
operator|>
literal|1
condition|)
block|{
name|const_op
operator|-=
literal|1
expr_stmt|;
name|op1
operator|=
name|GEN_INT
argument_list|(
name|const_op
argument_list|)
expr_stmt|;
name|code
operator|=
name|GTU
expr_stmt|;
comment|/* ... fall through ...  */
block|}
comment|/* (unsigned)>= 0x80000000 is equivalent to< 0.  */
elseif|else
if|if
condition|(
operator|(
name|mode_width
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|&&
operator|(
name|const_op
operator|==
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|mode_width
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|const_op
operator|=
literal|0
operator|,
name|op1
operator|=
name|const0_rtx
expr_stmt|;
name|code
operator|=
name|LT
expr_stmt|;
break|break;
block|}
else|else
break|break;
case|case
name|GTU
case|:
comment|/* unsigned> 0 is equivalent to != 0 */
if|if
condition|(
name|const_op
operator|==
literal|0
condition|)
name|code
operator|=
name|NE
expr_stmt|;
comment|/* (unsigned)> 0x7fffffff is equivalent to< 0.  */
elseif|else
if|if
condition|(
operator|(
name|mode_width
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|&&
operator|(
name|const_op
operator|==
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|mode_width
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
condition|)
block|{
name|const_op
operator|=
literal|0
operator|,
name|op1
operator|=
name|const0_rtx
expr_stmt|;
name|code
operator|=
name|LT
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
comment|/* Compute some predicates to simplify code below.  */
name|equality_comparison_p
operator|=
operator|(
name|code
operator|==
name|EQ
operator|||
name|code
operator|==
name|NE
operator|)
expr_stmt|;
name|sign_bit_comparison_p
operator|=
operator|(
operator|(
name|code
operator|==
name|LT
operator|||
name|code
operator|==
name|GE
operator|)
operator|&&
name|const_op
operator|==
literal|0
operator|)
expr_stmt|;
name|unsigned_comparison_p
operator|=
operator|(
name|code
operator|==
name|LTU
operator|||
name|code
operator|==
name|LEU
operator|||
name|code
operator|==
name|GTU
operator|||
name|code
operator|==
name|GEU
operator|)
expr_stmt|;
comment|/* If this is a sign bit comparison and we can do arithmetic in 	 MODE, say that we will only be needing the sign bit of OP0.  */
if|if
condition|(
name|sign_bit_comparison_p
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
condition|)
name|op0
operator|=
name|force_to_mode
argument_list|(
name|op0
argument_list|,
name|mode
argument_list|,
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Now try cases based on the opcode of OP0.  If none of the cases 	 does a "continue", we exit this loop immediately after the 	 switch.  */
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
condition|)
block|{
case|case
name|ZERO_EXTRACT
case|:
comment|/* If we are extracting a single bit from a variable position in 	     a constant that has only a single bit set and are comparing it 	     with zero, we can convert this into an equality comparison 	     between the position and the location of the single bit.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
operator|==
name|const1_rtx
operator|&&
name|equality_comparison_p
operator|&&
name|const_op
operator|==
literal|0
operator|&&
operator|(
name|i
operator|=
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|BITS_BIG_ENDIAN
condition|)
block|{
name|enum
name|machine_mode
name|new_mode
init|=
name|mode_for_extraction
argument_list|(
name|EP_extzv
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_mode
operator|==
name|MAX_MACHINE_MODE
condition|)
name|i
operator|=
name|BITS_PER_WORD
operator|-
literal|1
operator|-
name|i
expr_stmt|;
else|else
block|{
name|mode
operator|=
name|new_mode
expr_stmt|;
name|i
operator|=
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
operator|-
name|i
operator|)
expr_stmt|;
block|}
block|}
name|op0
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|op1
operator|=
name|GEN_INT
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|const_op
operator|=
name|i
expr_stmt|;
comment|/* Result is nonzero iff shift count is equal to I.  */
name|code
operator|=
name|reverse_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* ... fall through ...  */
case|case
name|SIGN_EXTRACT
case|:
name|tem
operator|=
name|expand_compound_operation
argument_list|(
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|!=
name|op0
condition|)
block|{
name|op0
operator|=
name|tem
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
name|NOT
case|:
comment|/* If testing for equality, we can take the NOT of the constant.  */
if|if
condition|(
name|equality_comparison_p
operator|&&
operator|(
name|tem
operator|=
name|simplify_unary_operation
argument_list|(
name|NOT
argument_list|,
name|mode
argument_list|,
name|op1
argument_list|,
name|mode
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|op0
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|tem
expr_stmt|;
continue|continue;
block|}
comment|/* If just looking at the sign bit, reverse the sense of the 	     comparison.  */
if|if
condition|(
name|sign_bit_comparison_p
condition|)
block|{
name|op0
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|code
operator|=
operator|(
name|code
operator|==
name|GE
condition|?
name|LT
else|:
name|GE
operator|)
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
name|NEG
case|:
comment|/* If testing for equality, we can take the NEG of the constant.  */
if|if
condition|(
name|equality_comparison_p
operator|&&
operator|(
name|tem
operator|=
name|simplify_unary_operation
argument_list|(
name|NEG
argument_list|,
name|mode
argument_list|,
name|op1
argument_list|,
name|mode
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|op0
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|tem
expr_stmt|;
continue|continue;
block|}
comment|/* The remaining cases only apply to comparisons with zero.  */
if|if
condition|(
name|const_op
operator|!=
literal|0
condition|)
break|break;
comment|/* When X is ABS or is known positive, 	     (neg X) is< 0 if and only if X != 0.  */
if|if
condition|(
name|sign_bit_comparison_p
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ABS
operator|||
operator|(
name|mode_width
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
name|nonzero_bits
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|mode_width
operator|-
literal|1
operator|)
operator|)
operator|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|op0
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|code
operator|=
operator|(
name|code
operator|==
name|LT
condition|?
name|NE
else|:
name|EQ
operator|)
expr_stmt|;
continue|continue;
block|}
comment|/* If we have NEG of something whose two high-order bits are the 	     same, we know that "(-a)< 0" is equivalent to "a> 0".  */
if|if
condition|(
name|num_sign_bit_copies
argument_list|(
name|op0
argument_list|,
name|mode
argument_list|)
operator|>=
literal|2
condition|)
block|{
name|op0
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|code
operator|=
name|swap_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
name|ROTATE
case|:
comment|/* If we are testing equality and our count is a constant, we 	     can perform the inverse operation on our RHS.  */
if|if
condition|(
name|equality_comparison_p
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|tem
operator|=
name|simplify_binary_operation
argument_list|(
name|ROTATERT
argument_list|,
name|mode
argument_list|,
name|op1
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|op0
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|tem
expr_stmt|;
continue|continue;
block|}
comment|/* If we are doing a< 0 or>= 0 comparison, it means we are testing 	     a particular bit.  Convert it to an AND of a constant of that 	     bit.  This will be converted into a ZERO_EXTRACT.  */
if|if
condition|(
name|const_op
operator|==
literal|0
operator|&&
name|sign_bit_comparison_p
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|mode_width
operator|<=
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|op0
operator|=
name|simplify_and_const_int
argument_list|(
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|mode_width
operator|-
literal|1
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|)
argument_list|)
expr_stmt|;
name|code
operator|=
operator|(
name|code
operator|==
name|LT
condition|?
name|NE
else|:
name|EQ
operator|)
expr_stmt|;
continue|continue;
block|}
comment|/* Fall through.  */
case|case
name|ABS
case|:
comment|/* ABS is ignorable inside an equality comparison with zero.  */
if|if
condition|(
name|const_op
operator|==
literal|0
operator|&&
name|equality_comparison_p
condition|)
block|{
name|op0
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
name|SIGN_EXTEND
case|:
comment|/* Can simplify (compare (zero/sign_extend FOO) CONST) 	     to (compare FOO CONST) if CONST fits in FOO's mode and we 	     are either testing inequality or have an unsigned comparison 	     with ZERO_EXTEND or a signed comparison with SIGN_EXTEND.  */
if|if
condition|(
operator|!
name|unsigned_comparison_p
operator|&&
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|&&
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|const_op
operator|<
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
name|op0
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
name|SUBREG
case|:
comment|/* Check for the case where we are comparing A - C1 with C2, 	     both constants are smaller than 1/2 the maximum positive 	     value in MODE, and the comparison is equality or unsigned. 	     In that case, if A is either zero-extended to MODE or has 	     sufficient sign bits so that the high-order bit in MODE 	     is a copy of the sign in the inner mode, we can prove that it is 	     safe to do the operation in the wider mode.  This simplifies 	     many range checks.  */
if|if
condition|(
name|mode_width
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|subreg_lowpart_p
argument_list|(
name|op0
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SUBREG_REG
argument_list|(
name|op0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|SUBREG_REG
argument_list|(
name|op0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
literal|0
operator|&&
operator|(
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|SUBREG_REG
argument_list|(
name|op0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|/
literal|2
argument_list|)
operator|)
operator|&&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|const_op
operator|<
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|/
literal|2
operator|&&
operator|(
literal|0
operator|==
operator|(
name|nonzero_bits
argument_list|(
name|XEXP
argument_list|(
name|SUBREG_REG
argument_list|(
name|op0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op0
argument_list|)
argument_list|)
argument_list|)
operator|&
operator|~
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|)
operator|||
operator|(
name|num_sign_bit_copies
argument_list|(
name|XEXP
argument_list|(
name|SUBREG_REG
argument_list|(
name|op0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op0
argument_list|)
argument_list|)
argument_list|)
operator|>
call|(
name|unsigned
name|int
call|)
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op0
argument_list|)
argument_list|)
argument_list|)
operator|-
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
block|{
name|op0
operator|=
name|SUBREG_REG
argument_list|(
name|op0
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* If the inner mode is narrower and we are extracting the low part, 	     we can treat the SUBREG as if it were a ZERO_EXTEND.  */
if|if
condition|(
name|subreg_lowpart_p
argument_list|(
name|op0
argument_list|)
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op0
argument_list|)
argument_list|)
argument_list|)
operator|<
name|mode_width
condition|)
comment|/* Fall through */
empty_stmt|;
else|else
break|break;
comment|/* ... fall through ...  */
case|case
name|ZERO_EXTEND
case|:
if|if
condition|(
operator|(
name|unsigned_comparison_p
operator|||
name|equality_comparison_p
operator|)
operator|&&
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|&&
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|const_op
operator|<
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|op0
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
name|PLUS
case|:
comment|/* (eq (plus X A) B) -> (eq X (minus B A)).  We can only do 	     this for equality comparisons due to pathological cases involving 	     overflows.  */
if|if
condition|(
name|equality_comparison_p
operator|&&
literal|0
operator|!=
operator|(
name|tem
operator|=
name|simplify_binary_operation
argument_list|(
name|MINUS
argument_list|,
name|mode
argument_list|,
name|op1
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|op0
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|tem
expr_stmt|;
continue|continue;
block|}
comment|/* (plus (abs X) (const_int -1)) is< 0 if and only if X == 0.  */
if|if
condition|(
name|const_op
operator|==
literal|0
operator|&&
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
operator|==
name|constm1_rtx
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ABS
operator|&&
name|sign_bit_comparison_p
condition|)
block|{
name|op0
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|code
operator|=
operator|(
name|code
operator|==
name|LT
condition|?
name|EQ
else|:
name|NE
operator|)
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
name|MINUS
case|:
comment|/* We used to optimize signed comparisons against zero, but that 	     was incorrect.  Unsigned comparisons against zero (GTU, LEU) 	     arrive here as equality comparisons, or (GEU, LTU) are 	     optimized away.  No need to special-case them.  */
comment|/* (eq (minus A B) C) -> (eq A (plus B C)) or 	     (eq B (minus A C)), whichever simplifies.  We can only do 	     this for equality comparisons due to pathological cases involving 	     overflows.  */
if|if
condition|(
name|equality_comparison_p
operator|&&
literal|0
operator|!=
operator|(
name|tem
operator|=
name|simplify_binary_operation
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|op1
argument_list|)
operator|)
condition|)
block|{
name|op0
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|tem
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|equality_comparison_p
operator|&&
literal|0
operator|!=
operator|(
name|tem
operator|=
name|simplify_binary_operation
argument_list|(
name|MINUS
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op1
argument_list|)
operator|)
condition|)
block|{
name|op0
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|op1
operator|=
name|tem
expr_stmt|;
continue|continue;
block|}
comment|/* The sign bit of (minus (ashiftrt X C) X), where C is the number 	     of bits in X minus 1, is one iff X> 0.  */
if|if
condition|(
name|sign_bit_comparison_p
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ASHIFTRT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|mode_width
operator|-
literal|1
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|op0
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|code
operator|=
operator|(
name|code
operator|==
name|GE
condition|?
name|LE
else|:
name|GT
operator|)
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
name|XOR
case|:
comment|/* (eq (xor A B) C) -> (eq A (xor B C)).  This is a simplification 	     if C is zero or B is a constant.  */
if|if
condition|(
name|equality_comparison_p
operator|&&
literal|0
operator|!=
operator|(
name|tem
operator|=
name|simplify_binary_operation
argument_list|(
name|XOR
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|op1
argument_list|)
operator|)
condition|)
block|{
name|op0
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|tem
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
name|EQ
case|:
case|case
name|NE
case|:
case|case
name|UNEQ
case|:
case|case
name|LTGT
case|:
case|case
name|LT
case|:
case|case
name|LTU
case|:
case|case
name|UNLT
case|:
case|case
name|LE
case|:
case|case
name|LEU
case|:
case|case
name|UNLE
case|:
case|case
name|GT
case|:
case|case
name|GTU
case|:
case|case
name|UNGT
case|:
case|case
name|GE
case|:
case|case
name|GEU
case|:
case|case
name|UNGE
case|:
case|case
name|UNORDERED
case|:
case|case
name|ORDERED
case|:
comment|/* We can't do anything if OP0 is a condition code value, rather 	     than an actual data value.  */
if|if
condition|(
name|const_op
operator|!=
literal|0
ifdef|#
directive|ifdef
name|HAVE_cc0
operator|||
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
operator|==
name|cc0_rtx
endif|#
directive|endif
operator|||
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MODE_CC
condition|)
break|break;
comment|/* Get the two operands being compared.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|COMPARE
condition|)
name|tem
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|,
name|tem1
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|tem
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
operator|,
name|tem1
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Check for the cases where we simply want the result of the 	     earlier test or the opposite of that result.  */
if|if
condition|(
name|code
operator|==
name|NE
operator|||
name|code
operator|==
name|EQ
operator|||
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|&&
operator|(
name|STORE_FLAG_VALUE
operator|&
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|)
operator|)
operator|&&
operator|(
name|code
operator|==
name|LT
operator|||
name|code
operator|==
name|GE
operator|)
operator|)
condition|)
block|{
name|enum
name|rtx_code
name|new_code
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|LT
operator|||
name|code
operator|==
name|NE
condition|)
name|new_code
operator|=
name|GET_CODE
argument_list|(
name|op0
argument_list|)
expr_stmt|;
else|else
name|new_code
operator|=
name|combine_reversed_comparison_code
argument_list|(
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_code
operator|!=
name|UNKNOWN
condition|)
block|{
name|code
operator|=
name|new_code
expr_stmt|;
name|op0
operator|=
name|tem
expr_stmt|;
name|op1
operator|=
name|tem1
expr_stmt|;
continue|continue;
block|}
block|}
break|break;
case|case
name|IOR
case|:
comment|/* The sign bit of (ior (plus X (const_int -1)) X) is nonzero 	     iff X<= 0.  */
if|if
condition|(
name|sign_bit_comparison_p
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|constm1_rtx
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|op0
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|code
operator|=
operator|(
name|code
operator|==
name|GE
condition|?
name|GT
else|:
name|LE
operator|)
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
name|AND
case|:
comment|/* Convert (and (xshift 1 X) Y) to (and (lshiftrt Y X) 1).  This 	     will be converted to a ZERO_EXTRACT later.  */
if|if
condition|(
name|const_op
operator|==
literal|0
operator|&&
name|equality_comparison_p
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ASHIFT
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|const1_rtx
condition|)
block|{
name|op0
operator|=
name|simplify_and_const_int
argument_list|(
name|op0
argument_list|,
name|mode
argument_list|,
name|gen_rtx_LSHIFTRT
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* If we are comparing (and (lshiftrt X C1) C2) for equality with 	     zero and X is a comparison and C1 and C2 describe only bits set 	     in STORE_FLAG_VALUE, we can compare with X.  */
if|if
condition|(
name|const_op
operator|==
literal|0
operator|&&
name|equality_comparison_p
operator|&&
name|mode_width
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LSHIFTRT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>=
literal|0
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|mask
operator|=
operator|(
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|)
operator|<<
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|~
name|STORE_FLAG_VALUE
operator|&
name|mask
operator|)
operator|==
literal|0
operator|&&
operator|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|||
operator|(
operator|(
name|tem
operator|=
name|get_last_value
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|)
operator|)
condition|)
block|{
name|op0
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* If we are doing an equality comparison of an AND of a bit equal 	     to the sign bit, replace this with a LT or GE comparison of 	     the underlying value.  */
if|if
condition|(
name|equality_comparison_p
operator|&&
name|const_op
operator|==
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|mode_width
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|)
operator|==
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|mode_width
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|op0
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|code
operator|=
operator|(
name|code
operator|==
name|EQ
condition|?
name|GE
else|:
name|LT
operator|)
expr_stmt|;
continue|continue;
block|}
comment|/* If this AND operation is really a ZERO_EXTEND from a narrower 	     mode, the constant fits within that mode, and this is either an 	     equality or unsigned comparison, try to do this comparison in 	     the narrower mode.  */
if|if
condition|(
operator|(
name|equality_comparison_p
operator|||
name|unsigned_comparison_p
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|i
operator|=
name|exact_log2
argument_list|(
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|)
operator|+
literal|1
argument_list|)
operator|)
operator|>=
literal|0
operator|&&
name|const_op
operator|>>
name|i
operator|==
literal|0
operator|&&
operator|(
name|tmode
operator|=
name|mode_for_size
argument_list|(
name|i
argument_list|,
name|MODE_INT
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
name|BLKmode
condition|)
block|{
name|op0
operator|=
name|gen_lowpart_for_combine
argument_list|(
name|tmode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* If this is (and:M1 (subreg:M2 X 0) (const_int C1)) where C1 fits 	     in both M1 and M2 and the SUBREG is either paradoxical or 	     represents the low part, permute the SUBREG and the AND and 	     try again.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
comment|/* Require an integral mode, to avoid creating something like 		 (AND:SF ...).  */
operator|&&
name|SCALAR_INT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|(
literal|0
ifdef|#
directive|ifdef
name|WORD_REGISTER_OPERATIONS
operator|||
operator|(
operator|(
name|mode_width
operator|>
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|)
operator|&&
name|mode_width
operator|<=
name|BITS_PER_WORD
operator|)
endif|#
directive|endif
operator|||
operator|(
operator|(
name|mode_width
operator|<=
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|)
operator|&&
name|subreg_lowpart_p
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|)
ifndef|#
directive|ifndef
name|WORD_REGISTER_OPERATIONS
comment|/* It is unsafe to commute the AND into the SUBREG if the SUBREG 		 is paradoxical and WORD_REGISTER_OPERATIONS is not defined. 		 As originally written the upper bits have a defined value 		 due to the AND operation.  However, if we commute the AND 		 inside the SUBREG then they no longer have defined values 		 and the meaning of the code has been changed.  */
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|<=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|)
endif|#
directive|endif
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|mode_width
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|&&
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&
operator|~
name|mask
operator|)
operator|==
literal|0
operator|&&
literal|0
operator|==
operator|(
operator|~
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|mask
operator|&&
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|op0
operator|=
name|gen_lowpart_for_combine
argument_list|(
name|mode
argument_list|,
name|gen_binary
argument_list|(
name|AND
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Convert (ne (and (lshiftrt (not X)) 1) 0) to 	     (eq (and (lshiftrt X) 1) 0).  */
if|if
condition|(
name|const_op
operator|==
literal|0
operator|&&
name|equality_comparison_p
operator|&&
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
operator|==
name|const1_rtx
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LSHIFTRT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NOT
condition|)
block|{
name|op0
operator|=
name|simplify_and_const_int
argument_list|(
name|op0
argument_list|,
name|mode
argument_list|,
name|gen_rtx_LSHIFTRT
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
argument_list|)
expr_stmt|;
name|code
operator|=
operator|(
name|code
operator|==
name|NE
condition|?
name|EQ
else|:
name|NE
operator|)
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
name|ASHIFT
case|:
comment|/* If we have (compare (ashift FOO N) (const_int C)) and 	     the high order N bits of FOO (N+1 if an inequality comparison) 	     are known to be zero, we can do this by comparing FOO with C 	     shifted right N bits so long as the low-order N bits of C are 	     zero.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>=
literal|0
operator|&&
operator|(
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|+
operator|!
name|equality_comparison_p
operator|)
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|&&
operator|(
operator|(
name|const_op
operator|&
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
operator|)
operator|&&
name|mode_width
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
name|nonzero_bits
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|&
operator|~
operator|(
name|mask
operator|>>
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|+
operator|!
name|equality_comparison_p
operator|)
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* We must perform a logical shift, not an arithmetic one, 		 as we want the top N bits of C to be zero.  */
name|unsigned
name|HOST_WIDE_INT
name|temp
init|=
name|const_op
operator|&
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|temp
operator|>>=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|op1
operator|=
name|gen_int_mode
argument_list|(
name|temp
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|op0
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* If we are doing a sign bit comparison, it means we are testing 	     a particular bit.  Convert it to the appropriate AND.  */
if|if
condition|(
name|sign_bit_comparison_p
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|mode_width
operator|<=
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|op0
operator|=
name|simplify_and_const_int
argument_list|(
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|mode_width
operator|-
literal|1
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|)
argument_list|)
expr_stmt|;
name|code
operator|=
operator|(
name|code
operator|==
name|LT
condition|?
name|NE
else|:
name|EQ
operator|)
expr_stmt|;
continue|continue;
block|}
comment|/* If this an equality comparison with zero and we are shifting 	     the low bit to the sign bit, we can convert this to an AND of the 	     low-order bit.  */
if|if
condition|(
name|const_op
operator|==
literal|0
operator|&&
name|equality_comparison_p
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|mode_width
operator|-
literal|1
condition|)
block|{
name|op0
operator|=
name|simplify_and_const_int
argument_list|(
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
name|ASHIFTRT
case|:
comment|/* If this is an equality comparison with zero, we can do this 	     as a logical shift, which might be much simpler.  */
if|if
condition|(
name|equality_comparison_p
operator|&&
name|const_op
operator|==
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|op0
operator|=
name|simplify_shift_const
argument_list|(
name|NULL_RTX
argument_list|,
name|LSHIFTRT
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* If OP0 is a sign extension and CODE is not an unsigned comparison, 	     do the comparison in a narrower mode.  */
if|if
condition|(
operator|!
name|unsigned_comparison_p
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ASHIFT
operator|&&
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
operator|==
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|&&
operator|(
name|tmode
operator|=
name|mode_for_size
argument_list|(
name|mode_width
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|MODE_INT
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
name|BLKmode
operator|&&
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|const_op
operator|+
operator|(
name|GET_MODE_MASK
argument_list|(
name|tmode
argument_list|)
operator|>>
literal|1
operator|)
operator|+
literal|1
operator|)
operator|<=
name|GET_MODE_MASK
argument_list|(
name|tmode
argument_list|)
operator|)
condition|)
block|{
name|op0
operator|=
name|gen_lowpart_for_combine
argument_list|(
name|tmode
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Likewise if OP0 is a PLUS of a sign extension with a 	     constant, which is usually represented with the PLUS 	     between the shifts.  */
if|if
condition|(
operator|!
name|unsigned_comparison_p
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ASHIFT
operator|&&
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
operator|==
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|&&
operator|(
name|tmode
operator|=
name|mode_for_size
argument_list|(
name|mode_width
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|MODE_INT
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
name|BLKmode
operator|&&
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|const_op
operator|+
operator|(
name|GET_MODE_MASK
argument_list|(
name|tmode
argument_list|)
operator|>>
literal|1
operator|)
operator|+
literal|1
operator|)
operator|<=
name|GET_MODE_MASK
argument_list|(
name|tmode
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|inner
init|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|add_const
init|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|new_const
init|=
name|gen_binary
argument_list|(
name|ASHIFTRT
argument_list|,
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|,
name|add_const
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|op0
operator|=
name|gen_binary
argument_list|(
name|PLUS
argument_list|,
name|tmode
argument_list|,
name|gen_lowpart_for_combine
argument_list|(
name|tmode
argument_list|,
name|inner
argument_list|)
argument_list|,
name|new_const
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* ... fall through ...  */
case|case
name|LSHIFTRT
case|:
comment|/* If we have (compare (xshiftrt FOO N) (const_int C)) and 	     the low order N bits of FOO are known to be zero, we can do this 	     by comparing FOO with C shifted left N bits so long as no 	     overflow occurs.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>=
literal|0
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|mode_width
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
name|nonzero_bits
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|&
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|const_op
operator|+
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|LSHIFTRT
condition|?
operator|(
operator|(
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|>>
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>>
literal|1
operator|)
operator|+
literal|1
operator|)
else|:
literal|0
operator|)
operator|)
operator|<=
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|>>
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/* If the shift was logical, then we must make the condition 		 unsigned.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|LSHIFTRT
condition|)
name|code
operator|=
name|unsigned_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|const_op
operator|<<=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|op1
operator|=
name|GEN_INT
argument_list|(
name|const_op
argument_list|)
expr_stmt|;
name|op0
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* If we are using this shift to extract just the sign bit, we 	     can replace this with an LT or GE comparison.  */
if|if
condition|(
name|const_op
operator|==
literal|0
operator|&&
operator|(
name|equality_comparison_p
operator|||
name|sign_bit_comparison_p
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|mode_width
operator|-
literal|1
condition|)
block|{
name|op0
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|code
operator|=
operator|(
name|code
operator|==
name|NE
operator|||
name|code
operator|==
name|GT
condition|?
name|LT
else|:
name|GE
operator|)
expr_stmt|;
continue|continue;
block|}
break|break;
default|default:
break|break;
block|}
break|break;
block|}
comment|/* Now make any compound operations involved in this comparison.  Then,      check for an outmost SUBREG on OP0 that is not doing anything or is      paradoxical.  The latter transformation must only be performed when      it is known that the "extra" bits will be the same in op0 and op1 or      that they don't matter.  There are three cases to consider:       1. SUBREG_REG (op0) is a register.  In this case the bits are don't      care bits and we can assume they have any convenient value.  So      making the transformation is safe.       2. SUBREG_REG (op0) is a memory and LOAD_EXTEND_OP is not defined.      In this case the upper bits of op0 are undefined.  We should not make      the simplification in that case as we do not know the contents of      those bits.       3. SUBREG_REG (op0) is a memory and LOAD_EXTEND_OP is defined and not      NIL.  In that case we know those bits are zeros or ones.  We must      also be sure that they are the same as the upper bits of op1.       We can never remove a SUBREG for a non-equality comparison because      the sign bit is in a different place in the underlying object.  */
name|op0
operator|=
name|make_compound_operation
argument_list|(
name|op0
argument_list|,
name|op1
operator|==
name|const0_rtx
condition|?
name|COMPARE
else|:
name|SET
argument_list|)
expr_stmt|;
name|op1
operator|=
name|make_compound_operation
argument_list|(
name|op1
argument_list|,
name|SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SUBREG
operator|&&
name|subreg_lowpart_p
argument_list|(
name|op0
argument_list|)
comment|/* Case 3 above, to sometimes allow (subreg (mem x)), isn't 	 implemented.  */
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|&&
operator|(
name|code
operator|==
name|NE
operator|||
name|code
operator|==
name|EQ
operator|)
condition|)
block|{
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op0
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|op0
operator|=
name|SUBREG_REG
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|gen_lowpart_for_combine
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op0
argument_list|)
argument_list|)
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|&&
operator|(
name|nonzero_bits
argument_list|(
name|SUBREG_REG
argument_list|(
name|op0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op0
argument_list|)
argument_list|)
argument_list|)
operator|&
operator|~
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|tem
operator|=
name|gen_lowpart_for_combine
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op0
argument_list|)
argument_list|)
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nonzero_bits
argument_list|(
name|tem
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op0
argument_list|)
argument_list|)
argument_list|)
operator|&
operator|~
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|op0
operator|=
name|SUBREG_REG
argument_list|(
name|op0
argument_list|)
operator|,
name|op1
operator|=
name|tem
expr_stmt|;
block|}
block|}
comment|/* We now do the opposite procedure: Some machines don't have compare      insns in all modes.  If OP0's mode is an integer mode smaller than a      word and we can't do a compare in that mode, see if there is a larger      mode for which we can do the compare.  There are a number of cases in      which we can use the wider mode.  */
name|mode
operator|=
name|GET_MODE
argument_list|(
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<
name|UNITS_PER_WORD
operator|&&
operator|!
name|have_insn_for
argument_list|(
name|COMPARE
argument_list|,
name|mode
argument_list|)
condition|)
for|for
control|(
name|tmode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
init|;
operator|(
name|tmode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|tmode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|)
condition|;
name|tmode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|tmode
argument_list|)
control|)
if|if
condition|(
name|have_insn_for
argument_list|(
name|COMPARE
argument_list|,
name|tmode
argument_list|)
condition|)
block|{
name|int
name|zero_extended
decl_stmt|;
comment|/* If the only nonzero bits in OP0 and OP1 are those in the 	     narrower mode and this is an equality or unsigned comparison, 	     we can use the wider mode.  Similarly for sign-extended 	     values, in which case it is true for all comparisons.  */
name|zero_extended
operator|=
operator|(
operator|(
name|code
operator|==
name|EQ
operator|||
name|code
operator|==
name|NE
operator|||
name|code
operator|==
name|GEU
operator|||
name|code
operator|==
name|GTU
operator|||
name|code
operator|==
name|LEU
operator|||
name|code
operator|==
name|LTU
operator|)
operator|&&
operator|(
name|nonzero_bits
argument_list|(
name|op0
argument_list|,
name|tmode
argument_list|)
operator|&
operator|~
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|||
operator|(
name|nonzero_bits
argument_list|(
name|op1
argument_list|,
name|tmode
argument_list|)
operator|&
operator|~
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|)
operator|==
literal|0
operator|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|zero_extended
operator|||
operator|(
operator|(
name|num_sign_bit_copies
argument_list|(
name|op0
argument_list|,
name|tmode
argument_list|)
operator|>
call|(
name|unsigned
name|int
call|)
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|tmode
argument_list|)
operator|-
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|num_sign_bit_copies
argument_list|(
name|op1
argument_list|,
name|tmode
argument_list|)
operator|>
call|(
name|unsigned
name|int
call|)
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|tmode
argument_list|)
operator|-
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* If OP0 is an AND and we don't have an AND in MODE either, 		 make a new AND in the proper mode.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|AND
operator|&&
operator|!
name|have_insn_for
argument_list|(
name|AND
argument_list|,
name|mode
argument_list|)
condition|)
name|op0
operator|=
name|gen_binary
argument_list|(
name|AND
argument_list|,
name|tmode
argument_list|,
name|gen_lowpart_for_combine
argument_list|(
name|tmode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|gen_lowpart_for_combine
argument_list|(
name|tmode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|gen_lowpart_for_combine
argument_list|(
name|tmode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|zero_extended
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
condition|)
name|op1
operator|=
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|&
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|op1
operator|=
name|gen_lowpart_for_combine
argument_list|(
name|tmode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* If this is a test for negative, we can make an explicit 	     test of the sign bit.  */
if|if
condition|(
name|op1
operator|==
name|const0_rtx
operator|&&
operator|(
name|code
operator|==
name|LT
operator|||
name|code
operator|==
name|GE
operator|)
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|op0
operator|=
name|gen_binary
argument_list|(
name|AND
argument_list|,
name|tmode
argument_list|,
name|gen_lowpart_for_combine
argument_list|(
name|tmode
argument_list|,
name|op0
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
operator|(
name|code
operator|==
name|LT
operator|)
condition|?
name|NE
else|:
name|EQ
expr_stmt|;
break|break;
block|}
block|}
ifdef|#
directive|ifdef
name|CANONICALIZE_COMPARISON
comment|/* If this machine only supports a subset of valid comparisons, see if we      can convert an unsupported one into a supported one.  */
name|CANONICALIZE_COMPARISON
argument_list|(
name|code
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|pop0
operator|=
name|op0
expr_stmt|;
operator|*
name|pop1
operator|=
name|op1
expr_stmt|;
return|return
name|code
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Like jump.c' reversed_comparison_code, but use combine infrastructure for    searching backward.  */
end_comment

begin_function
specifier|static
name|enum
name|rtx_code
name|combine_reversed_comparison_code
parameter_list|(
name|exp
parameter_list|)
name|rtx
name|exp
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code1
init|=
name|reversed_comparison_code
argument_list|(
name|exp
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|rtx
name|x
decl_stmt|;
if|if
condition|(
name|code1
operator|!=
name|UNKNOWN
operator|||
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|MODE_CC
condition|)
return|return
name|code1
return|;
comment|/* Otherwise try and find where the condition codes were last set and      use that.  */
name|x
operator|=
name|get_last_value
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|x
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|COMPARE
condition|)
return|return
name|UNKNOWN
return|;
return|return
name|reversed_comparison_code_parts
argument_list|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return comparison with reversed code of EXP and operands OP0 and OP1.    Return NULL_RTX in case we fail to do the reversal.  */
end_comment

begin_function
specifier|static
name|rtx
name|reversed_comparison
parameter_list|(
name|exp
parameter_list|,
name|mode
parameter_list|,
name|op0
parameter_list|,
name|op1
parameter_list|)
name|rtx
name|exp
decl_stmt|,
name|op0
decl_stmt|,
name|op1
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|enum
name|rtx_code
name|reversed_code
init|=
name|combine_reversed_comparison_code
argument_list|(
name|exp
argument_list|)
decl_stmt|;
if|if
condition|(
name|reversed_code
operator|==
name|UNKNOWN
condition|)
return|return
name|NULL_RTX
return|;
else|else
return|return
name|gen_binary
argument_list|(
name|reversed_code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Utility function for following routine.  Called when X is part of a value    being stored into reg_last_set_value.  Sets reg_last_set_table_tick    for each register mentioned.  Similar to mention_regs in cse.c  */
end_comment

begin_function
specifier|static
name|void
name|update_table_tick
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|REG
condition|)
block|{
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|endregno
init|=
name|regno
operator|+
operator|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|?
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
else|:
literal|1
operator|)
decl_stmt|;
name|unsigned
name|int
name|r
decl_stmt|;
for|for
control|(
name|r
operator|=
name|regno
init|;
name|r
operator|<
name|endregno
condition|;
name|r
operator|++
control|)
name|reg_last_set_table_tick
index|[
name|r
index|]
operator|=
name|label_tick
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
comment|/* Note that we can't have an "E" in values stored; see        get_last_value_validate.  */
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
comment|/* Check for identical subexpressions.  If x contains 	   identical subexpression we only have to traverse one of 	   them.  */
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
operator|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'2'
operator|||
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'c'
operator|)
condition|)
block|{
comment|/* Note that at this point x1 has already been 	       processed.  */
name|rtx
name|x0
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|x1
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* If x0 and x1 are identical then there is no need to 	       process x0.  */
if|if
condition|(
name|x0
operator|==
name|x1
condition|)
break|break;
comment|/* If x0 is identical to a subexpression of x1 then while 	       processing x1, x0 has already been processed.  Thus we 	       are done with x.  */
if|if
condition|(
operator|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|x1
argument_list|)
argument_list|)
operator|==
literal|'2'
operator|||
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|x1
argument_list|)
argument_list|)
operator|==
literal|'c'
operator|)
operator|&&
operator|(
name|x0
operator|==
name|XEXP
argument_list|(
name|x1
argument_list|,
literal|0
argument_list|)
operator|||
name|x0
operator|==
name|XEXP
argument_list|(
name|x1
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
break|break;
comment|/* If x1 is identical to a subexpression of x0 then we 	       still have to process the rest of x0.  */
if|if
condition|(
operator|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|x0
argument_list|)
argument_list|)
operator|==
literal|'2'
operator|||
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|x0
argument_list|)
argument_list|)
operator|==
literal|'c'
operator|)
operator|&&
operator|(
name|x1
operator|==
name|XEXP
argument_list|(
name|x0
argument_list|,
literal|0
argument_list|)
operator|||
name|x1
operator|==
name|XEXP
argument_list|(
name|x0
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
block|{
name|update_table_tick
argument_list|(
name|XEXP
argument_list|(
name|x0
argument_list|,
name|x1
operator|==
name|XEXP
argument_list|(
name|x0
argument_list|,
literal|0
argument_list|)
condition|?
literal|1
else|:
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|update_table_tick
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Record that REG is set to VALUE in insn INSN.  If VALUE is zero, we    are saying that the register is clobbered and we no longer know its    value.  If INSN is zero, don't update reg_last_set; this is only permitted    with VALUE also zero and is used to invalidate the register.  */
end_comment

begin_function
specifier|static
name|void
name|record_value_for_reg
parameter_list|(
name|reg
parameter_list|,
name|insn
parameter_list|,
name|value
parameter_list|)
name|rtx
name|reg
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|rtx
name|value
decl_stmt|;
block|{
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|reg
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|endregno
init|=
name|regno
operator|+
operator|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|?
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
else|:
literal|1
operator|)
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* If VALUE contains REG and we have a previous value for REG, substitute      the previous value.  */
if|if
condition|(
name|value
operator|&&
name|insn
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|reg
argument_list|,
name|value
argument_list|)
condition|)
block|{
name|rtx
name|tem
decl_stmt|;
comment|/* Set things up so get_last_value is allowed to see anything set up to 	 our insn.  */
name|subst_low_cuid
operator|=
name|INSN_CUID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|tem
operator|=
name|get_last_value
argument_list|(
name|reg
argument_list|)
expr_stmt|;
comment|/* If TEM is simply a binary operation with two CLOBBERs as operands, 	 it isn't going to be useful and will take a lot of time to process, 	 so just use the CLOBBER.  */
if|if
condition|(
name|tem
condition|)
block|{
if|if
condition|(
operator|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|==
literal|'2'
operator|||
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|==
literal|'c'
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CLOBBER
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
name|tem
operator|=
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|value
operator|=
name|replace_rtx
argument_list|(
name|copy_rtx
argument_list|(
name|value
argument_list|)
argument_list|,
name|reg
argument_list|,
name|tem
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* For each register modified, show we don't know its value, that      we don't know about its bitwise content, that its value has been      updated, and that we don't know the location of the death of the      register.  */
for|for
control|(
name|i
operator|=
name|regno
init|;
name|i
operator|<
name|endregno
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|insn
condition|)
name|reg_last_set
index|[
name|i
index|]
operator|=
name|insn
expr_stmt|;
name|reg_last_set_value
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|reg_last_set_mode
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|reg_last_set_nonzero_bits
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|reg_last_set_sign_bit_copies
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|reg_last_death
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Mark registers that are being referenced in this value.  */
if|if
condition|(
name|value
condition|)
name|update_table_tick
argument_list|(
name|value
argument_list|)
expr_stmt|;
comment|/* Now update the status of each register being set.      If someone is using this register in this block, set this register      to invalid since we will get confused between the two lives in this      basic block.  This makes using this register always invalid.  In cse, we      scan the table to invalidate all entries using this register, but this      is too much work for us.  */
for|for
control|(
name|i
operator|=
name|regno
init|;
name|i
operator|<
name|endregno
condition|;
name|i
operator|++
control|)
block|{
name|reg_last_set_label
index|[
name|i
index|]
operator|=
name|label_tick
expr_stmt|;
if|if
condition|(
name|value
operator|&&
name|reg_last_set_table_tick
index|[
name|i
index|]
operator|==
name|label_tick
condition|)
name|reg_last_set_invalid
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
else|else
name|reg_last_set_invalid
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* The value being assigned might refer to X (like in "x++;").  In that      case, we must replace it with (clobber (const_int 0)) to prevent      infinite loops.  */
if|if
condition|(
name|value
operator|&&
operator|!
name|get_last_value_validate
argument_list|(
operator|&
name|value
argument_list|,
name|insn
argument_list|,
name|reg_last_set_label
index|[
name|regno
index|]
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|value
operator|=
name|copy_rtx
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|get_last_value_validate
argument_list|(
operator|&
name|value
argument_list|,
name|insn
argument_list|,
name|reg_last_set_label
index|[
name|regno
index|]
argument_list|,
literal|1
argument_list|)
condition|)
name|value
operator|=
literal|0
expr_stmt|;
block|}
comment|/* For the main register being modified, update the value, the mode, the      nonzero bits, and the number of sign bit copies.  */
name|reg_last_set_value
index|[
name|regno
index|]
operator|=
name|value
expr_stmt|;
if|if
condition|(
name|value
condition|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|reg
argument_list|)
decl_stmt|;
name|subst_low_cuid
operator|=
name|INSN_CUID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|reg_last_set_mode
index|[
name|regno
index|]
operator|=
name|mode
expr_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
condition|)
name|mode
operator|=
name|nonzero_bits_mode
expr_stmt|;
name|reg_last_set_nonzero_bits
index|[
name|regno
index|]
operator|=
name|nonzero_bits
argument_list|(
name|value
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|reg_last_set_sign_bit_copies
index|[
name|regno
index|]
operator|=
name|num_sign_bit_copies
argument_list|(
name|value
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Called via note_stores from record_dead_and_set_regs to handle one    SET or CLOBBER in an insn.  DATA is the instruction in which the    set is occurring.  */
end_comment

begin_function
specifier|static
name|void
name|record_dead_and_set_regs_1
parameter_list|(
name|dest
parameter_list|,
name|setter
parameter_list|,
name|data
parameter_list|)
name|rtx
name|dest
decl_stmt|,
name|setter
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|rtx
name|record_dead_insn
init|=
operator|(
name|rtx
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
condition|)
name|dest
operator|=
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
condition|)
block|{
comment|/* If we are setting the whole register, we know its value.  Otherwise 	 show that we don't know the value.  We can handle SUBREG in 	 some cases.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|setter
argument_list|)
operator|==
name|SET
operator|&&
name|dest
operator|==
name|SET_DEST
argument_list|(
name|setter
argument_list|)
condition|)
name|record_value_for_reg
argument_list|(
name|dest
argument_list|,
name|record_dead_insn
argument_list|,
name|SET_SRC
argument_list|(
name|setter
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|setter
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|setter
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|setter
argument_list|)
argument_list|)
operator|==
name|dest
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|<=
name|BITS_PER_WORD
operator|&&
name|subreg_lowpart_p
argument_list|(
name|SET_DEST
argument_list|(
name|setter
argument_list|)
argument_list|)
condition|)
name|record_value_for_reg
argument_list|(
name|dest
argument_list|,
name|record_dead_insn
argument_list|,
name|gen_lowpart_for_combine
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|setter
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|record_value_for_reg
argument_list|(
name|dest
argument_list|,
name|record_dead_insn
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
comment|/* Ignore pushes, they clobber nothing.  */
operator|&&
operator|!
name|push_operand
argument_list|(
name|dest
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
condition|)
name|mem_last_set
operator|=
name|INSN_CUID
argument_list|(
name|record_dead_insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Update the records of when each REG was most recently set or killed    for the things done by INSN.  This is the last thing done in processing    INSN in the combiner loop.     We update reg_last_set, reg_last_set_value, reg_last_set_mode,    reg_last_set_nonzero_bits, reg_last_set_sign_bit_copies, reg_last_death,    and also the similar information mem_last_set (which insn most recently    modified memory) and last_call_cuid (which insn was the most recent    subroutine call).  */
end_comment

begin_function
specifier|static
name|void
name|record_dead_and_set_regs
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|link
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
block|{
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_DEAD
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|endregno
init|=
name|regno
operator|+
operator|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|?
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
else|:
literal|1
operator|)
decl_stmt|;
for|for
control|(
name|i
operator|=
name|regno
init|;
name|i
operator|<
name|endregno
condition|;
name|i
operator|++
control|)
name|reg_last_death
index|[
name|i
index|]
operator|=
name|insn
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_INC
condition|)
name|record_value_for_reg
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|regs_invalidated_by_call
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|reg_last_set_value
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|reg_last_set_mode
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|reg_last_set_nonzero_bits
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|reg_last_set_sign_bit_copies
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|reg_last_death
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|last_call_cuid
operator|=
name|mem_last_set
operator|=
name|INSN_CUID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Don't bother recording what this insn does.  It might set the 	 return value register, but we can't combine into a call 	 pattern anyway, so there's no point trying (and it may cause 	 a crash, if e.g. we wind up asking for last_set_value of a 	 SUBREG of the return value register).  */
return|return;
block|}
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|record_dead_and_set_regs_1
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If a SUBREG has the promoted bit set, it is in fact a property of the    register present in the SUBREG, so for each such SUBREG go back and    adjust nonzero and sign bit information of the registers that are    known to have some zero/sign bits set.     This is needed because when combine blows the SUBREGs away, the    information on zero/sign bits is lost and further combines can be    missed because of that.  */
end_comment

begin_function
specifier|static
name|void
name|record_promoted_value
parameter_list|(
name|insn
parameter_list|,
name|subreg
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|subreg
decl_stmt|;
block|{
name|rtx
name|links
decl_stmt|,
name|set
decl_stmt|;
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|subreg
argument_list|)
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|subreg
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
return|return;
for|for
control|(
name|links
operator|=
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
init|;
name|links
condition|;
control|)
block|{
name|insn
operator|=
name|XEXP
argument_list|(
name|links
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|!=
name|regno
operator|||
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|subreg
argument_list|)
argument_list|)
condition|)
block|{
name|links
operator|=
name|XEXP
argument_list|(
name|links
argument_list|,
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|reg_last_set
index|[
name|regno
index|]
operator|==
name|insn
condition|)
block|{
if|if
condition|(
name|SUBREG_PROMOTED_UNSIGNED_P
argument_list|(
name|subreg
argument_list|)
operator|>
literal|0
condition|)
name|reg_last_set_nonzero_bits
index|[
name|regno
index|]
operator|&=
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|regno
operator|=
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
name|links
operator|=
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Scan X for promoted SUBREGs.  For each one found,    note what it implies to the registers used in it.  */
end_comment

begin_function
specifier|static
name|void
name|check_promoted_subreg
parameter_list|(
name|insn
parameter_list|,
name|x
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|x
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|record_promoted_value
argument_list|(
name|insn
argument_list|,
name|x
argument_list|)
expr_stmt|;
else|else
block|{
specifier|const
name|char
modifier|*
name|format
init|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
switch|switch
condition|(
name|format
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'e'
case|:
name|check_promoted_subreg
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
case|case
literal|'E'
case|:
if|if
condition|(
name|XVEC
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|check_promoted_subreg
argument_list|(
name|insn
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Utility routine for the following function.  Verify that all the registers    mentioned in *LOC are valid when *LOC was part of a value set when    label_tick == TICK.  Return 0 if some are not.     If REPLACE is nonzero, replace the invalid reference with    (clobber (const_int 0)) and return 1.  This replacement is useful because    we often can get useful information about the form of a value (e.g., if    it was produced by a shift that always produces -1 or 0) even though    we don't know exactly what registers it was produced from.  */
end_comment

begin_function
specifier|static
name|int
name|get_last_value_validate
parameter_list|(
name|loc
parameter_list|,
name|insn
parameter_list|,
name|tick
parameter_list|,
name|replace
parameter_list|)
name|rtx
modifier|*
name|loc
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|tick
decl_stmt|;
name|int
name|replace
decl_stmt|;
block|{
name|rtx
name|x
init|=
operator|*
name|loc
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
block|{
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|endregno
init|=
name|regno
operator|+
operator|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|?
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
else|:
literal|1
operator|)
decl_stmt|;
name|unsigned
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|regno
init|;
name|j
operator|<
name|endregno
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|reg_last_set_invalid
index|[
name|j
index|]
comment|/* If this is a pseudo-register that was only set once and not 	       live at the beginning of the function, it is always valid.  */
operator|||
operator|(
operator|!
operator|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|REG_N_SETS
argument_list|(
name|regno
argument_list|)
operator|==
literal|1
operator|&&
operator|(
operator|!
name|REGNO_REG_SET_P
argument_list|(
name|ENTRY_BLOCK_PTR
operator|->
name|next_bb
operator|->
name|global_live_at_start
argument_list|,
name|regno
argument_list|)
operator|)
operator|)
operator|&&
name|reg_last_set_label
index|[
name|j
index|]
operator|>
name|tick
operator|)
condition|)
block|{
if|if
condition|(
name|replace
condition|)
operator|*
name|loc
operator|=
name|gen_rtx_CLOBBER
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
return|return
name|replace
return|;
block|}
return|return
literal|1
return|;
block|}
comment|/* If this is a memory reference, make sure that there were      no stores after it that might have clobbered the value.  We don't      have alias info, so we assume any store invalidates it.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|RTX_UNCHANGING_P
argument_list|(
name|x
argument_list|)
operator|&&
name|INSN_CUID
argument_list|(
name|insn
argument_list|)
operator|<=
name|mem_last_set
condition|)
block|{
if|if
condition|(
name|replace
condition|)
operator|*
name|loc
operator|=
name|gen_rtx_CLOBBER
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
return|return
name|replace
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
comment|/* Check for identical subexpressions.  If x contains 	     identical subexpression we only have to traverse one of 	     them.  */
if|if
condition|(
name|i
operator|==
literal|1
operator|&&
operator|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
literal|'2'
operator|||
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
literal|'c'
operator|)
condition|)
block|{
comment|/* Note that at this point x0 has already been checked 		 and found valid.  */
name|rtx
name|x0
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|x1
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* If x0 and x1 are identical then x is also valid.  */
if|if
condition|(
name|x0
operator|==
name|x1
condition|)
return|return
literal|1
return|;
comment|/* If x1 is identical to a subexpression of x0 then 		 while checking x0, x1 has already been checked.  Thus 		 it is valid and so as x.  */
if|if
condition|(
operator|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|x0
argument_list|)
argument_list|)
operator|==
literal|'2'
operator|||
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|x0
argument_list|)
argument_list|)
operator|==
literal|'c'
operator|)
operator|&&
operator|(
name|x1
operator|==
name|XEXP
argument_list|(
name|x0
argument_list|,
literal|0
argument_list|)
operator|||
name|x1
operator|==
name|XEXP
argument_list|(
name|x0
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
comment|/* If x0 is identical to a subexpression of x1 then x is 		 valid iff the rest of x1 is valid.  */
if|if
condition|(
operator|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|x1
argument_list|)
argument_list|)
operator|==
literal|'2'
operator|||
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|x1
argument_list|)
argument_list|)
operator|==
literal|'c'
operator|)
operator|&&
operator|(
name|x0
operator|==
name|XEXP
argument_list|(
name|x1
argument_list|,
literal|0
argument_list|)
operator|||
name|x0
operator|==
name|XEXP
argument_list|(
name|x1
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
return|return
name|get_last_value_validate
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x1
argument_list|,
name|x0
operator|==
name|XEXP
argument_list|(
name|x1
argument_list|,
literal|0
argument_list|)
condition|?
literal|1
else|:
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|,
name|tick
argument_list|,
name|replace
argument_list|)
return|;
block|}
if|if
condition|(
name|get_last_value_validate
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|,
name|tick
argument_list|,
name|replace
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
comment|/* Don't bother with these.  They shouldn't occur anyway.  */
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
return|return
literal|0
return|;
block|}
comment|/* If we haven't found a reason for it to be invalid, it is valid.  */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Get the last value assigned to X, if known.  Some registers    in the value may be replaced with (clobber (const_int 0)) if their value    is known longer known reliably.  */
end_comment

begin_function
specifier|static
name|rtx
name|get_last_value
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|unsigned
name|int
name|regno
decl_stmt|;
name|rtx
name|value
decl_stmt|;
comment|/* If this is a non-paradoxical SUBREG, get the value of its operand and      then convert it to the desired mode.  If this is a paradoxical SUBREG,      we cannot predict what values the "extra" bits might have.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
operator|&&
name|subreg_lowpart_p
argument_list|(
name|x
argument_list|)
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|value
operator|=
name|get_last_value
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|gen_lowpart_for_combine
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|value
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
name|regno
operator|=
name|REGNO
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|value
operator|=
name|reg_last_set_value
index|[
name|regno
index|]
expr_stmt|;
comment|/* If we don't have a value, or if it isn't for this basic block and      it's either a hard register, set more than once, or it's a live      at the beginning of the function, return 0.       Because if it's not live at the beginning of the function then the reg      is always set before being used (is never used without being set).      And, if it's set only once, and it's always set before use, then all      uses must have the same last value, even if it's not from this basic      block.  */
if|if
condition|(
name|value
operator|==
literal|0
operator|||
operator|(
name|reg_last_set_label
index|[
name|regno
index|]
operator|!=
name|label_tick
operator|&&
operator|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|||
name|REG_N_SETS
argument_list|(
name|regno
argument_list|)
operator|!=
literal|1
operator|||
operator|(
name|REGNO_REG_SET_P
argument_list|(
name|ENTRY_BLOCK_PTR
operator|->
name|next_bb
operator|->
name|global_live_at_start
argument_list|,
name|regno
argument_list|)
operator|)
operator|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* If the value was set in a later insn than the ones we are processing,      we can't use it even if the register was only set once.  */
if|if
condition|(
name|INSN_CUID
argument_list|(
name|reg_last_set
index|[
name|regno
index|]
argument_list|)
operator|>=
name|subst_low_cuid
condition|)
return|return
literal|0
return|;
comment|/* If the value has all its registers valid, return it.  */
if|if
condition|(
name|get_last_value_validate
argument_list|(
operator|&
name|value
argument_list|,
name|reg_last_set
index|[
name|regno
index|]
argument_list|,
name|reg_last_set_label
index|[
name|regno
index|]
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|value
return|;
comment|/* Otherwise, make a copy and replace any invalid register with      (clobber (const_int 0)).  If that fails for some reason, return 0.  */
name|value
operator|=
name|copy_rtx
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_last_value_validate
argument_list|(
operator|&
name|value
argument_list|,
name|reg_last_set
index|[
name|regno
index|]
argument_list|,
name|reg_last_set_label
index|[
name|regno
index|]
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|value
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if expression X refers to a REG or to memory    that is set in an instruction more recent than FROM_CUID.  */
end_comment

begin_function
specifier|static
name|int
name|use_crosses_set_p
parameter_list|(
name|x
parameter_list|,
name|from_cuid
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|int
name|from_cuid
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|REG
condition|)
block|{
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|unsigned
name|endreg
init|=
name|regno
operator|+
operator|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|?
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
else|:
literal|1
operator|)
decl_stmt|;
ifdef|#
directive|ifdef
name|PUSH_ROUNDING
comment|/* Don't allow uses of the stack pointer to be moved, 	 because we don't know whether the move crosses a push insn.  */
if|if
condition|(
name|regno
operator|==
name|STACK_POINTER_REGNUM
operator|&&
name|PUSH_ARGS
condition|)
return|return
literal|1
return|;
endif|#
directive|endif
for|for
control|(
init|;
name|regno
operator|<
name|endreg
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|reg_last_set
index|[
name|regno
index|]
operator|&&
name|INSN_CUID
argument_list|(
name|reg_last_set
index|[
name|regno
index|]
argument_list|)
operator|>
name|from_cuid
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|code
operator|==
name|MEM
operator|&&
name|mem_last_set
operator|>
name|from_cuid
condition|)
return|return
literal|1
return|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|use_crosses_set_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|from_cuid
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
name|use_crosses_set_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|from_cuid
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Define three variables used for communication between the following    routines.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|reg_dead_regno
decl_stmt|,
name|reg_dead_endregno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reg_dead_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function called via note_stores from reg_dead_at_p.     If DEST is within [reg_dead_regno, reg_dead_endregno), set    reg_dead_flag to 1 if X is a CLOBBER and to -1 it is a SET.  */
end_comment

begin_function
specifier|static
name|void
name|reg_dead_at_p_1
parameter_list|(
name|dest
parameter_list|,
name|x
parameter_list|,
name|data
parameter_list|)
name|rtx
name|dest
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|unsigned
name|int
name|regno
decl_stmt|,
name|endregno
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|!=
name|REG
condition|)
return|return;
name|regno
operator|=
name|REGNO
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|endregno
operator|=
name|regno
operator|+
operator|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|?
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
else|:
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|reg_dead_endregno
operator|>
name|regno
operator|&&
name|reg_dead_regno
operator|<
name|endregno
condition|)
name|reg_dead_flag
operator|=
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CLOBBER
operator|)
condition|?
literal|1
else|:
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return nonzero if REG is known to be dead at INSN.     We scan backwards from INSN.  If we hit a REG_DEAD note or a CLOBBER    referencing REG, it is dead.  If we hit a SET referencing REG, it is    live.  Otherwise, see if it is live or dead at the start of the basic    block we are in.  Hard regs marked as being live in NEWPAT_USED_REGS    must be assumed to be always live.  */
end_comment

begin_function
specifier|static
name|int
name|reg_dead_at_p
parameter_list|(
name|reg
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|reg
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|basic_block
name|block
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* Set variables for reg_dead_at_p_1.  */
name|reg_dead_regno
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|reg_dead_endregno
operator|=
name|reg_dead_regno
operator|+
operator|(
name|reg_dead_regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|?
name|HARD_REGNO_NREGS
argument_list|(
name|reg_dead_regno
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
else|:
literal|1
operator|)
expr_stmt|;
name|reg_dead_flag
operator|=
literal|0
expr_stmt|;
comment|/* Check that reg isn't mentioned in NEWPAT_USED_REGS.  */
if|if
condition|(
name|reg_dead_regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
for|for
control|(
name|i
operator|=
name|reg_dead_regno
init|;
name|i
operator|<
name|reg_dead_endregno
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|newpat_used_regs
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
comment|/* Scan backwards until we find a REG_DEAD note, SET, CLOBBER, label, or      beginning of function.  */
for|for
control|(
init|;
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|CODE_LABEL
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|BARRIER
condition|;
name|insn
operator|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|reg_dead_at_p_1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_dead_flag
condition|)
return|return
name|reg_dead_flag
operator|==
literal|1
condition|?
literal|1
else|:
literal|0
return|;
if|if
condition|(
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|reg_dead_regno
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
comment|/* Get the basic block that we were in.  */
if|if
condition|(
name|insn
operator|==
literal|0
condition|)
name|block
operator|=
name|ENTRY_BLOCK_PTR
operator|->
name|next_bb
expr_stmt|;
else|else
block|{
name|FOR_EACH_BB
argument_list|(
argument|block
argument_list|)
if|if
condition|(
name|insn
operator|==
name|block
operator|->
name|head
condition|)
break|break;
if|if
condition|(
name|block
operator|==
name|EXIT_BLOCK_PTR
condition|)
return|return
literal|0
return|;
block|}
for|for
control|(
name|i
operator|=
name|reg_dead_regno
init|;
name|i
operator|<
name|reg_dead_endregno
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|REGNO_REG_SET_P
argument_list|(
name|block
operator|->
name|global_live_at_start
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Note hard registers in X that are used.  This code is similar to    that in flow.c, but much simpler since we don't care about pseudos.  */
end_comment

begin_function
specifier|static
name|void
name|mark_used_regs_combine
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|regno
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_VECTOR
case|:
case|case
name|PC
case|:
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
case|case
name|ASM_INPUT
case|:
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* CC0 must die in the insn after it is set, so we don't need to take        special note of it here.  */
case|case
name|CC0
case|:
endif|#
directive|endif
return|return;
case|case
name|CLOBBER
case|:
comment|/* If we are clobbering a MEM, mark any hard registers inside the 	 address as used.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
name|mark_used_regs_combine
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|REG
case|:
name|regno
operator|=
name|REGNO
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* A hard reg in a wide mode may really be multiple registers. 	 If so, mark all of them just like the first.  */
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|unsigned
name|int
name|endregno
decl_stmt|,
name|r
decl_stmt|;
comment|/* None of this applies to the stack, frame or arg pointers.  */
if|if
condition|(
name|regno
operator|==
name|STACK_POINTER_REGNUM
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|HARD_FRAME_POINTER_REGNUM
operator|||
name|regno
operator|==
name|HARD_FRAME_POINTER_REGNUM
endif|#
directive|endif
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|ARG_POINTER_REGNUM
operator|||
operator|(
name|regno
operator|==
name|ARG_POINTER_REGNUM
operator|&&
name|fixed_regs
index|[
name|regno
index|]
operator|)
endif|#
directive|endif
operator|||
name|regno
operator|==
name|FRAME_POINTER_REGNUM
condition|)
return|return;
name|endregno
operator|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|r
operator|=
name|regno
init|;
name|r
operator|<
name|endregno
condition|;
name|r
operator|++
control|)
name|SET_HARD_REG_BIT
argument_list|(
name|newpat_used_regs
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|SET
case|:
block|{
comment|/* If setting a MEM, or a SUBREG of a MEM, then note any hard regs in 	   the address.  */
name|rtx
name|testreg
init|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|testreg
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|testreg
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|testreg
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|testreg
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|testreg
operator|=
name|XEXP
argument_list|(
name|testreg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|testreg
argument_list|)
operator|==
name|MEM
condition|)
name|mark_used_regs_combine
argument_list|(
name|XEXP
argument_list|(
name|testreg
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|mark_used_regs_combine
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
default|default:
break|break;
block|}
comment|/* Recursively scan the operands of this expression.  */
block|{
specifier|const
name|char
modifier|*
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|mark_used_regs_combine
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|mark_used_regs_combine
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Remove register number REGNO from the dead registers list of INSN.     Return the note used to record the death, if there was one.  */
end_comment

begin_function
name|rtx
name|remove_death
parameter_list|(
name|regno
parameter_list|,
name|insn
parameter_list|)
name|unsigned
name|int
name|regno
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|note
init|=
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|regno
argument_list|)
decl_stmt|;
if|if
condition|(
name|note
condition|)
block|{
name|REG_N_DEATHS
argument_list|(
name|regno
argument_list|)
operator|--
expr_stmt|;
name|remove_note
argument_list|(
name|insn
argument_list|,
name|note
argument_list|)
expr_stmt|;
block|}
return|return
name|note
return|;
block|}
end_function

begin_comment
comment|/* For each register (hardware or pseudo) used within expression X, if its    death is in an instruction with cuid between FROM_CUID (inclusive) and    TO_INSN (exclusive), put a REG_DEAD note for that register in the    list headed by PNOTES.     That said, don't move registers killed by maybe_kill_insn.     This is done when X is being merged by combination into TO_INSN.  These    notes will then be distributed as needed.  */
end_comment

begin_function
specifier|static
name|void
name|move_deaths
parameter_list|(
name|x
parameter_list|,
name|maybe_kill_insn
parameter_list|,
name|from_cuid
parameter_list|,
name|to_insn
parameter_list|,
name|pnotes
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|maybe_kill_insn
decl_stmt|;
name|int
name|from_cuid
decl_stmt|;
name|rtx
name|to_insn
decl_stmt|;
name|rtx
modifier|*
name|pnotes
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|len
decl_stmt|,
name|i
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|REG
condition|)
block|{
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
name|where_dead
init|=
name|reg_last_death
index|[
name|regno
index|]
decl_stmt|;
name|rtx
name|before_dead
decl_stmt|,
name|after_dead
decl_stmt|;
comment|/* Don't move the register if it gets killed in between from and to.  */
if|if
condition|(
name|maybe_kill_insn
operator|&&
name|reg_set_p
argument_list|(
name|x
argument_list|,
name|maybe_kill_insn
argument_list|)
operator|&&
operator|!
name|reg_referenced_p
argument_list|(
name|x
argument_list|,
name|maybe_kill_insn
argument_list|)
condition|)
return|return;
comment|/* WHERE_DEAD could be a USE insn made by combine, so first we 	 make sure that we have insns with valid INSN_CUID values.  */
name|before_dead
operator|=
name|where_dead
expr_stmt|;
while|while
condition|(
name|before_dead
operator|&&
name|INSN_UID
argument_list|(
name|before_dead
argument_list|)
operator|>
name|max_uid_cuid
condition|)
name|before_dead
operator|=
name|PREV_INSN
argument_list|(
name|before_dead
argument_list|)
expr_stmt|;
name|after_dead
operator|=
name|where_dead
expr_stmt|;
while|while
condition|(
name|after_dead
operator|&&
name|INSN_UID
argument_list|(
name|after_dead
argument_list|)
operator|>
name|max_uid_cuid
condition|)
name|after_dead
operator|=
name|NEXT_INSN
argument_list|(
name|after_dead
argument_list|)
expr_stmt|;
if|if
condition|(
name|before_dead
operator|&&
name|after_dead
operator|&&
name|INSN_CUID
argument_list|(
name|before_dead
argument_list|)
operator|>=
name|from_cuid
operator|&&
operator|(
name|INSN_CUID
argument_list|(
name|after_dead
argument_list|)
operator|<
name|INSN_CUID
argument_list|(
name|to_insn
argument_list|)
operator|||
operator|(
name|where_dead
operator|!=
name|after_dead
operator|&&
name|INSN_CUID
argument_list|(
name|after_dead
argument_list|)
operator|==
name|INSN_CUID
argument_list|(
name|to_insn
argument_list|)
operator|)
operator|)
condition|)
block|{
name|rtx
name|note
init|=
name|remove_death
argument_list|(
name|regno
argument_list|,
name|where_dead
argument_list|)
decl_stmt|;
comment|/* It is possible for the call above to return 0.  This can occur 	     when reg_last_death points to I2 or I1 that we combined with. 	     In that case make a new note.  	     We must also check for the case where X is a hard register 	     and NOTE is a death note for a range of hard registers 	     including X.  In that case, we must put REG_DEAD notes for 	     the remaining registers in place of NOTE.  */
if|if
condition|(
name|note
operator|!=
literal|0
operator|&&
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|unsigned
name|int
name|deadregno
init|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|deadend
init|=
operator|(
name|deadregno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|deadregno
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
decl_stmt|;
name|unsigned
name|int
name|ourend
init|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|deadregno
init|;
name|i
operator|<
name|deadend
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|i
operator|<
name|regno
operator|||
name|i
operator|>=
name|ourend
condition|)
name|REG_NOTES
argument_list|(
name|where_dead
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_DEAD
argument_list|,
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|,
name|REG_NOTES
argument_list|(
name|where_dead
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If we didn't find any note, or if we found a REG_DEAD note that 	     covers only part of the given reg, and we have a multi-reg hard 	     register, then to be safe we must check for REG_DEAD notes 	     for each register other than the first.  They could have 	     their own REG_DEAD notes lying around.  */
elseif|else
if|if
condition|(
operator|(
name|note
operator|==
literal|0
operator|||
operator|(
name|note
operator|!=
literal|0
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
operator|&&
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|>
literal|1
condition|)
block|{
name|unsigned
name|int
name|ourend
init|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|offset
decl_stmt|;
name|rtx
name|oldnotes
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|note
condition|)
name|offset
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|offset
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|regno
operator|+
name|offset
init|;
name|i
operator|<
name|ourend
condition|;
name|i
operator|++
control|)
name|move_deaths
argument_list|(
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|,
name|maybe_kill_insn
argument_list|,
name|from_cuid
argument_list|,
name|to_insn
argument_list|,
operator|&
name|oldnotes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|note
operator|!=
literal|0
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
operator|=
operator|*
name|pnotes
expr_stmt|;
operator|*
name|pnotes
operator|=
name|note
expr_stmt|;
block|}
else|else
operator|*
name|pnotes
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_DEAD
argument_list|,
name|x
argument_list|,
operator|*
name|pnotes
argument_list|)
expr_stmt|;
name|REG_N_DEATHS
argument_list|(
name|regno
argument_list|)
operator|++
expr_stmt|;
block|}
return|return;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
condition|)
block|{
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|move_deaths
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|maybe_kill_insn
argument_list|,
name|from_cuid
argument_list|,
name|to_insn
argument_list|,
name|pnotes
argument_list|)
expr_stmt|;
comment|/* In the case of a ZERO_EXTRACT, a STRICT_LOW_PART, or a SUBREG 	 that accesses one word of a multi-word item, some 	 piece of everything register in the expression is used by 	 this insn, so remove any old death.  */
comment|/* ??? So why do we test for equality of the sizes?  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
operator|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|==
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
argument_list|)
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|)
operator|)
condition|)
block|{
name|move_deaths
argument_list|(
name|dest
argument_list|,
name|maybe_kill_insn
argument_list|,
name|from_cuid
argument_list|,
name|to_insn
argument_list|,
name|pnotes
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If this is some other SUBREG, we know it replaces the entire 	 value, so use that as the destination.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
condition|)
name|dest
operator|=
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
expr_stmt|;
comment|/* If this is a MEM, adjust deaths of anything used in the address. 	 For a REG (the only other possibility), the entire value is 	 being replaced so the old value is not used in this insn.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
condition|)
name|move_deaths
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|,
name|maybe_kill_insn
argument_list|,
name|from_cuid
argument_list|,
name|to_insn
argument_list|,
name|pnotes
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CLOBBER
condition|)
return|return;
name|len
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|move_deaths
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|maybe_kill_insn
argument_list|,
name|from_cuid
argument_list|,
name|to_insn
argument_list|,
name|pnotes
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|move_deaths
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|maybe_kill_insn
argument_list|,
name|from_cuid
argument_list|,
name|to_insn
argument_list|,
name|pnotes
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if X is the target of a bit-field assignment in BODY, the    pattern of an insn.  X must be a REG.  */
end_comment

begin_function
specifier|static
name|int
name|reg_bitfield_target_p
parameter_list|(
name|x
parameter_list|,
name|body
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|body
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SET
condition|)
block|{
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|body
argument_list|)
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|unsigned
name|int
name|regno
decl_stmt|,
name|tregno
decl_stmt|,
name|endregno
decl_stmt|,
name|endtregno
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
name|target
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|target
operator|=
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|SUBREG
condition|)
name|target
operator|=
name|SUBREG_REG
argument_list|(
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
name|tregno
operator|=
name|REGNO
argument_list|(
name|target
argument_list|)
operator|,
name|regno
operator|=
name|REGNO
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|tregno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
return|return
name|target
operator|==
name|x
return|;
name|endtregno
operator|=
name|tregno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|tregno
argument_list|,
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
name|endregno
operator|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|endregno
operator|>
name|tregno
operator|&&
name|regno
operator|<
name|endtregno
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|PARALLEL
condition|)
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|reg_bitfield_target_p
argument_list|(
name|x
argument_list|,
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a chain of REG_NOTES originally from FROM_INSN, try to place them    as appropriate.  I3 and I2 are the insns resulting from the combination    insns including FROM (I2 may be zero).     ELIM_I2 and ELIM_I1 are either zero or registers that we know will    not need REG_DEAD notes because they are being substituted for.  This    saves searching in the most common cases.     Each note in the list is either ignored or placed on some insns, depending    on the type of note.  */
end_comment

begin_function
specifier|static
name|void
name|distribute_notes
parameter_list|(
name|notes
parameter_list|,
name|from_insn
parameter_list|,
name|i3
parameter_list|,
name|i2
parameter_list|,
name|elim_i2
parameter_list|,
name|elim_i1
parameter_list|)
name|rtx
name|notes
decl_stmt|;
name|rtx
name|from_insn
decl_stmt|;
name|rtx
name|i3
decl_stmt|,
name|i2
decl_stmt|;
name|rtx
name|elim_i2
decl_stmt|,
name|elim_i1
decl_stmt|;
block|{
name|rtx
name|note
decl_stmt|,
name|next_note
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
for|for
control|(
name|note
operator|=
name|notes
init|;
name|note
condition|;
name|note
operator|=
name|next_note
control|)
block|{
name|rtx
name|place
init|=
literal|0
decl_stmt|,
name|place2
init|=
literal|0
decl_stmt|;
comment|/* If this NOTE references a pseudo register, ensure it references 	 the latest copy of that register.  */
if|if
condition|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
operator|=
name|regno_reg_rtx
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
expr_stmt|;
name|next_note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
condition|)
block|{
case|case
name|REG_BR_PROB
case|:
case|case
name|REG_BR_PRED
case|:
comment|/* Doesn't matter much where we put this, as long as it's somewhere. 	     It is preferable to keep these notes on branches, which is most 	     likely to be i3.  */
name|place
operator|=
name|i3
expr_stmt|;
break|break;
case|case
name|REG_VTABLE_REF
case|:
comment|/* ??? Should remain with *a particular* memory load.  Given the 	     nature of vtable data, the last insn seems relatively safe.  */
name|place
operator|=
name|i3
expr_stmt|;
break|break;
case|case
name|REG_NON_LOCAL_GOTO
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|i3
argument_list|)
operator|==
name|JUMP_INSN
condition|)
name|place
operator|=
name|i3
expr_stmt|;
elseif|else
if|if
condition|(
name|i2
operator|&&
name|GET_CODE
argument_list|(
name|i2
argument_list|)
operator|==
name|JUMP_INSN
condition|)
name|place
operator|=
name|i2
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
name|REG_EH_REGION
case|:
comment|/* These notes must remain with the call or trapping instruction.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|i3
argument_list|)
operator|==
name|CALL_INSN
condition|)
name|place
operator|=
name|i3
expr_stmt|;
elseif|else
if|if
condition|(
name|i2
operator|&&
name|GET_CODE
argument_list|(
name|i2
argument_list|)
operator|==
name|CALL_INSN
condition|)
name|place
operator|=
name|i2
expr_stmt|;
elseif|else
if|if
condition|(
name|flag_non_call_exceptions
condition|)
block|{
if|if
condition|(
name|may_trap_p
argument_list|(
name|i3
argument_list|)
condition|)
name|place
operator|=
name|i3
expr_stmt|;
elseif|else
if|if
condition|(
name|i2
operator|&&
name|may_trap_p
argument_list|(
name|i2
argument_list|)
condition|)
name|place
operator|=
name|i2
expr_stmt|;
comment|/* ??? Otherwise assume we've combined things such that we 		 can now prove that the instructions can't trap.  Drop the 		 note in this case.  */
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
name|REG_NORETURN
case|:
case|case
name|REG_SETJMP
case|:
comment|/* These notes must remain with the call.  It should not be 	     possible for both I2 and I3 to be a call.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|i3
argument_list|)
operator|==
name|CALL_INSN
condition|)
name|place
operator|=
name|i3
expr_stmt|;
elseif|else
if|if
condition|(
name|i2
operator|&&
name|GET_CODE
argument_list|(
name|i2
argument_list|)
operator|==
name|CALL_INSN
condition|)
name|place
operator|=
name|i2
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
name|REG_UNUSED
case|:
comment|/* Any clobbers for i3 may still exist, and so we must process 	     REG_UNUSED notes from that insn.  	     Any clobbers from i2 or i1 can only exist if they were added by 	     recog_for_combine.  In that case, recog_for_combine created the 	     necessary REG_UNUSED notes.  Trying to keep any original 	     REG_UNUSED notes from these insns can cause incorrect output 	     if it is for the same register as the original i3 dest. 	     In that case, we will notice that the register is set in i3, 	     and then add a REG_UNUSED note for the destination of i3, which 	     is wrong.  However, it is possible to have REG_UNUSED notes from 	     i2 or i1 for register which were both used and clobbered, so 	     we keep notes from i2 or i1 if they will turn into REG_DEAD 	     notes.  */
comment|/* If this register is set or clobbered in I3, put the note there 	     unless there is one already.  */
if|if
condition|(
name|reg_set_p
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|from_insn
operator|!=
name|i3
condition|)
break|break;
if|if
condition|(
operator|!
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|?
name|find_regno_note
argument_list|(
name|i3
argument_list|,
name|REG_UNUSED
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
else|:
name|find_reg_note
argument_list|(
name|i3
argument_list|,
name|REG_UNUSED
argument_list|,
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
name|place
operator|=
name|i3
expr_stmt|;
block|}
comment|/* Otherwise, if this register is used by I3, then this register 	     now dies here, so we must put a REG_DEAD note here unless there 	     is one already.  */
elseif|else
if|if
condition|(
name|reg_referenced_p
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|)
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|?
name|find_regno_note
argument_list|(
name|i3
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
else|:
name|find_reg_note
argument_list|(
name|i3
argument_list|,
name|REG_DEAD
argument_list|,
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|PUT_REG_NOTE_KIND
argument_list|(
name|note
argument_list|,
name|REG_DEAD
argument_list|)
expr_stmt|;
name|place
operator|=
name|i3
expr_stmt|;
block|}
break|break;
case|case
name|REG_EQUAL
case|:
case|case
name|REG_EQUIV
case|:
case|case
name|REG_NOALIAS
case|:
comment|/* These notes say something about results of an insn.  We can 	     only support them if they used to be on I3 in which case they 	     remain on I3.  Otherwise they are ignored.  	     If the note refers to an expression that is not a constant, we 	     must also ignore the note since we cannot tell whether the 	     equivalence is still true.  It might be possible to do 	     slightly better than this (we only have a problem if I2DEST 	     or I1DEST is present in the expression), but it doesn't 	     seem worth the trouble.  */
if|if
condition|(
name|from_insn
operator|==
name|i3
operator|&&
operator|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
operator|||
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
name|place
operator|=
name|i3
expr_stmt|;
break|break;
case|case
name|REG_INC
case|:
case|case
name|REG_NO_CONFLICT
case|:
comment|/* These notes say something about how a register is used.  They must 	     be present on any use of the register in I2 or I3.  */
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|)
condition|)
name|place
operator|=
name|i3
expr_stmt|;
if|if
condition|(
name|i2
operator|&&
name|reg_mentioned_p
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|PATTERN
argument_list|(
name|i2
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|place
condition|)
name|place2
operator|=
name|i2
expr_stmt|;
else|else
name|place
operator|=
name|i2
expr_stmt|;
block|}
break|break;
case|case
name|REG_LABEL
case|:
comment|/* This can show up in several ways -- either directly in the 	     pattern, or hidden off in the constant pool with (or without?) 	     a REG_EQUAL note.  */
comment|/* ??? Ignore the without-reg_equal-note problem for now.  */
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|)
operator|||
operator|(
operator|(
name|tem
operator|=
name|find_reg_note
argument_list|(
name|i3
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
name|place
operator|=
name|i3
expr_stmt|;
if|if
condition|(
name|i2
operator|&&
operator|(
name|reg_mentioned_p
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|PATTERN
argument_list|(
name|i2
argument_list|)
argument_list|)
operator|||
operator|(
operator|(
name|tem
operator|=
name|find_reg_note
argument_list|(
name|i2
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|place
condition|)
name|place2
operator|=
name|i2
expr_stmt|;
else|else
name|place
operator|=
name|i2
expr_stmt|;
block|}
comment|/* Don't attach REG_LABEL note to a JUMP_INSN which has 	     JUMP_LABEL already.  Instead, decrement LABEL_NUSES.  */
if|if
condition|(
name|place
operator|&&
name|GET_CODE
argument_list|(
name|place
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|JUMP_LABEL
argument_list|(
name|place
argument_list|)
condition|)
block|{
if|if
condition|(
name|JUMP_LABEL
argument_list|(
name|place
argument_list|)
operator|!=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|JUMP_LABEL
argument_list|(
name|place
argument_list|)
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|LABEL_NUSES
argument_list|(
name|JUMP_LABEL
argument_list|(
name|place
argument_list|)
argument_list|)
operator|--
expr_stmt|;
name|place
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|place2
operator|&&
name|GET_CODE
argument_list|(
name|place2
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|JUMP_LABEL
argument_list|(
name|place2
argument_list|)
condition|)
block|{
if|if
condition|(
name|JUMP_LABEL
argument_list|(
name|place2
argument_list|)
operator|!=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|JUMP_LABEL
argument_list|(
name|place2
argument_list|)
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|LABEL_NUSES
argument_list|(
name|JUMP_LABEL
argument_list|(
name|place2
argument_list|)
argument_list|)
operator|--
expr_stmt|;
name|place2
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|REG_NONNEG
case|:
case|case
name|REG_WAS_0
case|:
comment|/* These notes say something about the value of a register prior 	     to the execution of an insn.  It is too much trouble to see 	     if the note is still correct in all situations.  It is better 	     to simply delete it.  */
break|break;
case|case
name|REG_RETVAL
case|:
comment|/* If the insn previously containing this note still exists, 	     put it back where it was.  Otherwise move it to the previous 	     insn.  Adjust the corresponding REG_LIBCALL note.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|from_insn
argument_list|)
operator|!=
name|NOTE
condition|)
name|place
operator|=
name|from_insn
expr_stmt|;
else|else
block|{
name|tem
operator|=
name|find_reg_note
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_LIBCALL
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|place
operator|=
name|prev_real_insn
argument_list|(
name|from_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|&&
name|place
condition|)
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
operator|=
name|place
expr_stmt|;
comment|/* If we're deleting the last remaining instruction of a 		 libcall sequence, don't add the notes.  */
elseif|else
if|if
condition|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
operator|==
name|from_insn
condition|)
name|tem
operator|=
name|place
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|REG_LIBCALL
case|:
comment|/* This is handled similarly to REG_RETVAL.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|from_insn
argument_list|)
operator|!=
name|NOTE
condition|)
name|place
operator|=
name|from_insn
expr_stmt|;
else|else
block|{
name|tem
operator|=
name|find_reg_note
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|place
operator|=
name|next_real_insn
argument_list|(
name|from_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|&&
name|place
condition|)
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
operator|=
name|place
expr_stmt|;
comment|/* If we're deleting the last remaining instruction of a 		 libcall sequence, don't add the notes.  */
elseif|else
if|if
condition|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
operator|==
name|from_insn
condition|)
name|tem
operator|=
name|place
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|REG_DEAD
case|:
comment|/* If the register is used as an input in I3, it dies there. 	     Similarly for I2, if it is nonzero and adjacent to I3.  	     If the register is not used as an input in either I3 or I2 	     and it is not one of the registers we were supposed to eliminate, 	     there are two possibilities.  We might have a non-adjacent I2 	     or we might have somehow eliminated an additional register 	     from a computation.  For example, we might have had A& B where 	     we discover that B will always be zero.  In this case we will 	     eliminate the reference to A.  	     In both cases, we must search to see if we can find a previous 	     use of A and put the death note there.  */
if|if
condition|(
name|from_insn
operator|&&
name|GET_CODE
argument_list|(
name|from_insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|find_reg_fusage
argument_list|(
name|from_insn
argument_list|,
name|USE
argument_list|,
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|place
operator|=
name|from_insn
expr_stmt|;
elseif|else
if|if
condition|(
name|reg_referenced_p
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|PATTERN
argument_list|(
name|i3
argument_list|)
argument_list|)
condition|)
name|place
operator|=
name|i3
expr_stmt|;
elseif|else
if|if
condition|(
name|i2
operator|!=
literal|0
operator|&&
name|next_nonnote_insn
argument_list|(
name|i2
argument_list|)
operator|==
name|i3
operator|&&
name|reg_referenced_p
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|PATTERN
argument_list|(
name|i2
argument_list|)
argument_list|)
condition|)
name|place
operator|=
name|i2
expr_stmt|;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|elim_i2
argument_list|)
operator|||
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|elim_i1
argument_list|)
condition|)
break|break;
if|if
condition|(
name|place
operator|==
literal|0
condition|)
block|{
name|basic_block
name|bb
init|=
name|this_basic_block
decl_stmt|;
for|for
control|(
name|tem
operator|=
name|PREV_INSN
argument_list|(
name|i3
argument_list|)
init|;
name|place
operator|==
literal|0
condition|;
name|tem
operator|=
name|PREV_INSN
argument_list|(
name|tem
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|tem
argument_list|)
condition|)
block|{
if|if
condition|(
name|tem
operator|==
name|bb
operator|->
name|head
condition|)
break|break;
continue|continue;
block|}
comment|/* If the register is being set at TEM, see if that is all 		     TEM is doing.  If so, delete TEM.  Otherwise, make this 		     into a REG_UNUSED note instead.  */
if|if
condition|(
name|reg_set_p
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|PATTERN
argument_list|(
name|tem
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|tem
argument_list|)
decl_stmt|;
name|rtx
name|inner_dest
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
name|rtx
name|cc0_setter
init|=
name|NULL_RTX
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|set
operator|!=
literal|0
condition|)
for|for
control|(
name|inner_dest
operator|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
init|;
operator|(
name|GET_CODE
argument_list|(
name|inner_dest
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|inner_dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|inner_dest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|)
condition|;
name|inner_dest
operator|=
name|XEXP
argument_list|(
name|inner_dest
argument_list|,
literal|0
argument_list|)
control|)
empty_stmt|;
comment|/* Verify that it was the set, and not a clobber that 			 modified the register.  			 CC0 targets must be careful to maintain setter/user 			 pairs.  If we cannot delete the setter due to side 			 effects, mark the user with an UNUSED note instead 			 of deleting it.  */
if|if
condition|(
name|set
operator|!=
literal|0
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|inner_dest
argument_list|)
ifdef|#
directive|ifdef
name|HAVE_cc0
operator|&&
operator|(
operator|!
name|reg_mentioned_p
argument_list|(
name|cc0_rtx
argument_list|,
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|||
operator|(
operator|(
name|cc0_setter
operator|=
name|prev_cc0_setter
argument_list|(
name|tem
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|sets_cc0_p
argument_list|(
name|PATTERN
argument_list|(
name|cc0_setter
argument_list|)
argument_list|)
operator|>
literal|0
operator|)
operator|)
endif|#
directive|endif
condition|)
block|{
comment|/* Move the notes and links of TEM elsewhere. 			     This might delete other dead insns recursively. 			     First set the pattern to something that won't use 			     any register.  */
name|PATTERN
argument_list|(
name|tem
argument_list|)
operator|=
name|pc_rtx
expr_stmt|;
name|distribute_notes
argument_list|(
name|REG_NOTES
argument_list|(
name|tem
argument_list|)
argument_list|,
name|tem
argument_list|,
name|tem
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|distribute_links
argument_list|(
name|LOG_LINKS
argument_list|(
name|tem
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_CODE
argument_list|(
name|tem
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|tem
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|tem
argument_list|)
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* Delete the setter too.  */
if|if
condition|(
name|cc0_setter
condition|)
block|{
name|PATTERN
argument_list|(
name|cc0_setter
argument_list|)
operator|=
name|pc_rtx
expr_stmt|;
name|distribute_notes
argument_list|(
name|REG_NOTES
argument_list|(
name|cc0_setter
argument_list|)
argument_list|,
name|cc0_setter
argument_list|,
name|cc0_setter
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|distribute_links
argument_list|(
name|LOG_LINKS
argument_list|(
name|cc0_setter
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_CODE
argument_list|(
name|cc0_setter
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|cc0_setter
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|cc0_setter
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
block|}
comment|/* If the register is both set and used here, put the 			 REG_DEAD note here, but place a REG_UNUSED note 			 here too unless there already is one.  */
elseif|else
if|if
condition|(
name|reg_referenced_p
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|PATTERN
argument_list|(
name|tem
argument_list|)
argument_list|)
condition|)
block|{
name|place
operator|=
name|tem
expr_stmt|;
if|if
condition|(
operator|!
name|find_regno_note
argument_list|(
name|tem
argument_list|,
name|REG_UNUSED
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
name|REG_NOTES
argument_list|(
name|tem
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_UNUSED
argument_list|,
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|tem
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PUT_REG_NOTE_KIND
argument_list|(
name|note
argument_list|,
name|REG_UNUSED
argument_list|)
expr_stmt|;
comment|/*  If there isn't already a REG_UNUSED note, put one 			      here.  */
if|if
condition|(
operator|!
name|find_regno_note
argument_list|(
name|tem
argument_list|,
name|REG_UNUSED
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
name|place
operator|=
name|tem
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|reg_referenced_p
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|PATTERN
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|find_reg_fusage
argument_list|(
name|tem
argument_list|,
name|USE
argument_list|,
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|place
operator|=
name|tem
expr_stmt|;
comment|/* If we are doing a 3->2 combination, and we have a 			 register which formerly died in i3 and was not used 			 by i2, which now no longer dies in i3 and is used in 			 i2 but does not die in i2, and place is between i2 			 and i3, then we may need to move a link from place to 			 i2.  */
if|if
condition|(
name|i2
operator|&&
name|INSN_UID
argument_list|(
name|place
argument_list|)
operator|<=
name|max_uid_cuid
operator|&&
name|INSN_CUID
argument_list|(
name|place
argument_list|)
operator|>
name|INSN_CUID
argument_list|(
name|i2
argument_list|)
operator|&&
name|from_insn
operator|&&
name|INSN_CUID
argument_list|(
name|from_insn
argument_list|)
operator|>
name|INSN_CUID
argument_list|(
name|i2
argument_list|)
operator|&&
name|reg_referenced_p
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|PATTERN
argument_list|(
name|i2
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|links
init|=
name|LOG_LINKS
argument_list|(
name|place
argument_list|)
decl_stmt|;
name|LOG_LINKS
argument_list|(
name|place
argument_list|)
operator|=
literal|0
expr_stmt|;
name|distribute_links
argument_list|(
name|links
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|tem
operator|==
name|bb
operator|->
name|head
condition|)
break|break;
block|}
comment|/* We haven't found an insn for the death note and it 		 is still a REG_DEAD note, but we have hit the beginning 		 of the block.  If the existing life info says the reg 		 was dead, there's nothing left to do.  Otherwise, we'll 		 need to do a global life update after combine.  */
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_DEAD
operator|&&
name|place
operator|==
literal|0
operator|&&
name|REGNO_REG_SET_P
argument_list|(
name|bb
operator|->
name|global_live_at_start
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|SET_BIT
argument_list|(
name|refresh_blocks
argument_list|,
name|this_basic_block
operator|->
name|index
argument_list|)
expr_stmt|;
name|need_refresh
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* If the register is set or already dead at PLACE, we needn't do 	     anything with this note if it is still a REG_DEAD note. 	     We can here if it is set at all, not if is it totally replace, 	     which is what `dead_or_set_p' checks, so also check for it being 	     set partially.  */
if|if
condition|(
name|place
operator|&&
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_DEAD
condition|)
block|{
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Similarly, if the instruction on which we want to place 		 the note is a noop, we'll need do a global live update 		 after we remove them in delete_noop_moves.  */
if|if
condition|(
name|noop_move_p
argument_list|(
name|place
argument_list|)
condition|)
block|{
name|SET_BIT
argument_list|(
name|refresh_blocks
argument_list|,
name|this_basic_block
operator|->
name|index
argument_list|)
expr_stmt|;
name|need_refresh
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|dead_or_set_p
argument_list|(
name|place
argument_list|,
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|reg_bitfield_target_p
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|PATTERN
argument_list|(
name|place
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Unless the register previously died in PLACE, clear 		     reg_last_death.  [I no longer understand why this is 		     being done.] */
if|if
condition|(
name|reg_last_death
index|[
name|regno
index|]
operator|!=
name|place
condition|)
name|reg_last_death
index|[
name|regno
index|]
operator|=
literal|0
expr_stmt|;
name|place
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|reg_last_death
index|[
name|regno
index|]
operator|=
name|place
expr_stmt|;
comment|/* If this is a death note for a hard reg that is occupying 		 multiple registers, ensure that we are still using all 		 parts of the object.  If we find a piece of the object 		 that is unused, we must arrange for an appropriate REG_DEAD 		 note to be added for it.  However, we can't just emit a USE 		 and tag the note to it, since the register might actually 		 be dead; so we recourse, and the recursive call then finds 		 the previous insn that used this register.  */
if|if
condition|(
name|place
operator|&&
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|>
literal|1
condition|)
block|{
name|unsigned
name|int
name|endregno
init|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|all_used
init|=
literal|1
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|regno
init|;
name|i
operator|<
name|endregno
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
operator|!
name|refers_to_regno_p
argument_list|(
name|i
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|PATTERN
argument_list|(
name|place
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|&&
operator|!
name|find_regno_fusage
argument_list|(
name|place
argument_list|,
name|USE
argument_list|,
name|i
argument_list|)
operator|)
operator|||
name|dead_or_set_regno_p
argument_list|(
name|place
argument_list|,
name|i
argument_list|)
condition|)
name|all_used
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|all_used
condition|)
block|{
comment|/* Put only REG_DEAD notes for pieces that are 			 not already dead or set.  */
for|for
control|(
name|i
operator|=
name|regno
init|;
name|i
operator|<
name|endregno
condition|;
name|i
operator|+=
name|HARD_REGNO_NREGS
argument_list|(
name|i
argument_list|,
name|reg_raw_mode
index|[
name|i
index|]
argument_list|)
control|)
block|{
name|rtx
name|piece
init|=
name|regno_reg_rtx
index|[
name|i
index|]
decl_stmt|;
name|basic_block
name|bb
init|=
name|this_basic_block
decl_stmt|;
if|if
condition|(
operator|!
name|dead_or_set_p
argument_list|(
name|place
argument_list|,
name|piece
argument_list|)
operator|&&
operator|!
name|reg_bitfield_target_p
argument_list|(
name|piece
argument_list|,
name|PATTERN
argument_list|(
name|place
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|new_note
init|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_DEAD
argument_list|,
name|piece
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
name|distribute_notes
argument_list|(
name|new_note
argument_list|,
name|place
argument_list|,
name|place
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|refers_to_regno_p
argument_list|(
name|i
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|PATTERN
argument_list|(
name|place
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|&&
operator|!
name|find_regno_fusage
argument_list|(
name|place
argument_list|,
name|USE
argument_list|,
name|i
argument_list|)
condition|)
for|for
control|(
name|tem
operator|=
name|PREV_INSN
argument_list|(
name|place
argument_list|)
init|;
condition|;
name|tem
operator|=
name|PREV_INSN
argument_list|(
name|tem
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|tem
argument_list|)
condition|)
block|{
if|if
condition|(
name|tem
operator|==
name|bb
operator|->
name|head
condition|)
block|{
name|SET_BIT
argument_list|(
name|refresh_blocks
argument_list|,
name|this_basic_block
operator|->
name|index
argument_list|)
expr_stmt|;
name|need_refresh
operator|=
literal|1
expr_stmt|;
break|break;
block|}
continue|continue;
block|}
if|if
condition|(
name|dead_or_set_p
argument_list|(
name|tem
argument_list|,
name|piece
argument_list|)
operator|||
name|reg_bitfield_target_p
argument_list|(
name|piece
argument_list|,
name|PATTERN
argument_list|(
name|tem
argument_list|)
argument_list|)
condition|)
block|{
name|REG_NOTES
argument_list|(
name|tem
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_UNUSED
argument_list|,
name|piece
argument_list|,
name|REG_NOTES
argument_list|(
name|tem
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|place
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
break|break;
default|default:
comment|/* Any other notes should not be present at this point in the 	     compilation.  */
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|place
condition|)
block|{
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
operator|=
name|REG_NOTES
argument_list|(
name|place
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|place
argument_list|)
operator|=
name|note
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_DEAD
operator|||
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_UNUSED
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|REG_N_DEATHS
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|--
expr_stmt|;
if|if
condition|(
name|place2
condition|)
block|{
if|if
condition|(
operator|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_DEAD
operator|||
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_UNUSED
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|REG_N_DEATHS
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|++
expr_stmt|;
name|REG_NOTES
argument_list|(
name|place2
argument_list|)
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|GET_CODE
argument_list|(
name|note
argument_list|)
argument_list|,
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|place2
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Similarly to above, distribute the LOG_LINKS that used to be present on    I3, I2, and I1 to new locations.  This is also called in one case to    add a link pointing at I3 when I3's destination is changed.  */
end_comment

begin_function
specifier|static
name|void
name|distribute_links
parameter_list|(
name|links
parameter_list|)
name|rtx
name|links
decl_stmt|;
block|{
name|rtx
name|link
decl_stmt|,
name|next_link
decl_stmt|;
for|for
control|(
name|link
operator|=
name|links
init|;
name|link
condition|;
name|link
operator|=
name|next_link
control|)
block|{
name|rtx
name|place
init|=
literal|0
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|rtx
name|set
decl_stmt|,
name|reg
decl_stmt|;
name|next_link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If the insn that this link points to is a NOTE or isn't a single 	 set, ignore it.  In the latter case, it isn't clear what we 	 can do other than ignore the link, since we can't tell which 	 register it was for.  Such links wouldn't be used by combine 	 anyway.  	 It is not possible for the destination of the target of the link to 	 have been changed by combine.  The only potential of this is if we 	 replace I3, I2, and I1 by I3 and I2.  But in that case the 	 destination of I2 also remains unchanged.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NOTE
operator|||
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|reg
operator|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
expr_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|reg
operator|=
name|XEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* A LOG_LINK is defined as being placed on the first insn that uses 	 a register and points to the insn that sets the register.  Start 	 searching at the next insn after the target of the link and stop 	 when we reach a set of the register or the end of the basic block.  	 Note that this correctly handles the link that used to point from 	 I3 to I2.  Also note that not much searching is typically done here 	 since most links don't point very far away.  */
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
init|;
operator|(
name|insn
operator|&&
operator|(
name|this_basic_block
operator|->
name|next_bb
operator|==
name|EXIT_BLOCK_PTR
operator|||
name|this_basic_block
operator|->
name|next_bb
operator|->
name|head
operator|!=
name|insn
operator|)
operator|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|reg
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|reg_referenced_p
argument_list|(
name|reg
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
name|place
operator|=
name|insn
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|find_reg_fusage
argument_list|(
name|insn
argument_list|,
name|USE
argument_list|,
name|reg
argument_list|)
condition|)
block|{
name|place
operator|=
name|insn
expr_stmt|;
break|break;
block|}
comment|/* If we found a place to put the link, place it there unless there 	 is already a link to the same insn as LINK at that point.  */
if|if
condition|(
name|place
condition|)
block|{
name|rtx
name|link2
decl_stmt|;
for|for
control|(
name|link2
operator|=
name|LOG_LINKS
argument_list|(
name|place
argument_list|)
init|;
name|link2
condition|;
name|link2
operator|=
name|XEXP
argument_list|(
name|link2
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|XEXP
argument_list|(
name|link2
argument_list|,
literal|0
argument_list|)
operator|==
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
condition|)
break|break;
if|if
condition|(
name|link2
operator|==
literal|0
condition|)
block|{
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
operator|=
name|LOG_LINKS
argument_list|(
name|place
argument_list|)
expr_stmt|;
name|LOG_LINKS
argument_list|(
name|place
argument_list|)
operator|=
name|link
expr_stmt|;
comment|/* Set added_links_insn to the earliest insn we added a 		 link to.  */
if|if
condition|(
name|added_links_insn
operator|==
literal|0
operator|||
name|INSN_CUID
argument_list|(
name|added_links_insn
argument_list|)
operator|>
name|INSN_CUID
argument_list|(
name|place
argument_list|)
condition|)
name|added_links_insn
operator|=
name|place
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compute INSN_CUID for INSN, which is an insn made by combine.  */
end_comment

begin_function
specifier|static
name|int
name|insn_cuid
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
while|while
condition|(
name|insn
operator|!=
literal|0
operator|&&
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|>
name|max_uid_cuid
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|USE
condition|)
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|>
name|max_uid_cuid
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|INSN_CUID
argument_list|(
name|insn
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|dump_combine_stats
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|fnotice
argument_list|(
name|file
argument_list|,
literal|";; Combiner statistics: %d attempts, %d substitutions (%d requiring new space),\n;; %d successes.\n\n"
argument_list|,
name|combine_attempts
argument_list|,
name|combine_merges
argument_list|,
name|combine_extras
argument_list|,
name|combine_successes
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dump_combine_total_stats
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|fnotice
argument_list|(
name|file
argument_list|,
literal|"\n;; Combiner totals: %d attempts, %d substitutions (%d requiring new space),\n;; %d successes.\n"
argument_list|,
name|total_attempts
argument_list|,
name|total_merges
argument_list|,
name|total_extras
argument_list|,
name|total_successes
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

