begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Generate code from machine description to compute values of attributes.    Copyright (C) 1991, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.    Contributed by Richard Kenner (kenner@vlsi1.ultra.nyu.edu)  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* This program handles insn attributes and the DEFINE_DELAY and    DEFINE_INSN_RESERVATION definitions.     It produces a series of functions named `get_attr_...', one for each insn    attribute.  Each of these is given the rtx for an insn and returns a member    of the enum for the attribute.     These subroutines have the form of a `switch' on the INSN_CODE (via    `recog_memoized').  Each case either returns a constant attribute value    or a value that depends on tests on other attributes, the form of    operands, or some random C expression (encoded with a SYMBOL_REF    expression).     If the attribute `alternative', or a random C expression is present,    `constrain_operands' is called.  If either of these cases of a reference to    an operand is found, `extract_insn' is called.     The special attribute `length' is also recognized.  For this operand,    expressions involving the address of an operand or the current insn,    (address (pc)), are valid.  In this case, an initial pass is made to    set all lengths that do not depend on address.  Those that do are set to    the maximum length.  Then each insn that depends on an address is checked    and possibly has its length changed.  The process repeats until no further    changed are made.  The resulting lengths are saved for use by    `get_attr_length'.     A special form of DEFINE_ATTR, where the expression for default value is a    CONST expression, indicates an attribute that is constant for a given run    of the compiler.  The subroutine generated for these attributes has no    parameters as it does not depend on any particular insn.  Constant    attributes are typically used to specify which variety of processor is    used.     Internal attributes are defined to handle DEFINE_DELAY and    DEFINE_INSN_RESERVATION.  Special routines are output for these cases.     This program works by keeping a list of possible values for each attribute.    These include the basic attribute choices, default values for attribute, and    all derived quantities.     As the description file is read, the definition for each insn is saved in a    `struct insn_def'.   When the file reading is complete, a `struct insn_ent'    is created for each insn and chained to the corresponding attribute value,    either that specified, or the default.     An optimization phase is then run.  This simplifies expressions for each    insn.  EQ_ATTR tests are resolved, whenever possible, to a test that    indicates when the attribute has the specified value for the insn.  This    avoids recursive calls during compilation.     The strategy used when processing DEFINE_DELAY definitions is to create    arbitrarily complex expressions and have the optimization simplify them.     Once optimization is complete, any required routines and definitions    will be written.     An optimization that is not yet implemented is to hoist the constant    expressions entirely out of the routines and definitions that are written.    A way to do this is to iterate over all possible combinations of values    for constant attributes and generate a set of functions for that given    combination.  An initialization function would be written that evaluates    the attributes and installs the corresponding set of routines and    definitions (each would be accessed through a pointer).     We use the flags in an RTX as follows:    `unchanging' (ATTR_IND_SIMPLIFIED_P): This rtx is fully simplified       independent of the insn code.    `in_struct' (ATTR_CURR_SIMPLIFIED_P): This rtx is fully simplified       for the insn code currently being processed (see optimize_attrs).    `return_val' (ATTR_PERMANENT_P): This rtx is permanent and unique       (see attr_rtx).  */
end_comment

begin_define
define|#
directive|define
name|ATTR_IND_SIMPLIFIED_P
parameter_list|(
name|RTX
parameter_list|)
value|(RTX_FLAG((RTX), unchanging))
end_define

begin_define
define|#
directive|define
name|ATTR_CURR_SIMPLIFIED_P
parameter_list|(
name|RTX
parameter_list|)
value|(RTX_FLAG((RTX), in_struct))
end_define

begin_define
define|#
directive|define
name|ATTR_PERMANENT_P
parameter_list|(
name|RTX
parameter_list|)
value|(RTX_FLAG((RTX), return_val))
end_define

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|strcmp_check
parameter_list|(
name|S1
parameter_list|,
name|S2
parameter_list|)
value|((S1) == (S2)		\ 			      ? 0			\ 			      : (gcc_assert (strcmp ((S1), (S2))), 1))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|strcmp_check
parameter_list|(
name|S1
parameter_list|,
name|S2
parameter_list|)
value|((S1) != (S2))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"bconfig.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"gensupport.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"errors.h"
end_include

begin_comment
comment|/* Flags for make_internal_attr's `special' parameter.  */
end_comment

begin_define
define|#
directive|define
name|ATTR_NONE
value|0
end_define

begin_define
define|#
directive|define
name|ATTR_SPECIAL
value|(1<< 0)
end_define

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|obstack1
decl_stmt|,
name|obstack2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|obstack
modifier|*
name|hash_obstack
init|=
operator|&
name|obstack1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|obstack
modifier|*
name|temp_obstack
init|=
operator|&
name|obstack2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* enough space to reserve for printing out ints */
end_comment

begin_define
define|#
directive|define
name|MAX_DIGITS
value|(HOST_BITS_PER_INT * 3 / 10 + 3)
end_define

begin_comment
comment|/* Define structures used to record attributes and values.  */
end_comment

begin_comment
comment|/* As each DEFINE_INSN, DEFINE_PEEPHOLE, or DEFINE_ASM_ATTRIBUTES is    encountered, we store all the relevant information into a    `struct insn_def'.  This is done to allow attribute definitions to occur    anywhere in the file.  */
end_comment

begin_struct
struct|struct
name|insn_def
block|{
name|struct
name|insn_def
modifier|*
name|next
decl_stmt|;
comment|/* Next insn in chain.  */
name|rtx
name|def
decl_stmt|;
comment|/* The DEFINE_...  */
name|int
name|insn_code
decl_stmt|;
comment|/* Instruction number.  */
name|int
name|insn_index
decl_stmt|;
comment|/* Expression numer in file, for errors.  */
name|int
name|lineno
decl_stmt|;
comment|/* Line number.  */
name|int
name|num_alternatives
decl_stmt|;
comment|/* Number of alternatives.  */
name|int
name|vec_idx
decl_stmt|;
comment|/* Index of attribute vector in `def'.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Once everything has been read in, we store in each attribute value a list    of insn codes that have that value.  Here is the structure used for the    list.  */
end_comment

begin_struct
struct|struct
name|insn_ent
block|{
name|struct
name|insn_ent
modifier|*
name|next
decl_stmt|;
comment|/* Next in chain.  */
name|struct
name|insn_def
modifier|*
name|def
decl_stmt|;
comment|/* Instruction definition.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Each value of an attribute (either constant or computed) is assigned a    structure which is used as the listhead of the insns that have that    value.  */
end_comment

begin_struct
struct|struct
name|attr_value
block|{
name|rtx
name|value
decl_stmt|;
comment|/* Value of attribute.  */
name|struct
name|attr_value
modifier|*
name|next
decl_stmt|;
comment|/* Next attribute value in chain.  */
name|struct
name|insn_ent
modifier|*
name|first_insn
decl_stmt|;
comment|/* First insn with this value.  */
name|int
name|num_insns
decl_stmt|;
comment|/* Number of insns with this value.  */
name|int
name|has_asm_insn
decl_stmt|;
comment|/* True if this value used for `asm' insns */
block|}
struct|;
end_struct

begin_comment
comment|/* Structure for each attribute.  */
end_comment

begin_struct
struct|struct
name|attr_desc
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Name of attribute.  */
name|struct
name|attr_desc
modifier|*
name|next
decl_stmt|;
comment|/* Next attribute.  */
name|struct
name|attr_value
modifier|*
name|first_value
decl_stmt|;
comment|/* First value of this attribute.  */
name|struct
name|attr_value
modifier|*
name|default_val
decl_stmt|;
comment|/* Default value for this attribute.  */
name|int
name|lineno
range|:
literal|24
decl_stmt|;
comment|/* Line number.  */
name|unsigned
name|is_numeric
range|:
literal|1
decl_stmt|;
comment|/* Values of this attribute are numeric.  */
name|unsigned
name|is_const
range|:
literal|1
decl_stmt|;
comment|/* Attribute value constant for each run.  */
name|unsigned
name|is_special
range|:
literal|1
decl_stmt|;
comment|/* Don't call `write_attr_set'.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Structure for each DEFINE_DELAY.  */
end_comment

begin_struct
struct|struct
name|delay_desc
block|{
name|rtx
name|def
decl_stmt|;
comment|/* DEFINE_DELAY expression.  */
name|struct
name|delay_desc
modifier|*
name|next
decl_stmt|;
comment|/* Next DEFINE_DELAY.  */
name|int
name|num
decl_stmt|;
comment|/* Number of DEFINE_DELAY, starting at 1.  */
name|int
name|lineno
decl_stmt|;
comment|/* Line number.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Listheads of above structures.  */
end_comment

begin_comment
comment|/* This one is indexed by the first character of the attribute name.  */
end_comment

begin_define
define|#
directive|define
name|MAX_ATTRS_INDEX
value|256
end_define

begin_decl_stmt
specifier|static
name|struct
name|attr_desc
modifier|*
name|attrs
index|[
name|MAX_ATTRS_INDEX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|insn_def
modifier|*
name|defs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|delay_desc
modifier|*
name|delays
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Other variables.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|insn_code_number
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|insn_index_number
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|got_define_asm_attributes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|must_extract
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|must_constrain
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|address_used
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|length_used
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|num_delays
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|have_annul_true
decl_stmt|,
name|have_annul_false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|num_insn_ents
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stores, for each insn code, the number of constraint alternatives.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|insn_n_alternatives
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stores, for each insn code, a bitmap that has bits on for each possible    alternative.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|insn_alternatives
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used to simplify expressions.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|true_rtx
decl_stmt|,
name|false_rtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used to reduce calls to `strcmp' */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|alternative_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|length_str
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|delay_type_str
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|delay_1_0_str
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|num_delay_slots_str
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Simplify an expression.  Only call the routine if there is something to    simplify.  */
end_comment

begin_define
define|#
directive|define
name|SIMPLIFY_TEST_EXP
parameter_list|(
name|EXP
parameter_list|,
name|INSN_CODE
parameter_list|,
name|INSN_INDEX
parameter_list|)
define|\
value|(ATTR_IND_SIMPLIFIED_P (EXP) || ATTR_CURR_SIMPLIFIED_P (EXP) ? (EXP)	\    : simplify_test_exp (EXP, INSN_CODE, INSN_INDEX))
end_define

begin_define
define|#
directive|define
name|DEF_ATTR_STRING
parameter_list|(
name|S
parameter_list|)
value|(attr_string ((S), strlen (S)))
end_define

begin_comment
comment|/* Forward declarations of functions used before their definitions, only.  */
end_comment

begin_function_decl
specifier|static
name|char
modifier|*
name|attr_string
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|char
modifier|*
name|attr_printf
argument_list|(
name|unsigned
name|int
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
operator|...
argument_list|)
name|ATTRIBUTE_PRINTF_2
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|rtx
name|make_numeric_value
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|attr_desc
modifier|*
name|find_attr
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|mk_attr_alt
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|next_comma_elt
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|insert_right_side
parameter_list|(
name|enum
name|rtx_code
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|copy_boolean
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|compares_alternatives_p
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|make_internal_attr
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|insert_insn_ent
parameter_list|(
name|struct
name|attr_value
modifier|*
parameter_list|,
name|struct
name|insn_ent
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|walk_attr_value
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|max_attr_value
parameter_list|(
name|rtx
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|min_attr_value
parameter_list|(
name|rtx
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|or_attr_value
parameter_list|(
name|rtx
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|simplify_test_exp
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|simplify_test_exp_in_temp
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|copy_rtx_unchanging
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|attr_alt_subset_p
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|attr_alt_subset_of_compl_p
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|clear_struct_flag
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_attr_valueq
parameter_list|(
name|struct
name|attr_desc
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|attr_value
modifier|*
name|find_most_used
parameter_list|(
name|struct
name|attr_desc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_attr_set
parameter_list|(
name|struct
name|attr_desc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|rtx
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_attr_case
parameter_list|(
name|struct
name|attr_desc
modifier|*
parameter_list|,
name|struct
name|attr_value
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_attr_value
parameter_list|(
name|struct
name|attr_desc
modifier|*
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_upcase
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_indent
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|identity_fn
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|zero_fn
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|one_fn
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|max_fn
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|min_fn
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|oballoc
parameter_list|(
name|size
parameter_list|)
value|obstack_alloc (hash_obstack, size)
end_define

begin_comment
comment|/* Hash table for sharing RTL and strings.  */
end_comment

begin_comment
comment|/* Each hash table slot is a bucket containing a chain of these structures.    Strings are given negative hash codes; RTL expressions are given positive    hash codes.  */
end_comment

begin_struct
struct|struct
name|attr_hash
block|{
name|struct
name|attr_hash
modifier|*
name|next
decl_stmt|;
comment|/* Next structure in the bucket.  */
name|int
name|hashcode
decl_stmt|;
comment|/* Hash code of this rtx or string.  */
union|union
block|{
name|char
modifier|*
name|str
decl_stmt|;
comment|/* The string (negative hash codes) */
name|rtx
name|rtl
decl_stmt|;
comment|/* or the RTL recorded here.  */
block|}
name|u
union|;
block|}
struct|;
end_struct

begin_comment
comment|/* Now here is the hash table.  When recording an RTL, it is added to    the slot whose index is the hash code mod the table size.  Note    that the hash table is used for several kinds of RTL (see attr_rtx)    and for strings.  While all these live in the same table, they are    completely independent, and the hash code is computed differently    for each.  */
end_comment

begin_define
define|#
directive|define
name|RTL_HASH_SIZE
value|4093
end_define

begin_decl_stmt
specifier|static
name|struct
name|attr_hash
modifier|*
name|attr_hash_table
index|[
name|RTL_HASH_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Here is how primitive or already-shared RTL's hash    codes are made.  */
end_comment

begin_define
define|#
directive|define
name|RTL_HASH
parameter_list|(
name|RTL
parameter_list|)
value|((long) (RTL)& 0777777)
end_define

begin_comment
comment|/* Add an entry to the hash table for RTL with hash code HASHCODE.  */
end_comment

begin_function
specifier|static
name|void
name|attr_hash_add_rtx
parameter_list|(
name|int
name|hashcode
parameter_list|,
name|rtx
name|rtl
parameter_list|)
block|{
name|struct
name|attr_hash
modifier|*
name|h
decl_stmt|;
name|h
operator|=
name|obstack_alloc
argument_list|(
name|hash_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|attr_hash
argument_list|)
argument_list|)
expr_stmt|;
name|h
operator|->
name|hashcode
operator|=
name|hashcode
expr_stmt|;
name|h
operator|->
name|u
operator|.
name|rtl
operator|=
name|rtl
expr_stmt|;
name|h
operator|->
name|next
operator|=
name|attr_hash_table
index|[
name|hashcode
operator|%
name|RTL_HASH_SIZE
index|]
expr_stmt|;
name|attr_hash_table
index|[
name|hashcode
operator|%
name|RTL_HASH_SIZE
index|]
operator|=
name|h
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add an entry to the hash table for STRING with hash code HASHCODE.  */
end_comment

begin_function
specifier|static
name|void
name|attr_hash_add_string
parameter_list|(
name|int
name|hashcode
parameter_list|,
name|char
modifier|*
name|str
parameter_list|)
block|{
name|struct
name|attr_hash
modifier|*
name|h
decl_stmt|;
name|h
operator|=
name|obstack_alloc
argument_list|(
name|hash_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|attr_hash
argument_list|)
argument_list|)
expr_stmt|;
name|h
operator|->
name|hashcode
operator|=
operator|-
name|hashcode
expr_stmt|;
name|h
operator|->
name|u
operator|.
name|str
operator|=
name|str
expr_stmt|;
name|h
operator|->
name|next
operator|=
name|attr_hash_table
index|[
name|hashcode
operator|%
name|RTL_HASH_SIZE
index|]
expr_stmt|;
name|attr_hash_table
index|[
name|hashcode
operator|%
name|RTL_HASH_SIZE
index|]
operator|=
name|h
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate an RTL expression, but avoid duplicates.    Set the ATTR_PERMANENT_P flag for these permanent objects.     In some cases we cannot uniquify; then we return an ordinary    impermanent rtx with ATTR_PERMANENT_P clear.     Args are as follows:     rtx attr_rtx (code, [element1, ..., elementn])  */
end_comment

begin_function
specifier|static
name|rtx
name|attr_rtx_1
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|va_list
name|p
parameter_list|)
block|{
name|rtx
name|rt_val
init|=
name|NULL_RTX
decl_stmt|;
comment|/* RTX to return to caller...		*/
name|int
name|hashcode
decl_stmt|;
name|struct
name|attr_hash
modifier|*
name|h
decl_stmt|;
name|struct
name|obstack
modifier|*
name|old_obstack
init|=
name|rtl_obstack
decl_stmt|;
comment|/* For each of several cases, search the hash table for an existing entry.      Use that entry if one is found; otherwise create a new RTL and add it      to the table.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|RTX_UNARY
condition|)
block|{
name|rtx
name|arg0
init|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|rtx
argument_list|)
decl_stmt|;
comment|/* A permanent object cannot point to impermanent ones.  */
if|if
condition|(
operator|!
name|ATTR_PERMANENT_P
argument_list|(
name|arg0
argument_list|)
condition|)
block|{
name|rt_val
operator|=
name|rtx_alloc
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|rt_val
argument_list|,
literal|0
argument_list|)
operator|=
name|arg0
expr_stmt|;
return|return
name|rt_val
return|;
block|}
name|hashcode
operator|=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
name|code
operator|+
name|RTL_HASH
argument_list|(
name|arg0
argument_list|)
operator|)
expr_stmt|;
for|for
control|(
name|h
operator|=
name|attr_hash_table
index|[
name|hashcode
operator|%
name|RTL_HASH_SIZE
index|]
init|;
name|h
condition|;
name|h
operator|=
name|h
operator|->
name|next
control|)
if|if
condition|(
name|h
operator|->
name|hashcode
operator|==
name|hashcode
operator|&&
name|GET_CODE
argument_list|(
name|h
operator|->
name|u
operator|.
name|rtl
argument_list|)
operator|==
name|code
operator|&&
name|XEXP
argument_list|(
name|h
operator|->
name|u
operator|.
name|rtl
argument_list|,
literal|0
argument_list|)
operator|==
name|arg0
condition|)
return|return
name|h
operator|->
name|u
operator|.
name|rtl
return|;
if|if
condition|(
name|h
operator|==
literal|0
condition|)
block|{
name|rtl_obstack
operator|=
name|hash_obstack
expr_stmt|;
name|rt_val
operator|=
name|rtx_alloc
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|rt_val
argument_list|,
literal|0
argument_list|)
operator|=
name|arg0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|RTX_BIN_ARITH
operator|||
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|RTX_COMM_ARITH
operator|||
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|RTX_COMPARE
operator|||
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|RTX_COMM_COMPARE
condition|)
block|{
name|rtx
name|arg0
init|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|rtx
argument_list|)
decl_stmt|;
name|rtx
name|arg1
init|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|rtx
argument_list|)
decl_stmt|;
comment|/* A permanent object cannot point to impermanent ones.  */
if|if
condition|(
operator|!
name|ATTR_PERMANENT_P
argument_list|(
name|arg0
argument_list|)
operator|||
operator|!
name|ATTR_PERMANENT_P
argument_list|(
name|arg1
argument_list|)
condition|)
block|{
name|rt_val
operator|=
name|rtx_alloc
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|rt_val
argument_list|,
literal|0
argument_list|)
operator|=
name|arg0
expr_stmt|;
name|XEXP
argument_list|(
name|rt_val
argument_list|,
literal|1
argument_list|)
operator|=
name|arg1
expr_stmt|;
return|return
name|rt_val
return|;
block|}
name|hashcode
operator|=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
name|code
operator|+
name|RTL_HASH
argument_list|(
name|arg0
argument_list|)
operator|+
name|RTL_HASH
argument_list|(
name|arg1
argument_list|)
operator|)
expr_stmt|;
for|for
control|(
name|h
operator|=
name|attr_hash_table
index|[
name|hashcode
operator|%
name|RTL_HASH_SIZE
index|]
init|;
name|h
condition|;
name|h
operator|=
name|h
operator|->
name|next
control|)
if|if
condition|(
name|h
operator|->
name|hashcode
operator|==
name|hashcode
operator|&&
name|GET_CODE
argument_list|(
name|h
operator|->
name|u
operator|.
name|rtl
argument_list|)
operator|==
name|code
operator|&&
name|XEXP
argument_list|(
name|h
operator|->
name|u
operator|.
name|rtl
argument_list|,
literal|0
argument_list|)
operator|==
name|arg0
operator|&&
name|XEXP
argument_list|(
name|h
operator|->
name|u
operator|.
name|rtl
argument_list|,
literal|1
argument_list|)
operator|==
name|arg1
condition|)
return|return
name|h
operator|->
name|u
operator|.
name|rtl
return|;
if|if
condition|(
name|h
operator|==
literal|0
condition|)
block|{
name|rtl_obstack
operator|=
name|hash_obstack
expr_stmt|;
name|rt_val
operator|=
name|rtx_alloc
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|rt_val
argument_list|,
literal|0
argument_list|)
operator|=
name|arg0
expr_stmt|;
name|XEXP
argument_list|(
name|rt_val
argument_list|,
literal|1
argument_list|)
operator|=
name|arg1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|==
literal|1
operator|&&
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'s'
condition|)
block|{
name|char
modifier|*
name|arg0
init|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|char
operator|*
argument_list|)
decl_stmt|;
name|arg0
operator|=
name|DEF_ATTR_STRING
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|hashcode
operator|=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
name|code
operator|+
name|RTL_HASH
argument_list|(
name|arg0
argument_list|)
operator|)
expr_stmt|;
for|for
control|(
name|h
operator|=
name|attr_hash_table
index|[
name|hashcode
operator|%
name|RTL_HASH_SIZE
index|]
init|;
name|h
condition|;
name|h
operator|=
name|h
operator|->
name|next
control|)
if|if
condition|(
name|h
operator|->
name|hashcode
operator|==
name|hashcode
operator|&&
name|GET_CODE
argument_list|(
name|h
operator|->
name|u
operator|.
name|rtl
argument_list|)
operator|==
name|code
operator|&&
name|XSTR
argument_list|(
name|h
operator|->
name|u
operator|.
name|rtl
argument_list|,
literal|0
argument_list|)
operator|==
name|arg0
condition|)
return|return
name|h
operator|->
name|u
operator|.
name|rtl
return|;
if|if
condition|(
name|h
operator|==
literal|0
condition|)
block|{
name|rtl_obstack
operator|=
name|hash_obstack
expr_stmt|;
name|rt_val
operator|=
name|rtx_alloc
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|XSTR
argument_list|(
name|rt_val
argument_list|,
literal|0
argument_list|)
operator|=
name|arg0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|==
literal|2
operator|&&
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'s'
operator|&&
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
index|[
literal|1
index|]
operator|==
literal|'s'
condition|)
block|{
name|char
modifier|*
name|arg0
init|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|char
operator|*
argument_list|)
decl_stmt|;
name|char
modifier|*
name|arg1
init|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|char
operator|*
argument_list|)
decl_stmt|;
name|hashcode
operator|=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
name|code
operator|+
name|RTL_HASH
argument_list|(
name|arg0
argument_list|)
operator|+
name|RTL_HASH
argument_list|(
name|arg1
argument_list|)
operator|)
expr_stmt|;
for|for
control|(
name|h
operator|=
name|attr_hash_table
index|[
name|hashcode
operator|%
name|RTL_HASH_SIZE
index|]
init|;
name|h
condition|;
name|h
operator|=
name|h
operator|->
name|next
control|)
if|if
condition|(
name|h
operator|->
name|hashcode
operator|==
name|hashcode
operator|&&
name|GET_CODE
argument_list|(
name|h
operator|->
name|u
operator|.
name|rtl
argument_list|)
operator|==
name|code
operator|&&
name|XSTR
argument_list|(
name|h
operator|->
name|u
operator|.
name|rtl
argument_list|,
literal|0
argument_list|)
operator|==
name|arg0
operator|&&
name|XSTR
argument_list|(
name|h
operator|->
name|u
operator|.
name|rtl
argument_list|,
literal|1
argument_list|)
operator|==
name|arg1
condition|)
return|return
name|h
operator|->
name|u
operator|.
name|rtl
return|;
if|if
condition|(
name|h
operator|==
literal|0
condition|)
block|{
name|rtl_obstack
operator|=
name|hash_obstack
expr_stmt|;
name|rt_val
operator|=
name|rtx_alloc
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|XSTR
argument_list|(
name|rt_val
argument_list|,
literal|0
argument_list|)
operator|=
name|arg0
expr_stmt|;
name|XSTR
argument_list|(
name|rt_val
argument_list|,
literal|1
argument_list|)
operator|=
name|arg1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|CONST_INT
condition|)
block|{
name|HOST_WIDE_INT
name|arg0
init|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|HOST_WIDE_INT
argument_list|)
decl_stmt|;
if|if
condition|(
name|arg0
operator|==
literal|0
condition|)
return|return
name|false_rtx
return|;
elseif|else
if|if
condition|(
name|arg0
operator|==
literal|1
condition|)
return|return
name|true_rtx
return|;
else|else
goto|goto
name|nohash
goto|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
comment|/* Array indices...			*/
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
comment|/* Current rtx's format...		*/
name|nohash
label|:
name|rt_val
operator|=
name|rtx_alloc
argument_list|(
name|code
argument_list|)
expr_stmt|;
comment|/* Allocate the storage space.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
comment|/* Find the right format...  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|fmt
operator|++
condition|)
block|{
case|case
literal|'0'
case|:
comment|/* Unused field.  */
break|break;
case|case
literal|'i'
case|:
comment|/* An integer?  */
name|XINT
argument_list|(
name|rt_val
argument_list|,
name|i
argument_list|)
operator|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|int
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
comment|/* A wide integer? */
name|XWINT
argument_list|(
name|rt_val
argument_list|,
name|i
argument_list|)
operator|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|HOST_WIDE_INT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* A string?  */
name|XSTR
argument_list|(
name|rt_val
argument_list|,
name|i
argument_list|)
operator|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
comment|/* An expression?  */
case|case
literal|'u'
case|:
comment|/* An insn?  Same except when printing.  */
name|XEXP
argument_list|(
name|rt_val
argument_list|,
name|i
argument_list|)
operator|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|rtx
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
comment|/* An RTX vector?  */
name|XVEC
argument_list|(
name|rt_val
argument_list|,
name|i
argument_list|)
operator|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|rtvec
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|rt_val
return|;
block|}
name|rtl_obstack
operator|=
name|old_obstack
expr_stmt|;
name|attr_hash_add_rtx
argument_list|(
name|hashcode
argument_list|,
name|rt_val
argument_list|)
expr_stmt|;
name|ATTR_PERMANENT_P
argument_list|(
name|rt_val
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|rt_val
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|attr_rtx
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
modifier|...
parameter_list|)
block|{
name|rtx
name|result
decl_stmt|;
name|va_list
name|p
decl_stmt|;
name|va_start
argument_list|(
name|p
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|result
operator|=
name|attr_rtx_1
argument_list|(
name|code
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Create a new string printed with the printf line arguments into a space    of at most LEN bytes:     rtx attr_printf (len, format, [arg1, ..., argn])  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|attr_printf
parameter_list|(
name|unsigned
name|int
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|char
name|str
index|[
literal|256
index|]
decl_stmt|;
name|va_list
name|p
decl_stmt|;
name|va_start
argument_list|(
name|p
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|len
operator|<
sizeof|sizeof
name|str
argument_list|)
expr_stmt|;
comment|/* Leave room for \0.  */
name|vsprintf
argument_list|(
name|str
argument_list|,
name|fmt
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|DEF_ATTR_STRING
argument_list|(
name|str
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|attr_eq
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
return|return
name|attr_rtx
argument_list|(
name|EQ_ATTR
argument_list|,
name|DEF_ATTR_STRING
argument_list|(
name|name
argument_list|)
argument_list|,
name|DEF_ATTR_STRING
argument_list|(
name|value
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|attr_numeral
parameter_list|(
name|int
name|n
parameter_list|)
block|{
return|return
name|XSTR
argument_list|(
name|make_numeric_value
argument_list|(
name|n
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a permanent (possibly shared) copy of a string STR (not assumed    to be null terminated) with LEN bytes.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|attr_string
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|attr_hash
modifier|*
name|h
decl_stmt|;
name|int
name|hashcode
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|new_str
decl_stmt|;
comment|/* Compute the hash code.  */
name|hashcode
operator|=
operator|(
name|len
operator|+
literal|1
operator|)
operator|*
literal|613
operator|+
operator|(
name|unsigned
operator|)
name|str
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|+=
literal|2
control|)
name|hashcode
operator|=
operator|(
operator|(
name|hashcode
operator|*
literal|613
operator|)
operator|+
operator|(
name|unsigned
operator|)
name|str
index|[
name|i
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|hashcode
operator|<
literal|0
condition|)
name|hashcode
operator|=
operator|-
name|hashcode
expr_stmt|;
comment|/* Search the table for the string.  */
for|for
control|(
name|h
operator|=
name|attr_hash_table
index|[
name|hashcode
operator|%
name|RTL_HASH_SIZE
index|]
init|;
name|h
condition|;
name|h
operator|=
name|h
operator|->
name|next
control|)
if|if
condition|(
name|h
operator|->
name|hashcode
operator|==
operator|-
name|hashcode
operator|&&
name|h
operator|->
name|u
operator|.
name|str
index|[
literal|0
index|]
operator|==
name|str
index|[
literal|0
index|]
operator|&&
operator|!
name|strncmp
argument_list|(
name|h
operator|->
name|u
operator|.
name|str
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
condition|)
return|return
name|h
operator|->
name|u
operator|.
name|str
return|;
comment|/*<-- return if found.  */
comment|/* Not found; create a permanent copy and add it to the hash table.  */
name|new_str
operator|=
name|obstack_alloc
argument_list|(
name|hash_obstack
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|new_str
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|new_str
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|attr_hash_add_string
argument_list|(
name|hashcode
argument_list|,
name|new_str
argument_list|)
expr_stmt|;
return|return
name|new_str
return|;
comment|/* Return the new string.  */
block|}
end_function

begin_comment
comment|/* Check two rtx's for equality of contents,    taking advantage of the fact that if both are hashed    then they can't be equal unless they are the same object.  */
end_comment

begin_function
specifier|static
name|int
name|attr_equal_p
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|y
parameter_list|)
block|{
return|return
operator|(
name|x
operator|==
name|y
operator|||
operator|(
operator|!
operator|(
name|ATTR_PERMANENT_P
argument_list|(
name|x
argument_list|)
operator|&&
name|ATTR_PERMANENT_P
argument_list|(
name|y
argument_list|)
operator|)
operator|&&
name|rtx_equal_p
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Copy an attribute value expression,    descending to all depths, but not copying any    permanent hashed subexpressions.  */
end_comment

begin_function
specifier|static
name|rtx
name|attr_copy_rtx
parameter_list|(
name|rtx
name|orig
parameter_list|)
block|{
name|rtx
name|copy
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|RTX_CODE
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|format_ptr
decl_stmt|;
comment|/* No need to copy a permanent object.  */
if|if
condition|(
name|ATTR_PERMANENT_P
argument_list|(
name|orig
argument_list|)
condition|)
return|return
name|orig
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|orig
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_VECTOR
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CODE_LABEL
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
return|return
name|orig
return|;
default|default:
break|break;
block|}
name|copy
operator|=
name|rtx_alloc
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|copy
argument_list|,
name|GET_MODE
argument_list|(
name|orig
argument_list|)
argument_list|)
expr_stmt|;
name|ATTR_IND_SIMPLIFIED_P
argument_list|(
name|copy
argument_list|)
operator|=
name|ATTR_IND_SIMPLIFIED_P
argument_list|(
name|orig
argument_list|)
expr_stmt|;
name|ATTR_CURR_SIMPLIFIED_P
argument_list|(
name|copy
argument_list|)
operator|=
name|ATTR_CURR_SIMPLIFIED_P
argument_list|(
name|orig
argument_list|)
expr_stmt|;
name|ATTR_PERMANENT_P
argument_list|(
name|copy
argument_list|)
operator|=
name|ATTR_PERMANENT_P
argument_list|(
name|orig
argument_list|)
expr_stmt|;
name|format_ptr
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|copy
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|copy
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|format_ptr
operator|++
condition|)
block|{
case|case
literal|'e'
case|:
name|XEXP
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|XEXP
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|XEXP
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
operator|!=
name|NULL
condition|)
name|XEXP
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|attr_copy_rtx
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
case|case
literal|'V'
case|:
name|XVEC
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|XVEC
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|XVEC
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|XVEC
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|rtvec_alloc
argument_list|(
name|XVECLEN
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|XVECEXP
argument_list|(
name|copy
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|=
name|attr_copy_rtx
argument_list|(
name|XVECEXP
argument_list|(
name|orig
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'n'
case|:
case|case
literal|'i'
case|:
name|XINT
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|XINT
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|XWINT
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|XWINT
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
name|XSTR
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|XSTR
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|copy
return|;
block|}
end_function

begin_comment
comment|/* Given a test expression for an attribute, ensure it is validly formed.    IS_CONST indicates whether the expression is constant for each compiler    run (a constant expression may not test any particular insn).     Convert (eq_attr "att" "a1,a2") to (ior (eq_attr ... ) (eq_attrq ..))    and (eq_attr "att" "!a1") to (not (eq_attr "att" "a1")).  Do the latter    test first so that (eq_attr "att" "!a1,a2,a3") works as expected.     Update the string address in EQ_ATTR expression to be the same used    in the attribute (or `alternative_name') to speed up subsequent    `find_attr' calls and eliminate most `strcmp' calls.     Return the new expression, if any.  */
end_comment

begin_function
specifier|static
name|rtx
name|check_attr_test
parameter_list|(
name|rtx
name|exp
parameter_list|,
name|int
name|is_const
parameter_list|,
name|int
name|lineno
parameter_list|)
block|{
name|struct
name|attr_desc
modifier|*
name|attr
decl_stmt|;
name|struct
name|attr_value
modifier|*
name|av
decl_stmt|;
specifier|const
name|char
modifier|*
name|name_ptr
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|rtx
name|orexp
decl_stmt|,
name|newexp
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|EQ_ATTR
case|:
comment|/* Handle negation test.  */
if|if
condition|(
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'!'
condition|)
return|return
name|check_attr_test
argument_list|(
name|attr_rtx
argument_list|(
name|NOT
argument_list|,
name|attr_eq
argument_list|(
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
index|[
literal|1
index|]
argument_list|)
argument_list|)
argument_list|,
name|is_const
argument_list|,
name|lineno
argument_list|)
return|;
elseif|else
if|if
condition|(
name|n_comma_elts
argument_list|(
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
literal|1
condition|)
block|{
name|attr
operator|=
name|find_attr
argument_list|(
operator|&
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|"alternative"
argument_list|)
condition|)
return|return
name|mk_attr_alt
argument_list|(
literal|1
operator|<<
name|atoi
argument_list|(
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
else|else
name|fatal
argument_list|(
literal|"unknown attribute `%s' in EQ_ATTR"
argument_list|,
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|is_const
operator|&&
operator|!
name|attr
operator|->
name|is_const
condition|)
name|fatal
argument_list|(
literal|"constant expression uses insn attribute `%s' in EQ_ATTR"
argument_list|,
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy this just to make it permanent, 	     so expressions using it can be permanent too.  */
name|exp
operator|=
name|attr_eq
argument_list|(
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* It shouldn't be possible to simplify the value given to a 	     constant attribute, so don't expand this until it's time to 	     write the test expression.  */
if|if
condition|(
name|attr
operator|->
name|is_const
condition|)
name|ATTR_IND_SIMPLIFIED_P
argument_list|(
name|exp
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|attr
operator|->
name|is_numeric
condition|)
block|{
for|for
control|(
name|p
operator|=
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"attribute `%s' takes only numeric values"
argument_list|,
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|av
operator|=
name|attr
operator|->
name|first_value
init|;
name|av
condition|;
name|av
operator|=
name|av
operator|->
name|next
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|av
operator|->
name|value
argument_list|)
operator|==
name|CONST_STRING
operator|&&
operator|!
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XSTR
argument_list|(
name|av
operator|->
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
break|break;
if|if
condition|(
name|av
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"unknown value `%s' for `%s' attribute"
argument_list|,
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|"alternative"
argument_list|)
condition|)
block|{
name|int
name|set
init|=
literal|0
decl_stmt|;
name|name_ptr
operator|=
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
name|next_comma_elt
argument_list|(
operator|&
name|name_ptr
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|set
operator||=
literal|1
operator|<<
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|mk_attr_alt
argument_list|(
name|set
argument_list|)
return|;
block|}
else|else
block|{
comment|/* Make an IOR tree of the possible values.  */
name|orexp
operator|=
name|false_rtx
expr_stmt|;
name|name_ptr
operator|=
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
name|next_comma_elt
argument_list|(
operator|&
name|name_ptr
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|newexp
operator|=
name|attr_eq
argument_list|(
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|orexp
operator|=
name|insert_right_side
argument_list|(
name|IOR
argument_list|,
name|orexp
argument_list|,
name|newexp
argument_list|,
operator|-
literal|2
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
return|return
name|check_attr_test
argument_list|(
name|orexp
argument_list|,
name|is_const
argument_list|,
name|lineno
argument_list|)
return|;
block|}
block|}
break|break;
case|case
name|ATTR_FLAG
case|:
break|break;
case|case
name|CONST_INT
case|:
comment|/* Either TRUE or FALSE.  */
if|if
condition|(
name|XWINT
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|true_rtx
return|;
else|else
return|return
name|false_rtx
return|;
case|case
name|IOR
case|:
case|case
name|AND
case|:
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|=
name|check_attr_test
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|is_const
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
operator|=
name|check_attr_test
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|is_const
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
break|break;
case|case
name|NOT
case|:
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|=
name|check_attr_test
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|is_const
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
break|break;
case|case
name|MATCH_OPERAND
case|:
if|if
condition|(
name|is_const
condition|)
name|fatal
argument_list|(
literal|"RTL operator \"%s\" not valid in constant attribute test"
argument_list|,
name|GET_RTX_NAME
argument_list|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* These cases can't be simplified.  */
name|ATTR_IND_SIMPLIFIED_P
argument_list|(
name|exp
argument_list|)
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|LE
case|:
case|case
name|LT
case|:
case|case
name|GT
case|:
case|case
name|GE
case|:
case|case
name|LEU
case|:
case|case
name|LTU
case|:
case|case
name|GTU
case|:
case|case
name|GEU
case|:
case|case
name|NE
case|:
case|case
name|EQ
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
name|exp
operator|=
name|attr_rtx
argument_list|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|attr_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|attr_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* These cases can't be simplified.  */
name|ATTR_IND_SIMPLIFIED_P
argument_list|(
name|exp
argument_list|)
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|SYMBOL_REF
case|:
if|if
condition|(
name|is_const
condition|)
block|{
comment|/* These cases are valid for constant attributes, but can't be 	     simplified.  */
name|exp
operator|=
name|attr_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|ATTR_IND_SIMPLIFIED_P
argument_list|(
name|exp
argument_list|)
operator|=
literal|1
expr_stmt|;
break|break;
block|}
default|default:
name|fatal
argument_list|(
literal|"RTL operator \"%s\" not valid in attribute test"
argument_list|,
name|GET_RTX_NAME
argument_list|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|exp
return|;
block|}
end_function

begin_comment
comment|/* Given an expression, ensure that it is validly formed and that all named    attribute values are valid for the given attribute.  Issue a fatal error    if not.  If no attribute is specified, assume a numeric attribute.     Return a perhaps modified replacement expression for the value.  */
end_comment

begin_function
specifier|static
name|rtx
name|check_attr_value
parameter_list|(
name|rtx
name|exp
parameter_list|,
name|struct
name|attr_desc
modifier|*
name|attr
parameter_list|)
block|{
name|struct
name|attr_value
modifier|*
name|av
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|CONST_INT
case|:
if|if
condition|(
name|attr
operator|&&
operator|!
name|attr
operator|->
name|is_numeric
condition|)
block|{
name|message_with_line
argument_list|(
name|attr
operator|->
name|lineno
argument_list|,
literal|"CONST_INT not valid for non-numeric attribute %s"
argument_list|,
name|attr
operator|->
name|name
argument_list|)
expr_stmt|;
name|have_error
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|INTVAL
argument_list|(
name|exp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|message_with_line
argument_list|(
name|attr
operator|->
name|lineno
argument_list|,
literal|"negative numeric value specified for attribute %s"
argument_list|,
name|attr
operator|->
name|name
argument_list|)
expr_stmt|;
name|have_error
operator|=
literal|1
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|CONST_STRING
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|"*"
argument_list|)
condition|)
break|break;
if|if
condition|(
name|attr
operator|==
literal|0
operator|||
name|attr
operator|->
name|is_numeric
condition|)
block|{
name|p
operator|=
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|message_with_line
argument_list|(
name|attr
condition|?
name|attr
operator|->
name|lineno
else|:
literal|0
argument_list|,
literal|"non-numeric value for numeric attribute %s"
argument_list|,
name|attr
condition|?
name|attr
operator|->
name|name
else|:
literal|"internal"
argument_list|)
expr_stmt|;
name|have_error
operator|=
literal|1
expr_stmt|;
break|break;
block|}
break|break;
block|}
for|for
control|(
name|av
operator|=
name|attr
operator|->
name|first_value
init|;
name|av
condition|;
name|av
operator|=
name|av
operator|->
name|next
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|av
operator|->
name|value
argument_list|)
operator|==
name|CONST_STRING
operator|&&
operator|!
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|av
operator|->
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
break|break;
if|if
condition|(
name|av
operator|==
name|NULL
condition|)
block|{
name|message_with_line
argument_list|(
name|attr
operator|->
name|lineno
argument_list|,
literal|"unknown value `%s' for `%s' attribute"
argument_list|,
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|attr
condition|?
name|attr
operator|->
name|name
else|:
literal|"internal"
argument_list|)
expr_stmt|;
name|have_error
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|IF_THEN_ELSE
case|:
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|=
name|check_attr_test
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|attr
condition|?
name|attr
operator|->
name|is_const
else|:
literal|0
argument_list|,
name|attr
condition|?
name|attr
operator|->
name|lineno
else|:
literal|0
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
operator|=
name|check_attr_value
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|attr
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
operator|=
name|check_attr_value
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
name|attr
argument_list|)
expr_stmt|;
break|break;
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
case|case
name|MULT
case|:
case|case
name|DIV
case|:
case|case
name|MOD
case|:
if|if
condition|(
name|attr
operator|&&
operator|!
name|attr
operator|->
name|is_numeric
condition|)
block|{
name|message_with_line
argument_list|(
name|attr
operator|->
name|lineno
argument_list|,
literal|"invalid operation `%s' for non-numeric attribute value"
argument_list|,
name|GET_RTX_NAME
argument_list|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|have_error
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* Fall through.  */
case|case
name|IOR
case|:
case|case
name|AND
case|:
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|=
name|check_attr_value
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|attr
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
operator|=
name|check_attr_value
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|attr
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFS
case|:
case|case
name|CLZ
case|:
case|case
name|CTZ
case|:
case|case
name|POPCOUNT
case|:
case|case
name|PARITY
case|:
case|case
name|BSWAP
case|:
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|=
name|check_attr_value
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|attr
argument_list|)
expr_stmt|;
break|break;
case|case
name|COND
case|:
if|if
condition|(
name|XVECLEN
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|%
literal|2
operator|!=
literal|0
condition|)
block|{
name|message_with_line
argument_list|(
name|attr
operator|->
name|lineno
argument_list|,
literal|"first operand of COND must have even length"
argument_list|)
expr_stmt|;
name|have_error
operator|=
literal|1
expr_stmt|;
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|XVECEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
operator|=
name|check_attr_test
argument_list|(
name|XVECEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|attr
condition|?
name|attr
operator|->
name|is_const
else|:
literal|0
argument_list|,
name|attr
condition|?
name|attr
operator|->
name|lineno
else|:
literal|0
argument_list|)
expr_stmt|;
name|XVECEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
name|i
operator|+
literal|1
argument_list|)
operator|=
name|check_attr_value
argument_list|(
name|XVECEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
name|i
operator|+
literal|1
argument_list|)
argument_list|,
name|attr
argument_list|)
expr_stmt|;
block|}
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
operator|=
name|check_attr_value
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|attr
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATTR
case|:
block|{
name|struct
name|attr_desc
modifier|*
name|attr2
init|=
name|find_attr
argument_list|(
operator|&
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|attr2
operator|==
name|NULL
condition|)
block|{
name|message_with_line
argument_list|(
name|attr
condition|?
name|attr
operator|->
name|lineno
else|:
literal|0
argument_list|,
literal|"unknown attribute `%s' in ATTR"
argument_list|,
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|have_error
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|attr
operator|&&
name|attr
operator|->
name|is_const
operator|&&
operator|!
name|attr2
operator|->
name|is_const
condition|)
block|{
name|message_with_line
argument_list|(
name|attr
operator|->
name|lineno
argument_list|,
literal|"non-constant attribute `%s' referenced from `%s'"
argument_list|,
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|attr
operator|->
name|name
argument_list|)
expr_stmt|;
name|have_error
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|attr
operator|&&
name|attr
operator|->
name|is_numeric
operator|!=
name|attr2
operator|->
name|is_numeric
condition|)
block|{
name|message_with_line
argument_list|(
name|attr
operator|->
name|lineno
argument_list|,
literal|"numeric attribute mismatch calling `%s' from `%s'"
argument_list|,
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|attr
operator|->
name|name
argument_list|)
expr_stmt|;
name|have_error
operator|=
literal|1
expr_stmt|;
block|}
block|}
break|break;
case|case
name|SYMBOL_REF
case|:
comment|/* A constant SYMBOL_REF is valid as a constant attribute test and          is expanded later by make_canonical into a COND.  In a non-constant          attribute test, it is left be.  */
return|return
name|attr_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
default|default:
name|message_with_line
argument_list|(
name|attr
condition|?
name|attr
operator|->
name|lineno
else|:
literal|0
argument_list|,
literal|"invalid operation `%s' for attribute value"
argument_list|,
name|GET_RTX_NAME
argument_list|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|have_error
operator|=
literal|1
expr_stmt|;
break|break;
block|}
return|return
name|exp
return|;
block|}
end_function

begin_comment
comment|/* Given an SET_ATTR_ALTERNATIVE expression, convert to the canonical SET.    It becomes a COND with each test being (eq_attr "alternative" "n") */
end_comment

begin_function
specifier|static
name|rtx
name|convert_set_attr_alternative
parameter_list|(
name|rtx
name|exp
parameter_list|,
name|struct
name|insn_def
modifier|*
name|id
parameter_list|)
block|{
name|int
name|num_alt
init|=
name|id
operator|->
name|num_alternatives
decl_stmt|;
name|rtx
name|condexp
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|XVECLEN
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
operator|!=
name|num_alt
condition|)
block|{
name|message_with_line
argument_list|(
name|id
operator|->
name|lineno
argument_list|,
literal|"bad number of entries in SET_ATTR_ALTERNATIVE"
argument_list|)
expr_stmt|;
name|have_error
operator|=
literal|1
expr_stmt|;
return|return
name|NULL_RTX
return|;
block|}
comment|/* Make a COND with all tests but the last.  Select the last value via the      default.  */
name|condexp
operator|=
name|rtx_alloc
argument_list|(
name|COND
argument_list|)
expr_stmt|;
name|XVEC
argument_list|(
name|condexp
argument_list|,
literal|0
argument_list|)
operator|=
name|rtvec_alloc
argument_list|(
operator|(
name|num_alt
operator|-
literal|1
operator|)
operator|*
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_alt
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|attr_numeral
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|XVECEXP
argument_list|(
name|condexp
argument_list|,
literal|0
argument_list|,
literal|2
operator|*
name|i
argument_list|)
operator|=
name|attr_eq
argument_list|(
name|alternative_name
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|XVECEXP
argument_list|(
name|condexp
argument_list|,
literal|0
argument_list|,
literal|2
operator|*
name|i
operator|+
literal|1
argument_list|)
operator|=
name|XVECEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|XEXP
argument_list|(
name|condexp
argument_list|,
literal|1
argument_list|)
operator|=
name|XVECEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|attr_rtx
argument_list|(
name|SET
argument_list|,
name|attr_rtx
argument_list|(
name|ATTR
argument_list|,
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|condexp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given a SET_ATTR, convert to the appropriate SET.  If a comma-separated    list of values is given, convert to SET_ATTR_ALTERNATIVE first.  */
end_comment

begin_function
specifier|static
name|rtx
name|convert_set_attr
parameter_list|(
name|rtx
name|exp
parameter_list|,
name|struct
name|insn_def
modifier|*
name|id
parameter_list|)
block|{
name|rtx
name|newexp
decl_stmt|;
specifier|const
name|char
modifier|*
name|name_ptr
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|n
decl_stmt|;
comment|/* See how many alternative specified.  */
name|n
operator|=
name|n_comma_elts
argument_list|(
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|1
condition|)
return|return
name|attr_rtx
argument_list|(
name|SET
argument_list|,
name|attr_rtx
argument_list|(
name|ATTR
argument_list|,
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|attr_rtx
argument_list|(
name|CONST_STRING
argument_list|,
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
name|newexp
operator|=
name|rtx_alloc
argument_list|(
name|SET_ATTR_ALTERNATIVE
argument_list|)
expr_stmt|;
name|XSTR
argument_list|(
name|newexp
argument_list|,
literal|0
argument_list|)
operator|=
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XVEC
argument_list|(
name|newexp
argument_list|,
literal|1
argument_list|)
operator|=
name|rtvec_alloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
comment|/* Process each comma-separated name.  */
name|name_ptr
operator|=
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
name|next_comma_elt
argument_list|(
operator|&
name|name_ptr
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|XVECEXP
argument_list|(
name|newexp
argument_list|,
literal|1
argument_list|,
name|n
operator|++
argument_list|)
operator|=
name|attr_rtx
argument_list|(
name|CONST_STRING
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|convert_set_attr_alternative
argument_list|(
name|newexp
argument_list|,
name|id
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Scan all definitions, checking for validity.  Also, convert any SET_ATTR    and SET_ATTR_ALTERNATIVE expressions to the corresponding SET    expressions.  */
end_comment

begin_function
specifier|static
name|void
name|check_defs
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|insn_def
modifier|*
name|id
decl_stmt|;
name|struct
name|attr_desc
modifier|*
name|attr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rtx
name|value
decl_stmt|;
for|for
control|(
name|id
operator|=
name|defs
init|;
name|id
condition|;
name|id
operator|=
name|id
operator|->
name|next
control|)
block|{
if|if
condition|(
name|XVEC
argument_list|(
name|id
operator|->
name|def
argument_list|,
name|id
operator|->
name|vec_idx
argument_list|)
operator|==
name|NULL
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|id
operator|->
name|def
argument_list|,
name|id
operator|->
name|vec_idx
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|value
operator|=
name|XVECEXP
argument_list|(
name|id
operator|->
name|def
argument_list|,
name|id
operator|->
name|vec_idx
argument_list|,
name|i
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
condition|)
block|{
case|case
name|SET
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|ATTR
condition|)
block|{
name|message_with_line
argument_list|(
name|id
operator|->
name|lineno
argument_list|,
literal|"bad attribute set"
argument_list|)
expr_stmt|;
name|have_error
operator|=
literal|1
expr_stmt|;
name|value
operator|=
name|NULL_RTX
expr_stmt|;
block|}
break|break;
case|case
name|SET_ATTR_ALTERNATIVE
case|:
name|value
operator|=
name|convert_set_attr_alternative
argument_list|(
name|value
argument_list|,
name|id
argument_list|)
expr_stmt|;
break|break;
case|case
name|SET_ATTR
case|:
name|value
operator|=
name|convert_set_attr
argument_list|(
name|value
argument_list|,
name|id
argument_list|)
expr_stmt|;
break|break;
default|default:
name|message_with_line
argument_list|(
name|id
operator|->
name|lineno
argument_list|,
literal|"invalid attribute code %s"
argument_list|,
name|GET_RTX_NAME
argument_list|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|have_error
operator|=
literal|1
expr_stmt|;
name|value
operator|=
name|NULL_RTX
expr_stmt|;
block|}
if|if
condition|(
name|value
operator|==
name|NULL_RTX
condition|)
continue|continue;
if|if
condition|(
operator|(
name|attr
operator|=
name|find_attr
argument_list|(
operator|&
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|message_with_line
argument_list|(
name|id
operator|->
name|lineno
argument_list|,
literal|"unknown attribute %s"
argument_list|,
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|have_error
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
name|XVECEXP
argument_list|(
name|id
operator|->
name|def
argument_list|,
name|id
operator|->
name|vec_idx
argument_list|,
name|i
argument_list|)
operator|=
name|value
expr_stmt|;
name|XEXP
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
operator|=
name|check_attr_value
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
argument_list|,
name|attr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Given a valid expression for an attribute value, remove any IF_THEN_ELSE    expressions by converting them into a COND.  This removes cases from this    program.  Also, replace an attribute value of "*" with the default attribute    value.  */
end_comment

begin_function
specifier|static
name|rtx
name|make_canonical
parameter_list|(
name|struct
name|attr_desc
modifier|*
name|attr
parameter_list|,
name|rtx
name|exp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|rtx
name|newexp
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|CONST_INT
case|:
name|exp
operator|=
name|make_numeric_value
argument_list|(
name|INTVAL
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_STRING
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|"*"
argument_list|)
condition|)
block|{
if|if
condition|(
name|attr
operator|==
literal|0
operator|||
name|attr
operator|->
name|default_val
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"(attr_value \"*\") used in invalid context"
argument_list|)
expr_stmt|;
name|exp
operator|=
name|attr
operator|->
name|default_val
operator|->
name|value
expr_stmt|;
block|}
else|else
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|=
name|DEF_ATTR_STRING
argument_list|(
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYMBOL_REF
case|:
if|if
condition|(
operator|!
name|attr
operator|->
name|is_const
operator|||
name|ATTR_IND_SIMPLIFIED_P
argument_list|(
name|exp
argument_list|)
condition|)
break|break;
comment|/* The SYMBOL_REF is constant for a given run, so mark it as unchanging. 	 This makes the COND something that won't be considered an arbitrary 	 expression by walk_attr_value.  */
name|ATTR_IND_SIMPLIFIED_P
argument_list|(
name|exp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|exp
operator|=
name|check_attr_value
argument_list|(
name|exp
argument_list|,
name|attr
argument_list|)
expr_stmt|;
break|break;
case|case
name|IF_THEN_ELSE
case|:
name|newexp
operator|=
name|rtx_alloc
argument_list|(
name|COND
argument_list|)
expr_stmt|;
name|XVEC
argument_list|(
name|newexp
argument_list|,
literal|0
argument_list|)
operator|=
name|rtvec_alloc
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|XVECEXP
argument_list|(
name|newexp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|=
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XVECEXP
argument_list|(
name|newexp
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
operator|=
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|newexp
argument_list|,
literal|1
argument_list|)
operator|=
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|exp
operator|=
name|newexp
expr_stmt|;
comment|/* Fall through to COND case since this is now a COND.  */
case|case
name|COND
case|:
block|{
name|int
name|allsame
init|=
literal|1
decl_stmt|;
name|rtx
name|defval
decl_stmt|;
comment|/* First, check for degenerate COND.  */
if|if
condition|(
name|XVECLEN
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
return|return
name|make_canonical
argument_list|(
name|attr
argument_list|,
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
name|defval
operator|=
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
operator|=
name|make_canonical
argument_list|(
name|attr
argument_list|,
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|XVECEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
operator|=
name|copy_boolean
argument_list|(
name|XVECEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|XVECEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
name|i
operator|+
literal|1
argument_list|)
operator|=
name|make_canonical
argument_list|(
name|attr
argument_list|,
name|XVECEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
name|i
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|XVECEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
name|i
operator|+
literal|1
argument_list|)
argument_list|,
name|defval
argument_list|)
condition|)
name|allsame
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|allsame
condition|)
return|return
name|defval
return|;
block|}
break|break;
default|default:
break|break;
block|}
return|return
name|exp
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|copy_boolean
parameter_list|(
name|rtx
name|exp
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|AND
operator|||
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|IOR
condition|)
return|return
name|attr_rtx
argument_list|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|copy_boolean
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|copy_boolean
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|MATCH_OPERAND
condition|)
block|{
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
operator|=
name|DEF_ATTR_STRING
argument_list|(
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
operator|=
name|DEF_ATTR_STRING
argument_list|(
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|EQ_ATTR
condition|)
block|{
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|=
name|DEF_ATTR_STRING
argument_list|(
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
operator|=
name|DEF_ATTR_STRING
argument_list|(
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|exp
return|;
block|}
end_function

begin_comment
comment|/* Given a value and an attribute description, return a `struct attr_value *'    that represents that value.  This is either an existing structure, if the    value has been previously encountered, or a newly-created structure.     `insn_code' is the code of an insn whose attribute has the specified    value (-2 if not processing an insn).  We ensure that all insns for    a given value have the same number of alternatives if the value checks    alternatives.  */
end_comment

begin_function
specifier|static
name|struct
name|attr_value
modifier|*
name|get_attr_value
parameter_list|(
name|rtx
name|value
parameter_list|,
name|struct
name|attr_desc
modifier|*
name|attr
parameter_list|,
name|int
name|insn_code
parameter_list|)
block|{
name|struct
name|attr_value
modifier|*
name|av
decl_stmt|;
name|int
name|num_alt
init|=
literal|0
decl_stmt|;
name|value
operator|=
name|make_canonical
argument_list|(
name|attr
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|compares_alternatives_p
argument_list|(
name|value
argument_list|)
condition|)
block|{
if|if
condition|(
name|insn_code
operator|<
literal|0
operator|||
name|insn_alternatives
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"(eq_attr \"alternatives\" ...) used in non-insn context"
argument_list|)
expr_stmt|;
else|else
name|num_alt
operator|=
name|insn_alternatives
index|[
name|insn_code
index|]
expr_stmt|;
block|}
for|for
control|(
name|av
operator|=
name|attr
operator|->
name|first_value
init|;
name|av
condition|;
name|av
operator|=
name|av
operator|->
name|next
control|)
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|value
argument_list|,
name|av
operator|->
name|value
argument_list|)
operator|&&
operator|(
name|num_alt
operator|==
literal|0
operator|||
name|av
operator|->
name|first_insn
operator|==
name|NULL
operator|||
name|insn_alternatives
index|[
name|av
operator|->
name|first_insn
operator|->
name|def
operator|->
name|insn_code
index|]
operator|)
condition|)
return|return
name|av
return|;
name|av
operator|=
name|oballoc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|attr_value
argument_list|)
argument_list|)
expr_stmt|;
name|av
operator|->
name|value
operator|=
name|value
expr_stmt|;
name|av
operator|->
name|next
operator|=
name|attr
operator|->
name|first_value
expr_stmt|;
name|attr
operator|->
name|first_value
operator|=
name|av
expr_stmt|;
name|av
operator|->
name|first_insn
operator|=
name|NULL
expr_stmt|;
name|av
operator|->
name|num_insns
operator|=
literal|0
expr_stmt|;
name|av
operator|->
name|has_asm_insn
operator|=
literal|0
expr_stmt|;
return|return
name|av
return|;
block|}
end_function

begin_comment
comment|/* After all DEFINE_DELAYs have been read in, create internal attributes    to generate the required routines.     First, we compute the number of delay slots for each insn (as a COND of    each of the test expressions in DEFINE_DELAYs).  Then, if more than one    delay type is specified, we compute a similar function giving the    DEFINE_DELAY ordinal for each insn.     Finally, for each [DEFINE_DELAY, slot #] pair, we compute an attribute that    tells whether a given insn can be in that delay slot.     Normal attribute filling and optimization expands these to contain the    information needed to handle delay slots.  */
end_comment

begin_function
specifier|static
name|void
name|expand_delays
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|delay_desc
modifier|*
name|delay
decl_stmt|;
name|rtx
name|condexp
decl_stmt|;
name|rtx
name|newexp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* First, generate data for `num_delay_slots' function.  */
name|condexp
operator|=
name|rtx_alloc
argument_list|(
name|COND
argument_list|)
expr_stmt|;
name|XVEC
argument_list|(
name|condexp
argument_list|,
literal|0
argument_list|)
operator|=
name|rtvec_alloc
argument_list|(
name|num_delays
operator|*
literal|2
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|condexp
argument_list|,
literal|1
argument_list|)
operator|=
name|make_numeric_value
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|delay
operator|=
name|delays
init|;
name|delay
condition|;
name|i
operator|+=
literal|2
operator|,
name|delay
operator|=
name|delay
operator|->
name|next
control|)
block|{
name|XVECEXP
argument_list|(
name|condexp
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
operator|=
name|XEXP
argument_list|(
name|delay
operator|->
name|def
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XVECEXP
argument_list|(
name|condexp
argument_list|,
literal|0
argument_list|,
name|i
operator|+
literal|1
argument_list|)
operator|=
name|make_numeric_value
argument_list|(
name|XVECLEN
argument_list|(
name|delay
operator|->
name|def
argument_list|,
literal|1
argument_list|)
operator|/
literal|3
argument_list|)
expr_stmt|;
block|}
name|make_internal_attr
argument_list|(
name|num_delay_slots_str
argument_list|,
name|condexp
argument_list|,
name|ATTR_NONE
argument_list|)
expr_stmt|;
comment|/* If more than one delay type, do the same for computing the delay type.  */
if|if
condition|(
name|num_delays
operator|>
literal|1
condition|)
block|{
name|condexp
operator|=
name|rtx_alloc
argument_list|(
name|COND
argument_list|)
expr_stmt|;
name|XVEC
argument_list|(
name|condexp
argument_list|,
literal|0
argument_list|)
operator|=
name|rtvec_alloc
argument_list|(
name|num_delays
operator|*
literal|2
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|condexp
argument_list|,
literal|1
argument_list|)
operator|=
name|make_numeric_value
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|delay
operator|=
name|delays
init|;
name|delay
condition|;
name|i
operator|+=
literal|2
operator|,
name|delay
operator|=
name|delay
operator|->
name|next
control|)
block|{
name|XVECEXP
argument_list|(
name|condexp
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
operator|=
name|XEXP
argument_list|(
name|delay
operator|->
name|def
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XVECEXP
argument_list|(
name|condexp
argument_list|,
literal|0
argument_list|,
name|i
operator|+
literal|1
argument_list|)
operator|=
name|make_numeric_value
argument_list|(
name|delay
operator|->
name|num
argument_list|)
expr_stmt|;
block|}
name|make_internal_attr
argument_list|(
name|delay_type_str
argument_list|,
name|condexp
argument_list|,
name|ATTR_SPECIAL
argument_list|)
expr_stmt|;
block|}
comment|/* For each delay possibility and delay slot, compute an eligibility      attribute for non-annulled insns and for each type of annulled (annul      if true and annul if false).  */
for|for
control|(
name|delay
operator|=
name|delays
init|;
name|delay
condition|;
name|delay
operator|=
name|delay
operator|->
name|next
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|delay
operator|->
name|def
argument_list|,
literal|1
argument_list|)
condition|;
name|i
operator|+=
literal|3
control|)
block|{
name|condexp
operator|=
name|XVECEXP
argument_list|(
name|delay
operator|->
name|def
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|condexp
operator|==
literal|0
condition|)
name|condexp
operator|=
name|false_rtx
expr_stmt|;
name|newexp
operator|=
name|attr_rtx
argument_list|(
name|IF_THEN_ELSE
argument_list|,
name|condexp
argument_list|,
name|make_numeric_value
argument_list|(
literal|1
argument_list|)
argument_list|,
name|make_numeric_value
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|attr_printf
argument_list|(
sizeof|sizeof
expr|"*delay__"
operator|+
name|MAX_DIGITS
operator|*
literal|2
argument_list|,
literal|"*delay_%d_%d"
argument_list|,
name|delay
operator|->
name|num
argument_list|,
name|i
operator|/
literal|3
argument_list|)
expr_stmt|;
name|make_internal_attr
argument_list|(
name|p
argument_list|,
name|newexp
argument_list|,
name|ATTR_SPECIAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_annul_true
condition|)
block|{
name|condexp
operator|=
name|XVECEXP
argument_list|(
name|delay
operator|->
name|def
argument_list|,
literal|1
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|condexp
operator|==
literal|0
condition|)
name|condexp
operator|=
name|false_rtx
expr_stmt|;
name|newexp
operator|=
name|attr_rtx
argument_list|(
name|IF_THEN_ELSE
argument_list|,
name|condexp
argument_list|,
name|make_numeric_value
argument_list|(
literal|1
argument_list|)
argument_list|,
name|make_numeric_value
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|attr_printf
argument_list|(
sizeof|sizeof
expr|"*annul_true__"
operator|+
name|MAX_DIGITS
operator|*
literal|2
argument_list|,
literal|"*annul_true_%d_%d"
argument_list|,
name|delay
operator|->
name|num
argument_list|,
name|i
operator|/
literal|3
argument_list|)
expr_stmt|;
name|make_internal_attr
argument_list|(
name|p
argument_list|,
name|newexp
argument_list|,
name|ATTR_SPECIAL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|have_annul_false
condition|)
block|{
name|condexp
operator|=
name|XVECEXP
argument_list|(
name|delay
operator|->
name|def
argument_list|,
literal|1
argument_list|,
name|i
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|condexp
operator|==
literal|0
condition|)
name|condexp
operator|=
name|false_rtx
expr_stmt|;
name|newexp
operator|=
name|attr_rtx
argument_list|(
name|IF_THEN_ELSE
argument_list|,
name|condexp
argument_list|,
name|make_numeric_value
argument_list|(
literal|1
argument_list|)
argument_list|,
name|make_numeric_value
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|attr_printf
argument_list|(
sizeof|sizeof
expr|"*annul_false__"
operator|+
name|MAX_DIGITS
operator|*
literal|2
argument_list|,
literal|"*annul_false_%d_%d"
argument_list|,
name|delay
operator|->
name|num
argument_list|,
name|i
operator|/
literal|3
argument_list|)
expr_stmt|;
name|make_internal_attr
argument_list|(
name|p
argument_list|,
name|newexp
argument_list|,
name|ATTR_SPECIAL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Once all attributes and insns have been read and checked, we construct for    each attribute value a list of all the insns that have that value for    the attribute.  */
end_comment

begin_function
specifier|static
name|void
name|fill_attr
parameter_list|(
name|struct
name|attr_desc
modifier|*
name|attr
parameter_list|)
block|{
name|struct
name|attr_value
modifier|*
name|av
decl_stmt|;
name|struct
name|insn_ent
modifier|*
name|ie
decl_stmt|;
name|struct
name|insn_def
modifier|*
name|id
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rtx
name|value
decl_stmt|;
comment|/* Don't fill constant attributes.  The value is independent of      any particular insn.  */
if|if
condition|(
name|attr
operator|->
name|is_const
condition|)
return|return;
for|for
control|(
name|id
operator|=
name|defs
init|;
name|id
condition|;
name|id
operator|=
name|id
operator|->
name|next
control|)
block|{
comment|/* If no value is specified for this insn for this attribute, use the 	 default.  */
name|value
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|XVEC
argument_list|(
name|id
operator|->
name|def
argument_list|,
name|id
operator|->
name|vec_idx
argument_list|)
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|id
operator|->
name|def
argument_list|,
name|id
operator|->
name|vec_idx
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp_check
argument_list|(
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|id
operator|->
name|def
argument_list|,
name|id
operator|->
name|vec_idx
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|attr
operator|->
name|name
argument_list|)
condition|)
name|value
operator|=
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|id
operator|->
name|def
argument_list|,
name|id
operator|->
name|vec_idx
argument_list|,
name|i
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
name|av
operator|=
name|attr
operator|->
name|default_val
expr_stmt|;
else|else
name|av
operator|=
name|get_attr_value
argument_list|(
name|value
argument_list|,
name|attr
argument_list|,
name|id
operator|->
name|insn_code
argument_list|)
expr_stmt|;
name|ie
operator|=
name|oballoc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|insn_ent
argument_list|)
argument_list|)
expr_stmt|;
name|ie
operator|->
name|def
operator|=
name|id
expr_stmt|;
name|insert_insn_ent
argument_list|(
name|av
argument_list|,
name|ie
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Given an expression EXP, see if it is a COND or IF_THEN_ELSE that has a    test that checks relative positions of insns (uses MATCH_DUP or PC).    If so, replace it with what is obtained by passing the expression to    ADDRESS_FN.  If not but it is a COND or IF_THEN_ELSE, call this routine    recursively on each value (including the default value).  Otherwise,    return the value returned by NO_ADDRESS_FN applied to EXP.  */
end_comment

begin_function
specifier|static
name|rtx
name|substitute_address
parameter_list|(
name|rtx
name|exp
parameter_list|,
name|rtx
function_decl|(
modifier|*
name|no_address_fn
function_decl|)
parameter_list|(
name|rtx
parameter_list|)
parameter_list|,
name|rtx
function_decl|(
modifier|*
name|address_fn
function_decl|)
parameter_list|(
name|rtx
parameter_list|)
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|rtx
name|newexp
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|COND
condition|)
block|{
comment|/* See if any tests use addresses.  */
name|address_used
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|+=
literal|2
control|)
name|walk_attr_value
argument_list|(
name|XVECEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|address_used
condition|)
return|return
call|(
modifier|*
name|address_fn
call|)
argument_list|(
name|exp
argument_list|)
return|;
comment|/* Make a new copy of this COND, replacing each element.  */
name|newexp
operator|=
name|rtx_alloc
argument_list|(
name|COND
argument_list|)
expr_stmt|;
name|XVEC
argument_list|(
name|newexp
argument_list|,
literal|0
argument_list|)
operator|=
name|rtvec_alloc
argument_list|(
name|XVECLEN
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|XVECEXP
argument_list|(
name|newexp
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
operator|=
name|XVECEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|XVECEXP
argument_list|(
name|newexp
argument_list|,
literal|0
argument_list|,
name|i
operator|+
literal|1
argument_list|)
operator|=
name|substitute_address
argument_list|(
name|XVECEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
name|i
operator|+
literal|1
argument_list|)
argument_list|,
name|no_address_fn
argument_list|,
name|address_fn
argument_list|)
expr_stmt|;
block|}
name|XEXP
argument_list|(
name|newexp
argument_list|,
literal|1
argument_list|)
operator|=
name|substitute_address
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|no_address_fn
argument_list|,
name|address_fn
argument_list|)
expr_stmt|;
return|return
name|newexp
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|IF_THEN_ELSE
condition|)
block|{
name|address_used
operator|=
literal|0
expr_stmt|;
name|walk_attr_value
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|address_used
condition|)
return|return
call|(
modifier|*
name|address_fn
call|)
argument_list|(
name|exp
argument_list|)
return|;
return|return
name|attr_rtx
argument_list|(
name|IF_THEN_ELSE
argument_list|,
name|substitute_address
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|no_address_fn
argument_list|,
name|address_fn
argument_list|)
argument_list|,
name|substitute_address
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|no_address_fn
argument_list|,
name|address_fn
argument_list|)
argument_list|,
name|substitute_address
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
name|no_address_fn
argument_list|,
name|address_fn
argument_list|)
argument_list|)
return|;
block|}
return|return
call|(
modifier|*
name|no_address_fn
call|)
argument_list|(
name|exp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Make new attributes from the `length' attribute.  The following are made,    each corresponding to a function called from `shorten_branches' or    `get_attr_length':     *insn_default_length		This is the length of the insn to be returned 				by `get_attr_length' before `shorten_branches' 				has been called.  In each case where the length 				depends on relative addresses, the largest 				possible is used.  This routine is also used 				to compute the initial size of the insn.     *insn_variable_length_p	This returns 1 if the insn's length depends 				on relative addresses, zero otherwise.     *insn_current_length		This is only called when it is known that the 				insn has a variable length and returns the 				current length, based on relative addresses.   */
end_comment

begin_function
specifier|static
name|void
name|make_length_attrs
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|new_names
index|[]
init|=
block|{
literal|"*insn_default_length"
block|,
literal|"*insn_min_length"
block|,
literal|"*insn_variable_length_p"
block|,
literal|"*insn_current_length"
block|}
decl_stmt|;
specifier|static
name|rtx
argument_list|(
operator|*
specifier|const
name|no_address_fn
index|[]
argument_list|)
argument_list|(
name|rtx
argument_list|)
operator|=
block|{
name|identity_fn
block|,
name|identity_fn
block|,
name|zero_fn
block|,
name|zero_fn
block|}
expr_stmt|;
specifier|static
name|rtx
argument_list|(
operator|*
specifier|const
name|address_fn
index|[]
argument_list|)
argument_list|(
name|rtx
argument_list|)
operator|=
block|{
name|max_fn
block|,
name|min_fn
block|,
name|one_fn
block|,
name|identity_fn
block|}
expr_stmt|;
name|size_t
name|i
decl_stmt|;
name|struct
name|attr_desc
modifier|*
name|length_attr
decl_stmt|,
modifier|*
name|new_attr
decl_stmt|;
name|struct
name|attr_value
modifier|*
name|av
decl_stmt|,
modifier|*
name|new_av
decl_stmt|;
name|struct
name|insn_ent
modifier|*
name|ie
decl_stmt|,
modifier|*
name|new_ie
decl_stmt|;
comment|/* See if length attribute is defined.  If so, it must be numeric.  Make      it special so we don't output anything for it.  */
name|length_attr
operator|=
name|find_attr
argument_list|(
operator|&
name|length_str
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|length_attr
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|!
name|length_attr
operator|->
name|is_numeric
condition|)
name|fatal
argument_list|(
literal|"length attribute must be numeric"
argument_list|)
expr_stmt|;
name|length_attr
operator|->
name|is_const
operator|=
literal|0
expr_stmt|;
name|length_attr
operator|->
name|is_special
operator|=
literal|1
expr_stmt|;
comment|/* Make each new attribute, in turn.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|new_names
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|make_internal_attr
argument_list|(
name|new_names
index|[
name|i
index|]
argument_list|,
name|substitute_address
argument_list|(
name|length_attr
operator|->
name|default_val
operator|->
name|value
argument_list|,
name|no_address_fn
index|[
name|i
index|]
argument_list|,
name|address_fn
index|[
name|i
index|]
argument_list|)
argument_list|,
name|ATTR_NONE
argument_list|)
expr_stmt|;
name|new_attr
operator|=
name|find_attr
argument_list|(
operator|&
name|new_names
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|av
operator|=
name|length_attr
operator|->
name|first_value
init|;
name|av
condition|;
name|av
operator|=
name|av
operator|->
name|next
control|)
for|for
control|(
name|ie
operator|=
name|av
operator|->
name|first_insn
init|;
name|ie
condition|;
name|ie
operator|=
name|ie
operator|->
name|next
control|)
block|{
name|new_av
operator|=
name|get_attr_value
argument_list|(
name|substitute_address
argument_list|(
name|av
operator|->
name|value
argument_list|,
name|no_address_fn
index|[
name|i
index|]
argument_list|,
name|address_fn
index|[
name|i
index|]
argument_list|)
argument_list|,
name|new_attr
argument_list|,
name|ie
operator|->
name|def
operator|->
name|insn_code
argument_list|)
expr_stmt|;
name|new_ie
operator|=
name|oballoc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|insn_ent
argument_list|)
argument_list|)
expr_stmt|;
name|new_ie
operator|->
name|def
operator|=
name|ie
operator|->
name|def
expr_stmt|;
name|insert_insn_ent
argument_list|(
name|new_av
argument_list|,
name|new_ie
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Utility functions called from above routine.  */
end_comment

begin_function
specifier|static
name|rtx
name|identity_fn
parameter_list|(
name|rtx
name|exp
parameter_list|)
block|{
return|return
name|exp
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|zero_fn
parameter_list|(
name|rtx
name|exp
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|make_numeric_value
argument_list|(
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|one_fn
parameter_list|(
name|rtx
name|exp
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|make_numeric_value
argument_list|(
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|max_fn
parameter_list|(
name|rtx
name|exp
parameter_list|)
block|{
name|int
name|unknown
decl_stmt|;
return|return
name|make_numeric_value
argument_list|(
name|max_attr_value
argument_list|(
name|exp
argument_list|,
operator|&
name|unknown
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|min_fn
parameter_list|(
name|rtx
name|exp
parameter_list|)
block|{
name|int
name|unknown
decl_stmt|;
return|return
name|make_numeric_value
argument_list|(
name|min_attr_value
argument_list|(
name|exp
argument_list|,
operator|&
name|unknown
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|write_length_unit_log
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|attr_desc
modifier|*
name|length_attr
init|=
name|find_attr
argument_list|(
operator|&
name|length_str
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|struct
name|attr_value
modifier|*
name|av
decl_stmt|;
name|struct
name|insn_ent
modifier|*
name|ie
decl_stmt|;
name|unsigned
name|int
name|length_unit_log
decl_stmt|,
name|length_or
decl_stmt|;
name|int
name|unknown
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|length_attr
operator|==
literal|0
condition|)
return|return;
name|length_or
operator|=
name|or_attr_value
argument_list|(
name|length_attr
operator|->
name|default_val
operator|->
name|value
argument_list|,
operator|&
name|unknown
argument_list|)
expr_stmt|;
for|for
control|(
name|av
operator|=
name|length_attr
operator|->
name|first_value
init|;
name|av
condition|;
name|av
operator|=
name|av
operator|->
name|next
control|)
for|for
control|(
name|ie
operator|=
name|av
operator|->
name|first_insn
init|;
name|ie
condition|;
name|ie
operator|=
name|ie
operator|->
name|next
control|)
name|length_or
operator||=
name|or_attr_value
argument_list|(
name|av
operator|->
name|value
argument_list|,
operator|&
name|unknown
argument_list|)
expr_stmt|;
if|if
condition|(
name|unknown
condition|)
name|length_unit_log
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|length_or
operator|=
operator|~
name|length_or
expr_stmt|;
for|for
control|(
name|length_unit_log
operator|=
literal|0
init|;
name|length_or
operator|&
literal|1
condition|;
name|length_or
operator|>>=
literal|1
control|)
name|length_unit_log
operator|++
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"const int length_unit_log = %u;\n"
argument_list|,
name|length_unit_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Take a COND expression and see if any of the conditions in it can be    simplified.  If any are known true or known false for the particular insn    code, the COND can be further simplified.     Also call ourselves on any COND operations that are values of this COND.     We do not modify EXP; rather, we make and return a new rtx.  */
end_comment

begin_function
specifier|static
name|rtx
name|simplify_cond
parameter_list|(
name|rtx
name|exp
parameter_list|,
name|int
name|insn_code
parameter_list|,
name|int
name|insn_index
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* We store the desired contents here,      then build a new expression if they don't match EXP.  */
name|rtx
name|defval
init|=
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|new_defval
init|=
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|XVECLEN
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
modifier|*
name|tests
init|=
name|XNEWVEC
argument_list|(
name|rtx
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|int
name|allsame
init|=
literal|1
decl_stmt|;
name|rtx
name|ret
decl_stmt|;
comment|/* This lets us free all storage allocated below, if appropriate.  */
operator|(
name|void
operator|)
name|obstack_finish
argument_list|(
name|rtl_obstack
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|tests
argument_list|,
name|XVEC
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|->
name|elem
argument_list|,
name|len
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* See if default value needs simplification.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|defval
argument_list|)
operator|==
name|COND
condition|)
name|new_defval
operator|=
name|simplify_cond
argument_list|(
name|defval
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
comment|/* Simplify the subexpressions, and see what tests we can get rid of.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|rtx
name|newtest
decl_stmt|,
name|newval
decl_stmt|;
comment|/* Simplify this test.  */
name|newtest
operator|=
name|simplify_test_exp_in_temp
argument_list|(
name|tests
index|[
name|i
index|]
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
name|tests
index|[
name|i
index|]
operator|=
name|newtest
expr_stmt|;
name|newval
operator|=
name|tests
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
comment|/* See if this value may need simplification.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|newval
argument_list|)
operator|==
name|COND
condition|)
name|newval
operator|=
name|simplify_cond
argument_list|(
name|newval
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
comment|/* Look for ways to delete or combine this test.  */
if|if
condition|(
name|newtest
operator|==
name|true_rtx
condition|)
block|{
comment|/* If test is true, make this value the default 	     and discard this + any following tests.  */
name|len
operator|=
name|i
expr_stmt|;
name|defval
operator|=
name|tests
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|new_defval
operator|=
name|newval
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|newtest
operator|==
name|false_rtx
condition|)
block|{
comment|/* If test is false, discard it and its value.  */
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|len
operator|-
literal|2
condition|;
name|j
operator|++
control|)
name|tests
index|[
name|j
index|]
operator|=
name|tests
index|[
name|j
operator|+
literal|2
index|]
expr_stmt|;
name|i
operator|-=
literal|2
expr_stmt|;
name|len
operator|-=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
name|attr_equal_p
argument_list|(
name|newval
argument_list|,
name|tests
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
comment|/* If this value and the value for the prev test are the same, 	     merge the tests.  */
name|tests
index|[
name|i
operator|-
literal|2
index|]
operator|=
name|insert_right_side
argument_list|(
name|IOR
argument_list|,
name|tests
index|[
name|i
operator|-
literal|2
index|]
argument_list|,
name|newtest
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
comment|/* Delete this test/value.  */
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|len
operator|-
literal|2
condition|;
name|j
operator|++
control|)
name|tests
index|[
name|j
index|]
operator|=
name|tests
index|[
name|j
operator|+
literal|2
index|]
expr_stmt|;
name|len
operator|-=
literal|2
expr_stmt|;
name|i
operator|-=
literal|2
expr_stmt|;
block|}
else|else
name|tests
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|newval
expr_stmt|;
block|}
comment|/* If the last test in a COND has the same value      as the default value, that test isn't needed.  */
while|while
condition|(
name|len
operator|>
literal|0
operator|&&
name|attr_equal_p
argument_list|(
name|tests
index|[
name|len
operator|-
literal|1
index|]
argument_list|,
name|new_defval
argument_list|)
condition|)
name|len
operator|-=
literal|2
expr_stmt|;
comment|/* See if we changed anything.  */
if|if
condition|(
name|len
operator|!=
name|XVECLEN
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|||
name|new_defval
operator|!=
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
condition|)
name|allsame
operator|=
literal|0
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|attr_equal_p
argument_list|(
name|tests
index|[
name|i
index|]
argument_list|,
name|XVECEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|allsame
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|defval
argument_list|)
operator|==
name|COND
condition|)
name|ret
operator|=
name|simplify_cond
argument_list|(
name|defval
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|defval
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|allsame
condition|)
name|ret
operator|=
name|exp
expr_stmt|;
else|else
block|{
name|rtx
name|newexp
init|=
name|rtx_alloc
argument_list|(
name|COND
argument_list|)
decl_stmt|;
name|XVEC
argument_list|(
name|newexp
argument_list|,
literal|0
argument_list|)
operator|=
name|rtvec_alloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|XVEC
argument_list|(
name|newexp
argument_list|,
literal|0
argument_list|)
operator|->
name|elem
argument_list|,
name|tests
argument_list|,
name|len
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|newexp
argument_list|,
literal|1
argument_list|)
operator|=
name|new_defval
expr_stmt|;
name|ret
operator|=
name|newexp
expr_stmt|;
block|}
name|free
argument_list|(
name|tests
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Remove an insn entry from an attribute value.  */
end_comment

begin_function
specifier|static
name|void
name|remove_insn_ent
parameter_list|(
name|struct
name|attr_value
modifier|*
name|av
parameter_list|,
name|struct
name|insn_ent
modifier|*
name|ie
parameter_list|)
block|{
name|struct
name|insn_ent
modifier|*
name|previe
decl_stmt|;
if|if
condition|(
name|av
operator|->
name|first_insn
operator|==
name|ie
condition|)
name|av
operator|->
name|first_insn
operator|=
name|ie
operator|->
name|next
expr_stmt|;
else|else
block|{
for|for
control|(
name|previe
operator|=
name|av
operator|->
name|first_insn
init|;
name|previe
operator|->
name|next
operator|!=
name|ie
condition|;
name|previe
operator|=
name|previe
operator|->
name|next
control|)
empty_stmt|;
name|previe
operator|->
name|next
operator|=
name|ie
operator|->
name|next
expr_stmt|;
block|}
name|av
operator|->
name|num_insns
operator|--
expr_stmt|;
if|if
condition|(
name|ie
operator|->
name|def
operator|->
name|insn_code
operator|==
operator|-
literal|1
condition|)
name|av
operator|->
name|has_asm_insn
operator|=
literal|0
expr_stmt|;
name|num_insn_ents
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Insert an insn entry in an attribute value list.  */
end_comment

begin_function
specifier|static
name|void
name|insert_insn_ent
parameter_list|(
name|struct
name|attr_value
modifier|*
name|av
parameter_list|,
name|struct
name|insn_ent
modifier|*
name|ie
parameter_list|)
block|{
name|ie
operator|->
name|next
operator|=
name|av
operator|->
name|first_insn
expr_stmt|;
name|av
operator|->
name|first_insn
operator|=
name|ie
expr_stmt|;
name|av
operator|->
name|num_insns
operator|++
expr_stmt|;
if|if
condition|(
name|ie
operator|->
name|def
operator|->
name|insn_code
operator|==
operator|-
literal|1
condition|)
name|av
operator|->
name|has_asm_insn
operator|=
literal|1
expr_stmt|;
name|num_insn_ents
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is a utility routine to take an expression that is a tree of either    AND or IOR expressions and insert a new term.  The new term will be    inserted at the right side of the first node whose code does not match    the root.  A new node will be created with the root's code.  Its left    side will be the old right side and its right side will be the new    term.     If the `term' is itself a tree, all its leaves will be inserted.  */
end_comment

begin_function
specifier|static
name|rtx
name|insert_right_side
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|rtx
name|exp
parameter_list|,
name|rtx
name|term
parameter_list|,
name|int
name|insn_code
parameter_list|,
name|int
name|insn_index
parameter_list|)
block|{
name|rtx
name|newexp
decl_stmt|;
comment|/* Avoid consing in some special cases.  */
if|if
condition|(
name|code
operator|==
name|AND
operator|&&
name|term
operator|==
name|true_rtx
condition|)
return|return
name|exp
return|;
if|if
condition|(
name|code
operator|==
name|AND
operator|&&
name|term
operator|==
name|false_rtx
condition|)
return|return
name|false_rtx
return|;
if|if
condition|(
name|code
operator|==
name|AND
operator|&&
name|exp
operator|==
name|true_rtx
condition|)
return|return
name|term
return|;
if|if
condition|(
name|code
operator|==
name|AND
operator|&&
name|exp
operator|==
name|false_rtx
condition|)
return|return
name|false_rtx
return|;
if|if
condition|(
name|code
operator|==
name|IOR
operator|&&
name|term
operator|==
name|true_rtx
condition|)
return|return
name|true_rtx
return|;
if|if
condition|(
name|code
operator|==
name|IOR
operator|&&
name|term
operator|==
name|false_rtx
condition|)
return|return
name|exp
return|;
if|if
condition|(
name|code
operator|==
name|IOR
operator|&&
name|exp
operator|==
name|true_rtx
condition|)
return|return
name|true_rtx
return|;
if|if
condition|(
name|code
operator|==
name|IOR
operator|&&
name|exp
operator|==
name|false_rtx
condition|)
return|return
name|term
return|;
if|if
condition|(
name|attr_equal_p
argument_list|(
name|exp
argument_list|,
name|term
argument_list|)
condition|)
return|return
name|exp
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|term
argument_list|)
operator|==
name|code
condition|)
block|{
name|exp
operator|=
name|insert_right_side
argument_list|(
name|code
argument_list|,
name|exp
argument_list|,
name|XEXP
argument_list|(
name|term
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
name|exp
operator|=
name|insert_right_side
argument_list|(
name|code
argument_list|,
name|exp
argument_list|,
name|XEXP
argument_list|(
name|term
argument_list|,
literal|1
argument_list|)
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
return|return
name|exp
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|code
condition|)
block|{
name|rtx
name|new
init|=
name|insert_right_side
argument_list|(
name|code
argument_list|,
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|term
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
decl_stmt|;
if|if
condition|(
name|new
operator|!=
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
condition|)
comment|/* Make a copy of this expression and call recursively.  */
name|newexp
operator|=
name|attr_rtx
argument_list|(
name|code
argument_list|,
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|new
argument_list|)
expr_stmt|;
else|else
name|newexp
operator|=
name|exp
expr_stmt|;
block|}
else|else
block|{
comment|/* Insert the new term.  */
name|newexp
operator|=
name|attr_rtx
argument_list|(
name|code
argument_list|,
name|exp
argument_list|,
name|term
argument_list|)
expr_stmt|;
block|}
return|return
name|simplify_test_exp_in_temp
argument_list|(
name|newexp
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If we have an expression which AND's a bunch of 	(not (eq_attrq "alternative" "n"))    terms, we may have covered all or all but one of the possible alternatives.    If so, we can optimize.  Similarly for IOR's of EQ_ATTR.     This routine is passed an expression and either AND or IOR.  It returns a    bitmask indicating which alternatives are mentioned within EXP.  */
end_comment

begin_function
specifier|static
name|int
name|compute_alternative_mask
parameter_list|(
name|rtx
name|exp
parameter_list|,
name|enum
name|rtx_code
name|code
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|code
condition|)
return|return
name|compute_alternative_mask
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|code
argument_list|)
operator||
name|compute_alternative_mask
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|code
argument_list|)
return|;
elseif|else
if|if
condition|(
name|code
operator|==
name|AND
operator|&&
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NOT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|EQ_ATTR
operator|&&
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|alternative_name
condition|)
name|string
operator|=
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|IOR
operator|&&
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|EQ_ATTR
operator|&&
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|==
name|alternative_name
condition|)
name|string
operator|=
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|EQ_ATTR_ALT
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|AND
operator|&&
name|XINT
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|XINT
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|IOR
operator|&&
operator|!
name|XINT
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|XINT
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
return|;
return|return
literal|0
return|;
block|}
else|else
return|return
literal|0
return|;
if|if
condition|(
name|string
index|[
literal|1
index|]
operator|==
literal|0
condition|)
return|return
literal|1
operator|<<
operator|(
name|string
index|[
literal|0
index|]
operator|-
literal|'0'
operator|)
return|;
return|return
literal|1
operator|<<
name|atoi
argument_list|(
name|string
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given I, a single-bit mask, return RTX to compare the `alternative'    attribute with the value represented by that bit.  */
end_comment

begin_function
specifier|static
name|rtx
name|make_alternative_compare
parameter_list|(
name|int
name|mask
parameter_list|)
block|{
return|return
name|mk_attr_alt
argument_list|(
name|mask
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If we are processing an (eq_attr "attr" "value") test, we find the value    of "attr" for this insn code.  From that value, we can compute a test    showing when the EQ_ATTR will be true.  This routine performs that    computation.  If a test condition involves an address, we leave the EQ_ATTR    intact because addresses are only valid for the `length' attribute.     EXP is the EQ_ATTR expression and VALUE is the value of that attribute    for the insn corresponding to INSN_CODE and INSN_INDEX.  */
end_comment

begin_function
specifier|static
name|rtx
name|evaluate_eq_attr
parameter_list|(
name|rtx
name|exp
parameter_list|,
name|rtx
name|value
parameter_list|,
name|int
name|insn_code
parameter_list|,
name|int
name|insn_index
parameter_list|)
block|{
name|rtx
name|orexp
decl_stmt|,
name|andexp
decl_stmt|;
name|rtx
name|right
decl_stmt|;
name|rtx
name|newexp
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
condition|)
block|{
case|case
name|CONST_STRING
case|:
if|if
condition|(
operator|!
name|strcmp_check
argument_list|(
name|XSTR
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|newexp
operator|=
name|true_rtx
expr_stmt|;
else|else
name|newexp
operator|=
name|false_rtx
expr_stmt|;
break|break;
case|case
name|SYMBOL_REF
case|:
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|string
index|[
literal|256
index|]
decl_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|EQ_ATTR
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|strlen
argument_list|(
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|+
name|strlen
argument_list|(
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|+
literal|2
operator|<=
literal|256
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|string
argument_list|,
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|string
argument_list|,
literal|"_"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|string
argument_list|,
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|string
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
operator|*
name|p
operator|=
name|TOUPPER
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|newexp
operator|=
name|attr_rtx
argument_list|(
name|EQ
argument_list|,
name|value
argument_list|,
name|attr_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|DEF_ATTR_STRING
argument_list|(
name|string
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|COND
case|:
comment|/* We construct an IOR of all the cases for which the 	 requested attribute value is present.  Since we start with 	 FALSE, if it is not present, FALSE will be returned. 	   	 Each case is the AND of the NOT's of the previous conditions with the 	 current condition; in the default case the current condition is TRUE. 	   	 For each possible COND value, call ourselves recursively. 	   	 The extra TRUE and FALSE expressions will be eliminated by another 	 call to the simplification routine.  */
name|orexp
operator|=
name|false_rtx
expr_stmt|;
name|andexp
operator|=
name|true_rtx
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|rtx
name|this
init|=
name|simplify_test_exp_in_temp
argument_list|(
name|XVECEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
decl_stmt|;
name|right
operator|=
name|insert_right_side
argument_list|(
name|AND
argument_list|,
name|andexp
argument_list|,
name|this
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
name|right
operator|=
name|insert_right_side
argument_list|(
name|AND
argument_list|,
name|right
argument_list|,
name|evaluate_eq_attr
argument_list|(
name|exp
argument_list|,
name|XVECEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|,
name|i
operator|+
literal|1
argument_list|)
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
name|orexp
operator|=
name|insert_right_side
argument_list|(
name|IOR
argument_list|,
name|orexp
argument_list|,
name|right
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
comment|/* Add this condition into the AND expression.  */
name|newexp
operator|=
name|attr_rtx
argument_list|(
name|NOT
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|andexp
operator|=
name|insert_right_side
argument_list|(
name|AND
argument_list|,
name|andexp
argument_list|,
name|newexp
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
block|}
comment|/* Handle the default case.  */
name|right
operator|=
name|insert_right_side
argument_list|(
name|AND
argument_list|,
name|andexp
argument_list|,
name|evaluate_eq_attr
argument_list|(
name|exp
argument_list|,
name|XEXP
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
name|newexp
operator|=
name|insert_right_side
argument_list|(
name|IOR
argument_list|,
name|orexp
argument_list|,
name|right
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
comment|/* If uses an address, must return original expression.  But set the      ATTR_IND_SIMPLIFIED_P bit so we don't try to simplify it again.  */
name|address_used
operator|=
literal|0
expr_stmt|;
name|walk_attr_value
argument_list|(
name|newexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|address_used
condition|)
block|{
if|if
condition|(
operator|!
name|ATTR_IND_SIMPLIFIED_P
argument_list|(
name|exp
argument_list|)
condition|)
return|return
name|copy_rtx_unchanging
argument_list|(
name|exp
argument_list|)
return|;
return|return
name|exp
return|;
block|}
else|else
return|return
name|newexp
return|;
block|}
end_function

begin_comment
comment|/* This routine is called when an AND of a term with a tree of AND's is    encountered.  If the term or its complement is present in the tree, it    can be replaced with TRUE or FALSE, respectively.     Note that (eq_attr "att" "v1") and (eq_attr "att" "v2") cannot both    be true and hence are complementary.     There is one special case:  If we see 	(and (not (eq_attr "att" "v1")) 	     (eq_attr "att" "v2"))    this can be replaced by (eq_attr "att" "v2").  To do this we need to    replace the term, not anything in the AND tree.  So we pass a pointer to    the term.  */
end_comment

begin_function
specifier|static
name|rtx
name|simplify_and_tree
parameter_list|(
name|rtx
name|exp
parameter_list|,
name|rtx
modifier|*
name|pterm
parameter_list|,
name|int
name|insn_code
parameter_list|,
name|int
name|insn_index
parameter_list|)
block|{
name|rtx
name|left
decl_stmt|,
name|right
decl_stmt|;
name|rtx
name|newexp
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
name|int
name|left_eliminates_term
decl_stmt|,
name|right_eliminates_term
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|AND
condition|)
block|{
name|left
operator|=
name|simplify_and_tree
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|pterm
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
name|right
operator|=
name|simplify_and_tree
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|pterm
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|left
operator|!=
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|||
name|right
operator|!=
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|newexp
operator|=
name|attr_rtx
argument_list|(
name|AND
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
expr_stmt|;
name|exp
operator|=
name|simplify_test_exp_in_temp
argument_list|(
name|newexp
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|IOR
condition|)
block|{
comment|/* For the IOR case, we do the same as above, except that we can          only eliminate `term' if both sides of the IOR would do so.  */
name|temp
operator|=
operator|*
name|pterm
expr_stmt|;
name|left
operator|=
name|simplify_and_tree
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|temp
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
name|left_eliminates_term
operator|=
operator|(
name|temp
operator|==
name|true_rtx
operator|)
expr_stmt|;
name|temp
operator|=
operator|*
name|pterm
expr_stmt|;
name|right
operator|=
name|simplify_and_tree
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|&
name|temp
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
name|right_eliminates_term
operator|=
operator|(
name|temp
operator|==
name|true_rtx
operator|)
expr_stmt|;
if|if
condition|(
name|left_eliminates_term
operator|&&
name|right_eliminates_term
condition|)
operator|*
name|pterm
operator|=
name|true_rtx
expr_stmt|;
if|if
condition|(
name|left
operator|!=
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|||
name|right
operator|!=
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|newexp
operator|=
name|attr_rtx
argument_list|(
name|IOR
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
expr_stmt|;
name|exp
operator|=
name|simplify_test_exp_in_temp
argument_list|(
name|newexp
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Check for simplifications.  Do some extra checking here since this      routine is called so many times.  */
if|if
condition|(
name|exp
operator|==
operator|*
name|pterm
condition|)
return|return
name|true_rtx
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NOT
operator|&&
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|==
operator|*
name|pterm
condition|)
return|return
name|false_rtx
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|pterm
argument_list|)
operator|==
name|NOT
operator|&&
name|exp
operator|==
name|XEXP
argument_list|(
operator|*
name|pterm
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false_rtx
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|EQ_ATTR_ALT
operator|&&
name|GET_CODE
argument_list|(
operator|*
name|pterm
argument_list|)
operator|==
name|EQ_ATTR_ALT
condition|)
block|{
if|if
condition|(
name|attr_alt_subset_p
argument_list|(
operator|*
name|pterm
argument_list|,
name|exp
argument_list|)
condition|)
return|return
name|true_rtx
return|;
if|if
condition|(
name|attr_alt_subset_of_compl_p
argument_list|(
operator|*
name|pterm
argument_list|,
name|exp
argument_list|)
condition|)
return|return
name|false_rtx
return|;
if|if
condition|(
name|attr_alt_subset_p
argument_list|(
name|exp
argument_list|,
operator|*
name|pterm
argument_list|)
condition|)
operator|*
name|pterm
operator|=
name|true_rtx
expr_stmt|;
return|return
name|exp
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|EQ_ATTR
operator|&&
name|GET_CODE
argument_list|(
operator|*
name|pterm
argument_list|)
operator|==
name|EQ_ATTR
condition|)
block|{
if|if
condition|(
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|!=
name|XSTR
argument_list|(
operator|*
name|pterm
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|exp
return|;
if|if
condition|(
operator|!
name|strcmp_check
argument_list|(
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XSTR
argument_list|(
operator|*
name|pterm
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|true_rtx
return|;
else|else
return|return
name|false_rtx
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|pterm
argument_list|)
operator|==
name|EQ_ATTR
operator|&&
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NOT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|EQ_ATTR
condition|)
block|{
if|if
condition|(
name|XSTR
argument_list|(
operator|*
name|pterm
argument_list|,
literal|0
argument_list|)
operator|!=
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|exp
return|;
if|if
condition|(
operator|!
name|strcmp_check
argument_list|(
name|XSTR
argument_list|(
operator|*
name|pterm
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|false_rtx
return|;
else|else
return|return
name|true_rtx
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|EQ_ATTR
operator|&&
name|GET_CODE
argument_list|(
operator|*
name|pterm
argument_list|)
operator|==
name|NOT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
operator|*
name|pterm
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|EQ_ATTR
condition|)
block|{
if|if
condition|(
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|!=
name|XSTR
argument_list|(
name|XEXP
argument_list|(
operator|*
name|pterm
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|exp
return|;
if|if
condition|(
operator|!
name|strcmp_check
argument_list|(
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XSTR
argument_list|(
name|XEXP
argument_list|(
operator|*
name|pterm
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|false_rtx
return|;
else|else
operator|*
name|pterm
operator|=
name|true_rtx
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NOT
operator|&&
name|GET_CODE
argument_list|(
operator|*
name|pterm
argument_list|)
operator|==
name|NOT
condition|)
block|{
if|if
condition|(
name|attr_equal_p
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
operator|*
name|pterm
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|true_rtx
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NOT
condition|)
block|{
if|if
condition|(
name|attr_equal_p
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|*
name|pterm
argument_list|)
condition|)
return|return
name|false_rtx
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|pterm
argument_list|)
operator|==
name|NOT
condition|)
block|{
if|if
condition|(
name|attr_equal_p
argument_list|(
name|XEXP
argument_list|(
operator|*
name|pterm
argument_list|,
literal|0
argument_list|)
argument_list|,
name|exp
argument_list|)
condition|)
return|return
name|false_rtx
return|;
block|}
elseif|else
if|if
condition|(
name|attr_equal_p
argument_list|(
name|exp
argument_list|,
operator|*
name|pterm
argument_list|)
condition|)
return|return
name|true_rtx
return|;
return|return
name|exp
return|;
block|}
end_function

begin_comment
comment|/* Similar to `simplify_and_tree', but for IOR trees.  */
end_comment

begin_function
specifier|static
name|rtx
name|simplify_or_tree
parameter_list|(
name|rtx
name|exp
parameter_list|,
name|rtx
modifier|*
name|pterm
parameter_list|,
name|int
name|insn_code
parameter_list|,
name|int
name|insn_index
parameter_list|)
block|{
name|rtx
name|left
decl_stmt|,
name|right
decl_stmt|;
name|rtx
name|newexp
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
name|int
name|left_eliminates_term
decl_stmt|,
name|right_eliminates_term
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|IOR
condition|)
block|{
name|left
operator|=
name|simplify_or_tree
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|pterm
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
name|right
operator|=
name|simplify_or_tree
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|pterm
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|left
operator|!=
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|||
name|right
operator|!=
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|newexp
operator|=
name|attr_rtx
argument_list|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
expr_stmt|;
name|exp
operator|=
name|simplify_test_exp_in_temp
argument_list|(
name|newexp
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|AND
condition|)
block|{
comment|/* For the AND case, we do the same as above, except that we can          only eliminate `term' if both sides of the AND would do so.  */
name|temp
operator|=
operator|*
name|pterm
expr_stmt|;
name|left
operator|=
name|simplify_or_tree
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|temp
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
name|left_eliminates_term
operator|=
operator|(
name|temp
operator|==
name|false_rtx
operator|)
expr_stmt|;
name|temp
operator|=
operator|*
name|pterm
expr_stmt|;
name|right
operator|=
name|simplify_or_tree
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|&
name|temp
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
name|right_eliminates_term
operator|=
operator|(
name|temp
operator|==
name|false_rtx
operator|)
expr_stmt|;
if|if
condition|(
name|left_eliminates_term
operator|&&
name|right_eliminates_term
condition|)
operator|*
name|pterm
operator|=
name|false_rtx
expr_stmt|;
if|if
condition|(
name|left
operator|!=
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|||
name|right
operator|!=
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|newexp
operator|=
name|attr_rtx
argument_list|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
expr_stmt|;
name|exp
operator|=
name|simplify_test_exp_in_temp
argument_list|(
name|newexp
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|attr_equal_p
argument_list|(
name|exp
argument_list|,
operator|*
name|pterm
argument_list|)
condition|)
return|return
name|false_rtx
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NOT
operator|&&
name|attr_equal_p
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|*
name|pterm
argument_list|)
condition|)
return|return
name|true_rtx
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|pterm
argument_list|)
operator|==
name|NOT
operator|&&
name|attr_equal_p
argument_list|(
name|XEXP
argument_list|(
operator|*
name|pterm
argument_list|,
literal|0
argument_list|)
argument_list|,
name|exp
argument_list|)
condition|)
return|return
name|true_rtx
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|pterm
argument_list|)
operator|==
name|EQ_ATTR
operator|&&
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NOT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|EQ_ATTR
operator|&&
name|XSTR
argument_list|(
operator|*
name|pterm
argument_list|,
literal|0
argument_list|)
operator|==
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
operator|*
name|pterm
operator|=
name|false_rtx
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|EQ_ATTR
operator|&&
name|GET_CODE
argument_list|(
operator|*
name|pterm
argument_list|)
operator|==
name|NOT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
operator|*
name|pterm
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|EQ_ATTR
operator|&&
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|==
name|XSTR
argument_list|(
name|XEXP
argument_list|(
operator|*
name|pterm
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false_rtx
return|;
return|return
name|exp
return|;
block|}
end_function

begin_comment
comment|/* Compute approximate cost of the expression.  Used to decide whether    expression is cheap enough for inline.  */
end_comment

begin_function
specifier|static
name|int
name|attr_rtx_cost
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|int
name|cost
init|=
literal|0
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
if|if
condition|(
operator|!
name|x
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|MATCH_OPERAND
case|:
if|if
condition|(
name|XSTR
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
index|[
literal|0
index|]
condition|)
return|return
literal|10
return|;
else|else
return|return
literal|0
return|;
case|case
name|EQ_ATTR_ALT
case|:
return|return
literal|0
return|;
case|case
name|EQ_ATTR
case|:
comment|/* Alternatives don't result into function call.  */
if|if
condition|(
operator|!
name|strcmp_check
argument_list|(
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|alternative_name
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
return|return
literal|5
return|;
default|default:
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
switch|switch
condition|(
name|fmt
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'V'
case|:
case|case
literal|'E'
case|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|cost
operator|+=
name|attr_rtx_cost
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|cost
operator|+=
name|attr_rtx_cost
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
break|break;
block|}
return|return
name|cost
return|;
block|}
end_function

begin_comment
comment|/* Simplify test expression and use temporary obstack in order to avoid    memory bloat.  Use ATTR_IND_SIMPLIFIED to avoid unnecessary simplifications    and avoid unnecessary copying if possible.  */
end_comment

begin_function
specifier|static
name|rtx
name|simplify_test_exp_in_temp
parameter_list|(
name|rtx
name|exp
parameter_list|,
name|int
name|insn_code
parameter_list|,
name|int
name|insn_index
parameter_list|)
block|{
name|rtx
name|x
decl_stmt|;
name|struct
name|obstack
modifier|*
name|old
decl_stmt|;
if|if
condition|(
name|ATTR_IND_SIMPLIFIED_P
argument_list|(
name|exp
argument_list|)
condition|)
return|return
name|exp
return|;
name|old
operator|=
name|rtl_obstack
expr_stmt|;
name|rtl_obstack
operator|=
name|temp_obstack
expr_stmt|;
name|x
operator|=
name|simplify_test_exp
argument_list|(
name|exp
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
name|rtl_obstack
operator|=
name|old
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|exp
operator|||
name|rtl_obstack
operator|==
name|temp_obstack
condition|)
return|return
name|x
return|;
return|return
name|attr_copy_rtx
argument_list|(
name|x
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns true if S1 is a subset of S2.  */
end_comment

begin_function
specifier|static
name|bool
name|attr_alt_subset_p
parameter_list|(
name|rtx
name|s1
parameter_list|,
name|rtx
name|s2
parameter_list|)
block|{
switch|switch
condition|(
operator|(
name|XINT
argument_list|(
name|s1
argument_list|,
literal|1
argument_list|)
operator|<<
literal|1
operator|)
operator||
name|XINT
argument_list|(
name|s2
argument_list|,
literal|1
argument_list|)
condition|)
block|{
case|case
operator|(
literal|0
operator|<<
literal|1
operator|)
operator||
literal|0
case|:
return|return
operator|!
operator|(
name|XINT
argument_list|(
name|s1
argument_list|,
literal|0
argument_list|)
operator|&
operator|~
name|XINT
argument_list|(
name|s2
argument_list|,
literal|0
argument_list|)
operator|)
return|;
case|case
operator|(
literal|0
operator|<<
literal|1
operator|)
operator||
literal|1
case|:
return|return
operator|!
operator|(
name|XINT
argument_list|(
name|s1
argument_list|,
literal|0
argument_list|)
operator|&
name|XINT
argument_list|(
name|s2
argument_list|,
literal|0
argument_list|)
operator|)
return|;
case|case
operator|(
literal|1
operator|<<
literal|1
operator|)
operator||
literal|0
case|:
return|return
name|false
return|;
case|case
operator|(
literal|1
operator|<<
literal|1
operator|)
operator||
literal|1
case|:
return|return
operator|!
operator|(
name|XINT
argument_list|(
name|s2
argument_list|,
literal|0
argument_list|)
operator|&
operator|~
name|XINT
argument_list|(
name|s1
argument_list|,
literal|0
argument_list|)
operator|)
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Returns true if S1 is a subset of complement of S2.  */
end_comment

begin_function
specifier|static
name|bool
name|attr_alt_subset_of_compl_p
parameter_list|(
name|rtx
name|s1
parameter_list|,
name|rtx
name|s2
parameter_list|)
block|{
switch|switch
condition|(
operator|(
name|XINT
argument_list|(
name|s1
argument_list|,
literal|1
argument_list|)
operator|<<
literal|1
operator|)
operator||
name|XINT
argument_list|(
name|s2
argument_list|,
literal|1
argument_list|)
condition|)
block|{
case|case
operator|(
literal|0
operator|<<
literal|1
operator|)
operator||
literal|0
case|:
return|return
operator|!
operator|(
name|XINT
argument_list|(
name|s1
argument_list|,
literal|0
argument_list|)
operator|&
name|XINT
argument_list|(
name|s2
argument_list|,
literal|0
argument_list|)
operator|)
return|;
case|case
operator|(
literal|0
operator|<<
literal|1
operator|)
operator||
literal|1
case|:
return|return
operator|!
operator|(
name|XINT
argument_list|(
name|s1
argument_list|,
literal|0
argument_list|)
operator|&
operator|~
name|XINT
argument_list|(
name|s2
argument_list|,
literal|0
argument_list|)
operator|)
return|;
case|case
operator|(
literal|1
operator|<<
literal|1
operator|)
operator||
literal|0
case|:
return|return
operator|!
operator|(
name|XINT
argument_list|(
name|s2
argument_list|,
literal|0
argument_list|)
operator|&
operator|~
name|XINT
argument_list|(
name|s1
argument_list|,
literal|0
argument_list|)
operator|)
return|;
case|case
operator|(
literal|1
operator|<<
literal|1
operator|)
operator||
literal|1
case|:
return|return
name|false
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return EQ_ATTR_ALT expression representing intersection of S1 and S2.  */
end_comment

begin_function
specifier|static
name|rtx
name|attr_alt_intersection
parameter_list|(
name|rtx
name|s1
parameter_list|,
name|rtx
name|s2
parameter_list|)
block|{
name|rtx
name|result
init|=
name|rtx_alloc
argument_list|(
name|EQ_ATTR_ALT
argument_list|)
decl_stmt|;
switch|switch
condition|(
operator|(
name|XINT
argument_list|(
name|s1
argument_list|,
literal|1
argument_list|)
operator|<<
literal|1
operator|)
operator||
name|XINT
argument_list|(
name|s2
argument_list|,
literal|1
argument_list|)
condition|)
block|{
case|case
operator|(
literal|0
operator|<<
literal|1
operator|)
operator||
literal|0
case|:
name|XINT
argument_list|(
name|result
argument_list|,
literal|0
argument_list|)
operator|=
name|XINT
argument_list|(
name|s1
argument_list|,
literal|0
argument_list|)
operator|&
name|XINT
argument_list|(
name|s2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
literal|0
operator|<<
literal|1
operator|)
operator||
literal|1
case|:
name|XINT
argument_list|(
name|result
argument_list|,
literal|0
argument_list|)
operator|=
name|XINT
argument_list|(
name|s1
argument_list|,
literal|0
argument_list|)
operator|&
operator|~
name|XINT
argument_list|(
name|s2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
literal|1
operator|<<
literal|1
operator|)
operator||
literal|0
case|:
name|XINT
argument_list|(
name|result
argument_list|,
literal|0
argument_list|)
operator|=
name|XINT
argument_list|(
name|s2
argument_list|,
literal|0
argument_list|)
operator|&
operator|~
name|XINT
argument_list|(
name|s1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
literal|1
operator|<<
literal|1
operator|)
operator||
literal|1
case|:
name|XINT
argument_list|(
name|result
argument_list|,
literal|0
argument_list|)
operator|=
name|XINT
argument_list|(
name|s1
argument_list|,
literal|0
argument_list|)
operator||
name|XINT
argument_list|(
name|s2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|XINT
argument_list|(
name|result
argument_list|,
literal|1
argument_list|)
operator|=
name|XINT
argument_list|(
name|s1
argument_list|,
literal|1
argument_list|)
operator|&
name|XINT
argument_list|(
name|s2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Return EQ_ATTR_ALT expression representing union of S1 and S2.  */
end_comment

begin_function
specifier|static
name|rtx
name|attr_alt_union
parameter_list|(
name|rtx
name|s1
parameter_list|,
name|rtx
name|s2
parameter_list|)
block|{
name|rtx
name|result
init|=
name|rtx_alloc
argument_list|(
name|EQ_ATTR_ALT
argument_list|)
decl_stmt|;
switch|switch
condition|(
operator|(
name|XINT
argument_list|(
name|s1
argument_list|,
literal|1
argument_list|)
operator|<<
literal|1
operator|)
operator||
name|XINT
argument_list|(
name|s2
argument_list|,
literal|1
argument_list|)
condition|)
block|{
case|case
operator|(
literal|0
operator|<<
literal|1
operator|)
operator||
literal|0
case|:
name|XINT
argument_list|(
name|result
argument_list|,
literal|0
argument_list|)
operator|=
name|XINT
argument_list|(
name|s1
argument_list|,
literal|0
argument_list|)
operator||
name|XINT
argument_list|(
name|s2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
literal|0
operator|<<
literal|1
operator|)
operator||
literal|1
case|:
name|XINT
argument_list|(
name|result
argument_list|,
literal|0
argument_list|)
operator|=
name|XINT
argument_list|(
name|s2
argument_list|,
literal|0
argument_list|)
operator|&
operator|~
name|XINT
argument_list|(
name|s1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
literal|1
operator|<<
literal|1
operator|)
operator||
literal|0
case|:
name|XINT
argument_list|(
name|result
argument_list|,
literal|0
argument_list|)
operator|=
name|XINT
argument_list|(
name|s1
argument_list|,
literal|0
argument_list|)
operator|&
operator|~
name|XINT
argument_list|(
name|s2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
literal|1
operator|<<
literal|1
operator|)
operator||
literal|1
case|:
name|XINT
argument_list|(
name|result
argument_list|,
literal|0
argument_list|)
operator|=
name|XINT
argument_list|(
name|s1
argument_list|,
literal|0
argument_list|)
operator|&
name|XINT
argument_list|(
name|s2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|XINT
argument_list|(
name|result
argument_list|,
literal|1
argument_list|)
operator|=
name|XINT
argument_list|(
name|s1
argument_list|,
literal|1
argument_list|)
operator||
name|XINT
argument_list|(
name|s2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Return EQ_ATTR_ALT expression representing complement of S.  */
end_comment

begin_function
specifier|static
name|rtx
name|attr_alt_complement
parameter_list|(
name|rtx
name|s
parameter_list|)
block|{
name|rtx
name|result
init|=
name|rtx_alloc
argument_list|(
name|EQ_ATTR_ALT
argument_list|)
decl_stmt|;
name|XINT
argument_list|(
name|result
argument_list|,
literal|0
argument_list|)
operator|=
name|XINT
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XINT
argument_list|(
name|result
argument_list|,
literal|1
argument_list|)
operator|=
literal|1
operator|-
name|XINT
argument_list|(
name|s
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Return EQ_ATTR_ALT expression representing set containing elements set    in E.  */
end_comment

begin_function
specifier|static
name|rtx
name|mk_attr_alt
parameter_list|(
name|int
name|e
parameter_list|)
block|{
name|rtx
name|result
init|=
name|rtx_alloc
argument_list|(
name|EQ_ATTR_ALT
argument_list|)
decl_stmt|;
name|XINT
argument_list|(
name|result
argument_list|,
literal|0
argument_list|)
operator|=
name|e
expr_stmt|;
name|XINT
argument_list|(
name|result
argument_list|,
literal|1
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Given an expression, see if it can be simplified for a particular insn    code based on the values of other attributes being tested.  This can    eliminate nested get_attr_... calls.     Note that if an endless recursion is specified in the patterns, the    optimization will loop.  However, it will do so in precisely the cases where    an infinite recursion loop could occur during compilation.  It's better that    it occurs here!  */
end_comment

begin_function
specifier|static
name|rtx
name|simplify_test_exp
parameter_list|(
name|rtx
name|exp
parameter_list|,
name|int
name|insn_code
parameter_list|,
name|int
name|insn_index
parameter_list|)
block|{
name|rtx
name|left
decl_stmt|,
name|right
decl_stmt|;
name|struct
name|attr_desc
modifier|*
name|attr
decl_stmt|;
name|struct
name|attr_value
modifier|*
name|av
decl_stmt|;
name|struct
name|insn_ent
modifier|*
name|ie
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rtx
name|newexp
init|=
name|exp
decl_stmt|;
name|bool
name|left_alt
decl_stmt|,
name|right_alt
decl_stmt|;
comment|/* Don't re-simplify something we already simplified.  */
if|if
condition|(
name|ATTR_IND_SIMPLIFIED_P
argument_list|(
name|exp
argument_list|)
operator|||
name|ATTR_CURR_SIMPLIFIED_P
argument_list|(
name|exp
argument_list|)
condition|)
return|return
name|exp
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|AND
case|:
name|left
operator|=
name|SIMPLIFY_TEST_EXP
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|left
operator|==
name|false_rtx
condition|)
return|return
name|false_rtx
return|;
name|right
operator|=
name|SIMPLIFY_TEST_EXP
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|right
operator|==
name|false_rtx
condition|)
return|return
name|false_rtx
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|left
argument_list|)
operator|==
name|EQ_ATTR_ALT
operator|&&
name|GET_CODE
argument_list|(
name|right
argument_list|)
operator|==
name|EQ_ATTR_ALT
condition|)
block|{
name|exp
operator|=
name|attr_alt_intersection
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
expr_stmt|;
return|return
name|simplify_test_exp
argument_list|(
name|exp
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
return|;
block|}
comment|/* If either side is an IOR and we have (eq_attr "alternative" ..") 	 present on both sides, apply the distributive law since this will 	 yield simplifications.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|left
argument_list|)
operator|==
name|IOR
operator|||
name|GET_CODE
argument_list|(
name|right
argument_list|)
operator|==
name|IOR
operator|)
operator|&&
name|compute_alternative_mask
argument_list|(
name|left
argument_list|,
name|IOR
argument_list|)
operator|&&
name|compute_alternative_mask
argument_list|(
name|right
argument_list|,
name|IOR
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|left
argument_list|)
operator|==
name|IOR
condition|)
block|{
name|rtx
name|tem
init|=
name|left
decl_stmt|;
name|left
operator|=
name|right
expr_stmt|;
name|right
operator|=
name|tem
expr_stmt|;
block|}
name|newexp
operator|=
name|attr_rtx
argument_list|(
name|IOR
argument_list|,
name|attr_rtx
argument_list|(
name|AND
argument_list|,
name|left
argument_list|,
name|XEXP
argument_list|(
name|right
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|attr_rtx
argument_list|(
name|AND
argument_list|,
name|left
argument_list|,
name|XEXP
argument_list|(
name|right
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SIMPLIFY_TEST_EXP
argument_list|(
name|newexp
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
return|;
block|}
comment|/* Try with the term on both sides.  */
name|right
operator|=
name|simplify_and_tree
argument_list|(
name|right
argument_list|,
operator|&
name|left
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|left
operator|==
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|&&
name|right
operator|==
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
condition|)
name|left
operator|=
name|simplify_and_tree
argument_list|(
name|left
argument_list|,
operator|&
name|right
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|left
operator|==
name|false_rtx
operator|||
name|right
operator|==
name|false_rtx
condition|)
return|return
name|false_rtx
return|;
elseif|else
if|if
condition|(
name|left
operator|==
name|true_rtx
condition|)
block|{
return|return
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|==
name|true_rtx
condition|)
block|{
return|return
name|left
return|;
block|}
comment|/* See if all or all but one of the insn's alternatives are specified 	 in this tree.  Optimize if so.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|left
argument_list|)
operator|==
name|NOT
condition|)
name|left_alt
operator|=
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|left
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|EQ_ATTR
operator|&&
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|left
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|alternative_name
operator|)
expr_stmt|;
else|else
name|left_alt
operator|=
operator|(
name|GET_CODE
argument_list|(
name|left
argument_list|)
operator|==
name|EQ_ATTR_ALT
operator|&&
name|XINT
argument_list|(
name|left
argument_list|,
literal|1
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|right
argument_list|)
operator|==
name|NOT
condition|)
name|right_alt
operator|=
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|right
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|EQ_ATTR
operator|&&
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|right
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|alternative_name
operator|)
expr_stmt|;
else|else
name|right_alt
operator|=
operator|(
name|GET_CODE
argument_list|(
name|right
argument_list|)
operator|==
name|EQ_ATTR_ALT
operator|&&
name|XINT
argument_list|(
name|right
argument_list|,
literal|1
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|insn_code
operator|>=
literal|0
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|left
argument_list|)
operator|==
name|AND
operator|||
name|left_alt
operator|||
name|GET_CODE
argument_list|(
name|right
argument_list|)
operator|==
name|AND
operator|||
name|right_alt
operator|)
condition|)
block|{
name|i
operator|=
name|compute_alternative_mask
argument_list|(
name|exp
argument_list|,
name|AND
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&
operator|~
name|insn_alternatives
index|[
name|insn_code
index|]
condition|)
name|fatal
argument_list|(
literal|"invalid alternative specified for pattern number %d"
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
comment|/* If all alternatives are excluded, this is false.  */
name|i
operator|^=
name|insn_alternatives
index|[
name|insn_code
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
name|false_rtx
return|;
elseif|else
if|if
condition|(
operator|(
name|i
operator|&
operator|(
name|i
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
operator|&&
name|insn_alternatives
index|[
name|insn_code
index|]
operator|>
literal|1
condition|)
block|{
comment|/* If just one excluded, AND a comparison with that one to the 		 front of the tree.  The others will be eliminated by 		 optimization.  We do not want to do this if the insn has one 		 alternative and we have tested none of them!  */
name|left
operator|=
name|make_alternative_compare
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|right
operator|=
name|simplify_and_tree
argument_list|(
name|exp
argument_list|,
operator|&
name|left
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
name|newexp
operator|=
name|attr_rtx
argument_list|(
name|AND
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
expr_stmt|;
return|return
name|SIMPLIFY_TEST_EXP
argument_list|(
name|newexp
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|left
operator|!=
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|||
name|right
operator|!=
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|newexp
operator|=
name|attr_rtx
argument_list|(
name|AND
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
expr_stmt|;
return|return
name|SIMPLIFY_TEST_EXP
argument_list|(
name|newexp
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
return|;
block|}
break|break;
case|case
name|IOR
case|:
name|left
operator|=
name|SIMPLIFY_TEST_EXP
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|left
operator|==
name|true_rtx
condition|)
return|return
name|true_rtx
return|;
name|right
operator|=
name|SIMPLIFY_TEST_EXP
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|right
operator|==
name|true_rtx
condition|)
return|return
name|true_rtx
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|left
argument_list|)
operator|==
name|EQ_ATTR_ALT
operator|&&
name|GET_CODE
argument_list|(
name|right
argument_list|)
operator|==
name|EQ_ATTR_ALT
condition|)
block|{
name|exp
operator|=
name|attr_alt_union
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
expr_stmt|;
return|return
name|simplify_test_exp
argument_list|(
name|exp
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
return|;
block|}
name|right
operator|=
name|simplify_or_tree
argument_list|(
name|right
argument_list|,
operator|&
name|left
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|left
operator|==
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|&&
name|right
operator|==
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
condition|)
name|left
operator|=
name|simplify_or_tree
argument_list|(
name|left
argument_list|,
operator|&
name|right
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|right
operator|==
name|true_rtx
operator|||
name|left
operator|==
name|true_rtx
condition|)
return|return
name|true_rtx
return|;
elseif|else
if|if
condition|(
name|left
operator|==
name|false_rtx
condition|)
block|{
return|return
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|==
name|false_rtx
condition|)
block|{
return|return
name|left
return|;
block|}
comment|/* Test for simple cases where the distributive law is useful.  I.e., 	    convert (ior (and (x) (y)) 			 (and (x) (z))) 	    to      (and (x) 			 (ior (y) (z)))        */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|left
argument_list|)
operator|==
name|AND
operator|&&
name|GET_CODE
argument_list|(
name|right
argument_list|)
operator|==
name|AND
operator|&&
name|attr_equal_p
argument_list|(
name|XEXP
argument_list|(
name|left
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|right
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|newexp
operator|=
name|attr_rtx
argument_list|(
name|IOR
argument_list|,
name|XEXP
argument_list|(
name|left
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|right
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|left
operator|=
name|XEXP
argument_list|(
name|left
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|right
operator|=
name|newexp
expr_stmt|;
name|newexp
operator|=
name|attr_rtx
argument_list|(
name|AND
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
expr_stmt|;
return|return
name|SIMPLIFY_TEST_EXP
argument_list|(
name|newexp
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
return|;
block|}
comment|/* See if all or all but one of the insn's alternatives are specified 	 in this tree.  Optimize if so.  */
elseif|else
if|if
condition|(
name|insn_code
operator|>=
literal|0
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|left
argument_list|)
operator|==
name|IOR
operator|||
operator|(
name|GET_CODE
argument_list|(
name|left
argument_list|)
operator|==
name|EQ_ATTR_ALT
operator|&&
operator|!
name|XINT
argument_list|(
name|left
argument_list|,
literal|1
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|left
argument_list|)
operator|==
name|EQ_ATTR
operator|&&
name|XSTR
argument_list|(
name|left
argument_list|,
literal|0
argument_list|)
operator|==
name|alternative_name
operator|)
operator|||
name|GET_CODE
argument_list|(
name|right
argument_list|)
operator|==
name|IOR
operator|||
operator|(
name|GET_CODE
argument_list|(
name|right
argument_list|)
operator|==
name|EQ_ATTR_ALT
operator|&&
operator|!
name|XINT
argument_list|(
name|right
argument_list|,
literal|1
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|right
argument_list|)
operator|==
name|EQ_ATTR
operator|&&
name|XSTR
argument_list|(
name|right
argument_list|,
literal|0
argument_list|)
operator|==
name|alternative_name
operator|)
operator|)
condition|)
block|{
name|i
operator|=
name|compute_alternative_mask
argument_list|(
name|exp
argument_list|,
name|IOR
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&
operator|~
name|insn_alternatives
index|[
name|insn_code
index|]
condition|)
name|fatal
argument_list|(
literal|"invalid alternative specified for pattern number %d"
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
comment|/* If all alternatives are included, this is true.  */
name|i
operator|^=
name|insn_alternatives
index|[
name|insn_code
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
name|true_rtx
return|;
elseif|else
if|if
condition|(
operator|(
name|i
operator|&
operator|(
name|i
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
operator|&&
name|insn_alternatives
index|[
name|insn_code
index|]
operator|>
literal|1
condition|)
block|{
comment|/* If just one excluded, IOR a comparison with that one to the 		 front of the tree.  The others will be eliminated by 		 optimization.  We do not want to do this if the insn has one 		 alternative and we have tested none of them!  */
name|left
operator|=
name|make_alternative_compare
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|right
operator|=
name|simplify_and_tree
argument_list|(
name|exp
argument_list|,
operator|&
name|left
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
name|newexp
operator|=
name|attr_rtx
argument_list|(
name|IOR
argument_list|,
name|attr_rtx
argument_list|(
name|NOT
argument_list|,
name|left
argument_list|)
argument_list|,
name|right
argument_list|)
expr_stmt|;
return|return
name|SIMPLIFY_TEST_EXP
argument_list|(
name|newexp
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|left
operator|!=
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|||
name|right
operator|!=
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|newexp
operator|=
name|attr_rtx
argument_list|(
name|IOR
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
expr_stmt|;
return|return
name|SIMPLIFY_TEST_EXP
argument_list|(
name|newexp
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
return|;
block|}
break|break;
case|case
name|NOT
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NOT
condition|)
block|{
name|left
operator|=
name|SIMPLIFY_TEST_EXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
return|return
name|left
return|;
block|}
name|left
operator|=
name|SIMPLIFY_TEST_EXP
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|left
argument_list|)
operator|==
name|NOT
condition|)
return|return
name|XEXP
argument_list|(
name|left
argument_list|,
literal|0
argument_list|)
return|;
if|if
condition|(
name|left
operator|==
name|false_rtx
condition|)
return|return
name|true_rtx
return|;
if|if
condition|(
name|left
operator|==
name|true_rtx
condition|)
return|return
name|false_rtx
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|left
argument_list|)
operator|==
name|EQ_ATTR_ALT
condition|)
block|{
name|exp
operator|=
name|attr_alt_complement
argument_list|(
name|left
argument_list|)
expr_stmt|;
return|return
name|simplify_test_exp
argument_list|(
name|exp
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
return|;
block|}
comment|/* Try to apply De`Morgan's laws.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|left
argument_list|)
operator|==
name|IOR
condition|)
block|{
name|newexp
operator|=
name|attr_rtx
argument_list|(
name|AND
argument_list|,
name|attr_rtx
argument_list|(
name|NOT
argument_list|,
name|XEXP
argument_list|(
name|left
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|attr_rtx
argument_list|(
name|NOT
argument_list|,
name|XEXP
argument_list|(
name|left
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|newexp
operator|=
name|SIMPLIFY_TEST_EXP
argument_list|(
name|newexp
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|left
argument_list|)
operator|==
name|AND
condition|)
block|{
name|newexp
operator|=
name|attr_rtx
argument_list|(
name|IOR
argument_list|,
name|attr_rtx
argument_list|(
name|NOT
argument_list|,
name|XEXP
argument_list|(
name|left
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|attr_rtx
argument_list|(
name|NOT
argument_list|,
name|XEXP
argument_list|(
name|left
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|newexp
operator|=
name|SIMPLIFY_TEST_EXP
argument_list|(
name|newexp
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|left
operator|!=
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|newexp
operator|=
name|attr_rtx
argument_list|(
name|NOT
argument_list|,
name|left
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|EQ_ATTR_ALT
case|:
if|if
condition|(
operator|!
name|XINT
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|XINT
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
condition|?
name|true_rtx
else|:
name|false_rtx
return|;
break|break;
case|case
name|EQ_ATTR
case|:
if|if
condition|(
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|==
name|alternative_name
condition|)
block|{
name|newexp
operator|=
name|mk_attr_alt
argument_list|(
literal|1
operator|<<
name|atoi
argument_list|(
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Look at the value for this insn code in the specified attribute. 	 We normally can replace this comparison with the condition that 	 would give this insn the values being tested for.  */
if|if
condition|(
name|insn_code
operator|>=
literal|0
operator|&&
operator|(
name|attr
operator|=
name|find_attr
argument_list|(
operator|&
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
for|for
control|(
name|av
operator|=
name|attr
operator|->
name|first_value
init|;
name|av
condition|;
name|av
operator|=
name|av
operator|->
name|next
control|)
for|for
control|(
name|ie
operator|=
name|av
operator|->
name|first_insn
init|;
name|ie
condition|;
name|ie
operator|=
name|ie
operator|->
name|next
control|)
if|if
condition|(
name|ie
operator|->
name|def
operator|->
name|insn_code
operator|==
name|insn_code
condition|)
block|{
name|rtx
name|x
decl_stmt|;
name|x
operator|=
name|evaluate_eq_attr
argument_list|(
name|exp
argument_list|,
name|av
operator|->
name|value
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
name|x
operator|=
name|SIMPLIFY_TEST_EXP
argument_list|(
name|x
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr_rtx_cost
argument_list|(
name|x
argument_list|)
operator|<
literal|20
condition|)
return|return
name|x
return|;
block|}
break|break;
default|default:
break|break;
block|}
comment|/* We have already simplified this expression.  Simplifying it again      won't buy anything unless we weren't given a valid insn code      to process (i.e., we are canonicalizing something.).  */
if|if
condition|(
name|insn_code
operator|!=
operator|-
literal|2
operator|&&
operator|!
name|ATTR_IND_SIMPLIFIED_P
argument_list|(
name|newexp
argument_list|)
condition|)
return|return
name|copy_rtx_unchanging
argument_list|(
name|newexp
argument_list|)
return|;
return|return
name|newexp
return|;
block|}
end_function

begin_comment
comment|/* Optimize the attribute lists by seeing if we can determine conditional    values from the known values of other attributes.  This will save subroutine    calls during the compilation.  */
end_comment

begin_function
specifier|static
name|void
name|optimize_attrs
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|attr_desc
modifier|*
name|attr
decl_stmt|;
name|struct
name|attr_value
modifier|*
name|av
decl_stmt|;
name|struct
name|insn_ent
modifier|*
name|ie
decl_stmt|;
name|rtx
name|newexp
decl_stmt|;
name|int
name|i
decl_stmt|;
struct|struct
name|attr_value_list
block|{
name|struct
name|attr_value
modifier|*
name|av
decl_stmt|;
name|struct
name|insn_ent
modifier|*
name|ie
decl_stmt|;
name|struct
name|attr_desc
modifier|*
name|attr
decl_stmt|;
name|struct
name|attr_value_list
modifier|*
name|next
decl_stmt|;
block|}
struct|;
name|struct
name|attr_value_list
modifier|*
modifier|*
name|insn_code_values
decl_stmt|;
name|struct
name|attr_value_list
modifier|*
name|ivbuf
decl_stmt|;
name|struct
name|attr_value_list
modifier|*
name|iv
decl_stmt|;
comment|/* For each insn code, make a list of all the insn_ent's for it,      for all values for all attributes.  */
if|if
condition|(
name|num_insn_ents
operator|==
literal|0
condition|)
return|return;
comment|/* Make 2 extra elements, for "code" values -2 and -1.  */
name|insn_code_values
operator|=
name|XCNEWVEC
argument_list|(
expr|struct
name|attr_value_list
operator|*
argument_list|,
name|insn_code_number
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* Offset the table address so we can index by -2 or -1.  */
name|insn_code_values
operator|+=
literal|2
expr_stmt|;
name|iv
operator|=
name|ivbuf
operator|=
name|XNEWVEC
argument_list|(
expr|struct
name|attr_value_list
argument_list|,
name|num_insn_ents
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_ATTRS_INDEX
condition|;
name|i
operator|++
control|)
for|for
control|(
name|attr
operator|=
name|attrs
index|[
name|i
index|]
init|;
name|attr
condition|;
name|attr
operator|=
name|attr
operator|->
name|next
control|)
for|for
control|(
name|av
operator|=
name|attr
operator|->
name|first_value
init|;
name|av
condition|;
name|av
operator|=
name|av
operator|->
name|next
control|)
for|for
control|(
name|ie
operator|=
name|av
operator|->
name|first_insn
init|;
name|ie
condition|;
name|ie
operator|=
name|ie
operator|->
name|next
control|)
block|{
name|iv
operator|->
name|attr
operator|=
name|attr
expr_stmt|;
name|iv
operator|->
name|av
operator|=
name|av
expr_stmt|;
name|iv
operator|->
name|ie
operator|=
name|ie
expr_stmt|;
name|iv
operator|->
name|next
operator|=
name|insn_code_values
index|[
name|ie
operator|->
name|def
operator|->
name|insn_code
index|]
expr_stmt|;
name|insn_code_values
index|[
name|ie
operator|->
name|def
operator|->
name|insn_code
index|]
operator|=
name|iv
expr_stmt|;
name|iv
operator|++
expr_stmt|;
block|}
comment|/* Sanity check on num_insn_ents.  */
name|gcc_assert
argument_list|(
name|iv
operator|==
name|ivbuf
operator|+
name|num_insn_ents
argument_list|)
expr_stmt|;
comment|/* Process one insn code at a time.  */
for|for
control|(
name|i
operator|=
operator|-
literal|2
init|;
name|i
operator|<
name|insn_code_number
condition|;
name|i
operator|++
control|)
block|{
comment|/* Clear the ATTR_CURR_SIMPLIFIED_P flag everywhere relevant. 	 We use it to mean "already simplified for this insn".  */
for|for
control|(
name|iv
operator|=
name|insn_code_values
index|[
name|i
index|]
init|;
name|iv
condition|;
name|iv
operator|=
name|iv
operator|->
name|next
control|)
name|clear_struct_flag
argument_list|(
name|iv
operator|->
name|av
operator|->
name|value
argument_list|)
expr_stmt|;
for|for
control|(
name|iv
operator|=
name|insn_code_values
index|[
name|i
index|]
init|;
name|iv
condition|;
name|iv
operator|=
name|iv
operator|->
name|next
control|)
block|{
name|struct
name|obstack
modifier|*
name|old
init|=
name|rtl_obstack
decl_stmt|;
name|attr
operator|=
name|iv
operator|->
name|attr
expr_stmt|;
name|av
operator|=
name|iv
operator|->
name|av
expr_stmt|;
name|ie
operator|=
name|iv
operator|->
name|ie
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|av
operator|->
name|value
argument_list|)
operator|!=
name|COND
condition|)
continue|continue;
name|rtl_obstack
operator|=
name|temp_obstack
expr_stmt|;
name|newexp
operator|=
name|av
operator|->
name|value
expr_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|newexp
argument_list|)
operator|==
name|COND
condition|)
block|{
name|rtx
name|newexp2
init|=
name|simplify_cond
argument_list|(
name|newexp
argument_list|,
name|ie
operator|->
name|def
operator|->
name|insn_code
argument_list|,
name|ie
operator|->
name|def
operator|->
name|insn_index
argument_list|)
decl_stmt|;
if|if
condition|(
name|newexp2
operator|==
name|newexp
condition|)
break|break;
name|newexp
operator|=
name|newexp2
expr_stmt|;
block|}
name|rtl_obstack
operator|=
name|old
expr_stmt|;
if|if
condition|(
name|newexp
operator|!=
name|av
operator|->
name|value
condition|)
block|{
name|newexp
operator|=
name|attr_copy_rtx
argument_list|(
name|newexp
argument_list|)
expr_stmt|;
name|remove_insn_ent
argument_list|(
name|av
argument_list|,
name|ie
argument_list|)
expr_stmt|;
name|av
operator|=
name|get_attr_value
argument_list|(
name|newexp
argument_list|,
name|attr
argument_list|,
name|ie
operator|->
name|def
operator|->
name|insn_code
argument_list|)
expr_stmt|;
name|iv
operator|->
name|av
operator|=
name|av
expr_stmt|;
name|insert_insn_ent
argument_list|(
name|av
argument_list|,
name|ie
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|free
argument_list|(
name|ivbuf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|insn_code_values
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clear the ATTR_CURR_SIMPLIFIED_P flag in EXP and its subexpressions.  */
end_comment

begin_function
specifier|static
name|void
name|clear_struct_flag
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|ATTR_CURR_SIMPLIFIED_P
argument_list|(
name|x
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ATTR_IND_SIMPLIFIED_P
argument_list|(
name|x
argument_list|)
condition|)
return|return;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_VECTOR
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CODE_LABEL
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|EQ_ATTR
case|:
case|case
name|ATTR_FLAG
case|:
return|return;
default|default:
break|break;
block|}
comment|/* Compare the elements.  If any pair of corresponding elements      fail to match, return 0 for the whole things.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
switch|switch
condition|(
name|fmt
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'V'
case|:
case|case
literal|'E'
case|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|clear_struct_flag
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|clear_struct_flag
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Create table entries for DEFINE_ATTR.  */
end_comment

begin_function
specifier|static
name|void
name|gen_attr
parameter_list|(
name|rtx
name|exp
parameter_list|,
name|int
name|lineno
parameter_list|)
block|{
name|struct
name|attr_desc
modifier|*
name|attr
decl_stmt|;
name|struct
name|attr_value
modifier|*
name|av
decl_stmt|;
specifier|const
name|char
modifier|*
name|name_ptr
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Make a new attribute structure.  Check for duplicate by looking at      attr->default_val, since it is initialized by this routine.  */
name|attr
operator|=
name|find_attr
argument_list|(
operator|&
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
operator|->
name|default_val
condition|)
block|{
name|message_with_line
argument_list|(
name|lineno
argument_list|,
literal|"duplicate definition for attribute %s"
argument_list|,
name|attr
operator|->
name|name
argument_list|)
expr_stmt|;
name|message_with_line
argument_list|(
name|attr
operator|->
name|lineno
argument_list|,
literal|"previous definition"
argument_list|)
expr_stmt|;
name|have_error
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|attr
operator|->
name|lineno
operator|=
name|lineno
expr_stmt|;
if|if
condition|(
operator|*
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
operator|==
literal|'\0'
condition|)
name|attr
operator|->
name|is_numeric
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|name_ptr
operator|=
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
name|next_comma_elt
argument_list|(
operator|&
name|name_ptr
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|av
operator|=
name|oballoc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|attr_value
argument_list|)
argument_list|)
expr_stmt|;
name|av
operator|->
name|value
operator|=
name|attr_rtx
argument_list|(
name|CONST_STRING
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|av
operator|->
name|next
operator|=
name|attr
operator|->
name|first_value
expr_stmt|;
name|attr
operator|->
name|first_value
operator|=
name|av
expr_stmt|;
name|av
operator|->
name|first_insn
operator|=
name|NULL
expr_stmt|;
name|av
operator|->
name|num_insns
operator|=
literal|0
expr_stmt|;
name|av
operator|->
name|has_asm_insn
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|CONST
condition|)
block|{
name|attr
operator|->
name|is_const
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|attr
operator|->
name|is_numeric
condition|)
block|{
name|message_with_line
argument_list|(
name|lineno
argument_list|,
literal|"constant attributes may not take numeric values"
argument_list|)
expr_stmt|;
name|have_error
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Get rid of the CONST node.  It is allowed only at top-level.  */
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strcmp_check
argument_list|(
name|attr
operator|->
name|name
argument_list|,
name|length_str
argument_list|)
operator|&&
operator|!
name|attr
operator|->
name|is_numeric
condition|)
block|{
name|message_with_line
argument_list|(
name|lineno
argument_list|,
literal|"`length' attribute must take numeric values"
argument_list|)
expr_stmt|;
name|have_error
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Set up the default value.  */
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
operator|=
name|check_attr_value
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
name|attr
argument_list|)
expr_stmt|;
name|attr
operator|->
name|default_val
operator|=
name|get_attr_value
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
name|attr
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a pattern for DEFINE_PEEPHOLE or DEFINE_INSN, return the number of    alternatives in the constraints.  Assume all MATCH_OPERANDs have the same    number of alternatives as this should be checked elsewhere.  */
end_comment

begin_function
specifier|static
name|int
name|count_alternatives
parameter_list|(
name|rtx
name|exp
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|n
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|MATCH_OPERAND
condition|)
return|return
name|n_comma_elts
argument_list|(
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|)
return|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
argument_list|)
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
switch|switch
condition|(
operator|*
name|fmt
operator|++
condition|)
block|{
case|case
literal|'e'
case|:
case|case
literal|'u'
case|:
name|n
operator|=
name|count_alternatives
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
return|return
name|n
return|;
break|break;
case|case
literal|'E'
case|:
case|case
literal|'V'
case|:
if|if
condition|(
name|XVEC
argument_list|(
name|exp
argument_list|,
name|i
argument_list|)
operator|!=
name|NULL
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|exp
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|n
operator|=
name|count_alternatives
argument_list|(
name|XVECEXP
argument_list|(
name|exp
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
return|return
name|n
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if the given expression contains an EQ_ATTR with the    `alternative' attribute.  */
end_comment

begin_function
specifier|static
name|int
name|compares_alternatives_p
parameter_list|(
name|rtx
name|exp
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|EQ_ATTR
operator|&&
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|==
name|alternative_name
condition|)
return|return
literal|1
return|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
argument_list|)
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
switch|switch
condition|(
operator|*
name|fmt
operator|++
condition|)
block|{
case|case
literal|'e'
case|:
case|case
literal|'u'
case|:
if|if
condition|(
name|compares_alternatives_p
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
literal|'E'
case|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|exp
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|compares_alternatives_p
argument_list|(
name|XVECEXP
argument_list|(
name|exp
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero is INNER is contained in EXP.  */
end_comment

begin_function
specifier|static
name|int
name|contained_in_p
parameter_list|(
name|rtx
name|inner
parameter_list|,
name|rtx
name|exp
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|inner
argument_list|,
name|exp
argument_list|)
condition|)
return|return
literal|1
return|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
argument_list|)
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
switch|switch
condition|(
operator|*
name|fmt
operator|++
condition|)
block|{
case|case
literal|'e'
case|:
case|case
literal|'u'
case|:
if|if
condition|(
name|contained_in_p
argument_list|(
name|inner
argument_list|,
name|XEXP
argument_list|(
name|exp
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
literal|'E'
case|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|exp
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|contained_in_p
argument_list|(
name|inner
argument_list|,
name|XVECEXP
argument_list|(
name|exp
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Process DEFINE_PEEPHOLE, DEFINE_INSN, and DEFINE_ASM_ATTRIBUTES.  */
end_comment

begin_function
specifier|static
name|void
name|gen_insn
parameter_list|(
name|rtx
name|exp
parameter_list|,
name|int
name|lineno
parameter_list|)
block|{
name|struct
name|insn_def
modifier|*
name|id
decl_stmt|;
name|id
operator|=
name|oballoc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|insn_def
argument_list|)
argument_list|)
expr_stmt|;
name|id
operator|->
name|next
operator|=
name|defs
expr_stmt|;
name|defs
operator|=
name|id
expr_stmt|;
name|id
operator|->
name|def
operator|=
name|exp
expr_stmt|;
name|id
operator|->
name|lineno
operator|=
name|lineno
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|DEFINE_INSN
case|:
name|id
operator|->
name|insn_code
operator|=
name|insn_code_number
expr_stmt|;
name|id
operator|->
name|insn_index
operator|=
name|insn_index_number
expr_stmt|;
name|id
operator|->
name|num_alternatives
operator|=
name|count_alternatives
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|->
name|num_alternatives
operator|==
literal|0
condition|)
name|id
operator|->
name|num_alternatives
operator|=
literal|1
expr_stmt|;
name|id
operator|->
name|vec_idx
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|DEFINE_PEEPHOLE
case|:
name|id
operator|->
name|insn_code
operator|=
name|insn_code_number
expr_stmt|;
name|id
operator|->
name|insn_index
operator|=
name|insn_index_number
expr_stmt|;
name|id
operator|->
name|num_alternatives
operator|=
name|count_alternatives
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|->
name|num_alternatives
operator|==
literal|0
condition|)
name|id
operator|->
name|num_alternatives
operator|=
literal|1
expr_stmt|;
name|id
operator|->
name|vec_idx
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|DEFINE_ASM_ATTRIBUTES
case|:
name|id
operator|->
name|insn_code
operator|=
operator|-
literal|1
expr_stmt|;
name|id
operator|->
name|insn_index
operator|=
operator|-
literal|1
expr_stmt|;
name|id
operator|->
name|num_alternatives
operator|=
literal|1
expr_stmt|;
name|id
operator|->
name|vec_idx
operator|=
literal|0
expr_stmt|;
name|got_define_asm_attributes
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Process a DEFINE_DELAY.  Validate the vector length, check if annul    true or annul false is specified, and make a `struct delay_desc'.  */
end_comment

begin_function
specifier|static
name|void
name|gen_delay
parameter_list|(
name|rtx
name|def
parameter_list|,
name|int
name|lineno
parameter_list|)
block|{
name|struct
name|delay_desc
modifier|*
name|delay
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|XVECLEN
argument_list|(
name|def
argument_list|,
literal|1
argument_list|)
operator|%
literal|3
operator|!=
literal|0
condition|)
block|{
name|message_with_line
argument_list|(
name|lineno
argument_list|,
literal|"number of elements in DEFINE_DELAY must be multiple of three"
argument_list|)
expr_stmt|;
name|have_error
operator|=
literal|1
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|def
argument_list|,
literal|1
argument_list|)
condition|;
name|i
operator|+=
literal|3
control|)
block|{
if|if
condition|(
name|XVECEXP
argument_list|(
name|def
argument_list|,
literal|1
argument_list|,
name|i
operator|+
literal|1
argument_list|)
condition|)
name|have_annul_true
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|XVECEXP
argument_list|(
name|def
argument_list|,
literal|1
argument_list|,
name|i
operator|+
literal|2
argument_list|)
condition|)
name|have_annul_false
operator|=
literal|1
expr_stmt|;
block|}
name|delay
operator|=
name|oballoc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|delay_desc
argument_list|)
argument_list|)
expr_stmt|;
name|delay
operator|->
name|def
operator|=
name|def
expr_stmt|;
name|delay
operator|->
name|num
operator|=
operator|++
name|num_delays
expr_stmt|;
name|delay
operator|->
name|next
operator|=
name|delays
expr_stmt|;
name|delay
operator|->
name|lineno
operator|=
name|lineno
expr_stmt|;
name|delays
operator|=
name|delay
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a piece of RTX, print a C expression to test its truth value.    We use AND and IOR both for logical and bit-wise operations, so    interpret them as logical unless they are inside a comparison expression.    The first bit of FLAGS will be nonzero in that case.     Set the second bit of FLAGS to make references to attribute values use    a cached local variable instead of calling a function.  */
end_comment

begin_function
specifier|static
name|void
name|write_test_expr
parameter_list|(
name|rtx
name|exp
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|comparison_operator
init|=
literal|0
decl_stmt|;
name|RTX_CODE
name|code
decl_stmt|;
name|struct
name|attr_desc
modifier|*
name|attr
decl_stmt|;
comment|/* In order not to worry about operator precedence, surround our part of      the expression with parentheses.  */
name|printf
argument_list|(
literal|"("
argument_list|)
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
comment|/* Binary operators.  */
case|case
name|GEU
case|:
case|case
name|GTU
case|:
case|case
name|LEU
case|:
case|case
name|LTU
case|:
name|printf
argument_list|(
literal|"(unsigned) "
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|EQ
case|:
case|case
name|NE
case|:
case|case
name|GE
case|:
case|case
name|GT
case|:
case|case
name|LE
case|:
case|case
name|LT
case|:
name|comparison_operator
operator|=
literal|1
expr_stmt|;
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
case|case
name|MULT
case|:
case|case
name|DIV
case|:
case|case
name|MOD
case|:
case|case
name|AND
case|:
case|case
name|IOR
case|:
case|case
name|XOR
case|:
case|case
name|ASHIFT
case|:
case|case
name|LSHIFTRT
case|:
case|case
name|ASHIFTRT
case|:
name|write_test_expr
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
operator||
name|comparison_operator
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ
case|:
name|printf
argument_list|(
literal|" == "
argument_list|)
expr_stmt|;
break|break;
case|case
name|NE
case|:
name|printf
argument_list|(
literal|" != "
argument_list|)
expr_stmt|;
break|break;
case|case
name|GE
case|:
name|printf
argument_list|(
literal|">= "
argument_list|)
expr_stmt|;
break|break;
case|case
name|GT
case|:
name|printf
argument_list|(
literal|"> "
argument_list|)
expr_stmt|;
break|break;
case|case
name|GEU
case|:
name|printf
argument_list|(
literal|">= (unsigned) "
argument_list|)
expr_stmt|;
break|break;
case|case
name|GTU
case|:
name|printf
argument_list|(
literal|"> (unsigned) "
argument_list|)
expr_stmt|;
break|break;
case|case
name|LE
case|:
name|printf
argument_list|(
literal|"<= "
argument_list|)
expr_stmt|;
break|break;
case|case
name|LT
case|:
name|printf
argument_list|(
literal|"< "
argument_list|)
expr_stmt|;
break|break;
case|case
name|LEU
case|:
name|printf
argument_list|(
literal|"<= (unsigned) "
argument_list|)
expr_stmt|;
break|break;
case|case
name|LTU
case|:
name|printf
argument_list|(
literal|"< (unsigned) "
argument_list|)
expr_stmt|;
break|break;
case|case
name|PLUS
case|:
name|printf
argument_list|(
literal|" + "
argument_list|)
expr_stmt|;
break|break;
case|case
name|MINUS
case|:
name|printf
argument_list|(
literal|" - "
argument_list|)
expr_stmt|;
break|break;
case|case
name|MULT
case|:
name|printf
argument_list|(
literal|" * "
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIV
case|:
name|printf
argument_list|(
literal|" / "
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD
case|:
name|printf
argument_list|(
literal|" %% "
argument_list|)
expr_stmt|;
break|break;
case|case
name|AND
case|:
if|if
condition|(
name|flags
operator|&
literal|1
condition|)
name|printf
argument_list|(
literal|"& "
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"&& "
argument_list|)
expr_stmt|;
break|break;
case|case
name|IOR
case|:
if|if
condition|(
name|flags
operator|&
literal|1
condition|)
name|printf
argument_list|(
literal|" | "
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" || "
argument_list|)
expr_stmt|;
break|break;
case|case
name|XOR
case|:
name|printf
argument_list|(
literal|" ^ "
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASHIFT
case|:
name|printf
argument_list|(
literal|"<< "
argument_list|)
expr_stmt|;
break|break;
case|case
name|LSHIFTRT
case|:
case|case
name|ASHIFTRT
case|:
name|printf
argument_list|(
literal|">> "
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|write_test_expr
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|flags
operator||
name|comparison_operator
argument_list|)
expr_stmt|;
break|break;
case|case
name|NOT
case|:
comment|/* Special-case (not (eq_attrq "alternative" "x")) */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
literal|1
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|EQ_ATTR
operator|&&
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|alternative_name
condition|)
block|{
name|printf
argument_list|(
literal|"which_alternative != %s"
argument_list|,
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Otherwise, fall through to normal unary operator.  */
comment|/* Unary operators.  */
case|case
name|ABS
case|:
case|case
name|NEG
case|:
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|NOT
case|:
if|if
condition|(
name|flags
operator|&
literal|1
condition|)
name|printf
argument_list|(
literal|"~ "
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"! "
argument_list|)
expr_stmt|;
break|break;
case|case
name|ABS
case|:
name|printf
argument_list|(
literal|"abs "
argument_list|)
expr_stmt|;
break|break;
case|case
name|NEG
case|:
name|printf
argument_list|(
literal|"-"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|write_test_expr
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|EQ_ATTR_ALT
case|:
block|{
name|int
name|set
init|=
name|XINT
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|,
name|bit
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|flags
operator|&
literal|1
condition|)
name|fatal
argument_list|(
literal|"EQ_ATTR_ALT not valid inside comparison"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set
condition|)
name|fatal
argument_list|(
literal|"Empty EQ_ATTR_ALT should be optimized out"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|set
operator|&
operator|(
name|set
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|set
operator|&
literal|0xffff
operator|)
condition|)
block|{
name|bit
operator|+=
literal|16
expr_stmt|;
name|set
operator|>>=
literal|16
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|set
operator|&
literal|0xff
operator|)
condition|)
block|{
name|bit
operator|+=
literal|8
expr_stmt|;
name|set
operator|>>=
literal|8
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|set
operator|&
literal|0xf
operator|)
condition|)
block|{
name|bit
operator|+=
literal|4
expr_stmt|;
name|set
operator|>>=
literal|4
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|set
operator|&
literal|0x3
operator|)
condition|)
block|{
name|bit
operator|+=
literal|2
expr_stmt|;
name|set
operator|>>=
literal|2
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|set
operator|&
literal|1
operator|)
condition|)
name|bit
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"which_alternative %s= %d"
argument_list|,
name|XINT
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
condition|?
literal|"!"
else|:
literal|"="
argument_list|,
name|bit
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%s((1<< which_alternative)& 0x%x)"
argument_list|,
name|XINT
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
condition|?
literal|"!"
else|:
literal|""
argument_list|,
name|set
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
comment|/* Comparison test of an attribute with a value.  Most of these will        have been removed by optimization.   Handle "alternative"        specially and give error if EQ_ATTR present inside a comparison.  */
case|case
name|EQ_ATTR
case|:
if|if
condition|(
name|flags
operator|&
literal|1
condition|)
name|fatal
argument_list|(
literal|"EQ_ATTR not valid inside comparison"
argument_list|)
expr_stmt|;
if|if
condition|(
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|==
name|alternative_name
condition|)
block|{
name|printf
argument_list|(
literal|"which_alternative == %s"
argument_list|,
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|attr
operator|=
name|find_attr
argument_list|(
operator|&
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|attr
argument_list|)
expr_stmt|;
comment|/* Now is the time to expand the value of a constant attribute.  */
if|if
condition|(
name|attr
operator|->
name|is_const
condition|)
block|{
name|write_test_expr
argument_list|(
name|evaluate_eq_attr
argument_list|(
name|exp
argument_list|,
name|attr
operator|->
name|default_val
operator|->
name|value
argument_list|,
operator|-
literal|2
argument_list|,
operator|-
literal|2
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|flags
operator|&
literal|2
condition|)
name|printf
argument_list|(
literal|"attr_%s"
argument_list|,
name|attr
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"get_attr_%s (insn)"
argument_list|,
name|attr
operator|->
name|name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" == "
argument_list|)
expr_stmt|;
name|write_attr_valueq
argument_list|(
name|attr
argument_list|,
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* Comparison test of flags for define_delays.  */
case|case
name|ATTR_FLAG
case|:
if|if
condition|(
name|flags
operator|&
literal|1
condition|)
name|fatal
argument_list|(
literal|"ATTR_FLAG not valid inside comparison"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"(flags& ATTR_FLAG_%s) != 0"
argument_list|,
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|/* See if an operand matches a predicate.  */
case|case
name|MATCH_OPERAND
case|:
comment|/* If only a mode is given, just ensure the mode matches the operand. 	 If neither a mode nor predicate is given, error.  */
if|if
condition|(
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
operator|==
name|NULL
operator|||
operator|*
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|exp
argument_list|)
operator|==
name|VOIDmode
condition|)
name|fatal
argument_list|(
literal|"null MATCH_OPERAND specified as test"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"GET_MODE (operands[%d]) == %smode"
argument_list|,
name|XINT
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|GET_MODE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"%s (operands[%d], %smode)"
argument_list|,
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XINT
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|GET_MODE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|/* Constant integer.  */
case|case
name|CONST_INT
case|:
name|printf
argument_list|(
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|XWINT
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|/* A random C expression.  */
case|case
name|SYMBOL_REF
case|:
name|print_c_condition
argument_list|(
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|/* The address of the branch target.  */
case|case
name|MATCH_DUP
case|:
name|printf
argument_list|(
literal|"INSN_ADDRESSES_SET_P () ? INSN_ADDRESSES (INSN_UID (GET_CODE (operands[%d]) == LABEL_REF ? XEXP (operands[%d], 0) : operands[%d])) : 0"
argument_list|,
name|XINT
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XINT
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XINT
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|PC
case|:
comment|/* The address of the current insn.  We implement this actually as the 	 address of the current insn for backward branches, but the last 	 address of the next insn for forward branches, and both with 	 adjustments that account for the worst-case possible stretching of 	 intervening alignments between this insn and its destination.  */
name|printf
argument_list|(
literal|"insn_current_reference_address (insn)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_STRING
case|:
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|IF_THEN_ELSE
case|:
name|write_test_expr
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
operator|&
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" ? "
argument_list|)
expr_stmt|;
name|write_test_expr
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|flags
operator||
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" : "
argument_list|)
expr_stmt|;
name|write_test_expr
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
name|flags
operator||
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fatal
argument_list|(
literal|"bad RTX code `%s' in attribute calculation\n"
argument_list|,
name|GET_RTX_NAME
argument_list|(
name|code
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given an attribute value, return the maximum CONST_STRING argument    encountered.  Set *UNKNOWNP and return INT_MAX if the value is unknown.  */
end_comment

begin_function
specifier|static
name|int
name|max_attr_value
parameter_list|(
name|rtx
name|exp
parameter_list|,
name|int
modifier|*
name|unknownp
parameter_list|)
block|{
name|int
name|current_max
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|CONST_STRING
case|:
name|current_max
operator|=
name|atoi
argument_list|(
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|COND
case|:
name|current_max
operator|=
name|max_attr_value
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|unknownp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|n
operator|=
name|max_attr_value
argument_list|(
name|XVECEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
name|i
operator|+
literal|1
argument_list|)
argument_list|,
name|unknownp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|current_max
condition|)
name|current_max
operator|=
name|n
expr_stmt|;
block|}
break|break;
case|case
name|IF_THEN_ELSE
case|:
name|current_max
operator|=
name|max_attr_value
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|unknownp
argument_list|)
expr_stmt|;
name|n
operator|=
name|max_attr_value
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
name|unknownp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|current_max
condition|)
name|current_max
operator|=
name|n
expr_stmt|;
break|break;
default|default:
operator|*
name|unknownp
operator|=
literal|1
expr_stmt|;
name|current_max
operator|=
name|INT_MAX
expr_stmt|;
break|break;
block|}
return|return
name|current_max
return|;
block|}
end_function

begin_comment
comment|/* Given an attribute value, return the minimum CONST_STRING argument    encountered.  Set *UNKNOWNP and return 0 if the value is unknown.  */
end_comment

begin_function
specifier|static
name|int
name|min_attr_value
parameter_list|(
name|rtx
name|exp
parameter_list|,
name|int
modifier|*
name|unknownp
parameter_list|)
block|{
name|int
name|current_min
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|CONST_STRING
case|:
name|current_min
operator|=
name|atoi
argument_list|(
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|COND
case|:
name|current_min
operator|=
name|min_attr_value
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|unknownp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|n
operator|=
name|min_attr_value
argument_list|(
name|XVECEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
name|i
operator|+
literal|1
argument_list|)
argument_list|,
name|unknownp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
name|current_min
condition|)
name|current_min
operator|=
name|n
expr_stmt|;
block|}
break|break;
case|case
name|IF_THEN_ELSE
case|:
name|current_min
operator|=
name|min_attr_value
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|unknownp
argument_list|)
expr_stmt|;
name|n
operator|=
name|min_attr_value
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
name|unknownp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
name|current_min
condition|)
name|current_min
operator|=
name|n
expr_stmt|;
break|break;
default|default:
operator|*
name|unknownp
operator|=
literal|1
expr_stmt|;
name|current_min
operator|=
name|INT_MAX
expr_stmt|;
break|break;
block|}
return|return
name|current_min
return|;
block|}
end_function

begin_comment
comment|/* Given an attribute value, return the result of ORing together all    CONST_STRING arguments encountered.  Set *UNKNOWNP and return -1    if the numeric value is not known.  */
end_comment

begin_function
specifier|static
name|int
name|or_attr_value
parameter_list|(
name|rtx
name|exp
parameter_list|,
name|int
modifier|*
name|unknownp
parameter_list|)
block|{
name|int
name|current_or
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|CONST_STRING
case|:
name|current_or
operator|=
name|atoi
argument_list|(
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|COND
case|:
name|current_or
operator|=
name|or_attr_value
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|unknownp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|+=
literal|2
control|)
name|current_or
operator||=
name|or_attr_value
argument_list|(
name|XVECEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
name|i
operator|+
literal|1
argument_list|)
argument_list|,
name|unknownp
argument_list|)
expr_stmt|;
break|break;
case|case
name|IF_THEN_ELSE
case|:
name|current_or
operator|=
name|or_attr_value
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|unknownp
argument_list|)
expr_stmt|;
name|current_or
operator||=
name|or_attr_value
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
name|unknownp
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|*
name|unknownp
operator|=
literal|1
expr_stmt|;
name|current_or
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
return|return
name|current_or
return|;
block|}
end_function

begin_comment
comment|/* Scan an attribute value, possibly a conditional, and record what actions    will be required to do any conditional tests in it.     Specifically, set 	`must_extract'	  if we need to extract the insn operands 	`must_constrain'  if we must compute `which_alternative' 	`address_used'	  if an address expression was used 	`length_used'	  if an (eq_attr "length" ...) was used  */
end_comment

begin_function
specifier|static
name|void
name|walk_attr_value
parameter_list|(
name|rtx
name|exp
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|RTX_CODE
name|code
decl_stmt|;
if|if
condition|(
name|exp
operator|==
name|NULL
condition|)
return|return;
name|code
operator|=
name|GET_CODE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|SYMBOL_REF
case|:
if|if
condition|(
operator|!
name|ATTR_IND_SIMPLIFIED_P
argument_list|(
name|exp
argument_list|)
condition|)
comment|/* Since this is an arbitrary expression, it can look at anything. 	   However, constant expressions do not depend on any particular 	   insn.  */
name|must_extract
operator|=
name|must_constrain
operator|=
literal|1
expr_stmt|;
return|return;
case|case
name|MATCH_OPERAND
case|:
name|must_extract
operator|=
literal|1
expr_stmt|;
return|return;
case|case
name|EQ_ATTR_ALT
case|:
name|must_extract
operator|=
name|must_constrain
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|EQ_ATTR
case|:
if|if
condition|(
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|==
name|alternative_name
condition|)
name|must_extract
operator|=
name|must_constrain
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp_check
argument_list|(
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|length_str
argument_list|)
operator|==
literal|0
condition|)
name|length_used
operator|=
literal|1
expr_stmt|;
return|return;
case|case
name|MATCH_DUP
case|:
name|must_extract
operator|=
literal|1
expr_stmt|;
name|address_used
operator|=
literal|1
expr_stmt|;
return|return;
case|case
name|PC
case|:
name|address_used
operator|=
literal|1
expr_stmt|;
return|return;
case|case
name|ATTR_FLAG
case|:
return|return;
default|default:
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
condition|;
name|i
operator|++
control|)
switch|switch
condition|(
operator|*
name|fmt
operator|++
condition|)
block|{
case|case
literal|'e'
case|:
case|case
literal|'u'
case|:
name|walk_attr_value
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
if|if
condition|(
name|XVEC
argument_list|(
name|exp
argument_list|,
name|i
argument_list|)
operator|!=
name|NULL
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|exp
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|walk_attr_value
argument_list|(
name|XVECEXP
argument_list|(
name|exp
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Write out a function to obtain the attribute for a given INSN.  */
end_comment

begin_function
specifier|static
name|void
name|write_attr_get
parameter_list|(
name|struct
name|attr_desc
modifier|*
name|attr
parameter_list|)
block|{
name|struct
name|attr_value
modifier|*
name|av
decl_stmt|,
modifier|*
name|common_av
decl_stmt|;
comment|/* Find the most used attribute value.  Handle that as the `default' of the      switch we will generate.  */
name|common_av
operator|=
name|find_most_used
argument_list|(
name|attr
argument_list|)
expr_stmt|;
comment|/* Write out start of function, then all values with explicit `case' lines,      then a `default', then the value with the most uses.  */
if|if
condition|(
operator|!
name|attr
operator|->
name|is_numeric
condition|)
name|printf
argument_list|(
literal|"enum attr_%s\n"
argument_list|,
name|attr
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"int\n"
argument_list|)
expr_stmt|;
comment|/* If the attribute name starts with a star, the remainder is the name of      the subroutine to use, instead of `get_attr_...'.  */
if|if
condition|(
name|attr
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
name|printf
argument_list|(
literal|"%s (rtx insn ATTRIBUTE_UNUSED)\n"
argument_list|,
operator|&
name|attr
operator|->
name|name
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|attr
operator|->
name|is_const
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"get_attr_%s (rtx insn ATTRIBUTE_UNUSED)\n"
argument_list|,
name|attr
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"get_attr_%s (void)\n"
argument_list|,
name|attr
operator|->
name|name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"{\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|av
operator|=
name|attr
operator|->
name|first_value
init|;
name|av
condition|;
name|av
operator|=
name|av
operator|->
name|next
control|)
if|if
condition|(
name|av
operator|->
name|num_insns
operator|==
literal|1
condition|)
name|write_attr_set
argument_list|(
name|attr
argument_list|,
literal|2
argument_list|,
name|av
operator|->
name|value
argument_list|,
literal|"return"
argument_list|,
literal|";"
argument_list|,
name|true_rtx
argument_list|,
name|av
operator|->
name|first_insn
operator|->
name|def
operator|->
name|insn_code
argument_list|,
name|av
operator|->
name|first_insn
operator|->
name|def
operator|->
name|insn_index
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|av
operator|->
name|num_insns
operator|!=
literal|0
condition|)
name|write_attr_set
argument_list|(
name|attr
argument_list|,
literal|2
argument_list|,
name|av
operator|->
name|value
argument_list|,
literal|"return"
argument_list|,
literal|";"
argument_list|,
name|true_rtx
argument_list|,
operator|-
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"}\n\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"{\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  switch (recog_memoized (insn))\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|av
operator|=
name|attr
operator|->
name|first_value
init|;
name|av
condition|;
name|av
operator|=
name|av
operator|->
name|next
control|)
if|if
condition|(
name|av
operator|!=
name|common_av
condition|)
name|write_attr_case
argument_list|(
name|attr
argument_list|,
name|av
argument_list|,
literal|1
argument_list|,
literal|"return"
argument_list|,
literal|";"
argument_list|,
literal|4
argument_list|,
name|true_rtx
argument_list|)
expr_stmt|;
name|write_attr_case
argument_list|(
name|attr
argument_list|,
name|common_av
argument_list|,
literal|0
argument_list|,
literal|"return"
argument_list|,
literal|";"
argument_list|,
literal|4
argument_list|,
name|true_rtx
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    }\n}\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given an AND tree of known true terms (because we are inside an `if' with    that as the condition or are in an `else' clause) and an expression,    replace any known true terms with TRUE.  Use `simplify_and_tree' to do    the bulk of the work.  */
end_comment

begin_function
specifier|static
name|rtx
name|eliminate_known_true
parameter_list|(
name|rtx
name|known_true
parameter_list|,
name|rtx
name|exp
parameter_list|,
name|int
name|insn_code
parameter_list|,
name|int
name|insn_index
parameter_list|)
block|{
name|rtx
name|term
decl_stmt|;
name|known_true
operator|=
name|SIMPLIFY_TEST_EXP
argument_list|(
name|known_true
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|known_true
argument_list|)
operator|==
name|AND
condition|)
block|{
name|exp
operator|=
name|eliminate_known_true
argument_list|(
name|XEXP
argument_list|(
name|known_true
argument_list|,
literal|0
argument_list|)
argument_list|,
name|exp
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
name|exp
operator|=
name|eliminate_known_true
argument_list|(
name|XEXP
argument_list|(
name|known_true
argument_list|,
literal|1
argument_list|)
argument_list|,
name|exp
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|term
operator|=
name|known_true
expr_stmt|;
name|exp
operator|=
name|simplify_and_tree
argument_list|(
name|exp
argument_list|,
operator|&
name|term
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
block|}
return|return
name|exp
return|;
block|}
end_function

begin_comment
comment|/* Write out a series of tests and assignment statements to perform tests and    sets of an attribute value.  We are passed an indentation amount and prefix    and suffix strings to write around each attribute value (e.g., "return"    and ";").  */
end_comment

begin_function
specifier|static
name|void
name|write_attr_set
parameter_list|(
name|struct
name|attr_desc
modifier|*
name|attr
parameter_list|,
name|int
name|indent
parameter_list|,
name|rtx
name|value
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
specifier|const
name|char
modifier|*
name|suffix
parameter_list|,
name|rtx
name|known_true
parameter_list|,
name|int
name|insn_code
parameter_list|,
name|int
name|insn_index
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|COND
condition|)
block|{
comment|/* Assume the default value will be the default of the COND unless we 	 find an always true expression.  */
name|rtx
name|default_val
init|=
name|XEXP
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|our_known_true
init|=
name|known_true
decl_stmt|;
name|rtx
name|newexp
decl_stmt|;
name|int
name|first_if
init|=
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|rtx
name|testexp
decl_stmt|;
name|rtx
name|inner_true
decl_stmt|;
name|testexp
operator|=
name|eliminate_known_true
argument_list|(
name|our_known_true
argument_list|,
name|XVECEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
name|newexp
operator|=
name|attr_rtx
argument_list|(
name|NOT
argument_list|,
name|testexp
argument_list|)
expr_stmt|;
name|newexp
operator|=
name|insert_right_side
argument_list|(
name|AND
argument_list|,
name|our_known_true
argument_list|,
name|newexp
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
comment|/* If the test expression is always true or if the next `known_true' 	     expression is always false, this is the last case, so break 	     out and let this value be the `else' case.  */
if|if
condition|(
name|testexp
operator|==
name|true_rtx
operator|||
name|newexp
operator|==
name|false_rtx
condition|)
block|{
name|default_val
operator|=
name|XVECEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Compute the expression to pass to our recursive call as being 	     known true.  */
name|inner_true
operator|=
name|insert_right_side
argument_list|(
name|AND
argument_list|,
name|our_known_true
argument_list|,
name|testexp
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
comment|/* If this is always false, skip it.  */
if|if
condition|(
name|inner_true
operator|==
name|false_rtx
condition|)
continue|continue;
name|write_indent
argument_list|(
name|indent
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%sif "
argument_list|,
name|first_if
condition|?
literal|""
else|:
literal|"else "
argument_list|)
expr_stmt|;
name|first_if
operator|=
literal|0
expr_stmt|;
name|write_test_expr
argument_list|(
name|testexp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|write_indent
argument_list|(
name|indent
operator|+
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"{\n"
argument_list|)
expr_stmt|;
name|write_attr_set
argument_list|(
name|attr
argument_list|,
name|indent
operator|+
literal|4
argument_list|,
name|XVECEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|,
name|i
operator|+
literal|1
argument_list|)
argument_list|,
name|prefix
argument_list|,
name|suffix
argument_list|,
name|inner_true
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
name|write_indent
argument_list|(
name|indent
operator|+
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"}\n"
argument_list|)
expr_stmt|;
name|our_known_true
operator|=
name|newexp
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|first_if
condition|)
block|{
name|write_indent
argument_list|(
name|indent
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"else\n"
argument_list|)
expr_stmt|;
name|write_indent
argument_list|(
name|indent
operator|+
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"{\n"
argument_list|)
expr_stmt|;
block|}
name|write_attr_set
argument_list|(
name|attr
argument_list|,
name|first_if
condition|?
name|indent
else|:
name|indent
operator|+
literal|4
argument_list|,
name|default_val
argument_list|,
name|prefix
argument_list|,
name|suffix
argument_list|,
name|our_known_true
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|first_if
condition|)
block|{
name|write_indent
argument_list|(
name|indent
operator|+
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"}\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|write_indent
argument_list|(
name|indent
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|write_attr_value
argument_list|(
name|attr
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Write a series of case statements for every instruction in list IE.    INDENT is the amount of indentation to write before each case.  */
end_comment

begin_function
specifier|static
name|void
name|write_insn_cases
parameter_list|(
name|struct
name|insn_ent
modifier|*
name|ie
parameter_list|,
name|int
name|indent
parameter_list|)
block|{
for|for
control|(
init|;
name|ie
operator|!=
literal|0
condition|;
name|ie
operator|=
name|ie
operator|->
name|next
control|)
if|if
condition|(
name|ie
operator|->
name|def
operator|->
name|insn_code
operator|!=
operator|-
literal|1
condition|)
block|{
name|write_indent
argument_list|(
name|indent
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|ie
operator|->
name|def
operator|->
name|def
argument_list|)
operator|==
name|DEFINE_PEEPHOLE
condition|)
name|printf
argument_list|(
literal|"case %d:  /* define_peephole, line %d */\n"
argument_list|,
name|ie
operator|->
name|def
operator|->
name|insn_code
argument_list|,
name|ie
operator|->
name|def
operator|->
name|lineno
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"case %d:  /* %s */\n"
argument_list|,
name|ie
operator|->
name|def
operator|->
name|insn_code
argument_list|,
name|XSTR
argument_list|(
name|ie
operator|->
name|def
operator|->
name|def
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Write out the computation for one attribute value.  */
end_comment

begin_function
specifier|static
name|void
name|write_attr_case
parameter_list|(
name|struct
name|attr_desc
modifier|*
name|attr
parameter_list|,
name|struct
name|attr_value
modifier|*
name|av
parameter_list|,
name|int
name|write_case_lines
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
specifier|const
name|char
modifier|*
name|suffix
parameter_list|,
name|int
name|indent
parameter_list|,
name|rtx
name|known_true
parameter_list|)
block|{
if|if
condition|(
name|av
operator|->
name|num_insns
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|av
operator|->
name|has_asm_insn
condition|)
block|{
name|write_indent
argument_list|(
name|indent
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"case -1:\n"
argument_list|)
expr_stmt|;
name|write_indent
argument_list|(
name|indent
operator|+
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"if (GET_CODE (PATTERN (insn)) != ASM_INPUT\n"
argument_list|)
expr_stmt|;
name|write_indent
argument_list|(
name|indent
operator|+
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"&& asm_noperands (PATTERN (insn))< 0)\n"
argument_list|)
expr_stmt|;
name|write_indent
argument_list|(
name|indent
operator|+
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  fatal_insn_not_found (insn);\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|write_case_lines
condition|)
name|write_insn_cases
argument_list|(
name|av
operator|->
name|first_insn
argument_list|,
name|indent
argument_list|)
expr_stmt|;
else|else
block|{
name|write_indent
argument_list|(
name|indent
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"default:\n"
argument_list|)
expr_stmt|;
block|}
comment|/* See what we have to do to output this value.  */
name|must_extract
operator|=
name|must_constrain
operator|=
name|address_used
operator|=
literal|0
expr_stmt|;
name|walk_attr_value
argument_list|(
name|av
operator|->
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|must_constrain
condition|)
block|{
name|write_indent
argument_list|(
name|indent
operator|+
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"extract_constrain_insn_cached (insn);\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|must_extract
condition|)
block|{
name|write_indent
argument_list|(
name|indent
operator|+
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"extract_insn_cached (insn);\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|av
operator|->
name|num_insns
operator|==
literal|1
condition|)
name|write_attr_set
argument_list|(
name|attr
argument_list|,
name|indent
operator|+
literal|2
argument_list|,
name|av
operator|->
name|value
argument_list|,
name|prefix
argument_list|,
name|suffix
argument_list|,
name|known_true
argument_list|,
name|av
operator|->
name|first_insn
operator|->
name|def
operator|->
name|insn_code
argument_list|,
name|av
operator|->
name|first_insn
operator|->
name|def
operator|->
name|insn_index
argument_list|)
expr_stmt|;
else|else
name|write_attr_set
argument_list|(
name|attr
argument_list|,
name|indent
operator|+
literal|2
argument_list|,
name|av
operator|->
name|value
argument_list|,
name|prefix
argument_list|,
name|suffix
argument_list|,
name|known_true
argument_list|,
operator|-
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|prefix
argument_list|,
literal|"return"
argument_list|,
literal|6
argument_list|)
condition|)
block|{
name|write_indent
argument_list|(
name|indent
operator|+
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"break;\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Search for uses of non-const attributes and write code to cache them.  */
end_comment

begin_function
specifier|static
name|int
name|write_expr_attr_cache
parameter_list|(
name|rtx
name|p
parameter_list|,
name|struct
name|attr_desc
modifier|*
name|attr
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ie
decl_stmt|,
name|j
decl_stmt|,
name|je
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|EQ_ATTR
condition|)
block|{
if|if
condition|(
name|XSTR
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
operator|!=
name|attr
operator|->
name|name
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|attr
operator|->
name|is_numeric
condition|)
name|printf
argument_list|(
literal|"  enum attr_%s "
argument_list|,
name|attr
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"  int "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"attr_%s = get_attr_%s (insn);\n"
argument_list|,
name|attr
operator|->
name|name
argument_list|,
name|attr
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|ie
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ie
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|fmt
operator|++
condition|)
block|{
case|case
literal|'e'
case|:
if|if
condition|(
name|write_expr_attr_cache
argument_list|(
name|XEXP
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
argument_list|,
name|attr
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
literal|'E'
case|:
name|je
operator|=
name|XVECLEN
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|je
condition|;
operator|++
name|j
control|)
if|if
condition|(
name|write_expr_attr_cache
argument_list|(
name|XVECEXP
argument_list|(
name|p
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|attr
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Utilities to write in various forms.  */
end_comment

begin_function
specifier|static
name|void
name|write_attr_valueq
parameter_list|(
name|struct
name|attr_desc
modifier|*
name|attr
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
if|if
condition|(
name|attr
operator|->
name|is_numeric
condition|)
block|{
name|int
name|num
init|=
name|atoi
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|num
operator|>
literal|9
operator|||
name|num
operator|<
literal|0
condition|)
name|printf
argument_list|(
literal|" /* 0x%x */"
argument_list|,
name|num
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|write_upcase
argument_list|(
name|attr
operator|->
name|name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"_"
argument_list|)
expr_stmt|;
name|write_upcase
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|write_attr_value
parameter_list|(
name|struct
name|attr_desc
modifier|*
name|attr
parameter_list|,
name|rtx
name|value
parameter_list|)
block|{
name|int
name|op
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
condition|)
block|{
case|case
name|CONST_STRING
case|:
name|write_attr_valueq
argument_list|(
name|attr
argument_list|,
name|XSTR
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_INT
case|:
name|printf
argument_list|(
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|INTVAL
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYMBOL_REF
case|:
name|print_c_condition
argument_list|(
name|XSTR
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATTR
case|:
block|{
name|struct
name|attr_desc
modifier|*
name|attr2
init|=
name|find_attr
argument_list|(
operator|&
name|XSTR
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"get_attr_%s (%s)"
argument_list|,
name|attr2
operator|->
name|name
argument_list|,
operator|(
name|attr2
operator|->
name|is_const
condition|?
literal|""
else|:
literal|"insn"
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PLUS
case|:
name|op
operator|=
literal|'+'
expr_stmt|;
goto|goto
name|do_operator
goto|;
case|case
name|MINUS
case|:
name|op
operator|=
literal|'-'
expr_stmt|;
goto|goto
name|do_operator
goto|;
case|case
name|MULT
case|:
name|op
operator|=
literal|'*'
expr_stmt|;
goto|goto
name|do_operator
goto|;
case|case
name|DIV
case|:
name|op
operator|=
literal|'/'
expr_stmt|;
goto|goto
name|do_operator
goto|;
case|case
name|MOD
case|:
name|op
operator|=
literal|'%'
expr_stmt|;
goto|goto
name|do_operator
goto|;
name|do_operator
label|:
name|write_attr_value
argument_list|(
name|attr
argument_list|,
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|write_attr_value
argument_list|(
name|attr
argument_list|,
name|XEXP
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|write_upcase
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
while|while
condition|(
operator|*
name|str
condition|)
block|{
comment|/* The argument of TOUPPER should not have side effects.  */
name|putchar
argument_list|(
name|TOUPPER
argument_list|(
operator|*
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|str
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|write_indent
parameter_list|(
name|int
name|indent
parameter_list|)
block|{
for|for
control|(
init|;
name|indent
operator|>
literal|8
condition|;
name|indent
operator|-=
literal|8
control|)
name|printf
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|indent
condition|;
name|indent
operator|--
control|)
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write a subroutine that is given an insn that requires a delay slot, a    delay slot ordinal, and a candidate insn.  It returns nonzero if the    candidate can be placed in the specified delay slot of the insn.     We can write as many as three subroutines.  `eligible_for_delay'    handles normal delay slots, `eligible_for_annul_true' indicates that    the specified insn can be annulled if the branch is true, and likewise    for `eligible_for_annul_false'.     KIND is a string distinguishing these three cases ("delay", "annul_true",    or "annul_false").  */
end_comment

begin_function
specifier|static
name|void
name|write_eligible_delay
parameter_list|(
specifier|const
name|char
modifier|*
name|kind
parameter_list|)
block|{
name|struct
name|delay_desc
modifier|*
name|delay
decl_stmt|;
name|int
name|max_slots
decl_stmt|;
name|char
name|str
index|[
literal|50
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|pstr
decl_stmt|;
name|struct
name|attr_desc
modifier|*
name|attr
decl_stmt|;
name|struct
name|attr_value
modifier|*
name|av
decl_stmt|,
modifier|*
name|common_av
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Compute the maximum number of delay slots required.  We use the delay      ordinal times this number plus one, plus the slot number as an index into      the appropriate predicate to test.  */
for|for
control|(
name|delay
operator|=
name|delays
operator|,
name|max_slots
operator|=
literal|0
init|;
name|delay
condition|;
name|delay
operator|=
name|delay
operator|->
name|next
control|)
if|if
condition|(
name|XVECLEN
argument_list|(
name|delay
operator|->
name|def
argument_list|,
literal|1
argument_list|)
operator|/
literal|3
operator|>
name|max_slots
condition|)
name|max_slots
operator|=
name|XVECLEN
argument_list|(
name|delay
operator|->
name|def
argument_list|,
literal|1
argument_list|)
operator|/
literal|3
expr_stmt|;
comment|/* Write function prelude.  */
name|printf
argument_list|(
literal|"int\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"eligible_for_%s (rtx delay_insn ATTRIBUTE_UNUSED, int slot, rtx candidate_insn, int flags ATTRIBUTE_UNUSED)\n"
argument_list|,
name|kind
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"{\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  rtx insn;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  gcc_assert (slot< %d);\n"
argument_list|,
name|max_slots
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* Allow dbr_schedule to pass labels, etc.  This can happen if try_split      converts a compound instruction into a loop.  */
name|printf
argument_list|(
literal|"  if (!INSN_P (candidate_insn))\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    return 0;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* If more than one delay type, find out which type the delay insn is.  */
if|if
condition|(
name|num_delays
operator|>
literal|1
condition|)
block|{
name|attr
operator|=
name|find_attr
argument_list|(
operator|&
name|delay_type_str
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|attr
argument_list|)
expr_stmt|;
name|common_av
operator|=
name|find_most_used
argument_list|(
name|attr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  insn = delay_insn;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  switch (recog_memoized (insn))\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    {\n"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|str
argument_list|,
literal|" * %d;\n      break;"
argument_list|,
name|max_slots
argument_list|)
expr_stmt|;
for|for
control|(
name|av
operator|=
name|attr
operator|->
name|first_value
init|;
name|av
condition|;
name|av
operator|=
name|av
operator|->
name|next
control|)
if|if
condition|(
name|av
operator|!=
name|common_av
condition|)
name|write_attr_case
argument_list|(
name|attr
argument_list|,
name|av
argument_list|,
literal|1
argument_list|,
literal|"slot +="
argument_list|,
name|str
argument_list|,
literal|4
argument_list|,
name|true_rtx
argument_list|)
expr_stmt|;
name|write_attr_case
argument_list|(
name|attr
argument_list|,
name|common_av
argument_list|,
literal|0
argument_list|,
literal|"slot +="
argument_list|,
name|str
argument_list|,
literal|4
argument_list|,
name|true_rtx
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    }\n\n"
argument_list|)
expr_stmt|;
comment|/* Ensure matched.  Otherwise, shouldn't have been called.  */
name|printf
argument_list|(
literal|"  gcc_assert (slot>= %d);\n\n"
argument_list|,
name|max_slots
argument_list|)
expr_stmt|;
block|}
comment|/* If just one type of delay slot, write simple switch.  */
if|if
condition|(
name|num_delays
operator|==
literal|1
operator|&&
name|max_slots
operator|==
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"  insn = candidate_insn;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  switch (recog_memoized (insn))\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    {\n"
argument_list|)
expr_stmt|;
name|attr
operator|=
name|find_attr
argument_list|(
operator|&
name|delay_1_0_str
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|attr
argument_list|)
expr_stmt|;
name|common_av
operator|=
name|find_most_used
argument_list|(
name|attr
argument_list|)
expr_stmt|;
for|for
control|(
name|av
operator|=
name|attr
operator|->
name|first_value
init|;
name|av
condition|;
name|av
operator|=
name|av
operator|->
name|next
control|)
if|if
condition|(
name|av
operator|!=
name|common_av
condition|)
name|write_attr_case
argument_list|(
name|attr
argument_list|,
name|av
argument_list|,
literal|1
argument_list|,
literal|"return"
argument_list|,
literal|";"
argument_list|,
literal|4
argument_list|,
name|true_rtx
argument_list|)
expr_stmt|;
name|write_attr_case
argument_list|(
name|attr
argument_list|,
name|common_av
argument_list|,
literal|0
argument_list|,
literal|"return"
argument_list|,
literal|";"
argument_list|,
literal|4
argument_list|,
name|true_rtx
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    }\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Write a nested CASE.  The first indicates which condition we need to 	 test, and the inner CASE tests the condition.  */
name|printf
argument_list|(
literal|"  insn = candidate_insn;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  switch (slot)\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|delay
operator|=
name|delays
init|;
name|delay
condition|;
name|delay
operator|=
name|delay
operator|->
name|next
control|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|delay
operator|->
name|def
argument_list|,
literal|1
argument_list|)
condition|;
name|i
operator|+=
literal|3
control|)
block|{
name|printf
argument_list|(
literal|"    case %d:\n"
argument_list|,
operator|(
name|i
operator|/
literal|3
operator|)
operator|+
operator|(
name|num_delays
operator|==
literal|1
condition|?
literal|0
else|:
name|delay
operator|->
name|num
operator|*
name|max_slots
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"      switch (recog_memoized (insn))\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t{\n"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"*%s_%d_%d"
argument_list|,
name|kind
argument_list|,
name|delay
operator|->
name|num
argument_list|,
name|i
operator|/
literal|3
argument_list|)
expr_stmt|;
name|pstr
operator|=
name|str
expr_stmt|;
name|attr
operator|=
name|find_attr
argument_list|(
operator|&
name|pstr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|attr
argument_list|)
expr_stmt|;
name|common_av
operator|=
name|find_most_used
argument_list|(
name|attr
argument_list|)
expr_stmt|;
for|for
control|(
name|av
operator|=
name|attr
operator|->
name|first_value
init|;
name|av
condition|;
name|av
operator|=
name|av
operator|->
name|next
control|)
if|if
condition|(
name|av
operator|!=
name|common_av
condition|)
name|write_attr_case
argument_list|(
name|attr
argument_list|,
name|av
argument_list|,
literal|1
argument_list|,
literal|"return"
argument_list|,
literal|";"
argument_list|,
literal|8
argument_list|,
name|true_rtx
argument_list|)
expr_stmt|;
name|write_attr_case
argument_list|(
name|attr
argument_list|,
name|common_av
argument_list|,
literal|0
argument_list|,
literal|"return"
argument_list|,
literal|";"
argument_list|,
literal|8
argument_list|,
name|true_rtx
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"      }\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"    default:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"      gcc_unreachable ();\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    }\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"}\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This page contains miscellaneous utility routines.  */
end_comment

begin_comment
comment|/* Given a pointer to a (char *), return a malloc'ed string containing the    next comma-separated element.  Advance the pointer to after the string    scanned, or the end-of-string.  Return NULL if at end of string.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|next_comma_elt
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|pstr
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
name|start
operator|=
name|scan_comma_elt
argument_list|(
name|pstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
return|return
name|attr_string
argument_list|(
name|start
argument_list|,
operator|*
name|pstr
operator|-
name|start
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a `struct attr_desc' pointer for a given named attribute.  If CREATE    is nonzero, build a new attribute, if one does not exist.  *NAME_P is    replaced by a pointer to a canonical copy of the string.  */
end_comment

begin_function
specifier|static
name|struct
name|attr_desc
modifier|*
name|find_attr
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|name_p
parameter_list|,
name|int
name|create
parameter_list|)
block|{
name|struct
name|attr_desc
modifier|*
name|attr
decl_stmt|;
name|int
name|index
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
operator|*
name|name_p
decl_stmt|;
comment|/* Before we resort to using `strcmp', see if the string address matches      anywhere.  In most cases, it should have been canonicalized to do so.  */
if|if
condition|(
name|name
operator|==
name|alternative_name
condition|)
return|return
name|NULL
return|;
name|index
operator|=
name|name
index|[
literal|0
index|]
operator|&
operator|(
name|MAX_ATTRS_INDEX
operator|-
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|attr
operator|=
name|attrs
index|[
name|index
index|]
init|;
name|attr
condition|;
name|attr
operator|=
name|attr
operator|->
name|next
control|)
if|if
condition|(
name|name
operator|==
name|attr
operator|->
name|name
condition|)
return|return
name|attr
return|;
comment|/* Otherwise, do it the slow way.  */
for|for
control|(
name|attr
operator|=
name|attrs
index|[
name|index
index|]
init|;
name|attr
condition|;
name|attr
operator|=
name|attr
operator|->
name|next
control|)
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
name|attr
operator|->
name|name
index|[
literal|0
index|]
operator|&&
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|attr
operator|->
name|name
argument_list|)
condition|)
block|{
operator|*
name|name_p
operator|=
name|attr
operator|->
name|name
expr_stmt|;
return|return
name|attr
return|;
block|}
if|if
condition|(
operator|!
name|create
condition|)
return|return
name|NULL
return|;
name|attr
operator|=
name|oballoc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|attr_desc
argument_list|)
argument_list|)
expr_stmt|;
name|attr
operator|->
name|name
operator|=
name|DEF_ATTR_STRING
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|attr
operator|->
name|first_value
operator|=
name|attr
operator|->
name|default_val
operator|=
name|NULL
expr_stmt|;
name|attr
operator|->
name|is_numeric
operator|=
name|attr
operator|->
name|is_const
operator|=
name|attr
operator|->
name|is_special
operator|=
literal|0
expr_stmt|;
name|attr
operator|->
name|next
operator|=
name|attrs
index|[
name|index
index|]
expr_stmt|;
name|attrs
index|[
name|index
index|]
operator|=
name|attr
expr_stmt|;
operator|*
name|name_p
operator|=
name|attr
operator|->
name|name
expr_stmt|;
return|return
name|attr
return|;
block|}
end_function

begin_comment
comment|/* Create internal attribute with the given default value.  */
end_comment

begin_function
specifier|static
name|void
name|make_internal_attr
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|rtx
name|value
parameter_list|,
name|int
name|special
parameter_list|)
block|{
name|struct
name|attr_desc
modifier|*
name|attr
decl_stmt|;
name|attr
operator|=
name|find_attr
argument_list|(
operator|&
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|attr
operator|->
name|default_val
argument_list|)
expr_stmt|;
name|attr
operator|->
name|is_numeric
operator|=
literal|1
expr_stmt|;
name|attr
operator|->
name|is_const
operator|=
literal|0
expr_stmt|;
name|attr
operator|->
name|is_special
operator|=
operator|(
name|special
operator|&
name|ATTR_SPECIAL
operator|)
operator|!=
literal|0
expr_stmt|;
name|attr
operator|->
name|default_val
operator|=
name|get_attr_value
argument_list|(
name|value
argument_list|,
name|attr
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find the most used value of an attribute.  */
end_comment

begin_function
specifier|static
name|struct
name|attr_value
modifier|*
name|find_most_used
parameter_list|(
name|struct
name|attr_desc
modifier|*
name|attr
parameter_list|)
block|{
name|struct
name|attr_value
modifier|*
name|av
decl_stmt|;
name|struct
name|attr_value
modifier|*
name|most_used
decl_stmt|;
name|int
name|nuses
decl_stmt|;
name|most_used
operator|=
name|NULL
expr_stmt|;
name|nuses
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|av
operator|=
name|attr
operator|->
name|first_value
init|;
name|av
condition|;
name|av
operator|=
name|av
operator|->
name|next
control|)
if|if
condition|(
name|av
operator|->
name|num_insns
operator|>
name|nuses
condition|)
name|nuses
operator|=
name|av
operator|->
name|num_insns
operator|,
name|most_used
operator|=
name|av
expr_stmt|;
return|return
name|most_used
return|;
block|}
end_function

begin_comment
comment|/* Return (attr_value "n") */
end_comment

begin_function
specifier|static
name|rtx
name|make_numeric_value
parameter_list|(
name|int
name|n
parameter_list|)
block|{
specifier|static
name|rtx
name|int_values
index|[
literal|20
index|]
decl_stmt|;
name|rtx
name|exp
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|gcc_assert
argument_list|(
name|n
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|20
operator|&&
name|int_values
index|[
name|n
index|]
condition|)
return|return
name|int_values
index|[
name|n
index|]
return|;
name|p
operator|=
name|attr_printf
argument_list|(
name|MAX_DIGITS
argument_list|,
literal|"%d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|exp
operator|=
name|attr_rtx
argument_list|(
name|CONST_STRING
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|20
condition|)
name|int_values
index|[
name|n
index|]
operator|=
name|exp
expr_stmt|;
return|return
name|exp
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|copy_rtx_unchanging
parameter_list|(
name|rtx
name|orig
parameter_list|)
block|{
if|if
condition|(
name|ATTR_IND_SIMPLIFIED_P
argument_list|(
name|orig
argument_list|)
operator|||
name|ATTR_CURR_SIMPLIFIED_P
argument_list|(
name|orig
argument_list|)
condition|)
return|return
name|orig
return|;
name|ATTR_CURR_SIMPLIFIED_P
argument_list|(
name|orig
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|orig
return|;
block|}
end_function

begin_comment
comment|/* Determine if an insn has a constant number of delay slots, i.e., the    number of delay slots is not a function of the length of the insn.  */
end_comment

begin_function
specifier|static
name|void
name|write_const_num_delay_slots
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|attr_desc
modifier|*
name|attr
init|=
name|find_attr
argument_list|(
operator|&
name|num_delay_slots_str
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|struct
name|attr_value
modifier|*
name|av
decl_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
name|printf
argument_list|(
literal|"int\nconst_num_delay_slots (rtx insn)\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"{\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  switch (recog_memoized (insn))\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|av
operator|=
name|attr
operator|->
name|first_value
init|;
name|av
condition|;
name|av
operator|=
name|av
operator|->
name|next
control|)
block|{
name|length_used
operator|=
literal|0
expr_stmt|;
name|walk_attr_value
argument_list|(
name|av
operator|->
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|length_used
condition|)
name|write_insn_cases
argument_list|(
name|av
operator|->
name|first_insn
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"    default:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"      return 1;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    }\n}\n\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Synthetic attributes used by insn-automata.c and the scheduler.    These are primarily concerned with (define_insn_reservation)    patterns.  */
end_comment

begin_struct
struct|struct
name|insn_reserv
block|{
name|struct
name|insn_reserv
modifier|*
name|next
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|default_latency
decl_stmt|;
name|rtx
name|condexp
decl_stmt|;
comment|/* Sequence number of this insn.  */
name|int
name|insn_num
decl_stmt|;
comment|/* Whether a (define_bypass) construct names this insn in its      output list.  */
name|bool
name|bypassed
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|insn_reserv
modifier|*
name|all_insn_reservs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|insn_reserv
modifier|*
modifier|*
name|last_insn_reserv_p
init|=
operator|&
name|all_insn_reservs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|n_insn_reservs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Store information from a DEFINE_INSN_RESERVATION for future    attribute generation.  */
end_comment

begin_function
specifier|static
name|void
name|gen_insn_reserv
parameter_list|(
name|rtx
name|def
parameter_list|)
block|{
name|struct
name|insn_reserv
modifier|*
name|decl
init|=
name|oballoc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|insn_reserv
argument_list|)
argument_list|)
decl_stmt|;
name|decl
operator|->
name|name
operator|=
name|DEF_ATTR_STRING
argument_list|(
name|XSTR
argument_list|(
name|def
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|decl
operator|->
name|default_latency
operator|=
name|XINT
argument_list|(
name|def
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|decl
operator|->
name|condexp
operator|=
name|check_attr_test
argument_list|(
name|XEXP
argument_list|(
name|def
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|decl
operator|->
name|insn_num
operator|=
name|n_insn_reservs
expr_stmt|;
name|decl
operator|->
name|bypassed
operator|=
name|false
expr_stmt|;
name|decl
operator|->
name|next
operator|=
literal|0
expr_stmt|;
operator|*
name|last_insn_reserv_p
operator|=
name|decl
expr_stmt|;
name|last_insn_reserv_p
operator|=
operator|&
name|decl
operator|->
name|next
expr_stmt|;
name|n_insn_reservs
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store information from a DEFINE_BYPASS for future attribute    generation.  The only thing we care about is the list of output    insns, which will later be used to tag reservation structures with    a 'bypassed' bit.  */
end_comment

begin_struct
struct|struct
name|bypass_list
block|{
name|struct
name|bypass_list
modifier|*
name|next
decl_stmt|;
specifier|const
name|char
modifier|*
name|insn
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|bypass_list
modifier|*
name|all_bypasses
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|n_bypasses
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|gen_bypass_1
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|struct
name|bypass_list
modifier|*
name|b
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return;
name|s
operator|=
name|attr_string
argument_list|(
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|b
operator|=
name|all_bypasses
init|;
name|b
condition|;
name|b
operator|=
name|b
operator|->
name|next
control|)
if|if
condition|(
name|s
operator|==
name|b
operator|->
name|insn
condition|)
return|return;
comment|/* already got that one */
name|b
operator|=
name|oballoc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|bypass_list
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|insn
operator|=
name|s
expr_stmt|;
name|b
operator|->
name|next
operator|=
name|all_bypasses
expr_stmt|;
name|all_bypasses
operator|=
name|b
expr_stmt|;
name|n_bypasses
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gen_bypass
parameter_list|(
name|rtx
name|def
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|base
decl_stmt|;
for|for
control|(
name|p
operator|=
name|base
operator|=
name|XSTR
argument_list|(
name|def
argument_list|,
literal|1
argument_list|)
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|','
condition|)
block|{
name|gen_bypass_1
argument_list|(
name|base
argument_list|,
name|p
operator|-
name|base
argument_list|)
expr_stmt|;
do|do
name|p
operator|++
expr_stmt|;
do|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|p
argument_list|)
condition|)
do|;
name|base
operator|=
name|p
expr_stmt|;
block|}
name|gen_bypass_1
argument_list|(
name|base
argument_list|,
name|p
operator|-
name|base
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find and mark all of the bypassed insns.  */
end_comment

begin_function
specifier|static
name|void
name|process_bypasses
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|bypass_list
modifier|*
name|b
decl_stmt|;
name|struct
name|insn_reserv
modifier|*
name|r
decl_stmt|;
comment|/* The reservation list is likely to be much longer than the bypass      list.  */
for|for
control|(
name|r
operator|=
name|all_insn_reservs
init|;
name|r
condition|;
name|r
operator|=
name|r
operator|->
name|next
control|)
for|for
control|(
name|b
operator|=
name|all_bypasses
init|;
name|b
condition|;
name|b
operator|=
name|b
operator|->
name|next
control|)
if|if
condition|(
name|r
operator|->
name|name
operator|==
name|b
operator|->
name|insn
condition|)
name|r
operator|->
name|bypassed
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create all of the attributes that describe automaton properties.  */
end_comment

begin_function
specifier|static
name|void
name|make_automaton_attrs
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|insn_reserv
modifier|*
name|decl
decl_stmt|;
name|rtx
name|code_exp
decl_stmt|,
name|lats_exp
decl_stmt|,
name|byps_exp
decl_stmt|;
if|if
condition|(
name|n_insn_reservs
operator|==
literal|0
condition|)
return|return;
name|code_exp
operator|=
name|rtx_alloc
argument_list|(
name|COND
argument_list|)
expr_stmt|;
name|lats_exp
operator|=
name|rtx_alloc
argument_list|(
name|COND
argument_list|)
expr_stmt|;
name|XVEC
argument_list|(
name|code_exp
argument_list|,
literal|0
argument_list|)
operator|=
name|rtvec_alloc
argument_list|(
name|n_insn_reservs
operator|*
literal|2
argument_list|)
expr_stmt|;
name|XVEC
argument_list|(
name|lats_exp
argument_list|,
literal|0
argument_list|)
operator|=
name|rtvec_alloc
argument_list|(
name|n_insn_reservs
operator|*
literal|2
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|code_exp
argument_list|,
literal|1
argument_list|)
operator|=
name|make_numeric_value
argument_list|(
name|n_insn_reservs
operator|+
literal|1
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|lats_exp
argument_list|,
literal|1
argument_list|)
operator|=
name|make_numeric_value
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|decl
operator|=
name|all_insn_reservs
operator|,
name|i
operator|=
literal|0
init|;
name|decl
condition|;
name|decl
operator|=
name|decl
operator|->
name|next
operator|,
name|i
operator|+=
literal|2
control|)
block|{
name|XVECEXP
argument_list|(
name|code_exp
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
operator|=
name|decl
operator|->
name|condexp
expr_stmt|;
name|XVECEXP
argument_list|(
name|lats_exp
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
operator|=
name|decl
operator|->
name|condexp
expr_stmt|;
name|XVECEXP
argument_list|(
name|code_exp
argument_list|,
literal|0
argument_list|,
name|i
operator|+
literal|1
argument_list|)
operator|=
name|make_numeric_value
argument_list|(
name|decl
operator|->
name|insn_num
argument_list|)
expr_stmt|;
name|XVECEXP
argument_list|(
name|lats_exp
argument_list|,
literal|0
argument_list|,
name|i
operator|+
literal|1
argument_list|)
operator|=
name|make_numeric_value
argument_list|(
name|decl
operator|->
name|default_latency
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n_bypasses
operator|==
literal|0
condition|)
name|byps_exp
operator|=
name|make_numeric_value
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|process_bypasses
argument_list|()
expr_stmt|;
name|byps_exp
operator|=
name|rtx_alloc
argument_list|(
name|COND
argument_list|)
expr_stmt|;
name|XVEC
argument_list|(
name|byps_exp
argument_list|,
literal|0
argument_list|)
operator|=
name|rtvec_alloc
argument_list|(
name|n_bypasses
operator|*
literal|2
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|byps_exp
argument_list|,
literal|1
argument_list|)
operator|=
name|make_numeric_value
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|decl
operator|=
name|all_insn_reservs
operator|,
name|i
operator|=
literal|0
init|;
name|decl
condition|;
name|decl
operator|=
name|decl
operator|->
name|next
control|)
if|if
condition|(
name|decl
operator|->
name|bypassed
condition|)
block|{
name|XVECEXP
argument_list|(
name|byps_exp
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
operator|=
name|decl
operator|->
name|condexp
expr_stmt|;
name|XVECEXP
argument_list|(
name|byps_exp
argument_list|,
literal|0
argument_list|,
name|i
operator|+
literal|1
argument_list|)
operator|=
name|make_numeric_value
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
block|}
block|}
name|make_internal_attr
argument_list|(
literal|"*internal_dfa_insn_code"
argument_list|,
name|code_exp
argument_list|,
name|ATTR_NONE
argument_list|)
expr_stmt|;
name|make_internal_attr
argument_list|(
literal|"*insn_default_latency"
argument_list|,
name|lats_exp
argument_list|,
name|ATTR_NONE
argument_list|)
expr_stmt|;
name|make_internal_attr
argument_list|(
literal|"*bypass_p"
argument_list|,
name|byps_exp
argument_list|,
name|ATTR_NONE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|rtx
name|desc
decl_stmt|;
name|struct
name|attr_desc
modifier|*
name|attr
decl_stmt|;
name|struct
name|insn_def
modifier|*
name|id
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
name|int
name|i
decl_stmt|;
name|progname
operator|=
literal|"genattrtab"
expr_stmt|;
if|if
condition|(
name|init_md_reader_args
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
operator|!=
name|SUCCESS_EXIT_CODE
condition|)
return|return
operator|(
name|FATAL_EXIT_CODE
operator|)
return|;
name|obstack_init
argument_list|(
name|hash_obstack
argument_list|)
expr_stmt|;
name|obstack_init
argument_list|(
name|temp_obstack
argument_list|)
expr_stmt|;
comment|/* Set up true and false rtx's */
name|true_rtx
operator|=
name|rtx_alloc
argument_list|(
name|CONST_INT
argument_list|)
expr_stmt|;
name|XWINT
argument_list|(
name|true_rtx
argument_list|,
literal|0
argument_list|)
operator|=
literal|1
expr_stmt|;
name|false_rtx
operator|=
name|rtx_alloc
argument_list|(
name|CONST_INT
argument_list|)
expr_stmt|;
name|XWINT
argument_list|(
name|false_rtx
argument_list|,
literal|0
argument_list|)
operator|=
literal|0
expr_stmt|;
name|ATTR_IND_SIMPLIFIED_P
argument_list|(
name|true_rtx
argument_list|)
operator|=
name|ATTR_IND_SIMPLIFIED_P
argument_list|(
name|false_rtx
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ATTR_PERMANENT_P
argument_list|(
name|true_rtx
argument_list|)
operator|=
name|ATTR_PERMANENT_P
argument_list|(
name|false_rtx
argument_list|)
operator|=
literal|1
expr_stmt|;
name|alternative_name
operator|=
name|DEF_ATTR_STRING
argument_list|(
literal|"alternative"
argument_list|)
expr_stmt|;
name|length_str
operator|=
name|DEF_ATTR_STRING
argument_list|(
literal|"length"
argument_list|)
expr_stmt|;
name|delay_type_str
operator|=
name|DEF_ATTR_STRING
argument_list|(
literal|"*delay_type"
argument_list|)
expr_stmt|;
name|delay_1_0_str
operator|=
name|DEF_ATTR_STRING
argument_list|(
literal|"*delay_1_0"
argument_list|)
expr_stmt|;
name|num_delay_slots_str
operator|=
name|DEF_ATTR_STRING
argument_list|(
literal|"*num_delay_slots"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"/* Generated automatically by the program `genattrtab'\n\ from the machine description file `md'.  */\n\n"
argument_list|)
expr_stmt|;
comment|/* Read the machine description.  */
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|lineno
decl_stmt|;
name|desc
operator|=
name|read_md_rtx
argument_list|(
operator|&
name|lineno
argument_list|,
operator|&
name|insn_code_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|==
name|NULL
condition|)
break|break;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|desc
argument_list|)
condition|)
block|{
case|case
name|DEFINE_INSN
case|:
case|case
name|DEFINE_PEEPHOLE
case|:
case|case
name|DEFINE_ASM_ATTRIBUTES
case|:
name|gen_insn
argument_list|(
name|desc
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEFINE_ATTR
case|:
name|gen_attr
argument_list|(
name|desc
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEFINE_DELAY
case|:
name|gen_delay
argument_list|(
name|desc
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEFINE_INSN_RESERVATION
case|:
name|gen_insn_reserv
argument_list|(
name|desc
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEFINE_BYPASS
case|:
name|gen_bypass
argument_list|(
name|desc
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|!=
name|DEFINE_ASM_ATTRIBUTES
condition|)
name|insn_index_number
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|have_error
condition|)
return|return
name|FATAL_EXIT_CODE
return|;
name|insn_code_number
operator|++
expr_stmt|;
comment|/* If we didn't have a DEFINE_ASM_ATTRIBUTES, make a null one.  */
if|if
condition|(
operator|!
name|got_define_asm_attributes
condition|)
block|{
name|tem
operator|=
name|rtx_alloc
argument_list|(
name|DEFINE_ASM_ATTRIBUTES
argument_list|)
expr_stmt|;
name|XVEC
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
operator|=
name|rtvec_alloc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|gen_insn
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Expand DEFINE_DELAY information into new attribute.  */
if|if
condition|(
name|num_delays
condition|)
name|expand_delays
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"config.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"system.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"coretypes.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"tm.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"rtl.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"tm_p.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"insn-config.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"recog.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"regs.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"real.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"output.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"insn-attr.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"toplev.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"flags.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"function.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#define operands recog_data.operand\n\n"
argument_list|)
expr_stmt|;
comment|/* Make `insn_alternatives'.  */
name|insn_alternatives
operator|=
name|oballoc
argument_list|(
name|insn_code_number
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|id
operator|=
name|defs
init|;
name|id
condition|;
name|id
operator|=
name|id
operator|->
name|next
control|)
if|if
condition|(
name|id
operator|->
name|insn_code
operator|>=
literal|0
condition|)
name|insn_alternatives
index|[
name|id
operator|->
name|insn_code
index|]
operator|=
operator|(
literal|1
operator|<<
name|id
operator|->
name|num_alternatives
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* Make `insn_n_alternatives'.  */
name|insn_n_alternatives
operator|=
name|oballoc
argument_list|(
name|insn_code_number
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|id
operator|=
name|defs
init|;
name|id
condition|;
name|id
operator|=
name|id
operator|->
name|next
control|)
if|if
condition|(
name|id
operator|->
name|insn_code
operator|>=
literal|0
condition|)
name|insn_n_alternatives
index|[
name|id
operator|->
name|insn_code
index|]
operator|=
name|id
operator|->
name|num_alternatives
expr_stmt|;
comment|/* Construct extra attributes for automata.  */
name|make_automaton_attrs
argument_list|()
expr_stmt|;
comment|/* Prepare to write out attribute subroutines by checking everything stored      away and building the attribute cases.  */
name|check_defs
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_ATTRS_INDEX
condition|;
name|i
operator|++
control|)
for|for
control|(
name|attr
operator|=
name|attrs
index|[
name|i
index|]
init|;
name|attr
condition|;
name|attr
operator|=
name|attr
operator|->
name|next
control|)
name|attr
operator|->
name|default_val
operator|->
name|value
operator|=
name|check_attr_value
argument_list|(
name|attr
operator|->
name|default_val
operator|->
name|value
argument_list|,
name|attr
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_error
condition|)
return|return
name|FATAL_EXIT_CODE
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_ATTRS_INDEX
condition|;
name|i
operator|++
control|)
for|for
control|(
name|attr
operator|=
name|attrs
index|[
name|i
index|]
init|;
name|attr
condition|;
name|attr
operator|=
name|attr
operator|->
name|next
control|)
name|fill_attr
argument_list|(
name|attr
argument_list|)
expr_stmt|;
comment|/* Construct extra attributes for `length'.  */
name|make_length_attrs
argument_list|()
expr_stmt|;
comment|/* Perform any possible optimizations to speed up compilation.  */
name|optimize_attrs
argument_list|()
expr_stmt|;
comment|/* Now write out all the `gen_attr_...' routines.  Do these before the      special routines so that they get defined before they are used.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_ATTRS_INDEX
condition|;
name|i
operator|++
control|)
for|for
control|(
name|attr
operator|=
name|attrs
index|[
name|i
index|]
init|;
name|attr
condition|;
name|attr
operator|=
name|attr
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|attr
operator|->
name|is_special
operator|&&
operator|!
name|attr
operator|->
name|is_const
condition|)
name|write_attr_get
argument_list|(
name|attr
argument_list|)
expr_stmt|;
block|}
comment|/* Write out delay eligibility information, if DEFINE_DELAY present.      (The function to compute the number of delay slots will be written      below.)  */
if|if
condition|(
name|num_delays
condition|)
block|{
name|write_eligible_delay
argument_list|(
literal|"delay"
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_annul_true
condition|)
name|write_eligible_delay
argument_list|(
literal|"annul_true"
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_annul_false
condition|)
name|write_eligible_delay
argument_list|(
literal|"annul_false"
argument_list|)
expr_stmt|;
block|}
comment|/* Write out constant delay slot info.  */
name|write_const_num_delay_slots
argument_list|()
expr_stmt|;
name|write_length_unit_log
argument_list|()
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
return|return
operator|(
name|ferror
argument_list|(
name|stdout
argument_list|)
operator|!=
literal|0
condition|?
name|FATAL_EXIT_CODE
else|:
name|SUCCESS_EXIT_CODE
operator|)
return|;
block|}
end_function

end_unit

