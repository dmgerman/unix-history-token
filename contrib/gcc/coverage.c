begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Read and write coverage files, and associated functionality.    Copyright (C) 1990, 1991, 1992, 1993, 1994, 1996, 1997, 1998, 1999,    2000, 2001, 2003, 2004, 2005 Free Software Foundation, Inc.    Contributed by James E. Wilson, UC Berkeley/Cygnus Support;    based on some ideas from Dain Samples of UC Berkeley.    Further mangling by Bob Manson, Cygnus Support.    Further mangled by Nathan Sidwell, CodeSourcery  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_define
define|#
directive|define
name|GCOV_LINKAGE
end_define

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"coverage.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"tree-iterator.h"
end_include

begin_include
include|#
directive|include
file|"cgraph.h"
end_include

begin_include
include|#
directive|include
file|"gcov-io.c"
end_include

begin_struct
struct|struct
name|function_list
block|{
name|struct
name|function_list
modifier|*
name|next
decl_stmt|;
comment|/* next function */
name|unsigned
name|ident
decl_stmt|;
comment|/* function ident */
name|unsigned
name|checksum
decl_stmt|;
comment|/* function checksum */
name|unsigned
name|n_ctrs
index|[
name|GCOV_COUNTERS
index|]
decl_stmt|;
comment|/* number of counters.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Counts information for a function.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|counts_entry
block|{
comment|/* We hash by  */
name|unsigned
name|ident
decl_stmt|;
name|unsigned
name|ctr
decl_stmt|;
comment|/* Store  */
name|unsigned
name|checksum
decl_stmt|;
name|gcov_type
modifier|*
name|counts
decl_stmt|;
name|struct
name|gcov_ctr_summary
name|summary
decl_stmt|;
comment|/* Workspace */
name|struct
name|counts_entry
modifier|*
name|chain
decl_stmt|;
block|}
name|counts_entry_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|struct
name|function_list
modifier|*
name|functions_head
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|function_list
modifier|*
modifier|*
name|functions_tail
init|=
operator|&
name|functions_head
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|no_coverage
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Cumulative counter information for whole program.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|prg_ctr_mask
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mask of counter types generated.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|prg_n_ctrs
index|[
name|GCOV_COUNTERS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Total counters allocated.  */
end_comment

begin_comment
comment|/* Counter information for current function.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|fn_ctr_mask
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mask of counters used.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|fn_n_ctrs
index|[
name|GCOV_COUNTERS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Counters allocated.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|fn_b_ctrs
index|[
name|GCOV_COUNTERS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Allocation base.  */
end_comment

begin_comment
comment|/* Name of the output file for coverage output file.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|bbg_file_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|bbg_file_opened
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|bbg_function_announced
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name of the count data file.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|da_file_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Hash table of count data.  */
end_comment

begin_decl_stmt
specifier|static
name|htab_t
name|counts_hash
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Trees representing the counter table arrays.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|tree_ctr_tables
index|[
name|GCOV_COUNTERS
index|]
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* The names of the counter tables.  Not used if we're    generating counters at tree level.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|rtx
name|ctr_labels
index|[
name|GCOV_COUNTERS
index|]
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* The names of merge functions for counters.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|ctr_merge_functions
index|[
name|GCOV_COUNTERS
index|]
init|=
name|GCOV_MERGE_FUNCTIONS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|ctr_names
index|[
name|GCOV_COUNTERS
index|]
init|=
name|GCOV_COUNTER_NAMES
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declarations.  */
end_comment

begin_function_decl
specifier|static
name|hashval_t
name|htab_counts_entry_hash
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|htab_counts_entry_eq
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|htab_counts_entry_del
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|read_counts_file
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|compute_checksum
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|coverage_checksum_string
parameter_list|(
name|unsigned
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|build_fn_info_type
parameter_list|(
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|build_fn_info_value
parameter_list|(
specifier|const
name|struct
name|function_list
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|build_ctr_info_type
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|build_ctr_info_value
parameter_list|(
name|unsigned
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|build_gcov_info
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|create_coverage
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Return the type node for gcov_type.  */
end_comment

begin_function
name|tree
name|get_gcov_type
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|lang_hooks
operator|.
name|types
operator|.
name|type_for_size
argument_list|(
name|GCOV_TYPE_SIZE
argument_list|,
name|false
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the type node for gcov_unsigned_t.  */
end_comment

begin_function
specifier|static
name|tree
name|get_gcov_unsigned_t
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|lang_hooks
operator|.
name|types
operator|.
name|type_for_size
argument_list|(
literal|32
argument_list|,
name|true
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|hashval_t
name|htab_counts_entry_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|of
parameter_list|)
block|{
specifier|const
name|counts_entry_t
modifier|*
name|entry
init|=
name|of
decl_stmt|;
return|return
name|entry
operator|->
name|ident
operator|*
name|GCOV_COUNTERS
operator|+
name|entry
operator|->
name|ctr
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|htab_counts_entry_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|of1
parameter_list|,
specifier|const
name|void
modifier|*
name|of2
parameter_list|)
block|{
specifier|const
name|counts_entry_t
modifier|*
name|entry1
init|=
name|of1
decl_stmt|;
specifier|const
name|counts_entry_t
modifier|*
name|entry2
init|=
name|of2
decl_stmt|;
return|return
name|entry1
operator|->
name|ident
operator|==
name|entry2
operator|->
name|ident
operator|&&
name|entry1
operator|->
name|ctr
operator|==
name|entry2
operator|->
name|ctr
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|htab_counts_entry_del
parameter_list|(
name|void
modifier|*
name|of
parameter_list|)
block|{
name|counts_entry_t
modifier|*
name|entry
init|=
name|of
decl_stmt|;
name|free
argument_list|(
name|entry
operator|->
name|counts
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read in the counts file, if available.  */
end_comment

begin_function
specifier|static
name|void
name|read_counts_file
parameter_list|(
name|void
parameter_list|)
block|{
name|gcov_unsigned_t
name|fn_ident
init|=
literal|0
decl_stmt|;
name|gcov_unsigned_t
name|checksum
init|=
operator|-
literal|1
decl_stmt|;
name|counts_entry_t
modifier|*
name|summaried
init|=
name|NULL
decl_stmt|;
name|unsigned
name|seen_summary
init|=
literal|0
decl_stmt|;
name|gcov_unsigned_t
name|tag
decl_stmt|;
name|int
name|is_error
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|gcov_open
argument_list|(
name|da_file_name
argument_list|,
literal|1
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|gcov_magic
argument_list|(
name|gcov_read_unsigned
argument_list|()
argument_list|,
name|GCOV_DATA_MAGIC
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"%qs is not a gcov data file"
argument_list|,
name|da_file_name
argument_list|)
expr_stmt|;
name|gcov_close
argument_list|()
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|(
name|tag
operator|=
name|gcov_read_unsigned
argument_list|()
operator|)
operator|!=
name|GCOV_VERSION
condition|)
block|{
name|char
name|v
index|[
literal|4
index|]
decl_stmt|,
name|e
index|[
literal|4
index|]
decl_stmt|;
name|GCOV_UNSIGNED2STRING
argument_list|(
name|v
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|GCOV_UNSIGNED2STRING
argument_list|(
name|e
argument_list|,
name|GCOV_VERSION
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|0
argument_list|,
literal|"%qs is version %q.*s, expected version %q.*s"
argument_list|,
name|da_file_name
argument_list|,
literal|4
argument_list|,
name|v
argument_list|,
literal|4
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|gcov_close
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Read and discard the stamp.  */
name|gcov_read_unsigned
argument_list|()
expr_stmt|;
name|counts_hash
operator|=
name|htab_create
argument_list|(
literal|10
argument_list|,
name|htab_counts_entry_hash
argument_list|,
name|htab_counts_entry_eq
argument_list|,
name|htab_counts_entry_del
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|tag
operator|=
name|gcov_read_unsigned
argument_list|()
operator|)
condition|)
block|{
name|gcov_unsigned_t
name|length
decl_stmt|;
name|gcov_position_t
name|offset
decl_stmt|;
name|length
operator|=
name|gcov_read_unsigned
argument_list|()
expr_stmt|;
name|offset
operator|=
name|gcov_position
argument_list|()
expr_stmt|;
if|if
condition|(
name|tag
operator|==
name|GCOV_TAG_FUNCTION
condition|)
block|{
name|fn_ident
operator|=
name|gcov_read_unsigned
argument_list|()
expr_stmt|;
name|checksum
operator|=
name|gcov_read_unsigned
argument_list|()
expr_stmt|;
if|if
condition|(
name|seen_summary
condition|)
block|{
comment|/* We have already seen a summary, this means that this 		 new function begins a new set of program runs. We 		 must unlink the summaried chain.  */
name|counts_entry_t
modifier|*
name|entry
decl_stmt|,
modifier|*
name|chain
decl_stmt|;
for|for
control|(
name|entry
operator|=
name|summaried
init|;
name|entry
condition|;
name|entry
operator|=
name|chain
control|)
block|{
name|chain
operator|=
name|entry
operator|->
name|chain
expr_stmt|;
name|entry
operator|->
name|chain
operator|=
name|NULL
expr_stmt|;
block|}
name|summaried
operator|=
name|NULL
expr_stmt|;
name|seen_summary
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|tag
operator|==
name|GCOV_TAG_PROGRAM_SUMMARY
condition|)
block|{
name|counts_entry_t
modifier|*
name|entry
decl_stmt|;
name|struct
name|gcov_summary
name|summary
decl_stmt|;
name|gcov_read_summary
argument_list|(
operator|&
name|summary
argument_list|)
expr_stmt|;
name|seen_summary
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|entry
operator|=
name|summaried
init|;
name|entry
condition|;
name|entry
operator|=
name|entry
operator|->
name|chain
control|)
block|{
name|struct
name|gcov_ctr_summary
modifier|*
name|csum
init|=
operator|&
name|summary
operator|.
name|ctrs
index|[
name|entry
operator|->
name|ctr
index|]
decl_stmt|;
name|entry
operator|->
name|summary
operator|.
name|runs
operator|+=
name|csum
operator|->
name|runs
expr_stmt|;
name|entry
operator|->
name|summary
operator|.
name|sum_all
operator|+=
name|csum
operator|->
name|sum_all
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|summary
operator|.
name|run_max
operator|<
name|csum
operator|->
name|run_max
condition|)
name|entry
operator|->
name|summary
operator|.
name|run_max
operator|=
name|csum
operator|->
name|run_max
expr_stmt|;
name|entry
operator|->
name|summary
operator|.
name|sum_max
operator|+=
name|csum
operator|->
name|sum_max
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GCOV_TAG_IS_COUNTER
argument_list|(
name|tag
argument_list|)
operator|&&
name|fn_ident
condition|)
block|{
name|counts_entry_t
modifier|*
modifier|*
name|slot
decl_stmt|,
modifier|*
name|entry
decl_stmt|,
name|elt
decl_stmt|;
name|unsigned
name|n_counts
init|=
name|GCOV_TAG_COUNTER_NUM
argument_list|(
name|length
argument_list|)
decl_stmt|;
name|unsigned
name|ix
decl_stmt|;
name|elt
operator|.
name|ident
operator|=
name|fn_ident
expr_stmt|;
name|elt
operator|.
name|ctr
operator|=
name|GCOV_COUNTER_FOR_TAG
argument_list|(
name|tag
argument_list|)
expr_stmt|;
name|slot
operator|=
operator|(
name|counts_entry_t
operator|*
operator|*
operator|)
name|htab_find_slot
argument_list|(
name|counts_hash
argument_list|,
operator|&
name|elt
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
name|entry
operator|=
operator|*
name|slot
expr_stmt|;
if|if
condition|(
operator|!
name|entry
condition|)
block|{
operator|*
name|slot
operator|=
name|entry
operator|=
name|XCNEW
argument_list|(
name|counts_entry_t
argument_list|)
expr_stmt|;
name|entry
operator|->
name|ident
operator|=
name|elt
operator|.
name|ident
expr_stmt|;
name|entry
operator|->
name|ctr
operator|=
name|elt
operator|.
name|ctr
expr_stmt|;
name|entry
operator|->
name|checksum
operator|=
name|checksum
expr_stmt|;
name|entry
operator|->
name|summary
operator|.
name|num
operator|=
name|n_counts
expr_stmt|;
name|entry
operator|->
name|counts
operator|=
name|XCNEWVEC
argument_list|(
name|gcov_type
argument_list|,
name|n_counts
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|entry
operator|->
name|checksum
operator|!=
name|checksum
condition|)
block|{
name|error
argument_list|(
literal|"coverage mismatch for function %u while reading execution counters"
argument_list|,
name|fn_ident
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"checksum is %x instead of %x"
argument_list|,
name|entry
operator|->
name|checksum
argument_list|,
name|checksum
argument_list|)
expr_stmt|;
name|htab_delete
argument_list|(
name|counts_hash
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|entry
operator|->
name|summary
operator|.
name|num
operator|!=
name|n_counts
condition|)
block|{
name|error
argument_list|(
literal|"coverage mismatch for function %u while reading execution counters"
argument_list|,
name|fn_ident
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"number of counters is %d instead of %d"
argument_list|,
name|entry
operator|->
name|summary
operator|.
name|num
argument_list|,
name|n_counts
argument_list|)
expr_stmt|;
name|htab_delete
argument_list|(
name|counts_hash
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|elt
operator|.
name|ctr
operator|>=
name|GCOV_COUNTERS_SUMMABLE
condition|)
block|{
name|error
argument_list|(
literal|"cannot merge separate %s counters for function %u"
argument_list|,
name|ctr_names
index|[
name|elt
operator|.
name|ctr
index|]
argument_list|,
name|fn_ident
argument_list|)
expr_stmt|;
goto|goto
name|skip_merge
goto|;
block|}
if|if
condition|(
name|elt
operator|.
name|ctr
operator|<
name|GCOV_COUNTERS_SUMMABLE
comment|/* This should always be true for a just allocated entry, 		 and always false for an existing one. Check this way, in 		 case the gcov file is corrupt.  */
operator|&&
operator|(
operator|!
name|entry
operator|->
name|chain
operator|||
name|summaried
operator|!=
name|entry
operator|)
condition|)
block|{
name|entry
operator|->
name|chain
operator|=
name|summaried
expr_stmt|;
name|summaried
operator|=
name|entry
expr_stmt|;
block|}
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|!=
name|n_counts
condition|;
name|ix
operator|++
control|)
name|entry
operator|->
name|counts
index|[
name|ix
index|]
operator|+=
name|gcov_read_counter
argument_list|()
expr_stmt|;
name|skip_merge
label|:
empty_stmt|;
block|}
name|gcov_sync
argument_list|(
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|is_error
operator|=
name|gcov_is_error
argument_list|()
operator|)
condition|)
block|{
name|error
argument_list|(
name|is_error
operator|<
literal|0
condition|?
literal|"%qs has overflowed"
else|:
literal|"%qs is corrupted"
argument_list|,
name|da_file_name
argument_list|)
expr_stmt|;
name|htab_delete
argument_list|(
name|counts_hash
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|gcov_close
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns the counters for a particular tag.  */
end_comment

begin_function
name|gcov_type
modifier|*
name|get_coverage_counts
parameter_list|(
name|unsigned
name|counter
parameter_list|,
name|unsigned
name|expected
parameter_list|,
specifier|const
name|struct
name|gcov_ctr_summary
modifier|*
modifier|*
name|summary
parameter_list|)
block|{
name|counts_entry_t
modifier|*
name|entry
decl_stmt|,
name|elt
decl_stmt|;
name|gcov_unsigned_t
name|checksum
init|=
operator|-
literal|1
decl_stmt|;
comment|/* No hash table, no counts.  */
if|if
condition|(
operator|!
name|counts_hash
condition|)
block|{
specifier|static
name|int
name|warned
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|warned
operator|++
condition|)
name|inform
argument_list|(
operator|(
name|flag_guess_branch_prob
condition|?
literal|"file %s not found, execution counts estimated"
else|:
literal|"file %s not found, execution counts assumed to be zero"
operator|)
argument_list|,
name|da_file_name
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|elt
operator|.
name|ident
operator|=
name|current_function_funcdef_no
operator|+
literal|1
expr_stmt|;
name|elt
operator|.
name|ctr
operator|=
name|counter
expr_stmt|;
name|entry
operator|=
name|htab_find
argument_list|(
name|counts_hash
argument_list|,
operator|&
name|elt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|entry
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"no coverage for function %qs found"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|checksum
operator|=
name|compute_checksum
argument_list|()
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|checksum
operator|!=
name|checksum
condition|)
block|{
name|error
argument_list|(
literal|"coverage mismatch for function %qs while reading counter %qs"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|,
name|ctr_names
index|[
name|counter
index|]
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"checksum is %x instead of %x"
argument_list|,
name|entry
operator|->
name|checksum
argument_list|,
name|checksum
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|entry
operator|->
name|summary
operator|.
name|num
operator|!=
name|expected
condition|)
block|{
name|error
argument_list|(
literal|"coverage mismatch for function %qs while reading counter %qs"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|,
name|ctr_names
index|[
name|counter
index|]
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"number of counters is %d instead of %d"
argument_list|,
name|entry
operator|->
name|summary
operator|.
name|num
argument_list|,
name|expected
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|summary
condition|)
operator|*
name|summary
operator|=
operator|&
name|entry
operator|->
name|summary
expr_stmt|;
return|return
name|entry
operator|->
name|counts
return|;
block|}
end_function

begin_comment
comment|/* Allocate NUM counters of type COUNTER. Returns nonzero if the    allocation succeeded.  */
end_comment

begin_function
name|int
name|coverage_counter_alloc
parameter_list|(
name|unsigned
name|counter
parameter_list|,
name|unsigned
name|num
parameter_list|)
block|{
if|if
condition|(
name|no_coverage
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|num
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|tree_ctr_tables
index|[
name|counter
index|]
condition|)
block|{
comment|/* Generate and save a copy of this so it can be shared.  Leave 	 the index type unspecified for now; it will be set after all 	 functions have been compiled.  */
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
name|tree
name|gcov_type_node
init|=
name|get_gcov_type
argument_list|()
decl_stmt|;
name|tree
name|gcov_type_array_type
init|=
name|build_array_type
argument_list|(
name|gcov_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree_ctr_tables
index|[
name|counter
index|]
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|gcov_type_array_type
argument_list|)
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|tree_ctr_tables
index|[
name|counter
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"LPBX"
argument_list|,
name|counter
operator|+
literal|1
argument_list|)
expr_stmt|;
name|DECL_NAME
argument_list|(
name|tree_ctr_tables
index|[
name|counter
index|]
argument_list|)
operator|=
name|get_identifier
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|DECL_ALIGN
argument_list|(
name|tree_ctr_tables
index|[
name|counter
index|]
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|gcov_type_node
argument_list|)
expr_stmt|;
block|}
name|fn_b_ctrs
index|[
name|counter
index|]
operator|=
name|fn_n_ctrs
index|[
name|counter
index|]
expr_stmt|;
name|fn_n_ctrs
index|[
name|counter
index|]
operator|+=
name|num
expr_stmt|;
name|fn_ctr_mask
operator||=
literal|1
operator|<<
name|counter
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Generate a tree to access COUNTER NO.  */
end_comment

begin_function
name|tree
name|tree_coverage_counter_ref
parameter_list|(
name|unsigned
name|counter
parameter_list|,
name|unsigned
name|no
parameter_list|)
block|{
name|tree
name|gcov_type_node
init|=
name|get_gcov_type
argument_list|()
decl_stmt|;
name|gcc_assert
argument_list|(
name|no
operator|<
name|fn_n_ctrs
index|[
name|counter
index|]
operator|-
name|fn_b_ctrs
index|[
name|counter
index|]
argument_list|)
expr_stmt|;
name|no
operator|+=
name|prg_n_ctrs
index|[
name|counter
index|]
operator|+
name|fn_b_ctrs
index|[
name|counter
index|]
expr_stmt|;
comment|/* "no" here is an array index, scaled to bytes later.  */
return|return
name|build4
argument_list|(
name|ARRAY_REF
argument_list|,
name|gcov_type_node
argument_list|,
name|tree_ctr_tables
index|[
name|counter
index|]
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|no
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate a checksum for a string.  CHKSUM is the current    checksum.  */
end_comment

begin_function
specifier|static
name|unsigned
name|coverage_checksum_string
parameter_list|(
name|unsigned
name|chksum
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|char
modifier|*
name|dup
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
comment|/* Look for everything that looks if it were produced by      get_file_function_name_long and zero out the second part      that may result from flag_random_seed.  This is not critical      as the checksums are used only for sanity checking.  */
define|#
directive|define
name|GLOBAL_PREFIX
value|"_GLOBAL__"
define|#
directive|define
name|TRAILING_N
value|"N_"
define|#
directive|define
name|ISCAPXDIGIT
parameter_list|(
name|a
parameter_list|)
value|(((a)>= '0'&& (a)<= '9') || ((a)>= 'A'&& (a)<= 'F'))
if|if
condition|(
operator|(
name|ptr
operator|=
name|strstr
argument_list|(
name|string
argument_list|,
name|GLOBAL_PREFIX
argument_list|)
operator|)
condition|)
block|{
comment|/* Skip _GLOBAL__. */
name|ptr
operator|+=
name|strlen
argument_list|(
name|GLOBAL_PREFIX
argument_list|)
expr_stmt|;
comment|/* Skip optional N_ (in case __GLOBAL_N__). */
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|ptr
argument_list|,
name|TRAILING_N
argument_list|,
name|strlen
argument_list|(
name|TRAILING_N
argument_list|)
argument_list|)
condition|)
name|ptr
operator|+=
name|strlen
argument_list|(
name|TRAILING_N
argument_list|)
expr_stmt|;
comment|/* At this point, ptr should point after "_GLOBAL__N_" or "_GLOBAL__". */
while|while
condition|(
operator|(
name|ptr
operator|=
name|strchr
argument_list|(
name|ptr
argument_list|,
literal|'_'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|y
decl_stmt|;
comment|/* For every "_" in the rest of the string,              try the follwing pattern matching */
comment|/* Skip over '_'. */
name|ptr
operator|++
expr_stmt|;
define|#
directive|define
name|NDIGITS
value|(8)
comment|/* Try matching the pattern:<8-digit hex>_<8-digit hex>              The second number is randomly generated              so we want to mask it out before computing the checksum. */
for|for
control|(
name|y
operator|=
literal|0
init|;
operator|*
name|ptr
operator|!=
literal|0
operator|&&
name|y
operator|<
name|NDIGITS
condition|;
name|y
operator|++
operator|,
name|ptr
operator|++
control|)
if|if
condition|(
operator|!
name|ISCAPXDIGIT
argument_list|(
operator|*
name|ptr
argument_list|)
condition|)
break|break;
if|if
condition|(
name|y
operator|!=
name|NDIGITS
operator|||
operator|*
name|ptr
operator|!=
literal|'_'
condition|)
continue|continue;
comment|/* Skip over '_' again. */
name|ptr
operator|++
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
operator|*
name|ptr
operator|!=
literal|0
operator|&&
name|y
operator|<
name|NDIGITS
condition|;
name|y
operator|++
operator|,
name|ptr
operator|++
control|)
if|if
condition|(
operator|!
name|ISCAPXDIGIT
argument_list|(
operator|*
name|ptr
argument_list|)
condition|)
break|break;
if|if
condition|(
name|y
operator|==
name|NDIGITS
condition|)
block|{
comment|/* We have a match.                  Duplicate the string and mask out                  the second 8-digit number. */
name|dup
operator|=
name|xstrdup
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|dup
operator|+
operator|(
name|ptr
operator|-
name|string
operator|)
expr_stmt|;
for|for
control|(
name|y
operator|=
operator|-
name|NDIGITS
operator|-
literal|1
init|;
name|y
operator|<
literal|0
condition|;
name|y
operator|++
control|)
block|{
name|ptr
index|[
name|y
index|]
operator|=
literal|'0'
expr_stmt|;
block|}
name|ptr
operator|=
name|dup
expr_stmt|;
break|break;
block|}
block|}
comment|/* "ptr" should be NULL if we couldn't find the match            (strchr will return NULL if no match is found),            or it should point to dup which contains the string            with the random part masked. */
block|}
name|chksum
operator|=
name|crc32_string
argument_list|(
name|chksum
argument_list|,
operator|(
name|ptr
operator|)
condition|?
name|ptr
else|:
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|dup
condition|)
name|free
argument_list|(
name|dup
argument_list|)
expr_stmt|;
return|return
name|chksum
return|;
block|}
end_function

begin_comment
comment|/* Compute checksum for the current function.  We generate a CRC32.  */
end_comment

begin_function
specifier|static
name|unsigned
name|compute_checksum
parameter_list|(
name|void
parameter_list|)
block|{
name|expanded_location
name|xloc
init|=
name|expand_location
argument_list|(
name|DECL_SOURCE_LOCATION
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|chksum
init|=
name|xloc
operator|.
name|line
decl_stmt|;
name|chksum
operator|=
name|coverage_checksum_string
argument_list|(
name|chksum
argument_list|,
name|xloc
operator|.
name|file
argument_list|)
expr_stmt|;
name|chksum
operator|=
name|coverage_checksum_string
argument_list|(
name|chksum
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|chksum
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Begin output to the graph file for the current function.    Opens the output file, if not already done. Writes the    function header, if not already done. Returns nonzero if data    should be output.  */
end_comment

begin_function
name|int
name|coverage_begin_output
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|no_coverage
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|bbg_function_announced
condition|)
block|{
name|expanded_location
name|xloc
init|=
name|expand_location
argument_list|(
name|DECL_SOURCE_LOCATION
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|offset
decl_stmt|;
if|if
condition|(
operator|!
name|bbg_file_opened
condition|)
block|{
if|if
condition|(
operator|!
name|gcov_open
argument_list|(
name|bbg_file_name
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
name|error
argument_list|(
literal|"cannot open %s"
argument_list|,
name|bbg_file_name
argument_list|)
expr_stmt|;
else|else
block|{
name|gcov_write_unsigned
argument_list|(
name|GCOV_NOTE_MAGIC
argument_list|)
expr_stmt|;
name|gcov_write_unsigned
argument_list|(
name|GCOV_VERSION
argument_list|)
expr_stmt|;
name|gcov_write_unsigned
argument_list|(
name|local_tick
argument_list|)
expr_stmt|;
block|}
name|bbg_file_opened
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Announce function */
name|offset
operator|=
name|gcov_write_tag
argument_list|(
name|GCOV_TAG_FUNCTION
argument_list|)
expr_stmt|;
name|gcov_write_unsigned
argument_list|(
name|current_function_funcdef_no
operator|+
literal|1
argument_list|)
expr_stmt|;
name|gcov_write_unsigned
argument_list|(
name|compute_checksum
argument_list|()
argument_list|)
expr_stmt|;
name|gcov_write_string
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|gcov_write_string
argument_list|(
name|xloc
operator|.
name|file
argument_list|)
expr_stmt|;
name|gcov_write_unsigned
argument_list|(
name|xloc
operator|.
name|line
argument_list|)
expr_stmt|;
name|gcov_write_length
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|bbg_function_announced
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|!
name|gcov_is_error
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/* Finish coverage data for the current function. Verify no output    error has occurred.  Save function coverage counts.  */
end_comment

begin_function
name|void
name|coverage_end_function
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
if|if
condition|(
name|bbg_file_opened
operator|>
literal|1
operator|&&
name|gcov_is_error
argument_list|()
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"error writing %qs"
argument_list|,
name|bbg_file_name
argument_list|)
expr_stmt|;
name|bbg_file_opened
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|fn_ctr_mask
condition|)
block|{
name|struct
name|function_list
modifier|*
name|item
decl_stmt|;
name|item
operator|=
name|XNEW
argument_list|(
expr|struct
name|function_list
argument_list|)
expr_stmt|;
operator|*
name|functions_tail
operator|=
name|item
expr_stmt|;
name|functions_tail
operator|=
operator|&
name|item
operator|->
name|next
expr_stmt|;
name|item
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|item
operator|->
name|ident
operator|=
name|current_function_funcdef_no
operator|+
literal|1
expr_stmt|;
name|item
operator|->
name|checksum
operator|=
name|compute_checksum
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
name|GCOV_COUNTERS
condition|;
name|i
operator|++
control|)
block|{
name|item
operator|->
name|n_ctrs
index|[
name|i
index|]
operator|=
name|fn_n_ctrs
index|[
name|i
index|]
expr_stmt|;
name|prg_n_ctrs
index|[
name|i
index|]
operator|+=
name|fn_n_ctrs
index|[
name|i
index|]
expr_stmt|;
name|fn_n_ctrs
index|[
name|i
index|]
operator|=
name|fn_b_ctrs
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|prg_ctr_mask
operator||=
name|fn_ctr_mask
expr_stmt|;
name|fn_ctr_mask
operator|=
literal|0
expr_stmt|;
block|}
name|bbg_function_announced
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Creates the gcov_fn_info RECORD_TYPE.  */
end_comment

begin_function
specifier|static
name|tree
name|build_fn_info_type
parameter_list|(
name|unsigned
name|int
name|counters
parameter_list|)
block|{
name|tree
name|type
init|=
name|lang_hooks
operator|.
name|types
operator|.
name|make_type
argument_list|(
name|RECORD_TYPE
argument_list|)
decl_stmt|;
name|tree
name|field
decl_stmt|,
name|fields
decl_stmt|;
name|tree
name|array_type
decl_stmt|;
comment|/* ident */
name|fields
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|get_gcov_unsigned_t
argument_list|()
argument_list|)
expr_stmt|;
comment|/* checksum */
name|field
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|get_gcov_unsigned_t
argument_list|()
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
operator|=
name|fields
expr_stmt|;
name|fields
operator|=
name|field
expr_stmt|;
name|array_type
operator|=
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|counters
operator|-
literal|1
argument_list|)
expr_stmt|;
name|array_type
operator|=
name|build_index_type
argument_list|(
name|array_type
argument_list|)
expr_stmt|;
name|array_type
operator|=
name|build_array_type
argument_list|(
name|get_gcov_unsigned_t
argument_list|()
argument_list|,
name|array_type
argument_list|)
expr_stmt|;
comment|/* counters */
name|field
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|array_type
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
operator|=
name|fields
expr_stmt|;
name|fields
operator|=
name|field
expr_stmt|;
name|finish_builtin_struct
argument_list|(
name|type
argument_list|,
literal|"__gcov_fn_info"
argument_list|,
name|fields
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Creates a CONSTRUCTOR for a gcov_fn_info. FUNCTION is    the function being processed and TYPE is the gcov_fn_info    RECORD_TYPE.  */
end_comment

begin_function
specifier|static
name|tree
name|build_fn_info_value
parameter_list|(
specifier|const
name|struct
name|function_list
modifier|*
name|function
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|tree
name|value
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|fields
init|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|unsigned
name|ix
decl_stmt|;
name|tree
name|array_value
init|=
name|NULL_TREE
decl_stmt|;
comment|/* ident */
name|value
operator|=
name|tree_cons
argument_list|(
name|fields
argument_list|,
name|build_int_cstu
argument_list|(
name|get_gcov_unsigned_t
argument_list|()
argument_list|,
name|function
operator|->
name|ident
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
expr_stmt|;
comment|/* checksum */
name|value
operator|=
name|tree_cons
argument_list|(
name|fields
argument_list|,
name|build_int_cstu
argument_list|(
name|get_gcov_unsigned_t
argument_list|()
argument_list|,
name|function
operator|->
name|checksum
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
expr_stmt|;
comment|/* counters */
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|!=
name|GCOV_COUNTERS
condition|;
name|ix
operator|++
control|)
if|if
condition|(
name|prg_ctr_mask
operator|&
operator|(
literal|1
operator|<<
name|ix
operator|)
condition|)
block|{
name|tree
name|counters
init|=
name|build_int_cstu
argument_list|(
name|get_gcov_unsigned_t
argument_list|()
argument_list|,
name|function
operator|->
name|n_ctrs
index|[
name|ix
index|]
argument_list|)
decl_stmt|;
name|array_value
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|counters
argument_list|,
name|array_value
argument_list|)
expr_stmt|;
block|}
comment|/* FIXME: use build_constructor directly.  */
name|array_value
operator|=
name|build_constructor_from_list
argument_list|(
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
argument_list|,
name|nreverse
argument_list|(
name|array_value
argument_list|)
argument_list|)
expr_stmt|;
name|value
operator|=
name|tree_cons
argument_list|(
name|fields
argument_list|,
name|array_value
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* FIXME: use build_constructor directly.  */
name|value
operator|=
name|build_constructor_from_list
argument_list|(
name|type
argument_list|,
name|nreverse
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* Creates the gcov_ctr_info RECORD_TYPE.  */
end_comment

begin_function
specifier|static
name|tree
name|build_ctr_info_type
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|type
init|=
name|lang_hooks
operator|.
name|types
operator|.
name|make_type
argument_list|(
name|RECORD_TYPE
argument_list|)
decl_stmt|;
name|tree
name|field
decl_stmt|,
name|fields
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|gcov_ptr_type
init|=
name|build_pointer_type
argument_list|(
name|get_gcov_type
argument_list|()
argument_list|)
decl_stmt|;
name|tree
name|gcov_merge_fn_type
decl_stmt|;
comment|/* counters */
name|field
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|get_gcov_unsigned_t
argument_list|()
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
operator|=
name|fields
expr_stmt|;
name|fields
operator|=
name|field
expr_stmt|;
comment|/* values */
name|field
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|gcov_ptr_type
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
operator|=
name|fields
expr_stmt|;
name|fields
operator|=
name|field
expr_stmt|;
comment|/* merge */
name|gcov_merge_fn_type
operator|=
name|build_function_type_list
argument_list|(
name|void_type_node
argument_list|,
name|gcov_ptr_type
argument_list|,
name|get_gcov_unsigned_t
argument_list|()
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|field
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|build_pointer_type
argument_list|(
name|gcov_merge_fn_type
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
operator|=
name|fields
expr_stmt|;
name|fields
operator|=
name|field
expr_stmt|;
name|finish_builtin_struct
argument_list|(
name|type
argument_list|,
literal|"__gcov_ctr_info"
argument_list|,
name|fields
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Creates a CONSTRUCTOR for a gcov_ctr_info. COUNTER is    the counter being processed and TYPE is the gcov_ctr_info    RECORD_TYPE.  */
end_comment

begin_function
specifier|static
name|tree
name|build_ctr_info_value
parameter_list|(
name|unsigned
name|int
name|counter
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|tree
name|value
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|fields
init|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|fn
decl_stmt|;
comment|/* counters */
name|value
operator|=
name|tree_cons
argument_list|(
name|fields
argument_list|,
name|build_int_cstu
argument_list|(
name|get_gcov_unsigned_t
argument_list|()
argument_list|,
name|prg_n_ctrs
index|[
name|counter
index|]
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
expr_stmt|;
if|if
condition|(
name|prg_n_ctrs
index|[
name|counter
index|]
condition|)
block|{
name|tree
name|array_type
decl_stmt|;
name|array_type
operator|=
name|build_int_cstu
argument_list|(
name|get_gcov_unsigned_t
argument_list|()
argument_list|,
name|prg_n_ctrs
index|[
name|counter
index|]
operator|-
literal|1
argument_list|)
expr_stmt|;
name|array_type
operator|=
name|build_index_type
argument_list|(
name|array_type
argument_list|)
expr_stmt|;
name|array_type
operator|=
name|build_array_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
argument_list|)
argument_list|,
name|array_type
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|tree_ctr_tables
index|[
name|counter
index|]
argument_list|)
operator|=
name|array_type
expr_stmt|;
name|DECL_SIZE
argument_list|(
name|tree_ctr_tables
index|[
name|counter
index|]
argument_list|)
operator|=
name|TYPE_SIZE
argument_list|(
name|array_type
argument_list|)
expr_stmt|;
name|DECL_SIZE_UNIT
argument_list|(
name|tree_ctr_tables
index|[
name|counter
index|]
argument_list|)
operator|=
name|TYPE_SIZE_UNIT
argument_list|(
name|array_type
argument_list|)
expr_stmt|;
name|assemble_variable
argument_list|(
name|tree_ctr_tables
index|[
name|counter
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|value
operator|=
name|tree_cons
argument_list|(
name|fields
argument_list|,
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
argument_list|,
name|tree_ctr_tables
index|[
name|counter
index|]
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
else|else
name|value
operator|=
name|tree_cons
argument_list|(
name|fields
argument_list|,
name|null_pointer_node
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
expr_stmt|;
name|fn
operator|=
name|build_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|get_identifier
argument_list|(
name|ctr_merge_functions
index|[
name|counter
index|]
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_NOTHROW
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|value
operator|=
name|tree_cons
argument_list|(
name|fields
argument_list|,
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
argument_list|,
name|fn
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* FIXME: use build_constructor directly.  */
name|value
operator|=
name|build_constructor_from_list
argument_list|(
name|type
argument_list|,
name|nreverse
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* Creates the gcov_info RECORD_TYPE and initializer for it. Returns a    CONSTRUCTOR.  */
end_comment

begin_function
specifier|static
name|tree
name|build_gcov_info
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|n_ctr_types
decl_stmt|,
name|ix
decl_stmt|;
name|tree
name|type
decl_stmt|,
name|const_type
decl_stmt|;
name|tree
name|fn_info_type
decl_stmt|,
name|fn_info_value
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|fn_info_ptr_type
decl_stmt|;
name|tree
name|ctr_info_type
decl_stmt|,
name|ctr_info_ary_type
decl_stmt|,
name|ctr_info_value
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|field
decl_stmt|,
name|fields
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|value
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|filename_string
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|filename_len
decl_stmt|;
name|unsigned
name|n_fns
decl_stmt|;
specifier|const
name|struct
name|function_list
modifier|*
name|fn
decl_stmt|;
name|tree
name|string_type
decl_stmt|;
comment|/* Count the number of active counters.  */
for|for
control|(
name|n_ctr_types
operator|=
literal|0
operator|,
name|ix
operator|=
literal|0
init|;
name|ix
operator|!=
name|GCOV_COUNTERS
condition|;
name|ix
operator|++
control|)
if|if
condition|(
name|prg_ctr_mask
operator|&
operator|(
literal|1
operator|<<
name|ix
operator|)
condition|)
name|n_ctr_types
operator|++
expr_stmt|;
name|type
operator|=
name|lang_hooks
operator|.
name|types
operator|.
name|make_type
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|const_type
operator|=
name|build_qualified_type
argument_list|(
name|type
argument_list|,
name|TYPE_QUAL_CONST
argument_list|)
expr_stmt|;
comment|/* Version ident */
name|field
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|get_gcov_unsigned_t
argument_list|()
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
operator|=
name|fields
expr_stmt|;
name|fields
operator|=
name|field
expr_stmt|;
name|value
operator|=
name|tree_cons
argument_list|(
name|field
argument_list|,
name|build_int_cstu
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|GCOV_VERSION
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* next -- NULL */
name|field
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|build_pointer_type
argument_list|(
name|const_type
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
operator|=
name|fields
expr_stmt|;
name|fields
operator|=
name|field
expr_stmt|;
name|value
operator|=
name|tree_cons
argument_list|(
name|field
argument_list|,
name|null_pointer_node
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* stamp */
name|field
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|get_gcov_unsigned_t
argument_list|()
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
operator|=
name|fields
expr_stmt|;
name|fields
operator|=
name|field
expr_stmt|;
name|value
operator|=
name|tree_cons
argument_list|(
name|field
argument_list|,
name|build_int_cstu
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|local_tick
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* Filename */
name|string_type
operator|=
name|build_pointer_type
argument_list|(
name|build_qualified_type
argument_list|(
name|char_type_node
argument_list|,
name|TYPE_QUAL_CONST
argument_list|)
argument_list|)
expr_stmt|;
name|field
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|string_type
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
operator|=
name|fields
expr_stmt|;
name|fields
operator|=
name|field
expr_stmt|;
name|filename
operator|=
name|getpwd
argument_list|()
expr_stmt|;
name|filename
operator|=
operator|(
name|filename
operator|&&
name|da_file_name
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|?
name|concat
argument_list|(
name|filename
argument_list|,
literal|"/"
argument_list|,
name|da_file_name
argument_list|,
name|NULL
argument_list|)
else|:
name|da_file_name
operator|)
expr_stmt|;
name|filename_len
operator|=
name|strlen
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|filename_string
operator|=
name|build_string
argument_list|(
name|filename_len
operator|+
literal|1
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|filename
operator|!=
name|da_file_name
condition|)
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|filename_string
argument_list|)
operator|=
name|build_array_type
argument_list|(
name|char_type_node
argument_list|,
name|build_index_type
argument_list|(
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|filename_len
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|value
operator|=
name|tree_cons
argument_list|(
name|field
argument_list|,
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|string_type
argument_list|,
name|filename_string
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* Build the fn_info type and initializer.  */
name|fn_info_type
operator|=
name|build_fn_info_type
argument_list|(
name|n_ctr_types
argument_list|)
expr_stmt|;
name|fn_info_ptr_type
operator|=
name|build_pointer_type
argument_list|(
name|build_qualified_type
argument_list|(
name|fn_info_type
argument_list|,
name|TYPE_QUAL_CONST
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|fn
operator|=
name|functions_head
operator|,
name|n_fns
operator|=
literal|0
init|;
name|fn
condition|;
name|fn
operator|=
name|fn
operator|->
name|next
operator|,
name|n_fns
operator|++
control|)
name|fn_info_value
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_fn_info_value
argument_list|(
name|fn
argument_list|,
name|fn_info_type
argument_list|)
argument_list|,
name|fn_info_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_fns
condition|)
block|{
name|tree
name|array_type
decl_stmt|;
name|array_type
operator|=
name|build_index_type
argument_list|(
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|n_fns
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|array_type
operator|=
name|build_array_type
argument_list|(
name|fn_info_type
argument_list|,
name|array_type
argument_list|)
expr_stmt|;
comment|/* FIXME: use build_constructor directly.  */
name|fn_info_value
operator|=
name|build_constructor_from_list
argument_list|(
name|array_type
argument_list|,
name|nreverse
argument_list|(
name|fn_info_value
argument_list|)
argument_list|)
expr_stmt|;
name|fn_info_value
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|fn_info_ptr_type
argument_list|,
name|fn_info_value
argument_list|)
expr_stmt|;
block|}
else|else
name|fn_info_value
operator|=
name|null_pointer_node
expr_stmt|;
comment|/* number of functions */
name|field
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|get_gcov_unsigned_t
argument_list|()
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
operator|=
name|fields
expr_stmt|;
name|fields
operator|=
name|field
expr_stmt|;
name|value
operator|=
name|tree_cons
argument_list|(
name|field
argument_list|,
name|build_int_cstu
argument_list|(
name|get_gcov_unsigned_t
argument_list|()
argument_list|,
name|n_fns
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* fn_info table */
name|field
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|fn_info_ptr_type
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
operator|=
name|fields
expr_stmt|;
name|fields
operator|=
name|field
expr_stmt|;
name|value
operator|=
name|tree_cons
argument_list|(
name|field
argument_list|,
name|fn_info_value
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* counter_mask */
name|field
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|get_gcov_unsigned_t
argument_list|()
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
operator|=
name|fields
expr_stmt|;
name|fields
operator|=
name|field
expr_stmt|;
name|value
operator|=
name|tree_cons
argument_list|(
name|field
argument_list|,
name|build_int_cstu
argument_list|(
name|get_gcov_unsigned_t
argument_list|()
argument_list|,
name|prg_ctr_mask
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* counters */
name|ctr_info_type
operator|=
name|build_ctr_info_type
argument_list|()
expr_stmt|;
name|ctr_info_ary_type
operator|=
name|build_index_type
argument_list|(
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|n_ctr_types
argument_list|)
argument_list|)
expr_stmt|;
name|ctr_info_ary_type
operator|=
name|build_array_type
argument_list|(
name|ctr_info_type
argument_list|,
name|ctr_info_ary_type
argument_list|)
expr_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|!=
name|GCOV_COUNTERS
condition|;
name|ix
operator|++
control|)
if|if
condition|(
name|prg_ctr_mask
operator|&
operator|(
literal|1
operator|<<
name|ix
operator|)
condition|)
name|ctr_info_value
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_ctr_info_value
argument_list|(
name|ix
argument_list|,
name|ctr_info_type
argument_list|)
argument_list|,
name|ctr_info_value
argument_list|)
expr_stmt|;
comment|/* FIXME: use build_constructor directly.  */
name|ctr_info_value
operator|=
name|build_constructor_from_list
argument_list|(
name|ctr_info_ary_type
argument_list|,
name|nreverse
argument_list|(
name|ctr_info_value
argument_list|)
argument_list|)
expr_stmt|;
name|field
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|ctr_info_ary_type
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
operator|=
name|fields
expr_stmt|;
name|fields
operator|=
name|field
expr_stmt|;
name|value
operator|=
name|tree_cons
argument_list|(
name|field
argument_list|,
name|ctr_info_value
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|finish_builtin_struct
argument_list|(
name|type
argument_list|,
literal|"__gcov_info"
argument_list|,
name|fields
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* FIXME: use build_constructor directly.  */
name|value
operator|=
name|build_constructor_from_list
argument_list|(
name|type
argument_list|,
name|nreverse
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* Write out the structure which libgcov uses to locate all the    counters.  The structures used here must match those defined in    gcov-io.h.  Write out the constructor to call __gcov_init.  */
end_comment

begin_function
specifier|static
name|void
name|create_coverage
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|gcov_info
decl_stmt|,
name|gcov_init
decl_stmt|,
name|body
decl_stmt|,
name|t
decl_stmt|;
name|char
name|name_buf
index|[
literal|32
index|]
decl_stmt|;
name|no_coverage
operator|=
literal|1
expr_stmt|;
comment|/* Disable any further coverage.  */
if|if
condition|(
operator|!
name|prg_ctr_mask
condition|)
return|return;
name|t
operator|=
name|build_gcov_info
argument_list|()
expr_stmt|;
name|gcov_info
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|gcov_info
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|name_buf
argument_list|,
literal|"LPBX"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DECL_NAME
argument_list|(
name|gcov_info
argument_list|)
operator|=
name|get_identifier
argument_list|(
name|name_buf
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|gcov_info
argument_list|)
operator|=
name|t
expr_stmt|;
comment|/* Build structure.  */
name|assemble_variable
argument_list|(
name|gcov_info
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Build a decl for __gcov_init.  */
name|t
operator|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|gcov_info
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_function_type_list
argument_list|(
name|void_type_node
argument_list|,
name|t
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__gcov_init"
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|gcov_init
operator|=
name|t
expr_stmt|;
comment|/* Generate a call to __gcov_init(&gcov_info).  */
name|body
operator|=
name|NULL
expr_stmt|;
name|t
operator|=
name|build_fold_addr_expr
argument_list|(
name|gcov_info
argument_list|)
expr_stmt|;
name|t
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|t
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_function_call_expr
argument_list|(
name|gcov_init
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|t
argument_list|,
operator|&
name|body
argument_list|)
expr_stmt|;
comment|/* Generate a constructor to run it.  */
name|cgraph_build_static_cdtor
argument_list|(
literal|'I'
argument_list|,
name|body
argument_list|,
name|DEFAULT_INIT_PRIORITY
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Perform file-level initialization. Read in data file, generate name    of graph file.  */
end_comment

begin_function
name|void
name|coverage_init
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|filename
argument_list|)
decl_stmt|;
comment|/* Name of da file.  */
name|da_file_name
operator|=
name|XNEWVEC
argument_list|(
name|char
argument_list|,
name|len
operator|+
name|strlen
argument_list|(
name|GCOV_DATA_SUFFIX
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|da_file_name
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|da_file_name
argument_list|,
name|GCOV_DATA_SUFFIX
argument_list|)
expr_stmt|;
comment|/* Name of bbg file.  */
name|bbg_file_name
operator|=
name|XNEWVEC
argument_list|(
name|char
argument_list|,
name|len
operator|+
name|strlen
argument_list|(
name|GCOV_NOTE_SUFFIX
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|bbg_file_name
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|bbg_file_name
argument_list|,
name|GCOV_NOTE_SUFFIX
argument_list|)
expr_stmt|;
name|read_counts_file
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Performs file-level cleanup.  Close graph file, generate coverage    variables and constructor.  */
end_comment

begin_function
name|void
name|coverage_finish
parameter_list|(
name|void
parameter_list|)
block|{
name|create_coverage
argument_list|()
expr_stmt|;
if|if
condition|(
name|bbg_file_opened
condition|)
block|{
name|int
name|error
init|=
name|gcov_close
argument_list|()
decl_stmt|;
if|if
condition|(
name|error
condition|)
name|unlink
argument_list|(
name|bbg_file_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|local_tick
condition|)
comment|/* Only remove the da file, if we cannot stamp it. If we can 	   stamp it, libgcov will DTRT.  */
name|unlink
argument_list|(
name|da_file_name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_include
include|#
directive|include
file|"gt-coverage.h"
end_include

end_unit

