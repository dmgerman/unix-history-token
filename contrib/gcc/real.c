begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* real.c - implementation of REAL_ARITHMETIC, REAL_VALUE_ATOF,    and support for XFmode IEEE extended real floating point arithmetic.    Copyright (C) 1993, 94-98, 1999 Free Software Foundation, Inc.    Contributed by Stephen L. Moshier (moshier@world.std.com).  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_comment
comment|/* To enable support of XFmode extended real floating point, define LONG_DOUBLE_TYPE_SIZE 96 in the tm.h file (m68k.h or i386.h).  To support cross compilation between IEEE, VAX and IBM floating point formats, define REAL_ARITHMETIC in the tm.h file.  In either case the machine files (tm.h) must not contain any code that tries to use host floating point arithmetic to convert REAL_VALUE_TYPEs from `double' to `float', pass them to fprintf, etc.  In cross-compile situations a REAL_VALUE_TYPE may not be intelligible to the host computer's native arithmetic.  The emulator defaults to the host's floating point format so that its decimal conversion functions can be used if desired (see real.h).  The first part of this file interfaces gcc to a floating point arithmetic suite that was not written with gcc in mind.  Avoid changing the low-level arithmetic routines unless you have suitable test programs available.  A special version of the PARANOIA floating point arithmetic tester, modified for this purpose, can be found on usc.edu: /pub/C-numanal/ieeetest.zoo.  Other tests, and libraries of XFmode and TFmode transcendental functions, can be obtained by ftp from netlib.att.com: netlib/cephes.   */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Type of computer arithmetic.    Only one of DEC, IBM, IEEE, C4X, or UNK should get defined.     `IEEE', when REAL_WORDS_BIG_ENDIAN is non-zero, refers generically    to big-endian IEEE floating-point data structure.  This definition    should work in SFmode `float' type and DFmode `double' type on    virtually all big-endian IEEE machines.  If LONG_DOUBLE_TYPE_SIZE    has been defined to be 96, then IEEE also invokes the particular    XFmode (`long double' type) data structure used by the Motorola    680x0 series processors.     `IEEE', when REAL_WORDS_BIG_ENDIAN is zero, refers generally to    little-endian IEEE machines. In this case, if LONG_DOUBLE_TYPE_SIZE    has been defined to be 96, then IEEE also invokes the particular    XFmode `long double' data structure used by the Intel 80x86 series    processors.     `DEC' refers specifically to the Digital Equipment Corp PDP-11    and VAX floating point data structure.  This model currently    supports no type wider than DFmode.     `IBM' refers specifically to the IBM System/370 and compatible    floating point data structure.  This model currently supports    no type wider than DFmode.  The IBM conversions were contributed by    frank@atom.ansto.gov.au (Frank Crawford).     `C4X' refers specifically to the floating point format used on    Texas Instruments TMS320C3x and TMS320C4x digital signal    processors.  This supports QFmode (32-bit float, double) and HFmode    (40-bit long double) where BITS_PER_BYTE is 32. Unlike IEEE    floats, C4x floats are not rounded to be even. The C4x conversions    were contributed by m.hayes@elec.canterbury.ac.nz (Michael Hayes) and    Haj.Ten.Brugge@net.HCC.nl (Herman ten Brugge).     If LONG_DOUBLE_TYPE_SIZE = 64 (the default, unless tm.h defines it)    then `long double' and `double' are both implemented, but they    both mean DFmode.  In this case, the software floating-point    support available here is activated by writing       #define REAL_ARITHMETIC    in tm.h.     The case LONG_DOUBLE_TYPE_SIZE = 128 activates TFmode support    and may deactivate XFmode since `long double' is used to refer    to both modes.     The macros FLOAT_WORDS_BIG_ENDIAN, HOST_FLOAT_WORDS_BIG_ENDIAN,    contributed by Richard Earnshaw<Richard.Earnshaw@cl.cam.ac.uk>,    separate the floating point unit's endian-ness from that of    the integer addressing.  This permits one to define a big-endian    FPU on a little-endian machine (e.g., ARM).  An extension to    BYTES_BIG_ENDIAN may be required for some machines in the future.    These optional macros may be defined in tm.h.  In real.h, they    default to WORDS_BIG_ENDIAN, etc., so there is no need to define    them for any normal host or target machine on which the floats    and the integers have the same endian-ness.   */
end_comment

begin_comment
comment|/* The following converts gcc macros into the ones used by this file.  */
end_comment

begin_comment
comment|/* REAL_ARITHMETIC defined means that macros in real.h are    defined to call emulator functions.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|REAL_ARITHMETIC
end_ifdef

begin_if
if|#
directive|if
name|TARGET_FLOAT_FORMAT
operator|==
name|VAX_FLOAT_FORMAT
end_if

begin_comment
comment|/* PDP-11, Pro350, VAX: */
end_comment

begin_define
define|#
directive|define
name|DEC
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* it's not VAX */
end_comment

begin_if
if|#
directive|if
name|TARGET_FLOAT_FORMAT
operator|==
name|IBM_FLOAT_FORMAT
end_if

begin_comment
comment|/* IBM System/370 style */
end_comment

begin_define
define|#
directive|define
name|IBM
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* it's also not an IBM */
end_comment

begin_if
if|#
directive|if
name|TARGET_FLOAT_FORMAT
operator|==
name|C4X_FLOAT_FORMAT
end_if

begin_comment
comment|/* TMS320C3x/C4x style */
end_comment

begin_define
define|#
directive|define
name|C4X
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* it's also not a C4X */
end_comment

begin_if
if|#
directive|if
name|TARGET_FLOAT_FORMAT
operator|==
name|IEEE_FLOAT_FORMAT
end_if

begin_define
define|#
directive|define
name|IEEE
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* it's not IEEE either */
end_comment

begin_comment
comment|/* UNKnown arithmetic.  We don't support this and can't go on.  */
end_comment

begin_decl_stmt
name|unknown
name|arithmetic
name|type
define|#
directive|define
name|UNK
value|1
endif|#
directive|endif
comment|/* not IEEE */
endif|#
directive|endif
comment|/* not C4X */
endif|#
directive|endif
comment|/* not IBM */
endif|#
directive|endif
comment|/* not VAX */
define|#
directive|define
name|REAL_WORDS_BIG_ENDIAN
value|FLOAT_WORDS_BIG_ENDIAN
else|#
directive|else
comment|/* REAL_ARITHMETIC not defined means that the *host's* data    structure will be used.  It may differ by endian-ness from the    target machine's structure and will get its ends swapped    accordingly (but not here).  Probably only the decimal<-> binary    functions in this file will actually be used in this case.  */
if|#
directive|if
name|HOST_FLOAT_FORMAT
operator|==
name|VAX_FLOAT_FORMAT
define|#
directive|define
name|DEC
value|1
else|#
directive|else
comment|/* it's not VAX */
if|#
directive|if
name|HOST_FLOAT_FORMAT
operator|==
name|IBM_FLOAT_FORMAT
comment|/* IBM System/370 style */
define|#
directive|define
name|IBM
value|1
else|#
directive|else
comment|/* it's also not an IBM */
if|#
directive|if
name|HOST_FLOAT_FORMAT
operator|==
name|IEEE_FLOAT_FORMAT
define|#
directive|define
name|IEEE
else|#
directive|else
comment|/* it's not IEEE either */
name|unknown
name|arithmetic
name|type
define|#
directive|define
name|UNK
value|1
endif|#
directive|endif
comment|/* not IEEE */
endif|#
directive|endif
comment|/* not IBM */
endif|#
directive|endif
comment|/* not VAX */
define|#
directive|define
name|REAL_WORDS_BIG_ENDIAN
value|HOST_FLOAT_WORDS_BIG_ENDIAN
endif|#
directive|endif
comment|/* REAL_ARITHMETIC not defined */
comment|/* Define INFINITY for support of infinity.    Define NANS for support of Not-a-Number's (NaN's).  */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DEC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|IBM
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|C4X
argument_list|)
define|#
directive|define
name|INFINITY
define|#
directive|define
name|NANS
endif|#
directive|endif
comment|/* Support of NaNs requires support of infinity.  */
ifdef|#
directive|ifdef
name|NANS
ifndef|#
directive|ifndef
name|INFINITY
define|#
directive|define
name|INFINITY
endif|#
directive|endif
endif|#
directive|endif
comment|/* Find a host integer type that is at least 16 bits wide,    and another type at least twice whatever that size is.  */
if|#
directive|if
name|HOST_BITS_PER_CHAR
operator|>=
literal|16
define|#
directive|define
name|EMUSHORT
value|char
define|#
directive|define
name|EMUSHORT_SIZE
value|HOST_BITS_PER_CHAR
define|#
directive|define
name|EMULONG_SIZE
value|(2 * HOST_BITS_PER_CHAR)
else|#
directive|else
if|#
directive|if
name|HOST_BITS_PER_SHORT
operator|>=
literal|16
define|#
directive|define
name|EMUSHORT
value|short
define|#
directive|define
name|EMUSHORT_SIZE
value|HOST_BITS_PER_SHORT
define|#
directive|define
name|EMULONG_SIZE
value|(2 * HOST_BITS_PER_SHORT)
else|#
directive|else
if|#
directive|if
name|HOST_BITS_PER_INT
operator|>=
literal|16
define|#
directive|define
name|EMUSHORT
value|int
define|#
directive|define
name|EMUSHORT_SIZE
value|HOST_BITS_PER_INT
define|#
directive|define
name|EMULONG_SIZE
value|(2 * HOST_BITS_PER_INT)
else|#
directive|else
if|#
directive|if
name|HOST_BITS_PER_LONG
operator|>=
literal|16
define|#
directive|define
name|EMUSHORT
value|long
define|#
directive|define
name|EMUSHORT_SIZE
value|HOST_BITS_PER_LONG
define|#
directive|define
name|EMULONG_SIZE
value|(2 * HOST_BITS_PER_LONG)
else|#
directive|else
comment|/*  You will have to modify this program to have a smaller unit size.  */
define|#
directive|define
name|EMU_NON_COMPILE
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
if|#
directive|if
name|HOST_BITS_PER_SHORT
operator|>=
name|EMULONG_SIZE
define|#
directive|define
name|EMULONG
value|short
else|#
directive|else
if|#
directive|if
name|HOST_BITS_PER_INT
operator|>=
name|EMULONG_SIZE
define|#
directive|define
name|EMULONG
value|int
else|#
directive|else
if|#
directive|if
name|HOST_BITS_PER_LONG
operator|>=
name|EMULONG_SIZE
define|#
directive|define
name|EMULONG
value|long
else|#
directive|else
if|#
directive|if
name|HOST_BITS_PER_LONGLONG
operator|>=
name|EMULONG_SIZE
define|#
directive|define
name|EMULONG
value|long long int
else|#
directive|else
comment|/*  You will have to modify this program to have a smaller unit size.  */
define|#
directive|define
name|EMU_NON_COMPILE
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
comment|/* The host interface doesn't work if no 16-bit size exists.  */
if|#
directive|if
name|EMUSHORT_SIZE
operator|!=
literal|16
define|#
directive|define
name|EMU_NON_COMPILE
endif|#
directive|endif
comment|/* OK to continue compilation.  */
ifndef|#
directive|ifndef
name|EMU_NON_COMPILE
comment|/* Construct macros to translate between REAL_VALUE_TYPE and e type.    In GET_REAL and PUT_REAL, r and e are pointers.    A REAL_VALUE_TYPE is guaranteed to occupy contiguous locations    in memory, with no holes.  */
if|#
directive|if
name|LONG_DOUBLE_TYPE_SIZE
operator|==
literal|96
comment|/* Number of 16 bit words in external e type format */
define|#
directive|define
name|NE
value|6
define|#
directive|define
name|MAXDECEXP
value|4932
define|#
directive|define
name|MINDECEXP
value|-4956
define|#
directive|define
name|GET_REAL
parameter_list|(
name|r
parameter_list|,
name|e
parameter_list|)
value|bcopy ((char *) r, (char *) e, 2*NE)
define|#
directive|define
name|PUT_REAL
parameter_list|(
name|e
parameter_list|,
name|r
parameter_list|)
define|\
value|do {						\   if (2*NE< sizeof(*r))			\     bzero((char *)r, sizeof(*r));		\   bcopy ((char *) e, (char *) r, 2*NE);		\ } while (0)
else|#
directive|else
comment|/* no XFmode */
if|#
directive|if
name|LONG_DOUBLE_TYPE_SIZE
operator|==
literal|128
define|#
directive|define
name|NE
value|10
define|#
directive|define
name|MAXDECEXP
value|4932
define|#
directive|define
name|MINDECEXP
value|-4977
define|#
directive|define
name|GET_REAL
parameter_list|(
name|r
parameter_list|,
name|e
parameter_list|)
value|bcopy ((char *) r, (char *) e, 2*NE)
define|#
directive|define
name|PUT_REAL
parameter_list|(
name|e
parameter_list|,
name|r
parameter_list|)
value|bcopy ((char *) e, (char *) r, 2*NE)
else|#
directive|else
define|#
directive|define
name|NE
value|6
define|#
directive|define
name|MAXDECEXP
value|4932
define|#
directive|define
name|MINDECEXP
value|-4956
ifdef|#
directive|ifdef
name|REAL_ARITHMETIC
comment|/* Emulator uses target format internally    but host stores it in host endian-ness.  */
define|#
directive|define
name|GET_REAL
parameter_list|(
name|r
parameter_list|,
name|e
parameter_list|)
define|\
value|do {									\      if (HOST_FLOAT_WORDS_BIG_ENDIAN == REAL_WORDS_BIG_ENDIAN)		\        e53toe ((unsigned EMUSHORT *) (r), (e));				\      else								\        {								\ 	 unsigned EMUSHORT w[4];					\          bcopy (((EMUSHORT *) r),&w[3], sizeof (EMUSHORT));		\          bcopy (((EMUSHORT *) r) + 1,&w[2], sizeof (EMUSHORT));	\ 	 bcopy (((EMUSHORT *) r) + 2,&w[1], sizeof (EMUSHORT));	\ 	 bcopy (((EMUSHORT *) r) + 3,&w[0], sizeof (EMUSHORT));	\ 	 e53toe (w, (e));						\        }								\    } while (0)
define|#
directive|define
name|PUT_REAL
parameter_list|(
name|e
parameter_list|,
name|r
parameter_list|)
define|\
value|do {									\      if (HOST_FLOAT_WORDS_BIG_ENDIAN == REAL_WORDS_BIG_ENDIAN)		\        etoe53 ((e), (unsigned EMUSHORT *) (r));				\      else								\        {								\ 	 unsigned EMUSHORT w[4];					\ 	 etoe53 ((e), w);						\          bcopy (&w[3], ((EMUSHORT *) r), sizeof (EMUSHORT));		\          bcopy (&w[2], ((EMUSHORT *) r) + 1, sizeof (EMUSHORT));	\          bcopy (&w[1], ((EMUSHORT *) r) + 2, sizeof (EMUSHORT));	\          bcopy (&w[0], ((EMUSHORT *) r) + 3, sizeof (EMUSHORT));	\        }								\    } while (0)
else|#
directive|else
comment|/* not REAL_ARITHMETIC */
comment|/* emulator uses host format */
define|#
directive|define
name|GET_REAL
parameter_list|(
name|r
parameter_list|,
name|e
parameter_list|)
value|e53toe ((unsigned EMUSHORT *) (r), (e))
define|#
directive|define
name|PUT_REAL
parameter_list|(
name|e
parameter_list|,
name|r
parameter_list|)
value|etoe53 ((e), (unsigned EMUSHORT *) (r))
endif|#
directive|endif
comment|/* not REAL_ARITHMETIC */
endif|#
directive|endif
comment|/* not TFmode */
endif|#
directive|endif
comment|/* not XFmode */
comment|/* Number of 16 bit words in internal format */
define|#
directive|define
name|NI
value|(NE+3)
comment|/* Array offset to exponent */
define|#
directive|define
name|E
value|1
comment|/* Array offset to high guard word */
define|#
directive|define
name|M
value|2
comment|/* Number of bits of precision */
define|#
directive|define
name|NBITS
value|((NI-4)*16)
comment|/* Maximum number of decimal digits in ASCII conversion  * = NBITS*log10(2)  */
define|#
directive|define
name|NDEC
value|(NBITS*8/27)
comment|/* The exponent of 1.0 */
define|#
directive|define
name|EXONE
value|(0x3fff)
specifier|extern
name|int
name|extra_warnings
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|EMUSHORT
name|ezero
index|[]
decl_stmt|,
name|ehalf
index|[]
decl_stmt|,
name|eone
index|[]
decl_stmt|,
name|etwo
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|EMUSHORT
name|elog2
index|[]
decl_stmt|,
name|esqrt2
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|endian
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|long
operator|*
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|eclear
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|emov
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void eabs	PROTO((unsigned EMUSHORT *));
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|eneg
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|eisneg
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|eisinf
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|eisnan
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|einfin
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|enan
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|emovi
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|emovo
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ecleaz
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ecleazs
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|emovz
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|einan
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|eiisnan
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|eiisneg
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void eiinfin	PROTO((unsigned EMUSHORT *));
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|eiisinf
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ecmpm
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|eshdn1
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|eshup1
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|eshdn8
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|eshup8
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|eshup6
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|eshdn6
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|eaddm
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|void
name|esubm
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|m16m
name|PROTO
argument_list|(
operator|(
name|unsigned
name|int
operator|,
name|unsigned
name|short
operator|*
operator|,
name|unsigned
name|short
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|edivm
name|PROTO
argument_list|(
operator|(
name|unsigned
name|short
operator|*
operator|,
name|unsigned
name|short
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|emulm
name|PROTO
argument_list|(
operator|(
name|unsigned
name|short
operator|*
operator|,
name|unsigned
name|short
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|emdnorm
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|EMULONG
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|esub
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|eadd
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|eadd1
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ediv
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|emul
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|e53toe
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|e64toe
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|e113toe
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|e24toe
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|etoe113
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|toe113
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|etoe64
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|toe64
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|etoe53
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|toe53
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|etoe24
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|toe24
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ecmp
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void eround	PROTO((unsigned EMUSHORT *, unsigned EMUSHORT *));
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|ltoe
name|PROTO
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ultoe
name|PROTO
argument_list|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|eifrac
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|HOST_WIDE_INT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|euifrac
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|HOST_WIDE_INT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|eshift
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|enormlz
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void e24toasc	PROTO((unsigned EMUSHORT *, char *, int)); static void e53toasc	PROTO((unsigned EMUSHORT *, char *, int)); static void e64toasc	PROTO((unsigned EMUSHORT *, char *, int)); static void e113toasc	PROTO((unsigned EMUSHORT *, char *, int));
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_decl_stmt
specifier|static
name|void
name|etoasc
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|asctoe24
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|asctoe53
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|asctoe64
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|asctoe113
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|asctoe
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|asctoeg
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|efloor
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void efrexp	PROTO((unsigned EMUSHORT *, int *, 			       unsigned EMUSHORT *));
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|eldexp
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|int
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void eremain	PROTO((unsigned EMUSHORT *, unsigned EMUSHORT *, 			       unsigned EMUSHORT *));
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|eiremain
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mtherr
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEC
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|dectoe
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|etodec
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|todec
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|IBM
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|ibmtoe
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|etoibm
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|toibm
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|C4X
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|c4xtoe
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|etoc4x
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|toc4x
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|make_nan
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|int
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void uditoe	PROTO((unsigned EMUSHORT *, unsigned EMUSHORT *)); static void ditoe	PROTO((unsigned EMUSHORT *, unsigned EMUSHORT *)); static void etoudi	PROTO((unsigned EMUSHORT *, unsigned EMUSHORT *)); static void etodi	PROTO((unsigned EMUSHORT *, unsigned EMUSHORT *)); static void esqrt	PROTO((unsigned EMUSHORT *, unsigned EMUSHORT *));
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Copy 32-bit numbers obtained from array containing 16-bit numbers,    swapping ends if required, into output array of longs.  The    result is normally passed to fprintf by the ASM_OUTPUT_ macros.   */
end_comment

begin_function
specifier|static
name|void
name|endian
parameter_list|(
name|e
parameter_list|,
name|x
parameter_list|,
name|mode
parameter_list|)
name|unsigned
name|EMUSHORT
name|e
index|[]
decl_stmt|;
name|long
name|x
index|[]
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|unsigned
name|long
name|th
decl_stmt|,
name|t
decl_stmt|;
if|if
condition|(
name|REAL_WORDS_BIG_ENDIAN
condition|)
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|TFmode
case|:
comment|/* Swap halfwords in the fourth long.  */
name|th
operator|=
operator|(
name|unsigned
name|long
operator|)
name|e
index|[
literal|6
index|]
operator|&
literal|0xffff
expr_stmt|;
name|t
operator|=
operator|(
name|unsigned
name|long
operator|)
name|e
index|[
literal|7
index|]
operator|&
literal|0xffff
expr_stmt|;
name|t
operator||=
name|th
operator|<<
literal|16
expr_stmt|;
name|x
index|[
literal|3
index|]
operator|=
operator|(
name|long
operator|)
name|t
expr_stmt|;
case|case
name|XFmode
case|:
comment|/* Swap halfwords in the third long.  */
name|th
operator|=
operator|(
name|unsigned
name|long
operator|)
name|e
index|[
literal|4
index|]
operator|&
literal|0xffff
expr_stmt|;
name|t
operator|=
operator|(
name|unsigned
name|long
operator|)
name|e
index|[
literal|5
index|]
operator|&
literal|0xffff
expr_stmt|;
name|t
operator||=
name|th
operator|<<
literal|16
expr_stmt|;
name|x
index|[
literal|2
index|]
operator|=
operator|(
name|long
operator|)
name|t
expr_stmt|;
comment|/* fall into the double case */
case|case
name|DFmode
case|:
comment|/* Swap halfwords in the second word.  */
name|th
operator|=
operator|(
name|unsigned
name|long
operator|)
name|e
index|[
literal|2
index|]
operator|&
literal|0xffff
expr_stmt|;
name|t
operator|=
operator|(
name|unsigned
name|long
operator|)
name|e
index|[
literal|3
index|]
operator|&
literal|0xffff
expr_stmt|;
name|t
operator||=
name|th
operator|<<
literal|16
expr_stmt|;
name|x
index|[
literal|1
index|]
operator|=
operator|(
name|long
operator|)
name|t
expr_stmt|;
comment|/* fall into the float case */
case|case
name|SFmode
case|:
case|case
name|HFmode
case|:
comment|/* Swap halfwords in the first word.  */
name|th
operator|=
operator|(
name|unsigned
name|long
operator|)
name|e
index|[
literal|0
index|]
operator|&
literal|0xffff
expr_stmt|;
name|t
operator|=
operator|(
name|unsigned
name|long
operator|)
name|e
index|[
literal|1
index|]
operator|&
literal|0xffff
expr_stmt|;
name|t
operator||=
name|th
operator|<<
literal|16
expr_stmt|;
name|x
index|[
literal|0
index|]
operator|=
operator|(
name|long
operator|)
name|t
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Pack the output array without swapping.  */
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|TFmode
case|:
comment|/* Pack the fourth long.  */
name|th
operator|=
operator|(
name|unsigned
name|long
operator|)
name|e
index|[
literal|7
index|]
operator|&
literal|0xffff
expr_stmt|;
name|t
operator|=
operator|(
name|unsigned
name|long
operator|)
name|e
index|[
literal|6
index|]
operator|&
literal|0xffff
expr_stmt|;
name|t
operator||=
name|th
operator|<<
literal|16
expr_stmt|;
name|x
index|[
literal|3
index|]
operator|=
operator|(
name|long
operator|)
name|t
expr_stmt|;
case|case
name|XFmode
case|:
comment|/* Pack the third long. 	     Each element of the input REAL_VALUE_TYPE array has 16 useful bits 	     in it.  */
name|th
operator|=
operator|(
name|unsigned
name|long
operator|)
name|e
index|[
literal|5
index|]
operator|&
literal|0xffff
expr_stmt|;
name|t
operator|=
operator|(
name|unsigned
name|long
operator|)
name|e
index|[
literal|4
index|]
operator|&
literal|0xffff
expr_stmt|;
name|t
operator||=
name|th
operator|<<
literal|16
expr_stmt|;
name|x
index|[
literal|2
index|]
operator|=
operator|(
name|long
operator|)
name|t
expr_stmt|;
comment|/* fall into the double case */
case|case
name|DFmode
case|:
comment|/* Pack the second long */
name|th
operator|=
operator|(
name|unsigned
name|long
operator|)
name|e
index|[
literal|3
index|]
operator|&
literal|0xffff
expr_stmt|;
name|t
operator|=
operator|(
name|unsigned
name|long
operator|)
name|e
index|[
literal|2
index|]
operator|&
literal|0xffff
expr_stmt|;
name|t
operator||=
name|th
operator|<<
literal|16
expr_stmt|;
name|x
index|[
literal|1
index|]
operator|=
operator|(
name|long
operator|)
name|t
expr_stmt|;
comment|/* fall into the float case */
case|case
name|SFmode
case|:
case|case
name|HFmode
case|:
comment|/* Pack the first long */
name|th
operator|=
operator|(
name|unsigned
name|long
operator|)
name|e
index|[
literal|1
index|]
operator|&
literal|0xffff
expr_stmt|;
name|t
operator|=
operator|(
name|unsigned
name|long
operator|)
name|e
index|[
literal|0
index|]
operator|&
literal|0xffff
expr_stmt|;
name|t
operator||=
name|th
operator|<<
literal|16
expr_stmt|;
name|x
index|[
literal|0
index|]
operator|=
operator|(
name|long
operator|)
name|t
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* This is the implementation of the REAL_ARITHMETIC macro.  */
end_comment

begin_function
name|void
name|earith
parameter_list|(
name|value
parameter_list|,
name|icode
parameter_list|,
name|r1
parameter_list|,
name|r2
parameter_list|)
name|REAL_VALUE_TYPE
modifier|*
name|value
decl_stmt|;
name|int
name|icode
decl_stmt|;
name|REAL_VALUE_TYPE
modifier|*
name|r1
decl_stmt|;
name|REAL_VALUE_TYPE
modifier|*
name|r2
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|d1
index|[
name|NE
index|]
decl_stmt|,
name|d2
index|[
name|NE
index|]
decl_stmt|,
name|v
index|[
name|NE
index|]
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
name|GET_REAL
argument_list|(
name|r1
argument_list|,
name|d1
argument_list|)
expr_stmt|;
name|GET_REAL
argument_list|(
name|r2
argument_list|,
name|d2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NANS
comment|/*  Return NaN input back to the caller.  */
if|if
condition|(
name|eisnan
argument_list|(
name|d1
argument_list|)
condition|)
block|{
name|PUT_REAL
argument_list|(
name|d1
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|eisnan
argument_list|(
name|d2
argument_list|)
condition|)
block|{
name|PUT_REAL
argument_list|(
name|d2
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|code
operator|=
operator|(
expr|enum
name|tree_code
operator|)
name|icode
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS_EXPR
case|:
name|eadd
argument_list|(
name|d2
argument_list|,
name|d1
argument_list|,
name|v
argument_list|)
expr_stmt|;
break|break;
case|case
name|MINUS_EXPR
case|:
name|esub
argument_list|(
name|d2
argument_list|,
name|d1
argument_list|,
name|v
argument_list|)
expr_stmt|;
comment|/* d1 - d2 */
break|break;
case|case
name|MULT_EXPR
case|:
name|emul
argument_list|(
name|d2
argument_list|,
name|d1
argument_list|,
name|v
argument_list|)
expr_stmt|;
break|break;
case|case
name|RDIV_EXPR
case|:
ifndef|#
directive|ifndef
name|REAL_INFINITY
if|if
condition|(
name|ecmp
argument_list|(
name|d2
argument_list|,
name|ezero
argument_list|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|NANS
name|enan
argument_list|(
name|v
argument_list|,
name|eisneg
argument_list|(
name|d1
argument_list|)
operator|^
name|eisneg
argument_list|(
name|d2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
else|#
directive|else
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
name|ediv
argument_list|(
name|d2
argument_list|,
name|d1
argument_list|,
name|v
argument_list|)
expr_stmt|;
comment|/* d1/d2 */
break|break;
case|case
name|MIN_EXPR
case|:
comment|/* min (d1,d2) */
if|if
condition|(
name|ecmp
argument_list|(
name|d1
argument_list|,
name|d2
argument_list|)
operator|<
literal|0
condition|)
name|emov
argument_list|(
name|d1
argument_list|,
name|v
argument_list|)
expr_stmt|;
else|else
name|emov
argument_list|(
name|d2
argument_list|,
name|v
argument_list|)
expr_stmt|;
break|break;
case|case
name|MAX_EXPR
case|:
comment|/* max (d1,d2) */
if|if
condition|(
name|ecmp
argument_list|(
name|d1
argument_list|,
name|d2
argument_list|)
operator|>
literal|0
condition|)
name|emov
argument_list|(
name|d1
argument_list|,
name|v
argument_list|)
expr_stmt|;
else|else
name|emov
argument_list|(
name|d2
argument_list|,
name|v
argument_list|)
expr_stmt|;
break|break;
default|default:
name|emov
argument_list|(
name|ezero
argument_list|,
name|v
argument_list|)
expr_stmt|;
break|break;
block|}
name|PUT_REAL
argument_list|(
name|v
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Truncate REAL_VALUE_TYPE toward zero to signed HOST_WIDE_INT.    implements REAL_VALUE_RNDZINT (x) (etrunci (x)).  */
end_comment

begin_function
name|REAL_VALUE_TYPE
name|etrunci
parameter_list|(
name|x
parameter_list|)
name|REAL_VALUE_TYPE
name|x
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|f
index|[
name|NE
index|]
decl_stmt|,
name|g
index|[
name|NE
index|]
decl_stmt|;
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|HOST_WIDE_INT
name|l
decl_stmt|;
name|GET_REAL
argument_list|(
operator|&
name|x
argument_list|,
name|g
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
name|eisnan
argument_list|(
name|g
argument_list|)
condition|)
return|return
operator|(
name|x
operator|)
return|;
endif|#
directive|endif
name|eifrac
argument_list|(
name|g
argument_list|,
operator|&
name|l
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|ltoe
argument_list|(
operator|&
name|l
argument_list|,
name|g
argument_list|)
expr_stmt|;
name|PUT_REAL
argument_list|(
name|g
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Truncate REAL_VALUE_TYPE toward zero to unsigned HOST_WIDE_INT;    implements REAL_VALUE_UNSIGNED_RNDZINT (x) (etruncui (x)).  */
end_comment

begin_function
name|REAL_VALUE_TYPE
name|etruncui
parameter_list|(
name|x
parameter_list|)
name|REAL_VALUE_TYPE
name|x
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|f
index|[
name|NE
index|]
decl_stmt|,
name|g
index|[
name|NE
index|]
decl_stmt|;
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|l
decl_stmt|;
name|GET_REAL
argument_list|(
operator|&
name|x
argument_list|,
name|g
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
name|eisnan
argument_list|(
name|g
argument_list|)
condition|)
return|return
operator|(
name|x
operator|)
return|;
endif|#
directive|endif
name|euifrac
argument_list|(
name|g
argument_list|,
operator|&
name|l
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|ultoe
argument_list|(
operator|&
name|l
argument_list|,
name|g
argument_list|)
expr_stmt|;
name|PUT_REAL
argument_list|(
name|g
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_comment
comment|/* This is the REAL_VALUE_ATOF function.  It converts a decimal or hexadecimal    string to binary, rounding off as indicated by the machine_mode argument.    Then it promotes the rounded value to REAL_VALUE_TYPE.  */
end_comment

begin_function
name|REAL_VALUE_TYPE
name|ereal_atof
parameter_list|(
name|s
parameter_list|,
name|t
parameter_list|)
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|enum
name|machine_mode
name|t
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|tem
index|[
name|NE
index|]
decl_stmt|,
name|e
index|[
name|NE
index|]
decl_stmt|;
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
switch|switch
condition|(
name|t
condition|)
block|{
ifdef|#
directive|ifdef
name|C4X
case|case
name|QFmode
case|:
case|case
name|HFmode
case|:
name|asctoe53
argument_list|(
name|s
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|e53toe
argument_list|(
name|tem
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
else|#
directive|else
case|case
name|HFmode
case|:
endif|#
directive|endif
case|case
name|SFmode
case|:
name|asctoe24
argument_list|(
name|s
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|e24toe
argument_list|(
name|tem
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|DFmode
case|:
name|asctoe53
argument_list|(
name|s
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|e53toe
argument_list|(
name|tem
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|XFmode
case|:
name|asctoe64
argument_list|(
name|s
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|e64toe
argument_list|(
name|tem
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|TFmode
case|:
name|asctoe113
argument_list|(
name|s
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|e113toe
argument_list|(
name|tem
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
default|default:
name|asctoe
argument_list|(
name|s
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|PUT_REAL
argument_list|(
name|e
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Expansion of REAL_NEGATE.  */
end_comment

begin_function
name|REAL_VALUE_TYPE
name|ereal_negate
parameter_list|(
name|x
parameter_list|)
name|REAL_VALUE_TYPE
name|x
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|e
index|[
name|NE
index|]
decl_stmt|;
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|GET_REAL
argument_list|(
operator|&
name|x
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|eneg
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|PUT_REAL
argument_list|(
name|e
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Round real toward zero to HOST_WIDE_INT;    implements REAL_VALUE_FIX (x).  */
end_comment

begin_function
name|HOST_WIDE_INT
name|efixi
parameter_list|(
name|x
parameter_list|)
name|REAL_VALUE_TYPE
name|x
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|f
index|[
name|NE
index|]
decl_stmt|,
name|g
index|[
name|NE
index|]
decl_stmt|;
name|HOST_WIDE_INT
name|l
decl_stmt|;
name|GET_REAL
argument_list|(
operator|&
name|x
argument_list|,
name|f
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
name|eisnan
argument_list|(
name|f
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"conversion from NaN to int"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
name|eifrac
argument_list|(
name|f
argument_list|,
operator|&
name|l
argument_list|,
name|g
argument_list|)
expr_stmt|;
return|return
name|l
return|;
block|}
end_function

begin_comment
comment|/* Round real toward zero to unsigned HOST_WIDE_INT    implements  REAL_VALUE_UNSIGNED_FIX (x).    Negative input returns zero.  */
end_comment

begin_function
name|unsigned
name|HOST_WIDE_INT
name|efixui
parameter_list|(
name|x
parameter_list|)
name|REAL_VALUE_TYPE
name|x
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|f
index|[
name|NE
index|]
decl_stmt|,
name|g
index|[
name|NE
index|]
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|l
decl_stmt|;
name|GET_REAL
argument_list|(
operator|&
name|x
argument_list|,
name|f
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
name|eisnan
argument_list|(
name|f
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"conversion from NaN to unsigned int"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
name|euifrac
argument_list|(
name|f
argument_list|,
operator|&
name|l
argument_list|,
name|g
argument_list|)
expr_stmt|;
return|return
name|l
return|;
block|}
end_function

begin_comment
comment|/* REAL_VALUE_FROM_INT macro.  */
end_comment

begin_function
name|void
name|ereal_from_int
parameter_list|(
name|d
parameter_list|,
name|i
parameter_list|,
name|j
parameter_list|,
name|mode
parameter_list|)
name|REAL_VALUE_TYPE
modifier|*
name|d
decl_stmt|;
name|HOST_WIDE_INT
name|i
decl_stmt|,
name|j
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|df
index|[
name|NE
index|]
decl_stmt|,
name|dg
index|[
name|NE
index|]
decl_stmt|;
name|HOST_WIDE_INT
name|low
decl_stmt|,
name|high
decl_stmt|;
name|int
name|sign
decl_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_FLOAT
condition|)
name|abort
argument_list|()
expr_stmt|;
name|sign
operator|=
literal|0
expr_stmt|;
name|low
operator|=
name|i
expr_stmt|;
if|if
condition|(
operator|(
name|high
operator|=
name|j
operator|)
operator|<
literal|0
condition|)
block|{
name|sign
operator|=
literal|1
expr_stmt|;
comment|/* complement and add 1 */
name|high
operator|=
operator|~
name|high
expr_stmt|;
if|if
condition|(
name|low
condition|)
name|low
operator|=
operator|-
name|low
expr_stmt|;
else|else
name|high
operator|+=
literal|1
expr_stmt|;
block|}
name|eldexp
argument_list|(
name|eone
argument_list|,
name|HOST_BITS_PER_WIDE_INT
argument_list|,
name|df
argument_list|)
expr_stmt|;
name|ultoe
argument_list|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|*
operator|)
operator|&
name|high
argument_list|,
name|dg
argument_list|)
expr_stmt|;
name|emul
argument_list|(
name|dg
argument_list|,
name|df
argument_list|,
name|dg
argument_list|)
expr_stmt|;
name|ultoe
argument_list|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|*
operator|)
operator|&
name|low
argument_list|,
name|df
argument_list|)
expr_stmt|;
name|eadd
argument_list|(
name|df
argument_list|,
name|dg
argument_list|,
name|dg
argument_list|)
expr_stmt|;
if|if
condition|(
name|sign
condition|)
name|eneg
argument_list|(
name|dg
argument_list|)
expr_stmt|;
comment|/* A REAL_VALUE_TYPE may not be wide enough to hold the two HOST_WIDE_INTS.      Avoid double-rounding errors later by rounding off now from the      extra-wide internal format to the requested precision.  */
switch|switch
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
condition|)
block|{
case|case
literal|32
case|:
name|etoe24
argument_list|(
name|dg
argument_list|,
name|df
argument_list|)
expr_stmt|;
name|e24toe
argument_list|(
name|df
argument_list|,
name|dg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|64
case|:
name|etoe53
argument_list|(
name|dg
argument_list|,
name|df
argument_list|)
expr_stmt|;
name|e53toe
argument_list|(
name|df
argument_list|,
name|dg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|96
case|:
name|etoe64
argument_list|(
name|dg
argument_list|,
name|df
argument_list|)
expr_stmt|;
name|e64toe
argument_list|(
name|df
argument_list|,
name|dg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|128
case|:
name|etoe113
argument_list|(
name|dg
argument_list|,
name|df
argument_list|)
expr_stmt|;
name|e113toe
argument_list|(
name|df
argument_list|,
name|dg
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|PUT_REAL
argument_list|(
name|dg
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* REAL_VALUE_FROM_UNSIGNED_INT macro.   */
end_comment

begin_function
name|void
name|ereal_from_uint
parameter_list|(
name|d
parameter_list|,
name|i
parameter_list|,
name|j
parameter_list|,
name|mode
parameter_list|)
name|REAL_VALUE_TYPE
modifier|*
name|d
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|i
decl_stmt|,
name|j
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|df
index|[
name|NE
index|]
decl_stmt|,
name|dg
index|[
name|NE
index|]
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|low
decl_stmt|,
name|high
decl_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_FLOAT
condition|)
name|abort
argument_list|()
expr_stmt|;
name|low
operator|=
name|i
expr_stmt|;
name|high
operator|=
name|j
expr_stmt|;
name|eldexp
argument_list|(
name|eone
argument_list|,
name|HOST_BITS_PER_WIDE_INT
argument_list|,
name|df
argument_list|)
expr_stmt|;
name|ultoe
argument_list|(
operator|&
name|high
argument_list|,
name|dg
argument_list|)
expr_stmt|;
name|emul
argument_list|(
name|dg
argument_list|,
name|df
argument_list|,
name|dg
argument_list|)
expr_stmt|;
name|ultoe
argument_list|(
operator|&
name|low
argument_list|,
name|df
argument_list|)
expr_stmt|;
name|eadd
argument_list|(
name|df
argument_list|,
name|dg
argument_list|,
name|dg
argument_list|)
expr_stmt|;
comment|/* A REAL_VALUE_TYPE may not be wide enough to hold the two HOST_WIDE_INTS.      Avoid double-rounding errors later by rounding off now from the      extra-wide internal format to the requested precision.  */
switch|switch
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
condition|)
block|{
case|case
literal|32
case|:
name|etoe24
argument_list|(
name|dg
argument_list|,
name|df
argument_list|)
expr_stmt|;
name|e24toe
argument_list|(
name|df
argument_list|,
name|dg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|64
case|:
name|etoe53
argument_list|(
name|dg
argument_list|,
name|df
argument_list|)
expr_stmt|;
name|e53toe
argument_list|(
name|df
argument_list|,
name|dg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|96
case|:
name|etoe64
argument_list|(
name|dg
argument_list|,
name|df
argument_list|)
expr_stmt|;
name|e64toe
argument_list|(
name|df
argument_list|,
name|dg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|128
case|:
name|etoe113
argument_list|(
name|dg
argument_list|,
name|df
argument_list|)
expr_stmt|;
name|e113toe
argument_list|(
name|df
argument_list|,
name|dg
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|PUT_REAL
argument_list|(
name|dg
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* REAL_VALUE_TO_INT macro.  */
end_comment

begin_function
name|void
name|ereal_to_int
parameter_list|(
name|low
parameter_list|,
name|high
parameter_list|,
name|rr
parameter_list|)
name|HOST_WIDE_INT
modifier|*
name|low
decl_stmt|,
decl|*
name|high
decl_stmt|;
end_function

begin_decl_stmt
name|REAL_VALUE_TYPE
name|rr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unsigned
name|EMUSHORT
name|d
index|[
name|NE
index|]
decl_stmt|,
name|df
index|[
name|NE
index|]
decl_stmt|,
name|dg
index|[
name|NE
index|]
decl_stmt|,
name|dh
index|[
name|NE
index|]
decl_stmt|;
name|int
name|s
decl_stmt|;
name|GET_REAL
argument_list|(
operator|&
name|rr
argument_list|,
name|d
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
name|eisnan
argument_list|(
name|d
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"conversion from NaN to int"
argument_list|)
expr_stmt|;
operator|*
name|low
operator|=
operator|-
literal|1
expr_stmt|;
operator|*
name|high
operator|=
operator|-
literal|1
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* convert positive value */
name|s
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|eisneg
argument_list|(
name|d
argument_list|)
condition|)
block|{
name|eneg
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|s
operator|=
literal|1
expr_stmt|;
block|}
name|eldexp
argument_list|(
name|eone
argument_list|,
name|HOST_BITS_PER_WIDE_INT
argument_list|,
name|df
argument_list|)
expr_stmt|;
name|ediv
argument_list|(
name|df
argument_list|,
name|d
argument_list|,
name|dg
argument_list|)
expr_stmt|;
comment|/* dg = d / 2^32 is the high word */
name|euifrac
argument_list|(
name|dg
argument_list|,
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|*
operator|)
name|high
argument_list|,
name|dh
argument_list|)
expr_stmt|;
name|emul
argument_list|(
name|df
argument_list|,
name|dh
argument_list|,
name|dg
argument_list|)
expr_stmt|;
comment|/* fractional part is the low word */
name|euifrac
argument_list|(
name|dg
argument_list|,
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|*
operator|)
name|low
argument_list|,
name|dh
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
comment|/* complement and add 1 */
operator|*
name|high
operator|=
operator|~
operator|(
operator|*
name|high
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|low
condition|)
operator|*
name|low
operator|=
operator|-
operator|(
operator|*
name|low
operator|)
expr_stmt|;
else|else
operator|*
name|high
operator|+=
literal|1
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* REAL_VALUE_LDEXP macro.  */
end_comment

begin_function
name|REAL_VALUE_TYPE
name|ereal_ldexp
parameter_list|(
name|x
parameter_list|,
name|n
parameter_list|)
name|REAL_VALUE_TYPE
name|x
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|e
index|[
name|NE
index|]
decl_stmt|,
name|y
index|[
name|NE
index|]
decl_stmt|;
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|GET_REAL
argument_list|(
operator|&
name|x
argument_list|,
name|e
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
name|eisnan
argument_list|(
name|e
argument_list|)
condition|)
return|return
operator|(
name|x
operator|)
return|;
endif|#
directive|endif
name|eldexp
argument_list|(
name|e
argument_list|,
name|n
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|PUT_REAL
argument_list|(
name|y
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_comment
comment|/* These routines are conditionally compiled because functions    of the same names may be defined in fold-const.c.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|REAL_ARITHMETIC
end_ifdef

begin_comment
comment|/* Check for infinity in a REAL_VALUE_TYPE.  */
end_comment

begin_function
name|int
name|target_isinf
parameter_list|(
name|x
parameter_list|)
name|REAL_VALUE_TYPE
name|x
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|e
index|[
name|NE
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|INFINITY
name|GET_REAL
argument_list|(
operator|&
name|x
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
operator|(
name|eisinf
argument_list|(
name|e
argument_list|)
operator|)
return|;
else|#
directive|else
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Check whether a REAL_VALUE_TYPE item is a NaN.  */
end_comment

begin_function
name|int
name|target_isnan
parameter_list|(
name|x
parameter_list|)
name|REAL_VALUE_TYPE
name|x
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|e
index|[
name|NE
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|NANS
name|GET_REAL
argument_list|(
operator|&
name|x
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
operator|(
name|eisnan
argument_list|(
name|e
argument_list|)
operator|)
return|;
else|#
directive|else
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Check for a negative REAL_VALUE_TYPE number.    This just checks the sign bit, so that -0 counts as negative.  */
end_comment

begin_function
name|int
name|target_negative
parameter_list|(
name|x
parameter_list|)
name|REAL_VALUE_TYPE
name|x
decl_stmt|;
block|{
return|return
name|ereal_isneg
argument_list|(
name|x
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Expansion of REAL_VALUE_TRUNCATE.    The result is in floating point, rounded to nearest or even.  */
end_comment

begin_function
name|REAL_VALUE_TYPE
name|real_value_truncate
parameter_list|(
name|mode
parameter_list|,
name|arg
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|REAL_VALUE_TYPE
name|arg
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|e
index|[
name|NE
index|]
decl_stmt|,
name|t
index|[
name|NE
index|]
decl_stmt|;
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|GET_REAL
argument_list|(
operator|&
name|arg
argument_list|,
name|e
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
name|eisnan
argument_list|(
name|e
argument_list|)
condition|)
return|return
operator|(
name|arg
operator|)
return|;
endif|#
directive|endif
name|eclear
argument_list|(
name|t
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|TFmode
case|:
name|etoe113
argument_list|(
name|e
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|e113toe
argument_list|(
name|t
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|XFmode
case|:
name|etoe64
argument_list|(
name|e
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|e64toe
argument_list|(
name|t
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|DFmode
case|:
name|etoe53
argument_list|(
name|e
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|e53toe
argument_list|(
name|t
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|SFmode
case|:
ifndef|#
directive|ifndef
name|C4X
case|case
name|HFmode
case|:
endif|#
directive|endif
name|etoe24
argument_list|(
name|e
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|e24toe
argument_list|(
name|t
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|C4X
case|case
name|HFmode
case|:
case|case
name|QFmode
case|:
name|etoe53
argument_list|(
name|e
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|e53toe
argument_list|(
name|t
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|SImode
case|:
name|r
operator|=
name|etrunci
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
comment|/* If an unsupported type was requested, presume that        the machine files know something useful to do with        the unmodified value.  */
default|default:
return|return
operator|(
name|arg
operator|)
return|;
block|}
name|PUT_REAL
argument_list|(
name|t
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Try to change R into its exact multiplicative inverse in machine mode    MODE.  Return nonzero function value if successful.  */
end_comment

begin_function
name|int
name|exact_real_inverse
parameter_list|(
name|mode
parameter_list|,
name|r
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|REAL_VALUE_TYPE
modifier|*
name|r
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|e
index|[
name|NE
index|]
decl_stmt|,
name|einv
index|[
name|NE
index|]
decl_stmt|;
name|REAL_VALUE_TYPE
name|rinv
decl_stmt|;
name|int
name|i
decl_stmt|;
name|GET_REAL
argument_list|(
name|r
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|/* Test for input in range.  Don't transform IEEE special values.  */
if|if
condition|(
name|eisinf
argument_list|(
name|e
argument_list|)
operator|||
name|eisnan
argument_list|(
name|e
argument_list|)
operator|||
operator|(
name|ecmp
argument_list|(
name|e
argument_list|,
name|ezero
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Test for a power of 2: all significand bits zero except the MSB.      We are assuming the target has binary (or hex) arithmetic.  */
if|if
condition|(
name|e
index|[
name|NE
operator|-
literal|2
index|]
operator|!=
literal|0x8000
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NE
operator|-
literal|2
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|e
index|[
name|i
index|]
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
block|}
comment|/* Compute the inverse and truncate it to the required mode.  */
name|ediv
argument_list|(
name|e
argument_list|,
name|eone
argument_list|,
name|einv
argument_list|)
expr_stmt|;
name|PUT_REAL
argument_list|(
name|einv
argument_list|,
operator|&
name|rinv
argument_list|)
expr_stmt|;
name|rinv
operator|=
name|real_value_truncate
argument_list|(
name|mode
argument_list|,
name|rinv
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CHECK_FLOAT_VALUE
comment|/* This check is not redundant.  It may, for example, flush      a supposedly IEEE denormal value to zero.  */
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|CHECK_FLOAT_VALUE
argument_list|(
name|mode
argument_list|,
name|rinv
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
name|GET_REAL
argument_list|(
operator|&
name|rinv
argument_list|,
name|einv
argument_list|)
expr_stmt|;
comment|/* Check the bits again, because the truncation might have      generated an arbitrary saturation value on overflow.  */
if|if
condition|(
name|einv
index|[
name|NE
operator|-
literal|2
index|]
operator|!=
literal|0x8000
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NE
operator|-
literal|2
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|einv
index|[
name|i
index|]
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
block|}
comment|/* Fail if the computed inverse is out of range.  */
if|if
condition|(
name|eisinf
argument_list|(
name|einv
argument_list|)
operator|||
name|eisnan
argument_list|(
name|einv
argument_list|)
operator|||
operator|(
name|ecmp
argument_list|(
name|einv
argument_list|,
name|ezero
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Output the reciprocal and return success flag.  */
name|PUT_REAL
argument_list|(
name|einv
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REAL_ARITHMETIC defined */
end_comment

begin_comment
comment|/* Used for debugging--print the value of R in human-readable format    on stderr.  */
end_comment

begin_function
name|void
name|debug_real
parameter_list|(
name|r
parameter_list|)
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
block|{
name|char
name|dstr
index|[
literal|30
index|]
decl_stmt|;
name|REAL_VALUE_TO_DECIMAL
argument_list|(
name|r
argument_list|,
literal|"%.20g"
argument_list|,
name|dstr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|dstr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The following routines convert REAL_VALUE_TYPE to the various floating    point formats that are meaningful to supported computers.     The results are returned in 32-bit pieces, each piece stored in a `long'.    This is so they can be printed by statements like        fprintf (file, "%lx, %lx", L[0],  L[1]);     that will work on both narrow- and wide-word host computers.  */
end_comment

begin_comment
comment|/* Convert R to a 128-bit long double precision value.  The output array L    contains four 32-bit pieces of the result, in the order they would appear    in memory.  */
end_comment

begin_function
name|void
name|etartdouble
parameter_list|(
name|r
parameter_list|,
name|l
parameter_list|)
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|long
name|l
index|[]
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|e
index|[
name|NE
index|]
decl_stmt|;
name|GET_REAL
argument_list|(
operator|&
name|r
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|etoe113
argument_list|(
name|e
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|endian
argument_list|(
name|e
argument_list|,
name|l
argument_list|,
name|TFmode
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert R to a double extended precision value.  The output array L    contains three 32-bit pieces of the result, in the order they would    appear in memory.  */
end_comment

begin_function
name|void
name|etarldouble
parameter_list|(
name|r
parameter_list|,
name|l
parameter_list|)
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|long
name|l
index|[]
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|e
index|[
name|NE
index|]
decl_stmt|;
name|GET_REAL
argument_list|(
operator|&
name|r
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|etoe64
argument_list|(
name|e
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|endian
argument_list|(
name|e
argument_list|,
name|l
argument_list|,
name|XFmode
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert R to a double precision value.  The output array L contains two    32-bit pieces of the result, in the order they would appear in memory.  */
end_comment

begin_function
name|void
name|etardouble
parameter_list|(
name|r
parameter_list|,
name|l
parameter_list|)
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|long
name|l
index|[]
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|e
index|[
name|NE
index|]
decl_stmt|;
name|GET_REAL
argument_list|(
operator|&
name|r
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|etoe53
argument_list|(
name|e
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|endian
argument_list|(
name|e
argument_list|,
name|l
argument_list|,
name|DFmode
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert R to a single precision float value stored in the least-significant    bits of a `long'.  */
end_comment

begin_function
name|long
name|etarsingle
parameter_list|(
name|r
parameter_list|)
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|e
index|[
name|NE
index|]
decl_stmt|;
name|long
name|l
decl_stmt|;
name|GET_REAL
argument_list|(
operator|&
name|r
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|etoe24
argument_list|(
name|e
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|endian
argument_list|(
name|e
argument_list|,
operator|&
name|l
argument_list|,
name|SFmode
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|long
operator|)
name|l
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Convert X to a decimal ASCII string S for output to an assembly    language file.  Note, there is no standard way to spell infinity or    a NaN, so these values may require special treatment in the tm.h    macros.  */
end_comment

begin_function
name|void
name|ereal_to_decimal
parameter_list|(
name|x
parameter_list|,
name|s
parameter_list|)
name|REAL_VALUE_TYPE
name|x
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|e
index|[
name|NE
index|]
decl_stmt|;
name|GET_REAL
argument_list|(
operator|&
name|x
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|etoasc
argument_list|(
name|e
argument_list|,
name|s
argument_list|,
literal|20
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compare X and Y.  Return 1 if X> Y, 0 if X == Y, -1 if X< Y,    or -2 if either is a NaN.   */
end_comment

begin_function
name|int
name|ereal_cmp
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|REAL_VALUE_TYPE
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|ex
index|[
name|NE
index|]
decl_stmt|,
name|ey
index|[
name|NE
index|]
decl_stmt|;
name|GET_REAL
argument_list|(
operator|&
name|x
argument_list|,
name|ex
argument_list|)
expr_stmt|;
name|GET_REAL
argument_list|(
operator|&
name|y
argument_list|,
name|ey
argument_list|)
expr_stmt|;
return|return
operator|(
name|ecmp
argument_list|(
name|ex
argument_list|,
name|ey
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  Return 1 if the sign bit of X is set, else return 0.  */
end_comment

begin_function
name|int
name|ereal_isneg
parameter_list|(
name|x
parameter_list|)
name|REAL_VALUE_TYPE
name|x
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|ex
index|[
name|NE
index|]
decl_stmt|;
name|GET_REAL
argument_list|(
operator|&
name|x
argument_list|,
name|ex
argument_list|)
expr_stmt|;
return|return
operator|(
name|eisneg
argument_list|(
name|ex
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* End of REAL_ARITHMETIC interface */
end_comment

begin_escape
end_escape

begin_comment
comment|/*   Extended precision IEEE binary floating point arithmetic routines    Numbers are stored in C language as arrays of 16-bit unsigned   short integers.  The arguments of the routines are pointers to   the arrays.    External e type data structure, similar to Intel 8087 chip   temporary real format but possibly with a larger significand:  	NE-1 significand words	(least significant word first, 				 most significant bit is normally set) 	exponent		(value = EXONE for 1.0, 				top bit is the sign)     Internal exploded e-type data structure of a number (a "word" is 16 bits):    ei[0]	sign word	(0 for positive, 0xffff for negative)   ei[1]	biased exponent	(value = EXONE for the number 1.0)   ei[2]	high guard word	(always zero after normalization)   ei[3]   to ei[NI-2]	significand	(NI-4 significand words,  				 most significant word first,  				 most significant bit is set)   ei[NI-1]	low guard word	(0x8000 bit is rounding place)     		Routines for external format e-type numbers   	asctoe (string, e)	ASCII string to extended double e type  	asctoe64 (string,&d)	ASCII string to long double  	asctoe53 (string,&d)	ASCII string to double  	asctoe24 (string,&f)	ASCII string to single  	asctoeg (string, e, prec) ASCII string to specified precision  	e24toe (&f, e)		IEEE single precision to e type  	e53toe (&d, e)		IEEE double precision to e type  	e64toe (&d, e)		IEEE long double precision to e type  	e113toe (&d, e)		128-bit long double precision to e type #if 0  	eabs (e)			absolute value #endif  	eadd (a, b, c)		c = b + a  	eclear (e)		e = 0  	ecmp (a, b)		Returns 1 if a> b, 0 if a == b,  				-1 if a< b, -2 if either a or b is a NaN.  	ediv (a, b, c)		c = b / a  	efloor (a, b)		truncate to integer, toward -infinity  	efrexp (a, exp, s)	extract exponent and significand  	eifrac (e,&l, frac)    e to HOST_WIDE_INT and e type fraction  	euifrac (e,&l, frac)   e to unsigned HOST_WIDE_INT and e type fraction  	einfin (e)		set e to infinity, leaving its sign alone  	eldexp (a, n, b)	multiply by 2**n  	emov (a, b)		b = a  	emul (a, b, c)		c = b * a  	eneg (e)			e = -e #if 0  	eround (a, b)		b = nearest integer value to a #endif  	esub (a, b, c)		c = b - a #if 0  	e24toasc (&f, str, n)	single to ASCII string, n digits after decimal  	e53toasc (&d, str, n)	double to ASCII string, n digits after decimal  	e64toasc (&d, str, n)	80-bit long double to ASCII string  	e113toasc (&d, str, n)	128-bit long double to ASCII string #endif  	etoasc (e, str, n)	e to ASCII string, n digits after decimal  	etoe24 (e,&f)		convert e type to IEEE single precision  	etoe53 (e,&d)		convert e type to IEEE double precision  	etoe64 (e,&d)		convert e type to IEEE long double precision  	ltoe (&l, e)		HOST_WIDE_INT to e type  	ultoe (&l, e)		unsigned HOST_WIDE_INT to e type 	eisneg (e)              1 if sign bit of e != 0, else 0 	eisinf (e)              1 if e has maximum exponent (non-IEEE)  				or is infinite (IEEE)         eisnan (e)              1 if e is a NaN    		Routines for internal format exploded e-type numbers   	eaddm (ai, bi)		add significands, bi = bi + ai  	ecleaz (ei)		ei = 0  	ecleazs (ei)		set ei = 0 but leave its sign alone  	ecmpm (ai, bi)		compare significands, return 1, 0, or -1  	edivm (ai, bi)		divide  significands, bi = bi / ai  	emdnorm (ai,l,s,exp)	normalize and round off  	emovi (a, ai)		convert external a to internal ai  	emovo (ai, a)		convert internal ai to external a  	emovz (ai, bi)		bi = ai, low guard word of bi = 0  	emulm (ai, bi)		multiply significands, bi = bi * ai  	enormlz (ei)		left-justify the significand  	eshdn1 (ai)		shift significand and guards down 1 bit  	eshdn8 (ai)		shift down 8 bits  	eshdn6 (ai)		shift down 16 bits  	eshift (ai, n)		shift ai n bits up (or down if n< 0)  	eshup1 (ai)		shift significand and guards up 1 bit  	eshup8 (ai)		shift up 8 bits  	eshup6 (ai)		shift up 16 bits  	esubm (ai, bi)		subtract significands, bi = bi - ai         eiisinf (ai)            1 if infinite         eiisnan (ai)            1 if a NaN  	eiisneg (ai)		1 if sign bit of ai != 0, else 0         einan (ai)              set ai = NaN #if 0         eiinfin (ai)            set ai = infinity #endif    The result is always normalized and rounded to NI-4 word precision   after each arithmetic operation.    Exception flags are NOT fully supported.    Signaling NaN's are NOT supported; they are treated the same   as quiet NaN's.    Define INFINITY for support of infinity; otherwise a   saturation arithmetic is implemented.    Define NANS for support of Not-a-Number items; otherwise the   arithmetic will never produce a NaN output, and might be confused   by a NaN input.   If NaN's are supported, the output of `ecmp (a,b)' is -2 if   either a or b is a NaN. This means asking `if (ecmp (a,b)< 0)'   may not be legitimate. Use `if (ecmp (a,b) == -1)' for `less than'   if in doubt.    Denormals are always supported here where appropriate (e.g., not   for conversion to DEC numbers).  */
end_comment

begin_comment
comment|/* Definitions for error codes that are passed to the common error handling    routine mtherr.     For Digital Equipment PDP-11 and VAX computers, certain   IBM systems, and others that use numbers with a 56-bit   significand, the symbol DEC should be defined.  In this   mode, most floating point constants are given as arrays   of octal integers to eliminate decimal to binary conversion   errors that might be introduced by the compiler.    For computers, such as IBM PC, that follow the IEEE   Standard for Binary Floating Point Arithmetic (ANSI/IEEE   Std 754-1985), the symbol IEEE should be defined.   These numbers have 53-bit significands.  In this mode, constants   are provided as arrays of hexadecimal 16 bit integers.   The endian-ness of generated values is controlled by   REAL_WORDS_BIG_ENDIAN.    To accommodate other types of computer arithmetic, all   constants are also provided in a normal decimal radix   which one can hope are correctly converted to a suitable   format by the available C language compiler.  To invoke   this mode, the symbol UNK is defined.    An important difference among these modes is a predefined   set of machine arithmetic constants for each.  The numbers   MACHEP (the machine roundoff error), MAXNUM (largest number   represented), and several other parameters are preset by   the configuration symbol.  Check the file const.c to   ensure that these values are correct for your computer.    For ANSI C compatibility, define ANSIC equal to 1.  Currently   this affects only the atan2 function and others that use it.  */
end_comment

begin_comment
comment|/* Constant definitions for math error conditions.  */
end_comment

begin_define
define|#
directive|define
name|DOMAIN
value|1
end_define

begin_comment
comment|/* argument domain error */
end_comment

begin_define
define|#
directive|define
name|SING
value|2
end_define

begin_comment
comment|/* argument singularity */
end_comment

begin_define
define|#
directive|define
name|OVERFLOW
value|3
end_define

begin_comment
comment|/* overflow range error */
end_comment

begin_define
define|#
directive|define
name|UNDERFLOW
value|4
end_define

begin_comment
comment|/* underflow range error */
end_comment

begin_define
define|#
directive|define
name|TLOSS
value|5
end_define

begin_comment
comment|/* total loss of precision */
end_comment

begin_define
define|#
directive|define
name|PLOSS
value|6
end_define

begin_comment
comment|/* partial loss of precision */
end_comment

begin_define
define|#
directive|define
name|INVALID
value|7
end_define

begin_comment
comment|/* NaN-producing operation */
end_comment

begin_comment
comment|/*  e type constants used by high precision check routines */
end_comment

begin_if
if|#
directive|if
name|LONG_DOUBLE_TYPE_SIZE
operator|==
literal|128
end_if

begin_comment
comment|/* 0.0 */
end_comment

begin_decl_stmt
name|unsigned
name|EMUSHORT
name|ezero
index|[
name|NE
index|]
init|=
block|{
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|EMUSHORT
name|ezero
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 5.0E-1 */
end_comment

begin_decl_stmt
name|unsigned
name|EMUSHORT
name|ehalf
index|[
name|NE
index|]
init|=
block|{
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x8000
block|,
literal|0x3ffe
block|,}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|EMUSHORT
name|ehalf
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1.0E0 */
end_comment

begin_decl_stmt
name|unsigned
name|EMUSHORT
name|eone
index|[
name|NE
index|]
init|=
block|{
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x8000
block|,
literal|0x3fff
block|,}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|EMUSHORT
name|eone
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 2.0E0 */
end_comment

begin_decl_stmt
name|unsigned
name|EMUSHORT
name|etwo
index|[
name|NE
index|]
init|=
block|{
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x8000
block|,
literal|0x4000
block|,}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|EMUSHORT
name|etwo
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 3.2E1 */
end_comment

begin_decl_stmt
name|unsigned
name|EMUSHORT
name|e32
index|[
name|NE
index|]
init|=
block|{
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x8000
block|,
literal|0x4004
block|,}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|EMUSHORT
name|e32
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 6.93147180559945309417232121458176568075500134360255E-1 */
end_comment

begin_decl_stmt
name|unsigned
name|EMUSHORT
name|elog2
index|[
name|NE
index|]
init|=
block|{
literal|0x40f3
block|,
literal|0xf6af
block|,
literal|0x03f2
block|,
literal|0xb398
block|,
literal|0xc9e3
block|,
literal|0x79ab
block|,
literal|0150717
block|,
literal|0013767
block|,
literal|0130562
block|,
literal|0x3ffe
block|,}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|EMUSHORT
name|elog2
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1.41421356237309504880168872420969807856967187537695E0 */
end_comment

begin_decl_stmt
name|unsigned
name|EMUSHORT
name|esqrt2
index|[
name|NE
index|]
init|=
block|{
literal|0x1d6f
block|,
literal|0xbe9f
block|,
literal|0x754a
block|,
literal|0x89b3
block|,
literal|0x597d
block|,
literal|0x6484
block|,
literal|0174736
block|,
literal|0171463
block|,
literal|0132404
block|,
literal|0x3fff
block|,}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|EMUSHORT
name|esqrt2
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 3.14159265358979323846264338327950288419716939937511E0 */
end_comment

begin_decl_stmt
name|unsigned
name|EMUSHORT
name|epi
index|[
name|NE
index|]
init|=
block|{
literal|0x2902
block|,
literal|0x1cd1
block|,
literal|0x80dc
block|,
literal|0x628b
block|,
literal|0xc4c6
block|,
literal|0xc234
block|,
literal|0020550
block|,
literal|0155242
block|,
literal|0144417
block|,
literal|0040000
block|,}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|EMUSHORT
name|epi
index|[]
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* LONG_DOUBLE_TYPE_SIZE is other than 128 */
end_comment

begin_decl_stmt
name|unsigned
name|EMUSHORT
name|ezero
index|[
name|NE
index|]
init|=
block|{
literal|0
block|,
literal|0000000
block|,
literal|0000000
block|,
literal|0000000
block|,
literal|0000000
block|,
literal|0000000
block|,}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|EMUSHORT
name|ehalf
index|[
name|NE
index|]
init|=
block|{
literal|0
block|,
literal|0000000
block|,
literal|0000000
block|,
literal|0000000
block|,
literal|0100000
block|,
literal|0x3ffe
block|,}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|EMUSHORT
name|eone
index|[
name|NE
index|]
init|=
block|{
literal|0
block|,
literal|0000000
block|,
literal|0000000
block|,
literal|0000000
block|,
literal|0100000
block|,
literal|0x3fff
block|,}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|EMUSHORT
name|etwo
index|[
name|NE
index|]
init|=
block|{
literal|0
block|,
literal|0000000
block|,
literal|0000000
block|,
literal|0000000
block|,
literal|0100000
block|,
literal|0040000
block|,}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|EMUSHORT
name|e32
index|[
name|NE
index|]
init|=
block|{
literal|0
block|,
literal|0000000
block|,
literal|0000000
block|,
literal|0000000
block|,
literal|0100000
block|,
literal|0040004
block|,}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|EMUSHORT
name|elog2
index|[
name|NE
index|]
init|=
block|{
literal|0xc9e4
block|,
literal|0x79ab
block|,
literal|0150717
block|,
literal|0013767
block|,
literal|0130562
block|,
literal|0x3ffe
block|,}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|EMUSHORT
name|esqrt2
index|[
name|NE
index|]
init|=
block|{
literal|0x597e
block|,
literal|0x6484
block|,
literal|0174736
block|,
literal|0171463
block|,
literal|0132404
block|,
literal|0x3fff
block|,}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|EMUSHORT
name|epi
index|[
name|NE
index|]
init|=
block|{
literal|0xc4c6
block|,
literal|0xc234
block|,
literal|0020550
block|,
literal|0155242
block|,
literal|0144417
block|,
literal|0040000
block|,}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Control register for rounding precision.    This can be set to 113 (if NE=10), 80 (if NE=6), 64, 56, 53, or 24 bits.  */
end_comment

begin_decl_stmt
name|int
name|rndprc
init|=
name|NBITS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|rndprc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  Clear out entire e-type number X.  */
end_comment

begin_function
specifier|static
name|void
name|eclear
parameter_list|(
name|x
parameter_list|)
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NE
condition|;
name|i
operator|++
control|)
operator|*
name|x
operator|++
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Move e-type number from A to B.  */
end_comment

begin_function
specifier|static
name|void
name|emov
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NE
condition|;
name|i
operator|++
control|)
operator|*
name|b
operator|++
operator|=
operator|*
name|a
operator|++
expr_stmt|;
block|}
end_block

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Absolute value of e-type X.  */
end_comment

begin_comment
unit|static void eabs (x)      unsigned EMUSHORT x[]; {
comment|/* sign is top bit of last word of external format */
end_comment

begin_endif
unit|x[NE - 1]&= 0x7fff; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_comment
comment|/* Negate the e-type number X.  */
end_comment

begin_function
specifier|static
name|void
name|eneg
parameter_list|(
name|x
parameter_list|)
name|unsigned
name|EMUSHORT
name|x
index|[]
decl_stmt|;
block|{
name|x
index|[
name|NE
operator|-
literal|1
index|]
operator|^=
literal|0x8000
expr_stmt|;
comment|/* Toggle the sign bit */
block|}
end_function

begin_comment
comment|/* Return 1 if sign bit of e-type number X is nonzero, else zero.  */
end_comment

begin_function
specifier|static
name|int
name|eisneg
parameter_list|(
name|x
parameter_list|)
name|unsigned
name|EMUSHORT
name|x
index|[]
decl_stmt|;
block|{
if|if
condition|(
name|x
index|[
name|NE
operator|-
literal|1
index|]
operator|&
literal|0x8000
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if e-type number X is infinity, else return zero.  */
end_comment

begin_function
specifier|static
name|int
name|eisinf
parameter_list|(
name|x
parameter_list|)
name|unsigned
name|EMUSHORT
name|x
index|[]
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
name|eisnan
argument_list|(
name|x
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|x
index|[
name|NE
operator|-
literal|1
index|]
operator|&
literal|0x7fff
operator|)
operator|==
literal|0x7fff
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Check if e-type number is not a number.  The bit pattern is one that we    defined, so we know for sure how to detect it.  */
end_comment

begin_function
specifier|static
name|int
name|eisnan
parameter_list|(
name|x
parameter_list|)
name|unsigned
name|EMUSHORT
name|x
index|[]
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|NANS
name|int
name|i
decl_stmt|;
comment|/* NaN has maximum exponent */
if|if
condition|(
operator|(
name|x
index|[
name|NE
operator|-
literal|1
index|]
operator|&
literal|0x7fff
operator|)
operator|!=
literal|0x7fff
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* ... and non-zero significand field.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NE
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|x
operator|++
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  Fill e-type number X with infinity pattern (IEEE)     or largest possible number (non-IEEE).  */
end_comment

begin_function
specifier|static
name|void
name|einfin
parameter_list|(
name|x
parameter_list|)
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|INFINITY
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NE
operator|-
literal|1
condition|;
name|i
operator|++
control|)
operator|*
name|x
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|x
operator||=
literal|32767
expr_stmt|;
else|#
directive|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NE
operator|-
literal|1
condition|;
name|i
operator|++
control|)
operator|*
name|x
operator|++
operator|=
literal|0xffff
expr_stmt|;
operator|*
name|x
operator||=
literal|32766
expr_stmt|;
if|if
condition|(
name|rndprc
operator|<
name|NBITS
condition|)
block|{
if|if
condition|(
name|rndprc
operator|==
literal|113
condition|)
block|{
operator|*
operator|(
name|x
operator|-
literal|9
operator|)
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
name|x
operator|-
literal|8
operator|)
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|rndprc
operator|==
literal|64
condition|)
block|{
operator|*
operator|(
name|x
operator|-
literal|5
operator|)
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|rndprc
operator|==
literal|53
condition|)
block|{
operator|*
operator|(
name|x
operator|-
literal|4
operator|)
operator|=
literal|0xf800
expr_stmt|;
block|}
else|else
block|{
operator|*
operator|(
name|x
operator|-
literal|4
operator|)
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
name|x
operator|-
literal|3
operator|)
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
name|x
operator|-
literal|2
operator|)
operator|=
literal|0xff00
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Output an e-type NaN.    This generates Intel's quiet NaN pattern for extended real.    The exponent is 7fff, the leading mantissa word is c000.  */
end_comment

begin_function
specifier|static
name|void
name|enan
parameter_list|(
name|x
parameter_list|,
name|sign
parameter_list|)
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|;
name|int
name|sign
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NE
operator|-
literal|2
condition|;
name|i
operator|++
control|)
operator|*
name|x
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|x
operator|++
operator|=
literal|0xc000
expr_stmt|;
operator|*
name|x
operator|=
operator|(
name|sign
operator|<<
literal|15
operator|)
operator||
literal|0x7fff
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Move in an e-type number A, converting it to exploded e-type B.  */
end_comment

begin_function
specifier|static
name|void
name|emovi
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|int
name|i
decl_stmt|;
name|q
operator|=
name|b
expr_stmt|;
name|p
operator|=
name|a
operator|+
operator|(
name|NE
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* point to last word of external number */
comment|/* get the sign bit */
if|if
condition|(
operator|*
name|p
operator|&
literal|0x8000
condition|)
operator|*
name|q
operator|++
operator|=
literal|0xffff
expr_stmt|;
else|else
operator|*
name|q
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* get the exponent */
operator|*
name|q
operator|=
operator|*
name|p
operator|--
expr_stmt|;
operator|*
name|q
operator|++
operator|&=
literal|0x7fff
expr_stmt|;
comment|/* delete the sign bit */
ifdef|#
directive|ifdef
name|INFINITY
if|if
condition|(
operator|(
operator|*
operator|(
name|q
operator|-
literal|1
operator|)
operator|&
literal|0x7fff
operator|)
operator|==
literal|0x7fff
condition|)
block|{
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
name|eisnan
argument_list|(
name|a
argument_list|)
condition|)
block|{
operator|*
name|q
operator|++
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|<
name|NI
condition|;
name|i
operator|++
control|)
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|--
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|NI
condition|;
name|i
operator|++
control|)
operator|*
name|q
operator|++
operator|=
literal|0
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* clear high guard word */
operator|*
name|q
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* move in the significand */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NE
operator|-
literal|1
condition|;
name|i
operator|++
control|)
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|--
expr_stmt|;
comment|/* clear low guard word */
operator|*
name|q
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Move out exploded e-type number A, converting it to e type B.  */
end_comment

begin_function
specifier|static
name|void
name|emovo
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|unsigned
name|EMUSHORT
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|p
operator|=
name|a
expr_stmt|;
name|q
operator|=
name|b
operator|+
operator|(
name|NE
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* point to output exponent */
comment|/* combine sign and exponent */
name|i
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|i
condition|)
operator|*
name|q
operator|--
operator|=
operator|*
name|p
operator|++
operator||
literal|0x8000
expr_stmt|;
else|else
operator|*
name|q
operator|--
operator|=
operator|*
name|p
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|INFINITY
if|if
condition|(
operator|*
operator|(
name|p
operator|-
literal|1
operator|)
operator|==
literal|0x7fff
condition|)
block|{
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
name|eiisnan
argument_list|(
name|a
argument_list|)
condition|)
block|{
name|enan
argument_list|(
name|b
argument_list|,
name|eiisneg
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|einfin
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* skip over guard word */
operator|++
name|p
expr_stmt|;
comment|/* move the significand */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NE
operator|-
literal|1
condition|;
name|j
operator|++
control|)
operator|*
name|q
operator|--
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Clear out exploded e-type number XI.  */
end_comment

begin_function
specifier|static
name|void
name|ecleaz
parameter_list|(
name|xi
parameter_list|)
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|xi
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NI
condition|;
name|i
operator|++
control|)
operator|*
name|xi
operator|++
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clear out exploded e-type XI, but don't touch the sign.  */
end_comment

begin_function
specifier|static
name|void
name|ecleazs
parameter_list|(
name|xi
parameter_list|)
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|xi
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
operator|++
name|xi
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NI
operator|-
literal|1
condition|;
name|i
operator|++
control|)
operator|*
name|xi
operator|++
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Move exploded e-type number from A to B.  */
end_comment

begin_function
specifier|static
name|void
name|emovz
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NI
operator|-
literal|1
condition|;
name|i
operator|++
control|)
operator|*
name|b
operator|++
operator|=
operator|*
name|a
operator|++
expr_stmt|;
comment|/* clear low guard word */
operator|*
name|b
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Generate exploded e-type NaN.    The explicit pattern for this is maximum exponent and    top two significant bits set.  */
end_comment

begin_function
specifier|static
name|void
name|einan
parameter_list|(
name|x
parameter_list|)
name|unsigned
name|EMUSHORT
name|x
index|[]
decl_stmt|;
block|{
name|ecleaz
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
index|[
name|E
index|]
operator|=
literal|0x7fff
expr_stmt|;
name|x
index|[
name|M
operator|+
literal|1
index|]
operator|=
literal|0xc000
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return nonzero if exploded e-type X is a NaN.  */
end_comment

begin_function
specifier|static
name|int
name|eiisnan
parameter_list|(
name|x
parameter_list|)
name|unsigned
name|EMUSHORT
name|x
index|[]
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|x
index|[
name|E
index|]
operator|&
literal|0x7fff
operator|)
operator|==
literal|0x7fff
condition|)
block|{
for|for
control|(
name|i
operator|=
name|M
operator|+
literal|1
init|;
name|i
operator|<
name|NI
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|x
index|[
name|i
index|]
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if sign of exploded e-type X is nonzero.  */
end_comment

begin_function
specifier|static
name|int
name|eiisneg
parameter_list|(
name|x
parameter_list|)
name|unsigned
name|EMUSHORT
name|x
index|[]
decl_stmt|;
block|{
return|return
name|x
index|[
literal|0
index|]
operator|!=
literal|0
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Fill exploded e-type X with infinity pattern.    This has maximum exponent and significand all zeros.  */
end_comment

begin_endif
unit|static void eiinfin (x)      unsigned EMUSHORT x[]; {    ecleaz (x);   x[E] = 0x7fff; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_comment
comment|/* Return nonzero if exploded e-type X is infinite.  */
end_comment

begin_function
specifier|static
name|int
name|eiisinf
parameter_list|(
name|x
parameter_list|)
name|unsigned
name|EMUSHORT
name|x
index|[]
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
name|eiisnan
argument_list|(
name|x
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|x
index|[
name|E
index|]
operator|&
literal|0x7fff
operator|)
operator|==
literal|0x7fff
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Compare significands of numbers in internal exploded e-type format.    Guard words are included in the comparison.     Returns	+1 if a> b 		 0 if a == b 		-1 if a< b   */
end_comment

begin_function
specifier|static
name|int
name|ecmpm
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|;
end_function

begin_block
block|{
name|int
name|i
decl_stmt|;
name|a
operator|+=
name|M
expr_stmt|;
comment|/* skip up to significand area */
name|b
operator|+=
name|M
expr_stmt|;
for|for
control|(
name|i
operator|=
name|M
init|;
name|i
operator|<
name|NI
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|a
operator|++
operator|!=
operator|*
name|b
operator|++
condition|)
goto|goto
name|difrnt
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|difrnt
label|:
if|if
condition|(
operator|*
operator|(
operator|--
name|a
operator|)
operator|>
operator|*
operator|(
operator|--
name|b
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Shift significand of exploded e-type X down by 1 bit.  */
end_comment

begin_function
specifier|static
name|void
name|eshdn1
parameter_list|(
name|x
parameter_list|)
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|;
block|{
specifier|register
name|unsigned
name|EMUSHORT
name|bits
decl_stmt|;
name|int
name|i
decl_stmt|;
name|x
operator|+=
name|M
expr_stmt|;
comment|/* point to significand area */
name|bits
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|M
init|;
name|i
operator|<
name|NI
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|x
operator|&
literal|1
condition|)
name|bits
operator||=
literal|1
expr_stmt|;
operator|*
name|x
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|bits
operator|&
literal|2
condition|)
operator|*
name|x
operator||=
literal|0x8000
expr_stmt|;
name|bits
operator|<<=
literal|1
expr_stmt|;
operator|++
name|x
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Shift significand of exploded e-type X up by 1 bit.  */
end_comment

begin_function
specifier|static
name|void
name|eshup1
parameter_list|(
name|x
parameter_list|)
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|;
block|{
specifier|register
name|unsigned
name|EMUSHORT
name|bits
decl_stmt|;
name|int
name|i
decl_stmt|;
name|x
operator|+=
name|NI
operator|-
literal|1
expr_stmt|;
name|bits
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|M
init|;
name|i
operator|<
name|NI
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|x
operator|&
literal|0x8000
condition|)
name|bits
operator||=
literal|1
expr_stmt|;
operator|*
name|x
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|bits
operator|&
literal|2
condition|)
operator|*
name|x
operator||=
literal|1
expr_stmt|;
name|bits
operator|<<=
literal|1
expr_stmt|;
operator|--
name|x
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Shift significand of exploded e-type X down by 8 bits.  */
end_comment

begin_function
specifier|static
name|void
name|eshdn8
parameter_list|(
name|x
parameter_list|)
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|;
block|{
specifier|register
name|unsigned
name|EMUSHORT
name|newbyt
decl_stmt|,
name|oldbyt
decl_stmt|;
name|int
name|i
decl_stmt|;
name|x
operator|+=
name|M
expr_stmt|;
name|oldbyt
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|M
init|;
name|i
operator|<
name|NI
condition|;
name|i
operator|++
control|)
block|{
name|newbyt
operator|=
operator|*
name|x
operator|<<
literal|8
expr_stmt|;
operator|*
name|x
operator|>>=
literal|8
expr_stmt|;
operator|*
name|x
operator||=
name|oldbyt
expr_stmt|;
name|oldbyt
operator|=
name|newbyt
expr_stmt|;
operator|++
name|x
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Shift significand of exploded e-type X up by 8 bits.  */
end_comment

begin_function
specifier|static
name|void
name|eshup8
parameter_list|(
name|x
parameter_list|)
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
specifier|register
name|unsigned
name|EMUSHORT
name|newbyt
decl_stmt|,
name|oldbyt
decl_stmt|;
name|x
operator|+=
name|NI
operator|-
literal|1
expr_stmt|;
name|oldbyt
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|M
init|;
name|i
operator|<
name|NI
condition|;
name|i
operator|++
control|)
block|{
name|newbyt
operator|=
operator|*
name|x
operator|>>
literal|8
expr_stmt|;
operator|*
name|x
operator|<<=
literal|8
expr_stmt|;
operator|*
name|x
operator||=
name|oldbyt
expr_stmt|;
name|oldbyt
operator|=
name|newbyt
expr_stmt|;
operator|--
name|x
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Shift significand of exploded e-type X up by 16 bits.  */
end_comment

begin_function
specifier|static
name|void
name|eshup6
parameter_list|(
name|x
parameter_list|)
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|x
operator|+
name|M
expr_stmt|;
name|x
operator|+=
name|M
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|M
init|;
name|i
operator|<
name|NI
operator|-
literal|1
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
operator|*
name|x
operator|++
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Shift significand of exploded e-type X down by 16 bits.  */
end_comment

begin_function
specifier|static
name|void
name|eshdn6
parameter_list|(
name|x
parameter_list|)
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|p
decl_stmt|;
name|x
operator|+=
name|NI
operator|-
literal|1
expr_stmt|;
name|p
operator|=
name|x
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|M
init|;
name|i
operator|<
name|NI
operator|-
literal|1
condition|;
name|i
operator|++
control|)
operator|*
operator|(
operator|--
name|p
operator|)
operator|=
operator|*
operator|(
operator|--
name|x
operator|)
expr_stmt|;
operator|*
operator|(
operator|--
name|p
operator|)
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add significands of exploded e-type X and Y.  X + Y replaces Y.  */
end_comment

begin_function
specifier|static
name|void
name|eaddm
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|,
decl|*
name|y
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|unsigned
name|EMULONG
name|a
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|carry
decl_stmt|;
name|x
operator|+=
name|NI
operator|-
literal|1
expr_stmt|;
name|y
operator|+=
name|NI
operator|-
literal|1
expr_stmt|;
name|carry
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|M
init|;
name|i
operator|<
name|NI
condition|;
name|i
operator|++
control|)
block|{
name|a
operator|=
call|(
name|unsigned
name|EMULONG
call|)
argument_list|(
operator|*
name|x
argument_list|)
operator|+
call|(
name|unsigned
name|EMULONG
call|)
argument_list|(
operator|*
name|y
argument_list|)
operator|+
name|carry
expr_stmt|;
if|if
condition|(
name|a
operator|&
literal|0x10000
condition|)
name|carry
operator|=
literal|1
expr_stmt|;
else|else
name|carry
operator|=
literal|0
expr_stmt|;
operator|*
name|y
operator|=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|a
expr_stmt|;
operator|--
name|x
expr_stmt|;
operator|--
name|y
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Subtract significands of exploded e-type X and Y.  Y - X replaces Y.  */
end_comment

begin_function
specifier|static
name|void
name|esubm
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|,
decl|*
name|y
decl_stmt|;
end_function

begin_block
block|{
name|unsigned
name|EMULONG
name|a
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|carry
decl_stmt|;
name|x
operator|+=
name|NI
operator|-
literal|1
expr_stmt|;
name|y
operator|+=
name|NI
operator|-
literal|1
expr_stmt|;
name|carry
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|M
init|;
name|i
operator|<
name|NI
condition|;
name|i
operator|++
control|)
block|{
name|a
operator|=
call|(
name|unsigned
name|EMULONG
call|)
argument_list|(
operator|*
name|y
argument_list|)
operator|-
call|(
name|unsigned
name|EMULONG
call|)
argument_list|(
operator|*
name|x
argument_list|)
operator|-
name|carry
expr_stmt|;
if|if
condition|(
name|a
operator|&
literal|0x10000
condition|)
name|carry
operator|=
literal|1
expr_stmt|;
else|else
name|carry
operator|=
literal|0
expr_stmt|;
operator|*
name|y
operator|=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|a
expr_stmt|;
operator|--
name|x
expr_stmt|;
operator|--
name|y
expr_stmt|;
block|}
block|}
end_block

begin_decl_stmt
specifier|static
name|unsigned
name|EMUSHORT
name|equot
index|[
name|NI
index|]
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Radix 2 shift-and-add versions of multiply and divide  */
end_comment

begin_comment
comment|/* Divide significands */
end_comment

begin_comment
unit|int edivm (den, num)      unsigned EMUSHORT den[], num[]; {   int i;   register unsigned EMUSHORT *p, *q;   unsigned EMUSHORT j;    p =&equot[0];   *p++ = num[0];   *p++ = num[1];    for (i = M; i< NI; i++)     {       *p++ = 0;     }
comment|/* Use faster compare and subtraction if denominator has only 15 bits of      significance.  */
end_comment

begin_comment
unit|p =&den[M + 2];   if (*p++ == 0)     {       for (i = M + 3; i< NI; i++) 	{ 	  if (*p++ != 0) 	    goto fulldiv; 	}       if ((den[M + 1]& 1) != 0) 	goto fulldiv;       eshdn1 (num);       eshdn1 (den);        p =&den[M + 1];       q =&num[M + 1];        for (i = 0; i< NBITS + 2; i++) 	{ 	  if (*p<= *q) 	    { 	      *q -= *p; 	      j = 1; 	    } 	  else 	    { 	      j = 0; 	    } 	  eshup1 (equot); 	  equot[NI - 2] |= j; 	  eshup1 (num); 	}       goto divdon;     }
comment|/* The number of quotient bits to calculate is NBITS + 1 scaling guard      bit + 1 roundoff bit.  */
end_comment

begin_comment
unit|fulldiv:    p =&equot[NI - 2];   for (i = 0; i< NBITS + 2; i++)     {       if (ecmpm (den, num)<= 0) 	{ 	  esubm (den, num); 	  j = 1;
comment|/* quotient bit = 1 */
end_comment

begin_comment
unit|}       else 	j = 0;       eshup1 (equot);       *p |= j;       eshup1 (num);     }   divdon:    eshdn1 (equot);   eshdn1 (equot);
comment|/* test for nonzero remainder after roundoff bit */
end_comment

begin_comment
unit|p =&num[M];   j = 0;   for (i = M; i< NI; i++)     {       j |= *p++;     }   if (j)     j = 1;     for (i = 0; i< NI; i++)     num[i] = equot[i];   return ((int) j); }
comment|/* Multiply significands */
end_comment

begin_comment
unit|int emulm (a, b)      unsigned EMUSHORT a[], b[]; {   unsigned EMUSHORT *p, *q;   int i, j, k;    equot[0] = b[0];   equot[1] = b[1];   for (i = M; i< NI; i++)     equot[i] = 0;    p =&a[NI - 2];   k = NBITS;   while (*p == 0)
comment|/* significand is not supposed to be zero */
end_comment

begin_comment
unit|{       eshdn6 (a);       k -= 16;     }   if ((*p& 0xff) == 0)     {       eshdn8 (a);       k -= 8;     }    q =&equot[NI - 1];   j = 0;   for (i = 0; i< k; i++)     {       if (*p& 1) 	eaddm (b, equot);
comment|/* remember if there were any nonzero bits shifted out */
end_comment

begin_comment
unit|if (*q& 1) 	j |= 1;       eshdn1 (a);       eshdn1 (equot);     }    for (i = 0; i< NI; i++)     b[i] = equot[i];
comment|/* return flag for lost nonzero bits */
end_comment

begin_else
unit|return (j); }
else|#
directive|else
end_else

begin_comment
comment|/* Radix 65536 versions of multiply and divide.  */
end_comment

begin_comment
comment|/* Multiply significand of e-type number B    by 16-bit quantity A, return e-type result to C.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|m16m
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|)
name|unsigned
name|int
name|a
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|EMUSHORT
name|b
index|[]
decl_stmt|,
name|c
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|pp
decl_stmt|;
specifier|register
name|unsigned
name|EMULONG
name|carry
decl_stmt|;
name|unsigned
name|EMUSHORT
modifier|*
name|ps
decl_stmt|;
name|unsigned
name|EMUSHORT
name|p
index|[
name|NI
index|]
decl_stmt|;
name|unsigned
name|EMULONG
name|aa
decl_stmt|,
name|m
decl_stmt|;
name|int
name|i
decl_stmt|;
name|aa
operator|=
name|a
expr_stmt|;
name|pp
operator|=
operator|&
name|p
index|[
name|NI
operator|-
literal|2
index|]
expr_stmt|;
operator|*
name|pp
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|pp
operator|=
literal|0
expr_stmt|;
name|ps
operator|=
operator|&
name|b
index|[
name|NI
operator|-
literal|1
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|M
operator|+
literal|1
init|;
name|i
operator|<
name|NI
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|ps
operator|==
literal|0
condition|)
block|{
operator|--
name|ps
expr_stmt|;
operator|--
name|pp
expr_stmt|;
operator|*
operator|(
name|pp
operator|-
literal|1
operator|)
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|m
operator|=
operator|(
name|unsigned
name|EMULONG
operator|)
name|aa
operator|*
operator|*
name|ps
operator|--
expr_stmt|;
name|carry
operator|=
operator|(
name|m
operator|&
literal|0xffff
operator|)
operator|+
operator|*
name|pp
expr_stmt|;
operator|*
name|pp
operator|--
operator|=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|carry
expr_stmt|;
name|carry
operator|=
operator|(
name|carry
operator|>>
literal|16
operator|)
operator|+
operator|(
name|m
operator|>>
literal|16
operator|)
operator|+
operator|*
name|pp
expr_stmt|;
operator|*
name|pp
operator|=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|carry
expr_stmt|;
operator|*
operator|(
name|pp
operator|-
literal|1
operator|)
operator|=
name|carry
operator|>>
literal|16
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
name|M
init|;
name|i
operator|<
name|NI
condition|;
name|i
operator|++
control|)
name|c
index|[
name|i
index|]
operator|=
name|p
index|[
name|i
index|]
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Divide significands of exploded e-types NUM / DEN.  Neither the    numerator NUM nor the denominator DEN is permitted to have its high guard    word nonzero.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|edivm
argument_list|(
name|den
argument_list|,
name|num
argument_list|)
name|unsigned
name|EMUSHORT
name|den
index|[]
decl_stmt|,
name|num
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|p
decl_stmt|;
name|unsigned
name|EMULONG
name|tnum
decl_stmt|;
name|unsigned
name|EMUSHORT
name|j
decl_stmt|,
name|tdenm
decl_stmt|,
name|tquot
decl_stmt|;
name|unsigned
name|EMUSHORT
name|tprod
index|[
name|NI
operator|+
literal|1
index|]
decl_stmt|;
name|p
operator|=
operator|&
name|equot
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|num
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|num
index|[
literal|1
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|M
init|;
name|i
operator|<
name|NI
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
block|}
name|eshdn1
argument_list|(
name|num
argument_list|)
expr_stmt|;
name|tdenm
operator|=
name|den
index|[
name|M
operator|+
literal|1
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|M
init|;
name|i
operator|<
name|NI
condition|;
name|i
operator|++
control|)
block|{
comment|/* Find trial quotient digit (the radix is 65536).  */
name|tnum
operator|=
operator|(
operator|(
operator|(
name|unsigned
name|EMULONG
operator|)
name|num
index|[
name|M
index|]
operator|)
operator|<<
literal|16
operator|)
operator|+
name|num
index|[
name|M
operator|+
literal|1
index|]
expr_stmt|;
comment|/* Do not execute the divide instruction if it will overflow.  */
if|if
condition|(
operator|(
name|tdenm
operator|*
operator|(
name|unsigned
name|long
operator|)
literal|0xffff
operator|)
operator|<
name|tnum
condition|)
name|tquot
operator|=
literal|0xffff
expr_stmt|;
else|else
name|tquot
operator|=
name|tnum
operator|/
name|tdenm
expr_stmt|;
comment|/* Multiply denominator by trial quotient digit.  */
name|m16m
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|tquot
argument_list|,
name|den
argument_list|,
name|tprod
argument_list|)
expr_stmt|;
comment|/* The quotient digit may have been overestimated.  */
if|if
condition|(
name|ecmpm
argument_list|(
name|tprod
argument_list|,
name|num
argument_list|)
operator|>
literal|0
condition|)
block|{
name|tquot
operator|-=
literal|1
expr_stmt|;
name|esubm
argument_list|(
name|den
argument_list|,
name|tprod
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecmpm
argument_list|(
name|tprod
argument_list|,
name|num
argument_list|)
operator|>
literal|0
condition|)
block|{
name|tquot
operator|-=
literal|1
expr_stmt|;
name|esubm
argument_list|(
name|den
argument_list|,
name|tprod
argument_list|)
expr_stmt|;
block|}
block|}
name|esubm
argument_list|(
name|tprod
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|equot
index|[
name|i
index|]
operator|=
name|tquot
expr_stmt|;
name|eshup6
argument_list|(
name|num
argument_list|)
expr_stmt|;
block|}
comment|/* test for nonzero remainder after roundoff bit */
name|p
operator|=
operator|&
name|num
index|[
name|M
index|]
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|M
init|;
name|i
operator|<
name|NI
condition|;
name|i
operator|++
control|)
block|{
name|j
operator||=
operator|*
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|j
condition|)
name|j
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NI
condition|;
name|i
operator|++
control|)
name|num
index|[
name|i
index|]
operator|=
name|equot
index|[
name|i
index|]
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|j
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Multiply significands of exploded e-type A and B, result in B.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|emulm
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
name|unsigned
name|EMUSHORT
name|a
index|[]
decl_stmt|,
name|b
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unsigned
name|EMUSHORT
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|unsigned
name|EMUSHORT
name|pprod
index|[
name|NI
index|]
decl_stmt|;
name|unsigned
name|EMUSHORT
name|j
decl_stmt|;
name|int
name|i
decl_stmt|;
name|equot
index|[
literal|0
index|]
operator|=
name|b
index|[
literal|0
index|]
expr_stmt|;
name|equot
index|[
literal|1
index|]
operator|=
name|b
index|[
literal|1
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|M
init|;
name|i
operator|<
name|NI
condition|;
name|i
operator|++
control|)
name|equot
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
name|p
operator|=
operator|&
name|a
index|[
name|NI
operator|-
literal|1
index|]
expr_stmt|;
name|q
operator|=
operator|&
name|equot
index|[
name|NI
operator|-
literal|1
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|M
operator|+
literal|1
init|;
name|i
operator|<
name|NI
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
block|{
operator|--
name|p
expr_stmt|;
block|}
else|else
block|{
name|m16m
argument_list|(
operator|(
name|unsigned
name|int
operator|)
operator|*
name|p
operator|--
argument_list|,
name|b
argument_list|,
name|pprod
argument_list|)
expr_stmt|;
name|eaddm
argument_list|(
name|pprod
argument_list|,
name|equot
argument_list|)
expr_stmt|;
block|}
name|j
operator||=
operator|*
name|q
expr_stmt|;
name|eshdn6
argument_list|(
name|equot
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NI
condition|;
name|i
operator|++
control|)
name|b
index|[
name|i
index|]
operator|=
name|equot
index|[
name|i
index|]
expr_stmt|;
comment|/* return flag for lost nonzero bits */
return|return
operator|(
operator|(
name|int
operator|)
name|j
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Normalize and round off.    The internal format number to be rounded is S.   Input LOST is 0 if the value is exact.  This is the so-called sticky bit.    Input SUBFLG indicates whether the number was obtained   by a subtraction operation.  In that case if LOST is nonzero   then the number is slightly smaller than indicated.    Input EXP is the biased exponent, which may be negative.   the exponent field of S is ignored but is replaced by   EXP as adjusted by normalization and rounding.    Input RCNTRL is the rounding control.  If it is nonzero, the   returned value will be rounded to RNDPRC bits.    For future reference:  In order for emdnorm to round off denormal    significands at the right point, the input exponent must be    adjusted to be the actual value it would have after conversion to    the final floating point type.  This adjustment has been    implemented for all type conversions (etoe53, etc.) and decimal    conversions, but not for the arithmetic functions (eadd, etc.).    Data types having standard 15-bit exponents are not affected by    this, but SFmode and DFmode are affected. For example, ediv with    rndprc = 24 will not round correctly to 24-bit precision if the    result is denormal.   */
end_comment

begin_decl_stmt
specifier|static
name|int
name|rlast
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rw
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|EMUSHORT
name|rmsk
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|EMUSHORT
name|rmbit
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|EMUSHORT
name|rebit
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|re
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|EMUSHORT
name|rbit
index|[
name|NI
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|emdnorm
parameter_list|(
name|s
parameter_list|,
name|lost
parameter_list|,
name|subflg
parameter_list|,
name|exp
parameter_list|,
name|rcntrl
parameter_list|)
name|unsigned
name|EMUSHORT
name|s
index|[]
decl_stmt|;
name|int
name|lost
decl_stmt|;
name|int
name|subflg
decl_stmt|;
name|EMULONG
name|exp
decl_stmt|;
name|int
name|rcntrl
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|unsigned
name|EMUSHORT
name|r
decl_stmt|;
comment|/* Normalize */
name|j
operator|=
name|enormlz
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* a blank significand could mean either zero or infinity.  */
ifndef|#
directive|ifndef
name|INFINITY
if|if
condition|(
name|j
operator|>
name|NBITS
condition|)
block|{
name|ecleazs
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|exp
operator|-=
name|j
expr_stmt|;
ifndef|#
directive|ifndef
name|INFINITY
if|if
condition|(
name|exp
operator|>=
literal|32767L
condition|)
goto|goto
name|overf
goto|;
else|#
directive|else
if|if
condition|(
operator|(
name|j
operator|>
name|NBITS
operator|)
operator|&&
operator|(
name|exp
operator|<
literal|32767
operator|)
condition|)
block|{
name|ecleazs
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
if|if
condition|(
name|exp
operator|<
literal|0L
condition|)
block|{
if|if
condition|(
name|exp
operator|>
call|(
name|EMULONG
call|)
argument_list|(
operator|-
name|NBITS
operator|-
literal|1
argument_list|)
condition|)
block|{
name|j
operator|=
operator|(
name|int
operator|)
name|exp
expr_stmt|;
name|i
operator|=
name|eshift
argument_list|(
name|s
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
name|lost
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ecleazs
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Round off, unless told not to by rcntrl.  */
if|if
condition|(
name|rcntrl
operator|==
literal|0
condition|)
goto|goto
name|mdfin
goto|;
comment|/* Set up rounding parameters if the control register changed.  */
if|if
condition|(
name|rndprc
operator|!=
name|rlast
condition|)
block|{
name|ecleaz
argument_list|(
name|rbit
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rndprc
condition|)
block|{
default|default:
case|case
name|NBITS
case|:
name|rw
operator|=
name|NI
operator|-
literal|1
expr_stmt|;
comment|/* low guard word */
name|rmsk
operator|=
literal|0xffff
expr_stmt|;
name|rmbit
operator|=
literal|0x8000
expr_stmt|;
name|re
operator|=
name|rw
operator|-
literal|1
expr_stmt|;
name|rebit
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|113
case|:
name|rw
operator|=
literal|10
expr_stmt|;
name|rmsk
operator|=
literal|0x7fff
expr_stmt|;
name|rmbit
operator|=
literal|0x4000
expr_stmt|;
name|rebit
operator|=
literal|0x8000
expr_stmt|;
name|re
operator|=
name|rw
expr_stmt|;
break|break;
case|case
literal|64
case|:
name|rw
operator|=
literal|7
expr_stmt|;
name|rmsk
operator|=
literal|0xffff
expr_stmt|;
name|rmbit
operator|=
literal|0x8000
expr_stmt|;
name|re
operator|=
name|rw
operator|-
literal|1
expr_stmt|;
name|rebit
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* For DEC or IBM arithmetic */
case|case
literal|56
case|:
name|rw
operator|=
literal|6
expr_stmt|;
name|rmsk
operator|=
literal|0xff
expr_stmt|;
name|rmbit
operator|=
literal|0x80
expr_stmt|;
name|rebit
operator|=
literal|0x100
expr_stmt|;
name|re
operator|=
name|rw
expr_stmt|;
break|break;
case|case
literal|53
case|:
name|rw
operator|=
literal|6
expr_stmt|;
name|rmsk
operator|=
literal|0x7ff
expr_stmt|;
name|rmbit
operator|=
literal|0x0400
expr_stmt|;
name|rebit
operator|=
literal|0x800
expr_stmt|;
name|re
operator|=
name|rw
expr_stmt|;
break|break;
comment|/* For C4x arithmetic */
case|case
literal|32
case|:
name|rw
operator|=
literal|5
expr_stmt|;
name|rmsk
operator|=
literal|0xffff
expr_stmt|;
name|rmbit
operator|=
literal|0x8000
expr_stmt|;
name|rebit
operator|=
literal|1
expr_stmt|;
name|re
operator|=
name|rw
operator|-
literal|1
expr_stmt|;
break|break;
case|case
literal|24
case|:
name|rw
operator|=
literal|4
expr_stmt|;
name|rmsk
operator|=
literal|0xff
expr_stmt|;
name|rmbit
operator|=
literal|0x80
expr_stmt|;
name|rebit
operator|=
literal|0x100
expr_stmt|;
name|re
operator|=
name|rw
expr_stmt|;
break|break;
block|}
name|rbit
index|[
name|re
index|]
operator|=
name|rebit
expr_stmt|;
name|rlast
operator|=
name|rndprc
expr_stmt|;
block|}
comment|/* Shift down 1 temporarily if the data structure has an implied      most significant bit and the number is denormal.      Intel long double denormals also lose one bit of precision.  */
if|if
condition|(
operator|(
name|exp
operator|<=
literal|0
operator|)
operator|&&
operator|(
name|rndprc
operator|!=
name|NBITS
operator|)
operator|&&
operator|(
operator|(
name|rndprc
operator|!=
literal|64
operator|)
operator|||
operator|(
operator|(
name|rndprc
operator|==
literal|64
operator|)
operator|&&
operator|!
name|REAL_WORDS_BIG_ENDIAN
operator|)
operator|)
condition|)
block|{
name|lost
operator||=
name|s
index|[
name|NI
operator|-
literal|1
index|]
operator|&
literal|1
expr_stmt|;
name|eshdn1
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
comment|/* Clear out all bits below the rounding bit,      remembering in r if any were nonzero.  */
name|r
operator|=
name|s
index|[
name|rw
index|]
operator|&
name|rmsk
expr_stmt|;
if|if
condition|(
name|rndprc
operator|<
name|NBITS
condition|)
block|{
name|i
operator|=
name|rw
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|NI
condition|)
block|{
if|if
condition|(
name|s
index|[
name|i
index|]
condition|)
name|r
operator||=
literal|1
expr_stmt|;
name|s
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
block|}
name|s
index|[
name|rw
index|]
operator|&=
operator|~
name|rmsk
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|&
name|rmbit
operator|)
operator|!=
literal|0
condition|)
block|{
ifndef|#
directive|ifndef
name|C4X
if|if
condition|(
name|r
operator|==
name|rmbit
condition|)
block|{
if|if
condition|(
name|lost
operator|==
literal|0
condition|)
block|{
comment|/* round to even */
if|if
condition|(
operator|(
name|s
index|[
name|re
index|]
operator|&
name|rebit
operator|)
operator|==
literal|0
condition|)
goto|goto
name|mddone
goto|;
block|}
else|else
block|{
if|if
condition|(
name|subflg
operator|!=
literal|0
condition|)
goto|goto
name|mddone
goto|;
block|}
block|}
endif|#
directive|endif
name|eaddm
argument_list|(
name|rbit
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
name|mddone
label|:
comment|/* Undo the temporary shift for denormal values.  */
if|if
condition|(
operator|(
name|exp
operator|<=
literal|0
operator|)
operator|&&
operator|(
name|rndprc
operator|!=
name|NBITS
operator|)
operator|&&
operator|(
operator|(
name|rndprc
operator|!=
literal|64
operator|)
operator|||
operator|(
operator|(
name|rndprc
operator|==
literal|64
operator|)
operator|&&
operator|!
name|REAL_WORDS_BIG_ENDIAN
operator|)
operator|)
condition|)
block|{
name|eshup1
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
index|[
literal|2
index|]
operator|!=
literal|0
condition|)
block|{
comment|/* overflow on roundoff */
name|eshdn1
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|exp
operator|+=
literal|1
expr_stmt|;
block|}
name|mdfin
label|:
name|s
index|[
name|NI
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|exp
operator|>=
literal|32767L
condition|)
block|{
ifndef|#
directive|ifndef
name|INFINITY
name|overf
label|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INFINITY
name|s
index|[
literal|1
index|]
operator|=
literal|32767
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|NI
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|s
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|extra_warnings
condition|)
name|warning
argument_list|(
literal|"floating point overflow"
argument_list|)
expr_stmt|;
else|#
directive|else
name|s
index|[
literal|1
index|]
operator|=
literal|32766
expr_stmt|;
name|s
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|M
operator|+
literal|1
init|;
name|i
operator|<
name|NI
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|s
index|[
name|i
index|]
operator|=
literal|0xffff
expr_stmt|;
name|s
index|[
name|NI
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|rndprc
operator|<
literal|64
operator|)
operator|||
operator|(
name|rndprc
operator|==
literal|113
operator|)
condition|)
block|{
name|s
index|[
name|rw
index|]
operator|&=
operator|~
name|rmsk
expr_stmt|;
if|if
condition|(
name|rndprc
operator|==
literal|24
condition|)
block|{
name|s
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
name|s
index|[
literal|6
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
endif|#
directive|endif
return|return;
block|}
if|if
condition|(
name|exp
operator|<
literal|0
condition|)
name|s
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
else|else
name|s
index|[
literal|1
index|]
operator|=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|exp
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  Subtract.  C = B - A, all e type numbers.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|subflg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|esub
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|,
modifier|*
name|c
decl_stmt|;
end_function

begin_block
block|{
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
name|eisnan
argument_list|(
name|a
argument_list|)
condition|)
block|{
name|emov
argument_list|(
name|a
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|eisnan
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|emov
argument_list|(
name|b
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Infinity minus infinity is a NaN.    Test for subtracting infinities of the same sign.  */
if|if
condition|(
name|eisinf
argument_list|(
name|a
argument_list|)
operator|&&
name|eisinf
argument_list|(
name|b
argument_list|)
operator|&&
operator|(
operator|(
name|eisneg
argument_list|(
name|a
argument_list|)
operator|^
name|eisneg
argument_list|(
name|b
argument_list|)
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|mtherr
argument_list|(
literal|"esub"
argument_list|,
name|INVALID
argument_list|)
expr_stmt|;
name|enan
argument_list|(
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|subflg
operator|=
literal|1
expr_stmt|;
name|eadd1
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Add.  C = A + B, all e type.  */
end_comment

begin_function
specifier|static
name|void
name|eadd
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|,
modifier|*
name|c
decl_stmt|;
end_function

begin_block
block|{
ifdef|#
directive|ifdef
name|NANS
comment|/* NaN plus anything is a NaN.  */
if|if
condition|(
name|eisnan
argument_list|(
name|a
argument_list|)
condition|)
block|{
name|emov
argument_list|(
name|a
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|eisnan
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|emov
argument_list|(
name|b
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Infinity minus infinity is a NaN.    Test for adding infinities of opposite signs.  */
if|if
condition|(
name|eisinf
argument_list|(
name|a
argument_list|)
operator|&&
name|eisinf
argument_list|(
name|b
argument_list|)
operator|&&
operator|(
operator|(
name|eisneg
argument_list|(
name|a
argument_list|)
operator|^
name|eisneg
argument_list|(
name|b
argument_list|)
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|mtherr
argument_list|(
literal|"esub"
argument_list|,
name|INVALID
argument_list|)
expr_stmt|;
name|enan
argument_list|(
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|subflg
operator|=
literal|0
expr_stmt|;
name|eadd1
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Arithmetic common to both addition and subtraction.  */
end_comment

begin_function
specifier|static
name|void
name|eadd1
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|,
modifier|*
name|c
decl_stmt|;
end_function

begin_block
block|{
name|unsigned
name|EMUSHORT
name|ai
index|[
name|NI
index|]
decl_stmt|,
name|bi
index|[
name|NI
index|]
decl_stmt|,
name|ci
index|[
name|NI
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|lost
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|EMULONG
name|lt
decl_stmt|,
name|lta
decl_stmt|,
name|ltb
decl_stmt|;
ifdef|#
directive|ifdef
name|INFINITY
if|if
condition|(
name|eisinf
argument_list|(
name|a
argument_list|)
condition|)
block|{
name|emov
argument_list|(
name|a
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|subflg
condition|)
name|eneg
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|eisinf
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|emov
argument_list|(
name|b
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|emovi
argument_list|(
name|a
argument_list|,
name|ai
argument_list|)
expr_stmt|;
name|emovi
argument_list|(
name|b
argument_list|,
name|bi
argument_list|)
expr_stmt|;
if|if
condition|(
name|subflg
condition|)
name|ai
index|[
literal|0
index|]
operator|=
operator|~
name|ai
index|[
literal|0
index|]
expr_stmt|;
comment|/* compare exponents */
name|lta
operator|=
name|ai
index|[
name|E
index|]
expr_stmt|;
name|ltb
operator|=
name|bi
index|[
name|E
index|]
expr_stmt|;
name|lt
operator|=
name|lta
operator|-
name|ltb
expr_stmt|;
if|if
condition|(
name|lt
operator|>
literal|0L
condition|)
block|{
comment|/* put the larger number in bi */
name|emovz
argument_list|(
name|bi
argument_list|,
name|ci
argument_list|)
expr_stmt|;
name|emovz
argument_list|(
name|ai
argument_list|,
name|bi
argument_list|)
expr_stmt|;
name|emovz
argument_list|(
name|ci
argument_list|,
name|ai
argument_list|)
expr_stmt|;
name|ltb
operator|=
name|bi
index|[
name|E
index|]
expr_stmt|;
name|lt
operator|=
operator|-
name|lt
expr_stmt|;
block|}
name|lost
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lt
operator|!=
literal|0L
condition|)
block|{
if|if
condition|(
name|lt
operator|<
call|(
name|EMULONG
call|)
argument_list|(
operator|-
name|NBITS
operator|-
literal|1
argument_list|)
condition|)
goto|goto
name|done
goto|;
comment|/* answer same as larger addend */
name|k
operator|=
operator|(
name|int
operator|)
name|lt
expr_stmt|;
name|lost
operator|=
name|eshift
argument_list|(
name|ai
argument_list|,
name|k
argument_list|)
expr_stmt|;
comment|/* shift the smaller number down */
block|}
else|else
block|{
comment|/* exponents were the same, so must compare significands */
name|i
operator|=
name|ecmpm
argument_list|(
name|ai
argument_list|,
name|bi
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
comment|/* the numbers are identical in magnitude */
comment|/* if different signs, result is zero */
if|if
condition|(
name|ai
index|[
literal|0
index|]
operator|!=
name|bi
index|[
literal|0
index|]
condition|)
block|{
name|eclear
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* if same sign, result is double */
comment|/* double denormalized tiny number */
if|if
condition|(
operator|(
name|bi
index|[
name|E
index|]
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|bi
index|[
literal|3
index|]
operator|&
literal|0x8000
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|eshup1
argument_list|(
name|bi
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* add 1 to exponent unless both are zero! */
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|NI
operator|-
literal|1
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|bi
index|[
name|j
index|]
operator|!=
literal|0
condition|)
block|{
name|ltb
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|ltb
operator|>=
literal|0x7fff
condition|)
block|{
name|eclear
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
name|eneg
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|einfin
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
block|}
block|}
name|bi
index|[
name|E
index|]
operator|=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|ltb
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
comment|/* put the larger number in bi */
name|emovz
argument_list|(
name|bi
argument_list|,
name|ci
argument_list|)
expr_stmt|;
name|emovz
argument_list|(
name|ai
argument_list|,
name|bi
argument_list|)
expr_stmt|;
name|emovz
argument_list|(
name|ci
argument_list|,
name|ai
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ai
index|[
literal|0
index|]
operator|==
name|bi
index|[
literal|0
index|]
condition|)
block|{
name|eaddm
argument_list|(
name|ai
argument_list|,
name|bi
argument_list|)
expr_stmt|;
name|subflg
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|esubm
argument_list|(
name|ai
argument_list|,
name|bi
argument_list|)
expr_stmt|;
name|subflg
operator|=
literal|1
expr_stmt|;
block|}
name|emdnorm
argument_list|(
name|bi
argument_list|,
name|lost
argument_list|,
name|subflg
argument_list|,
name|ltb
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|done
label|:
name|emovo
argument_list|(
name|bi
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Divide: C = B/A, all e type.  */
end_comment

begin_function
specifier|static
name|void
name|ediv
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|,
modifier|*
name|c
decl_stmt|;
end_function

begin_block
block|{
name|unsigned
name|EMUSHORT
name|ai
index|[
name|NI
index|]
decl_stmt|,
name|bi
index|[
name|NI
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|sign
decl_stmt|;
name|EMULONG
name|lt
decl_stmt|,
name|lta
decl_stmt|,
name|ltb
decl_stmt|;
comment|/* IEEE says if result is not a NaN, the sign is "-" if and only if    operands have opposite signs -- but flush -0 to 0 later if not IEEE.  */
name|sign
operator|=
name|eisneg
argument_list|(
name|a
argument_list|)
operator|^
name|eisneg
argument_list|(
name|b
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NANS
comment|/* Return any NaN input.  */
if|if
condition|(
name|eisnan
argument_list|(
name|a
argument_list|)
condition|)
block|{
name|emov
argument_list|(
name|a
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|eisnan
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|emov
argument_list|(
name|b
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Zero over zero, or infinity over infinity, is a NaN.  */
if|if
condition|(
operator|(
operator|(
name|ecmp
argument_list|(
name|a
argument_list|,
name|ezero
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|ecmp
argument_list|(
name|b
argument_list|,
name|ezero
argument_list|)
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
name|eisinf
argument_list|(
name|a
argument_list|)
operator|&&
name|eisinf
argument_list|(
name|b
argument_list|)
operator|)
condition|)
block|{
name|mtherr
argument_list|(
literal|"ediv"
argument_list|,
name|INVALID
argument_list|)
expr_stmt|;
name|enan
argument_list|(
name|c
argument_list|,
name|sign
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* Infinity over anything else is infinity.  */
ifdef|#
directive|ifdef
name|INFINITY
if|if
condition|(
name|eisinf
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|einfin
argument_list|(
name|c
argument_list|)
expr_stmt|;
goto|goto
name|divsign
goto|;
block|}
comment|/* Anything else over infinity is zero.  */
if|if
condition|(
name|eisinf
argument_list|(
name|a
argument_list|)
condition|)
block|{
name|eclear
argument_list|(
name|c
argument_list|)
expr_stmt|;
goto|goto
name|divsign
goto|;
block|}
endif|#
directive|endif
name|emovi
argument_list|(
name|a
argument_list|,
name|ai
argument_list|)
expr_stmt|;
name|emovi
argument_list|(
name|b
argument_list|,
name|bi
argument_list|)
expr_stmt|;
name|lta
operator|=
name|ai
index|[
name|E
index|]
expr_stmt|;
name|ltb
operator|=
name|bi
index|[
name|E
index|]
expr_stmt|;
if|if
condition|(
name|bi
index|[
name|E
index|]
operator|==
literal|0
condition|)
block|{
comment|/* See if numerator is zero.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NI
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bi
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|ltb
operator|-=
name|enormlz
argument_list|(
name|bi
argument_list|)
expr_stmt|;
goto|goto
name|dnzro1
goto|;
block|}
block|}
name|eclear
argument_list|(
name|c
argument_list|)
expr_stmt|;
goto|goto
name|divsign
goto|;
block|}
name|dnzro1
label|:
if|if
condition|(
name|ai
index|[
name|E
index|]
operator|==
literal|0
condition|)
block|{
comment|/* possible divide by zero */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NI
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ai
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|lta
operator|-=
name|enormlz
argument_list|(
name|ai
argument_list|)
expr_stmt|;
goto|goto
name|dnzro2
goto|;
block|}
block|}
comment|/* Divide by zero is not an invalid operation.    It is a divide-by-zero operation!   */
name|einfin
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|mtherr
argument_list|(
literal|"ediv"
argument_list|,
name|SING
argument_list|)
expr_stmt|;
goto|goto
name|divsign
goto|;
block|}
name|dnzro2
label|:
name|i
operator|=
name|edivm
argument_list|(
name|ai
argument_list|,
name|bi
argument_list|)
expr_stmt|;
comment|/* calculate exponent */
name|lt
operator|=
name|ltb
operator|-
name|lta
operator|+
name|EXONE
expr_stmt|;
name|emdnorm
argument_list|(
name|bi
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
name|lt
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|emovo
argument_list|(
name|bi
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|divsign
label|:
if|if
condition|(
name|sign
ifndef|#
directive|ifndef
name|IEEE
operator|&&
operator|(
name|ecmp
argument_list|(
name|c
argument_list|,
name|ezero
argument_list|)
operator|!=
literal|0
operator|)
endif|#
directive|endif
condition|)
operator|*
operator|(
name|c
operator|+
operator|(
name|NE
operator|-
literal|1
operator|)
operator|)
operator||=
literal|0x8000
expr_stmt|;
else|else
operator|*
operator|(
name|c
operator|+
operator|(
name|NE
operator|-
literal|1
operator|)
operator|)
operator|&=
operator|~
literal|0x8000
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Multiply e-types A and B, return e-type product C.   */
end_comment

begin_function
specifier|static
name|void
name|emul
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|,
modifier|*
name|c
decl_stmt|;
end_function

begin_block
block|{
name|unsigned
name|EMUSHORT
name|ai
index|[
name|NI
index|]
decl_stmt|,
name|bi
index|[
name|NI
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|sign
decl_stmt|;
name|EMULONG
name|lt
decl_stmt|,
name|lta
decl_stmt|,
name|ltb
decl_stmt|;
comment|/* IEEE says if result is not a NaN, the sign is "-" if and only if    operands have opposite signs -- but flush -0 to 0 later if not IEEE.  */
name|sign
operator|=
name|eisneg
argument_list|(
name|a
argument_list|)
operator|^
name|eisneg
argument_list|(
name|b
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NANS
comment|/* NaN times anything is the same NaN.  */
if|if
condition|(
name|eisnan
argument_list|(
name|a
argument_list|)
condition|)
block|{
name|emov
argument_list|(
name|a
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|eisnan
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|emov
argument_list|(
name|b
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Zero times infinity is a NaN.  */
if|if
condition|(
operator|(
name|eisinf
argument_list|(
name|a
argument_list|)
operator|&&
operator|(
name|ecmp
argument_list|(
name|b
argument_list|,
name|ezero
argument_list|)
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
name|eisinf
argument_list|(
name|b
argument_list|)
operator|&&
operator|(
name|ecmp
argument_list|(
name|a
argument_list|,
name|ezero
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|mtherr
argument_list|(
literal|"emul"
argument_list|,
name|INVALID
argument_list|)
expr_stmt|;
name|enan
argument_list|(
name|c
argument_list|,
name|sign
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* Infinity times anything else is infinity.  */
ifdef|#
directive|ifdef
name|INFINITY
if|if
condition|(
name|eisinf
argument_list|(
name|a
argument_list|)
operator|||
name|eisinf
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|einfin
argument_list|(
name|c
argument_list|)
expr_stmt|;
goto|goto
name|mulsign
goto|;
block|}
endif|#
directive|endif
name|emovi
argument_list|(
name|a
argument_list|,
name|ai
argument_list|)
expr_stmt|;
name|emovi
argument_list|(
name|b
argument_list|,
name|bi
argument_list|)
expr_stmt|;
name|lta
operator|=
name|ai
index|[
name|E
index|]
expr_stmt|;
name|ltb
operator|=
name|bi
index|[
name|E
index|]
expr_stmt|;
if|if
condition|(
name|ai
index|[
name|E
index|]
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NI
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ai
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|lta
operator|-=
name|enormlz
argument_list|(
name|ai
argument_list|)
expr_stmt|;
goto|goto
name|mnzer1
goto|;
block|}
block|}
name|eclear
argument_list|(
name|c
argument_list|)
expr_stmt|;
goto|goto
name|mulsign
goto|;
block|}
name|mnzer1
label|:
if|if
condition|(
name|bi
index|[
name|E
index|]
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NI
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bi
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|ltb
operator|-=
name|enormlz
argument_list|(
name|bi
argument_list|)
expr_stmt|;
goto|goto
name|mnzer2
goto|;
block|}
block|}
name|eclear
argument_list|(
name|c
argument_list|)
expr_stmt|;
goto|goto
name|mulsign
goto|;
block|}
name|mnzer2
label|:
comment|/* Multiply significands */
name|j
operator|=
name|emulm
argument_list|(
name|ai
argument_list|,
name|bi
argument_list|)
expr_stmt|;
comment|/* calculate exponent */
name|lt
operator|=
name|lta
operator|+
name|ltb
operator|-
operator|(
name|EXONE
operator|-
literal|1
operator|)
expr_stmt|;
name|emdnorm
argument_list|(
name|bi
argument_list|,
name|j
argument_list|,
literal|0
argument_list|,
name|lt
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|emovo
argument_list|(
name|bi
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|mulsign
label|:
if|if
condition|(
name|sign
ifndef|#
directive|ifndef
name|IEEE
operator|&&
operator|(
name|ecmp
argument_list|(
name|c
argument_list|,
name|ezero
argument_list|)
operator|!=
literal|0
operator|)
endif|#
directive|endif
condition|)
operator|*
operator|(
name|c
operator|+
operator|(
name|NE
operator|-
literal|1
operator|)
operator|)
operator||=
literal|0x8000
expr_stmt|;
else|else
operator|*
operator|(
name|c
operator|+
operator|(
name|NE
operator|-
literal|1
operator|)
operator|)
operator|&=
operator|~
literal|0x8000
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Convert double precision PE to e-type Y.  */
end_comment

begin_function
specifier|static
name|void
name|e53toe
parameter_list|(
name|pe
parameter_list|,
name|y
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|pe
decl_stmt|,
decl|*
name|y
decl_stmt|;
end_function

begin_block
block|{
ifdef|#
directive|ifdef
name|DEC
name|dectoe
argument_list|(
name|pe
argument_list|,
name|y
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|IBM
name|ibmtoe
argument_list|(
name|pe
argument_list|,
name|y
argument_list|,
name|DFmode
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|C4X
name|c4xtoe
argument_list|(
name|pe
argument_list|,
name|y
argument_list|,
name|HFmode
argument_list|)
expr_stmt|;
else|#
directive|else
specifier|register
name|unsigned
name|EMUSHORT
name|r
decl_stmt|;
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|e
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|unsigned
name|EMUSHORT
name|yy
index|[
name|NI
index|]
decl_stmt|;
name|int
name|denorm
decl_stmt|,
name|k
decl_stmt|;
name|e
operator|=
name|pe
expr_stmt|;
name|denorm
operator|=
literal|0
expr_stmt|;
comment|/* flag if denormalized number */
name|ecleaz
argument_list|(
name|yy
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|REAL_WORDS_BIG_ENDIAN
condition|)
name|e
operator|+=
literal|3
expr_stmt|;
name|r
operator|=
operator|*
name|e
expr_stmt|;
name|yy
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|r
operator|&
literal|0x8000
condition|)
name|yy
index|[
literal|0
index|]
operator|=
literal|0xffff
expr_stmt|;
name|yy
index|[
name|M
index|]
operator|=
operator|(
name|r
operator|&
literal|0x0f
operator|)
operator||
literal|0x10
expr_stmt|;
name|r
operator|&=
operator|~
literal|0x800f
expr_stmt|;
comment|/* strip sign and 4 significand bits */
ifdef|#
directive|ifdef
name|INFINITY
if|if
condition|(
name|r
operator|==
literal|0x7ff0
condition|)
block|{
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
operator|!
name|REAL_WORDS_BIG_ENDIAN
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|pe
index|[
literal|3
index|]
operator|&
literal|0xf
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|pe
index|[
literal|2
index|]
operator|!=
literal|0
operator|)
operator|||
operator|(
name|pe
index|[
literal|1
index|]
operator|!=
literal|0
operator|)
operator|||
operator|(
name|pe
index|[
literal|0
index|]
operator|!=
literal|0
operator|)
condition|)
block|{
name|enan
argument_list|(
name|y
argument_list|,
name|yy
index|[
literal|0
index|]
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
operator|(
name|pe
index|[
literal|0
index|]
operator|&
literal|0xf
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|pe
index|[
literal|1
index|]
operator|!=
literal|0
operator|)
operator|||
operator|(
name|pe
index|[
literal|2
index|]
operator|!=
literal|0
operator|)
operator|||
operator|(
name|pe
index|[
literal|3
index|]
operator|!=
literal|0
operator|)
condition|)
block|{
name|enan
argument_list|(
name|y
argument_list|,
name|yy
index|[
literal|0
index|]
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
comment|/* NANS */
name|eclear
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|einfin
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|yy
index|[
literal|0
index|]
condition|)
name|eneg
argument_list|(
name|y
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* INFINITY */
name|r
operator|>>=
literal|4
expr_stmt|;
comment|/* If zero exponent, then the significand is denormalized.      So take back the understood high significand bit.  */
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
name|denorm
operator|=
literal|1
expr_stmt|;
name|yy
index|[
name|M
index|]
operator|&=
operator|~
literal|0x10
expr_stmt|;
block|}
name|r
operator|+=
name|EXONE
operator|-
literal|01777
expr_stmt|;
name|yy
index|[
name|E
index|]
operator|=
name|r
expr_stmt|;
name|p
operator|=
operator|&
name|yy
index|[
name|M
operator|+
literal|1
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE
if|if
condition|(
operator|!
name|REAL_WORDS_BIG_ENDIAN
condition|)
block|{
operator|*
name|p
operator|++
operator|=
operator|*
operator|(
operator|--
name|e
operator|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|*
operator|(
operator|--
name|e
operator|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|*
operator|(
operator|--
name|e
operator|)
expr_stmt|;
block|}
else|else
block|{
operator|++
name|e
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|*
name|e
operator|++
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|*
name|e
operator|++
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|*
name|e
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
name|eshift
argument_list|(
name|yy
argument_list|,
operator|-
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|denorm
condition|)
block|{
comment|/* If zero exponent, then normalize the significand.  */
if|if
condition|(
operator|(
name|k
operator|=
name|enormlz
argument_list|(
name|yy
argument_list|)
operator|)
operator|>
name|NBITS
condition|)
name|ecleazs
argument_list|(
name|yy
argument_list|)
expr_stmt|;
else|else
name|yy
index|[
name|E
index|]
operator|-=
call|(
name|unsigned
name|EMUSHORT
call|)
argument_list|(
name|k
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|emovo
argument_list|(
name|yy
argument_list|,
name|y
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not C4X */
endif|#
directive|endif
comment|/* not IBM */
endif|#
directive|endif
comment|/* not DEC */
block|}
end_block

begin_comment
comment|/* Convert double extended precision float PE to e type Y.  */
end_comment

begin_function
specifier|static
name|void
name|e64toe
parameter_list|(
name|pe
parameter_list|,
name|y
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|pe
decl_stmt|,
decl|*
name|y
decl_stmt|;
end_function

begin_block
block|{
name|unsigned
name|EMUSHORT
name|yy
index|[
name|NI
index|]
decl_stmt|;
name|unsigned
name|EMUSHORT
modifier|*
name|e
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|int
name|i
decl_stmt|;
name|e
operator|=
name|pe
expr_stmt|;
name|p
operator|=
name|yy
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NE
operator|-
literal|5
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* This precision is not ordinarily supported on DEC or IBM.  */
ifdef|#
directive|ifdef
name|DEC
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
operator|*
name|e
operator|++
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IBM
name|p
operator|=
operator|&
name|yy
index|[
literal|0
index|]
operator|+
operator|(
name|NE
operator|-
literal|1
operator|)
expr_stmt|;
operator|*
name|p
operator|--
operator|=
operator|*
name|e
operator|++
expr_stmt|;
operator|++
name|e
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|--
operator|=
operator|*
name|e
operator|++
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IEEE
if|if
condition|(
operator|!
name|REAL_WORDS_BIG_ENDIAN
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
operator|*
name|e
operator|++
expr_stmt|;
comment|/* For denormal long double Intel format, shift significand up one 	 -- but only if the top significand bit is zero.  A top bit of 1 	 is "pseudodenormal" when the exponent is zero.  */
if|if
condition|(
operator|(
name|yy
index|[
name|NE
operator|-
literal|1
index|]
operator|&
literal|0x7fff
operator|)
operator|==
literal|0
operator|&&
operator|(
name|yy
index|[
name|NE
operator|-
literal|2
index|]
operator|&
literal|0x8000
operator|)
operator|==
literal|0
condition|)
block|{
name|unsigned
name|EMUSHORT
name|temp
index|[
name|NI
index|]
decl_stmt|;
name|emovi
argument_list|(
name|yy
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|eshup1
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|emovo
argument_list|(
name|temp
argument_list|,
name|y
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|p
operator|=
operator|&
name|yy
index|[
literal|0
index|]
operator|+
operator|(
name|NE
operator|-
literal|1
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ARM_EXTENDED_IEEE_FORMAT
comment|/* For ARMs, the exponent is in the lowest 15 bits of the word.  */
operator|*
name|p
operator|--
operator|=
operator|(
name|e
index|[
literal|0
index|]
operator|&
literal|0x8000
operator|)
operator||
operator|(
name|e
index|[
literal|1
index|]
operator|&
literal|0x7ffff
operator|)
expr_stmt|;
name|e
operator|+=
literal|2
expr_stmt|;
else|#
directive|else
operator|*
name|p
operator|--
operator|=
operator|*
name|e
operator|++
expr_stmt|;
operator|++
name|e
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|--
operator|=
operator|*
name|e
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INFINITY
comment|/* Point to the exponent field and check max exponent cases.  */
name|p
operator|=
operator|&
name|yy
index|[
name|NE
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|p
operator|&
literal|0x7fff
operator|)
operator|==
literal|0x7fff
condition|)
block|{
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
operator|!
name|REAL_WORDS_BIG_ENDIAN
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|i
operator|!=
literal|3
operator|&&
name|pe
index|[
name|i
index|]
operator|!=
literal|0
operator|)
comment|/* Anything but 0x8000 here, including 0, is a NaN.  */
operator|||
operator|(
name|i
operator|==
literal|3
operator|&&
name|pe
index|[
name|i
index|]
operator|!=
literal|0x8000
operator|)
condition|)
block|{
name|enan
argument_list|(
name|y
argument_list|,
operator|(
operator|*
name|p
operator|&
literal|0x8000
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|ARM_EXTENDED_IEEE_FORMAT
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<=
literal|5
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pe
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|enan
argument_list|(
name|y
argument_list|,
operator|(
operator|*
name|p
operator|&
literal|0x8000
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|#
directive|else
comment|/* not ARM */
comment|/* In Motorola extended precision format, the most significant 	     bit of an infinity mantissa could be either 1 or 0.  It is 	     the lower order bits that tell whether the value is a NaN.  */
if|if
condition|(
operator|(
name|pe
index|[
literal|2
index|]
operator|&
literal|0x7fff
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|bigend_nan
goto|;
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|<=
literal|5
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pe
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|bigend_nan
label|:
name|enan
argument_list|(
name|y
argument_list|,
operator|(
operator|*
name|p
operator|&
literal|0x8000
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
comment|/* not ARM */
block|}
endif|#
directive|endif
comment|/* NANS */
name|eclear
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|einfin
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|&
literal|0x8000
condition|)
name|eneg
argument_list|(
name|y
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* INFINITY */
name|p
operator|=
name|yy
expr_stmt|;
name|q
operator|=
name|y
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NE
condition|;
name|i
operator|++
control|)
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Convert 128-bit long double precision float PE to e type Y.  */
end_comment

begin_function
specifier|static
name|void
name|e113toe
parameter_list|(
name|pe
parameter_list|,
name|y
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|pe
decl_stmt|,
decl|*
name|y
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|unsigned
name|EMUSHORT
name|r
decl_stmt|;
name|unsigned
name|EMUSHORT
modifier|*
name|e
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|unsigned
name|EMUSHORT
name|yy
index|[
name|NI
index|]
decl_stmt|;
name|int
name|denorm
decl_stmt|,
name|i
decl_stmt|;
name|e
operator|=
name|pe
expr_stmt|;
name|denorm
operator|=
literal|0
expr_stmt|;
name|ecleaz
argument_list|(
name|yy
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE
if|if
condition|(
operator|!
name|REAL_WORDS_BIG_ENDIAN
condition|)
name|e
operator|+=
literal|7
expr_stmt|;
endif|#
directive|endif
name|r
operator|=
operator|*
name|e
expr_stmt|;
name|yy
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|r
operator|&
literal|0x8000
condition|)
name|yy
index|[
literal|0
index|]
operator|=
literal|0xffff
expr_stmt|;
name|r
operator|&=
literal|0x7fff
expr_stmt|;
ifdef|#
directive|ifdef
name|INFINITY
if|if
condition|(
name|r
operator|==
literal|0x7fff
condition|)
block|{
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
operator|!
name|REAL_WORDS_BIG_ENDIAN
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pe
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|enan
argument_list|(
name|y
argument_list|,
name|yy
index|[
literal|0
index|]
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pe
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|enan
argument_list|(
name|y
argument_list|,
name|yy
index|[
literal|0
index|]
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* NANS */
name|eclear
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|einfin
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|yy
index|[
literal|0
index|]
condition|)
name|eneg
argument_list|(
name|y
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* INFINITY */
name|yy
index|[
name|E
index|]
operator|=
name|r
expr_stmt|;
name|p
operator|=
operator|&
name|yy
index|[
name|M
operator|+
literal|1
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE
if|if
condition|(
operator|!
name|REAL_WORDS_BIG_ENDIAN
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
operator|*
operator|(
operator|--
name|e
operator|)
expr_stmt|;
block|}
else|else
block|{
operator|++
name|e
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
operator|*
name|e
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* If denormal, remove the implied bit; else shift down 1.  */
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
name|yy
index|[
name|M
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|yy
index|[
name|M
index|]
operator|=
literal|1
expr_stmt|;
name|eshift
argument_list|(
name|yy
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|emovo
argument_list|(
name|yy
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Convert single precision float PE to e type Y.  */
end_comment

begin_function
specifier|static
name|void
name|e24toe
parameter_list|(
name|pe
parameter_list|,
name|y
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|pe
decl_stmt|,
decl|*
name|y
decl_stmt|;
end_function

begin_block
block|{
ifdef|#
directive|ifdef
name|IBM
name|ibmtoe
argument_list|(
name|pe
argument_list|,
name|y
argument_list|,
name|SFmode
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|C4X
name|c4xtoe
argument_list|(
name|pe
argument_list|,
name|y
argument_list|,
name|QFmode
argument_list|)
expr_stmt|;
else|#
directive|else
specifier|register
name|unsigned
name|EMUSHORT
name|r
decl_stmt|;
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|e
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|unsigned
name|EMUSHORT
name|yy
index|[
name|NI
index|]
decl_stmt|;
name|int
name|denorm
decl_stmt|,
name|k
decl_stmt|;
name|e
operator|=
name|pe
expr_stmt|;
name|denorm
operator|=
literal|0
expr_stmt|;
comment|/* flag if denormalized number */
name|ecleaz
argument_list|(
name|yy
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE
if|if
condition|(
operator|!
name|REAL_WORDS_BIG_ENDIAN
condition|)
name|e
operator|+=
literal|1
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEC
name|e
operator|+=
literal|1
expr_stmt|;
endif|#
directive|endif
name|r
operator|=
operator|*
name|e
expr_stmt|;
name|yy
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|r
operator|&
literal|0x8000
condition|)
name|yy
index|[
literal|0
index|]
operator|=
literal|0xffff
expr_stmt|;
name|yy
index|[
name|M
index|]
operator|=
operator|(
name|r
operator|&
literal|0x7f
operator|)
operator||
literal|0200
expr_stmt|;
name|r
operator|&=
operator|~
literal|0x807f
expr_stmt|;
comment|/* strip sign and 7 significand bits */
ifdef|#
directive|ifdef
name|INFINITY
if|if
condition|(
name|r
operator|==
literal|0x7f80
condition|)
block|{
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
name|REAL_WORDS_BIG_ENDIAN
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|pe
index|[
literal|0
index|]
operator|&
literal|0x7f
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|pe
index|[
literal|1
index|]
operator|!=
literal|0
operator|)
condition|)
block|{
name|enan
argument_list|(
name|y
argument_list|,
name|yy
index|[
literal|0
index|]
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
operator|(
name|pe
index|[
literal|1
index|]
operator|&
literal|0x7f
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|pe
index|[
literal|0
index|]
operator|!=
literal|0
operator|)
condition|)
block|{
name|enan
argument_list|(
name|y
argument_list|,
name|yy
index|[
literal|0
index|]
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
comment|/* NANS */
name|eclear
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|einfin
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|yy
index|[
literal|0
index|]
condition|)
name|eneg
argument_list|(
name|y
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* INFINITY */
name|r
operator|>>=
literal|7
expr_stmt|;
comment|/* If zero exponent, then the significand is denormalized.      So take back the understood high significand bit.  */
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
name|denorm
operator|=
literal|1
expr_stmt|;
name|yy
index|[
name|M
index|]
operator|&=
operator|~
literal|0200
expr_stmt|;
block|}
name|r
operator|+=
name|EXONE
operator|-
literal|0177
expr_stmt|;
name|yy
index|[
name|E
index|]
operator|=
name|r
expr_stmt|;
name|p
operator|=
operator|&
name|yy
index|[
name|M
operator|+
literal|1
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|DEC
operator|*
name|p
operator|++
operator|=
operator|*
operator|(
operator|--
name|e
operator|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IEEE
if|if
condition|(
operator|!
name|REAL_WORDS_BIG_ENDIAN
condition|)
operator|*
name|p
operator|++
operator|=
operator|*
operator|(
operator|--
name|e
operator|)
expr_stmt|;
else|else
block|{
operator|++
name|e
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|*
name|e
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
name|eshift
argument_list|(
name|yy
argument_list|,
operator|-
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|denorm
condition|)
block|{
comment|/* if zero exponent, then normalize the significand */
if|if
condition|(
operator|(
name|k
operator|=
name|enormlz
argument_list|(
name|yy
argument_list|)
operator|)
operator|>
name|NBITS
condition|)
name|ecleazs
argument_list|(
name|yy
argument_list|)
expr_stmt|;
else|else
name|yy
index|[
name|E
index|]
operator|-=
call|(
name|unsigned
name|EMUSHORT
call|)
argument_list|(
name|k
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|emovo
argument_list|(
name|yy
argument_list|,
name|y
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not C4X */
endif|#
directive|endif
comment|/* not IBM */
block|}
end_block

begin_comment
comment|/* Convert e-type X to IEEE 128-bit long double format E.  */
end_comment

begin_function
specifier|static
name|void
name|etoe113
parameter_list|(
name|x
parameter_list|,
name|e
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|,
decl|*
name|e
decl_stmt|;
end_function

begin_block
block|{
name|unsigned
name|EMUSHORT
name|xi
index|[
name|NI
index|]
decl_stmt|;
name|EMULONG
name|exp
decl_stmt|;
name|int
name|rndsav
decl_stmt|;
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
name|eisnan
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|make_nan
argument_list|(
name|e
argument_list|,
name|eisneg
argument_list|(
name|x
argument_list|)
argument_list|,
name|TFmode
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|emovi
argument_list|(
name|x
argument_list|,
name|xi
argument_list|)
expr_stmt|;
name|exp
operator|=
operator|(
name|EMULONG
operator|)
name|xi
index|[
name|E
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|INFINITY
if|if
condition|(
name|eisinf
argument_list|(
name|x
argument_list|)
condition|)
goto|goto
name|nonorm
goto|;
endif|#
directive|endif
comment|/* round off to nearest or even */
name|rndsav
operator|=
name|rndprc
expr_stmt|;
name|rndprc
operator|=
literal|113
expr_stmt|;
name|emdnorm
argument_list|(
name|xi
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|exp
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|rndprc
operator|=
name|rndsav
expr_stmt|;
name|nonorm
label|:
name|toe113
argument_list|(
name|xi
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Convert exploded e-type X, that has already been rounded to    113-bit precision, to IEEE 128-bit long double format Y.  */
end_comment

begin_function
specifier|static
name|void
name|toe113
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|unsigned
name|EMUSHORT
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
name|eiisnan
argument_list|(
name|a
argument_list|)
condition|)
block|{
name|make_nan
argument_list|(
name|b
argument_list|,
name|eiisneg
argument_list|(
name|a
argument_list|)
argument_list|,
name|TFmode
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|p
operator|=
name|a
expr_stmt|;
if|if
condition|(
name|REAL_WORDS_BIG_ENDIAN
condition|)
name|q
operator|=
name|b
expr_stmt|;
else|else
name|q
operator|=
name|b
operator|+
literal|7
expr_stmt|;
comment|/* point to output exponent */
comment|/* If not denormal, delete the implied bit.  */
if|if
condition|(
name|a
index|[
name|E
index|]
operator|!=
literal|0
condition|)
block|{
name|eshup1
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
comment|/* combine sign and exponent */
name|i
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|REAL_WORDS_BIG_ENDIAN
condition|)
block|{
if|if
condition|(
name|i
condition|)
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
operator||
literal|0x8000
expr_stmt|;
else|else
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|i
condition|)
operator|*
name|q
operator|--
operator|=
operator|*
name|p
operator|++
operator||
literal|0x8000
expr_stmt|;
else|else
operator|*
name|q
operator|--
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
comment|/* skip over guard word */
operator|++
name|p
expr_stmt|;
comment|/* move the significand */
if|if
condition|(
name|REAL_WORDS_BIG_ENDIAN
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
operator|*
name|q
operator|--
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Convert e-type X to IEEE double extended format E.  */
end_comment

begin_function
specifier|static
name|void
name|etoe64
parameter_list|(
name|x
parameter_list|,
name|e
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|,
decl|*
name|e
decl_stmt|;
end_function

begin_block
block|{
name|unsigned
name|EMUSHORT
name|xi
index|[
name|NI
index|]
decl_stmt|;
name|EMULONG
name|exp
decl_stmt|;
name|int
name|rndsav
decl_stmt|;
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
name|eisnan
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|make_nan
argument_list|(
name|e
argument_list|,
name|eisneg
argument_list|(
name|x
argument_list|)
argument_list|,
name|XFmode
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|emovi
argument_list|(
name|x
argument_list|,
name|xi
argument_list|)
expr_stmt|;
comment|/* adjust exponent for offset */
name|exp
operator|=
operator|(
name|EMULONG
operator|)
name|xi
index|[
name|E
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|INFINITY
if|if
condition|(
name|eisinf
argument_list|(
name|x
argument_list|)
condition|)
goto|goto
name|nonorm
goto|;
endif|#
directive|endif
comment|/* round off to nearest or even */
name|rndsav
operator|=
name|rndprc
expr_stmt|;
name|rndprc
operator|=
literal|64
expr_stmt|;
name|emdnorm
argument_list|(
name|xi
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|exp
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|rndprc
operator|=
name|rndsav
expr_stmt|;
name|nonorm
label|:
name|toe64
argument_list|(
name|xi
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Convert exploded e-type X, that has already been rounded to    64-bit precision, to IEEE double extended format Y.  */
end_comment

begin_function
specifier|static
name|void
name|toe64
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|unsigned
name|EMUSHORT
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
name|eiisnan
argument_list|(
name|a
argument_list|)
condition|)
block|{
name|make_nan
argument_list|(
name|b
argument_list|,
name|eiisneg
argument_list|(
name|a
argument_list|)
argument_list|,
name|XFmode
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* Shift denormal long double Intel format significand down one bit.  */
if|if
condition|(
operator|(
name|a
index|[
name|E
index|]
operator|==
literal|0
operator|)
operator|&&
operator|!
name|REAL_WORDS_BIG_ENDIAN
condition|)
name|eshdn1
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|p
operator|=
name|a
expr_stmt|;
ifdef|#
directive|ifdef
name|IBM
name|q
operator|=
name|b
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEC
name|q
operator|=
name|b
operator|+
literal|4
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IEEE
if|if
condition|(
name|REAL_WORDS_BIG_ENDIAN
condition|)
name|q
operator|=
name|b
expr_stmt|;
else|else
block|{
name|q
operator|=
name|b
operator|+
literal|4
expr_stmt|;
comment|/* point to output exponent */
if|#
directive|if
name|LONG_DOUBLE_TYPE_SIZE
operator|==
literal|96
comment|/* Clear the last two bytes of 12-byte Intel format */
operator|*
operator|(
name|q
operator|+
literal|1
operator|)
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* combine sign and exponent */
name|i
operator|=
operator|*
name|p
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|IBM
if|if
condition|(
name|i
condition|)
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
operator||
literal|0x8000
expr_stmt|;
else|else
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEC
if|if
condition|(
name|i
condition|)
operator|*
name|q
operator|--
operator|=
operator|*
name|p
operator|++
operator||
literal|0x8000
expr_stmt|;
else|else
operator|*
name|q
operator|--
operator|=
operator|*
name|p
operator|++
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IEEE
if|if
condition|(
name|REAL_WORDS_BIG_ENDIAN
condition|)
block|{
ifdef|#
directive|ifdef
name|ARM_EXTENDED_IEEE_FORMAT
comment|/* The exponent is in the lowest 15 bits of the first word.  */
operator|*
name|q
operator|++
operator|=
name|i
condition|?
literal|0x8000
else|:
literal|0
expr_stmt|;
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|i
condition|)
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
operator||
literal|0x8000
expr_stmt|;
else|else
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
if|if
condition|(
name|i
condition|)
operator|*
name|q
operator|--
operator|=
operator|*
name|p
operator|++
operator||
literal|0x8000
expr_stmt|;
else|else
operator|*
name|q
operator|--
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* skip over guard word */
operator|++
name|p
expr_stmt|;
comment|/* move the significand */
ifdef|#
directive|ifdef
name|IBM
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEC
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|*
name|q
operator|--
operator|=
operator|*
name|p
operator|++
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IEEE
if|if
condition|(
name|REAL_WORDS_BIG_ENDIAN
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|INFINITY
if|if
condition|(
name|eiisinf
argument_list|(
name|a
argument_list|)
condition|)
block|{
comment|/* Intel long double infinity significand.  */
operator|*
name|q
operator|--
operator|=
literal|0x8000
expr_stmt|;
operator|*
name|q
operator|--
operator|=
literal|0
expr_stmt|;
operator|*
name|q
operator|--
operator|=
literal|0
expr_stmt|;
operator|*
name|q
operator|=
literal|0
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|*
name|q
operator|--
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/* e type to double precision.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEC
end_ifdef

begin_comment
comment|/* Convert e-type X to DEC-format double E.  */
end_comment

begin_function
specifier|static
name|void
name|etoe53
parameter_list|(
name|x
parameter_list|,
name|e
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|,
decl|*
name|e
decl_stmt|;
end_function

begin_block
block|{
name|etodec
argument_list|(
name|x
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|/* see etodec.c */
block|}
end_block

begin_comment
comment|/* Convert exploded e-type X, that has already been rounded to    56-bit double precision, to DEC double Y.  */
end_comment

begin_function
specifier|static
name|void
name|toe53
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|,
decl|*
name|y
decl_stmt|;
end_function

begin_block
block|{
name|todec
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|IBM
end_ifdef

begin_comment
comment|/* Convert e-type X to IBM 370-format double E.  */
end_comment

begin_function
specifier|static
name|void
name|etoe53
parameter_list|(
name|x
parameter_list|,
name|e
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|,
decl|*
name|e
decl_stmt|;
end_function

begin_block
block|{
name|etoibm
argument_list|(
name|x
argument_list|,
name|e
argument_list|,
name|DFmode
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Convert exploded e-type X, that has already been rounded to    56-bit precision, to IBM 370 double Y.  */
end_comment

begin_function
specifier|static
name|void
name|toe53
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|,
decl|*
name|y
decl_stmt|;
end_function

begin_block
block|{
name|toibm
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|DFmode
argument_list|)
expr_stmt|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* it's neither DEC nor IBM */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|C4X
end_ifdef

begin_comment
comment|/* Convert e-type X to C4X-format long double E.  */
end_comment

begin_function
specifier|static
name|void
name|etoe53
parameter_list|(
name|x
parameter_list|,
name|e
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|,
decl|*
name|e
decl_stmt|;
end_function

begin_block
block|{
name|etoc4x
argument_list|(
name|x
argument_list|,
name|e
argument_list|,
name|HFmode
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Convert exploded e-type X, that has already been rounded to    56-bit precision, to IBM 370 double Y.  */
end_comment

begin_function
specifier|static
name|void
name|toe53
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|,
decl|*
name|y
decl_stmt|;
end_function

begin_block
block|{
name|toc4x
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|HFmode
argument_list|)
expr_stmt|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* it's neither DEC nor IBM nor C4X */
end_comment

begin_comment
comment|/* Convert e-type X to IEEE double E.  */
end_comment

begin_function
specifier|static
name|void
name|etoe53
parameter_list|(
name|x
parameter_list|,
name|e
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|,
decl|*
name|e
decl_stmt|;
end_function

begin_block
block|{
name|unsigned
name|EMUSHORT
name|xi
index|[
name|NI
index|]
decl_stmt|;
name|EMULONG
name|exp
decl_stmt|;
name|int
name|rndsav
decl_stmt|;
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
name|eisnan
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|make_nan
argument_list|(
name|e
argument_list|,
name|eisneg
argument_list|(
name|x
argument_list|)
argument_list|,
name|DFmode
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|emovi
argument_list|(
name|x
argument_list|,
name|xi
argument_list|)
expr_stmt|;
comment|/* adjust exponent for offsets */
name|exp
operator|=
operator|(
name|EMULONG
operator|)
name|xi
index|[
name|E
index|]
operator|-
operator|(
name|EXONE
operator|-
literal|0x3ff
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INFINITY
if|if
condition|(
name|eisinf
argument_list|(
name|x
argument_list|)
condition|)
goto|goto
name|nonorm
goto|;
endif|#
directive|endif
comment|/* round off to nearest or even */
name|rndsav
operator|=
name|rndprc
expr_stmt|;
name|rndprc
operator|=
literal|53
expr_stmt|;
name|emdnorm
argument_list|(
name|xi
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|exp
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|rndprc
operator|=
name|rndsav
expr_stmt|;
name|nonorm
label|:
name|toe53
argument_list|(
name|xi
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Convert exploded e-type X, that has already been rounded to    53-bit precision, to IEEE double Y.  */
end_comment

begin_function
specifier|static
name|void
name|toe53
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|,
decl|*
name|y
decl_stmt|;
end_function

begin_block
block|{
name|unsigned
name|EMUSHORT
name|i
decl_stmt|;
name|unsigned
name|EMUSHORT
modifier|*
name|p
decl_stmt|;
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
name|eiisnan
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|make_nan
argument_list|(
name|y
argument_list|,
name|eiisneg
argument_list|(
name|x
argument_list|)
argument_list|,
name|DFmode
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|p
operator|=
operator|&
name|x
index|[
literal|0
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE
if|if
condition|(
operator|!
name|REAL_WORDS_BIG_ENDIAN
condition|)
name|y
operator|+=
literal|3
expr_stmt|;
endif|#
directive|endif
operator|*
name|y
operator|=
literal|0
expr_stmt|;
comment|/* output high order */
if|if
condition|(
operator|*
name|p
operator|++
condition|)
operator|*
name|y
operator|=
literal|0x8000
expr_stmt|;
comment|/* output sign bit */
name|i
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>=
operator|(
name|unsigned
name|int
operator|)
literal|2047
condition|)
block|{
comment|/* Saturate at largest number less than infinity.  */
ifdef|#
directive|ifdef
name|INFINITY
operator|*
name|y
operator||=
literal|0x7ff0
expr_stmt|;
if|if
condition|(
operator|!
name|REAL_WORDS_BIG_ENDIAN
condition|)
block|{
operator|*
operator|(
operator|--
name|y
operator|)
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
operator|--
name|y
operator|)
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
operator|--
name|y
operator|)
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|++
name|y
expr_stmt|;
operator|*
name|y
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|y
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|y
operator|++
operator|=
literal|0
expr_stmt|;
block|}
else|#
directive|else
operator|*
name|y
operator||=
operator|(
name|unsigned
name|EMUSHORT
operator|)
literal|0x7fef
expr_stmt|;
if|if
condition|(
operator|!
name|REAL_WORDS_BIG_ENDIAN
condition|)
block|{
operator|*
operator|(
operator|--
name|y
operator|)
operator|=
literal|0xffff
expr_stmt|;
operator|*
operator|(
operator|--
name|y
operator|)
operator|=
literal|0xffff
expr_stmt|;
operator|*
operator|(
operator|--
name|y
operator|)
operator|=
literal|0xffff
expr_stmt|;
block|}
else|else
block|{
operator|++
name|y
expr_stmt|;
operator|*
name|y
operator|++
operator|=
literal|0xffff
expr_stmt|;
operator|*
name|y
operator|++
operator|=
literal|0xffff
expr_stmt|;
operator|*
name|y
operator|++
operator|=
literal|0xffff
expr_stmt|;
block|}
endif|#
directive|endif
return|return;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|eshift
argument_list|(
name|x
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|i
operator|<<=
literal|4
expr_stmt|;
name|eshift
argument_list|(
name|x
argument_list|,
literal|5
argument_list|)
expr_stmt|;
block|}
name|i
operator||=
operator|*
name|p
operator|++
operator|&
operator|(
name|unsigned
name|EMUSHORT
operator|)
literal|0x0f
expr_stmt|;
comment|/* *p = xi[M] */
operator|*
name|y
operator||=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|i
expr_stmt|;
comment|/* high order output already has sign bit set */
if|if
condition|(
operator|!
name|REAL_WORDS_BIG_ENDIAN
condition|)
block|{
operator|*
operator|(
operator|--
name|y
operator|)
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
operator|(
operator|--
name|y
operator|)
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
operator|(
operator|--
name|y
operator|)
operator|=
operator|*
name|p
expr_stmt|;
block|}
else|else
block|{
operator|++
name|y
expr_stmt|;
operator|*
name|y
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|y
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|y
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not C4X */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not IBM */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not DEC */
end_comment

begin_comment
comment|/* e type to single precision.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|IBM
end_ifdef

begin_comment
comment|/* Convert e-type X to IBM 370 float E.  */
end_comment

begin_function
specifier|static
name|void
name|etoe24
parameter_list|(
name|x
parameter_list|,
name|e
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|,
decl|*
name|e
decl_stmt|;
end_function

begin_block
block|{
name|etoibm
argument_list|(
name|x
argument_list|,
name|e
argument_list|,
name|SFmode
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Convert exploded e-type X, that has already been rounded to    float precision, to IBM 370 float Y.  */
end_comment

begin_function
specifier|static
name|void
name|toe24
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|,
decl|*
name|y
decl_stmt|;
end_function

begin_block
block|{
name|toibm
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|SFmode
argument_list|)
expr_stmt|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|C4X
end_ifdef

begin_comment
comment|/* Convert e-type X to C4X float E.  */
end_comment

begin_function
specifier|static
name|void
name|etoe24
parameter_list|(
name|x
parameter_list|,
name|e
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|,
decl|*
name|e
decl_stmt|;
end_function

begin_block
block|{
name|etoc4x
argument_list|(
name|x
argument_list|,
name|e
argument_list|,
name|QFmode
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Convert exploded e-type X, that has already been rounded to    float precision, to IBM 370 float Y.  */
end_comment

begin_function
specifier|static
name|void
name|toe24
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|,
decl|*
name|y
decl_stmt|;
end_function

begin_block
block|{
name|toc4x
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|QFmode
argument_list|)
expr_stmt|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Convert e-type X to IEEE float E.  DEC float is the same as IEEE float.  */
end_comment

begin_function
specifier|static
name|void
name|etoe24
parameter_list|(
name|x
parameter_list|,
name|e
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|,
decl|*
name|e
decl_stmt|;
end_function

begin_block
block|{
name|EMULONG
name|exp
decl_stmt|;
name|unsigned
name|EMUSHORT
name|xi
index|[
name|NI
index|]
decl_stmt|;
name|int
name|rndsav
decl_stmt|;
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
name|eisnan
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|make_nan
argument_list|(
name|e
argument_list|,
name|eisneg
argument_list|(
name|x
argument_list|)
argument_list|,
name|SFmode
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|emovi
argument_list|(
name|x
argument_list|,
name|xi
argument_list|)
expr_stmt|;
comment|/* adjust exponent for offsets */
name|exp
operator|=
operator|(
name|EMULONG
operator|)
name|xi
index|[
name|E
index|]
operator|-
operator|(
name|EXONE
operator|-
literal|0177
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INFINITY
if|if
condition|(
name|eisinf
argument_list|(
name|x
argument_list|)
condition|)
goto|goto
name|nonorm
goto|;
endif|#
directive|endif
comment|/* round off to nearest or even */
name|rndsav
operator|=
name|rndprc
expr_stmt|;
name|rndprc
operator|=
literal|24
expr_stmt|;
name|emdnorm
argument_list|(
name|xi
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|exp
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|rndprc
operator|=
name|rndsav
expr_stmt|;
name|nonorm
label|:
name|toe24
argument_list|(
name|xi
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Convert exploded e-type X, that has already been rounded to    float precision, to IEEE float Y.  */
end_comment

begin_function
specifier|static
name|void
name|toe24
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|,
decl|*
name|y
decl_stmt|;
end_function

begin_block
block|{
name|unsigned
name|EMUSHORT
name|i
decl_stmt|;
name|unsigned
name|EMUSHORT
modifier|*
name|p
decl_stmt|;
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
name|eiisnan
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|make_nan
argument_list|(
name|y
argument_list|,
name|eiisneg
argument_list|(
name|x
argument_list|)
argument_list|,
name|SFmode
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|p
operator|=
operator|&
name|x
index|[
literal|0
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE
if|if
condition|(
operator|!
name|REAL_WORDS_BIG_ENDIAN
condition|)
name|y
operator|+=
literal|1
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEC
name|y
operator|+=
literal|1
expr_stmt|;
endif|#
directive|endif
operator|*
name|y
operator|=
literal|0
expr_stmt|;
comment|/* output high order */
if|if
condition|(
operator|*
name|p
operator|++
condition|)
operator|*
name|y
operator|=
literal|0x8000
expr_stmt|;
comment|/* output sign bit */
name|i
operator|=
operator|*
name|p
operator|++
expr_stmt|;
comment|/* Handle overflow cases.  */
if|if
condition|(
name|i
operator|>=
literal|255
condition|)
block|{
ifdef|#
directive|ifdef
name|INFINITY
operator|*
name|y
operator||=
operator|(
name|unsigned
name|EMUSHORT
operator|)
literal|0x7f80
expr_stmt|;
ifdef|#
directive|ifdef
name|DEC
operator|*
operator|(
operator|--
name|y
operator|)
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IEEE
if|if
condition|(
operator|!
name|REAL_WORDS_BIG_ENDIAN
condition|)
operator|*
operator|(
operator|--
name|y
operator|)
operator|=
literal|0
expr_stmt|;
else|else
block|{
operator|++
name|y
expr_stmt|;
operator|*
name|y
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
else|#
directive|else
comment|/* no INFINITY */
operator|*
name|y
operator||=
operator|(
name|unsigned
name|EMUSHORT
operator|)
literal|0x7f7f
expr_stmt|;
ifdef|#
directive|ifdef
name|DEC
operator|*
operator|(
operator|--
name|y
operator|)
operator|=
literal|0xffff
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IEEE
if|if
condition|(
operator|!
name|REAL_WORDS_BIG_ENDIAN
condition|)
operator|*
operator|(
operator|--
name|y
operator|)
operator|=
literal|0xffff
expr_stmt|;
else|else
block|{
operator|++
name|y
expr_stmt|;
operator|*
name|y
operator|=
literal|0xffff
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ERANGE
name|errno
operator|=
name|ERANGE
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* no INFINITY */
return|return;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|eshift
argument_list|(
name|x
argument_list|,
literal|7
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|i
operator|<<=
literal|7
expr_stmt|;
name|eshift
argument_list|(
name|x
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
name|i
operator||=
operator|*
name|p
operator|++
operator|&
operator|(
name|unsigned
name|EMUSHORT
operator|)
literal|0x7f
expr_stmt|;
comment|/* *p = xi[M] */
comment|/* High order output already has sign bit set.  */
operator|*
name|y
operator||=
name|i
expr_stmt|;
ifdef|#
directive|ifdef
name|DEC
operator|*
operator|(
operator|--
name|y
operator|)
operator|=
operator|*
name|p
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IEEE
if|if
condition|(
operator|!
name|REAL_WORDS_BIG_ENDIAN
condition|)
operator|*
operator|(
operator|--
name|y
operator|)
operator|=
operator|*
name|p
expr_stmt|;
else|else
block|{
operator|++
name|y
expr_stmt|;
operator|*
name|y
operator|=
operator|*
name|p
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not C4X */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not IBM */
end_comment

begin_comment
comment|/* Compare two e type numbers.    Return +1 if a> b            0 if a == b           -1 if a< b           -2 if either a or b is a NaN.  */
end_comment

begin_function
specifier|static
name|int
name|ecmp
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|;
end_function

begin_block
block|{
name|unsigned
name|EMUSHORT
name|ai
index|[
name|NI
index|]
decl_stmt|,
name|bi
index|[
name|NI
index|]
decl_stmt|;
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|msign
decl_stmt|;
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
name|eisnan
argument_list|(
name|a
argument_list|)
operator|||
name|eisnan
argument_list|(
name|b
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|2
operator|)
return|;
endif|#
directive|endif
name|emovi
argument_list|(
name|a
argument_list|,
name|ai
argument_list|)
expr_stmt|;
name|p
operator|=
name|ai
expr_stmt|;
name|emovi
argument_list|(
name|b
argument_list|,
name|bi
argument_list|)
expr_stmt|;
name|q
operator|=
name|bi
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
operator|*
name|q
condition|)
block|{
comment|/* the signs are different */
comment|/* -0 equals + 0 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NI
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ai
index|[
name|i
index|]
operator|!=
literal|0
condition|)
goto|goto
name|nzro
goto|;
if|if
condition|(
name|bi
index|[
name|i
index|]
operator|!=
literal|0
condition|)
goto|goto
name|nzro
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|nzro
label|:
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* both are the same sign */
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
name|msign
operator|=
literal|1
expr_stmt|;
else|else
name|msign
operator|=
operator|-
literal|1
expr_stmt|;
name|i
operator|=
name|NI
operator|-
literal|1
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
operator|*
name|q
operator|++
condition|)
block|{
goto|goto
name|diff
goto|;
block|}
block|}
do|while
condition|(
operator|--
name|i
operator|>
literal|0
condition|)
do|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* equality */
name|diff
label|:
if|if
condition|(
operator|*
operator|(
operator|--
name|p
operator|)
operator|>
operator|*
operator|(
operator|--
name|q
operator|)
condition|)
return|return
operator|(
name|msign
operator|)
return|;
comment|/* p is bigger */
else|else
return|return
operator|(
operator|-
name|msign
operator|)
return|;
comment|/* p is littler */
block|}
end_block

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Find e-type nearest integer to X, as floor (X + 0.5).  */
end_comment

begin_endif
unit|static void eround (x, y)      unsigned EMUSHORT *x, *y; {   eadd (ehalf, x, y);   efloor (y, y); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_comment
comment|/* Convert HOST_WIDE_INT LP to e type Y.  */
end_comment

begin_function
specifier|static
name|void
name|ltoe
parameter_list|(
name|lp
parameter_list|,
name|y
parameter_list|)
name|HOST_WIDE_INT
modifier|*
name|lp
decl_stmt|;
name|unsigned
name|EMUSHORT
modifier|*
name|y
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|yi
index|[
name|NI
index|]
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|ll
decl_stmt|;
name|int
name|k
decl_stmt|;
name|ecleaz
argument_list|(
name|yi
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|lp
operator|<
literal|0
condition|)
block|{
comment|/* make it positive */
name|ll
operator|=
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
operator|(
operator|*
name|lp
operator|)
argument_list|)
expr_stmt|;
name|yi
index|[
literal|0
index|]
operator|=
literal|0xffff
expr_stmt|;
comment|/* put correct sign in the e type number */
block|}
else|else
block|{
name|ll
operator|=
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
operator|*
name|lp
argument_list|)
expr_stmt|;
block|}
comment|/* move the long integer to yi significand area */
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|64
name|yi
index|[
name|M
index|]
operator|=
call|(
name|unsigned
name|EMUSHORT
call|)
argument_list|(
name|ll
operator|>>
literal|48
argument_list|)
expr_stmt|;
name|yi
index|[
name|M
operator|+
literal|1
index|]
operator|=
call|(
name|unsigned
name|EMUSHORT
call|)
argument_list|(
name|ll
operator|>>
literal|32
argument_list|)
expr_stmt|;
name|yi
index|[
name|M
operator|+
literal|2
index|]
operator|=
call|(
name|unsigned
name|EMUSHORT
call|)
argument_list|(
name|ll
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|yi
index|[
name|M
operator|+
literal|3
index|]
operator|=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|ll
expr_stmt|;
name|yi
index|[
name|E
index|]
operator|=
name|EXONE
operator|+
literal|47
expr_stmt|;
comment|/* exponent if normalize shift count were 0 */
else|#
directive|else
name|yi
index|[
name|M
index|]
operator|=
call|(
name|unsigned
name|EMUSHORT
call|)
argument_list|(
name|ll
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|yi
index|[
name|M
operator|+
literal|1
index|]
operator|=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|ll
expr_stmt|;
name|yi
index|[
name|E
index|]
operator|=
name|EXONE
operator|+
literal|15
expr_stmt|;
comment|/* exponent if normalize shift count were 0 */
endif|#
directive|endif
if|if
condition|(
operator|(
name|k
operator|=
name|enormlz
argument_list|(
name|yi
argument_list|)
operator|)
operator|>
name|NBITS
condition|)
comment|/* normalize the significand */
name|ecleaz
argument_list|(
name|yi
argument_list|)
expr_stmt|;
comment|/* it was zero */
else|else
name|yi
index|[
name|E
index|]
operator|-=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|k
expr_stmt|;
comment|/* subtract shift count from exponent */
name|emovo
argument_list|(
name|yi
argument_list|,
name|y
argument_list|)
expr_stmt|;
comment|/* output the answer */
block|}
end_function

begin_comment
comment|/* Convert unsigned HOST_WIDE_INT LP to e type Y.  */
end_comment

begin_function
specifier|static
name|void
name|ultoe
parameter_list|(
name|lp
parameter_list|,
name|y
parameter_list|)
name|unsigned
name|HOST_WIDE_INT
modifier|*
name|lp
decl_stmt|;
name|unsigned
name|EMUSHORT
modifier|*
name|y
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|yi
index|[
name|NI
index|]
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|ll
decl_stmt|;
name|int
name|k
decl_stmt|;
name|ecleaz
argument_list|(
name|yi
argument_list|)
expr_stmt|;
name|ll
operator|=
operator|*
name|lp
expr_stmt|;
comment|/* move the long integer to ayi significand area */
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|64
name|yi
index|[
name|M
index|]
operator|=
call|(
name|unsigned
name|EMUSHORT
call|)
argument_list|(
name|ll
operator|>>
literal|48
argument_list|)
expr_stmt|;
name|yi
index|[
name|M
operator|+
literal|1
index|]
operator|=
call|(
name|unsigned
name|EMUSHORT
call|)
argument_list|(
name|ll
operator|>>
literal|32
argument_list|)
expr_stmt|;
name|yi
index|[
name|M
operator|+
literal|2
index|]
operator|=
call|(
name|unsigned
name|EMUSHORT
call|)
argument_list|(
name|ll
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|yi
index|[
name|M
operator|+
literal|3
index|]
operator|=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|ll
expr_stmt|;
name|yi
index|[
name|E
index|]
operator|=
name|EXONE
operator|+
literal|47
expr_stmt|;
comment|/* exponent if normalize shift count were 0 */
else|#
directive|else
name|yi
index|[
name|M
index|]
operator|=
call|(
name|unsigned
name|EMUSHORT
call|)
argument_list|(
name|ll
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|yi
index|[
name|M
operator|+
literal|1
index|]
operator|=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|ll
expr_stmt|;
name|yi
index|[
name|E
index|]
operator|=
name|EXONE
operator|+
literal|15
expr_stmt|;
comment|/* exponent if normalize shift count were 0 */
endif|#
directive|endif
if|if
condition|(
operator|(
name|k
operator|=
name|enormlz
argument_list|(
name|yi
argument_list|)
operator|)
operator|>
name|NBITS
condition|)
comment|/* normalize the significand */
name|ecleaz
argument_list|(
name|yi
argument_list|)
expr_stmt|;
comment|/* it was zero */
else|else
name|yi
index|[
name|E
index|]
operator|-=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|k
expr_stmt|;
comment|/* subtract shift count from exponent */
name|emovo
argument_list|(
name|yi
argument_list|,
name|y
argument_list|)
expr_stmt|;
comment|/* output the answer */
block|}
end_function

begin_comment
comment|/* Find signed HOST_WIDE_INT integer I and floating point fractional    part FRAC of e-type (packed internal format) floating point input X.    The integer output I has the sign of the input, except that    positive overflow is permitted if FIXUNS_TRUNC_LIKE_FIX_TRUNC.    The output e-type fraction FRAC is the positive fractional    part of abs (X).  */
end_comment

begin_function
specifier|static
name|void
name|eifrac
parameter_list|(
name|x
parameter_list|,
name|i
parameter_list|,
name|frac
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|;
name|HOST_WIDE_INT
modifier|*
name|i
decl_stmt|;
name|unsigned
name|EMUSHORT
modifier|*
name|frac
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|xi
index|[
name|NI
index|]
decl_stmt|;
name|int
name|j
decl_stmt|,
name|k
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|ll
decl_stmt|;
name|emovi
argument_list|(
name|x
argument_list|,
name|xi
argument_list|)
expr_stmt|;
name|k
operator|=
operator|(
name|int
operator|)
name|xi
index|[
name|E
index|]
operator|-
operator|(
name|EXONE
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|k
operator|<=
literal|0
condition|)
block|{
comment|/* if exponent<= 0, integer = 0 and real output is fraction */
operator|*
name|i
operator|=
literal|0L
expr_stmt|;
name|emovo
argument_list|(
name|xi
argument_list|,
name|frac
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|k
operator|>
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
condition|)
block|{
comment|/* long integer overflow: output large integer 	 and correct fraction  */
if|if
condition|(
name|xi
index|[
literal|0
index|]
condition|)
operator|*
name|i
operator|=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|)
operator|<<
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|FIXUNS_TRUNC_LIKE_FIX_TRUNC
comment|/* In this case, let it overflow and convert as if unsigned.  */
name|euifrac
argument_list|(
name|x
argument_list|,
operator|&
name|ll
argument_list|,
name|frac
argument_list|)
expr_stmt|;
operator|*
name|i
operator|=
operator|(
name|HOST_WIDE_INT
operator|)
name|ll
expr_stmt|;
return|return;
else|#
directive|else
comment|/* In other cases, return the largest positive integer.  */
operator|*
name|i
operator|=
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|)
operator|<<
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
name|eshift
argument_list|(
name|xi
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|extra_warnings
condition|)
name|warning
argument_list|(
literal|"overflow on truncation to integer"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|k
operator|>
literal|16
condition|)
block|{
comment|/* Shift more than 16 bits: first shift up k-16 mod 16, 	 then shift up by 16's.  */
name|j
operator|=
name|k
operator|-
operator|(
operator|(
name|k
operator|>>
literal|4
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
name|eshift
argument_list|(
name|xi
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|ll
operator|=
name|xi
index|[
name|M
index|]
expr_stmt|;
name|k
operator|-=
name|j
expr_stmt|;
do|do
block|{
name|eshup6
argument_list|(
name|xi
argument_list|)
expr_stmt|;
name|ll
operator|=
operator|(
name|ll
operator|<<
literal|16
operator|)
operator||
name|xi
index|[
name|M
index|]
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|k
operator|-=
literal|16
operator|)
operator|>
literal|0
condition|)
do|;
operator|*
name|i
operator|=
name|ll
expr_stmt|;
if|if
condition|(
name|xi
index|[
literal|0
index|]
condition|)
operator|*
name|i
operator|=
operator|-
operator|(
operator|*
name|i
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* shift not more than 16 bits */
name|eshift
argument_list|(
name|xi
argument_list|,
name|k
argument_list|)
expr_stmt|;
operator|*
name|i
operator|=
operator|(
name|HOST_WIDE_INT
operator|)
name|xi
index|[
name|M
index|]
operator|&
literal|0xffff
expr_stmt|;
if|if
condition|(
name|xi
index|[
literal|0
index|]
condition|)
operator|*
name|i
operator|=
operator|-
operator|(
operator|*
name|i
operator|)
expr_stmt|;
block|}
name|xi
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|xi
index|[
name|E
index|]
operator|=
name|EXONE
operator|-
literal|1
expr_stmt|;
name|xi
index|[
name|M
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|k
operator|=
name|enormlz
argument_list|(
name|xi
argument_list|)
operator|)
operator|>
name|NBITS
condition|)
name|ecleaz
argument_list|(
name|xi
argument_list|)
expr_stmt|;
else|else
name|xi
index|[
name|E
index|]
operator|-=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|k
expr_stmt|;
name|emovo
argument_list|(
name|xi
argument_list|,
name|frac
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find unsigned HOST_WIDE_INT integer I and floating point fractional part    FRAC of e-type X.  A negative input yields integer output = 0 but    correct fraction.  */
end_comment

begin_function
specifier|static
name|void
name|euifrac
parameter_list|(
name|x
parameter_list|,
name|i
parameter_list|,
name|frac
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
modifier|*
name|i
decl_stmt|;
name|unsigned
name|EMUSHORT
modifier|*
name|frac
decl_stmt|;
block|{
name|unsigned
name|HOST_WIDE_INT
name|ll
decl_stmt|;
name|unsigned
name|EMUSHORT
name|xi
index|[
name|NI
index|]
decl_stmt|;
name|int
name|j
decl_stmt|,
name|k
decl_stmt|;
name|emovi
argument_list|(
name|x
argument_list|,
name|xi
argument_list|)
expr_stmt|;
name|k
operator|=
operator|(
name|int
operator|)
name|xi
index|[
name|E
index|]
operator|-
operator|(
name|EXONE
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|k
operator|<=
literal|0
condition|)
block|{
comment|/* if exponent<= 0, integer = 0 and argument is fraction */
operator|*
name|i
operator|=
literal|0L
expr_stmt|;
name|emovo
argument_list|(
name|xi
argument_list|,
name|frac
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|k
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
comment|/* Long integer overflow: output large integer 	 and correct fraction. 	 Note, the BSD microvax compiler says that ~(0UL) 	 is a syntax error.  */
operator|*
name|i
operator|=
operator|~
operator|(
literal|0L
operator|)
expr_stmt|;
name|eshift
argument_list|(
name|xi
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|extra_warnings
condition|)
name|warning
argument_list|(
literal|"overflow on truncation to unsigned integer"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|k
operator|>
literal|16
condition|)
block|{
comment|/* Shift more than 16 bits: first shift up k-16 mod 16, 	 then shift up by 16's.  */
name|j
operator|=
name|k
operator|-
operator|(
operator|(
name|k
operator|>>
literal|4
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
name|eshift
argument_list|(
name|xi
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|ll
operator|=
name|xi
index|[
name|M
index|]
expr_stmt|;
name|k
operator|-=
name|j
expr_stmt|;
do|do
block|{
name|eshup6
argument_list|(
name|xi
argument_list|)
expr_stmt|;
name|ll
operator|=
operator|(
name|ll
operator|<<
literal|16
operator|)
operator||
name|xi
index|[
name|M
index|]
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|k
operator|-=
literal|16
operator|)
operator|>
literal|0
condition|)
do|;
operator|*
name|i
operator|=
name|ll
expr_stmt|;
block|}
else|else
block|{
comment|/* shift not more than 16 bits */
name|eshift
argument_list|(
name|xi
argument_list|,
name|k
argument_list|)
expr_stmt|;
operator|*
name|i
operator|=
operator|(
name|HOST_WIDE_INT
operator|)
name|xi
index|[
name|M
index|]
operator|&
literal|0xffff
expr_stmt|;
block|}
if|if
condition|(
name|xi
index|[
literal|0
index|]
condition|)
comment|/* A negative value yields unsigned integer 0.  */
operator|*
name|i
operator|=
literal|0L
expr_stmt|;
name|xi
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|xi
index|[
name|E
index|]
operator|=
name|EXONE
operator|-
literal|1
expr_stmt|;
name|xi
index|[
name|M
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|k
operator|=
name|enormlz
argument_list|(
name|xi
argument_list|)
operator|)
operator|>
name|NBITS
condition|)
name|ecleaz
argument_list|(
name|xi
argument_list|)
expr_stmt|;
else|else
name|xi
index|[
name|E
index|]
operator|-=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|k
expr_stmt|;
name|emovo
argument_list|(
name|xi
argument_list|,
name|frac
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Shift the significand of exploded e-type X up or down by SC bits.  */
end_comment

begin_function
specifier|static
name|int
name|eshift
parameter_list|(
name|x
parameter_list|,
name|sc
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|;
name|int
name|sc
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|lost
decl_stmt|;
name|unsigned
name|EMUSHORT
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|sc
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|lost
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|x
operator|+
name|NI
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|sc
operator|<
literal|0
condition|)
block|{
name|sc
operator|=
operator|-
name|sc
expr_stmt|;
while|while
condition|(
name|sc
operator|>=
literal|16
condition|)
block|{
name|lost
operator||=
operator|*
name|p
expr_stmt|;
comment|/* remember lost bits */
name|eshdn6
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|sc
operator|-=
literal|16
expr_stmt|;
block|}
while|while
condition|(
name|sc
operator|>=
literal|8
condition|)
block|{
name|lost
operator||=
operator|*
name|p
operator|&
literal|0xff
expr_stmt|;
name|eshdn8
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|sc
operator|-=
literal|8
expr_stmt|;
block|}
while|while
condition|(
name|sc
operator|>
literal|0
condition|)
block|{
name|lost
operator||=
operator|*
name|p
operator|&
literal|1
expr_stmt|;
name|eshdn1
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|sc
operator|-=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|sc
operator|>=
literal|16
condition|)
block|{
name|eshup6
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|sc
operator|-=
literal|16
expr_stmt|;
block|}
while|while
condition|(
name|sc
operator|>=
literal|8
condition|)
block|{
name|eshup8
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|sc
operator|-=
literal|8
expr_stmt|;
block|}
while|while
condition|(
name|sc
operator|>
literal|0
condition|)
block|{
name|eshup1
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|sc
operator|-=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|lost
condition|)
name|lost
operator|=
literal|1
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|lost
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Shift normalize the significand area of exploded e-type X.    Return the shift count (up = positive).  */
end_comment

begin_function
specifier|static
name|int
name|enormlz
parameter_list|(
name|x
parameter_list|)
name|unsigned
name|EMUSHORT
name|x
index|[]
decl_stmt|;
block|{
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|p
decl_stmt|;
name|int
name|sc
decl_stmt|;
name|sc
operator|=
literal|0
expr_stmt|;
name|p
operator|=
operator|&
name|x
index|[
name|M
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|0
condition|)
goto|goto
name|normdn
goto|;
operator|++
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|&
literal|0x8000
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* already normalized */
while|while
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
block|{
name|eshup6
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|sc
operator|+=
literal|16
expr_stmt|;
comment|/* With guard word, there are NBITS+16 bits available.        Return true if all are zero.  */
if|if
condition|(
name|sc
operator|>
name|NBITS
condition|)
return|return
operator|(
name|sc
operator|)
return|;
block|}
comment|/* see if high byte is zero */
while|while
condition|(
operator|(
operator|*
name|p
operator|&
literal|0xff00
operator|)
operator|==
literal|0
condition|)
block|{
name|eshup8
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|sc
operator|+=
literal|8
expr_stmt|;
block|}
comment|/* now shift 1 bit at a time */
while|while
condition|(
operator|(
operator|*
name|p
operator|&
literal|0x8000
operator|)
operator|==
literal|0
condition|)
block|{
name|eshup1
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|sc
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|sc
operator|>
name|NBITS
condition|)
block|{
name|mtherr
argument_list|(
literal|"enormlz"
argument_list|,
name|UNDERFLOW
argument_list|)
expr_stmt|;
return|return
operator|(
name|sc
operator|)
return|;
block|}
block|}
return|return
operator|(
name|sc
operator|)
return|;
comment|/* Normalize by shifting down out of the high guard word      of the significand */
name|normdn
label|:
if|if
condition|(
operator|*
name|p
operator|&
literal|0xff00
condition|)
block|{
name|eshdn8
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|sc
operator|-=
literal|8
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|p
operator|!=
literal|0
condition|)
block|{
name|eshdn1
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|sc
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|sc
operator|<
operator|-
name|NBITS
condition|)
block|{
name|mtherr
argument_list|(
literal|"enormlz"
argument_list|,
name|OVERFLOW
argument_list|)
expr_stmt|;
return|return
operator|(
name|sc
operator|)
return|;
block|}
block|}
return|return
operator|(
name|sc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Powers of ten used in decimal<-> binary conversions.  */
end_comment

begin_define
define|#
directive|define
name|NTEN
value|12
end_define

begin_define
define|#
directive|define
name|MAXP
value|4096
end_define

begin_if
if|#
directive|if
name|LONG_DOUBLE_TYPE_SIZE
operator|==
literal|128
end_if

begin_decl_stmt
specifier|static
name|unsigned
name|EMUSHORT
name|etens
index|[
name|NTEN
operator|+
literal|1
index|]
index|[
name|NE
index|]
init|=
block|{
block|{
literal|0x6576
block|,
literal|0x4a92
block|,
literal|0x804a
block|,
literal|0x153f
block|,
literal|0xc94c
block|,
literal|0x979a
block|,
literal|0x8a20
block|,
literal|0x5202
block|,
literal|0xc460
block|,
literal|0x7525
block|,}
block|,
comment|/* 10**4096 */
block|{
literal|0x6a32
block|,
literal|0xce52
block|,
literal|0x329a
block|,
literal|0x28ce
block|,
literal|0xa74d
block|,
literal|0x5de4
block|,
literal|0xc53d
block|,
literal|0x3b5d
block|,
literal|0x9e8b
block|,
literal|0x5a92
block|,}
block|,
comment|/* 10**2048 */
block|{
literal|0x526c
block|,
literal|0x50ce
block|,
literal|0xf18b
block|,
literal|0x3d28
block|,
literal|0x650d
block|,
literal|0x0c17
block|,
literal|0x8175
block|,
literal|0x7586
block|,
literal|0xc976
block|,
literal|0x4d48
block|,}
block|,
block|{
literal|0x9c66
block|,
literal|0x58f8
block|,
literal|0xbc50
block|,
literal|0x5c54
block|,
literal|0xcc65
block|,
literal|0x91c6
block|,
literal|0xa60e
block|,
literal|0xa0ae
block|,
literal|0xe319
block|,
literal|0x46a3
block|,}
block|,
block|{
literal|0x851e
block|,
literal|0xeab7
block|,
literal|0x98fe
block|,
literal|0x901b
block|,
literal|0xddbb
block|,
literal|0xde8d
block|,
literal|0x9df9
block|,
literal|0xebfb
block|,
literal|0xaa7e
block|,
literal|0x4351
block|,}
block|,
block|{
literal|0x0235
block|,
literal|0x0137
block|,
literal|0x36b1
block|,
literal|0x336c
block|,
literal|0xc66f
block|,
literal|0x8cdf
block|,
literal|0x80e9
block|,
literal|0x47c9
block|,
literal|0x93ba
block|,
literal|0x41a8
block|,}
block|,
block|{
literal|0x50f8
block|,
literal|0x25fb
block|,
literal|0xc76b
block|,
literal|0x6b71
block|,
literal|0x3cbf
block|,
literal|0xa6d5
block|,
literal|0xffcf
block|,
literal|0x1f49
block|,
literal|0xc278
block|,
literal|0x40d3
block|,}
block|,
block|{
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0xf020
block|,
literal|0xb59d
block|,
literal|0x2b70
block|,
literal|0xada8
block|,
literal|0x9dc5
block|,
literal|0x4069
block|,}
block|,
block|{
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0400
block|,
literal|0xc9bf
block|,
literal|0x8e1b
block|,
literal|0x4034
block|,}
block|,
block|{
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x2000
block|,
literal|0xbebc
block|,
literal|0x4019
block|,}
block|,
block|{
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x9c40
block|,
literal|0x400c
block|,}
block|,
block|{
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0xc800
block|,
literal|0x4005
block|,}
block|,
block|{
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0xa000
block|,
literal|0x4002
block|,}
block|,
comment|/* 10**1 */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|EMUSHORT
name|emtens
index|[
name|NTEN
operator|+
literal|1
index|]
index|[
name|NE
index|]
init|=
block|{
block|{
literal|0x2030
block|,
literal|0xcffc
block|,
literal|0xa1c3
block|,
literal|0x8123
block|,
literal|0x2de3
block|,
literal|0x9fde
block|,
literal|0xd2ce
block|,
literal|0x04c8
block|,
literal|0xa6dd
block|,
literal|0x0ad8
block|,}
block|,
comment|/* 10**-4096 */
block|{
literal|0x8264
block|,
literal|0xd2cb
block|,
literal|0xf2ea
block|,
literal|0x12d4
block|,
literal|0x4925
block|,
literal|0x2de4
block|,
literal|0x3436
block|,
literal|0x534f
block|,
literal|0xceae
block|,
literal|0x256b
block|,}
block|,
comment|/* 10**-2048 */
block|{
literal|0xf53f
block|,
literal|0xf698
block|,
literal|0x6bd3
block|,
literal|0x0158
block|,
literal|0x87a6
block|,
literal|0xc0bd
block|,
literal|0xda57
block|,
literal|0x82a5
block|,
literal|0xa2a6
block|,
literal|0x32b5
block|,}
block|,
block|{
literal|0xe731
block|,
literal|0x04d4
block|,
literal|0xe3f2
block|,
literal|0xd332
block|,
literal|0x7132
block|,
literal|0xd21c
block|,
literal|0xdb23
block|,
literal|0xee32
block|,
literal|0x9049
block|,
literal|0x395a
block|,}
block|,
block|{
literal|0xa23e
block|,
literal|0x5308
block|,
literal|0xfefb
block|,
literal|0x1155
block|,
literal|0xfa91
block|,
literal|0x1939
block|,
literal|0x637a
block|,
literal|0x4325
block|,
literal|0xc031
block|,
literal|0x3cac
block|,}
block|,
block|{
literal|0xe26d
block|,
literal|0xdbde
block|,
literal|0xd05d
block|,
literal|0xb3f6
block|,
literal|0xac7c
block|,
literal|0xe4a0
block|,
literal|0x64bc
block|,
literal|0x467c
block|,
literal|0xddd0
block|,
literal|0x3e55
block|,}
block|,
block|{
literal|0x2a20
block|,
literal|0x6224
block|,
literal|0x47b3
block|,
literal|0x98d7
block|,
literal|0x3f23
block|,
literal|0xe9a5
block|,
literal|0xa539
block|,
literal|0xea27
block|,
literal|0xa87f
block|,
literal|0x3f2a
block|,}
block|,
block|{
literal|0x0b5b
block|,
literal|0x4af2
block|,
literal|0xa581
block|,
literal|0x18ed
block|,
literal|0x67de
block|,
literal|0x94ba
block|,
literal|0x4539
block|,
literal|0x1ead
block|,
literal|0xcfb1
block|,
literal|0x3f94
block|,}
block|,
block|{
literal|0xbf71
block|,
literal|0xa9b3
block|,
literal|0x7989
block|,
literal|0xbe68
block|,
literal|0x4c2e
block|,
literal|0xe15b
block|,
literal|0xc44d
block|,
literal|0x94be
block|,
literal|0xe695
block|,
literal|0x3fc9
block|,}
block|,
block|{
literal|0x3d4d
block|,
literal|0x7c3d
block|,
literal|0x36ba
block|,
literal|0x0d2b
block|,
literal|0xfdc2
block|,
literal|0xcefc
block|,
literal|0x8461
block|,
literal|0x7711
block|,
literal|0xabcc
block|,
literal|0x3fe4
block|,}
block|,
block|{
literal|0xc155
block|,
literal|0xa4a8
block|,
literal|0x404e
block|,
literal|0x6113
block|,
literal|0xd3c3
block|,
literal|0x652b
block|,
literal|0xe219
block|,
literal|0x1758
block|,
literal|0xd1b7
block|,
literal|0x3ff1
block|,}
block|,
block|{
literal|0xd70a
block|,
literal|0x70a3
block|,
literal|0x0a3d
block|,
literal|0xa3d7
block|,
literal|0x3d70
block|,
literal|0xd70a
block|,
literal|0x70a3
block|,
literal|0x0a3d
block|,
literal|0xa3d7
block|,
literal|0x3ff8
block|,}
block|,
block|{
literal|0xcccd
block|,
literal|0xcccc
block|,
literal|0xcccc
block|,
literal|0xcccc
block|,
literal|0xcccc
block|,
literal|0xcccc
block|,
literal|0xcccc
block|,
literal|0xcccc
block|,
literal|0xcccc
block|,
literal|0x3ffb
block|,}
block|,
comment|/* 10**-1 */
block|}
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* LONG_DOUBLE_TYPE_SIZE is other than 128 */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|EMUSHORT
name|etens
index|[
name|NTEN
operator|+
literal|1
index|]
index|[
name|NE
index|]
init|=
block|{
block|{
literal|0xc94c
block|,
literal|0x979a
block|,
literal|0x8a20
block|,
literal|0x5202
block|,
literal|0xc460
block|,
literal|0x7525
block|,}
block|,
comment|/* 10**4096 */
block|{
literal|0xa74d
block|,
literal|0x5de4
block|,
literal|0xc53d
block|,
literal|0x3b5d
block|,
literal|0x9e8b
block|,
literal|0x5a92
block|,}
block|,
comment|/* 10**2048 */
block|{
literal|0x650d
block|,
literal|0x0c17
block|,
literal|0x8175
block|,
literal|0x7586
block|,
literal|0xc976
block|,
literal|0x4d48
block|,}
block|,
block|{
literal|0xcc65
block|,
literal|0x91c6
block|,
literal|0xa60e
block|,
literal|0xa0ae
block|,
literal|0xe319
block|,
literal|0x46a3
block|,}
block|,
block|{
literal|0xddbc
block|,
literal|0xde8d
block|,
literal|0x9df9
block|,
literal|0xebfb
block|,
literal|0xaa7e
block|,
literal|0x4351
block|,}
block|,
block|{
literal|0xc66f
block|,
literal|0x8cdf
block|,
literal|0x80e9
block|,
literal|0x47c9
block|,
literal|0x93ba
block|,
literal|0x41a8
block|,}
block|,
block|{
literal|0x3cbf
block|,
literal|0xa6d5
block|,
literal|0xffcf
block|,
literal|0x1f49
block|,
literal|0xc278
block|,
literal|0x40d3
block|,}
block|,
block|{
literal|0xf020
block|,
literal|0xb59d
block|,
literal|0x2b70
block|,
literal|0xada8
block|,
literal|0x9dc5
block|,
literal|0x4069
block|,}
block|,
block|{
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0400
block|,
literal|0xc9bf
block|,
literal|0x8e1b
block|,
literal|0x4034
block|,}
block|,
block|{
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x2000
block|,
literal|0xbebc
block|,
literal|0x4019
block|,}
block|,
block|{
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x9c40
block|,
literal|0x400c
block|,}
block|,
block|{
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0xc800
block|,
literal|0x4005
block|,}
block|,
block|{
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0xa000
block|,
literal|0x4002
block|,}
block|,
comment|/* 10**1 */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|EMUSHORT
name|emtens
index|[
name|NTEN
operator|+
literal|1
index|]
index|[
name|NE
index|]
init|=
block|{
block|{
literal|0x2de4
block|,
literal|0x9fde
block|,
literal|0xd2ce
block|,
literal|0x04c8
block|,
literal|0xa6dd
block|,
literal|0x0ad8
block|,}
block|,
comment|/* 10**-4096 */
block|{
literal|0x4925
block|,
literal|0x2de4
block|,
literal|0x3436
block|,
literal|0x534f
block|,
literal|0xceae
block|,
literal|0x256b
block|,}
block|,
comment|/* 10**-2048 */
block|{
literal|0x87a6
block|,
literal|0xc0bd
block|,
literal|0xda57
block|,
literal|0x82a5
block|,
literal|0xa2a6
block|,
literal|0x32b5
block|,}
block|,
block|{
literal|0x7133
block|,
literal|0xd21c
block|,
literal|0xdb23
block|,
literal|0xee32
block|,
literal|0x9049
block|,
literal|0x395a
block|,}
block|,
block|{
literal|0xfa91
block|,
literal|0x1939
block|,
literal|0x637a
block|,
literal|0x4325
block|,
literal|0xc031
block|,
literal|0x3cac
block|,}
block|,
block|{
literal|0xac7d
block|,
literal|0xe4a0
block|,
literal|0x64bc
block|,
literal|0x467c
block|,
literal|0xddd0
block|,
literal|0x3e55
block|,}
block|,
block|{
literal|0x3f24
block|,
literal|0xe9a5
block|,
literal|0xa539
block|,
literal|0xea27
block|,
literal|0xa87f
block|,
literal|0x3f2a
block|,}
block|,
block|{
literal|0x67de
block|,
literal|0x94ba
block|,
literal|0x4539
block|,
literal|0x1ead
block|,
literal|0xcfb1
block|,
literal|0x3f94
block|,}
block|,
block|{
literal|0x4c2f
block|,
literal|0xe15b
block|,
literal|0xc44d
block|,
literal|0x94be
block|,
literal|0xe695
block|,
literal|0x3fc9
block|,}
block|,
block|{
literal|0xfdc2
block|,
literal|0xcefc
block|,
literal|0x8461
block|,
literal|0x7711
block|,
literal|0xabcc
block|,
literal|0x3fe4
block|,}
block|,
block|{
literal|0xd3c3
block|,
literal|0x652b
block|,
literal|0xe219
block|,
literal|0x1758
block|,
literal|0xd1b7
block|,
literal|0x3ff1
block|,}
block|,
block|{
literal|0x3d71
block|,
literal|0xd70a
block|,
literal|0x70a3
block|,
literal|0x0a3d
block|,
literal|0xa3d7
block|,
literal|0x3ff8
block|,}
block|,
block|{
literal|0xcccd
block|,
literal|0xcccc
block|,
literal|0xcccc
block|,
literal|0xcccc
block|,
literal|0xcccc
block|,
literal|0x3ffb
block|,}
block|,
comment|/* 10**-1 */
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Convert float value X to ASCII string STRING with NDIG digits after    the decimal point.  */
end_comment

begin_comment
unit|static void e24toasc (x, string, ndigs)      unsigned EMUSHORT x[];      char *string;      int ndigs; {   unsigned EMUSHORT w[NI];    e24toe (x, w);   etoasc (w, string, ndigs); }
comment|/* Convert double value X to ASCII string STRING with NDIG digits after    the decimal point.  */
end_comment

begin_comment
unit|static void e53toasc (x, string, ndigs)      unsigned EMUSHORT x[];      char *string;      int ndigs; {   unsigned EMUSHORT w[NI];    e53toe (x, w);   etoasc (w, string, ndigs); }
comment|/* Convert double extended value X to ASCII string STRING with NDIG digits    after the decimal point.  */
end_comment

begin_comment
unit|static void e64toasc (x, string, ndigs)      unsigned EMUSHORT x[];      char *string;      int ndigs; {   unsigned EMUSHORT w[NI];    e64toe (x, w);   etoasc (w, string, ndigs); }
comment|/* Convert 128-bit long double value X to ASCII string STRING with NDIG digits    after the decimal point.  */
end_comment

begin_endif
unit|static void e113toasc (x, string, ndigs)      unsigned EMUSHORT x[];      char *string;      int ndigs; {   unsigned EMUSHORT w[NI];    e113toe (x, w);   etoasc (w, string, ndigs); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_comment
comment|/* Convert e-type X to ASCII string STRING with NDIGS digits after    the decimal point.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|wstring
index|[
literal|80
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* working storage for ASCII output */
end_comment

begin_function
specifier|static
name|void
name|etoasc
parameter_list|(
name|x
parameter_list|,
name|string
parameter_list|,
name|ndigs
parameter_list|)
name|unsigned
name|EMUSHORT
name|x
index|[]
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|ndigs
decl_stmt|;
block|{
name|EMUSHORT
name|digit
decl_stmt|;
name|unsigned
name|EMUSHORT
name|y
index|[
name|NI
index|]
decl_stmt|,
name|t
index|[
name|NI
index|]
decl_stmt|,
name|u
index|[
name|NI
index|]
decl_stmt|,
name|w
index|[
name|NI
index|]
decl_stmt|;
name|unsigned
name|EMUSHORT
modifier|*
name|p
decl_stmt|,
modifier|*
name|r
decl_stmt|,
modifier|*
name|ten
decl_stmt|;
name|unsigned
name|EMUSHORT
name|sign
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|expon
decl_stmt|,
name|rndsav
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|ss
decl_stmt|;
name|unsigned
name|EMUSHORT
name|m
decl_stmt|;
name|rndsav
operator|=
name|rndprc
expr_stmt|;
name|ss
operator|=
name|string
expr_stmt|;
name|s
operator|=
name|wstring
expr_stmt|;
operator|*
name|ss
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
name|eisnan
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|wstring
argument_list|,
literal|" NaN "
argument_list|)
expr_stmt|;
goto|goto
name|bxit
goto|;
block|}
endif|#
directive|endif
name|rndprc
operator|=
name|NBITS
expr_stmt|;
comment|/* set to full precision */
name|emov
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
comment|/* retain external format */
if|if
condition|(
name|y
index|[
name|NE
operator|-
literal|1
index|]
operator|&
literal|0x8000
condition|)
block|{
name|sign
operator|=
literal|0xffff
expr_stmt|;
name|y
index|[
name|NE
operator|-
literal|1
index|]
operator|&=
literal|0x7fff
expr_stmt|;
block|}
else|else
block|{
name|sign
operator|=
literal|0
expr_stmt|;
block|}
name|expon
operator|=
literal|0
expr_stmt|;
name|ten
operator|=
operator|&
name|etens
index|[
name|NTEN
index|]
index|[
literal|0
index|]
expr_stmt|;
name|emov
argument_list|(
name|eone
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* Test for zero exponent */
if|if
condition|(
name|y
index|[
name|NE
operator|-
literal|1
index|]
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|NE
operator|-
literal|1
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|y
index|[
name|k
index|]
operator|!=
literal|0
condition|)
goto|goto
name|tnzro
goto|;
comment|/* denormalized number */
block|}
goto|goto
name|isone
goto|;
comment|/* valid all zeros */
block|}
name|tnzro
label|:
comment|/* Test for infinity.  */
if|if
condition|(
name|y
index|[
name|NE
operator|-
literal|1
index|]
operator|==
literal|0x7fff
condition|)
block|{
if|if
condition|(
name|sign
condition|)
name|sprintf
argument_list|(
name|wstring
argument_list|,
literal|" -Infinity "
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|wstring
argument_list|,
literal|" Infinity "
argument_list|)
expr_stmt|;
goto|goto
name|bxit
goto|;
block|}
comment|/* Test for exponent nonzero but significand denormalized.    * This is an error condition.    */
if|if
condition|(
operator|(
name|y
index|[
name|NE
operator|-
literal|1
index|]
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|y
index|[
name|NE
operator|-
literal|2
index|]
operator|&
literal|0x8000
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|mtherr
argument_list|(
literal|"etoasc"
argument_list|,
name|DOMAIN
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|wstring
argument_list|,
literal|"NaN"
argument_list|)
expr_stmt|;
goto|goto
name|bxit
goto|;
block|}
comment|/* Compare to 1.0 */
name|i
operator|=
name|ecmp
argument_list|(
name|eone
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
goto|goto
name|isone
goto|;
if|if
condition|(
name|i
operator|==
operator|-
literal|2
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
comment|/* Number is greater than 1 */
comment|/* Convert significand to an integer and strip trailing decimal zeros.  */
name|emov
argument_list|(
name|y
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|u
index|[
name|NE
operator|-
literal|1
index|]
operator|=
name|EXONE
operator|+
name|NBITS
operator|-
literal|1
expr_stmt|;
name|p
operator|=
operator|&
name|etens
index|[
name|NTEN
operator|-
literal|4
index|]
index|[
literal|0
index|]
expr_stmt|;
name|m
operator|=
literal|16
expr_stmt|;
do|do
block|{
name|ediv
argument_list|(
name|p
argument_list|,
name|u
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|efloor
argument_list|(
name|t
argument_list|,
name|w
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NE
operator|-
literal|1
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|t
index|[
name|j
index|]
operator|!=
name|w
index|[
name|j
index|]
condition|)
goto|goto
name|noint
goto|;
block|}
name|emov
argument_list|(
name|t
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|expon
operator|+=
operator|(
name|int
operator|)
name|m
expr_stmt|;
name|noint
label|:
name|p
operator|+=
name|NE
expr_stmt|;
name|m
operator|>>=
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|m
operator|!=
literal|0
condition|)
do|;
comment|/* Rescale from integer significand */
name|u
index|[
name|NE
operator|-
literal|1
index|]
operator|+=
name|y
index|[
name|NE
operator|-
literal|1
index|]
operator|-
call|(
name|unsigned
name|int
call|)
argument_list|(
name|EXONE
operator|+
name|NBITS
operator|-
literal|1
argument_list|)
expr_stmt|;
name|emov
argument_list|(
name|u
argument_list|,
name|y
argument_list|)
expr_stmt|;
comment|/* Find power of 10 */
name|emov
argument_list|(
name|eone
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|m
operator|=
name|MAXP
expr_stmt|;
name|p
operator|=
operator|&
name|etens
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
comment|/* An unordered compare result shouldn't happen here.  */
while|while
condition|(
name|ecmp
argument_list|(
name|ten
argument_list|,
name|u
argument_list|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|ecmp
argument_list|(
name|p
argument_list|,
name|u
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|ediv
argument_list|(
name|p
argument_list|,
name|u
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|emul
argument_list|(
name|p
argument_list|,
name|t
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|expon
operator|+=
operator|(
name|int
operator|)
name|m
expr_stmt|;
block|}
name|m
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
break|break;
name|p
operator|+=
name|NE
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Number is less than 1.0 */
comment|/* Pad significand with trailing decimal zeros.  */
if|if
condition|(
name|y
index|[
name|NE
operator|-
literal|1
index|]
operator|==
literal|0
condition|)
block|{
while|while
condition|(
operator|(
name|y
index|[
name|NE
operator|-
literal|2
index|]
operator|&
literal|0x8000
operator|)
operator|==
literal|0
condition|)
block|{
name|emul
argument_list|(
name|ten
argument_list|,
name|y
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|expon
operator|-=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|emovi
argument_list|(
name|y
argument_list|,
name|w
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NDEC
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|w
index|[
name|NI
operator|-
literal|1
index|]
operator|&
literal|0x7
operator|)
operator|!=
literal|0
condition|)
break|break;
comment|/* multiply by 10 */
name|emovz
argument_list|(
name|w
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|eshdn1
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|eshdn1
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|eaddm
argument_list|(
name|w
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|u
index|[
literal|1
index|]
operator|+=
literal|3
expr_stmt|;
while|while
condition|(
name|u
index|[
literal|2
index|]
operator|!=
literal|0
condition|)
block|{
name|eshdn1
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|u
index|[
literal|1
index|]
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|u
index|[
name|NI
operator|-
literal|1
index|]
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|eone
index|[
name|NE
operator|-
literal|1
index|]
operator|<=
name|u
index|[
literal|1
index|]
condition|)
break|break;
name|emovz
argument_list|(
name|u
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|expon
operator|-=
literal|1
expr_stmt|;
block|}
name|emovo
argument_list|(
name|w
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
name|k
operator|=
operator|-
name|MAXP
expr_stmt|;
name|p
operator|=
operator|&
name|emtens
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
name|r
operator|=
operator|&
name|etens
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
name|emov
argument_list|(
name|y
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|emov
argument_list|(
name|eone
argument_list|,
name|t
argument_list|)
expr_stmt|;
while|while
condition|(
name|ecmp
argument_list|(
name|eone
argument_list|,
name|w
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|ecmp
argument_list|(
name|p
argument_list|,
name|w
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|emul
argument_list|(
name|r
argument_list|,
name|w
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|emul
argument_list|(
name|r
argument_list|,
name|t
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|expon
operator|+=
name|k
expr_stmt|;
block|}
name|k
operator|/=
literal|2
expr_stmt|;
if|if
condition|(
name|k
operator|==
literal|0
condition|)
break|break;
name|p
operator|+=
name|NE
expr_stmt|;
name|r
operator|+=
name|NE
expr_stmt|;
block|}
name|ediv
argument_list|(
name|t
argument_list|,
name|eone
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
name|isone
label|:
comment|/* Find the first (leading) digit.  */
name|emovi
argument_list|(
name|t
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|emovz
argument_list|(
name|w
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|emovi
argument_list|(
name|y
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|emovz
argument_list|(
name|w
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|eiremain
argument_list|(
name|t
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|digit
operator|=
name|equot
index|[
name|NI
operator|-
literal|1
index|]
expr_stmt|;
while|while
condition|(
operator|(
name|digit
operator|==
literal|0
operator|)
operator|&&
operator|(
name|ecmp
argument_list|(
name|y
argument_list|,
name|ezero
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|eshup1
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|emovz
argument_list|(
name|y
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|eshup1
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|eshup1
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|eaddm
argument_list|(
name|u
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|eiremain
argument_list|(
name|t
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|digit
operator|=
name|equot
index|[
name|NI
operator|-
literal|1
index|]
expr_stmt|;
name|expon
operator|-=
literal|1
expr_stmt|;
block|}
name|s
operator|=
name|wstring
expr_stmt|;
if|if
condition|(
name|sign
condition|)
operator|*
name|s
operator|++
operator|=
literal|'-'
expr_stmt|;
else|else
operator|*
name|s
operator|++
operator|=
literal|' '
expr_stmt|;
comment|/* Examine number of digits requested by caller.  */
if|if
condition|(
name|ndigs
operator|<
literal|0
condition|)
name|ndigs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ndigs
operator|>
name|NDEC
condition|)
name|ndigs
operator|=
name|NDEC
expr_stmt|;
if|if
condition|(
name|digit
operator|==
literal|10
condition|)
block|{
operator|*
name|s
operator|++
operator|=
literal|'1'
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'.'
expr_stmt|;
if|if
condition|(
name|ndigs
operator|>
literal|0
condition|)
block|{
operator|*
name|s
operator|++
operator|=
literal|'0'
expr_stmt|;
name|ndigs
operator|-=
literal|1
expr_stmt|;
block|}
name|expon
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
operator|*
name|s
operator|++
operator|=
operator|(
name|char
operator|)
name|digit
operator|+
literal|'0'
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'.'
expr_stmt|;
block|}
comment|/* Generate digits after the decimal point.  */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<=
name|ndigs
condition|;
name|k
operator|++
control|)
block|{
comment|/* multiply current number by 10, without normalizing */
name|eshup1
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|emovz
argument_list|(
name|y
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|eshup1
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|eshup1
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|eaddm
argument_list|(
name|u
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|eiremain
argument_list|(
name|t
argument_list|,
name|y
argument_list|)
expr_stmt|;
operator|*
name|s
operator|++
operator|=
operator|(
name|char
operator|)
name|equot
index|[
name|NI
operator|-
literal|1
index|]
operator|+
literal|'0'
expr_stmt|;
block|}
name|digit
operator|=
name|equot
index|[
name|NI
operator|-
literal|1
index|]
expr_stmt|;
operator|--
name|s
expr_stmt|;
name|ss
operator|=
name|s
expr_stmt|;
comment|/* round off the ASCII string */
if|if
condition|(
name|digit
operator|>
literal|4
condition|)
block|{
comment|/* Test for critical rounding case in ASCII output.  */
if|if
condition|(
name|digit
operator|==
literal|5
condition|)
block|{
name|emovo
argument_list|(
name|y
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecmp
argument_list|(
name|t
argument_list|,
name|ezero
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|roun
goto|;
comment|/* round to nearest */
ifndef|#
directive|ifndef
name|C4X
if|if
condition|(
operator|(
operator|*
operator|(
name|s
operator|-
literal|1
operator|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
goto|goto
name|doexp
goto|;
comment|/* round to even */
endif|#
directive|endif
block|}
comment|/* Round up and propagate carry-outs */
name|roun
label|:
operator|--
name|s
expr_stmt|;
name|k
operator|=
operator|*
name|s
operator|&
literal|0x7f
expr_stmt|;
comment|/* Carry out to most significant digit? */
if|if
condition|(
name|k
operator|==
literal|'.'
condition|)
block|{
operator|--
name|s
expr_stmt|;
name|k
operator|=
operator|*
name|s
expr_stmt|;
name|k
operator|+=
literal|1
expr_stmt|;
operator|*
name|s
operator|=
operator|(
name|char
operator|)
name|k
expr_stmt|;
comment|/* Most significant digit carries to 10? */
if|if
condition|(
name|k
operator|>
literal|'9'
condition|)
block|{
name|expon
operator|+=
literal|1
expr_stmt|;
operator|*
name|s
operator|=
literal|'1'
expr_stmt|;
block|}
goto|goto
name|doexp
goto|;
block|}
comment|/* Round up and carry out from less significant digits */
name|k
operator|+=
literal|1
expr_stmt|;
operator|*
name|s
operator|=
operator|(
name|char
operator|)
name|k
expr_stmt|;
if|if
condition|(
name|k
operator|>
literal|'9'
condition|)
block|{
operator|*
name|s
operator|=
literal|'0'
expr_stmt|;
goto|goto
name|roun
goto|;
block|}
block|}
name|doexp
label|:
comment|/*      if (expon>= 0)      sprintf (ss, "e+%d", expon);      else      sprintf (ss, "e%d", expon);      */
name|sprintf
argument_list|(
name|ss
argument_list|,
literal|"e%d"
argument_list|,
name|expon
argument_list|)
expr_stmt|;
name|bxit
label|:
name|rndprc
operator|=
name|rndsav
expr_stmt|;
comment|/* copy out the working string */
name|s
operator|=
name|string
expr_stmt|;
name|ss
operator|=
name|wstring
expr_stmt|;
while|while
condition|(
operator|*
name|ss
operator|==
literal|' '
condition|)
comment|/* strip possible leading space */
operator|++
name|ss
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|s
operator|++
operator|=
operator|*
name|ss
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
empty_stmt|;
block|}
end_function

begin_comment
comment|/* Convert ASCII string to floating point.     Numeric input is a free format decimal number of any length, with    or without decimal point.  Entering E after the number followed by an    integer number causes the second number to be interpreted as a power of    10 to be multiplied by the first number (i.e., "scientific" notation).  */
end_comment

begin_comment
comment|/* Convert ASCII string S to single precision float value Y.  */
end_comment

begin_function
specifier|static
name|void
name|asctoe24
parameter_list|(
name|s
parameter_list|,
name|y
parameter_list|)
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|unsigned
name|EMUSHORT
modifier|*
name|y
decl_stmt|;
block|{
name|asctoeg
argument_list|(
name|s
argument_list|,
name|y
argument_list|,
literal|24
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert ASCII string S to double precision value Y.  */
end_comment

begin_function
specifier|static
name|void
name|asctoe53
parameter_list|(
name|s
parameter_list|,
name|y
parameter_list|)
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|unsigned
name|EMUSHORT
modifier|*
name|y
decl_stmt|;
block|{
if|#
directive|if
name|defined
argument_list|(
name|DEC
argument_list|)
operator|||
name|defined
argument_list|(
name|IBM
argument_list|)
name|asctoeg
argument_list|(
name|s
argument_list|,
name|y
argument_list|,
literal|56
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|C4X
argument_list|)
name|asctoeg
argument_list|(
name|s
argument_list|,
name|y
argument_list|,
literal|32
argument_list|)
expr_stmt|;
else|#
directive|else
name|asctoeg
argument_list|(
name|s
argument_list|,
name|y
argument_list|,
literal|53
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Convert ASCII string S to double extended value Y.  */
end_comment

begin_function
specifier|static
name|void
name|asctoe64
parameter_list|(
name|s
parameter_list|,
name|y
parameter_list|)
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|unsigned
name|EMUSHORT
modifier|*
name|y
decl_stmt|;
block|{
name|asctoeg
argument_list|(
name|s
argument_list|,
name|y
argument_list|,
literal|64
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert ASCII string S to 128-bit long double Y.  */
end_comment

begin_function
specifier|static
name|void
name|asctoe113
parameter_list|(
name|s
parameter_list|,
name|y
parameter_list|)
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|unsigned
name|EMUSHORT
modifier|*
name|y
decl_stmt|;
block|{
name|asctoeg
argument_list|(
name|s
argument_list|,
name|y
argument_list|,
literal|113
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert ASCII string S to e type Y.  */
end_comment

begin_function
specifier|static
name|void
name|asctoe
parameter_list|(
name|s
parameter_list|,
name|y
parameter_list|)
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|unsigned
name|EMUSHORT
modifier|*
name|y
decl_stmt|;
block|{
name|asctoeg
argument_list|(
name|s
argument_list|,
name|y
argument_list|,
name|NBITS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert ASCII string SS to e type Y, with a specified rounding precision    of OPREC bits.  BASE is 16 for C9X hexadecimal floating constants.  */
end_comment

begin_function
specifier|static
name|void
name|asctoeg
parameter_list|(
name|ss
parameter_list|,
name|y
parameter_list|,
name|oprec
parameter_list|)
specifier|const
name|char
modifier|*
name|ss
decl_stmt|;
name|unsigned
name|EMUSHORT
modifier|*
name|y
decl_stmt|;
name|int
name|oprec
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|yy
index|[
name|NI
index|]
decl_stmt|,
name|xt
index|[
name|NI
index|]
decl_stmt|,
name|tt
index|[
name|NI
index|]
decl_stmt|;
name|int
name|esign
decl_stmt|,
name|decflg
decl_stmt|,
name|sgnflg
decl_stmt|,
name|nexp
decl_stmt|,
name|exp
decl_stmt|,
name|prec
decl_stmt|,
name|lost
decl_stmt|;
name|int
name|k
decl_stmt|,
name|trail
decl_stmt|,
name|c
decl_stmt|,
name|rndsav
decl_stmt|;
name|EMULONG
name|lexp
decl_stmt|;
name|unsigned
name|EMUSHORT
name|nsign
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|sp
decl_stmt|,
modifier|*
name|s
decl_stmt|,
modifier|*
name|lstr
decl_stmt|;
name|int
name|base
init|=
literal|10
decl_stmt|;
comment|/* Copy the input string.  */
name|lstr
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|ss
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|ss
operator|==
literal|' '
condition|)
comment|/* skip leading spaces */
operator|++
name|ss
expr_stmt|;
name|sp
operator|=
name|lstr
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|sp
operator|++
operator|=
operator|*
name|ss
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
empty_stmt|;
name|s
operator|=
name|lstr
expr_stmt|;
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|'0'
operator|&&
operator|(
name|s
index|[
literal|1
index|]
operator|==
literal|'x'
operator|||
name|s
index|[
literal|1
index|]
operator|==
literal|'X'
operator|)
condition|)
block|{
name|base
operator|=
literal|16
expr_stmt|;
name|s
operator|+=
literal|2
expr_stmt|;
block|}
name|rndsav
operator|=
name|rndprc
expr_stmt|;
name|rndprc
operator|=
name|NBITS
expr_stmt|;
comment|/* Set to full precision */
name|lost
operator|=
literal|0
expr_stmt|;
name|nsign
operator|=
literal|0
expr_stmt|;
name|decflg
operator|=
literal|0
expr_stmt|;
name|sgnflg
operator|=
literal|0
expr_stmt|;
name|nexp
operator|=
literal|0
expr_stmt|;
name|exp
operator|=
literal|0
expr_stmt|;
name|prec
operator|=
literal|0
expr_stmt|;
name|ecleaz
argument_list|(
name|yy
argument_list|)
expr_stmt|;
name|trail
operator|=
literal|0
expr_stmt|;
name|nxtcom
label|:
if|if
condition|(
operator|*
name|s
operator|>=
literal|'0'
operator|&&
operator|*
name|s
operator|<=
literal|'9'
condition|)
name|k
operator|=
operator|*
name|s
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|>=
literal|'a'
condition|)
name|k
operator|=
literal|10
operator|+
operator|*
name|s
operator|-
literal|'a'
expr_stmt|;
else|else
name|k
operator|=
literal|10
operator|+
operator|*
name|s
operator|-
literal|'A'
expr_stmt|;
if|if
condition|(
operator|(
name|k
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|k
operator|<
name|base
operator|)
condition|)
block|{
comment|/* Ignore leading zeros */
if|if
condition|(
operator|(
name|prec
operator|==
literal|0
operator|)
operator|&&
operator|(
name|decflg
operator|==
literal|0
operator|)
operator|&&
operator|(
name|k
operator|==
literal|0
operator|)
condition|)
goto|goto
name|donchr
goto|;
comment|/* Identify and strip trailing zeros after the decimal point.  */
if|if
condition|(
operator|(
name|trail
operator|==
literal|0
operator|)
operator|&&
operator|(
name|decflg
operator|!=
literal|0
operator|)
condition|)
block|{
name|sp
operator|=
name|s
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|sp
operator|>=
literal|'0'
operator|&&
operator|*
name|sp
operator|<=
literal|'9'
operator|)
operator|||
operator|(
name|base
operator|==
literal|16
operator|&&
operator|(
operator|(
operator|*
name|sp
operator|>=
literal|'a'
operator|&&
operator|*
name|sp
operator|<=
literal|'f'
operator|)
operator|||
operator|(
operator|*
name|sp
operator|>=
literal|'A'
operator|&&
operator|*
name|sp
operator|<=
literal|'F'
operator|)
operator|)
operator|)
condition|)
operator|++
name|sp
expr_stmt|;
comment|/* Check for syntax error */
name|c
operator|=
operator|*
name|sp
operator|&
literal|0x7f
expr_stmt|;
if|if
condition|(
operator|(
name|base
operator|!=
literal|10
operator|||
operator|(
operator|(
name|c
operator|!=
literal|'e'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'E'
operator|)
operator|)
operator|)
operator|&&
operator|(
name|base
operator|!=
literal|16
operator|||
operator|(
operator|(
name|c
operator|!=
literal|'p'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'P'
operator|)
operator|)
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'\0'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'\n'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'\r'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|' '
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|','
operator|)
condition|)
goto|goto
name|error
goto|;
operator|--
name|sp
expr_stmt|;
while|while
condition|(
operator|*
name|sp
operator|==
literal|'0'
condition|)
operator|*
name|sp
operator|--
operator|=
literal|'z'
expr_stmt|;
name|trail
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'z'
condition|)
goto|goto
name|donchr
goto|;
block|}
comment|/* If enough digits were given to more than fill up the yy register, 	 continuing until overflow into the high guard word yy[2] 	 guarantees that there will be a roundoff bit at the top 	 of the low guard word after normalization.  */
if|if
condition|(
name|yy
index|[
literal|2
index|]
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|base
operator|==
literal|16
condition|)
block|{
if|if
condition|(
name|decflg
condition|)
name|nexp
operator|+=
literal|4
expr_stmt|;
comment|/* count digits after decimal point */
name|eshup1
argument_list|(
name|yy
argument_list|)
expr_stmt|;
comment|/* multiply current number by 16 */
name|eshup1
argument_list|(
name|yy
argument_list|)
expr_stmt|;
name|eshup1
argument_list|(
name|yy
argument_list|)
expr_stmt|;
name|eshup1
argument_list|(
name|yy
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|decflg
condition|)
name|nexp
operator|+=
literal|1
expr_stmt|;
comment|/* count digits after decimal point */
name|eshup1
argument_list|(
name|yy
argument_list|)
expr_stmt|;
comment|/* multiply current number by 10 */
name|emovz
argument_list|(
name|yy
argument_list|,
name|xt
argument_list|)
expr_stmt|;
name|eshup1
argument_list|(
name|xt
argument_list|)
expr_stmt|;
name|eshup1
argument_list|(
name|xt
argument_list|)
expr_stmt|;
name|eaddm
argument_list|(
name|xt
argument_list|,
name|yy
argument_list|)
expr_stmt|;
block|}
comment|/* Insert the current digit.  */
name|ecleaz
argument_list|(
name|xt
argument_list|)
expr_stmt|;
name|xt
index|[
name|NI
operator|-
literal|2
index|]
operator|=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|k
expr_stmt|;
name|eaddm
argument_list|(
name|xt
argument_list|,
name|yy
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Mark any lost non-zero digit.  */
name|lost
operator||=
name|k
expr_stmt|;
comment|/* Count lost digits before the decimal point.  */
if|if
condition|(
name|decflg
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|base
operator|==
literal|10
condition|)
name|nexp
operator|-=
literal|1
expr_stmt|;
else|else
name|nexp
operator|-=
literal|4
expr_stmt|;
block|}
block|}
name|prec
operator|+=
literal|1
expr_stmt|;
goto|goto
name|donchr
goto|;
block|}
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'z'
case|:
break|break;
case|case
literal|'E'
case|:
case|case
literal|'e'
case|:
case|case
literal|'P'
case|:
case|case
literal|'p'
case|:
goto|goto
name|expnt
goto|;
case|case
literal|'.'
case|:
comment|/* decimal point */
if|if
condition|(
name|decflg
condition|)
goto|goto
name|error
goto|;
operator|++
name|decflg
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|nsign
operator|=
literal|0xffff
expr_stmt|;
if|if
condition|(
name|sgnflg
condition|)
goto|goto
name|error
goto|;
operator|++
name|sgnflg
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
if|if
condition|(
name|sgnflg
condition|)
goto|goto
name|error
goto|;
operator|++
name|sgnflg
expr_stmt|;
break|break;
case|case
literal|','
case|:
case|case
literal|' '
case|:
case|case
literal|'\0'
case|:
case|case
literal|'\n'
case|:
case|case
literal|'\r'
case|:
goto|goto
name|daldone
goto|;
case|case
literal|'i'
case|:
case|case
literal|'I'
case|:
goto|goto
name|infinite
goto|;
default|default:
name|error
label|:
ifdef|#
directive|ifdef
name|NANS
name|einan
argument_list|(
name|yy
argument_list|)
expr_stmt|;
else|#
directive|else
name|mtherr
argument_list|(
literal|"asctoe"
argument_list|,
name|DOMAIN
argument_list|)
expr_stmt|;
name|eclear
argument_list|(
name|yy
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|aexit
goto|;
block|}
name|donchr
label|:
operator|++
name|s
expr_stmt|;
goto|goto
name|nxtcom
goto|;
comment|/* Exponent interpretation */
name|expnt
label|:
comment|/* 0.0eXXX is zero, regardless of XXX.  Check for the 0.0. */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|NI
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|yy
index|[
name|k
index|]
operator|!=
literal|0
condition|)
goto|goto
name|read_expnt
goto|;
block|}
goto|goto
name|aexit
goto|;
name|read_expnt
label|:
name|esign
operator|=
literal|1
expr_stmt|;
name|exp
operator|=
literal|0
expr_stmt|;
operator|++
name|s
expr_stmt|;
comment|/* check for + or - */
if|if
condition|(
operator|*
name|s
operator|==
literal|'-'
condition|)
block|{
name|esign
operator|=
operator|-
literal|1
expr_stmt|;
operator|++
name|s
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'+'
condition|)
operator|++
name|s
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|s
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
operator|*
name|s
operator|<=
literal|'9'
operator|)
condition|)
block|{
name|exp
operator|*=
literal|10
expr_stmt|;
name|exp
operator|+=
operator|*
name|s
operator|++
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|exp
operator|>
literal|999999
condition|)
break|break;
block|}
if|if
condition|(
name|esign
operator|<
literal|0
condition|)
name|exp
operator|=
operator|-
name|exp
expr_stmt|;
if|if
condition|(
operator|(
name|exp
operator|>
name|MAXDECEXP
operator|)
operator|&&
operator|(
name|base
operator|==
literal|10
operator|)
condition|)
block|{
name|infinite
label|:
name|ecleaz
argument_list|(
name|yy
argument_list|)
expr_stmt|;
name|yy
index|[
name|E
index|]
operator|=
literal|0x7fff
expr_stmt|;
comment|/* infinity */
goto|goto
name|aexit
goto|;
block|}
if|if
condition|(
operator|(
name|exp
operator|<
name|MINDECEXP
operator|)
operator|&&
operator|(
name|base
operator|==
literal|10
operator|)
condition|)
block|{
name|zero
label|:
name|ecleaz
argument_list|(
name|yy
argument_list|)
expr_stmt|;
goto|goto
name|aexit
goto|;
block|}
name|daldone
label|:
if|if
condition|(
name|base
operator|==
literal|16
condition|)
block|{
comment|/* Base 16 hexadecimal floating constant.  */
if|if
condition|(
operator|(
name|k
operator|=
name|enormlz
argument_list|(
name|yy
argument_list|)
operator|)
operator|>
name|NBITS
condition|)
block|{
name|ecleaz
argument_list|(
name|yy
argument_list|)
expr_stmt|;
goto|goto
name|aexit
goto|;
block|}
comment|/* Adjust the exponent.  NEXP is the number of hex digits,          EXP is a power of 2.  */
name|lexp
operator|=
operator|(
name|EXONE
operator|-
literal|1
operator|+
name|NBITS
operator|)
operator|-
name|k
operator|+
name|yy
index|[
name|E
index|]
operator|+
name|exp
operator|-
name|nexp
expr_stmt|;
if|if
condition|(
name|lexp
operator|>
literal|0x7fff
condition|)
goto|goto
name|infinite
goto|;
if|if
condition|(
name|lexp
operator|<
literal|0
condition|)
goto|goto
name|zero
goto|;
name|yy
index|[
name|E
index|]
operator|=
name|lexp
expr_stmt|;
goto|goto
name|expdon
goto|;
block|}
name|nexp
operator|=
name|exp
operator|-
name|nexp
expr_stmt|;
comment|/* Pad trailing zeros to minimize power of 10, per IEEE spec.  */
while|while
condition|(
operator|(
name|nexp
operator|>
literal|0
operator|)
operator|&&
operator|(
name|yy
index|[
literal|2
index|]
operator|==
literal|0
operator|)
condition|)
block|{
name|emovz
argument_list|(
name|yy
argument_list|,
name|xt
argument_list|)
expr_stmt|;
name|eshup1
argument_list|(
name|xt
argument_list|)
expr_stmt|;
name|eshup1
argument_list|(
name|xt
argument_list|)
expr_stmt|;
name|eaddm
argument_list|(
name|yy
argument_list|,
name|xt
argument_list|)
expr_stmt|;
name|eshup1
argument_list|(
name|xt
argument_list|)
expr_stmt|;
if|if
condition|(
name|xt
index|[
literal|2
index|]
operator|!=
literal|0
condition|)
break|break;
name|nexp
operator|-=
literal|1
expr_stmt|;
name|emovz
argument_list|(
name|xt
argument_list|,
name|yy
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|k
operator|=
name|enormlz
argument_list|(
name|yy
argument_list|)
operator|)
operator|>
name|NBITS
condition|)
block|{
name|ecleaz
argument_list|(
name|yy
argument_list|)
expr_stmt|;
goto|goto
name|aexit
goto|;
block|}
name|lexp
operator|=
operator|(
name|EXONE
operator|-
literal|1
operator|+
name|NBITS
operator|)
operator|-
name|k
expr_stmt|;
name|emdnorm
argument_list|(
name|yy
argument_list|,
name|lost
argument_list|,
literal|0
argument_list|,
name|lexp
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|lost
operator|=
literal|0
expr_stmt|;
comment|/* Convert to external format:       Multiply by 10**nexp.  If precision is 64 bits,      the maximum relative error incurred in forming 10**n      for 0<= n<= 324 is 8.2e-20, at 10**180.      For 0<= n<= 999, the peak relative error is 1.4e-19 at 10**947.      For 0>= n>= -999, it is -1.55e-19 at 10**-435.  */
name|lexp
operator|=
name|yy
index|[
name|E
index|]
expr_stmt|;
if|if
condition|(
name|nexp
operator|==
literal|0
condition|)
block|{
name|k
operator|=
literal|0
expr_stmt|;
goto|goto
name|expdon
goto|;
block|}
name|esign
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|nexp
operator|<
literal|0
condition|)
block|{
name|nexp
operator|=
operator|-
name|nexp
expr_stmt|;
name|esign
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|nexp
operator|>
literal|4096
condition|)
block|{
comment|/* Punt.  Can't handle this without 2 divides.  */
name|emovi
argument_list|(
name|etens
index|[
literal|0
index|]
argument_list|,
name|tt
argument_list|)
expr_stmt|;
name|lexp
operator|-=
name|tt
index|[
name|E
index|]
expr_stmt|;
name|k
operator|=
name|edivm
argument_list|(
name|tt
argument_list|,
name|yy
argument_list|)
expr_stmt|;
name|lexp
operator|+=
name|EXONE
expr_stmt|;
name|nexp
operator|-=
literal|4096
expr_stmt|;
block|}
block|}
name|p
operator|=
operator|&
name|etens
index|[
name|NTEN
index|]
index|[
literal|0
index|]
expr_stmt|;
name|emov
argument_list|(
name|eone
argument_list|,
name|xt
argument_list|)
expr_stmt|;
name|exp
operator|=
literal|1
expr_stmt|;
do|do
block|{
if|if
condition|(
name|exp
operator|&
name|nexp
condition|)
name|emul
argument_list|(
name|p
argument_list|,
name|xt
argument_list|,
name|xt
argument_list|)
expr_stmt|;
name|p
operator|-=
name|NE
expr_stmt|;
name|exp
operator|=
name|exp
operator|+
name|exp
expr_stmt|;
block|}
do|while
condition|(
name|exp
operator|<=
name|MAXP
condition|)
do|;
name|emovi
argument_list|(
name|xt
argument_list|,
name|tt
argument_list|)
expr_stmt|;
if|if
condition|(
name|esign
operator|<
literal|0
condition|)
block|{
name|lexp
operator|-=
name|tt
index|[
name|E
index|]
expr_stmt|;
name|k
operator|=
name|edivm
argument_list|(
name|tt
argument_list|,
name|yy
argument_list|)
expr_stmt|;
name|lexp
operator|+=
name|EXONE
expr_stmt|;
block|}
else|else
block|{
name|lexp
operator|+=
name|tt
index|[
name|E
index|]
expr_stmt|;
name|k
operator|=
name|emulm
argument_list|(
name|tt
argument_list|,
name|yy
argument_list|)
expr_stmt|;
name|lexp
operator|-=
name|EXONE
operator|-
literal|1
expr_stmt|;
block|}
name|lost
operator|=
name|k
expr_stmt|;
name|expdon
label|:
comment|/* Round and convert directly to the destination type */
if|if
condition|(
name|oprec
operator|==
literal|53
condition|)
name|lexp
operator|-=
name|EXONE
operator|-
literal|0x3ff
expr_stmt|;
ifdef|#
directive|ifdef
name|C4X
elseif|else
if|if
condition|(
name|oprec
operator|==
literal|24
operator|||
name|oprec
operator|==
literal|32
condition|)
name|lexp
operator|-=
operator|(
name|EXONE
operator|-
literal|0x7f
operator|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|IBM
elseif|else
if|if
condition|(
name|oprec
operator|==
literal|24
operator|||
name|oprec
operator|==
literal|56
condition|)
name|lexp
operator|-=
name|EXONE
operator|-
operator|(
literal|0x41
operator|<<
literal|2
operator|)
expr_stmt|;
else|#
directive|else
elseif|else
if|if
condition|(
name|oprec
operator|==
literal|24
condition|)
name|lexp
operator|-=
name|EXONE
operator|-
literal|0177
expr_stmt|;
endif|#
directive|endif
comment|/* IBM */
endif|#
directive|endif
comment|/* C4X */
ifdef|#
directive|ifdef
name|DEC
elseif|else
if|if
condition|(
name|oprec
operator|==
literal|56
condition|)
name|lexp
operator|-=
name|EXONE
operator|-
literal|0201
expr_stmt|;
endif|#
directive|endif
name|rndprc
operator|=
name|oprec
expr_stmt|;
name|emdnorm
argument_list|(
name|yy
argument_list|,
name|lost
argument_list|,
literal|0
argument_list|,
name|lexp
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|aexit
label|:
name|rndprc
operator|=
name|rndsav
expr_stmt|;
name|yy
index|[
literal|0
index|]
operator|=
name|nsign
expr_stmt|;
switch|switch
condition|(
name|oprec
condition|)
block|{
ifdef|#
directive|ifdef
name|DEC
case|case
literal|56
case|:
name|todec
argument_list|(
name|yy
argument_list|,
name|y
argument_list|)
expr_stmt|;
comment|/* see etodec.c */
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IBM
case|case
literal|56
case|:
name|toibm
argument_list|(
name|yy
argument_list|,
name|y
argument_list|,
name|DFmode
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|C4X
case|case
literal|32
case|:
name|toc4x
argument_list|(
name|yy
argument_list|,
name|y
argument_list|,
name|HFmode
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|53
case|:
name|toe53
argument_list|(
name|yy
argument_list|,
name|y
argument_list|)
expr_stmt|;
break|break;
case|case
literal|24
case|:
name|toe24
argument_list|(
name|yy
argument_list|,
name|y
argument_list|)
expr_stmt|;
break|break;
case|case
literal|64
case|:
name|toe64
argument_list|(
name|yy
argument_list|,
name|y
argument_list|)
expr_stmt|;
break|break;
case|case
literal|113
case|:
name|toe113
argument_list|(
name|yy
argument_list|,
name|y
argument_list|)
expr_stmt|;
break|break;
case|case
name|NBITS
case|:
name|emovo
argument_list|(
name|yy
argument_list|,
name|y
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Return Y = largest integer not greater than X (truncated toward minus    infinity).  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|EMUSHORT
name|bmask
index|[]
init|=
block|{
literal|0xffff
block|,
literal|0xfffe
block|,
literal|0xfffc
block|,
literal|0xfff8
block|,
literal|0xfff0
block|,
literal|0xffe0
block|,
literal|0xffc0
block|,
literal|0xff80
block|,
literal|0xff00
block|,
literal|0xfe00
block|,
literal|0xfc00
block|,
literal|0xf800
block|,
literal|0xf000
block|,
literal|0xe000
block|,
literal|0xc000
block|,
literal|0x8000
block|,
literal|0x0000
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|efloor
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
name|unsigned
name|EMUSHORT
name|x
index|[]
decl_stmt|,
name|y
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|p
decl_stmt|;
name|int
name|e
decl_stmt|,
name|expon
decl_stmt|,
name|i
decl_stmt|;
name|unsigned
name|EMUSHORT
name|f
index|[
name|NE
index|]
decl_stmt|;
name|emov
argument_list|(
name|x
argument_list|,
name|f
argument_list|)
expr_stmt|;
comment|/* leave in external format */
name|expon
operator|=
operator|(
name|int
operator|)
name|f
index|[
name|NE
operator|-
literal|1
index|]
expr_stmt|;
name|e
operator|=
operator|(
name|expon
operator|&
literal|0x7fff
operator|)
operator|-
operator|(
name|EXONE
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|e
operator|<=
literal|0
condition|)
block|{
name|eclear
argument_list|(
name|y
argument_list|)
expr_stmt|;
goto|goto
name|isitneg
goto|;
block|}
comment|/* number of bits to clear out */
name|e
operator|=
name|NBITS
operator|-
name|e
expr_stmt|;
name|emov
argument_list|(
name|f
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|<=
literal|0
condition|)
return|return;
name|p
operator|=
operator|&
name|y
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
name|e
operator|>=
literal|16
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
name|e
operator|-=
literal|16
expr_stmt|;
block|}
comment|/* clear the remaining bits */
operator|*
name|p
operator|&=
name|bmask
index|[
name|e
index|]
expr_stmt|;
comment|/* truncate negatives toward minus infinity */
name|isitneg
label|:
if|if
condition|(
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|expon
operator|&
operator|(
name|unsigned
name|EMUSHORT
operator|)
literal|0x8000
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NE
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|f
index|[
name|i
index|]
operator|!=
name|y
index|[
name|i
index|]
condition|)
block|{
name|esub
argument_list|(
name|eone
argument_list|,
name|y
argument_list|,
name|y
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_block

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Return S and EXP such that  S * 2^EXP = X and .5<= S< 1.    For example, 1.1 = 0.55 * 2^1.  */
end_comment

begin_comment
unit|static void efrexp (x, exp, s)      unsigned EMUSHORT x[];      int *exp;      unsigned EMUSHORT s[]; {   unsigned EMUSHORT xi[NI];   EMULONG li;    emovi (x, xi);
comment|/*  Handle denormalized numbers properly using long integer exponent.  */
end_comment

begin_endif
unit|li = (EMULONG) ((EMUSHORT) xi[1]);    if (li == 0)     {       li -= enormlz (xi);     }   xi[1] = 0x3ffe;   emovo (xi, s);   *exp = (int) (li - 0x3ffe); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Return e type Y = X * 2^PWR2.  */
end_comment

begin_function
specifier|static
name|void
name|eldexp
parameter_list|(
name|x
parameter_list|,
name|pwr2
parameter_list|,
name|y
parameter_list|)
name|unsigned
name|EMUSHORT
name|x
index|[]
decl_stmt|;
name|int
name|pwr2
decl_stmt|;
name|unsigned
name|EMUSHORT
name|y
index|[]
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|xi
index|[
name|NI
index|]
decl_stmt|;
name|EMULONG
name|li
decl_stmt|;
name|int
name|i
decl_stmt|;
name|emovi
argument_list|(
name|x
argument_list|,
name|xi
argument_list|)
expr_stmt|;
name|li
operator|=
name|xi
index|[
literal|1
index|]
expr_stmt|;
name|li
operator|+=
name|pwr2
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|emdnorm
argument_list|(
name|xi
argument_list|,
name|i
argument_list|,
name|i
argument_list|,
name|li
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|emovo
argument_list|(
name|xi
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* C = remainder after dividing B by A, all e type values.    Least significant integer quotient bits left in EQUOT.  */
end_comment

begin_ifdef
unit|static void eremain (a, b, c)      unsigned EMUSHORT a[], b[], c[]; {   unsigned EMUSHORT den[NI], num[NI];
ifdef|#
directive|ifdef
name|NANS
end_ifdef

begin_endif
unit|if (eisinf (b)       || (ecmp (a, ezero) == 0)       || eisnan (a)       || eisnan (b))     {       enan (c, 0);       return;     }
endif|#
directive|endif
end_endif

begin_comment
unit|if (ecmp (a, ezero) == 0)     {       mtherr ("eremain", SING);       eclear (c);       return;     }   emovi (a, den);   emovi (b, num);   eiremain (den, num);
comment|/* Sign of remainder = sign of quotient */
end_comment

begin_endif
unit|if (a[0] == b[0])     num[0] = 0;   else     num[0] = 0xffff;   emovo (num, c); }
endif|#
directive|endif
end_endif

begin_comment
comment|/*  Return quotient of exploded e-types NUM / DEN in EQUOT,     remainder in NUM.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|eiremain
argument_list|(
name|den
argument_list|,
name|num
argument_list|)
name|unsigned
name|EMUSHORT
name|den
index|[]
decl_stmt|,
name|num
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|EMULONG
name|ld
decl_stmt|,
name|ln
decl_stmt|;
name|unsigned
name|EMUSHORT
name|j
decl_stmt|;
name|ld
operator|=
name|den
index|[
name|E
index|]
expr_stmt|;
name|ld
operator|-=
name|enormlz
argument_list|(
name|den
argument_list|)
expr_stmt|;
name|ln
operator|=
name|num
index|[
name|E
index|]
expr_stmt|;
name|ln
operator|-=
name|enormlz
argument_list|(
name|num
argument_list|)
expr_stmt|;
name|ecleaz
argument_list|(
name|equot
argument_list|)
expr_stmt|;
while|while
condition|(
name|ln
operator|>=
name|ld
condition|)
block|{
if|if
condition|(
name|ecmpm
argument_list|(
name|den
argument_list|,
name|num
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|esubm
argument_list|(
name|den
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|j
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|j
operator|=
literal|0
expr_stmt|;
name|eshup1
argument_list|(
name|equot
argument_list|)
expr_stmt|;
name|equot
index|[
name|NI
operator|-
literal|1
index|]
operator||=
name|j
expr_stmt|;
name|eshup1
argument_list|(
name|num
argument_list|)
expr_stmt|;
name|ln
operator|-=
literal|1
expr_stmt|;
block|}
name|emdnorm
argument_list|(
name|num
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ln
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Report an error condition CODE encountered in function NAME.      Mnemonic        Value          Significance       DOMAIN            1       argument domain error      SING              2       function singularity      OVERFLOW          3       overflow range error      UNDERFLOW         4       underflow range error      TLOSS             5       total loss of precision      PLOSS             6       partial loss of precision      INVALID           7       NaN - producing operation      EDOM             33       Unix domain error code      ERANGE           34       Unix range error code     The order of appearance of the following messages is bound to the    error codes defined above.  */
end_comment

begin_decl_stmt
name|int
name|merror
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|merror
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|mtherr
parameter_list|(
name|name
parameter_list|,
name|code
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|code
decl_stmt|;
block|{
comment|/* The string passed by the calling program is supposed to be the      name of the function in which the error occurred.      The code argument selects which error message string will be printed.  */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"esub"
argument_list|)
operator|==
literal|0
condition|)
name|name
operator|=
literal|"subtraction"
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"ediv"
argument_list|)
operator|==
literal|0
condition|)
name|name
operator|=
literal|"division"
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"emul"
argument_list|)
operator|==
literal|0
condition|)
name|name
operator|=
literal|"multiplication"
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"enormlz"
argument_list|)
operator|==
literal|0
condition|)
name|name
operator|=
literal|"normalization"
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"etoasc"
argument_list|)
operator|==
literal|0
condition|)
name|name
operator|=
literal|"conversion to text"
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"asctoe"
argument_list|)
operator|==
literal|0
condition|)
name|name
operator|=
literal|"parsing"
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"eremain"
argument_list|)
operator|==
literal|0
condition|)
name|name
operator|=
literal|"modulus"
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"esqrt"
argument_list|)
operator|==
literal|0
condition|)
name|name
operator|=
literal|"square root"
expr_stmt|;
if|if
condition|(
name|extra_warnings
condition|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|DOMAIN
case|:
name|warning
argument_list|(
literal|"%s: argument domain error"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|SING
case|:
name|warning
argument_list|(
literal|"%s: function singularity"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|OVERFLOW
case|:
name|warning
argument_list|(
literal|"%s: overflow range error"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNDERFLOW
case|:
name|warning
argument_list|(
literal|"%s: underflow range error"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|TLOSS
case|:
name|warning
argument_list|(
literal|"%s: total loss of precision"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|PLOSS
case|:
name|warning
argument_list|(
literal|"%s: partial loss of precision"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|INVALID
case|:
name|warning
argument_list|(
literal|"%s: NaN - producing operation"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Set global error message word */
name|merror
operator|=
name|code
operator|+
literal|1
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEC
end_ifdef

begin_comment
comment|/* Convert DEC double precision D to e type E.  */
end_comment

begin_function
specifier|static
name|void
name|dectoe
parameter_list|(
name|d
parameter_list|,
name|e
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|d
decl_stmt|;
name|unsigned
name|EMUSHORT
modifier|*
name|e
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|y
index|[
name|NI
index|]
decl_stmt|;
specifier|register
name|unsigned
name|EMUSHORT
name|r
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|ecleaz
argument_list|(
name|y
argument_list|)
expr_stmt|;
comment|/* start with a zero */
name|p
operator|=
name|y
expr_stmt|;
comment|/* point to our number */
name|r
operator|=
operator|*
name|d
expr_stmt|;
comment|/* get DEC exponent word */
if|if
condition|(
operator|*
name|d
operator|&
operator|(
name|unsigned
name|int
operator|)
literal|0x8000
condition|)
operator|*
name|p
operator|=
literal|0xffff
expr_stmt|;
comment|/* fill in our sign */
operator|++
name|p
expr_stmt|;
comment|/* bump pointer to our exponent word */
name|r
operator|&=
literal|0x7fff
expr_stmt|;
comment|/* strip the sign bit */
if|if
condition|(
name|r
operator|==
literal|0
condition|)
comment|/* answer = 0 if high order DEC word = 0 */
goto|goto
name|done
goto|;
name|r
operator|>>=
literal|7
expr_stmt|;
comment|/* shift exponent word down 7 bits */
name|r
operator|+=
name|EXONE
operator|-
literal|0201
expr_stmt|;
comment|/* subtract DEC exponent offset */
comment|/* add our e type exponent offset */
operator|*
name|p
operator|++
operator|=
name|r
expr_stmt|;
comment|/* to form our exponent */
name|r
operator|=
operator|*
name|d
operator|++
expr_stmt|;
comment|/* now do the high order mantissa */
name|r
operator|&=
literal|0177
expr_stmt|;
comment|/* strip off the DEC exponent and sign bits */
name|r
operator||=
literal|0200
expr_stmt|;
comment|/* the DEC understood high order mantissa bit */
operator|*
name|p
operator|++
operator|=
name|r
expr_stmt|;
comment|/* put result in our high guard word */
operator|*
name|p
operator|++
operator|=
operator|*
name|d
operator|++
expr_stmt|;
comment|/* fill in the rest of our mantissa */
operator|*
name|p
operator|++
operator|=
operator|*
name|d
operator|++
expr_stmt|;
operator|*
name|p
operator|=
operator|*
name|d
expr_stmt|;
name|eshdn8
argument_list|(
name|y
argument_list|)
expr_stmt|;
comment|/* shift our mantissa down 8 bits */
name|done
label|:
name|emovo
argument_list|(
name|y
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert e type X to DEC double precision D.  */
end_comment

begin_function
specifier|static
name|void
name|etodec
parameter_list|(
name|x
parameter_list|,
name|d
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|,
decl|*
name|d
decl_stmt|;
end_function

begin_block
block|{
name|unsigned
name|EMUSHORT
name|xi
index|[
name|NI
index|]
decl_stmt|;
name|EMULONG
name|exp
decl_stmt|;
name|int
name|rndsav
decl_stmt|;
name|emovi
argument_list|(
name|x
argument_list|,
name|xi
argument_list|)
expr_stmt|;
comment|/* Adjust exponent for offsets.  */
name|exp
operator|=
operator|(
name|EMULONG
operator|)
name|xi
index|[
name|E
index|]
operator|-
operator|(
name|EXONE
operator|-
literal|0201
operator|)
expr_stmt|;
comment|/* Round off to nearest or even.  */
name|rndsav
operator|=
name|rndprc
expr_stmt|;
name|rndprc
operator|=
literal|56
expr_stmt|;
name|emdnorm
argument_list|(
name|xi
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|exp
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|rndprc
operator|=
name|rndsav
expr_stmt|;
name|todec
argument_list|(
name|xi
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Convert exploded e-type X, that has already been rounded to    56-bit precision, to DEC format double Y.  */
end_comment

begin_function
specifier|static
name|void
name|todec
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|,
decl|*
name|y
decl_stmt|;
end_function

begin_block
block|{
name|unsigned
name|EMUSHORT
name|i
decl_stmt|;
name|unsigned
name|EMUSHORT
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|x
expr_stmt|;
operator|*
name|y
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
condition|)
operator|*
name|y
operator|=
literal|0100000
expr_stmt|;
name|i
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
operator|*
name|y
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|y
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|y
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|y
operator|++
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|i
operator|>
literal|0377
condition|)
block|{
operator|*
name|y
operator|++
operator||=
literal|077777
expr_stmt|;
operator|*
name|y
operator|++
operator|=
literal|0xffff
expr_stmt|;
operator|*
name|y
operator|++
operator|=
literal|0xffff
expr_stmt|;
operator|*
name|y
operator|++
operator|=
literal|0xffff
expr_stmt|;
ifdef|#
directive|ifdef
name|ERANGE
name|errno
operator|=
name|ERANGE
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
name|i
operator|&=
literal|0377
expr_stmt|;
name|i
operator|<<=
literal|7
expr_stmt|;
name|eshup8
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
index|[
name|M
index|]
operator|&=
literal|0177
expr_stmt|;
name|i
operator||=
name|x
index|[
name|M
index|]
expr_stmt|;
operator|*
name|y
operator|++
operator||=
name|i
expr_stmt|;
operator|*
name|y
operator|++
operator|=
name|x
index|[
name|M
operator|+
literal|1
index|]
expr_stmt|;
operator|*
name|y
operator|++
operator|=
name|x
index|[
name|M
operator|+
literal|2
index|]
expr_stmt|;
operator|*
name|y
operator|++
operator|=
name|x
index|[
name|M
operator|+
literal|3
index|]
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEC */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|IBM
end_ifdef

begin_comment
comment|/* Convert IBM single/double precision to e type.  */
end_comment

begin_function
specifier|static
name|void
name|ibmtoe
parameter_list|(
name|d
parameter_list|,
name|e
parameter_list|,
name|mode
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|d
decl_stmt|;
name|unsigned
name|EMUSHORT
modifier|*
name|e
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|y
index|[
name|NI
index|]
decl_stmt|;
specifier|register
name|unsigned
name|EMUSHORT
name|r
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|rndsav
decl_stmt|;
name|ecleaz
argument_list|(
name|y
argument_list|)
expr_stmt|;
comment|/* start with a zero */
name|p
operator|=
name|y
expr_stmt|;
comment|/* point to our number */
name|r
operator|=
operator|*
name|d
expr_stmt|;
comment|/* get IBM exponent word */
if|if
condition|(
operator|*
name|d
operator|&
operator|(
name|unsigned
name|int
operator|)
literal|0x8000
condition|)
operator|*
name|p
operator|=
literal|0xffff
expr_stmt|;
comment|/* fill in our sign */
operator|++
name|p
expr_stmt|;
comment|/* bump pointer to our exponent word */
name|r
operator|&=
literal|0x7f00
expr_stmt|;
comment|/* strip the sign bit */
name|r
operator|>>=
literal|6
expr_stmt|;
comment|/* shift exponent word down 6 bits */
comment|/* in fact shift by 8 right and 2 left */
name|r
operator|+=
name|EXONE
operator|-
operator|(
literal|0x41
operator|<<
literal|2
operator|)
expr_stmt|;
comment|/* subtract IBM exponent offset */
comment|/* add our e type exponent offset */
operator|*
name|p
operator|++
operator|=
name|r
expr_stmt|;
comment|/* to form our exponent */
operator|*
name|p
operator|++
operator|=
operator|*
name|d
operator|++
operator|&
literal|0xff
expr_stmt|;
comment|/* now do the high order mantissa */
comment|/* strip off the IBM exponent and sign bits */
if|if
condition|(
name|mode
operator|!=
name|SFmode
condition|)
comment|/* there are only 2 words in SFmode */
block|{
operator|*
name|p
operator|++
operator|=
operator|*
name|d
operator|++
expr_stmt|;
comment|/* fill in the rest of our mantissa */
operator|*
name|p
operator|++
operator|=
operator|*
name|d
operator|++
expr_stmt|;
block|}
operator|*
name|p
operator|=
operator|*
name|d
expr_stmt|;
if|if
condition|(
name|y
index|[
name|M
index|]
operator|==
literal|0
operator|&&
name|y
index|[
name|M
operator|+
literal|1
index|]
operator|==
literal|0
operator|&&
name|y
index|[
name|M
operator|+
literal|2
index|]
operator|==
literal|0
operator|&&
name|y
index|[
name|M
operator|+
literal|3
index|]
operator|==
literal|0
condition|)
name|y
index|[
literal|0
index|]
operator|=
name|y
index|[
name|E
index|]
operator|=
literal|0
expr_stmt|;
else|else
name|y
index|[
name|E
index|]
operator|-=
literal|5
operator|+
name|enormlz
argument_list|(
name|y
argument_list|)
expr_stmt|;
comment|/* now normalise the mantissa */
comment|/* handle change in RADIX */
name|emovo
argument_list|(
name|y
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert e type to IBM single/double precision.  */
end_comment

begin_function
specifier|static
name|void
name|etoibm
parameter_list|(
name|x
parameter_list|,
name|d
parameter_list|,
name|mode
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|,
decl|*
name|d
decl_stmt|;
end_function

begin_decl_stmt
name|enum
name|machine_mode
name|mode
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unsigned
name|EMUSHORT
name|xi
index|[
name|NI
index|]
decl_stmt|;
name|EMULONG
name|exp
decl_stmt|;
name|int
name|rndsav
decl_stmt|;
name|emovi
argument_list|(
name|x
argument_list|,
name|xi
argument_list|)
expr_stmt|;
name|exp
operator|=
operator|(
name|EMULONG
operator|)
name|xi
index|[
name|E
index|]
operator|-
operator|(
name|EXONE
operator|-
operator|(
literal|0x41
operator|<<
literal|2
operator|)
operator|)
expr_stmt|;
comment|/* adjust exponent for offsets */
comment|/* round off to nearest or even */
name|rndsav
operator|=
name|rndprc
expr_stmt|;
name|rndprc
operator|=
literal|56
expr_stmt|;
name|emdnorm
argument_list|(
name|xi
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|exp
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|rndprc
operator|=
name|rndsav
expr_stmt|;
name|toibm
argument_list|(
name|xi
argument_list|,
name|d
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|toibm
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|mode
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|,
decl|*
name|y
decl_stmt|;
end_function

begin_decl_stmt
name|enum
name|machine_mode
name|mode
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unsigned
name|EMUSHORT
name|i
decl_stmt|;
name|unsigned
name|EMUSHORT
modifier|*
name|p
decl_stmt|;
name|int
name|r
decl_stmt|;
name|p
operator|=
name|x
expr_stmt|;
operator|*
name|y
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
condition|)
operator|*
name|y
operator|=
literal|0x8000
expr_stmt|;
name|i
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
operator|*
name|y
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|y
operator|++
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|SFmode
condition|)
block|{
operator|*
name|y
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|y
operator|++
operator|=
literal|0
expr_stmt|;
block|}
return|return;
block|}
name|r
operator|=
name|i
operator|&
literal|0x3
expr_stmt|;
name|i
operator|>>=
literal|2
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0x7f
condition|)
block|{
operator|*
name|y
operator|++
operator||=
literal|0x7fff
expr_stmt|;
operator|*
name|y
operator|++
operator|=
literal|0xffff
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|SFmode
condition|)
block|{
operator|*
name|y
operator|++
operator|=
literal|0xffff
expr_stmt|;
operator|*
name|y
operator|++
operator|=
literal|0xffff
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ERANGE
name|errno
operator|=
name|ERANGE
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
name|i
operator|&=
literal|0x7f
expr_stmt|;
operator|*
name|y
operator||=
operator|(
name|i
operator|<<
literal|8
operator|)
expr_stmt|;
name|eshift
argument_list|(
name|x
argument_list|,
name|r
operator|+
literal|5
argument_list|)
expr_stmt|;
operator|*
name|y
operator|++
operator||=
name|x
index|[
name|M
index|]
expr_stmt|;
operator|*
name|y
operator|++
operator|=
name|x
index|[
name|M
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|SFmode
condition|)
block|{
operator|*
name|y
operator|++
operator|=
name|x
index|[
name|M
operator|+
literal|2
index|]
expr_stmt|;
operator|*
name|y
operator|++
operator|=
name|x
index|[
name|M
operator|+
literal|3
index|]
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IBM */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|C4X
end_ifdef

begin_comment
comment|/* Convert C4X single/double precision to e type.  */
end_comment

begin_function
specifier|static
name|void
name|c4xtoe
parameter_list|(
name|d
parameter_list|,
name|e
parameter_list|,
name|mode
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|d
decl_stmt|;
name|unsigned
name|EMUSHORT
modifier|*
name|e
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|y
index|[
name|NI
index|]
decl_stmt|;
name|int
name|r
decl_stmt|;
name|int
name|isnegative
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|carry
decl_stmt|;
comment|/* Short-circuit the zero case. */
if|if
condition|(
operator|(
name|d
index|[
literal|0
index|]
operator|==
literal|0x8000
operator|)
operator|&&
operator|(
name|d
index|[
literal|1
index|]
operator|==
literal|0x0000
operator|)
operator|&&
operator|(
operator|(
name|mode
operator|==
name|QFmode
operator|)
operator|||
operator|(
operator|(
name|d
index|[
literal|2
index|]
operator|==
literal|0x0000
operator|)
operator|&&
operator|(
name|d
index|[
literal|3
index|]
operator|==
literal|0x0000
operator|)
operator|)
operator|)
condition|)
block|{
name|e
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|e
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|e
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|e
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|e
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
name|e
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|ecleaz
argument_list|(
name|y
argument_list|)
expr_stmt|;
comment|/* start with a zero */
name|r
operator|=
name|d
index|[
literal|0
index|]
expr_stmt|;
comment|/* get sign/exponent part */
if|if
condition|(
name|r
operator|&
operator|(
name|unsigned
name|int
operator|)
literal|0x0080
condition|)
block|{
name|y
index|[
literal|0
index|]
operator|=
literal|0xffff
expr_stmt|;
comment|/* fill in our sign */
name|isnegative
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|isnegative
operator|=
name|FALSE
expr_stmt|;
block|}
name|r
operator|>>=
literal|8
expr_stmt|;
comment|/* Shift exponent word down 8 bits.  */
if|if
condition|(
name|r
operator|&
literal|0x80
condition|)
comment|/* Make the exponent negative if it is. */
block|{
name|r
operator|=
name|r
operator||
operator|(
operator|~
literal|0
operator|&
operator|~
literal|0xff
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|isnegative
condition|)
block|{
comment|/* Now do the high order mantissa.  We don't "or" on the high bit 	because it is 2 (not 1) and is handled a little differently 	below.  */
name|y
index|[
name|M
index|]
operator|=
name|d
index|[
literal|0
index|]
operator|&
literal|0x7f
expr_stmt|;
name|y
index|[
name|M
operator|+
literal|1
index|]
operator|=
name|d
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|QFmode
condition|)
comment|/* There are only 2 words in QFmode.  */
block|{
name|y
index|[
name|M
operator|+
literal|2
index|]
operator|=
name|d
index|[
literal|2
index|]
expr_stmt|;
comment|/* Fill in the rest of our mantissa.  */
name|y
index|[
name|M
operator|+
literal|3
index|]
operator|=
name|d
index|[
literal|3
index|]
expr_stmt|;
name|size
operator|=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|size
operator|=
literal|2
expr_stmt|;
block|}
name|eshift
argument_list|(
name|y
argument_list|,
operator|-
literal|8
argument_list|)
expr_stmt|;
comment|/* Now do the two's complement on the data.  */
name|carry
operator|=
literal|1
expr_stmt|;
comment|/* Initially add 1 for the two's complement. */
for|for
control|(
name|i
operator|=
name|size
operator|+
name|M
init|;
name|i
operator|>
name|M
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|carry
operator|&&
operator|(
name|y
index|[
name|i
index|]
operator|==
literal|0x0000
operator|)
condition|)
block|{
comment|/* We overflowed into the next word, carry is the same.  */
name|y
index|[
name|i
index|]
operator|=
name|carry
condition|?
literal|0x0000
else|:
literal|0xffff
expr_stmt|;
block|}
else|else
block|{
comment|/* No overflow, just invert and add carry.  */
name|y
index|[
name|i
index|]
operator|=
operator|(
operator|(
operator|~
name|y
index|[
name|i
index|]
operator|)
operator|+
name|carry
operator|)
operator|&
literal|0xffff
expr_stmt|;
name|carry
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|carry
condition|)
block|{
name|eshift
argument_list|(
name|y
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|y
index|[
name|M
operator|+
literal|1
index|]
operator||=
literal|0x8000
expr_stmt|;
name|r
operator|++
expr_stmt|;
block|}
name|y
index|[
literal|1
index|]
operator|=
name|r
operator|+
name|EXONE
expr_stmt|;
block|}
else|else
block|{
comment|/* Add our e type exponent offset to form our exponent.  */
name|r
operator|+=
name|EXONE
expr_stmt|;
name|y
index|[
literal|1
index|]
operator|=
name|r
expr_stmt|;
comment|/* Now do the high order mantissa strip off the exponent and sign 	bits and add the high 1 bit.  */
name|y
index|[
name|M
index|]
operator|=
operator|(
name|d
index|[
literal|0
index|]
operator|&
literal|0x7f
operator|)
operator||
literal|0x80
expr_stmt|;
name|y
index|[
name|M
operator|+
literal|1
index|]
operator|=
name|d
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|QFmode
condition|)
comment|/* There are only 2 words in QFmode.  */
block|{
name|y
index|[
name|M
operator|+
literal|2
index|]
operator|=
name|d
index|[
literal|2
index|]
expr_stmt|;
comment|/* Fill in the rest of our mantissa.  */
name|y
index|[
name|M
operator|+
literal|3
index|]
operator|=
name|d
index|[
literal|3
index|]
expr_stmt|;
block|}
name|eshift
argument_list|(
name|y
argument_list|,
operator|-
literal|8
argument_list|)
expr_stmt|;
block|}
name|emovo
argument_list|(
name|y
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert e type to C4X single/double precision.  */
end_comment

begin_function
specifier|static
name|void
name|etoc4x
parameter_list|(
name|x
parameter_list|,
name|d
parameter_list|,
name|mode
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|,
decl|*
name|d
decl_stmt|;
end_function

begin_decl_stmt
name|enum
name|machine_mode
name|mode
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unsigned
name|EMUSHORT
name|xi
index|[
name|NI
index|]
decl_stmt|;
name|EMULONG
name|exp
decl_stmt|;
name|int
name|rndsav
decl_stmt|;
name|emovi
argument_list|(
name|x
argument_list|,
name|xi
argument_list|)
expr_stmt|;
comment|/* Adjust exponent for offsets. */
name|exp
operator|=
operator|(
name|EMULONG
operator|)
name|xi
index|[
name|E
index|]
operator|-
operator|(
name|EXONE
operator|-
literal|0x7f
operator|)
expr_stmt|;
comment|/* Round off to nearest or even. */
name|rndsav
operator|=
name|rndprc
expr_stmt|;
name|rndprc
operator|=
name|mode
operator|==
name|QFmode
condition|?
literal|24
else|:
literal|32
expr_stmt|;
name|emdnorm
argument_list|(
name|xi
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|exp
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|rndprc
operator|=
name|rndsav
expr_stmt|;
name|toc4x
argument_list|(
name|xi
argument_list|,
name|d
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|toc4x
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|mode
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|,
decl|*
name|y
decl_stmt|;
end_function

begin_decl_stmt
name|enum
name|machine_mode
name|mode
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|int
name|v
decl_stmt|;
name|int
name|carry
decl_stmt|;
comment|/* Short-circuit the zero case */
if|if
condition|(
operator|(
name|x
index|[
literal|0
index|]
operator|==
literal|0
operator|)
comment|/* Zero exponent and sign */
operator|&&
operator|(
name|x
index|[
literal|1
index|]
operator|==
literal|0
operator|)
operator|&&
operator|(
name|x
index|[
name|M
index|]
operator|==
literal|0
operator|)
comment|/* The rest is for zero mantissa */
operator|&&
operator|(
name|x
index|[
name|M
operator|+
literal|1
index|]
operator|==
literal|0
operator|)
comment|/* Only check for double if necessary */
operator|&&
operator|(
operator|(
name|mode
operator|==
name|QFmode
operator|)
operator|||
operator|(
operator|(
name|x
index|[
name|M
operator|+
literal|2
index|]
operator|==
literal|0
operator|)
operator|&&
operator|(
name|x
index|[
name|M
operator|+
literal|3
index|]
operator|==
literal|0
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* We have a zero.  Put it into the output and return. */
operator|*
name|y
operator|++
operator|=
literal|0x8000
expr_stmt|;
operator|*
name|y
operator|++
operator|=
literal|0x0000
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|QFmode
condition|)
block|{
operator|*
name|y
operator|++
operator|=
literal|0x0000
expr_stmt|;
operator|*
name|y
operator|++
operator|=
literal|0x0000
expr_stmt|;
block|}
return|return;
block|}
operator|*
name|y
operator|=
literal|0
expr_stmt|;
comment|/* Negative number require a two's complement conversion of the      mantissa. */
if|if
condition|(
name|x
index|[
literal|0
index|]
condition|)
block|{
operator|*
name|y
operator|=
literal|0x0080
expr_stmt|;
name|i
operator|=
operator|(
operator|(
name|int
operator|)
name|x
index|[
literal|1
index|]
operator|)
operator|-
literal|0x7f
expr_stmt|;
comment|/* Now add 1 to the inverted data to do the two's complement. */
if|if
condition|(
name|mode
operator|!=
name|QFmode
condition|)
name|v
operator|=
literal|4
operator|+
name|M
expr_stmt|;
else|else
name|v
operator|=
literal|2
operator|+
name|M
expr_stmt|;
name|carry
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|v
operator|>
name|M
condition|)
block|{
if|if
condition|(
name|x
index|[
name|v
index|]
operator|==
literal|0x0000
condition|)
block|{
name|x
index|[
name|v
index|]
operator|=
name|carry
condition|?
literal|0x0000
else|:
literal|0xffff
expr_stmt|;
block|}
else|else
block|{
name|x
index|[
name|v
index|]
operator|=
operator|(
operator|(
operator|~
name|x
index|[
name|v
index|]
operator|)
operator|+
name|carry
operator|)
operator|&
literal|0xffff
expr_stmt|;
name|carry
operator|=
literal|0
expr_stmt|;
block|}
name|v
operator|--
expr_stmt|;
block|}
comment|/* The following is a special case.  The C4X negative float requires 	 a zero in the high bit (because the format is (2 - x) x 2^m), so 	 if a one is in that bit, we have to shift left one to get rid 	 of it.  This only occurs if the number is -1 x 2^m. */
if|if
condition|(
name|x
index|[
name|M
operator|+
literal|1
index|]
operator|&
literal|0x8000
condition|)
block|{
comment|/* This is the case of -1 x 2^m, we have to rid ourselves of the 	     high sign bit and shift the exponent. */
name|eshift
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|i
operator|--
expr_stmt|;
block|}
block|}
else|else
block|{
name|i
operator|=
operator|(
operator|(
name|int
operator|)
name|x
index|[
literal|1
index|]
operator|)
operator|-
literal|0x7f
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|i
operator|<
operator|-
literal|128
operator|)
operator|||
operator|(
name|i
operator|>
literal|127
operator|)
condition|)
block|{
name|y
index|[
literal|0
index|]
operator||=
literal|0xff7f
expr_stmt|;
name|y
index|[
literal|1
index|]
operator|=
literal|0xffff
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|QFmode
condition|)
block|{
name|y
index|[
literal|2
index|]
operator|=
literal|0xffff
expr_stmt|;
name|y
index|[
literal|3
index|]
operator|=
literal|0xffff
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ERANGE
name|errno
operator|=
name|ERANGE
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
name|y
index|[
literal|0
index|]
operator||=
operator|(
operator|(
name|i
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
name|eshift
argument_list|(
name|x
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|y
index|[
literal|0
index|]
operator||=
name|x
index|[
name|M
index|]
operator|&
literal|0x7f
expr_stmt|;
name|y
index|[
literal|1
index|]
operator|=
name|x
index|[
name|M
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|QFmode
condition|)
block|{
name|y
index|[
literal|2
index|]
operator|=
name|x
index|[
name|M
operator|+
literal|2
index|]
expr_stmt|;
name|y
index|[
literal|3
index|]
operator|=
name|x
index|[
name|M
operator|+
literal|3
index|]
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* C4X */
end_comment

begin_comment
comment|/* Output a binary NaN bit pattern in the target machine's format.  */
end_comment

begin_comment
comment|/* If special NaN bit patterns are required, define them in tm.h    as arrays of unsigned 16-bit shorts.  Otherwise, use the default    patterns here.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TFMODE_NAN
end_ifdef

begin_expr_stmt
name|TFMODE_NAN
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE
end_ifdef

begin_decl_stmt
name|unsigned
name|EMUSHORT
name|TFbignan
index|[
literal|8
index|]
init|=
block|{
literal|0x7fff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|EMUSHORT
name|TFlittlenan
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0x8000
block|,
literal|0xffff
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|XFMODE_NAN
end_ifdef

begin_expr_stmt
name|XFMODE_NAN
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE
end_ifdef

begin_decl_stmt
name|unsigned
name|EMUSHORT
name|XFbignan
index|[
literal|6
index|]
init|=
block|{
literal|0x7fff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|EMUSHORT
name|XFlittlenan
index|[
literal|6
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0xc000
block|,
literal|0xffff
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DFMODE_NAN
end_ifdef

begin_expr_stmt
name|DFMODE_NAN
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE
end_ifdef

begin_decl_stmt
name|unsigned
name|EMUSHORT
name|DFbignan
index|[
literal|4
index|]
init|=
block|{
literal|0x7fff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|EMUSHORT
name|DFlittlenan
index|[
literal|4
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0xfff8
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SFMODE_NAN
end_ifdef

begin_expr_stmt
name|SFMODE_NAN
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE
end_ifdef

begin_decl_stmt
name|unsigned
name|EMUSHORT
name|SFbignan
index|[
literal|2
index|]
init|=
block|{
literal|0x7fff
block|,
literal|0xffff
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|EMUSHORT
name|SFlittlenan
index|[
literal|2
index|]
init|=
block|{
literal|0
block|,
literal|0xffc0
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|make_nan
parameter_list|(
name|nan
parameter_list|,
name|sign
parameter_list|,
name|mode
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|nan
decl_stmt|;
name|int
name|sign
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
name|unsigned
name|EMUSHORT
modifier|*
name|p
decl_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
comment|/* Possibly the `reserved operand' patterns on a VAX can be    used like NaN's, but probably not in the same way as IEEE.  */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DEC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|IBM
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|C4X
argument_list|)
case|case
name|TFmode
case|:
name|n
operator|=
literal|8
expr_stmt|;
if|if
condition|(
name|REAL_WORDS_BIG_ENDIAN
condition|)
name|p
operator|=
name|TFbignan
expr_stmt|;
else|else
name|p
operator|=
name|TFlittlenan
expr_stmt|;
break|break;
case|case
name|XFmode
case|:
name|n
operator|=
literal|6
expr_stmt|;
if|if
condition|(
name|REAL_WORDS_BIG_ENDIAN
condition|)
name|p
operator|=
name|XFbignan
expr_stmt|;
else|else
name|p
operator|=
name|XFlittlenan
expr_stmt|;
break|break;
case|case
name|DFmode
case|:
name|n
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|REAL_WORDS_BIG_ENDIAN
condition|)
name|p
operator|=
name|DFbignan
expr_stmt|;
else|else
name|p
operator|=
name|DFlittlenan
expr_stmt|;
break|break;
case|case
name|SFmode
case|:
case|case
name|HFmode
case|:
name|n
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|REAL_WORDS_BIG_ENDIAN
condition|)
name|p
operator|=
name|SFbignan
expr_stmt|;
else|else
name|p
operator|=
name|SFlittlenan
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|REAL_WORDS_BIG_ENDIAN
condition|)
operator|*
name|nan
operator|++
operator|=
operator|(
name|sign
operator|<<
literal|15
operator|)
operator||
operator|(
operator|*
name|p
operator|++
operator|&
literal|0x7fff
operator|)
expr_stmt|;
while|while
condition|(
operator|--
name|n
operator|!=
literal|0
condition|)
operator|*
name|nan
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|REAL_WORDS_BIG_ENDIAN
condition|)
operator|*
name|nan
operator|=
operator|(
name|sign
operator|<<
literal|15
operator|)
operator||
operator|(
operator|*
name|p
operator|&
literal|0x7fff
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is the inverse of the function `etarsingle' invoked by    REAL_VALUE_TO_TARGET_SINGLE.  */
end_comment

begin_function
name|REAL_VALUE_TYPE
name|ereal_unto_float
parameter_list|(
name|f
parameter_list|)
name|long
name|f
decl_stmt|;
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|unsigned
name|EMUSHORT
name|s
index|[
literal|2
index|]
decl_stmt|;
name|unsigned
name|EMUSHORT
name|e
index|[
name|NE
index|]
decl_stmt|;
comment|/* Convert 32 bit integer to array of 16 bit pieces in target machine order.    This is the inverse operation to what the function `endian' does.  */
if|if
condition|(
name|REAL_WORDS_BIG_ENDIAN
condition|)
block|{
name|s
index|[
literal|0
index|]
operator|=
call|(
name|unsigned
name|EMUSHORT
call|)
argument_list|(
name|f
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|s
index|[
literal|1
index|]
operator|=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|f
expr_stmt|;
block|}
else|else
block|{
name|s
index|[
literal|0
index|]
operator|=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|f
expr_stmt|;
name|s
index|[
literal|1
index|]
operator|=
call|(
name|unsigned
name|EMUSHORT
call|)
argument_list|(
name|f
operator|>>
literal|16
argument_list|)
expr_stmt|;
block|}
comment|/* Convert and promote the target float to E-type. */
name|e24toe
argument_list|(
name|s
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|/* Output E-type to REAL_VALUE_TYPE. */
name|PUT_REAL
argument_list|(
name|e
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* This is the inverse of the function `etardouble' invoked by    REAL_VALUE_TO_TARGET_DOUBLE.  */
end_comment

begin_function
name|REAL_VALUE_TYPE
name|ereal_unto_double
parameter_list|(
name|d
parameter_list|)
name|long
name|d
index|[]
decl_stmt|;
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|unsigned
name|EMUSHORT
name|s
index|[
literal|4
index|]
decl_stmt|;
name|unsigned
name|EMUSHORT
name|e
index|[
name|NE
index|]
decl_stmt|;
comment|/* Convert array of HOST_WIDE_INT to equivalent array of 16-bit pieces.  */
if|if
condition|(
name|REAL_WORDS_BIG_ENDIAN
condition|)
block|{
name|s
index|[
literal|0
index|]
operator|=
call|(
name|unsigned
name|EMUSHORT
call|)
argument_list|(
name|d
index|[
literal|0
index|]
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|s
index|[
literal|1
index|]
operator|=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|d
index|[
literal|0
index|]
expr_stmt|;
name|s
index|[
literal|2
index|]
operator|=
call|(
name|unsigned
name|EMUSHORT
call|)
argument_list|(
name|d
index|[
literal|1
index|]
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|s
index|[
literal|3
index|]
operator|=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|d
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
comment|/* Target float words are little-endian.  */
name|s
index|[
literal|0
index|]
operator|=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|d
index|[
literal|0
index|]
expr_stmt|;
name|s
index|[
literal|1
index|]
operator|=
call|(
name|unsigned
name|EMUSHORT
call|)
argument_list|(
name|d
index|[
literal|0
index|]
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|s
index|[
literal|2
index|]
operator|=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|d
index|[
literal|1
index|]
expr_stmt|;
name|s
index|[
literal|3
index|]
operator|=
call|(
name|unsigned
name|EMUSHORT
call|)
argument_list|(
name|d
index|[
literal|1
index|]
operator|>>
literal|16
argument_list|)
expr_stmt|;
block|}
comment|/* Convert target double to E-type. */
name|e53toe
argument_list|(
name|s
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|/* Output E-type to REAL_VALUE_TYPE. */
name|PUT_REAL
argument_list|(
name|e
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Convert an SFmode target `float' value to a REAL_VALUE_TYPE.    This is somewhat like ereal_unto_float, but the input types    for these are different.  */
end_comment

begin_function
name|REAL_VALUE_TYPE
name|ereal_from_float
parameter_list|(
name|f
parameter_list|)
name|HOST_WIDE_INT
name|f
decl_stmt|;
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|unsigned
name|EMUSHORT
name|s
index|[
literal|2
index|]
decl_stmt|;
name|unsigned
name|EMUSHORT
name|e
index|[
name|NE
index|]
decl_stmt|;
comment|/* Convert 32 bit integer to array of 16 bit pieces in target machine order.    This is the inverse operation to what the function `endian' does.  */
if|if
condition|(
name|REAL_WORDS_BIG_ENDIAN
condition|)
block|{
name|s
index|[
literal|0
index|]
operator|=
call|(
name|unsigned
name|EMUSHORT
call|)
argument_list|(
name|f
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|s
index|[
literal|1
index|]
operator|=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|f
expr_stmt|;
block|}
else|else
block|{
name|s
index|[
literal|0
index|]
operator|=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|f
expr_stmt|;
name|s
index|[
literal|1
index|]
operator|=
call|(
name|unsigned
name|EMUSHORT
call|)
argument_list|(
name|f
operator|>>
literal|16
argument_list|)
expr_stmt|;
block|}
comment|/* Convert and promote the target float to E-type.  */
name|e24toe
argument_list|(
name|s
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|/* Output E-type to REAL_VALUE_TYPE.  */
name|PUT_REAL
argument_list|(
name|e
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Convert a DFmode target `double' value to a REAL_VALUE_TYPE.    This is somewhat like ereal_unto_double, but the input types    for these are different.     The DFmode is stored as an array of HOST_WIDE_INT in the target's    data format, with no holes in the bit packing.  The first element    of the input array holds the bits that would come first in the    target computer's memory.  */
end_comment

begin_function
name|REAL_VALUE_TYPE
name|ereal_from_double
parameter_list|(
name|d
parameter_list|)
name|HOST_WIDE_INT
name|d
index|[]
decl_stmt|;
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|unsigned
name|EMUSHORT
name|s
index|[
literal|4
index|]
decl_stmt|;
name|unsigned
name|EMUSHORT
name|e
index|[
name|NE
index|]
decl_stmt|;
comment|/* Convert array of HOST_WIDE_INT to equivalent array of 16-bit pieces.  */
if|if
condition|(
name|REAL_WORDS_BIG_ENDIAN
condition|)
block|{
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|32
name|s
index|[
literal|0
index|]
operator|=
call|(
name|unsigned
name|EMUSHORT
call|)
argument_list|(
name|d
index|[
literal|0
index|]
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|s
index|[
literal|1
index|]
operator|=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|d
index|[
literal|0
index|]
expr_stmt|;
name|s
index|[
literal|2
index|]
operator|=
call|(
name|unsigned
name|EMUSHORT
call|)
argument_list|(
name|d
index|[
literal|1
index|]
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|s
index|[
literal|3
index|]
operator|=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|d
index|[
literal|1
index|]
expr_stmt|;
else|#
directive|else
comment|/* In this case the entire target double is contained in the 	 first array element.  The second element of the input is 	 ignored.  */
name|s
index|[
literal|0
index|]
operator|=
call|(
name|unsigned
name|EMUSHORT
call|)
argument_list|(
name|d
index|[
literal|0
index|]
operator|>>
literal|48
argument_list|)
expr_stmt|;
name|s
index|[
literal|1
index|]
operator|=
call|(
name|unsigned
name|EMUSHORT
call|)
argument_list|(
name|d
index|[
literal|0
index|]
operator|>>
literal|32
argument_list|)
expr_stmt|;
name|s
index|[
literal|2
index|]
operator|=
call|(
name|unsigned
name|EMUSHORT
call|)
argument_list|(
name|d
index|[
literal|0
index|]
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|s
index|[
literal|3
index|]
operator|=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|d
index|[
literal|0
index|]
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* Target float words are little-endian.  */
name|s
index|[
literal|0
index|]
operator|=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|d
index|[
literal|0
index|]
expr_stmt|;
name|s
index|[
literal|1
index|]
operator|=
call|(
name|unsigned
name|EMUSHORT
call|)
argument_list|(
name|d
index|[
literal|0
index|]
operator|>>
literal|16
argument_list|)
expr_stmt|;
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|32
name|s
index|[
literal|2
index|]
operator|=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|d
index|[
literal|1
index|]
expr_stmt|;
name|s
index|[
literal|3
index|]
operator|=
call|(
name|unsigned
name|EMUSHORT
call|)
argument_list|(
name|d
index|[
literal|1
index|]
operator|>>
literal|16
argument_list|)
expr_stmt|;
else|#
directive|else
name|s
index|[
literal|2
index|]
operator|=
call|(
name|unsigned
name|EMUSHORT
call|)
argument_list|(
name|d
index|[
literal|0
index|]
operator|>>
literal|32
argument_list|)
expr_stmt|;
name|s
index|[
literal|3
index|]
operator|=
call|(
name|unsigned
name|EMUSHORT
call|)
argument_list|(
name|d
index|[
literal|0
index|]
operator|>>
literal|48
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Convert target double to E-type.  */
name|e53toe
argument_list|(
name|s
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|/* Output E-type to REAL_VALUE_TYPE.  */
name|PUT_REAL
argument_list|(
name|e
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Convert target computer unsigned 64-bit integer to e-type.    The endian-ness of DImode follows the convention for integers,    so we use WORDS_BIG_ENDIAN here, not REAL_WORDS_BIG_ENDIAN.  */
end_comment

begin_comment
unit|static void uditoe (di, e)      unsigned EMUSHORT *di;
comment|/* Address of the 64-bit int.  */
end_comment

begin_comment
unit|unsigned EMUSHORT *e; {   unsigned EMUSHORT yi[NI];   int k;    ecleaz (yi);   if (WORDS_BIG_ENDIAN)     {       for (k = M; k< M + 4; k++) 	yi[k] = *di++;     }   else     {       for (k = M + 3; k>= M; k--) 	yi[k] = *di++;     }   yi[E] = EXONE + 47;
comment|/* exponent if normalize shift count were 0 */
end_comment

begin_comment
unit|if ((k = enormlz (yi))> NBITS)
comment|/* normalize the significand */
end_comment

begin_comment
unit|ecleaz (yi);
comment|/* it was zero */
end_comment

begin_comment
unit|else     yi[E] -= (unsigned EMUSHORT) k;
comment|/* subtract shift count from exponent */
end_comment

begin_comment
unit|emovo (yi, e); }
comment|/* Convert target computer signed 64-bit integer to e-type.  */
end_comment

begin_comment
unit|static void ditoe (di, e)      unsigned EMUSHORT *di;
comment|/* Address of the 64-bit int.  */
end_comment

begin_comment
unit|unsigned EMUSHORT *e; {   unsigned EMULONG acc;   unsigned EMUSHORT yi[NI];   unsigned EMUSHORT carry;   int k, sign;    ecleaz (yi);   if (WORDS_BIG_ENDIAN)     {       for (k = M; k< M + 4; k++) 	yi[k] = *di++;     }   else     {       for (k = M + 3; k>= M; k--) 	yi[k] = *di++;     }
comment|/* Take absolute value */
end_comment

begin_comment
unit|sign = 0;   if (yi[M]& 0x8000)     {       sign = 1;       carry = 0;       for (k = M + 3; k>= M; k--) 	{ 	  acc = (unsigned EMULONG) (~yi[k]& 0xffff) + carry; 	  yi[k] = acc; 	  carry = 0; 	  if (acc& 0x10000) 	    carry = 1; 	}     }   yi[E] = EXONE + 47;
comment|/* exponent if normalize shift count were 0 */
end_comment

begin_comment
unit|if ((k = enormlz (yi))> NBITS)
comment|/* normalize the significand */
end_comment

begin_comment
unit|ecleaz (yi);
comment|/* it was zero */
end_comment

begin_comment
unit|else     yi[E] -= (unsigned EMUSHORT) k;
comment|/* subtract shift count from exponent */
end_comment

begin_comment
unit|emovo (yi, e);   if (sign) 	eneg (e); }
comment|/* Convert e-type to unsigned 64-bit int.  */
end_comment

begin_comment
unit|static void etoudi (x, i)      unsigned EMUSHORT *x;      unsigned EMUSHORT *i; {   unsigned EMUSHORT xi[NI];   int j, k;    emovi (x, xi);   if (xi[0])     {       xi[M] = 0;       goto noshift;     }   k = (int) xi[E] - (EXONE - 1);   if (k<= 0)     {       for (j = 0; j< 4; j++) 	*i++ = 0;       return;     }   if (k> 64)     {       for (j = 0; j< 4; j++) 	*i++ = 0xffff;       if (extra_warnings) 	warning ("overflow on truncation to integer");       return;     }   if (k> 16)     {
comment|/* Shift more than 16 bits: first shift up k-16 mod 16, 	 then shift up by 16's.  */
end_comment

begin_comment
unit|j = k - ((k>> 4)<< 4);       if (j == 0) 	j = 16;       eshift (xi, j);       if (WORDS_BIG_ENDIAN) 	*i++ = xi[M];       else 	{ 	  i += 3; 	  *i-- = xi[M]; 	}       k -= j;       do 	{ 	  eshup6 (xi); 	  if (WORDS_BIG_ENDIAN) 	    *i++ = xi[M]; 	  else 	    *i-- = xi[M]; 	}       while ((k -= 16)> 0);     }   else     {
comment|/* shift not more than 16 bits */
end_comment

begin_comment
unit|eshift (xi, k);  noshift:        if (WORDS_BIG_ENDIAN) 	{ 	  i += 3; 	  *i-- = xi[M]; 	  *i-- = 0; 	  *i-- = 0; 	  *i = 0; 	}       else 	{ 	  *i++ = xi[M]; 	  *i++ = 0; 	  *i++ = 0; 	  *i = 0; 	}     } }
comment|/* Convert e-type to signed 64-bit int.  */
end_comment

begin_comment
unit|static void etodi (x, i)      unsigned EMUSHORT *x;      unsigned EMUSHORT *i; {   unsigned EMULONG acc;   unsigned EMUSHORT xi[NI];   unsigned EMUSHORT carry;   unsigned EMUSHORT *isave;   int j, k;    emovi (x, xi);   k = (int) xi[E] - (EXONE - 1);   if (k<= 0)     {       for (j = 0; j< 4; j++) 	*i++ = 0;       return;     }   if (k> 64)     {       for (j = 0; j< 4; j++) 	*i++ = 0xffff;       if (extra_warnings) 	warning ("overflow on truncation to integer");       return;     }   isave = i;   if (k> 16)     {
comment|/* Shift more than 16 bits: first shift up k-16 mod 16, 	 then shift up by 16's.  */
end_comment

begin_comment
unit|j = k - ((k>> 4)<< 4);       if (j == 0) 	j = 16;       eshift (xi, j);       if (WORDS_BIG_ENDIAN) 	*i++ = xi[M];       else 	{ 	  i += 3; 	  *i-- = xi[M]; 	}       k -= j;       do 	{ 	  eshup6 (xi); 	  if (WORDS_BIG_ENDIAN) 	    *i++ = xi[M]; 	  else 	    *i-- = xi[M]; 	}       while ((k -= 16)> 0);     }   else     {
comment|/* shift not more than 16 bits */
end_comment

begin_comment
unit|eshift (xi, k);        if (WORDS_BIG_ENDIAN) 	{ 	  i += 3; 	  *i = xi[M]; 	  *i-- = 0; 	  *i-- = 0; 	  *i = 0; 	}       else 	{ 	  *i++ = xi[M]; 	  *i++ = 0; 	  *i++ = 0; 	  *i = 0; 	}     }
comment|/* Negate if negative */
end_comment

begin_comment
unit|if (xi[0])     {       carry = 0;       if (WORDS_BIG_ENDIAN) 	isave += 3;       for (k = 0; k< 4; k++) 	{ 	  acc = (unsigned EMULONG) (~(*isave)& 0xffff) + carry; 	  if (WORDS_BIG_ENDIAN) 	    *isave-- = acc; 	  else 	    *isave++ = acc; 	  carry = 0; 	  if (acc& 0x10000) 	    carry = 1; 	}     } }
comment|/* Longhand square root routine.  */
end_comment

begin_comment
unit|static int esqinited = 0; static unsigned short sqrndbit[NI];  static void esqrt (x, y)      unsigned EMUSHORT *x, *y; {   unsigned EMUSHORT temp[NI], num[NI], sq[NI], xx[NI];   EMULONG m, exp;   int i, j, k, n, nlups;    if (esqinited == 0)     {       ecleaz (sqrndbit);       sqrndbit[NI - 2] = 1;       esqinited = 1;     }
comment|/* Check for arg<= 0 */
end_comment

begin_ifdef
unit|i = ecmp (x, ezero);   if (i<= 0)     {       if (i == -1) 	{ 	  mtherr ("esqrt", DOMAIN); 	  eclear (y); 	}       else 	emov (x, y);       return;     }
ifdef|#
directive|ifdef
name|INFINITY
end_ifdef

begin_endif
unit|if (eisinf (x))     {       eclear (y);       einfin (y);       return;     }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Bring in the arg and renormalize if it is denormal.  */
end_comment

begin_comment
unit|emovi (x, xx);   m = (EMULONG) xx[1];
comment|/* local long word exponent */
end_comment

begin_comment
unit|if (m == 0)     m -= enormlz (xx);
comment|/* Divide exponent by 2 */
end_comment

begin_comment
unit|m -= 0x3ffe;   exp = (unsigned short) ((m / 2) + 0x3ffe);
comment|/* Adjust if exponent odd */
end_comment

begin_comment
unit|if ((m& 1) != 0)     {       if (m> 0) 	exp += 1;       eshdn1 (xx);     }    ecleaz (sq);   ecleaz (num);   n = 8;
comment|/* get 8 bits of result per inner loop */
end_comment

begin_comment
unit|nlups = rndprc;   j = 0;    while (nlups> 0)     {
comment|/* bring in next word of arg */
end_comment

begin_comment
unit|if (j< NE) 	num[NI - 1] = xx[j + 3];
comment|/* Do additional bit on last outer loop, for roundoff.  */
end_comment

begin_comment
unit|if (nlups<= 8) 	n = nlups + 1;       for (i = 0; i< n; i++) 	{
comment|/* Next 2 bits of arg */
end_comment

begin_comment
unit|eshup1 (num); 	  eshup1 (num);
comment|/* Shift up answer */
end_comment

begin_comment
unit|eshup1 (sq);
comment|/* Make trial divisor */
end_comment

begin_comment
unit|for (k = 0; k< NI; k++) 	    temp[k] = sq[k]; 	  eshup1 (temp); 	  eaddm (sqrndbit, temp);
comment|/* Subtract and insert answer bit if it goes in */
end_comment

begin_comment
unit|if (ecmpm (temp, num)<= 0) 	    { 	      esubm (temp, num); 	      sq[NI - 2] |= 1; 	    } 	}       nlups -= n;       j += 1;     }
comment|/* Adjust for extra, roundoff loop done.  */
end_comment

begin_comment
unit|exp += (NBITS - 1) - rndprc;
comment|/* Sticky bit = 1 if the remainder is nonzero.  */
end_comment

begin_comment
unit|k = 0;   for (i = 3; i< NI; i++)     k |= (int) num[i];
comment|/* Renormalize and round off.  */
end_comment

begin_endif
unit|emdnorm (sq, k, 0, exp, 64);   emovo (sq, y); }
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EMU_NON_COMPILE not defined */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Return the binary precision of the significand for a given    floating point mode.  The mode can hold an integer value    that many bits wide, without losing any bits.  */
end_comment

begin_function
name|int
name|significand_size
parameter_list|(
name|mode
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
comment|/* Don't test the modes, but their sizes, lest this    code won't work for BITS_PER_UNIT != 8 .  */
switch|switch
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
condition|)
block|{
case|case
literal|32
case|:
if|#
directive|if
name|TARGET_FLOAT_FORMAT
operator|==
name|C4X_FLOAT_FORMAT
return|return
literal|56
return|;
endif|#
directive|endif
return|return
literal|24
return|;
case|case
literal|64
case|:
if|#
directive|if
name|TARGET_FLOAT_FORMAT
operator|==
name|IEEE_FLOAT_FORMAT
return|return
literal|53
return|;
else|#
directive|else
if|#
directive|if
name|TARGET_FLOAT_FORMAT
operator|==
name|IBM_FLOAT_FORMAT
return|return
literal|56
return|;
else|#
directive|else
if|#
directive|if
name|TARGET_FLOAT_FORMAT
operator|==
name|VAX_FLOAT_FORMAT
return|return
literal|56
return|;
else|#
directive|else
if|#
directive|if
name|TARGET_FLOAT_FORMAT
operator|==
name|C4X_FLOAT_FORMAT
return|return
literal|56
return|;
else|#
directive|else
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
case|case
literal|96
case|:
return|return
literal|64
return|;
case|case
literal|128
case|:
return|return
literal|113
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

end_unit

