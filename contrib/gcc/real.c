begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* real.c - software floating point emulation.    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999,    2000, 2002, 2003, 2004 Free Software Foundation, Inc.    Contributed by Stephen L. Moshier (moshier@world.std.com).    Re-written by Richard Henderson<rth@redhat.com>     This file is part of GCC.     GCC is free software; you can redistribute it and/or modify it under    the terms of the GNU General Public License as published by the Free    Software Foundation; either version 2, or (at your option) any later    version.     GCC is distributed in the hope that it will be useful, but WITHOUT ANY    WARRANTY; without even the implied warranty of MERCHANTABILITY or    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License    for more details.     You should have received a copy of the GNU General Public License    along with GCC; see the file COPYING.  If not, write to the Free    Software Foundation, 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_comment
comment|/* The floating point model used internally is not exactly IEEE 754    compliant, and close to the description in the ISO C99 standard,    section 5.2.4.2.2 Characteristics of floating types.     Specifically  	x = s * b^e * \sum_{k=1}^p f_k * b^{-k}  	where 		s = sign (+- 1) 		b = base or radix, here always 2 		e = exponent 		p = precision (the number of base-b digits in the significand) 		f_k = the digits of the significand.     We differ from typical IEEE 754 encodings in that the entire    significand is fractional.  Normalized significands are in the    range [0.5, 1.0).     A requirement of the model is that P be larger than the largest    supported target floating-point type by at least 2 bits.  This gives    us proper rounding when we truncate to the target type.  In addition,    E must be large enough to hold the smallest supported denormal number    in a normalized form.     Both of these requirements are easily satisfied.  The largest target    significand is 113 bits; we store at least 160.  The smallest    denormal number fits in 17 exponent bits; we store 27.     Note that the decimal string conversion routines are sensitive to    rounding errors.  Since the raw arithmetic routines do not themselves    have guard digits or rounding, the computation of 10**exp can    accumulate more than a few digits of error.  The previous incarnation    of real.c successfully used a 144-bit fraction; given the current    layout of REAL_VALUE_TYPE we're forced to expand to at least 160 bits.     Target floating point models that use base 16 instead of base 2    (i.e. IBM 370), are handled during round_for_format, in which we    canonicalize the exponent to be a multiple of 4 (log2(16)), and    adjust the significand to match.  */
end_comment

begin_comment
comment|/* Used to classify two numbers simultaneously.  */
end_comment

begin_define
define|#
directive|define
name|CLASS2
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|)
value|((A)<< 2 | (B))
end_define

begin_if
if|#
directive|if
name|HOST_BITS_PER_LONG
operator|!=
literal|64
operator|&&
name|HOST_BITS_PER_LONG
operator|!=
literal|32
end_if

begin_error
error|#
directive|error
literal|"Some constant folding done by hand to avoid shift count warnings"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|get_zero
parameter_list|(
name|REAL_VALUE_TYPE
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|get_canonical_qnan
parameter_list|(
name|REAL_VALUE_TYPE
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|get_canonical_snan
parameter_list|(
name|REAL_VALUE_TYPE
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|get_inf
parameter_list|(
name|REAL_VALUE_TYPE
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|sticky_rshift_significand
parameter_list|(
name|REAL_VALUE_TYPE
modifier|*
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rshift_significand
parameter_list|(
name|REAL_VALUE_TYPE
modifier|*
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lshift_significand
parameter_list|(
name|REAL_VALUE_TYPE
modifier|*
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lshift_significand_1
parameter_list|(
name|REAL_VALUE_TYPE
modifier|*
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|add_significands
parameter_list|(
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|sub_significands
parameter_list|(
name|REAL_VALUE_TYPE
modifier|*
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|neg_significand
parameter_list|(
name|REAL_VALUE_TYPE
modifier|*
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cmp_significands
parameter_list|(
specifier|const
name|REAL_VALUE_TYPE
modifier|*
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cmp_significand_0
parameter_list|(
specifier|const
name|REAL_VALUE_TYPE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_significand_bit
parameter_list|(
name|REAL_VALUE_TYPE
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|clear_significand_bit
parameter_list|(
name|REAL_VALUE_TYPE
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|test_significand_bit
parameter_list|(
name|REAL_VALUE_TYPE
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|clear_significand_below
parameter_list|(
name|REAL_VALUE_TYPE
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|div_significands
parameter_list|(
name|REAL_VALUE_TYPE
modifier|*
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|normalize
parameter_list|(
name|REAL_VALUE_TYPE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|do_add
parameter_list|(
name|REAL_VALUE_TYPE
modifier|*
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|do_multiply
parameter_list|(
name|REAL_VALUE_TYPE
modifier|*
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|do_divide
parameter_list|(
name|REAL_VALUE_TYPE
modifier|*
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|do_compare
parameter_list|(
specifier|const
name|REAL_VALUE_TYPE
modifier|*
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_fix_trunc
parameter_list|(
name|REAL_VALUE_TYPE
modifier|*
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|long
name|rtd_divmod
parameter_list|(
name|REAL_VALUE_TYPE
modifier|*
parameter_list|,
name|REAL_VALUE_TYPE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|ten_to_ptwo
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|ten_to_mptwo
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|real_digit
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|times_pten
parameter_list|(
name|REAL_VALUE_TYPE
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|round_for_format
parameter_list|(
specifier|const
name|struct
name|real_format
modifier|*
parameter_list|,
name|REAL_VALUE_TYPE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Initialize R with a positive zero.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|get_zero
parameter_list|(
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|,
name|int
name|sign
parameter_list|)
block|{
name|memset
argument_list|(
name|r
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|r
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|->
name|sign
operator|=
name|sign
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize R with the canonical quiet NaN.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|get_canonical_qnan
parameter_list|(
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|,
name|int
name|sign
parameter_list|)
block|{
name|memset
argument_list|(
name|r
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|r
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|->
name|class
operator|=
name|rvc_nan
expr_stmt|;
name|r
operator|->
name|sign
operator|=
name|sign
expr_stmt|;
name|r
operator|->
name|canonical
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|get_canonical_snan
parameter_list|(
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|,
name|int
name|sign
parameter_list|)
block|{
name|memset
argument_list|(
name|r
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|r
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|->
name|class
operator|=
name|rvc_nan
expr_stmt|;
name|r
operator|->
name|sign
operator|=
name|sign
expr_stmt|;
name|r
operator|->
name|signalling
operator|=
literal|1
expr_stmt|;
name|r
operator|->
name|canonical
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|get_inf
parameter_list|(
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|,
name|int
name|sign
parameter_list|)
block|{
name|memset
argument_list|(
name|r
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|r
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|->
name|class
operator|=
name|rvc_inf
expr_stmt|;
name|r
operator|->
name|sign
operator|=
name|sign
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Right-shift the significand of A by N bits; put the result in the    significand of R.  If any one bits are shifted out, return true.  */
end_comment

begin_function
specifier|static
name|bool
name|sticky_rshift_significand
parameter_list|(
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|a
parameter_list|,
name|unsigned
name|int
name|n
parameter_list|)
block|{
name|unsigned
name|long
name|sticky
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|ofs
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|n
operator|>=
name|HOST_BITS_PER_LONG
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|ofs
operator|=
name|n
operator|/
name|HOST_BITS_PER_LONG
init|;
name|i
operator|<
name|ofs
condition|;
operator|++
name|i
control|)
name|sticky
operator||=
name|a
operator|->
name|sig
index|[
name|i
index|]
expr_stmt|;
name|n
operator|&=
name|HOST_BITS_PER_LONG
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|!=
literal|0
condition|)
block|{
name|sticky
operator||=
name|a
operator|->
name|sig
index|[
name|ofs
index|]
operator|&
operator|(
operator|(
operator|(
name|unsigned
name|long
operator|)
literal|1
operator|<<
name|n
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SIGSZ
condition|;
operator|++
name|i
control|)
block|{
name|r
operator|->
name|sig
index|[
name|i
index|]
operator|=
operator|(
operator|(
operator|(
name|ofs
operator|+
name|i
operator|>=
name|SIGSZ
condition|?
literal|0
else|:
name|a
operator|->
name|sig
index|[
name|ofs
operator|+
name|i
index|]
operator|)
operator|>>
name|n
operator|)
operator||
operator|(
operator|(
name|ofs
operator|+
name|i
operator|+
literal|1
operator|>=
name|SIGSZ
condition|?
literal|0
else|:
name|a
operator|->
name|sig
index|[
name|ofs
operator|+
name|i
operator|+
literal|1
index|]
operator|)
operator|<<
operator|(
name|HOST_BITS_PER_LONG
operator|-
name|n
operator|)
operator|)
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ofs
operator|+
name|i
operator|<
name|SIGSZ
condition|;
operator|++
name|i
control|)
name|r
operator|->
name|sig
index|[
name|i
index|]
operator|=
name|a
operator|->
name|sig
index|[
name|ofs
operator|+
name|i
index|]
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|SIGSZ
condition|;
operator|++
name|i
control|)
name|r
operator|->
name|sig
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|sticky
operator|!=
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Right-shift the significand of A by N bits; put the result in the    significand of R.  */
end_comment

begin_function
specifier|static
name|void
name|rshift_significand
parameter_list|(
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|a
parameter_list|,
name|unsigned
name|int
name|n
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|ofs
init|=
name|n
operator|/
name|HOST_BITS_PER_LONG
decl_stmt|;
name|n
operator|&=
name|HOST_BITS_PER_LONG
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|n
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SIGSZ
condition|;
operator|++
name|i
control|)
block|{
name|r
operator|->
name|sig
index|[
name|i
index|]
operator|=
operator|(
operator|(
operator|(
name|ofs
operator|+
name|i
operator|>=
name|SIGSZ
condition|?
literal|0
else|:
name|a
operator|->
name|sig
index|[
name|ofs
operator|+
name|i
index|]
operator|)
operator|>>
name|n
operator|)
operator||
operator|(
operator|(
name|ofs
operator|+
name|i
operator|+
literal|1
operator|>=
name|SIGSZ
condition|?
literal|0
else|:
name|a
operator|->
name|sig
index|[
name|ofs
operator|+
name|i
operator|+
literal|1
index|]
operator|)
operator|<<
operator|(
name|HOST_BITS_PER_LONG
operator|-
name|n
operator|)
operator|)
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ofs
operator|+
name|i
operator|<
name|SIGSZ
condition|;
operator|++
name|i
control|)
name|r
operator|->
name|sig
index|[
name|i
index|]
operator|=
name|a
operator|->
name|sig
index|[
name|ofs
operator|+
name|i
index|]
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|SIGSZ
condition|;
operator|++
name|i
control|)
name|r
operator|->
name|sig
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Left-shift the significand of A by N bits; put the result in the    significand of R.  */
end_comment

begin_function
specifier|static
name|void
name|lshift_significand
parameter_list|(
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|a
parameter_list|,
name|unsigned
name|int
name|n
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|ofs
init|=
name|n
operator|/
name|HOST_BITS_PER_LONG
decl_stmt|;
name|n
operator|&=
name|HOST_BITS_PER_LONG
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ofs
operator|+
name|i
operator|<
name|SIGSZ
condition|;
operator|++
name|i
control|)
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|1
operator|-
name|i
index|]
operator|=
name|a
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|1
operator|-
name|i
operator|-
name|ofs
index|]
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|SIGSZ
condition|;
operator|++
name|i
control|)
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|1
operator|-
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SIGSZ
condition|;
operator|++
name|i
control|)
block|{
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|1
operator|-
name|i
index|]
operator|=
operator|(
operator|(
operator|(
name|ofs
operator|+
name|i
operator|>=
name|SIGSZ
condition|?
literal|0
else|:
name|a
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|1
operator|-
name|i
operator|-
name|ofs
index|]
operator|)
operator|<<
name|n
operator|)
operator||
operator|(
operator|(
name|ofs
operator|+
name|i
operator|+
literal|1
operator|>=
name|SIGSZ
condition|?
literal|0
else|:
name|a
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|1
operator|-
name|i
operator|-
name|ofs
operator|-
literal|1
index|]
operator|)
operator|>>
operator|(
name|HOST_BITS_PER_LONG
operator|-
name|n
operator|)
operator|)
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Likewise, but N is specialized to 1.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|lshift_significand_1
parameter_list|(
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|a
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|SIGSZ
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
name|r
operator|->
name|sig
index|[
name|i
index|]
operator|=
operator|(
name|a
operator|->
name|sig
index|[
name|i
index|]
operator|<<
literal|1
operator|)
operator||
operator|(
name|a
operator|->
name|sig
index|[
name|i
operator|-
literal|1
index|]
operator|>>
operator|(
name|HOST_BITS_PER_LONG
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|r
operator|->
name|sig
index|[
literal|0
index|]
operator|=
name|a
operator|->
name|sig
index|[
literal|0
index|]
operator|<<
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add the significands of A and B, placing the result in R.  Return    true if there was carry out of the most significant word.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|add_significands
parameter_list|(
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|a
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|b
parameter_list|)
block|{
name|bool
name|carry
init|=
name|false
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SIGSZ
condition|;
operator|++
name|i
control|)
block|{
name|unsigned
name|long
name|ai
init|=
name|a
operator|->
name|sig
index|[
name|i
index|]
decl_stmt|;
name|unsigned
name|long
name|ri
init|=
name|ai
operator|+
name|b
operator|->
name|sig
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|carry
condition|)
block|{
name|carry
operator|=
name|ri
operator|<
name|ai
expr_stmt|;
name|carry
operator||=
operator|++
name|ri
operator|==
literal|0
expr_stmt|;
block|}
else|else
name|carry
operator|=
name|ri
operator|<
name|ai
expr_stmt|;
name|r
operator|->
name|sig
index|[
name|i
index|]
operator|=
name|ri
expr_stmt|;
block|}
return|return
name|carry
return|;
block|}
end_function

begin_comment
comment|/* Subtract the significands of A and B, placing the result in R.  CARRY is    true if there's a borrow incoming to the least significant word.    Return true if there was borrow out of the most significant word.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|sub_significands
parameter_list|(
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|a
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|b
parameter_list|,
name|int
name|carry
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SIGSZ
condition|;
operator|++
name|i
control|)
block|{
name|unsigned
name|long
name|ai
init|=
name|a
operator|->
name|sig
index|[
name|i
index|]
decl_stmt|;
name|unsigned
name|long
name|ri
init|=
name|ai
operator|-
name|b
operator|->
name|sig
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|carry
condition|)
block|{
name|carry
operator|=
name|ri
operator|>
name|ai
expr_stmt|;
name|carry
operator||=
operator|~
operator|--
name|ri
operator|==
literal|0
expr_stmt|;
block|}
else|else
name|carry
operator|=
name|ri
operator|>
name|ai
expr_stmt|;
name|r
operator|->
name|sig
index|[
name|i
index|]
operator|=
name|ri
expr_stmt|;
block|}
return|return
name|carry
return|;
block|}
end_function

begin_comment
comment|/* Negate the significand A, placing the result in R.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|neg_significand
parameter_list|(
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|a
parameter_list|)
block|{
name|bool
name|carry
init|=
name|true
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SIGSZ
condition|;
operator|++
name|i
control|)
block|{
name|unsigned
name|long
name|ri
decl_stmt|,
name|ai
init|=
name|a
operator|->
name|sig
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|carry
condition|)
block|{
if|if
condition|(
name|ai
condition|)
block|{
name|ri
operator|=
operator|-
name|ai
expr_stmt|;
name|carry
operator|=
name|false
expr_stmt|;
block|}
else|else
name|ri
operator|=
name|ai
expr_stmt|;
block|}
else|else
name|ri
operator|=
operator|~
name|ai
expr_stmt|;
name|r
operator|->
name|sig
index|[
name|i
index|]
operator|=
name|ri
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Compare significands.  Return tri-state vs zero.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|cmp_significands
parameter_list|(
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|a
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|b
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|SIGSZ
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|unsigned
name|long
name|ai
init|=
name|a
operator|->
name|sig
index|[
name|i
index|]
decl_stmt|;
name|unsigned
name|long
name|bi
init|=
name|b
operator|->
name|sig
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|ai
operator|>
name|bi
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|ai
operator|<
name|bi
condition|)
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return true if A is nonzero.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|cmp_significand_0
parameter_list|(
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|a
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|SIGSZ
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
if|if
condition|(
name|a
operator|->
name|sig
index|[
name|i
index|]
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Set bit N of the significand of R.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|set_significand_bit
parameter_list|(
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|,
name|unsigned
name|int
name|n
parameter_list|)
block|{
name|r
operator|->
name|sig
index|[
name|n
operator|/
name|HOST_BITS_PER_LONG
index|]
operator||=
operator|(
name|unsigned
name|long
operator|)
literal|1
operator|<<
operator|(
name|n
operator|%
name|HOST_BITS_PER_LONG
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clear bit N of the significand of R.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|clear_significand_bit
parameter_list|(
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|,
name|unsigned
name|int
name|n
parameter_list|)
block|{
name|r
operator|->
name|sig
index|[
name|n
operator|/
name|HOST_BITS_PER_LONG
index|]
operator|&=
operator|~
operator|(
operator|(
name|unsigned
name|long
operator|)
literal|1
operator|<<
operator|(
name|n
operator|%
name|HOST_BITS_PER_LONG
operator|)
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Test bit N of the significand of R.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|test_significand_bit
parameter_list|(
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|,
name|unsigned
name|int
name|n
parameter_list|)
block|{
comment|/* ??? Compiler bug here if we return this expression directly.      The conversion to bool strips the "&1" and we wind up testing      e.g. 2 != 0 -> true.  Seen in gcc version 3.2 20020520.  */
name|int
name|t
init|=
operator|(
name|r
operator|->
name|sig
index|[
name|n
operator|/
name|HOST_BITS_PER_LONG
index|]
operator|>>
operator|(
name|n
operator|%
name|HOST_BITS_PER_LONG
operator|)
operator|)
operator|&
literal|1
decl_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Clear bits 0..N-1 of the significand of R.  */
end_comment

begin_function
specifier|static
name|void
name|clear_significand_below
parameter_list|(
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|,
name|unsigned
name|int
name|n
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|w
init|=
name|n
operator|/
name|HOST_BITS_PER_LONG
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|w
condition|;
operator|++
name|i
control|)
name|r
operator|->
name|sig
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|sig
index|[
name|w
index|]
operator|&=
operator|~
operator|(
operator|(
operator|(
name|unsigned
name|long
operator|)
literal|1
operator|<<
operator|(
name|n
operator|%
name|HOST_BITS_PER_LONG
operator|)
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Divide the significands of A and B, placing the result in R.  Return    true if the division was inexact.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|div_significands
parameter_list|(
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|a
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|b
parameter_list|)
block|{
name|REAL_VALUE_TYPE
name|u
decl_stmt|;
name|int
name|i
decl_stmt|,
name|bit
init|=
name|SIGNIFICAND_BITS
operator|-
literal|1
decl_stmt|;
name|unsigned
name|long
name|msb
decl_stmt|,
name|inexact
decl_stmt|;
name|u
operator|=
operator|*
name|a
expr_stmt|;
name|memset
argument_list|(
name|r
operator|->
name|sig
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|r
operator|->
name|sig
argument_list|)
argument_list|)
expr_stmt|;
name|msb
operator|=
literal|0
expr_stmt|;
goto|goto
name|start
goto|;
do|do
block|{
name|msb
operator|=
name|u
operator|.
name|sig
index|[
name|SIGSZ
operator|-
literal|1
index|]
operator|&
name|SIG_MSB
expr_stmt|;
name|lshift_significand_1
argument_list|(
operator|&
name|u
argument_list|,
operator|&
name|u
argument_list|)
expr_stmt|;
name|start
label|:
if|if
condition|(
name|msb
operator|||
name|cmp_significands
argument_list|(
operator|&
name|u
argument_list|,
name|b
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|sub_significands
argument_list|(
operator|&
name|u
argument_list|,
operator|&
name|u
argument_list|,
name|b
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_significand_bit
argument_list|(
name|r
argument_list|,
name|bit
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|--
name|bit
operator|>=
literal|0
condition|)
do|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|inexact
operator|=
literal|0
init|;
name|i
operator|<
name|SIGSZ
condition|;
name|i
operator|++
control|)
name|inexact
operator||=
name|u
operator|.
name|sig
index|[
name|i
index|]
expr_stmt|;
return|return
name|inexact
operator|!=
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Adjust the exponent and significand of R such that the most    significant bit is set.  We underflow to zero and overflow to    infinity here, without denormals.  (The intermediate representation    exponent is large enough to handle target denormals normalized.)  */
end_comment

begin_function
specifier|static
name|void
name|normalize
parameter_list|(
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|)
block|{
name|int
name|shift
init|=
literal|0
decl_stmt|,
name|exp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* Find the first word that is nonzero.  */
for|for
control|(
name|i
operator|=
name|SIGSZ
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|r
operator|->
name|sig
index|[
name|i
index|]
operator|==
literal|0
condition|)
name|shift
operator|+=
name|HOST_BITS_PER_LONG
expr_stmt|;
else|else
break|break;
comment|/* Zero significand flushes to zero.  */
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|r
operator|->
name|class
operator|=
name|rvc_zero
expr_stmt|;
name|r
operator|->
name|exp
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* Find the first bit that is nonzero.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|r
operator|->
name|sig
index|[
name|i
index|]
operator|&
operator|(
operator|(
name|unsigned
name|long
operator|)
literal|1
operator|<<
operator|(
name|HOST_BITS_PER_LONG
operator|-
literal|1
operator|-
name|j
operator|)
operator|)
condition|)
break|break;
name|shift
operator|+=
name|j
expr_stmt|;
if|if
condition|(
name|shift
operator|>
literal|0
condition|)
block|{
name|exp
operator|=
name|r
operator|->
name|exp
operator|-
name|shift
expr_stmt|;
if|if
condition|(
name|exp
operator|>
name|MAX_EXP
condition|)
name|get_inf
argument_list|(
name|r
argument_list|,
name|r
operator|->
name|sign
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|exp
operator|<
operator|-
name|MAX_EXP
condition|)
name|get_zero
argument_list|(
name|r
argument_list|,
name|r
operator|->
name|sign
argument_list|)
expr_stmt|;
else|else
block|{
name|r
operator|->
name|exp
operator|=
name|exp
expr_stmt|;
name|lshift_significand
argument_list|(
name|r
argument_list|,
name|r
argument_list|,
name|shift
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Calculate R = A + (SUBTRACT_P ? -B : B).  Return true if the    result may be inexact due to a loss of precision.  */
end_comment

begin_function
specifier|static
name|bool
name|do_add
parameter_list|(
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|a
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|b
parameter_list|,
name|int
name|subtract_p
parameter_list|)
block|{
name|int
name|dexp
decl_stmt|,
name|sign
decl_stmt|,
name|exp
decl_stmt|;
name|REAL_VALUE_TYPE
name|t
decl_stmt|;
name|bool
name|inexact
init|=
name|false
decl_stmt|;
comment|/* Determine if we need to add or subtract.  */
name|sign
operator|=
name|a
operator|->
name|sign
expr_stmt|;
name|subtract_p
operator|=
operator|(
name|sign
operator|^
name|b
operator|->
name|sign
operator|)
operator|^
name|subtract_p
expr_stmt|;
switch|switch
condition|(
name|CLASS2
argument_list|(
name|a
operator|->
name|class
argument_list|,
name|b
operator|->
name|class
argument_list|)
condition|)
block|{
case|case
name|CLASS2
argument_list|(
name|rvc_zero
argument_list|,
name|rvc_zero
argument_list|)
case|:
comment|/* -0 + -0 = -0, -0 - +0 = -0; all other cases yield +0.  */
name|get_zero
argument_list|(
name|r
argument_list|,
name|sign
operator|&
operator|!
name|subtract_p
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
name|CLASS2
argument_list|(
name|rvc_zero
argument_list|,
name|rvc_normal
argument_list|)
case|:
case|case
name|CLASS2
argument_list|(
name|rvc_zero
argument_list|,
name|rvc_inf
argument_list|)
case|:
case|case
name|CLASS2
argument_list|(
name|rvc_zero
argument_list|,
name|rvc_nan
argument_list|)
case|:
comment|/* 0 + ANY = ANY.  */
case|case
name|CLASS2
argument_list|(
name|rvc_normal
argument_list|,
name|rvc_nan
argument_list|)
case|:
case|case
name|CLASS2
argument_list|(
name|rvc_inf
argument_list|,
name|rvc_nan
argument_list|)
case|:
case|case
name|CLASS2
argument_list|(
name|rvc_nan
argument_list|,
name|rvc_nan
argument_list|)
case|:
comment|/* ANY + NaN = NaN.  */
case|case
name|CLASS2
argument_list|(
name|rvc_normal
argument_list|,
name|rvc_inf
argument_list|)
case|:
comment|/* R + Inf = Inf.  */
operator|*
name|r
operator|=
operator|*
name|b
expr_stmt|;
name|r
operator|->
name|sign
operator|=
name|sign
operator|^
name|subtract_p
expr_stmt|;
return|return
name|false
return|;
case|case
name|CLASS2
argument_list|(
name|rvc_normal
argument_list|,
name|rvc_zero
argument_list|)
case|:
case|case
name|CLASS2
argument_list|(
name|rvc_inf
argument_list|,
name|rvc_zero
argument_list|)
case|:
case|case
name|CLASS2
argument_list|(
name|rvc_nan
argument_list|,
name|rvc_zero
argument_list|)
case|:
comment|/* ANY + 0 = ANY.  */
case|case
name|CLASS2
argument_list|(
name|rvc_nan
argument_list|,
name|rvc_normal
argument_list|)
case|:
case|case
name|CLASS2
argument_list|(
name|rvc_nan
argument_list|,
name|rvc_inf
argument_list|)
case|:
comment|/* NaN + ANY = NaN.  */
case|case
name|CLASS2
argument_list|(
name|rvc_inf
argument_list|,
name|rvc_normal
argument_list|)
case|:
comment|/* Inf + R = Inf.  */
operator|*
name|r
operator|=
operator|*
name|a
expr_stmt|;
return|return
name|false
return|;
case|case
name|CLASS2
argument_list|(
name|rvc_inf
argument_list|,
name|rvc_inf
argument_list|)
case|:
if|if
condition|(
name|subtract_p
condition|)
comment|/* Inf - Inf = NaN.  */
name|get_canonical_qnan
argument_list|(
name|r
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
comment|/* Inf + Inf = Inf.  */
operator|*
name|r
operator|=
operator|*
name|a
expr_stmt|;
return|return
name|false
return|;
case|case
name|CLASS2
argument_list|(
name|rvc_normal
argument_list|,
name|rvc_normal
argument_list|)
case|:
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Swap the arguments such that A has the larger exponent.  */
name|dexp
operator|=
name|a
operator|->
name|exp
operator|-
name|b
operator|->
name|exp
expr_stmt|;
if|if
condition|(
name|dexp
operator|<
literal|0
condition|)
block|{
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|a
operator|,
name|a
operator|=
name|b
operator|,
name|b
operator|=
name|t
expr_stmt|;
name|dexp
operator|=
operator|-
name|dexp
expr_stmt|;
name|sign
operator|^=
name|subtract_p
expr_stmt|;
block|}
name|exp
operator|=
name|a
operator|->
name|exp
expr_stmt|;
comment|/* If the exponents are not identical, we need to shift the      significand of B down.  */
if|if
condition|(
name|dexp
operator|>
literal|0
condition|)
block|{
comment|/* If the exponents are too far apart, the significands 	 do not overlap, which makes the subtraction a noop.  */
if|if
condition|(
name|dexp
operator|>=
name|SIGNIFICAND_BITS
condition|)
block|{
operator|*
name|r
operator|=
operator|*
name|a
expr_stmt|;
name|r
operator|->
name|sign
operator|=
name|sign
expr_stmt|;
return|return
name|true
return|;
block|}
name|inexact
operator||=
name|sticky_rshift_significand
argument_list|(
operator|&
name|t
argument_list|,
name|b
argument_list|,
name|dexp
argument_list|)
expr_stmt|;
name|b
operator|=
operator|&
name|t
expr_stmt|;
block|}
if|if
condition|(
name|subtract_p
condition|)
block|{
if|if
condition|(
name|sub_significands
argument_list|(
name|r
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|inexact
argument_list|)
condition|)
block|{
comment|/* We got a borrow out of the subtraction.  That means that 	     A and B had the same exponent, and B had the larger 	     significand.  We need to swap the sign and negate the 	     significand.  */
name|sign
operator|^=
literal|1
expr_stmt|;
name|neg_significand
argument_list|(
name|r
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|add_significands
argument_list|(
name|r
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
condition|)
block|{
comment|/* We got carry out of the addition.  This means we need to 	     shift the significand back down one bit and increase the 	     exponent.  */
name|inexact
operator||=
name|sticky_rshift_significand
argument_list|(
name|r
argument_list|,
name|r
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|1
index|]
operator||=
name|SIG_MSB
expr_stmt|;
if|if
condition|(
operator|++
name|exp
operator|>
name|MAX_EXP
condition|)
block|{
name|get_inf
argument_list|(
name|r
argument_list|,
name|sign
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
block|}
name|r
operator|->
name|class
operator|=
name|rvc_normal
expr_stmt|;
name|r
operator|->
name|sign
operator|=
name|sign
expr_stmt|;
name|r
operator|->
name|exp
operator|=
name|exp
expr_stmt|;
comment|/* Re-normalize the result.  */
name|normalize
argument_list|(
name|r
argument_list|)
expr_stmt|;
comment|/* Special case: if the subtraction results in zero, the result      is positive.  */
if|if
condition|(
name|r
operator|->
name|class
operator|==
name|rvc_zero
condition|)
name|r
operator|->
name|sign
operator|=
literal|0
expr_stmt|;
else|else
name|r
operator|->
name|sig
index|[
literal|0
index|]
operator||=
name|inexact
expr_stmt|;
return|return
name|inexact
return|;
block|}
end_function

begin_comment
comment|/* Calculate R = A * B.  Return true if the result may be inexact.  */
end_comment

begin_function
specifier|static
name|bool
name|do_multiply
parameter_list|(
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|a
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|b
parameter_list|)
block|{
name|REAL_VALUE_TYPE
name|u
decl_stmt|,
name|t
decl_stmt|,
modifier|*
name|rr
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|int
name|sign
init|=
name|a
operator|->
name|sign
operator|^
name|b
operator|->
name|sign
decl_stmt|;
name|bool
name|inexact
init|=
name|false
decl_stmt|;
switch|switch
condition|(
name|CLASS2
argument_list|(
name|a
operator|->
name|class
argument_list|,
name|b
operator|->
name|class
argument_list|)
condition|)
block|{
case|case
name|CLASS2
argument_list|(
name|rvc_zero
argument_list|,
name|rvc_zero
argument_list|)
case|:
case|case
name|CLASS2
argument_list|(
name|rvc_zero
argument_list|,
name|rvc_normal
argument_list|)
case|:
case|case
name|CLASS2
argument_list|(
name|rvc_normal
argument_list|,
name|rvc_zero
argument_list|)
case|:
comment|/* +-0 * ANY = 0 with appropriate sign.  */
name|get_zero
argument_list|(
name|r
argument_list|,
name|sign
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
name|CLASS2
argument_list|(
name|rvc_zero
argument_list|,
name|rvc_nan
argument_list|)
case|:
case|case
name|CLASS2
argument_list|(
name|rvc_normal
argument_list|,
name|rvc_nan
argument_list|)
case|:
case|case
name|CLASS2
argument_list|(
name|rvc_inf
argument_list|,
name|rvc_nan
argument_list|)
case|:
case|case
name|CLASS2
argument_list|(
name|rvc_nan
argument_list|,
name|rvc_nan
argument_list|)
case|:
comment|/* ANY * NaN = NaN.  */
operator|*
name|r
operator|=
operator|*
name|b
expr_stmt|;
name|r
operator|->
name|sign
operator|=
name|sign
expr_stmt|;
return|return
name|false
return|;
case|case
name|CLASS2
argument_list|(
name|rvc_nan
argument_list|,
name|rvc_zero
argument_list|)
case|:
case|case
name|CLASS2
argument_list|(
name|rvc_nan
argument_list|,
name|rvc_normal
argument_list|)
case|:
case|case
name|CLASS2
argument_list|(
name|rvc_nan
argument_list|,
name|rvc_inf
argument_list|)
case|:
comment|/* NaN * ANY = NaN.  */
operator|*
name|r
operator|=
operator|*
name|a
expr_stmt|;
name|r
operator|->
name|sign
operator|=
name|sign
expr_stmt|;
return|return
name|false
return|;
case|case
name|CLASS2
argument_list|(
name|rvc_zero
argument_list|,
name|rvc_inf
argument_list|)
case|:
case|case
name|CLASS2
argument_list|(
name|rvc_inf
argument_list|,
name|rvc_zero
argument_list|)
case|:
comment|/* 0 * Inf = NaN */
name|get_canonical_qnan
argument_list|(
name|r
argument_list|,
name|sign
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
name|CLASS2
argument_list|(
name|rvc_inf
argument_list|,
name|rvc_inf
argument_list|)
case|:
case|case
name|CLASS2
argument_list|(
name|rvc_normal
argument_list|,
name|rvc_inf
argument_list|)
case|:
case|case
name|CLASS2
argument_list|(
name|rvc_inf
argument_list|,
name|rvc_normal
argument_list|)
case|:
comment|/* Inf * Inf = Inf, R * Inf = Inf */
name|get_inf
argument_list|(
name|r
argument_list|,
name|sign
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
name|CLASS2
argument_list|(
name|rvc_normal
argument_list|,
name|rvc_normal
argument_list|)
case|:
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|==
name|a
operator|||
name|r
operator|==
name|b
condition|)
name|rr
operator|=
operator|&
name|t
expr_stmt|;
else|else
name|rr
operator|=
name|r
expr_stmt|;
name|get_zero
argument_list|(
name|rr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Collect all the partial products.  Since we don't have sure access      to a widening multiply, we split each long into two half-words.       Consider the long-hand form of a four half-word multiplication:  		 A  B  C  D 	      *  E  F  G  H 	     -------------- 	        DE DF DG DH 	     CE CF CG CH 	  BE BF BG BH        AE AF AG AH       We construct partial products of the widened half-word products      that are known to not overlap, e.g. DF+DH.  Each such partial      product is given its proper exponent, which allows us to sum them      and obtain the finished product.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SIGSZ
operator|*
literal|2
condition|;
operator|++
name|i
control|)
block|{
name|unsigned
name|long
name|ai
init|=
name|a
operator|->
name|sig
index|[
name|i
operator|/
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|i
operator|&
literal|1
condition|)
name|ai
operator|>>=
name|HOST_BITS_PER_LONG
operator|/
literal|2
expr_stmt|;
else|else
name|ai
operator|&=
operator|(
operator|(
name|unsigned
name|long
operator|)
literal|1
operator|<<
operator|(
name|HOST_BITS_PER_LONG
operator|/
literal|2
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|ai
operator|==
literal|0
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|2
condition|;
operator|++
name|j
control|)
block|{
name|int
name|exp
init|=
operator|(
name|a
operator|->
name|exp
operator|-
operator|(
literal|2
operator|*
name|SIGSZ
operator|-
literal|1
operator|-
name|i
operator|)
operator|*
operator|(
name|HOST_BITS_PER_LONG
operator|/
literal|2
operator|)
operator|+
operator|(
name|b
operator|->
name|exp
operator|-
operator|(
literal|1
operator|-
name|j
operator|)
operator|*
operator|(
name|HOST_BITS_PER_LONG
operator|/
literal|2
operator|)
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|exp
operator|>
name|MAX_EXP
condition|)
block|{
name|get_inf
argument_list|(
name|r
argument_list|,
name|sign
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|exp
operator|<
operator|-
name|MAX_EXP
condition|)
block|{
comment|/* Would underflow to zero, which we shouldn't bother adding.  */
name|inexact
operator|=
name|true
expr_stmt|;
continue|continue;
block|}
name|memset
argument_list|(
operator|&
name|u
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|u
argument_list|)
argument_list|)
expr_stmt|;
name|u
operator|.
name|class
operator|=
name|rvc_normal
expr_stmt|;
name|u
operator|.
name|exp
operator|=
name|exp
expr_stmt|;
for|for
control|(
name|k
operator|=
name|j
init|;
name|k
operator|<
name|SIGSZ
operator|*
literal|2
condition|;
name|k
operator|+=
literal|2
control|)
block|{
name|unsigned
name|long
name|bi
init|=
name|b
operator|->
name|sig
index|[
name|k
operator|/
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|k
operator|&
literal|1
condition|)
name|bi
operator|>>=
name|HOST_BITS_PER_LONG
operator|/
literal|2
expr_stmt|;
else|else
name|bi
operator|&=
operator|(
operator|(
name|unsigned
name|long
operator|)
literal|1
operator|<<
operator|(
name|HOST_BITS_PER_LONG
operator|/
literal|2
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
name|u
operator|.
name|sig
index|[
name|k
operator|/
literal|2
index|]
operator|=
name|ai
operator|*
name|bi
expr_stmt|;
block|}
name|normalize
argument_list|(
operator|&
name|u
argument_list|)
expr_stmt|;
name|inexact
operator||=
name|do_add
argument_list|(
name|rr
argument_list|,
name|rr
argument_list|,
operator|&
name|u
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|rr
operator|->
name|sign
operator|=
name|sign
expr_stmt|;
if|if
condition|(
name|rr
operator|!=
name|r
condition|)
operator|*
name|r
operator|=
name|t
expr_stmt|;
return|return
name|inexact
return|;
block|}
end_function

begin_comment
comment|/* Calculate R = A / B.  Return true if the result may be inexact.  */
end_comment

begin_function
specifier|static
name|bool
name|do_divide
parameter_list|(
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|a
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|b
parameter_list|)
block|{
name|int
name|exp
decl_stmt|,
name|sign
init|=
name|a
operator|->
name|sign
operator|^
name|b
operator|->
name|sign
decl_stmt|;
name|REAL_VALUE_TYPE
name|t
decl_stmt|,
modifier|*
name|rr
decl_stmt|;
name|bool
name|inexact
decl_stmt|;
switch|switch
condition|(
name|CLASS2
argument_list|(
name|a
operator|->
name|class
argument_list|,
name|b
operator|->
name|class
argument_list|)
condition|)
block|{
case|case
name|CLASS2
argument_list|(
name|rvc_zero
argument_list|,
name|rvc_zero
argument_list|)
case|:
comment|/* 0 / 0 = NaN.  */
case|case
name|CLASS2
argument_list|(
name|rvc_inf
argument_list|,
name|rvc_inf
argument_list|)
case|:
comment|/* Inf / Inf = NaN.  */
name|get_canonical_qnan
argument_list|(
name|r
argument_list|,
name|sign
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
name|CLASS2
argument_list|(
name|rvc_zero
argument_list|,
name|rvc_normal
argument_list|)
case|:
case|case
name|CLASS2
argument_list|(
name|rvc_zero
argument_list|,
name|rvc_inf
argument_list|)
case|:
comment|/* 0 / ANY = 0.  */
case|case
name|CLASS2
argument_list|(
name|rvc_normal
argument_list|,
name|rvc_inf
argument_list|)
case|:
comment|/* R / Inf = 0.  */
name|get_zero
argument_list|(
name|r
argument_list|,
name|sign
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
name|CLASS2
argument_list|(
name|rvc_normal
argument_list|,
name|rvc_zero
argument_list|)
case|:
comment|/* R / 0 = Inf.  */
case|case
name|CLASS2
argument_list|(
name|rvc_inf
argument_list|,
name|rvc_zero
argument_list|)
case|:
comment|/* Inf / 0 = Inf.  */
name|get_inf
argument_list|(
name|r
argument_list|,
name|sign
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
name|CLASS2
argument_list|(
name|rvc_zero
argument_list|,
name|rvc_nan
argument_list|)
case|:
case|case
name|CLASS2
argument_list|(
name|rvc_normal
argument_list|,
name|rvc_nan
argument_list|)
case|:
case|case
name|CLASS2
argument_list|(
name|rvc_inf
argument_list|,
name|rvc_nan
argument_list|)
case|:
case|case
name|CLASS2
argument_list|(
name|rvc_nan
argument_list|,
name|rvc_nan
argument_list|)
case|:
comment|/* ANY / NaN = NaN.  */
operator|*
name|r
operator|=
operator|*
name|b
expr_stmt|;
name|r
operator|->
name|sign
operator|=
name|sign
expr_stmt|;
return|return
name|false
return|;
case|case
name|CLASS2
argument_list|(
name|rvc_nan
argument_list|,
name|rvc_zero
argument_list|)
case|:
case|case
name|CLASS2
argument_list|(
name|rvc_nan
argument_list|,
name|rvc_normal
argument_list|)
case|:
case|case
name|CLASS2
argument_list|(
name|rvc_nan
argument_list|,
name|rvc_inf
argument_list|)
case|:
comment|/* NaN / ANY = NaN.  */
operator|*
name|r
operator|=
operator|*
name|a
expr_stmt|;
name|r
operator|->
name|sign
operator|=
name|sign
expr_stmt|;
return|return
name|false
return|;
case|case
name|CLASS2
argument_list|(
name|rvc_inf
argument_list|,
name|rvc_normal
argument_list|)
case|:
comment|/* Inf / R = Inf.  */
name|get_inf
argument_list|(
name|r
argument_list|,
name|sign
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
name|CLASS2
argument_list|(
name|rvc_normal
argument_list|,
name|rvc_normal
argument_list|)
case|:
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|==
name|a
operator|||
name|r
operator|==
name|b
condition|)
name|rr
operator|=
operator|&
name|t
expr_stmt|;
else|else
name|rr
operator|=
name|r
expr_stmt|;
comment|/* Make sure all fields in the result are initialized.  */
name|get_zero
argument_list|(
name|rr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rr
operator|->
name|class
operator|=
name|rvc_normal
expr_stmt|;
name|rr
operator|->
name|sign
operator|=
name|sign
expr_stmt|;
name|exp
operator|=
name|a
operator|->
name|exp
operator|-
name|b
operator|->
name|exp
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|exp
operator|>
name|MAX_EXP
condition|)
block|{
name|get_inf
argument_list|(
name|r
argument_list|,
name|sign
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|exp
operator|<
operator|-
name|MAX_EXP
condition|)
block|{
name|get_zero
argument_list|(
name|r
argument_list|,
name|sign
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
name|rr
operator|->
name|exp
operator|=
name|exp
expr_stmt|;
name|inexact
operator|=
name|div_significands
argument_list|(
name|rr
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
comment|/* Re-normalize the result.  */
name|normalize
argument_list|(
name|rr
argument_list|)
expr_stmt|;
name|rr
operator|->
name|sig
index|[
literal|0
index|]
operator||=
name|inexact
expr_stmt|;
if|if
condition|(
name|rr
operator|!=
name|r
condition|)
operator|*
name|r
operator|=
name|t
expr_stmt|;
return|return
name|inexact
return|;
block|}
end_function

begin_comment
comment|/* Return a tri-state comparison of A vs B.  Return NAN_RESULT if    one of the two operands is a NaN.  */
end_comment

begin_function
specifier|static
name|int
name|do_compare
parameter_list|(
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|a
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|b
parameter_list|,
name|int
name|nan_result
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
switch|switch
condition|(
name|CLASS2
argument_list|(
name|a
operator|->
name|class
argument_list|,
name|b
operator|->
name|class
argument_list|)
condition|)
block|{
case|case
name|CLASS2
argument_list|(
name|rvc_zero
argument_list|,
name|rvc_zero
argument_list|)
case|:
comment|/* Sign of zero doesn't matter for compares.  */
return|return
literal|0
return|;
case|case
name|CLASS2
argument_list|(
name|rvc_inf
argument_list|,
name|rvc_zero
argument_list|)
case|:
case|case
name|CLASS2
argument_list|(
name|rvc_inf
argument_list|,
name|rvc_normal
argument_list|)
case|:
case|case
name|CLASS2
argument_list|(
name|rvc_normal
argument_list|,
name|rvc_zero
argument_list|)
case|:
return|return
operator|(
name|a
operator|->
name|sign
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
return|;
case|case
name|CLASS2
argument_list|(
name|rvc_inf
argument_list|,
name|rvc_inf
argument_list|)
case|:
return|return
operator|-
name|a
operator|->
name|sign
operator|-
operator|-
name|b
operator|->
name|sign
return|;
case|case
name|CLASS2
argument_list|(
name|rvc_zero
argument_list|,
name|rvc_normal
argument_list|)
case|:
case|case
name|CLASS2
argument_list|(
name|rvc_zero
argument_list|,
name|rvc_inf
argument_list|)
case|:
case|case
name|CLASS2
argument_list|(
name|rvc_normal
argument_list|,
name|rvc_inf
argument_list|)
case|:
return|return
operator|(
name|b
operator|->
name|sign
condition|?
literal|1
else|:
operator|-
literal|1
operator|)
return|;
case|case
name|CLASS2
argument_list|(
name|rvc_zero
argument_list|,
name|rvc_nan
argument_list|)
case|:
case|case
name|CLASS2
argument_list|(
name|rvc_normal
argument_list|,
name|rvc_nan
argument_list|)
case|:
case|case
name|CLASS2
argument_list|(
name|rvc_inf
argument_list|,
name|rvc_nan
argument_list|)
case|:
case|case
name|CLASS2
argument_list|(
name|rvc_nan
argument_list|,
name|rvc_nan
argument_list|)
case|:
case|case
name|CLASS2
argument_list|(
name|rvc_nan
argument_list|,
name|rvc_zero
argument_list|)
case|:
case|case
name|CLASS2
argument_list|(
name|rvc_nan
argument_list|,
name|rvc_normal
argument_list|)
case|:
case|case
name|CLASS2
argument_list|(
name|rvc_nan
argument_list|,
name|rvc_inf
argument_list|)
case|:
return|return
name|nan_result
return|;
case|case
name|CLASS2
argument_list|(
name|rvc_normal
argument_list|,
name|rvc_normal
argument_list|)
case|:
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|a
operator|->
name|sign
operator|!=
name|b
operator|->
name|sign
condition|)
return|return
operator|-
name|a
operator|->
name|sign
operator|-
operator|-
name|b
operator|->
name|sign
return|;
if|if
condition|(
name|a
operator|->
name|exp
operator|>
name|b
operator|->
name|exp
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|a
operator|->
name|exp
operator|<
name|b
operator|->
name|exp
condition|)
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|ret
operator|=
name|cmp_significands
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
return|return
operator|(
name|a
operator|->
name|sign
condition|?
operator|-
name|ret
else|:
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return A truncated to an integral value toward zero.  */
end_comment

begin_function
specifier|static
name|void
name|do_fix_trunc
parameter_list|(
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|a
parameter_list|)
block|{
operator|*
name|r
operator|=
operator|*
name|a
expr_stmt|;
switch|switch
condition|(
name|r
operator|->
name|class
condition|)
block|{
case|case
name|rvc_zero
case|:
case|case
name|rvc_inf
case|:
case|case
name|rvc_nan
case|:
break|break;
case|case
name|rvc_normal
case|:
if|if
condition|(
name|r
operator|->
name|exp
operator|<=
literal|0
condition|)
name|get_zero
argument_list|(
name|r
argument_list|,
name|r
operator|->
name|sign
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|exp
operator|<
name|SIGNIFICAND_BITS
condition|)
name|clear_significand_below
argument_list|(
name|r
argument_list|,
name|SIGNIFICAND_BITS
operator|-
name|r
operator|->
name|exp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Perform the binary or unary operation described by CODE.    For a unary operation, leave OP1 NULL.  */
end_comment

begin_function
name|void
name|real_arithmetic
parameter_list|(
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|,
name|int
name|icode
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|op0
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|op1
parameter_list|)
block|{
name|enum
name|tree_code
name|code
init|=
name|icode
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS_EXPR
case|:
name|do_add
argument_list|(
name|r
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|MINUS_EXPR
case|:
name|do_add
argument_list|(
name|r
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|MULT_EXPR
case|:
name|do_multiply
argument_list|(
name|r
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
break|break;
case|case
name|RDIV_EXPR
case|:
name|do_divide
argument_list|(
name|r
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
break|break;
case|case
name|MIN_EXPR
case|:
if|if
condition|(
name|op1
operator|->
name|class
operator|==
name|rvc_nan
condition|)
operator|*
name|r
operator|=
operator|*
name|op1
expr_stmt|;
elseif|else
if|if
condition|(
name|do_compare
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
operator|-
literal|1
argument_list|)
operator|<
literal|0
condition|)
operator|*
name|r
operator|=
operator|*
name|op0
expr_stmt|;
else|else
operator|*
name|r
operator|=
operator|*
name|op1
expr_stmt|;
break|break;
case|case
name|MAX_EXPR
case|:
if|if
condition|(
name|op1
operator|->
name|class
operator|==
name|rvc_nan
condition|)
operator|*
name|r
operator|=
operator|*
name|op1
expr_stmt|;
elseif|else
if|if
condition|(
name|do_compare
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
operator|*
name|r
operator|=
operator|*
name|op1
expr_stmt|;
else|else
operator|*
name|r
operator|=
operator|*
name|op0
expr_stmt|;
break|break;
case|case
name|NEGATE_EXPR
case|:
operator|*
name|r
operator|=
operator|*
name|op0
expr_stmt|;
name|r
operator|->
name|sign
operator|^=
literal|1
expr_stmt|;
break|break;
case|case
name|ABS_EXPR
case|:
operator|*
name|r
operator|=
operator|*
name|op0
expr_stmt|;
name|r
operator|->
name|sign
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|FIX_TRUNC_EXPR
case|:
name|do_fix_trunc
argument_list|(
name|r
argument_list|,
name|op0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Legacy.  Similar, but return the result directly.  */
end_comment

begin_function
name|REAL_VALUE_TYPE
name|real_arithmetic2
parameter_list|(
name|int
name|icode
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|op0
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|op1
parameter_list|)
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|real_arithmetic
argument_list|(
operator|&
name|r
argument_list|,
name|icode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|bool
name|real_compare
parameter_list|(
name|int
name|icode
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|op0
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|op1
parameter_list|)
block|{
name|enum
name|tree_code
name|code
init|=
name|icode
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LT_EXPR
case|:
return|return
name|do_compare
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
return|;
case|case
name|LE_EXPR
case|:
return|return
name|do_compare
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
literal|1
argument_list|)
operator|<=
literal|0
return|;
case|case
name|GT_EXPR
case|:
return|return
name|do_compare
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
operator|-
literal|1
argument_list|)
operator|>
literal|0
return|;
case|case
name|GE_EXPR
case|:
return|return
name|do_compare
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
operator|-
literal|1
argument_list|)
operator|>=
literal|0
return|;
case|case
name|EQ_EXPR
case|:
return|return
name|do_compare
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
operator|-
literal|1
argument_list|)
operator|==
literal|0
return|;
case|case
name|NE_EXPR
case|:
return|return
name|do_compare
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
operator|-
literal|1
argument_list|)
operator|!=
literal|0
return|;
case|case
name|UNORDERED_EXPR
case|:
return|return
name|op0
operator|->
name|class
operator|==
name|rvc_nan
operator|||
name|op1
operator|->
name|class
operator|==
name|rvc_nan
return|;
case|case
name|ORDERED_EXPR
case|:
return|return
name|op0
operator|->
name|class
operator|!=
name|rvc_nan
operator|&&
name|op1
operator|->
name|class
operator|!=
name|rvc_nan
return|;
case|case
name|UNLT_EXPR
case|:
return|return
name|do_compare
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
operator|-
literal|1
argument_list|)
operator|<
literal|0
return|;
case|case
name|UNLE_EXPR
case|:
return|return
name|do_compare
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
operator|-
literal|1
argument_list|)
operator|<=
literal|0
return|;
case|case
name|UNGT_EXPR
case|:
return|return
name|do_compare
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
literal|1
argument_list|)
operator|>
literal|0
return|;
case|case
name|UNGE_EXPR
case|:
return|return
name|do_compare
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
literal|1
argument_list|)
operator|>=
literal|0
return|;
case|case
name|UNEQ_EXPR
case|:
return|return
name|do_compare
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return floor log2(R).  */
end_comment

begin_function
name|int
name|real_exponent
parameter_list|(
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|)
block|{
switch|switch
condition|(
name|r
operator|->
name|class
condition|)
block|{
case|case
name|rvc_zero
case|:
return|return
literal|0
return|;
case|case
name|rvc_inf
case|:
case|case
name|rvc_nan
case|:
return|return
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
operator|>>
literal|1
return|;
case|case
name|rvc_normal
case|:
return|return
name|r
operator|->
name|exp
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* R = OP0 * 2**EXP.  */
end_comment

begin_function
name|void
name|real_ldexp
parameter_list|(
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|op0
parameter_list|,
name|int
name|exp
parameter_list|)
block|{
operator|*
name|r
operator|=
operator|*
name|op0
expr_stmt|;
switch|switch
condition|(
name|r
operator|->
name|class
condition|)
block|{
case|case
name|rvc_zero
case|:
case|case
name|rvc_inf
case|:
case|case
name|rvc_nan
case|:
break|break;
case|case
name|rvc_normal
case|:
name|exp
operator|+=
name|op0
operator|->
name|exp
expr_stmt|;
if|if
condition|(
name|exp
operator|>
name|MAX_EXP
condition|)
name|get_inf
argument_list|(
name|r
argument_list|,
name|r
operator|->
name|sign
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|exp
operator|<
operator|-
name|MAX_EXP
condition|)
name|get_zero
argument_list|(
name|r
argument_list|,
name|r
operator|->
name|sign
argument_list|)
expr_stmt|;
else|else
name|r
operator|->
name|exp
operator|=
name|exp
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Determine whether a floating-point value X is infinite.  */
end_comment

begin_function
name|bool
name|real_isinf
parameter_list|(
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|)
block|{
return|return
operator|(
name|r
operator|->
name|class
operator|==
name|rvc_inf
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Determine whether a floating-point value X is a NaN.  */
end_comment

begin_function
name|bool
name|real_isnan
parameter_list|(
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|)
block|{
return|return
operator|(
name|r
operator|->
name|class
operator|==
name|rvc_nan
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Determine whether a floating-point value X is negative.  */
end_comment

begin_function
name|bool
name|real_isneg
parameter_list|(
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|)
block|{
return|return
name|r
operator|->
name|sign
return|;
block|}
end_function

begin_comment
comment|/* Determine whether a floating-point value X is minus zero.  */
end_comment

begin_function
name|bool
name|real_isnegzero
parameter_list|(
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|)
block|{
return|return
name|r
operator|->
name|sign
operator|&&
name|r
operator|->
name|class
operator|==
name|rvc_zero
return|;
block|}
end_function

begin_comment
comment|/* Compare two floating-point objects for bitwise identity.  */
end_comment

begin_function
name|bool
name|real_identical
parameter_list|(
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|a
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|b
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|a
operator|->
name|class
operator|!=
name|b
operator|->
name|class
condition|)
return|return
name|false
return|;
if|if
condition|(
name|a
operator|->
name|sign
operator|!=
name|b
operator|->
name|sign
condition|)
return|return
name|false
return|;
switch|switch
condition|(
name|a
operator|->
name|class
condition|)
block|{
case|case
name|rvc_zero
case|:
case|case
name|rvc_inf
case|:
return|return
name|true
return|;
case|case
name|rvc_normal
case|:
if|if
condition|(
name|a
operator|->
name|exp
operator|!=
name|b
operator|->
name|exp
condition|)
return|return
name|false
return|;
break|break;
case|case
name|rvc_nan
case|:
if|if
condition|(
name|a
operator|->
name|signalling
operator|!=
name|b
operator|->
name|signalling
condition|)
return|return
name|false
return|;
comment|/* The significand is ignored for canonical NaNs.  */
if|if
condition|(
name|a
operator|->
name|canonical
operator|||
name|b
operator|->
name|canonical
condition|)
return|return
name|a
operator|->
name|canonical
operator|==
name|b
operator|->
name|canonical
return|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SIGSZ
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|a
operator|->
name|sig
index|[
name|i
index|]
operator|!=
name|b
operator|->
name|sig
index|[
name|i
index|]
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Try to change R into its exact multiplicative inverse in machine    mode MODE.  Return true if successful.  */
end_comment

begin_function
name|bool
name|exact_real_inverse
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|)
block|{
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|one
init|=
name|real_digit
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|REAL_VALUE_TYPE
name|u
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|r
operator|->
name|class
operator|!=
name|rvc_normal
condition|)
return|return
name|false
return|;
comment|/* Check for a power of two: all significand bits zero except the MSB.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SIGSZ
operator|-
literal|1
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|r
operator|->
name|sig
index|[
name|i
index|]
operator|!=
literal|0
condition|)
return|return
name|false
return|;
if|if
condition|(
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|1
index|]
operator|!=
name|SIG_MSB
condition|)
return|return
name|false
return|;
comment|/* Find the inverse and truncate to the required mode.  */
name|do_divide
argument_list|(
operator|&
name|u
argument_list|,
name|one
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|real_convert
argument_list|(
operator|&
name|u
argument_list|,
name|mode
argument_list|,
operator|&
name|u
argument_list|)
expr_stmt|;
comment|/* The rounding may have overflowed.  */
if|if
condition|(
name|u
operator|.
name|class
operator|!=
name|rvc_normal
condition|)
return|return
name|false
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SIGSZ
operator|-
literal|1
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|u
operator|.
name|sig
index|[
name|i
index|]
operator|!=
literal|0
condition|)
return|return
name|false
return|;
if|if
condition|(
name|u
operator|.
name|sig
index|[
name|SIGSZ
operator|-
literal|1
index|]
operator|!=
name|SIG_MSB
condition|)
return|return
name|false
return|;
operator|*
name|r
operator|=
name|u
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Render R as an integer.  */
end_comment

begin_function
name|HOST_WIDE_INT
name|real_to_integer
parameter_list|(
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|i
decl_stmt|;
switch|switch
condition|(
name|r
operator|->
name|class
condition|)
block|{
case|case
name|rvc_zero
case|:
name|underflow
label|:
return|return
literal|0
return|;
case|case
name|rvc_inf
case|:
case|case
name|rvc_nan
case|:
name|overflow
label|:
name|i
operator|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
operator|->
name|sign
condition|)
name|i
operator|--
expr_stmt|;
return|return
name|i
return|;
case|case
name|rvc_normal
case|:
if|if
condition|(
name|r
operator|->
name|exp
operator|<=
literal|0
condition|)
goto|goto
name|underflow
goto|;
comment|/* Only force overflow for unsigned overflow.  Signed overflow is 	 undefined, so it doesn't matter what we return, and some callers 	 expect to be able to use this routine for both signed and 	 unsigned conversions.  */
if|if
condition|(
name|r
operator|->
name|exp
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
goto|goto
name|overflow
goto|;
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|==
name|HOST_BITS_PER_LONG
condition|)
name|i
operator|=
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|1
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|2
operator|*
name|HOST_BITS_PER_LONG
condition|)
block|{
name|i
operator|=
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|1
index|]
expr_stmt|;
name|i
operator|=
name|i
operator|<<
operator|(
name|HOST_BITS_PER_LONG
operator|-
literal|1
operator|)
operator|<<
literal|1
expr_stmt|;
name|i
operator||=
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|2
index|]
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
name|i
operator|>>=
name|HOST_BITS_PER_WIDE_INT
operator|-
name|r
operator|->
name|exp
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|sign
condition|)
name|i
operator|=
operator|-
name|i
expr_stmt|;
return|return
name|i
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Likewise, but to an integer pair, HI+LOW.  */
end_comment

begin_function
name|void
name|real_to_integer2
parameter_list|(
name|HOST_WIDE_INT
modifier|*
name|plow
parameter_list|,
name|HOST_WIDE_INT
modifier|*
name|phigh
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|)
block|{
name|REAL_VALUE_TYPE
name|t
decl_stmt|;
name|HOST_WIDE_INT
name|low
decl_stmt|,
name|high
decl_stmt|;
name|int
name|exp
decl_stmt|;
switch|switch
condition|(
name|r
operator|->
name|class
condition|)
block|{
case|case
name|rvc_zero
case|:
name|underflow
label|:
name|low
operator|=
name|high
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|rvc_inf
case|:
case|case
name|rvc_nan
case|:
name|overflow
label|:
name|high
operator|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|sign
condition|)
name|low
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|high
operator|--
expr_stmt|;
name|low
operator|=
operator|-
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|rvc_normal
case|:
name|exp
operator|=
name|r
operator|->
name|exp
expr_stmt|;
if|if
condition|(
name|exp
operator|<=
literal|0
condition|)
goto|goto
name|underflow
goto|;
comment|/* Only force overflow for unsigned overflow.  Signed overflow is 	 undefined, so it doesn't matter what we return, and some callers 	 expect to be able to use this routine for both signed and 	 unsigned conversions.  */
if|if
condition|(
name|exp
operator|>
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
condition|)
goto|goto
name|overflow
goto|;
name|rshift_significand
argument_list|(
operator|&
name|t
argument_list|,
name|r
argument_list|,
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
operator|-
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|==
name|HOST_BITS_PER_LONG
condition|)
block|{
name|high
operator|=
name|t
operator|.
name|sig
index|[
name|SIGSZ
operator|-
literal|1
index|]
expr_stmt|;
name|low
operator|=
name|t
operator|.
name|sig
index|[
name|SIGSZ
operator|-
literal|2
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|2
operator|*
name|HOST_BITS_PER_LONG
condition|)
block|{
name|high
operator|=
name|t
operator|.
name|sig
index|[
name|SIGSZ
operator|-
literal|1
index|]
expr_stmt|;
name|high
operator|=
name|high
operator|<<
operator|(
name|HOST_BITS_PER_LONG
operator|-
literal|1
operator|)
operator|<<
literal|1
expr_stmt|;
name|high
operator||=
name|t
operator|.
name|sig
index|[
name|SIGSZ
operator|-
literal|2
index|]
expr_stmt|;
name|low
operator|=
name|t
operator|.
name|sig
index|[
name|SIGSZ
operator|-
literal|3
index|]
expr_stmt|;
name|low
operator|=
name|low
operator|<<
operator|(
name|HOST_BITS_PER_LONG
operator|-
literal|1
operator|)
operator|<<
literal|1
expr_stmt|;
name|low
operator||=
name|t
operator|.
name|sig
index|[
name|SIGSZ
operator|-
literal|4
index|]
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|sign
condition|)
block|{
if|if
condition|(
name|low
operator|==
literal|0
condition|)
name|high
operator|=
operator|-
name|high
expr_stmt|;
else|else
name|low
operator|=
operator|-
name|low
operator|,
name|high
operator|=
operator|~
name|high
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
operator|*
name|plow
operator|=
name|low
expr_stmt|;
operator|*
name|phigh
operator|=
name|high
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A subroutine of real_to_decimal.  Compute the quotient and remainder    of NUM / DEN.  Return the quotient and place the remainder in NUM.    It is expected that NUM / DEN are close enough that the quotient is    small.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|rtd_divmod
parameter_list|(
name|REAL_VALUE_TYPE
modifier|*
name|num
parameter_list|,
name|REAL_VALUE_TYPE
modifier|*
name|den
parameter_list|)
block|{
name|unsigned
name|long
name|q
decl_stmt|,
name|msb
decl_stmt|;
name|int
name|expn
init|=
name|num
operator|->
name|exp
decl_stmt|,
name|expd
init|=
name|den
operator|->
name|exp
decl_stmt|;
if|if
condition|(
name|expn
operator|<
name|expd
condition|)
return|return
literal|0
return|;
name|q
operator|=
name|msb
operator|=
literal|0
expr_stmt|;
goto|goto
name|start
goto|;
do|do
block|{
name|msb
operator|=
name|num
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|1
index|]
operator|&
name|SIG_MSB
expr_stmt|;
name|q
operator|<<=
literal|1
expr_stmt|;
name|lshift_significand_1
argument_list|(
name|num
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|start
label|:
if|if
condition|(
name|msb
operator|||
name|cmp_significands
argument_list|(
name|num
argument_list|,
name|den
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|sub_significands
argument_list|(
name|num
argument_list|,
name|num
argument_list|,
name|den
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|q
operator||=
literal|1
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|--
name|expn
operator|>=
name|expd
condition|)
do|;
name|num
operator|->
name|exp
operator|=
name|expd
expr_stmt|;
name|normalize
argument_list|(
name|num
argument_list|)
expr_stmt|;
return|return
name|q
return|;
block|}
end_function

begin_comment
comment|/* Render R as a decimal floating point constant.  Emit DIGITS significant    digits in the result, bounded by BUF_SIZE.  If DIGITS is 0, choose the    maximum for the representation.  If CROP_TRAILING_ZEROS, strip trailing    zeros.  */
end_comment

begin_define
define|#
directive|define
name|M_LOG10_2
value|0.30102999566398119521
end_define

begin_function
name|void
name|real_to_decimal
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|r_orig
parameter_list|,
name|size_t
name|buf_size
parameter_list|,
name|size_t
name|digits
parameter_list|,
name|int
name|crop_trailing_zeros
parameter_list|)
block|{
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|one
decl_stmt|,
modifier|*
name|ten
decl_stmt|;
name|REAL_VALUE_TYPE
name|r
decl_stmt|,
name|pten
decl_stmt|,
name|u
decl_stmt|,
name|v
decl_stmt|;
name|int
name|dec_exp
decl_stmt|,
name|cmp_one
decl_stmt|,
name|digit
decl_stmt|;
name|size_t
name|max_digits
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|first
decl_stmt|,
modifier|*
name|last
decl_stmt|;
name|bool
name|sign
decl_stmt|;
name|r
operator|=
operator|*
name|r_orig
expr_stmt|;
switch|switch
condition|(
name|r
operator|.
name|class
condition|)
block|{
case|case
name|rvc_zero
case|:
name|strcpy
argument_list|(
name|str
argument_list|,
operator|(
name|r
operator|.
name|sign
condition|?
literal|"-0.0"
else|:
literal|"0.0"
operator|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|rvc_normal
case|:
break|break;
case|case
name|rvc_inf
case|:
name|strcpy
argument_list|(
name|str
argument_list|,
operator|(
name|r
operator|.
name|sign
condition|?
literal|"-Inf"
else|:
literal|"+Inf"
operator|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|rvc_nan
case|:
comment|/* ??? Print the significand as well, if not canonical?  */
name|strcpy
argument_list|(
name|str
argument_list|,
operator|(
name|r
operator|.
name|sign
condition|?
literal|"-NaN"
else|:
literal|"+NaN"
operator|)
argument_list|)
expr_stmt|;
return|return;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Bound the number of digits printed by the size of the representation.  */
name|max_digits
operator|=
name|SIGNIFICAND_BITS
operator|*
name|M_LOG10_2
expr_stmt|;
if|if
condition|(
name|digits
operator|==
literal|0
operator|||
name|digits
operator|>
name|max_digits
condition|)
name|digits
operator|=
name|max_digits
expr_stmt|;
comment|/* Estimate the decimal exponent, and compute the length of the string it      will print as.  Be conservative and add one to account for possible      overflow or rounding error.  */
name|dec_exp
operator|=
name|r
operator|.
name|exp
operator|*
name|M_LOG10_2
expr_stmt|;
for|for
control|(
name|max_digits
operator|=
literal|1
init|;
name|dec_exp
condition|;
name|max_digits
operator|++
control|)
name|dec_exp
operator|/=
literal|10
expr_stmt|;
comment|/* Bound the number of digits printed by the size of the output buffer.  */
name|max_digits
operator|=
name|buf_size
operator|-
literal|1
operator|-
literal|1
operator|-
literal|2
operator|-
name|max_digits
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|max_digits
operator|>
name|buf_size
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|digits
operator|>
name|max_digits
condition|)
name|digits
operator|=
name|max_digits
expr_stmt|;
name|one
operator|=
name|real_digit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ten
operator|=
name|ten_to_ptwo
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|sign
operator|=
name|r
operator|.
name|sign
expr_stmt|;
name|r
operator|.
name|sign
operator|=
literal|0
expr_stmt|;
name|dec_exp
operator|=
literal|0
expr_stmt|;
name|pten
operator|=
operator|*
name|one
expr_stmt|;
name|cmp_one
operator|=
name|do_compare
argument_list|(
operator|&
name|r
argument_list|,
name|one
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp_one
operator|>
literal|0
condition|)
block|{
name|int
name|m
decl_stmt|;
comment|/* Number is greater than one.  Convert significand to an integer 	 and strip trailing decimal zeros.  */
name|u
operator|=
name|r
expr_stmt|;
name|u
operator|.
name|exp
operator|=
name|SIGNIFICAND_BITS
operator|-
literal|1
expr_stmt|;
comment|/* Largest M, such that 10**2**M fits within SIGNIFICAND_BITS.  */
name|m
operator|=
name|floor_log2
argument_list|(
name|max_digits
argument_list|)
expr_stmt|;
comment|/* Iterate over the bits of the possible powers of 10 that might 	 be present in U and eliminate them.  That is, if we find that 	 10**2**M divides U evenly, keep the division and increase 	 DEC_EXP by 2**M.  */
do|do
block|{
name|REAL_VALUE_TYPE
name|t
decl_stmt|;
name|do_divide
argument_list|(
operator|&
name|t
argument_list|,
operator|&
name|u
argument_list|,
name|ten_to_ptwo
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|do_fix_trunc
argument_list|(
operator|&
name|v
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp_significands
argument_list|(
operator|&
name|v
argument_list|,
operator|&
name|t
argument_list|)
operator|==
literal|0
condition|)
block|{
name|u
operator|=
name|t
expr_stmt|;
name|dec_exp
operator|+=
literal|1
operator|<<
name|m
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|--
name|m
operator|>=
literal|0
condition|)
do|;
comment|/* Revert the scaling to integer that we performed earlier.  */
name|u
operator|.
name|exp
operator|+=
name|r
operator|.
name|exp
operator|-
operator|(
name|SIGNIFICAND_BITS
operator|-
literal|1
operator|)
expr_stmt|;
name|r
operator|=
name|u
expr_stmt|;
comment|/* Find power of 10.  Do this by dividing out 10**2**M when 	 this is larger than the current remainder.  Fill PTEN with 	 the power of 10 that we compute.  */
if|if
condition|(
name|r
operator|.
name|exp
operator|>
literal|0
condition|)
block|{
name|m
operator|=
name|floor_log2
argument_list|(
call|(
name|int
call|)
argument_list|(
name|r
operator|.
name|exp
operator|*
name|M_LOG10_2
argument_list|)
argument_list|)
operator|+
literal|1
expr_stmt|;
do|do
block|{
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|ptentwo
init|=
name|ten_to_ptwo
argument_list|(
name|m
argument_list|)
decl_stmt|;
if|if
condition|(
name|do_compare
argument_list|(
operator|&
name|u
argument_list|,
name|ptentwo
argument_list|,
literal|0
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|do_divide
argument_list|(
operator|&
name|u
argument_list|,
operator|&
name|u
argument_list|,
name|ptentwo
argument_list|)
expr_stmt|;
name|do_multiply
argument_list|(
operator|&
name|pten
argument_list|,
operator|&
name|pten
argument_list|,
name|ptentwo
argument_list|)
expr_stmt|;
name|dec_exp
operator|+=
literal|1
operator|<<
name|m
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|--
name|m
operator|>=
literal|0
condition|)
do|;
block|}
else|else
comment|/* We managed to divide off enough tens in the above reduction 	   loop that we've now got a negative exponent.  Fall into the 	   less-than-one code to compute the proper value for PTEN.  */
name|cmp_one
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|cmp_one
operator|<
literal|0
condition|)
block|{
name|int
name|m
decl_stmt|;
comment|/* Number is less than one.  Pad significand with leading 	 decimal zeros.  */
name|v
operator|=
name|r
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Stop if we'd shift bits off the bottom.  */
if|if
condition|(
name|v
operator|.
name|sig
index|[
literal|0
index|]
operator|&
literal|7
condition|)
break|break;
name|do_multiply
argument_list|(
operator|&
name|u
argument_list|,
operator|&
name|v
argument_list|,
name|ten
argument_list|)
expr_stmt|;
comment|/* Stop if we're now>= 1.  */
if|if
condition|(
name|u
operator|.
name|exp
operator|>
literal|0
condition|)
break|break;
name|v
operator|=
name|u
expr_stmt|;
name|dec_exp
operator|-=
literal|1
expr_stmt|;
block|}
name|r
operator|=
name|v
expr_stmt|;
comment|/* Find power of 10.  Do this by multiplying in P=10**2**M when 	 the current remainder is smaller than 1/P.  Fill PTEN with the 	 power of 10 that we compute.  */
name|m
operator|=
name|floor_log2
argument_list|(
call|(
name|int
call|)
argument_list|(
operator|-
name|r
operator|.
name|exp
operator|*
name|M_LOG10_2
argument_list|)
argument_list|)
operator|+
literal|1
expr_stmt|;
do|do
block|{
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|ptentwo
init|=
name|ten_to_ptwo
argument_list|(
name|m
argument_list|)
decl_stmt|;
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|ptenmtwo
init|=
name|ten_to_mptwo
argument_list|(
name|m
argument_list|)
decl_stmt|;
if|if
condition|(
name|do_compare
argument_list|(
operator|&
name|v
argument_list|,
name|ptenmtwo
argument_list|,
literal|0
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|do_multiply
argument_list|(
operator|&
name|v
argument_list|,
operator|&
name|v
argument_list|,
name|ptentwo
argument_list|)
expr_stmt|;
name|do_multiply
argument_list|(
operator|&
name|pten
argument_list|,
operator|&
name|pten
argument_list|,
name|ptentwo
argument_list|)
expr_stmt|;
name|dec_exp
operator|-=
literal|1
operator|<<
name|m
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|--
name|m
operator|>=
literal|0
condition|)
do|;
comment|/* Invert the positive power of 10 that we've collected so far.  */
name|do_divide
argument_list|(
operator|&
name|pten
argument_list|,
name|one
argument_list|,
operator|&
name|pten
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|str
expr_stmt|;
if|if
condition|(
name|sign
condition|)
operator|*
name|p
operator|++
operator|=
literal|'-'
expr_stmt|;
name|first
operator|=
name|p
operator|++
expr_stmt|;
comment|/* At this point, PTEN should contain the nearest power of 10 smaller      than R, such that this division produces the first digit.       Using a divide-step primitive that returns the complete integral      remainder avoids the rounding error that would be produced if      we were to use do_divide here and then simply multiply by 10 for      each subsequent digit.  */
name|digit
operator|=
name|rtd_divmod
argument_list|(
operator|&
name|r
argument_list|,
operator|&
name|pten
argument_list|)
expr_stmt|;
comment|/* Be prepared for error in that division via underflow ...  */
if|if
condition|(
name|digit
operator|==
literal|0
operator|&&
name|cmp_significand_0
argument_list|(
operator|&
name|r
argument_list|)
condition|)
block|{
comment|/* Multiply by 10 and try again.  */
name|do_multiply
argument_list|(
operator|&
name|r
argument_list|,
operator|&
name|r
argument_list|,
name|ten
argument_list|)
expr_stmt|;
name|digit
operator|=
name|rtd_divmod
argument_list|(
operator|&
name|r
argument_list|,
operator|&
name|pten
argument_list|)
expr_stmt|;
name|dec_exp
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|digit
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* ... or overflow.  */
if|if
condition|(
name|digit
operator|==
literal|10
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'1'
expr_stmt|;
if|if
condition|(
operator|--
name|digits
operator|>
literal|0
condition|)
operator|*
name|p
operator|++
operator|=
literal|'0'
expr_stmt|;
name|dec_exp
operator|+=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|digit
operator|>
literal|10
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
operator|*
name|p
operator|++
operator|=
name|digit
operator|+
literal|'0'
expr_stmt|;
comment|/* Generate subsequent digits.  */
while|while
condition|(
operator|--
name|digits
operator|>
literal|0
condition|)
block|{
name|do_multiply
argument_list|(
operator|&
name|r
argument_list|,
operator|&
name|r
argument_list|,
name|ten
argument_list|)
expr_stmt|;
name|digit
operator|=
name|rtd_divmod
argument_list|(
operator|&
name|r
argument_list|,
operator|&
name|pten
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|digit
operator|+
literal|'0'
expr_stmt|;
block|}
name|last
operator|=
name|p
expr_stmt|;
comment|/* Generate one more digit with which to do rounding.  */
name|do_multiply
argument_list|(
operator|&
name|r
argument_list|,
operator|&
name|r
argument_list|,
name|ten
argument_list|)
expr_stmt|;
name|digit
operator|=
name|rtd_divmod
argument_list|(
operator|&
name|r
argument_list|,
operator|&
name|pten
argument_list|)
expr_stmt|;
comment|/* Round the result.  */
if|if
condition|(
name|digit
operator|==
literal|5
condition|)
block|{
comment|/* Round to nearest.  If R is nonzero there are additional 	 nonzero digits to be extracted.  */
if|if
condition|(
name|cmp_significand_0
argument_list|(
operator|&
name|r
argument_list|)
condition|)
name|digit
operator|++
expr_stmt|;
comment|/* Round to even.  */
elseif|else
if|if
condition|(
operator|(
name|p
index|[
operator|-
literal|1
index|]
operator|-
literal|'0'
operator|)
operator|&
literal|1
condition|)
name|digit
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|digit
operator|>
literal|5
condition|)
block|{
while|while
condition|(
name|p
operator|>
name|first
condition|)
block|{
name|digit
operator|=
operator|*
operator|--
name|p
expr_stmt|;
if|if
condition|(
name|digit
operator|==
literal|'9'
condition|)
operator|*
name|p
operator|=
literal|'0'
expr_stmt|;
else|else
block|{
operator|*
name|p
operator|=
name|digit
operator|+
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* Carry out of the first digit.  This means we had all 9's and 	 now have all 0's.  "Prepend" a 1 by overwriting the first 0.  */
if|if
condition|(
name|p
operator|==
name|first
condition|)
block|{
name|first
index|[
literal|1
index|]
operator|=
literal|'1'
expr_stmt|;
name|dec_exp
operator|++
expr_stmt|;
block|}
block|}
comment|/* Insert the decimal point.  */
name|first
index|[
literal|0
index|]
operator|=
name|first
index|[
literal|1
index|]
expr_stmt|;
name|first
index|[
literal|1
index|]
operator|=
literal|'.'
expr_stmt|;
comment|/* If requested, drop trailing zeros.  Never crop past "1.0".  */
if|if
condition|(
name|crop_trailing_zeros
condition|)
while|while
condition|(
name|last
operator|>
name|first
operator|+
literal|3
operator|&&
name|last
index|[
operator|-
literal|1
index|]
operator|==
literal|'0'
condition|)
name|last
operator|--
expr_stmt|;
comment|/* Append the exponent.  */
name|sprintf
argument_list|(
name|last
argument_list|,
literal|"e%+d"
argument_list|,
name|dec_exp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Render R as a hexadecimal floating point constant.  Emit DIGITS    significant digits in the result, bounded by BUF_SIZE.  If DIGITS is 0,    choose the maximum for the representation.  If CROP_TRAILING_ZEROS,    strip trailing zeros.  */
end_comment

begin_function
name|void
name|real_to_hexadecimal
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|,
name|size_t
name|buf_size
parameter_list|,
name|size_t
name|digits
parameter_list|,
name|int
name|crop_trailing_zeros
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|exp
init|=
name|r
operator|->
name|exp
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|first
decl_stmt|;
name|char
name|exp_buf
index|[
literal|16
index|]
decl_stmt|;
name|size_t
name|max_digits
decl_stmt|;
switch|switch
condition|(
name|r
operator|->
name|class
condition|)
block|{
case|case
name|rvc_zero
case|:
name|exp
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|rvc_normal
case|:
break|break;
case|case
name|rvc_inf
case|:
name|strcpy
argument_list|(
name|str
argument_list|,
operator|(
name|r
operator|->
name|sign
condition|?
literal|"-Inf"
else|:
literal|"+Inf"
operator|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|rvc_nan
case|:
comment|/* ??? Print the significand as well, if not canonical?  */
name|strcpy
argument_list|(
name|str
argument_list|,
operator|(
name|r
operator|->
name|sign
condition|?
literal|"-NaN"
else|:
literal|"+NaN"
operator|)
argument_list|)
expr_stmt|;
return|return;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|digits
operator|==
literal|0
condition|)
name|digits
operator|=
name|SIGNIFICAND_BITS
operator|/
literal|4
expr_stmt|;
comment|/* Bound the number of digits printed by the size of the output buffer.  */
name|sprintf
argument_list|(
name|exp_buf
argument_list|,
literal|"p%+d"
argument_list|,
name|exp
argument_list|)
expr_stmt|;
name|max_digits
operator|=
name|buf_size
operator|-
name|strlen
argument_list|(
name|exp_buf
argument_list|)
operator|-
name|r
operator|->
name|sign
operator|-
literal|4
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|max_digits
operator|>
name|buf_size
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|digits
operator|>
name|max_digits
condition|)
name|digits
operator|=
name|max_digits
expr_stmt|;
name|p
operator|=
name|str
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|sign
condition|)
operator|*
name|p
operator|++
operator|=
literal|'-'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'0'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'x'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'0'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'.'
expr_stmt|;
name|first
operator|=
name|p
expr_stmt|;
for|for
control|(
name|i
operator|=
name|SIGSZ
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
for|for
control|(
name|j
operator|=
name|HOST_BITS_PER_LONG
operator|-
literal|4
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|-=
literal|4
control|)
block|{
operator|*
name|p
operator|++
operator|=
literal|"0123456789abcdef"
index|[
operator|(
name|r
operator|->
name|sig
index|[
name|i
index|]
operator|>>
name|j
operator|)
operator|&
literal|15
index|]
expr_stmt|;
if|if
condition|(
operator|--
name|digits
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
name|out
label|:
if|if
condition|(
name|crop_trailing_zeros
condition|)
while|while
condition|(
name|p
operator|>
name|first
operator|+
literal|1
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'0'
condition|)
name|p
operator|--
expr_stmt|;
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"p%+d"
argument_list|,
name|exp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize R from a decimal or hexadecimal string.  The string is    assumed to have been syntax checked already.  */
end_comment

begin_function
name|void
name|real_from_string
parameter_list|(
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|int
name|exp
init|=
literal|0
decl_stmt|;
name|bool
name|sign
init|=
name|false
decl_stmt|;
name|get_zero
argument_list|(
name|r
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|'-'
condition|)
block|{
name|sign
operator|=
name|true
expr_stmt|;
name|str
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|str
operator|==
literal|'+'
condition|)
name|str
operator|++
expr_stmt|;
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|==
literal|'0'
operator|&&
operator|(
name|str
index|[
literal|1
index|]
operator|==
literal|'x'
operator|||
name|str
index|[
literal|1
index|]
operator|==
literal|'X'
operator|)
condition|)
block|{
comment|/* Hexadecimal floating point.  */
name|int
name|pos
init|=
name|SIGNIFICAND_BITS
operator|-
literal|4
decl_stmt|,
name|d
decl_stmt|;
name|str
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
operator|*
name|str
operator|==
literal|'0'
condition|)
name|str
operator|++
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|d
operator|=
name|hex_value
argument_list|(
operator|*
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|_hex_bad
condition|)
break|break;
if|if
condition|(
name|pos
operator|>=
literal|0
condition|)
block|{
name|r
operator|->
name|sig
index|[
name|pos
operator|/
name|HOST_BITS_PER_LONG
index|]
operator||=
operator|(
name|unsigned
name|long
operator|)
name|d
operator|<<
operator|(
name|pos
operator|%
name|HOST_BITS_PER_LONG
operator|)
expr_stmt|;
name|pos
operator|-=
literal|4
expr_stmt|;
block|}
name|exp
operator|+=
literal|4
expr_stmt|;
name|str
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|str
operator|==
literal|'.'
condition|)
block|{
name|str
operator|++
expr_stmt|;
if|if
condition|(
name|pos
operator|==
name|SIGNIFICAND_BITS
operator|-
literal|4
condition|)
block|{
while|while
condition|(
operator|*
name|str
operator|==
literal|'0'
condition|)
name|str
operator|++
operator|,
name|exp
operator|-=
literal|4
expr_stmt|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|d
operator|=
name|hex_value
argument_list|(
operator|*
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|_hex_bad
condition|)
break|break;
if|if
condition|(
name|pos
operator|>=
literal|0
condition|)
block|{
name|r
operator|->
name|sig
index|[
name|pos
operator|/
name|HOST_BITS_PER_LONG
index|]
operator||=
operator|(
name|unsigned
name|long
operator|)
name|d
operator|<<
operator|(
name|pos
operator|%
name|HOST_BITS_PER_LONG
operator|)
expr_stmt|;
name|pos
operator|-=
literal|4
expr_stmt|;
block|}
name|str
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|str
operator|==
literal|'p'
operator|||
operator|*
name|str
operator|==
literal|'P'
condition|)
block|{
name|bool
name|exp_neg
init|=
name|false
decl_stmt|;
name|str
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|'-'
condition|)
block|{
name|exp_neg
operator|=
name|true
expr_stmt|;
name|str
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|str
operator|==
literal|'+'
condition|)
name|str
operator|++
expr_stmt|;
name|d
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|str
argument_list|)
condition|)
block|{
name|d
operator|*=
literal|10
expr_stmt|;
name|d
operator|+=
operator|*
name|str
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|d
operator|>
name|MAX_EXP
condition|)
block|{
comment|/* Overflowed the exponent.  */
if|if
condition|(
name|exp_neg
condition|)
goto|goto
name|underflow
goto|;
else|else
goto|goto
name|overflow
goto|;
block|}
name|str
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|exp_neg
condition|)
name|d
operator|=
operator|-
name|d
expr_stmt|;
name|exp
operator|+=
name|d
expr_stmt|;
block|}
name|r
operator|->
name|class
operator|=
name|rvc_normal
expr_stmt|;
name|r
operator|->
name|exp
operator|=
name|exp
expr_stmt|;
name|normalize
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Decimal floating point.  */
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|ten
init|=
name|ten_to_ptwo
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|int
name|d
decl_stmt|;
while|while
condition|(
operator|*
name|str
operator|==
literal|'0'
condition|)
name|str
operator|++
expr_stmt|;
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|str
argument_list|)
condition|)
block|{
name|d
operator|=
operator|*
name|str
operator|++
operator|-
literal|'0'
expr_stmt|;
name|do_multiply
argument_list|(
name|r
argument_list|,
name|r
argument_list|,
name|ten
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
condition|)
name|do_add
argument_list|(
name|r
argument_list|,
name|r
argument_list|,
name|real_digit
argument_list|(
name|d
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|str
operator|==
literal|'.'
condition|)
block|{
name|str
operator|++
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|class
operator|==
name|rvc_zero
condition|)
block|{
while|while
condition|(
operator|*
name|str
operator|==
literal|'0'
condition|)
name|str
operator|++
operator|,
name|exp
operator|--
expr_stmt|;
block|}
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|str
argument_list|)
condition|)
block|{
name|d
operator|=
operator|*
name|str
operator|++
operator|-
literal|'0'
expr_stmt|;
name|do_multiply
argument_list|(
name|r
argument_list|,
name|r
argument_list|,
name|ten
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
condition|)
name|do_add
argument_list|(
name|r
argument_list|,
name|r
argument_list|,
name|real_digit
argument_list|(
name|d
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|exp
operator|--
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|str
operator|==
literal|'e'
operator|||
operator|*
name|str
operator|==
literal|'E'
condition|)
block|{
name|bool
name|exp_neg
init|=
name|false
decl_stmt|;
name|str
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|'-'
condition|)
block|{
name|exp_neg
operator|=
name|true
expr_stmt|;
name|str
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|str
operator|==
literal|'+'
condition|)
name|str
operator|++
expr_stmt|;
name|d
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|str
argument_list|)
condition|)
block|{
name|d
operator|*=
literal|10
expr_stmt|;
name|d
operator|+=
operator|*
name|str
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|d
operator|>
name|MAX_EXP
condition|)
block|{
comment|/* Overflowed the exponent.  */
if|if
condition|(
name|exp_neg
condition|)
goto|goto
name|underflow
goto|;
else|else
goto|goto
name|overflow
goto|;
block|}
name|str
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|exp_neg
condition|)
name|d
operator|=
operator|-
name|d
expr_stmt|;
name|exp
operator|+=
name|d
expr_stmt|;
block|}
if|if
condition|(
name|exp
condition|)
name|times_pten
argument_list|(
name|r
argument_list|,
name|exp
argument_list|)
expr_stmt|;
block|}
name|r
operator|->
name|sign
operator|=
name|sign
expr_stmt|;
return|return;
name|underflow
label|:
name|get_zero
argument_list|(
name|r
argument_list|,
name|sign
argument_list|)
expr_stmt|;
return|return;
name|overflow
label|:
name|get_inf
argument_list|(
name|r
argument_list|,
name|sign
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Legacy.  Similar, but return the result directly.  */
end_comment

begin_function
name|REAL_VALUE_TYPE
name|real_from_string2
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|real_from_string
argument_list|(
operator|&
name|r
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
condition|)
name|real_convert
argument_list|(
operator|&
name|r
argument_list|,
name|mode
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Initialize R from the integer pair HIGH+LOW.  */
end_comment

begin_function
name|void
name|real_from_integer
parameter_list|(
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|low
parameter_list|,
name|HOST_WIDE_INT
name|high
parameter_list|,
name|int
name|unsigned_p
parameter_list|)
block|{
if|if
condition|(
name|low
operator|==
literal|0
operator|&&
name|high
operator|==
literal|0
condition|)
name|get_zero
argument_list|(
name|r
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|r
operator|->
name|class
operator|=
name|rvc_normal
expr_stmt|;
name|r
operator|->
name|sign
operator|=
name|high
operator|<
literal|0
operator|&&
operator|!
name|unsigned_p
expr_stmt|;
name|r
operator|->
name|exp
operator|=
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|sign
condition|)
block|{
name|high
operator|=
operator|~
name|high
expr_stmt|;
if|if
condition|(
name|low
operator|==
literal|0
condition|)
name|high
operator|+=
literal|1
expr_stmt|;
else|else
name|low
operator|=
operator|-
name|low
expr_stmt|;
block|}
if|if
condition|(
name|HOST_BITS_PER_LONG
operator|==
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|1
index|]
operator|=
name|high
expr_stmt|;
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|2
index|]
operator|=
name|low
expr_stmt|;
name|memset
argument_list|(
name|r
operator|->
name|sig
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|*
operator|(
name|SIGSZ
operator|-
literal|2
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|HOST_BITS_PER_LONG
operator|*
literal|2
operator|==
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|1
index|]
operator|=
name|high
operator|>>
operator|(
name|HOST_BITS_PER_LONG
operator|-
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|2
index|]
operator|=
name|high
expr_stmt|;
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|3
index|]
operator|=
name|low
operator|>>
operator|(
name|HOST_BITS_PER_LONG
operator|-
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|4
index|]
operator|=
name|low
expr_stmt|;
if|if
condition|(
name|SIGSZ
operator|>
literal|4
condition|)
name|memset
argument_list|(
name|r
operator|->
name|sig
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|*
operator|(
name|SIGSZ
operator|-
literal|4
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
name|normalize
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
condition|)
name|real_convert
argument_list|(
name|r
argument_list|,
name|mode
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns 10**2**N.  */
end_comment

begin_function
specifier|static
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|ten_to_ptwo
parameter_list|(
name|int
name|n
parameter_list|)
block|{
specifier|static
name|REAL_VALUE_TYPE
name|tens
index|[
name|EXP_BITS
index|]
decl_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>=
name|EXP_BITS
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|tens
index|[
name|n
index|]
operator|.
name|class
operator|==
name|rvc_zero
condition|)
block|{
if|if
condition|(
name|n
operator|<
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|64
condition|?
literal|5
else|:
literal|4
operator|)
condition|)
block|{
name|HOST_WIDE_INT
name|t
init|=
literal|10
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
name|t
operator|*=
name|t
expr_stmt|;
name|real_from_integer
argument_list|(
operator|&
name|tens
index|[
name|n
index|]
argument_list|,
name|VOIDmode
argument_list|,
name|t
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|t
init|=
name|ten_to_ptwo
argument_list|(
name|n
operator|-
literal|1
argument_list|)
decl_stmt|;
name|do_multiply
argument_list|(
operator|&
name|tens
index|[
name|n
index|]
argument_list|,
name|t
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|&
name|tens
index|[
name|n
index|]
return|;
block|}
end_function

begin_comment
comment|/* Returns 10**(-2**N).  */
end_comment

begin_function
specifier|static
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|ten_to_mptwo
parameter_list|(
name|int
name|n
parameter_list|)
block|{
specifier|static
name|REAL_VALUE_TYPE
name|tens
index|[
name|EXP_BITS
index|]
decl_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>=
name|EXP_BITS
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|tens
index|[
name|n
index|]
operator|.
name|class
operator|==
name|rvc_zero
condition|)
name|do_divide
argument_list|(
operator|&
name|tens
index|[
name|n
index|]
argument_list|,
name|real_digit
argument_list|(
literal|1
argument_list|)
argument_list|,
name|ten_to_ptwo
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|&
name|tens
index|[
name|n
index|]
return|;
block|}
end_function

begin_comment
comment|/* Returns N.  */
end_comment

begin_function
specifier|static
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|real_digit
parameter_list|(
name|int
name|n
parameter_list|)
block|{
specifier|static
name|REAL_VALUE_TYPE
name|num
index|[
literal|10
index|]
decl_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>
literal|9
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
operator|&&
name|num
index|[
name|n
index|]
operator|.
name|class
operator|==
name|rvc_zero
condition|)
name|real_from_integer
argument_list|(
operator|&
name|num
index|[
name|n
index|]
argument_list|,
name|VOIDmode
argument_list|,
name|n
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|&
name|num
index|[
name|n
index|]
return|;
block|}
end_function

begin_comment
comment|/* Multiply R by 10**EXP.  */
end_comment

begin_function
specifier|static
name|void
name|times_pten
parameter_list|(
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|,
name|int
name|exp
parameter_list|)
block|{
name|REAL_VALUE_TYPE
name|pten
decl_stmt|,
modifier|*
name|rr
decl_stmt|;
name|bool
name|negative
init|=
operator|(
name|exp
operator|<
literal|0
operator|)
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|negative
condition|)
block|{
name|exp
operator|=
operator|-
name|exp
expr_stmt|;
name|pten
operator|=
operator|*
name|real_digit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|rr
operator|=
operator|&
name|pten
expr_stmt|;
block|}
else|else
name|rr
operator|=
name|r
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|exp
operator|>
literal|0
condition|;
operator|++
name|i
operator|,
name|exp
operator|>>=
literal|1
control|)
if|if
condition|(
name|exp
operator|&
literal|1
condition|)
name|do_multiply
argument_list|(
name|rr
argument_list|,
name|rr
argument_list|,
name|ten_to_ptwo
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|negative
condition|)
name|do_divide
argument_list|(
name|r
argument_list|,
name|r
argument_list|,
operator|&
name|pten
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fills R with +Inf.  */
end_comment

begin_function
name|void
name|real_inf
parameter_list|(
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|)
block|{
name|get_inf
argument_list|(
name|r
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fills R with a NaN whose significand is described by STR.  If QUIET,    we force a QNaN, else we force an SNaN.  The string, if not empty,    is parsed as a number and placed in the significand.  Return true    if the string was successfully parsed.  */
end_comment

begin_function
name|bool
name|real_nan
parameter_list|(
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|quiet
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
specifier|const
name|struct
name|real_format
modifier|*
name|fmt
decl_stmt|;
name|fmt
operator|=
name|REAL_MODE_FORMAT
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|quiet
condition|)
name|get_canonical_qnan
argument_list|(
name|r
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|get_canonical_snan
argument_list|(
name|r
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|base
init|=
literal|10
decl_stmt|,
name|d
decl_stmt|;
name|bool
name|neg
init|=
name|false
decl_stmt|;
name|memset
argument_list|(
name|r
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|r
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|->
name|class
operator|=
name|rvc_nan
expr_stmt|;
comment|/* Parse akin to strtol into the significand of R.  */
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|str
argument_list|)
condition|)
name|str
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|'-'
condition|)
name|str
operator|++
operator|,
name|neg
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|str
operator|==
literal|'+'
condition|)
name|str
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|'0'
condition|)
block|{
if|if
condition|(
operator|*
operator|++
name|str
operator|==
literal|'x'
condition|)
name|str
operator|++
operator|,
name|base
operator|=
literal|16
expr_stmt|;
else|else
name|base
operator|=
literal|8
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|d
operator|=
name|hex_value
argument_list|(
operator|*
name|str
argument_list|)
operator|)
operator|<
name|base
condition|)
block|{
name|REAL_VALUE_TYPE
name|u
decl_stmt|;
switch|switch
condition|(
name|base
condition|)
block|{
case|case
literal|8
case|:
name|lshift_significand
argument_list|(
name|r
argument_list|,
name|r
argument_list|,
literal|3
argument_list|)
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|lshift_significand
argument_list|(
name|r
argument_list|,
name|r
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
literal|10
case|:
name|lshift_significand_1
argument_list|(
operator|&
name|u
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|lshift_significand
argument_list|(
name|r
argument_list|,
name|r
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|add_significands
argument_list|(
name|r
argument_list|,
name|r
argument_list|,
operator|&
name|u
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|get_zero
argument_list|(
operator|&
name|u
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|u
operator|.
name|sig
index|[
literal|0
index|]
operator|=
name|d
expr_stmt|;
name|add_significands
argument_list|(
name|r
argument_list|,
name|r
argument_list|,
operator|&
name|u
argument_list|)
expr_stmt|;
name|str
operator|++
expr_stmt|;
block|}
comment|/* Must have consumed the entire string for success.  */
if|if
condition|(
operator|*
name|str
operator|!=
literal|0
condition|)
return|return
name|false
return|;
comment|/* Shift the significand into place such that the bits 	 are in the most significant bits for the format.  */
name|lshift_significand
argument_list|(
name|r
argument_list|,
name|r
argument_list|,
name|SIGNIFICAND_BITS
operator|-
name|fmt
operator|->
name|pnan
argument_list|)
expr_stmt|;
comment|/* Our MSB is always unset for NaNs.  */
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|1
index|]
operator|&=
operator|~
name|SIG_MSB
expr_stmt|;
comment|/* Force quiet or signalling NaN.  */
name|r
operator|->
name|signalling
operator|=
operator|!
name|quiet
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Fills R with the largest finite value representable in mode MODE.    If SIGN is nonzero, R is set to the most negative finite value.  */
end_comment

begin_function
name|void
name|real_maxval
parameter_list|(
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|,
name|int
name|sign
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
specifier|const
name|struct
name|real_format
modifier|*
name|fmt
decl_stmt|;
name|int
name|np2
decl_stmt|;
name|fmt
operator|=
name|REAL_MODE_FORMAT
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|r
operator|->
name|class
operator|=
name|rvc_normal
expr_stmt|;
name|r
operator|->
name|sign
operator|=
name|sign
expr_stmt|;
name|r
operator|->
name|signalling
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|canonical
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|exp
operator|=
name|fmt
operator|->
name|emax
operator|*
name|fmt
operator|->
name|log2_b
expr_stmt|;
name|np2
operator|=
name|SIGNIFICAND_BITS
operator|-
name|fmt
operator|->
name|p
operator|*
name|fmt
operator|->
name|log2_b
expr_stmt|;
name|memset
argument_list|(
name|r
operator|->
name|sig
argument_list|,
operator|-
literal|1
argument_list|,
name|SIGSZ
operator|*
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
argument_list|)
expr_stmt|;
name|clear_significand_below
argument_list|(
name|r
argument_list|,
name|np2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fills R with 2**N.  */
end_comment

begin_function
name|void
name|real_2expN
parameter_list|(
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|memset
argument_list|(
name|r
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|r
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|++
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|MAX_EXP
condition|)
name|r
operator|->
name|class
operator|=
name|rvc_inf
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|<
operator|-
name|MAX_EXP
condition|)
empty_stmt|;
else|else
block|{
name|r
operator|->
name|class
operator|=
name|rvc_normal
expr_stmt|;
name|r
operator|->
name|exp
operator|=
name|n
expr_stmt|;
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|1
index|]
operator|=
name|SIG_MSB
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|round_for_format
parameter_list|(
specifier|const
name|struct
name|real_format
modifier|*
name|fmt
parameter_list|,
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|)
block|{
name|int
name|p2
decl_stmt|,
name|np2
decl_stmt|,
name|i
decl_stmt|,
name|w
decl_stmt|;
name|unsigned
name|long
name|sticky
decl_stmt|;
name|bool
name|guard
decl_stmt|,
name|lsb
decl_stmt|;
name|int
name|emin2m1
decl_stmt|,
name|emax2
decl_stmt|;
name|p2
operator|=
name|fmt
operator|->
name|p
operator|*
name|fmt
operator|->
name|log2_b
expr_stmt|;
name|emin2m1
operator|=
operator|(
name|fmt
operator|->
name|emin
operator|-
literal|1
operator|)
operator|*
name|fmt
operator|->
name|log2_b
expr_stmt|;
name|emax2
operator|=
name|fmt
operator|->
name|emax
operator|*
name|fmt
operator|->
name|log2_b
expr_stmt|;
name|np2
operator|=
name|SIGNIFICAND_BITS
operator|-
name|p2
expr_stmt|;
switch|switch
condition|(
name|r
operator|->
name|class
condition|)
block|{
name|underflow
label|:
name|get_zero
argument_list|(
name|r
argument_list|,
name|r
operator|->
name|sign
argument_list|)
expr_stmt|;
case|case
name|rvc_zero
case|:
if|if
condition|(
operator|!
name|fmt
operator|->
name|has_signed_zero
condition|)
name|r
operator|->
name|sign
operator|=
literal|0
expr_stmt|;
return|return;
name|overflow
label|:
name|get_inf
argument_list|(
name|r
argument_list|,
name|r
operator|->
name|sign
argument_list|)
expr_stmt|;
case|case
name|rvc_inf
case|:
return|return;
case|case
name|rvc_nan
case|:
name|clear_significand_below
argument_list|(
name|r
argument_list|,
name|np2
argument_list|)
expr_stmt|;
return|return;
case|case
name|rvc_normal
case|:
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* If we're not base2, normalize the exponent to a multiple of      the true base.  */
if|if
condition|(
name|fmt
operator|->
name|log2_b
operator|!=
literal|1
condition|)
block|{
name|int
name|shift
init|=
name|r
operator|->
name|exp
operator|&
operator|(
name|fmt
operator|->
name|log2_b
operator|-
literal|1
operator|)
decl_stmt|;
if|if
condition|(
name|shift
condition|)
block|{
name|shift
operator|=
name|fmt
operator|->
name|log2_b
operator|-
name|shift
expr_stmt|;
name|r
operator|->
name|sig
index|[
literal|0
index|]
operator||=
name|sticky_rshift_significand
argument_list|(
name|r
argument_list|,
name|r
argument_list|,
name|shift
argument_list|)
expr_stmt|;
name|r
operator|->
name|exp
operator|+=
name|shift
expr_stmt|;
block|}
block|}
comment|/* Check the range of the exponent.  If we're out of range,      either underflow or overflow.  */
if|if
condition|(
name|r
operator|->
name|exp
operator|>
name|emax2
condition|)
goto|goto
name|overflow
goto|;
elseif|else
if|if
condition|(
name|r
operator|->
name|exp
operator|<=
name|emin2m1
condition|)
block|{
name|int
name|diff
decl_stmt|;
if|if
condition|(
operator|!
name|fmt
operator|->
name|has_denorm
condition|)
block|{
comment|/* Don't underflow completely until we've had a chance to round.  */
if|if
condition|(
name|r
operator|->
name|exp
operator|<
name|emin2m1
condition|)
goto|goto
name|underflow
goto|;
block|}
else|else
block|{
name|diff
operator|=
name|emin2m1
operator|-
name|r
operator|->
name|exp
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|diff
operator|>
name|p2
condition|)
goto|goto
name|underflow
goto|;
comment|/* De-normalize the significand.  */
name|r
operator|->
name|sig
index|[
literal|0
index|]
operator||=
name|sticky_rshift_significand
argument_list|(
name|r
argument_list|,
name|r
argument_list|,
name|diff
argument_list|)
expr_stmt|;
name|r
operator|->
name|exp
operator|+=
name|diff
expr_stmt|;
block|}
block|}
comment|/* There are P2 true significand bits, followed by one guard bit,      followed by one sticky bit, followed by stuff.  Fold nonzero      stuff into the sticky bit.  */
name|sticky
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|w
operator|=
operator|(
name|np2
operator|-
literal|1
operator|)
operator|/
name|HOST_BITS_PER_LONG
init|;
name|i
operator|<
name|w
condition|;
operator|++
name|i
control|)
name|sticky
operator||=
name|r
operator|->
name|sig
index|[
name|i
index|]
expr_stmt|;
name|sticky
operator||=
name|r
operator|->
name|sig
index|[
name|w
index|]
operator|&
operator|(
operator|(
operator|(
name|unsigned
name|long
operator|)
literal|1
operator|<<
operator|(
operator|(
name|np2
operator|-
literal|1
operator|)
operator|%
name|HOST_BITS_PER_LONG
operator|)
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|guard
operator|=
name|test_significand_bit
argument_list|(
name|r
argument_list|,
name|np2
operator|-
literal|1
argument_list|)
expr_stmt|;
name|lsb
operator|=
name|test_significand_bit
argument_list|(
name|r
argument_list|,
name|np2
argument_list|)
expr_stmt|;
comment|/* Round to even.  */
if|if
condition|(
name|guard
operator|&&
operator|(
name|sticky
operator|||
name|lsb
operator|)
condition|)
block|{
name|REAL_VALUE_TYPE
name|u
decl_stmt|;
name|get_zero
argument_list|(
operator|&
name|u
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_significand_bit
argument_list|(
operator|&
name|u
argument_list|,
name|np2
argument_list|)
expr_stmt|;
if|if
condition|(
name|add_significands
argument_list|(
name|r
argument_list|,
name|r
argument_list|,
operator|&
name|u
argument_list|)
condition|)
block|{
comment|/* Overflow.  Means the significand had been all ones, and 	     is now all zeros.  Need to increase the exponent, and 	     possibly re-normalize it.  */
if|if
condition|(
operator|++
name|r
operator|->
name|exp
operator|>
name|emax2
condition|)
goto|goto
name|overflow
goto|;
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|1
index|]
operator|=
name|SIG_MSB
expr_stmt|;
if|if
condition|(
name|fmt
operator|->
name|log2_b
operator|!=
literal|1
condition|)
block|{
name|int
name|shift
init|=
name|r
operator|->
name|exp
operator|&
operator|(
name|fmt
operator|->
name|log2_b
operator|-
literal|1
operator|)
decl_stmt|;
if|if
condition|(
name|shift
condition|)
block|{
name|shift
operator|=
name|fmt
operator|->
name|log2_b
operator|-
name|shift
expr_stmt|;
name|rshift_significand
argument_list|(
name|r
argument_list|,
name|r
argument_list|,
name|shift
argument_list|)
expr_stmt|;
name|r
operator|->
name|exp
operator|+=
name|shift
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|exp
operator|>
name|emax2
condition|)
goto|goto
name|overflow
goto|;
block|}
block|}
block|}
block|}
comment|/* Catch underflow that we deferred until after rounding.  */
if|if
condition|(
name|r
operator|->
name|exp
operator|<=
name|emin2m1
condition|)
goto|goto
name|underflow
goto|;
comment|/* Clear out trailing garbage.  */
name|clear_significand_below
argument_list|(
name|r
argument_list|,
name|np2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Extend or truncate to a new mode.  */
end_comment

begin_function
name|void
name|real_convert
parameter_list|(
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|a
parameter_list|)
block|{
specifier|const
name|struct
name|real_format
modifier|*
name|fmt
decl_stmt|;
name|fmt
operator|=
name|REAL_MODE_FORMAT
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
operator|*
name|r
operator|=
operator|*
name|a
expr_stmt|;
name|round_for_format
argument_list|(
name|fmt
argument_list|,
name|r
argument_list|)
expr_stmt|;
comment|/* round_for_format de-normalizes denormals.  Undo just that part.  */
if|if
condition|(
name|r
operator|->
name|class
operator|==
name|rvc_normal
condition|)
name|normalize
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Legacy.  Likewise, except return the struct directly.  */
end_comment

begin_function
name|REAL_VALUE_TYPE
name|real_value_truncate
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|REAL_VALUE_TYPE
name|a
parameter_list|)
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|real_convert
argument_list|(
operator|&
name|r
argument_list|,
name|mode
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Return true if truncating to MODE is exact.  */
end_comment

begin_function
name|bool
name|exact_real_truncate
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|a
parameter_list|)
block|{
name|REAL_VALUE_TYPE
name|t
decl_stmt|;
name|real_convert
argument_list|(
operator|&
name|t
argument_list|,
name|mode
argument_list|,
name|a
argument_list|)
expr_stmt|;
return|return
name|real_identical
argument_list|(
operator|&
name|t
argument_list|,
name|a
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Write R to the given target format.  Place the words of the result    in target word order in BUF.  There are always 32 bits in each    long, no matter the size of the host long.     Legacy: return word 0 for implementing REAL_VALUE_TO_TARGET_SINGLE.  */
end_comment

begin_function
name|long
name|real_to_target_fmt
parameter_list|(
name|long
modifier|*
name|buf
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|r_orig
parameter_list|,
specifier|const
name|struct
name|real_format
modifier|*
name|fmt
parameter_list|)
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|long
name|buf1
decl_stmt|;
name|r
operator|=
operator|*
name|r_orig
expr_stmt|;
name|round_for_format
argument_list|(
name|fmt
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
name|buf
operator|=
operator|&
name|buf1
expr_stmt|;
call|(
modifier|*
name|fmt
operator|->
name|encode
call|)
argument_list|(
name|fmt
argument_list|,
name|buf
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
return|return
operator|*
name|buf
return|;
block|}
end_function

begin_comment
comment|/* Similar, but look up the format from MODE.  */
end_comment

begin_function
name|long
name|real_to_target
parameter_list|(
name|long
modifier|*
name|buf
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
specifier|const
name|struct
name|real_format
modifier|*
name|fmt
decl_stmt|;
name|fmt
operator|=
name|REAL_MODE_FORMAT
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|real_to_target_fmt
argument_list|(
name|buf
argument_list|,
name|r
argument_list|,
name|fmt
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Read R from the given target format.  Read the words of the result    in target word order in BUF.  There are always 32 bits in each    long, no matter the size of the host long.  */
end_comment

begin_function
name|void
name|real_from_target_fmt
parameter_list|(
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|,
specifier|const
name|long
modifier|*
name|buf
parameter_list|,
specifier|const
name|struct
name|real_format
modifier|*
name|fmt
parameter_list|)
block|{
call|(
modifier|*
name|fmt
operator|->
name|decode
call|)
argument_list|(
name|fmt
argument_list|,
name|r
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Similar, but look up the format from MODE.  */
end_comment

begin_function
name|void
name|real_from_target
parameter_list|(
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|,
specifier|const
name|long
modifier|*
name|buf
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
specifier|const
name|struct
name|real_format
modifier|*
name|fmt
decl_stmt|;
name|fmt
operator|=
name|REAL_MODE_FORMAT
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
call|(
modifier|*
name|fmt
operator|->
name|decode
call|)
argument_list|(
name|fmt
argument_list|,
name|r
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the number of bits in the significand for MODE.  */
end_comment

begin_comment
comment|/* ??? Legacy.  Should get access to real_format directly.  */
end_comment

begin_function
name|int
name|significand_size
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
specifier|const
name|struct
name|real_format
modifier|*
name|fmt
decl_stmt|;
name|fmt
operator|=
name|REAL_MODE_FORMAT
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
return|return
name|fmt
operator|->
name|p
operator|*
name|fmt
operator|->
name|log2_b
return|;
block|}
end_function

begin_comment
comment|/* Return a hash value for the given real value.  */
end_comment

begin_comment
comment|/* ??? The "unsigned int" return value is intended to be hashval_t,    but I didn't want to pull hashtab.h into real.h.  */
end_comment

begin_function
name|unsigned
name|int
name|real_hash
parameter_list|(
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|)
block|{
name|unsigned
name|int
name|h
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|h
operator|=
name|r
operator|->
name|class
operator||
operator|(
name|r
operator|->
name|sign
operator|<<
literal|2
operator|)
expr_stmt|;
switch|switch
condition|(
name|r
operator|->
name|class
condition|)
block|{
case|case
name|rvc_zero
case|:
case|case
name|rvc_inf
case|:
return|return
name|h
return|;
case|case
name|rvc_normal
case|:
name|h
operator||=
name|r
operator|->
name|exp
operator|<<
literal|3
expr_stmt|;
break|break;
case|case
name|rvc_nan
case|:
if|if
condition|(
name|r
operator|->
name|signalling
condition|)
name|h
operator|^=
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|canonical
condition|)
return|return
name|h
return|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
operator|>
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SIGSZ
condition|;
operator|++
name|i
control|)
block|{
name|unsigned
name|long
name|s
init|=
name|r
operator|->
name|sig
index|[
name|i
index|]
decl_stmt|;
name|h
operator|^=
name|s
operator|^
operator|(
name|s
operator|>>
operator|(
name|HOST_BITS_PER_LONG
operator|/
literal|2
operator|)
operator|)
expr_stmt|;
block|}
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SIGSZ
condition|;
operator|++
name|i
control|)
name|h
operator|^=
name|r
operator|->
name|sig
index|[
name|i
index|]
expr_stmt|;
return|return
name|h
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* IEEE single-precision format.  */
end_comment

begin_function_decl
specifier|static
name|void
name|encode_ieee_single
parameter_list|(
specifier|const
name|struct
name|real_format
modifier|*
name|fmt
parameter_list|,
name|long
modifier|*
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|decode_ieee_single
parameter_list|(
specifier|const
name|struct
name|real_format
modifier|*
parameter_list|,
name|REAL_VALUE_TYPE
modifier|*
parameter_list|,
specifier|const
name|long
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|encode_ieee_single
parameter_list|(
specifier|const
name|struct
name|real_format
modifier|*
name|fmt
parameter_list|,
name|long
modifier|*
name|buf
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|)
block|{
name|unsigned
name|long
name|image
decl_stmt|,
name|sig
decl_stmt|,
name|exp
decl_stmt|;
name|unsigned
name|long
name|sign
init|=
name|r
operator|->
name|sign
decl_stmt|;
name|bool
name|denormal
init|=
operator|(
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|1
index|]
operator|&
name|SIG_MSB
operator|)
operator|==
literal|0
decl_stmt|;
name|image
operator|=
name|sign
operator|<<
literal|31
expr_stmt|;
name|sig
operator|=
operator|(
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|1
index|]
operator|>>
operator|(
name|HOST_BITS_PER_LONG
operator|-
literal|24
operator|)
operator|)
operator|&
literal|0x7fffff
expr_stmt|;
switch|switch
condition|(
name|r
operator|->
name|class
condition|)
block|{
case|case
name|rvc_zero
case|:
break|break;
case|case
name|rvc_inf
case|:
if|if
condition|(
name|fmt
operator|->
name|has_inf
condition|)
name|image
operator||=
literal|255
operator|<<
literal|23
expr_stmt|;
else|else
name|image
operator||=
literal|0x7fffffff
expr_stmt|;
break|break;
case|case
name|rvc_nan
case|:
if|if
condition|(
name|fmt
operator|->
name|has_nans
condition|)
block|{
if|if
condition|(
name|r
operator|->
name|canonical
condition|)
name|sig
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|signalling
operator|==
name|fmt
operator|->
name|qnan_msb_set
condition|)
name|sig
operator|&=
operator|~
operator|(
literal|1
operator|<<
literal|22
operator|)
expr_stmt|;
else|else
name|sig
operator||=
literal|1
operator|<<
literal|22
expr_stmt|;
comment|/* We overload qnan_msb_set here: it's only clear for 	     mips_ieee_single, which wants all mantissa bits but the 	     quiet/signalling one set in canonical NaNs (at least 	     Quiet ones).  */
if|if
condition|(
name|r
operator|->
name|canonical
operator|&&
operator|!
name|fmt
operator|->
name|qnan_msb_set
condition|)
name|sig
operator||=
operator|(
literal|1
operator|<<
literal|22
operator|)
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|sig
operator|==
literal|0
condition|)
name|sig
operator|=
literal|1
operator|<<
literal|21
expr_stmt|;
name|image
operator||=
literal|255
operator|<<
literal|23
expr_stmt|;
name|image
operator||=
name|sig
expr_stmt|;
block|}
else|else
name|image
operator||=
literal|0x7fffffff
expr_stmt|;
break|break;
case|case
name|rvc_normal
case|:
comment|/* Recall that IEEE numbers are interpreted as 1.F x 2**exp, 	 whereas the intermediate representation is 0.F x 2**exp. 	 Which means we're off by one.  */
if|if
condition|(
name|denormal
condition|)
name|exp
operator|=
literal|0
expr_stmt|;
else|else
name|exp
operator|=
name|r
operator|->
name|exp
operator|+
literal|127
operator|-
literal|1
expr_stmt|;
name|image
operator||=
name|exp
operator|<<
literal|23
expr_stmt|;
name|image
operator||=
name|sig
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|buf
index|[
literal|0
index|]
operator|=
name|image
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|decode_ieee_single
parameter_list|(
specifier|const
name|struct
name|real_format
modifier|*
name|fmt
parameter_list|,
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|,
specifier|const
name|long
modifier|*
name|buf
parameter_list|)
block|{
name|unsigned
name|long
name|image
init|=
name|buf
index|[
literal|0
index|]
operator|&
literal|0xffffffff
decl_stmt|;
name|bool
name|sign
init|=
operator|(
name|image
operator|>>
literal|31
operator|)
operator|&
literal|1
decl_stmt|;
name|int
name|exp
init|=
operator|(
name|image
operator|>>
literal|23
operator|)
operator|&
literal|0xff
decl_stmt|;
name|memset
argument_list|(
name|r
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|r
argument_list|)
argument_list|)
expr_stmt|;
name|image
operator|<<=
name|HOST_BITS_PER_LONG
operator|-
literal|24
expr_stmt|;
name|image
operator|&=
operator|~
name|SIG_MSB
expr_stmt|;
if|if
condition|(
name|exp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|image
operator|&&
name|fmt
operator|->
name|has_denorm
condition|)
block|{
name|r
operator|->
name|class
operator|=
name|rvc_normal
expr_stmt|;
name|r
operator|->
name|sign
operator|=
name|sign
expr_stmt|;
name|r
operator|->
name|exp
operator|=
operator|-
literal|126
expr_stmt|;
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|1
index|]
operator|=
name|image
operator|<<
literal|1
expr_stmt|;
name|normalize
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
operator|->
name|has_signed_zero
condition|)
name|r
operator|->
name|sign
operator|=
name|sign
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|exp
operator|==
literal|255
operator|&&
operator|(
name|fmt
operator|->
name|has_nans
operator|||
name|fmt
operator|->
name|has_inf
operator|)
condition|)
block|{
if|if
condition|(
name|image
condition|)
block|{
name|r
operator|->
name|class
operator|=
name|rvc_nan
expr_stmt|;
name|r
operator|->
name|sign
operator|=
name|sign
expr_stmt|;
name|r
operator|->
name|signalling
operator|=
operator|(
operator|(
operator|(
name|image
operator|>>
operator|(
name|HOST_BITS_PER_LONG
operator|-
literal|2
operator|)
operator|)
operator|&
literal|1
operator|)
operator|^
name|fmt
operator|->
name|qnan_msb_set
operator|)
expr_stmt|;
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|1
index|]
operator|=
name|image
expr_stmt|;
block|}
else|else
block|{
name|r
operator|->
name|class
operator|=
name|rvc_inf
expr_stmt|;
name|r
operator|->
name|sign
operator|=
name|sign
expr_stmt|;
block|}
block|}
else|else
block|{
name|r
operator|->
name|class
operator|=
name|rvc_normal
expr_stmt|;
name|r
operator|->
name|sign
operator|=
name|sign
expr_stmt|;
name|r
operator|->
name|exp
operator|=
name|exp
operator|-
literal|127
operator|+
literal|1
expr_stmt|;
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|1
index|]
operator|=
name|image
operator||
name|SIG_MSB
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|const
name|struct
name|real_format
name|ieee_single_format
init|=
block|{
name|encode_ieee_single
block|,
name|decode_ieee_single
block|,
literal|2
block|,
literal|1
block|,
literal|24
block|,
literal|24
block|,
operator|-
literal|125
block|,
literal|128
block|,
literal|31
block|,
name|true
block|,
name|true
block|,
name|true
block|,
name|true
block|,
name|true
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|real_format
name|mips_single_format
init|=
block|{
name|encode_ieee_single
block|,
name|decode_ieee_single
block|,
literal|2
block|,
literal|1
block|,
literal|24
block|,
literal|24
block|,
operator|-
literal|125
block|,
literal|128
block|,
literal|31
block|,
name|true
block|,
name|true
block|,
name|true
block|,
name|true
block|,
name|false
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* IEEE double-precision format.  */
end_comment

begin_function_decl
specifier|static
name|void
name|encode_ieee_double
parameter_list|(
specifier|const
name|struct
name|real_format
modifier|*
name|fmt
parameter_list|,
name|long
modifier|*
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|decode_ieee_double
parameter_list|(
specifier|const
name|struct
name|real_format
modifier|*
parameter_list|,
name|REAL_VALUE_TYPE
modifier|*
parameter_list|,
specifier|const
name|long
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|encode_ieee_double
parameter_list|(
specifier|const
name|struct
name|real_format
modifier|*
name|fmt
parameter_list|,
name|long
modifier|*
name|buf
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|)
block|{
name|unsigned
name|long
name|image_lo
decl_stmt|,
name|image_hi
decl_stmt|,
name|sig_lo
decl_stmt|,
name|sig_hi
decl_stmt|,
name|exp
decl_stmt|;
name|bool
name|denormal
init|=
operator|(
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|1
index|]
operator|&
name|SIG_MSB
operator|)
operator|==
literal|0
decl_stmt|;
name|image_hi
operator|=
name|r
operator|->
name|sign
operator|<<
literal|31
expr_stmt|;
name|image_lo
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|HOST_BITS_PER_LONG
operator|==
literal|64
condition|)
block|{
name|sig_hi
operator|=
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|1
index|]
expr_stmt|;
name|sig_lo
operator|=
operator|(
name|sig_hi
operator|>>
operator|(
literal|64
operator|-
literal|53
operator|)
operator|)
operator|&
literal|0xffffffff
expr_stmt|;
name|sig_hi
operator|=
operator|(
name|sig_hi
operator|>>
operator|(
literal|64
operator|-
literal|53
operator|+
literal|1
operator|)
operator|>>
literal|31
operator|)
operator|&
literal|0xfffff
expr_stmt|;
block|}
else|else
block|{
name|sig_hi
operator|=
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|1
index|]
expr_stmt|;
name|sig_lo
operator|=
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|2
index|]
expr_stmt|;
name|sig_lo
operator|=
operator|(
name|sig_hi
operator|<<
literal|21
operator|)
operator||
operator|(
name|sig_lo
operator|>>
literal|11
operator|)
expr_stmt|;
name|sig_hi
operator|=
operator|(
name|sig_hi
operator|>>
literal|11
operator|)
operator|&
literal|0xfffff
expr_stmt|;
block|}
switch|switch
condition|(
name|r
operator|->
name|class
condition|)
block|{
case|case
name|rvc_zero
case|:
break|break;
case|case
name|rvc_inf
case|:
if|if
condition|(
name|fmt
operator|->
name|has_inf
condition|)
name|image_hi
operator||=
literal|2047
operator|<<
literal|20
expr_stmt|;
else|else
block|{
name|image_hi
operator||=
literal|0x7fffffff
expr_stmt|;
name|image_lo
operator|=
literal|0xffffffff
expr_stmt|;
block|}
break|break;
case|case
name|rvc_nan
case|:
if|if
condition|(
name|fmt
operator|->
name|has_nans
condition|)
block|{
if|if
condition|(
name|r
operator|->
name|canonical
condition|)
name|sig_hi
operator|=
name|sig_lo
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|signalling
operator|==
name|fmt
operator|->
name|qnan_msb_set
condition|)
name|sig_hi
operator|&=
operator|~
operator|(
literal|1
operator|<<
literal|19
operator|)
expr_stmt|;
else|else
name|sig_hi
operator||=
literal|1
operator|<<
literal|19
expr_stmt|;
comment|/* We overload qnan_msb_set here: it's only clear for 	     mips_ieee_single, which wants all mantissa bits but the 	     quiet/signalling one set in canonical NaNs (at least 	     Quiet ones).  */
if|if
condition|(
name|r
operator|->
name|canonical
operator|&&
operator|!
name|fmt
operator|->
name|qnan_msb_set
condition|)
block|{
name|sig_hi
operator||=
operator|(
literal|1
operator|<<
literal|19
operator|)
operator|-
literal|1
expr_stmt|;
name|sig_lo
operator|=
literal|0xffffffff
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sig_hi
operator|==
literal|0
operator|&&
name|sig_lo
operator|==
literal|0
condition|)
name|sig_hi
operator|=
literal|1
operator|<<
literal|18
expr_stmt|;
name|image_hi
operator||=
literal|2047
operator|<<
literal|20
expr_stmt|;
name|image_hi
operator||=
name|sig_hi
expr_stmt|;
name|image_lo
operator|=
name|sig_lo
expr_stmt|;
block|}
else|else
block|{
name|image_hi
operator||=
literal|0x7fffffff
expr_stmt|;
name|image_lo
operator|=
literal|0xffffffff
expr_stmt|;
block|}
break|break;
case|case
name|rvc_normal
case|:
comment|/* Recall that IEEE numbers are interpreted as 1.F x 2**exp, 	 whereas the intermediate representation is 0.F x 2**exp. 	 Which means we're off by one.  */
if|if
condition|(
name|denormal
condition|)
name|exp
operator|=
literal|0
expr_stmt|;
else|else
name|exp
operator|=
name|r
operator|->
name|exp
operator|+
literal|1023
operator|-
literal|1
expr_stmt|;
name|image_hi
operator||=
name|exp
operator|<<
literal|20
expr_stmt|;
name|image_hi
operator||=
name|sig_hi
expr_stmt|;
name|image_lo
operator|=
name|sig_lo
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|FLOAT_WORDS_BIG_ENDIAN
condition|)
name|buf
index|[
literal|0
index|]
operator|=
name|image_hi
operator|,
name|buf
index|[
literal|1
index|]
operator|=
name|image_lo
expr_stmt|;
else|else
name|buf
index|[
literal|0
index|]
operator|=
name|image_lo
operator|,
name|buf
index|[
literal|1
index|]
operator|=
name|image_hi
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|decode_ieee_double
parameter_list|(
specifier|const
name|struct
name|real_format
modifier|*
name|fmt
parameter_list|,
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|,
specifier|const
name|long
modifier|*
name|buf
parameter_list|)
block|{
name|unsigned
name|long
name|image_hi
decl_stmt|,
name|image_lo
decl_stmt|;
name|bool
name|sign
decl_stmt|;
name|int
name|exp
decl_stmt|;
if|if
condition|(
name|FLOAT_WORDS_BIG_ENDIAN
condition|)
name|image_hi
operator|=
name|buf
index|[
literal|0
index|]
operator|,
name|image_lo
operator|=
name|buf
index|[
literal|1
index|]
expr_stmt|;
else|else
name|image_lo
operator|=
name|buf
index|[
literal|0
index|]
operator|,
name|image_hi
operator|=
name|buf
index|[
literal|1
index|]
expr_stmt|;
name|image_lo
operator|&=
literal|0xffffffff
expr_stmt|;
name|image_hi
operator|&=
literal|0xffffffff
expr_stmt|;
name|sign
operator|=
operator|(
name|image_hi
operator|>>
literal|31
operator|)
operator|&
literal|1
expr_stmt|;
name|exp
operator|=
operator|(
name|image_hi
operator|>>
literal|20
operator|)
operator|&
literal|0x7ff
expr_stmt|;
name|memset
argument_list|(
name|r
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|r
argument_list|)
argument_list|)
expr_stmt|;
name|image_hi
operator|<<=
literal|32
operator|-
literal|21
expr_stmt|;
name|image_hi
operator||=
name|image_lo
operator|>>
literal|21
expr_stmt|;
name|image_hi
operator|&=
literal|0x7fffffff
expr_stmt|;
name|image_lo
operator|<<=
literal|32
operator|-
literal|21
expr_stmt|;
if|if
condition|(
name|exp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|image_hi
operator|||
name|image_lo
operator|)
operator|&&
name|fmt
operator|->
name|has_denorm
condition|)
block|{
name|r
operator|->
name|class
operator|=
name|rvc_normal
expr_stmt|;
name|r
operator|->
name|sign
operator|=
name|sign
expr_stmt|;
name|r
operator|->
name|exp
operator|=
operator|-
literal|1022
expr_stmt|;
if|if
condition|(
name|HOST_BITS_PER_LONG
operator|==
literal|32
condition|)
block|{
name|image_hi
operator|=
operator|(
name|image_hi
operator|<<
literal|1
operator|)
operator||
operator|(
name|image_lo
operator|>>
literal|31
operator|)
expr_stmt|;
name|image_lo
operator|<<=
literal|1
expr_stmt|;
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|1
index|]
operator|=
name|image_hi
expr_stmt|;
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|2
index|]
operator|=
name|image_lo
expr_stmt|;
block|}
else|else
block|{
name|image_hi
operator|=
operator|(
name|image_hi
operator|<<
literal|31
operator|<<
literal|2
operator|)
operator||
operator|(
name|image_lo
operator|<<
literal|1
operator|)
expr_stmt|;
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|1
index|]
operator|=
name|image_hi
expr_stmt|;
block|}
name|normalize
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
operator|->
name|has_signed_zero
condition|)
name|r
operator|->
name|sign
operator|=
name|sign
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|exp
operator|==
literal|2047
operator|&&
operator|(
name|fmt
operator|->
name|has_nans
operator|||
name|fmt
operator|->
name|has_inf
operator|)
condition|)
block|{
if|if
condition|(
name|image_hi
operator|||
name|image_lo
condition|)
block|{
name|r
operator|->
name|class
operator|=
name|rvc_nan
expr_stmt|;
name|r
operator|->
name|sign
operator|=
name|sign
expr_stmt|;
name|r
operator|->
name|signalling
operator|=
operator|(
operator|(
name|image_hi
operator|>>
literal|30
operator|)
operator|&
literal|1
operator|)
operator|^
name|fmt
operator|->
name|qnan_msb_set
expr_stmt|;
if|if
condition|(
name|HOST_BITS_PER_LONG
operator|==
literal|32
condition|)
block|{
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|1
index|]
operator|=
name|image_hi
expr_stmt|;
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|2
index|]
operator|=
name|image_lo
expr_stmt|;
block|}
else|else
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|1
index|]
operator|=
operator|(
name|image_hi
operator|<<
literal|31
operator|<<
literal|1
operator|)
operator||
name|image_lo
expr_stmt|;
block|}
else|else
block|{
name|r
operator|->
name|class
operator|=
name|rvc_inf
expr_stmt|;
name|r
operator|->
name|sign
operator|=
name|sign
expr_stmt|;
block|}
block|}
else|else
block|{
name|r
operator|->
name|class
operator|=
name|rvc_normal
expr_stmt|;
name|r
operator|->
name|sign
operator|=
name|sign
expr_stmt|;
name|r
operator|->
name|exp
operator|=
name|exp
operator|-
literal|1023
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|HOST_BITS_PER_LONG
operator|==
literal|32
condition|)
block|{
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|1
index|]
operator|=
name|image_hi
operator||
name|SIG_MSB
expr_stmt|;
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|2
index|]
operator|=
name|image_lo
expr_stmt|;
block|}
else|else
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|1
index|]
operator|=
operator|(
name|image_hi
operator|<<
literal|31
operator|<<
literal|1
operator|)
operator||
name|image_lo
operator||
name|SIG_MSB
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|const
name|struct
name|real_format
name|ieee_double_format
init|=
block|{
name|encode_ieee_double
block|,
name|decode_ieee_double
block|,
literal|2
block|,
literal|1
block|,
literal|53
block|,
literal|53
block|,
operator|-
literal|1021
block|,
literal|1024
block|,
literal|63
block|,
name|true
block|,
name|true
block|,
name|true
block|,
name|true
block|,
name|true
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|real_format
name|mips_double_format
init|=
block|{
name|encode_ieee_double
block|,
name|decode_ieee_double
block|,
literal|2
block|,
literal|1
block|,
literal|53
block|,
literal|53
block|,
operator|-
literal|1021
block|,
literal|1024
block|,
literal|63
block|,
name|true
block|,
name|true
block|,
name|true
block|,
name|true
block|,
name|false
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* IEEE extended real format.  This comes in three flavors: Intel's as    a 12 byte image, Intel's as a 16 byte image, and Motorola's.  Intel    12- and 16-byte images may be big- or little endian; Motorola's is    always big endian.  */
end_comment

begin_comment
comment|/* Helper subroutine which converts from the internal format to the    12-byte little-endian Intel format.  Functions below adjust this    for the other possible formats.  */
end_comment

begin_function
specifier|static
name|void
name|encode_ieee_extended
parameter_list|(
specifier|const
name|struct
name|real_format
modifier|*
name|fmt
parameter_list|,
name|long
modifier|*
name|buf
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|)
block|{
name|unsigned
name|long
name|image_hi
decl_stmt|,
name|sig_hi
decl_stmt|,
name|sig_lo
decl_stmt|;
name|bool
name|denormal
init|=
operator|(
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|1
index|]
operator|&
name|SIG_MSB
operator|)
operator|==
literal|0
decl_stmt|;
name|image_hi
operator|=
name|r
operator|->
name|sign
operator|<<
literal|15
expr_stmt|;
name|sig_hi
operator|=
name|sig_lo
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|r
operator|->
name|class
condition|)
block|{
case|case
name|rvc_zero
case|:
break|break;
case|case
name|rvc_inf
case|:
if|if
condition|(
name|fmt
operator|->
name|has_inf
condition|)
block|{
name|image_hi
operator||=
literal|32767
expr_stmt|;
comment|/* Intel requires the explicit integer bit to be set, otherwise 	     it considers the value a "pseudo-infinity".  Motorola docs 	     say it doesn't care.  */
name|sig_hi
operator|=
literal|0x80000000
expr_stmt|;
block|}
else|else
block|{
name|image_hi
operator||=
literal|32767
expr_stmt|;
name|sig_lo
operator|=
name|sig_hi
operator|=
literal|0xffffffff
expr_stmt|;
block|}
break|break;
case|case
name|rvc_nan
case|:
if|if
condition|(
name|fmt
operator|->
name|has_nans
condition|)
block|{
name|image_hi
operator||=
literal|32767
expr_stmt|;
if|if
condition|(
name|HOST_BITS_PER_LONG
operator|==
literal|32
condition|)
block|{
name|sig_hi
operator|=
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|1
index|]
expr_stmt|;
name|sig_lo
operator|=
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|2
index|]
expr_stmt|;
block|}
else|else
block|{
name|sig_lo
operator|=
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|1
index|]
expr_stmt|;
name|sig_hi
operator|=
name|sig_lo
operator|>>
literal|31
operator|>>
literal|1
expr_stmt|;
name|sig_lo
operator|&=
literal|0xffffffff
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|->
name|signalling
operator|==
name|fmt
operator|->
name|qnan_msb_set
condition|)
name|sig_hi
operator|&=
operator|~
operator|(
literal|1
operator|<<
literal|30
operator|)
expr_stmt|;
else|else
name|sig_hi
operator||=
literal|1
operator|<<
literal|30
expr_stmt|;
if|if
condition|(
operator|(
name|sig_hi
operator|&
literal|0x7fffffff
operator|)
operator|==
literal|0
operator|&&
name|sig_lo
operator|==
literal|0
condition|)
name|sig_hi
operator|=
literal|1
operator|<<
literal|29
expr_stmt|;
comment|/* Intel requires the explicit integer bit to be set, otherwise 	     it considers the value a "pseudo-nan".  Motorola docs say it 	     doesn't care.  */
name|sig_hi
operator||=
literal|0x80000000
expr_stmt|;
block|}
else|else
block|{
name|image_hi
operator||=
literal|32767
expr_stmt|;
name|sig_lo
operator|=
name|sig_hi
operator|=
literal|0xffffffff
expr_stmt|;
block|}
break|break;
case|case
name|rvc_normal
case|:
block|{
name|int
name|exp
init|=
name|r
operator|->
name|exp
decl_stmt|;
comment|/* Recall that IEEE numbers are interpreted as 1.F x 2**exp, 	   whereas the intermediate representation is 0.F x 2**exp. 	   Which means we're off by one.  	   Except for Motorola, which consider exp=0 and explicit 	   integer bit set to continue to be normalized.  In theory 	   this discrepancy has been taken care of by the difference 	   in fmt->emin in round_for_format.  */
if|if
condition|(
name|denormal
condition|)
name|exp
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|exp
operator|+=
literal|16383
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|exp
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
name|image_hi
operator||=
name|exp
expr_stmt|;
if|if
condition|(
name|HOST_BITS_PER_LONG
operator|==
literal|32
condition|)
block|{
name|sig_hi
operator|=
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|1
index|]
expr_stmt|;
name|sig_lo
operator|=
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|2
index|]
expr_stmt|;
block|}
else|else
block|{
name|sig_lo
operator|=
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|1
index|]
expr_stmt|;
name|sig_hi
operator|=
name|sig_lo
operator|>>
literal|31
operator|>>
literal|1
expr_stmt|;
name|sig_lo
operator|&=
literal|0xffffffff
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|buf
index|[
literal|0
index|]
operator|=
name|sig_lo
operator|,
name|buf
index|[
literal|1
index|]
operator|=
name|sig_hi
operator|,
name|buf
index|[
literal|2
index|]
operator|=
name|image_hi
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert from the internal format to the 12-byte Motorola format    for an IEEE extended real.  */
end_comment

begin_function
specifier|static
name|void
name|encode_ieee_extended_motorola
parameter_list|(
specifier|const
name|struct
name|real_format
modifier|*
name|fmt
parameter_list|,
name|long
modifier|*
name|buf
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|)
block|{
name|long
name|intermed
index|[
literal|3
index|]
decl_stmt|;
name|encode_ieee_extended
argument_list|(
name|fmt
argument_list|,
name|intermed
argument_list|,
name|r
argument_list|)
expr_stmt|;
comment|/* Motorola chips are assumed always to be big-endian.  Also, the      padding in a Motorola extended real goes between the exponent and      the mantissa.  At this point the mantissa is entirely within      elements 0 and 1 of intermed, and the exponent entirely within      element 2, so all we have to do is swap the order around, and      shift element 2 left 16 bits.  */
name|buf
index|[
literal|0
index|]
operator|=
name|intermed
index|[
literal|2
index|]
operator|<<
literal|16
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|intermed
index|[
literal|1
index|]
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|intermed
index|[
literal|0
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert from the internal format to the 12-byte Intel format for    an IEEE extended real.  */
end_comment

begin_function
specifier|static
name|void
name|encode_ieee_extended_intel_96
parameter_list|(
specifier|const
name|struct
name|real_format
modifier|*
name|fmt
parameter_list|,
name|long
modifier|*
name|buf
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|)
block|{
if|if
condition|(
name|FLOAT_WORDS_BIG_ENDIAN
condition|)
block|{
comment|/* All the padding in an Intel-format extended real goes at the high 	 end, which in this case is after the mantissa, not the exponent. 	 Therefore we must shift everything down 16 bits.  */
name|long
name|intermed
index|[
literal|3
index|]
decl_stmt|;
name|encode_ieee_extended
argument_list|(
name|fmt
argument_list|,
name|intermed
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
operator|(
operator|(
name|intermed
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|intermed
index|[
literal|1
index|]
operator|&
literal|0xFFFF0000
argument_list|)
operator|>>
literal|16
operator|)
operator|)
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|intermed
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|intermed
index|[
literal|0
index|]
operator|&
literal|0xFFFF0000
argument_list|)
operator|>>
literal|16
operator|)
operator|)
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
operator|(
name|intermed
index|[
literal|0
index|]
operator|<<
literal|16
operator|)
expr_stmt|;
block|}
else|else
comment|/* encode_ieee_extended produces what we want directly.  */
name|encode_ieee_extended
argument_list|(
name|fmt
argument_list|,
name|buf
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert from the internal format to the 16-byte Intel format for    an IEEE extended real.  */
end_comment

begin_function
specifier|static
name|void
name|encode_ieee_extended_intel_128
parameter_list|(
specifier|const
name|struct
name|real_format
modifier|*
name|fmt
parameter_list|,
name|long
modifier|*
name|buf
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|)
block|{
comment|/* All the padding in an Intel-format extended real goes at the high end.  */
name|encode_ieee_extended_intel_96
argument_list|(
name|fmt
argument_list|,
name|buf
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* As above, we have a helper function which converts from 12-byte    little-endian Intel format to internal format.  Functions below    adjust for the other possible formats.  */
end_comment

begin_function
specifier|static
name|void
name|decode_ieee_extended
parameter_list|(
specifier|const
name|struct
name|real_format
modifier|*
name|fmt
parameter_list|,
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|,
specifier|const
name|long
modifier|*
name|buf
parameter_list|)
block|{
name|unsigned
name|long
name|image_hi
decl_stmt|,
name|sig_hi
decl_stmt|,
name|sig_lo
decl_stmt|;
name|bool
name|sign
decl_stmt|;
name|int
name|exp
decl_stmt|;
name|sig_lo
operator|=
name|buf
index|[
literal|0
index|]
operator|,
name|sig_hi
operator|=
name|buf
index|[
literal|1
index|]
operator|,
name|image_hi
operator|=
name|buf
index|[
literal|2
index|]
expr_stmt|;
name|sig_lo
operator|&=
literal|0xffffffff
expr_stmt|;
name|sig_hi
operator|&=
literal|0xffffffff
expr_stmt|;
name|image_hi
operator|&=
literal|0xffffffff
expr_stmt|;
name|sign
operator|=
operator|(
name|image_hi
operator|>>
literal|15
operator|)
operator|&
literal|1
expr_stmt|;
name|exp
operator|=
name|image_hi
operator|&
literal|0x7fff
expr_stmt|;
name|memset
argument_list|(
name|r
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|r
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|sig_hi
operator|||
name|sig_lo
operator|)
operator|&&
name|fmt
operator|->
name|has_denorm
condition|)
block|{
name|r
operator|->
name|class
operator|=
name|rvc_normal
expr_stmt|;
name|r
operator|->
name|sign
operator|=
name|sign
expr_stmt|;
comment|/* When the IEEE format contains a hidden bit, we know that 	     it's zero at this point, and so shift up the significand 	     and decrease the exponent to match.  In this case, Motorola 	     defines the explicit integer bit to be valid, so we don't 	     know whether the msb is set or not.  */
name|r
operator|->
name|exp
operator|=
name|fmt
operator|->
name|emin
expr_stmt|;
if|if
condition|(
name|HOST_BITS_PER_LONG
operator|==
literal|32
condition|)
block|{
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|1
index|]
operator|=
name|sig_hi
expr_stmt|;
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|2
index|]
operator|=
name|sig_lo
expr_stmt|;
block|}
else|else
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|1
index|]
operator|=
operator|(
name|sig_hi
operator|<<
literal|31
operator|<<
literal|1
operator|)
operator||
name|sig_lo
expr_stmt|;
name|normalize
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
operator|->
name|has_signed_zero
condition|)
name|r
operator|->
name|sign
operator|=
name|sign
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|exp
operator|==
literal|32767
operator|&&
operator|(
name|fmt
operator|->
name|has_nans
operator|||
name|fmt
operator|->
name|has_inf
operator|)
condition|)
block|{
comment|/* See above re "pseudo-infinities" and "pseudo-nans". 	 Short summary is that the MSB will likely always be 	 set, and that we don't care about it.  */
name|sig_hi
operator|&=
literal|0x7fffffff
expr_stmt|;
if|if
condition|(
name|sig_hi
operator|||
name|sig_lo
condition|)
block|{
name|r
operator|->
name|class
operator|=
name|rvc_nan
expr_stmt|;
name|r
operator|->
name|sign
operator|=
name|sign
expr_stmt|;
name|r
operator|->
name|signalling
operator|=
operator|(
operator|(
name|sig_hi
operator|>>
literal|30
operator|)
operator|&
literal|1
operator|)
operator|^
name|fmt
operator|->
name|qnan_msb_set
expr_stmt|;
if|if
condition|(
name|HOST_BITS_PER_LONG
operator|==
literal|32
condition|)
block|{
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|1
index|]
operator|=
name|sig_hi
expr_stmt|;
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|2
index|]
operator|=
name|sig_lo
expr_stmt|;
block|}
else|else
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|1
index|]
operator|=
operator|(
name|sig_hi
operator|<<
literal|31
operator|<<
literal|1
operator|)
operator||
name|sig_lo
expr_stmt|;
block|}
else|else
block|{
name|r
operator|->
name|class
operator|=
name|rvc_inf
expr_stmt|;
name|r
operator|->
name|sign
operator|=
name|sign
expr_stmt|;
block|}
block|}
else|else
block|{
name|r
operator|->
name|class
operator|=
name|rvc_normal
expr_stmt|;
name|r
operator|->
name|sign
operator|=
name|sign
expr_stmt|;
name|r
operator|->
name|exp
operator|=
name|exp
operator|-
literal|16383
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|HOST_BITS_PER_LONG
operator|==
literal|32
condition|)
block|{
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|1
index|]
operator|=
name|sig_hi
expr_stmt|;
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|2
index|]
operator|=
name|sig_lo
expr_stmt|;
block|}
else|else
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|1
index|]
operator|=
operator|(
name|sig_hi
operator|<<
literal|31
operator|<<
literal|1
operator|)
operator||
name|sig_lo
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Convert from the internal format to the 12-byte Motorola format    for an IEEE extended real.  */
end_comment

begin_function
specifier|static
name|void
name|decode_ieee_extended_motorola
parameter_list|(
specifier|const
name|struct
name|real_format
modifier|*
name|fmt
parameter_list|,
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|,
specifier|const
name|long
modifier|*
name|buf
parameter_list|)
block|{
name|long
name|intermed
index|[
literal|3
index|]
decl_stmt|;
comment|/* Motorola chips are assumed always to be big-endian.  Also, the      padding in a Motorola extended real goes between the exponent and      the mantissa; remove it.  */
name|intermed
index|[
literal|0
index|]
operator|=
name|buf
index|[
literal|2
index|]
expr_stmt|;
name|intermed
index|[
literal|1
index|]
operator|=
name|buf
index|[
literal|1
index|]
expr_stmt|;
name|intermed
index|[
literal|2
index|]
operator|=
operator|(
name|unsigned
name|long
operator|)
name|buf
index|[
literal|0
index|]
operator|>>
literal|16
expr_stmt|;
name|decode_ieee_extended
argument_list|(
name|fmt
argument_list|,
name|r
argument_list|,
name|intermed
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert from the internal format to the 12-byte Intel format for    an IEEE extended real.  */
end_comment

begin_function
specifier|static
name|void
name|decode_ieee_extended_intel_96
parameter_list|(
specifier|const
name|struct
name|real_format
modifier|*
name|fmt
parameter_list|,
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|,
specifier|const
name|long
modifier|*
name|buf
parameter_list|)
block|{
if|if
condition|(
name|FLOAT_WORDS_BIG_ENDIAN
condition|)
block|{
comment|/* All the padding in an Intel-format extended real goes at the high 	 end, which in this case is after the mantissa, not the exponent. 	 Therefore we must shift everything up 16 bits.  */
name|long
name|intermed
index|[
literal|3
index|]
decl_stmt|;
name|intermed
index|[
literal|0
index|]
operator|=
operator|(
operator|(
operator|(
name|unsigned
name|long
operator|)
name|buf
index|[
literal|2
index|]
operator|>>
literal|16
operator|)
operator||
operator|(
name|buf
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator|)
expr_stmt|;
name|intermed
index|[
literal|1
index|]
operator|=
operator|(
operator|(
operator|(
name|unsigned
name|long
operator|)
name|buf
index|[
literal|1
index|]
operator|>>
literal|16
operator|)
operator||
operator|(
name|buf
index|[
literal|0
index|]
operator|<<
literal|16
operator|)
operator|)
expr_stmt|;
name|intermed
index|[
literal|2
index|]
operator|=
operator|(
operator|(
name|unsigned
name|long
operator|)
name|buf
index|[
literal|0
index|]
operator|>>
literal|16
operator|)
expr_stmt|;
name|decode_ieee_extended
argument_list|(
name|fmt
argument_list|,
name|r
argument_list|,
name|intermed
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* decode_ieee_extended produces what we want directly.  */
name|decode_ieee_extended
argument_list|(
name|fmt
argument_list|,
name|r
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert from the internal format to the 16-byte Intel format for    an IEEE extended real.  */
end_comment

begin_function
specifier|static
name|void
name|decode_ieee_extended_intel_128
parameter_list|(
specifier|const
name|struct
name|real_format
modifier|*
name|fmt
parameter_list|,
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|,
specifier|const
name|long
modifier|*
name|buf
parameter_list|)
block|{
comment|/* All the padding in an Intel-format extended real goes at the high end.  */
name|decode_ieee_extended_intel_96
argument_list|(
name|fmt
argument_list|,
name|r
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|const
name|struct
name|real_format
name|ieee_extended_motorola_format
init|=
block|{
name|encode_ieee_extended_motorola
block|,
name|decode_ieee_extended_motorola
block|,
literal|2
block|,
literal|1
block|,
literal|64
block|,
literal|64
block|,
operator|-
literal|16382
block|,
literal|16384
block|,
literal|95
block|,
name|true
block|,
name|true
block|,
name|true
block|,
name|true
block|,
name|true
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|real_format
name|ieee_extended_intel_96_format
init|=
block|{
name|encode_ieee_extended_intel_96
block|,
name|decode_ieee_extended_intel_96
block|,
literal|2
block|,
literal|1
block|,
literal|64
block|,
literal|64
block|,
operator|-
literal|16381
block|,
literal|16384
block|,
literal|79
block|,
name|true
block|,
name|true
block|,
name|true
block|,
name|true
block|,
name|true
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|real_format
name|ieee_extended_intel_128_format
init|=
block|{
name|encode_ieee_extended_intel_128
block|,
name|decode_ieee_extended_intel_128
block|,
literal|2
block|,
literal|1
block|,
literal|64
block|,
literal|64
block|,
operator|-
literal|16381
block|,
literal|16384
block|,
literal|79
block|,
name|true
block|,
name|true
block|,
name|true
block|,
name|true
block|,
name|true
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following caters to i386 systems that set the rounding precision    to 53 bits instead of 64, e.g. FreeBSD.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|real_format
name|ieee_extended_intel_96_round_53_format
init|=
block|{
name|encode_ieee_extended_intel_96
block|,
name|decode_ieee_extended_intel_96
block|,
literal|2
block|,
literal|1
block|,
literal|53
block|,
literal|53
block|,
operator|-
literal|16381
block|,
literal|16384
block|,
literal|79
block|,
name|true
block|,
name|true
block|,
name|true
block|,
name|true
block|,
name|true
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* IBM 128-bit extended precision format: a pair of IEEE double precision    numbers whose sum is equal to the extended precision value.  The number    with greater magnitude is first.  This format has the same magnitude    range as an IEEE double precision value, but effectively 106 bits of    significand precision.  Infinity and NaN are represented by their IEEE    double precision value stored in the first number, the second number is    ignored.  Zeroes, Infinities, and NaNs are set in both doubles    due to precedent.  */
end_comment

begin_function_decl
specifier|static
name|void
name|encode_ibm_extended
parameter_list|(
specifier|const
name|struct
name|real_format
modifier|*
name|fmt
parameter_list|,
name|long
modifier|*
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|decode_ibm_extended
parameter_list|(
specifier|const
name|struct
name|real_format
modifier|*
parameter_list|,
name|REAL_VALUE_TYPE
modifier|*
parameter_list|,
specifier|const
name|long
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|encode_ibm_extended
parameter_list|(
specifier|const
name|struct
name|real_format
modifier|*
name|fmt
parameter_list|,
name|long
modifier|*
name|buf
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|)
block|{
name|REAL_VALUE_TYPE
name|u
decl_stmt|,
name|normr
decl_stmt|,
name|v
decl_stmt|;
specifier|const
name|struct
name|real_format
modifier|*
name|base_fmt
decl_stmt|;
name|base_fmt
operator|=
name|fmt
operator|->
name|qnan_msb_set
condition|?
operator|&
name|ieee_double_format
else|:
operator|&
name|mips_double_format
expr_stmt|;
comment|/* Renormlize R before doing any arithmetic on it.  */
name|normr
operator|=
operator|*
name|r
expr_stmt|;
if|if
condition|(
name|normr
operator|.
name|class
operator|==
name|rvc_normal
condition|)
name|normalize
argument_list|(
operator|&
name|normr
argument_list|)
expr_stmt|;
comment|/* u = IEEE double precision portion of significand.  */
name|u
operator|=
name|normr
expr_stmt|;
name|round_for_format
argument_list|(
name|base_fmt
argument_list|,
operator|&
name|u
argument_list|)
expr_stmt|;
name|encode_ieee_double
argument_list|(
name|base_fmt
argument_list|,
operator|&
name|buf
index|[
literal|0
index|]
argument_list|,
operator|&
name|u
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|class
operator|==
name|rvc_normal
condition|)
block|{
name|do_add
argument_list|(
operator|&
name|v
argument_list|,
operator|&
name|normr
argument_list|,
operator|&
name|u
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Call round_for_format since we might need to denormalize.  */
name|round_for_format
argument_list|(
name|base_fmt
argument_list|,
operator|&
name|v
argument_list|)
expr_stmt|;
name|encode_ieee_double
argument_list|(
name|base_fmt
argument_list|,
operator|&
name|buf
index|[
literal|2
index|]
argument_list|,
operator|&
name|v
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Inf, NaN, 0 are all representable as doubles, so the 	 least-significant part can be 0.0.  */
name|buf
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|decode_ibm_extended
parameter_list|(
specifier|const
name|struct
name|real_format
modifier|*
name|fmt
name|ATTRIBUTE_UNUSED
parameter_list|,
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|,
specifier|const
name|long
modifier|*
name|buf
parameter_list|)
block|{
name|REAL_VALUE_TYPE
name|u
decl_stmt|,
name|v
decl_stmt|;
specifier|const
name|struct
name|real_format
modifier|*
name|base_fmt
decl_stmt|;
name|base_fmt
operator|=
name|fmt
operator|->
name|qnan_msb_set
condition|?
operator|&
name|ieee_double_format
else|:
operator|&
name|mips_double_format
expr_stmt|;
name|decode_ieee_double
argument_list|(
name|base_fmt
argument_list|,
operator|&
name|u
argument_list|,
operator|&
name|buf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|class
operator|!=
name|rvc_zero
operator|&&
name|u
operator|.
name|class
operator|!=
name|rvc_inf
operator|&&
name|u
operator|.
name|class
operator|!=
name|rvc_nan
condition|)
block|{
name|decode_ieee_double
argument_list|(
name|base_fmt
argument_list|,
operator|&
name|v
argument_list|,
operator|&
name|buf
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|do_add
argument_list|(
name|r
argument_list|,
operator|&
name|u
argument_list|,
operator|&
name|v
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|r
operator|=
name|u
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|const
name|struct
name|real_format
name|ibm_extended_format
init|=
block|{
name|encode_ibm_extended
block|,
name|decode_ibm_extended
block|,
literal|2
block|,
literal|1
block|,
literal|53
operator|+
literal|53
block|,
literal|53
block|,
operator|-
literal|1021
operator|+
literal|53
block|,
literal|1024
block|,
operator|-
literal|1
block|,
name|true
block|,
name|true
block|,
name|true
block|,
name|true
block|,
name|true
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|real_format
name|mips_extended_format
init|=
block|{
name|encode_ibm_extended
block|,
name|decode_ibm_extended
block|,
literal|2
block|,
literal|1
block|,
literal|53
operator|+
literal|53
block|,
literal|53
block|,
operator|-
literal|1021
operator|+
literal|53
block|,
literal|1024
block|,
operator|-
literal|1
block|,
name|true
block|,
name|true
block|,
name|true
block|,
name|true
block|,
name|false
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* IEEE quad precision format.  */
end_comment

begin_function_decl
specifier|static
name|void
name|encode_ieee_quad
parameter_list|(
specifier|const
name|struct
name|real_format
modifier|*
name|fmt
parameter_list|,
name|long
modifier|*
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|decode_ieee_quad
parameter_list|(
specifier|const
name|struct
name|real_format
modifier|*
parameter_list|,
name|REAL_VALUE_TYPE
modifier|*
parameter_list|,
specifier|const
name|long
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|encode_ieee_quad
parameter_list|(
specifier|const
name|struct
name|real_format
modifier|*
name|fmt
parameter_list|,
name|long
modifier|*
name|buf
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|)
block|{
name|unsigned
name|long
name|image3
decl_stmt|,
name|image2
decl_stmt|,
name|image1
decl_stmt|,
name|image0
decl_stmt|,
name|exp
decl_stmt|;
name|bool
name|denormal
init|=
operator|(
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|1
index|]
operator|&
name|SIG_MSB
operator|)
operator|==
literal|0
decl_stmt|;
name|REAL_VALUE_TYPE
name|u
decl_stmt|;
name|image3
operator|=
name|r
operator|->
name|sign
operator|<<
literal|31
expr_stmt|;
name|image2
operator|=
literal|0
expr_stmt|;
name|image1
operator|=
literal|0
expr_stmt|;
name|image0
operator|=
literal|0
expr_stmt|;
name|rshift_significand
argument_list|(
operator|&
name|u
argument_list|,
name|r
argument_list|,
name|SIGNIFICAND_BITS
operator|-
literal|113
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r
operator|->
name|class
condition|)
block|{
case|case
name|rvc_zero
case|:
break|break;
case|case
name|rvc_inf
case|:
if|if
condition|(
name|fmt
operator|->
name|has_inf
condition|)
name|image3
operator||=
literal|32767
operator|<<
literal|16
expr_stmt|;
else|else
block|{
name|image3
operator||=
literal|0x7fffffff
expr_stmt|;
name|image2
operator|=
literal|0xffffffff
expr_stmt|;
name|image1
operator|=
literal|0xffffffff
expr_stmt|;
name|image0
operator|=
literal|0xffffffff
expr_stmt|;
block|}
break|break;
case|case
name|rvc_nan
case|:
if|if
condition|(
name|fmt
operator|->
name|has_nans
condition|)
block|{
name|image3
operator||=
literal|32767
operator|<<
literal|16
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|canonical
condition|)
block|{
comment|/* Don't use bits from the significand.  The 		 initialization above is right.  */
block|}
elseif|else
if|if
condition|(
name|HOST_BITS_PER_LONG
operator|==
literal|32
condition|)
block|{
name|image0
operator|=
name|u
operator|.
name|sig
index|[
literal|0
index|]
expr_stmt|;
name|image1
operator|=
name|u
operator|.
name|sig
index|[
literal|1
index|]
expr_stmt|;
name|image2
operator|=
name|u
operator|.
name|sig
index|[
literal|2
index|]
expr_stmt|;
name|image3
operator||=
name|u
operator|.
name|sig
index|[
literal|3
index|]
operator|&
literal|0xffff
expr_stmt|;
block|}
else|else
block|{
name|image0
operator|=
name|u
operator|.
name|sig
index|[
literal|0
index|]
expr_stmt|;
name|image1
operator|=
name|image0
operator|>>
literal|31
operator|>>
literal|1
expr_stmt|;
name|image2
operator|=
name|u
operator|.
name|sig
index|[
literal|1
index|]
expr_stmt|;
name|image3
operator||=
operator|(
name|image2
operator|>>
literal|31
operator|>>
literal|1
operator|)
operator|&
literal|0xffff
expr_stmt|;
name|image0
operator|&=
literal|0xffffffff
expr_stmt|;
name|image2
operator|&=
literal|0xffffffff
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|->
name|signalling
operator|==
name|fmt
operator|->
name|qnan_msb_set
condition|)
name|image3
operator|&=
operator|~
literal|0x8000
expr_stmt|;
else|else
name|image3
operator||=
literal|0x8000
expr_stmt|;
comment|/* We overload qnan_msb_set here: it's only clear for 	     mips_ieee_single, which wants all mantissa bits but the 	     quiet/signalling one set in canonical NaNs (at least 	     Quiet ones).  */
if|if
condition|(
name|r
operator|->
name|canonical
operator|&&
operator|!
name|fmt
operator|->
name|qnan_msb_set
condition|)
block|{
name|image3
operator||=
literal|0x7fff
expr_stmt|;
name|image2
operator|=
name|image1
operator|=
name|image0
operator|=
literal|0xffffffff
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|image3
operator|&
literal|0xffff
operator|)
operator||
name|image2
operator||
name|image1
operator||
name|image0
operator|)
operator|==
literal|0
condition|)
name|image3
operator||=
literal|0x4000
expr_stmt|;
block|}
else|else
block|{
name|image3
operator||=
literal|0x7fffffff
expr_stmt|;
name|image2
operator|=
literal|0xffffffff
expr_stmt|;
name|image1
operator|=
literal|0xffffffff
expr_stmt|;
name|image0
operator|=
literal|0xffffffff
expr_stmt|;
block|}
break|break;
case|case
name|rvc_normal
case|:
comment|/* Recall that IEEE numbers are interpreted as 1.F x 2**exp, 	 whereas the intermediate representation is 0.F x 2**exp. 	 Which means we're off by one.  */
if|if
condition|(
name|denormal
condition|)
name|exp
operator|=
literal|0
expr_stmt|;
else|else
name|exp
operator|=
name|r
operator|->
name|exp
operator|+
literal|16383
operator|-
literal|1
expr_stmt|;
name|image3
operator||=
name|exp
operator|<<
literal|16
expr_stmt|;
if|if
condition|(
name|HOST_BITS_PER_LONG
operator|==
literal|32
condition|)
block|{
name|image0
operator|=
name|u
operator|.
name|sig
index|[
literal|0
index|]
expr_stmt|;
name|image1
operator|=
name|u
operator|.
name|sig
index|[
literal|1
index|]
expr_stmt|;
name|image2
operator|=
name|u
operator|.
name|sig
index|[
literal|2
index|]
expr_stmt|;
name|image3
operator||=
name|u
operator|.
name|sig
index|[
literal|3
index|]
operator|&
literal|0xffff
expr_stmt|;
block|}
else|else
block|{
name|image0
operator|=
name|u
operator|.
name|sig
index|[
literal|0
index|]
expr_stmt|;
name|image1
operator|=
name|image0
operator|>>
literal|31
operator|>>
literal|1
expr_stmt|;
name|image2
operator|=
name|u
operator|.
name|sig
index|[
literal|1
index|]
expr_stmt|;
name|image3
operator||=
operator|(
name|image2
operator|>>
literal|31
operator|>>
literal|1
operator|)
operator|&
literal|0xffff
expr_stmt|;
name|image0
operator|&=
literal|0xffffffff
expr_stmt|;
name|image2
operator|&=
literal|0xffffffff
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|FLOAT_WORDS_BIG_ENDIAN
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
name|image3
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|image2
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|image1
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|image0
expr_stmt|;
block|}
else|else
block|{
name|buf
index|[
literal|0
index|]
operator|=
name|image0
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|image1
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|image2
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|image3
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|decode_ieee_quad
parameter_list|(
specifier|const
name|struct
name|real_format
modifier|*
name|fmt
parameter_list|,
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|,
specifier|const
name|long
modifier|*
name|buf
parameter_list|)
block|{
name|unsigned
name|long
name|image3
decl_stmt|,
name|image2
decl_stmt|,
name|image1
decl_stmt|,
name|image0
decl_stmt|;
name|bool
name|sign
decl_stmt|;
name|int
name|exp
decl_stmt|;
if|if
condition|(
name|FLOAT_WORDS_BIG_ENDIAN
condition|)
block|{
name|image3
operator|=
name|buf
index|[
literal|0
index|]
expr_stmt|;
name|image2
operator|=
name|buf
index|[
literal|1
index|]
expr_stmt|;
name|image1
operator|=
name|buf
index|[
literal|2
index|]
expr_stmt|;
name|image0
operator|=
name|buf
index|[
literal|3
index|]
expr_stmt|;
block|}
else|else
block|{
name|image0
operator|=
name|buf
index|[
literal|0
index|]
expr_stmt|;
name|image1
operator|=
name|buf
index|[
literal|1
index|]
expr_stmt|;
name|image2
operator|=
name|buf
index|[
literal|2
index|]
expr_stmt|;
name|image3
operator|=
name|buf
index|[
literal|3
index|]
expr_stmt|;
block|}
name|image0
operator|&=
literal|0xffffffff
expr_stmt|;
name|image1
operator|&=
literal|0xffffffff
expr_stmt|;
name|image2
operator|&=
literal|0xffffffff
expr_stmt|;
name|sign
operator|=
operator|(
name|image3
operator|>>
literal|31
operator|)
operator|&
literal|1
expr_stmt|;
name|exp
operator|=
operator|(
name|image3
operator|>>
literal|16
operator|)
operator|&
literal|0x7fff
expr_stmt|;
name|image3
operator|&=
literal|0xffff
expr_stmt|;
name|memset
argument_list|(
name|r
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|r
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|image3
operator||
name|image2
operator||
name|image1
operator||
name|image0
operator|)
operator|&&
name|fmt
operator|->
name|has_denorm
condition|)
block|{
name|r
operator|->
name|class
operator|=
name|rvc_normal
expr_stmt|;
name|r
operator|->
name|sign
operator|=
name|sign
expr_stmt|;
name|r
operator|->
name|exp
operator|=
operator|-
literal|16382
operator|+
operator|(
name|SIGNIFICAND_BITS
operator|-
literal|112
operator|)
expr_stmt|;
if|if
condition|(
name|HOST_BITS_PER_LONG
operator|==
literal|32
condition|)
block|{
name|r
operator|->
name|sig
index|[
literal|0
index|]
operator|=
name|image0
expr_stmt|;
name|r
operator|->
name|sig
index|[
literal|1
index|]
operator|=
name|image1
expr_stmt|;
name|r
operator|->
name|sig
index|[
literal|2
index|]
operator|=
name|image2
expr_stmt|;
name|r
operator|->
name|sig
index|[
literal|3
index|]
operator|=
name|image3
expr_stmt|;
block|}
else|else
block|{
name|r
operator|->
name|sig
index|[
literal|0
index|]
operator|=
operator|(
name|image1
operator|<<
literal|31
operator|<<
literal|1
operator|)
operator||
name|image0
expr_stmt|;
name|r
operator|->
name|sig
index|[
literal|1
index|]
operator|=
operator|(
name|image3
operator|<<
literal|31
operator|<<
literal|1
operator|)
operator||
name|image2
expr_stmt|;
block|}
name|normalize
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
operator|->
name|has_signed_zero
condition|)
name|r
operator|->
name|sign
operator|=
name|sign
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|exp
operator|==
literal|32767
operator|&&
operator|(
name|fmt
operator|->
name|has_nans
operator|||
name|fmt
operator|->
name|has_inf
operator|)
condition|)
block|{
if|if
condition|(
name|image3
operator||
name|image2
operator||
name|image1
operator||
name|image0
condition|)
block|{
name|r
operator|->
name|class
operator|=
name|rvc_nan
expr_stmt|;
name|r
operator|->
name|sign
operator|=
name|sign
expr_stmt|;
name|r
operator|->
name|signalling
operator|=
operator|(
operator|(
name|image3
operator|>>
literal|15
operator|)
operator|&
literal|1
operator|)
operator|^
name|fmt
operator|->
name|qnan_msb_set
expr_stmt|;
if|if
condition|(
name|HOST_BITS_PER_LONG
operator|==
literal|32
condition|)
block|{
name|r
operator|->
name|sig
index|[
literal|0
index|]
operator|=
name|image0
expr_stmt|;
name|r
operator|->
name|sig
index|[
literal|1
index|]
operator|=
name|image1
expr_stmt|;
name|r
operator|->
name|sig
index|[
literal|2
index|]
operator|=
name|image2
expr_stmt|;
name|r
operator|->
name|sig
index|[
literal|3
index|]
operator|=
name|image3
expr_stmt|;
block|}
else|else
block|{
name|r
operator|->
name|sig
index|[
literal|0
index|]
operator|=
operator|(
name|image1
operator|<<
literal|31
operator|<<
literal|1
operator|)
operator||
name|image0
expr_stmt|;
name|r
operator|->
name|sig
index|[
literal|1
index|]
operator|=
operator|(
name|image3
operator|<<
literal|31
operator|<<
literal|1
operator|)
operator||
name|image2
expr_stmt|;
block|}
name|lshift_significand
argument_list|(
name|r
argument_list|,
name|r
argument_list|,
name|SIGNIFICAND_BITS
operator|-
literal|113
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|r
operator|->
name|class
operator|=
name|rvc_inf
expr_stmt|;
name|r
operator|->
name|sign
operator|=
name|sign
expr_stmt|;
block|}
block|}
else|else
block|{
name|r
operator|->
name|class
operator|=
name|rvc_normal
expr_stmt|;
name|r
operator|->
name|sign
operator|=
name|sign
expr_stmt|;
name|r
operator|->
name|exp
operator|=
name|exp
operator|-
literal|16383
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|HOST_BITS_PER_LONG
operator|==
literal|32
condition|)
block|{
name|r
operator|->
name|sig
index|[
literal|0
index|]
operator|=
name|image0
expr_stmt|;
name|r
operator|->
name|sig
index|[
literal|1
index|]
operator|=
name|image1
expr_stmt|;
name|r
operator|->
name|sig
index|[
literal|2
index|]
operator|=
name|image2
expr_stmt|;
name|r
operator|->
name|sig
index|[
literal|3
index|]
operator|=
name|image3
expr_stmt|;
block|}
else|else
block|{
name|r
operator|->
name|sig
index|[
literal|0
index|]
operator|=
operator|(
name|image1
operator|<<
literal|31
operator|<<
literal|1
operator|)
operator||
name|image0
expr_stmt|;
name|r
operator|->
name|sig
index|[
literal|1
index|]
operator|=
operator|(
name|image3
operator|<<
literal|31
operator|<<
literal|1
operator|)
operator||
name|image2
expr_stmt|;
block|}
name|lshift_significand
argument_list|(
name|r
argument_list|,
name|r
argument_list|,
name|SIGNIFICAND_BITS
operator|-
literal|113
argument_list|)
expr_stmt|;
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|1
index|]
operator||=
name|SIG_MSB
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|const
name|struct
name|real_format
name|ieee_quad_format
init|=
block|{
name|encode_ieee_quad
block|,
name|decode_ieee_quad
block|,
literal|2
block|,
literal|1
block|,
literal|113
block|,
literal|113
block|,
operator|-
literal|16381
block|,
literal|16384
block|,
literal|127
block|,
name|true
block|,
name|true
block|,
name|true
block|,
name|true
block|,
name|true
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|real_format
name|mips_quad_format
init|=
block|{
name|encode_ieee_quad
block|,
name|decode_ieee_quad
block|,
literal|2
block|,
literal|1
block|,
literal|113
block|,
literal|113
block|,
operator|-
literal|16381
block|,
literal|16384
block|,
literal|127
block|,
name|true
block|,
name|true
block|,
name|true
block|,
name|true
block|,
name|false
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Descriptions of VAX floating point formats can be found beginning at     http://h71000.www7.hp.com/doc/73FINAL/4515/4515pro_013.html#f_floating_point_format     The thing to remember is that they're almost IEEE, except for word    order, exponent bias, and the lack of infinities, nans, and denormals.     We don't implement the H_floating format here, simply because neither    the VAX or Alpha ports use it.  */
end_comment

begin_function_decl
specifier|static
name|void
name|encode_vax_f
parameter_list|(
specifier|const
name|struct
name|real_format
modifier|*
name|fmt
parameter_list|,
name|long
modifier|*
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|decode_vax_f
parameter_list|(
specifier|const
name|struct
name|real_format
modifier|*
parameter_list|,
name|REAL_VALUE_TYPE
modifier|*
parameter_list|,
specifier|const
name|long
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|encode_vax_d
parameter_list|(
specifier|const
name|struct
name|real_format
modifier|*
name|fmt
parameter_list|,
name|long
modifier|*
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|decode_vax_d
parameter_list|(
specifier|const
name|struct
name|real_format
modifier|*
parameter_list|,
name|REAL_VALUE_TYPE
modifier|*
parameter_list|,
specifier|const
name|long
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|encode_vax_g
parameter_list|(
specifier|const
name|struct
name|real_format
modifier|*
name|fmt
parameter_list|,
name|long
modifier|*
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|decode_vax_g
parameter_list|(
specifier|const
name|struct
name|real_format
modifier|*
parameter_list|,
name|REAL_VALUE_TYPE
modifier|*
parameter_list|,
specifier|const
name|long
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|encode_vax_f
parameter_list|(
specifier|const
name|struct
name|real_format
modifier|*
name|fmt
name|ATTRIBUTE_UNUSED
parameter_list|,
name|long
modifier|*
name|buf
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|)
block|{
name|unsigned
name|long
name|sign
decl_stmt|,
name|exp
decl_stmt|,
name|sig
decl_stmt|,
name|image
decl_stmt|;
name|sign
operator|=
name|r
operator|->
name|sign
operator|<<
literal|15
expr_stmt|;
switch|switch
condition|(
name|r
operator|->
name|class
condition|)
block|{
case|case
name|rvc_zero
case|:
name|image
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|rvc_inf
case|:
case|case
name|rvc_nan
case|:
name|image
operator|=
literal|0xffff7fff
operator||
name|sign
expr_stmt|;
break|break;
case|case
name|rvc_normal
case|:
name|sig
operator|=
operator|(
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|1
index|]
operator|>>
operator|(
name|HOST_BITS_PER_LONG
operator|-
literal|24
operator|)
operator|)
operator|&
literal|0x7fffff
expr_stmt|;
name|exp
operator|=
name|r
operator|->
name|exp
operator|+
literal|128
expr_stmt|;
name|image
operator|=
operator|(
name|sig
operator|<<
literal|16
operator|)
operator|&
literal|0xffff0000
expr_stmt|;
name|image
operator||=
name|sign
expr_stmt|;
name|image
operator||=
name|exp
operator|<<
literal|7
expr_stmt|;
name|image
operator||=
name|sig
operator|>>
literal|16
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|buf
index|[
literal|0
index|]
operator|=
name|image
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|decode_vax_f
parameter_list|(
specifier|const
name|struct
name|real_format
modifier|*
name|fmt
name|ATTRIBUTE_UNUSED
parameter_list|,
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|,
specifier|const
name|long
modifier|*
name|buf
parameter_list|)
block|{
name|unsigned
name|long
name|image
init|=
name|buf
index|[
literal|0
index|]
operator|&
literal|0xffffffff
decl_stmt|;
name|int
name|exp
init|=
operator|(
name|image
operator|>>
literal|7
operator|)
operator|&
literal|0xff
decl_stmt|;
name|memset
argument_list|(
name|r
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|r
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|!=
literal|0
condition|)
block|{
name|r
operator|->
name|class
operator|=
name|rvc_normal
expr_stmt|;
name|r
operator|->
name|sign
operator|=
operator|(
name|image
operator|>>
literal|15
operator|)
operator|&
literal|1
expr_stmt|;
name|r
operator|->
name|exp
operator|=
name|exp
operator|-
literal|128
expr_stmt|;
name|image
operator|=
operator|(
operator|(
name|image
operator|&
literal|0x7f
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|image
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|1
index|]
operator|=
operator|(
name|image
operator|<<
operator|(
name|HOST_BITS_PER_LONG
operator|-
literal|24
operator|)
operator|)
operator||
name|SIG_MSB
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|encode_vax_d
parameter_list|(
specifier|const
name|struct
name|real_format
modifier|*
name|fmt
name|ATTRIBUTE_UNUSED
parameter_list|,
name|long
modifier|*
name|buf
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|)
block|{
name|unsigned
name|long
name|image0
decl_stmt|,
name|image1
decl_stmt|,
name|sign
init|=
name|r
operator|->
name|sign
operator|<<
literal|15
decl_stmt|;
switch|switch
condition|(
name|r
operator|->
name|class
condition|)
block|{
case|case
name|rvc_zero
case|:
name|image0
operator|=
name|image1
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|rvc_inf
case|:
case|case
name|rvc_nan
case|:
name|image0
operator|=
literal|0xffff7fff
operator||
name|sign
expr_stmt|;
name|image1
operator|=
literal|0xffffffff
expr_stmt|;
break|break;
case|case
name|rvc_normal
case|:
comment|/* Extract the significand into straight hi:lo.  */
if|if
condition|(
name|HOST_BITS_PER_LONG
operator|==
literal|64
condition|)
block|{
name|image0
operator|=
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|1
index|]
expr_stmt|;
name|image1
operator|=
operator|(
name|image0
operator|>>
operator|(
literal|64
operator|-
literal|56
operator|)
operator|)
operator|&
literal|0xffffffff
expr_stmt|;
name|image0
operator|=
operator|(
name|image0
operator|>>
operator|(
literal|64
operator|-
literal|56
operator|+
literal|1
operator|)
operator|>>
literal|31
operator|)
operator|&
literal|0x7fffff
expr_stmt|;
block|}
else|else
block|{
name|image0
operator|=
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|1
index|]
expr_stmt|;
name|image1
operator|=
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|2
index|]
expr_stmt|;
name|image1
operator|=
operator|(
name|image0
operator|<<
literal|24
operator|)
operator||
operator|(
name|image1
operator|>>
literal|8
operator|)
expr_stmt|;
name|image0
operator|=
operator|(
name|image0
operator|>>
literal|8
operator|)
operator|&
literal|0xffffff
expr_stmt|;
block|}
comment|/* Rearrange the half-words of the significand to match the 	 external format.  */
name|image0
operator|=
operator|(
operator|(
name|image0
operator|<<
literal|16
operator|)
operator||
operator|(
name|image0
operator|>>
literal|16
operator|)
operator|)
operator|&
literal|0xffff007f
expr_stmt|;
name|image1
operator|=
operator|(
operator|(
name|image1
operator|<<
literal|16
operator|)
operator||
operator|(
name|image1
operator|>>
literal|16
operator|)
operator|)
operator|&
literal|0xffffffff
expr_stmt|;
comment|/* Add the sign and exponent.  */
name|image0
operator||=
name|sign
expr_stmt|;
name|image0
operator||=
operator|(
name|r
operator|->
name|exp
operator|+
literal|128
operator|)
operator|<<
literal|7
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|FLOAT_WORDS_BIG_ENDIAN
condition|)
name|buf
index|[
literal|0
index|]
operator|=
name|image1
operator|,
name|buf
index|[
literal|1
index|]
operator|=
name|image0
expr_stmt|;
else|else
name|buf
index|[
literal|0
index|]
operator|=
name|image0
operator|,
name|buf
index|[
literal|1
index|]
operator|=
name|image1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|decode_vax_d
parameter_list|(
specifier|const
name|struct
name|real_format
modifier|*
name|fmt
name|ATTRIBUTE_UNUSED
parameter_list|,
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|,
specifier|const
name|long
modifier|*
name|buf
parameter_list|)
block|{
name|unsigned
name|long
name|image0
decl_stmt|,
name|image1
decl_stmt|;
name|int
name|exp
decl_stmt|;
if|if
condition|(
name|FLOAT_WORDS_BIG_ENDIAN
condition|)
name|image1
operator|=
name|buf
index|[
literal|0
index|]
operator|,
name|image0
operator|=
name|buf
index|[
literal|1
index|]
expr_stmt|;
else|else
name|image0
operator|=
name|buf
index|[
literal|0
index|]
operator|,
name|image1
operator|=
name|buf
index|[
literal|1
index|]
expr_stmt|;
name|image0
operator|&=
literal|0xffffffff
expr_stmt|;
name|image1
operator|&=
literal|0xffffffff
expr_stmt|;
name|exp
operator|=
operator|(
name|image0
operator|>>
literal|7
operator|)
operator|&
literal|0xff
expr_stmt|;
name|memset
argument_list|(
name|r
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|r
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|!=
literal|0
condition|)
block|{
name|r
operator|->
name|class
operator|=
name|rvc_normal
expr_stmt|;
name|r
operator|->
name|sign
operator|=
operator|(
name|image0
operator|>>
literal|15
operator|)
operator|&
literal|1
expr_stmt|;
name|r
operator|->
name|exp
operator|=
name|exp
operator|-
literal|128
expr_stmt|;
comment|/* Rearrange the half-words of the external format into 	 proper ascending order.  */
name|image0
operator|=
operator|(
operator|(
name|image0
operator|&
literal|0x7f
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|image0
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|image1
operator|=
operator|(
operator|(
name|image1
operator|&
literal|0xffff
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|image1
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
expr_stmt|;
if|if
condition|(
name|HOST_BITS_PER_LONG
operator|==
literal|64
condition|)
block|{
name|image0
operator|=
operator|(
name|image0
operator|<<
literal|31
operator|<<
literal|1
operator|)
operator||
name|image1
expr_stmt|;
name|image0
operator|<<=
literal|64
operator|-
literal|56
expr_stmt|;
name|image0
operator||=
name|SIG_MSB
expr_stmt|;
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|1
index|]
operator|=
name|image0
expr_stmt|;
block|}
else|else
block|{
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|1
index|]
operator|=
name|image0
expr_stmt|;
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|2
index|]
operator|=
name|image1
expr_stmt|;
name|lshift_significand
argument_list|(
name|r
argument_list|,
name|r
argument_list|,
literal|2
operator|*
name|HOST_BITS_PER_LONG
operator|-
literal|56
argument_list|)
expr_stmt|;
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|1
index|]
operator||=
name|SIG_MSB
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|encode_vax_g
parameter_list|(
specifier|const
name|struct
name|real_format
modifier|*
name|fmt
name|ATTRIBUTE_UNUSED
parameter_list|,
name|long
modifier|*
name|buf
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|)
block|{
name|unsigned
name|long
name|image0
decl_stmt|,
name|image1
decl_stmt|,
name|sign
init|=
name|r
operator|->
name|sign
operator|<<
literal|15
decl_stmt|;
switch|switch
condition|(
name|r
operator|->
name|class
condition|)
block|{
case|case
name|rvc_zero
case|:
name|image0
operator|=
name|image1
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|rvc_inf
case|:
case|case
name|rvc_nan
case|:
name|image0
operator|=
literal|0xffff7fff
operator||
name|sign
expr_stmt|;
name|image1
operator|=
literal|0xffffffff
expr_stmt|;
break|break;
case|case
name|rvc_normal
case|:
comment|/* Extract the significand into straight hi:lo.  */
if|if
condition|(
name|HOST_BITS_PER_LONG
operator|==
literal|64
condition|)
block|{
name|image0
operator|=
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|1
index|]
expr_stmt|;
name|image1
operator|=
operator|(
name|image0
operator|>>
operator|(
literal|64
operator|-
literal|53
operator|)
operator|)
operator|&
literal|0xffffffff
expr_stmt|;
name|image0
operator|=
operator|(
name|image0
operator|>>
operator|(
literal|64
operator|-
literal|53
operator|+
literal|1
operator|)
operator|>>
literal|31
operator|)
operator|&
literal|0xfffff
expr_stmt|;
block|}
else|else
block|{
name|image0
operator|=
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|1
index|]
expr_stmt|;
name|image1
operator|=
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|2
index|]
expr_stmt|;
name|image1
operator|=
operator|(
name|image0
operator|<<
literal|21
operator|)
operator||
operator|(
name|image1
operator|>>
literal|11
operator|)
expr_stmt|;
name|image0
operator|=
operator|(
name|image0
operator|>>
literal|11
operator|)
operator|&
literal|0xfffff
expr_stmt|;
block|}
comment|/* Rearrange the half-words of the significand to match the 	 external format.  */
name|image0
operator|=
operator|(
operator|(
name|image0
operator|<<
literal|16
operator|)
operator||
operator|(
name|image0
operator|>>
literal|16
operator|)
operator|)
operator|&
literal|0xffff000f
expr_stmt|;
name|image1
operator|=
operator|(
operator|(
name|image1
operator|<<
literal|16
operator|)
operator||
operator|(
name|image1
operator|>>
literal|16
operator|)
operator|)
operator|&
literal|0xffffffff
expr_stmt|;
comment|/* Add the sign and exponent.  */
name|image0
operator||=
name|sign
expr_stmt|;
name|image0
operator||=
operator|(
name|r
operator|->
name|exp
operator|+
literal|1024
operator|)
operator|<<
literal|4
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|FLOAT_WORDS_BIG_ENDIAN
condition|)
name|buf
index|[
literal|0
index|]
operator|=
name|image1
operator|,
name|buf
index|[
literal|1
index|]
operator|=
name|image0
expr_stmt|;
else|else
name|buf
index|[
literal|0
index|]
operator|=
name|image0
operator|,
name|buf
index|[
literal|1
index|]
operator|=
name|image1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|decode_vax_g
parameter_list|(
specifier|const
name|struct
name|real_format
modifier|*
name|fmt
name|ATTRIBUTE_UNUSED
parameter_list|,
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|,
specifier|const
name|long
modifier|*
name|buf
parameter_list|)
block|{
name|unsigned
name|long
name|image0
decl_stmt|,
name|image1
decl_stmt|;
name|int
name|exp
decl_stmt|;
if|if
condition|(
name|FLOAT_WORDS_BIG_ENDIAN
condition|)
name|image1
operator|=
name|buf
index|[
literal|0
index|]
operator|,
name|image0
operator|=
name|buf
index|[
literal|1
index|]
expr_stmt|;
else|else
name|image0
operator|=
name|buf
index|[
literal|0
index|]
operator|,
name|image1
operator|=
name|buf
index|[
literal|1
index|]
expr_stmt|;
name|image0
operator|&=
literal|0xffffffff
expr_stmt|;
name|image1
operator|&=
literal|0xffffffff
expr_stmt|;
name|exp
operator|=
operator|(
name|image0
operator|>>
literal|4
operator|)
operator|&
literal|0x7ff
expr_stmt|;
name|memset
argument_list|(
name|r
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|r
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|!=
literal|0
condition|)
block|{
name|r
operator|->
name|class
operator|=
name|rvc_normal
expr_stmt|;
name|r
operator|->
name|sign
operator|=
operator|(
name|image0
operator|>>
literal|15
operator|)
operator|&
literal|1
expr_stmt|;
name|r
operator|->
name|exp
operator|=
name|exp
operator|-
literal|1024
expr_stmt|;
comment|/* Rearrange the half-words of the external format into 	 proper ascending order.  */
name|image0
operator|=
operator|(
operator|(
name|image0
operator|&
literal|0xf
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|image0
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|image1
operator|=
operator|(
operator|(
name|image1
operator|&
literal|0xffff
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|image1
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
expr_stmt|;
if|if
condition|(
name|HOST_BITS_PER_LONG
operator|==
literal|64
condition|)
block|{
name|image0
operator|=
operator|(
name|image0
operator|<<
literal|31
operator|<<
literal|1
operator|)
operator||
name|image1
expr_stmt|;
name|image0
operator|<<=
literal|64
operator|-
literal|53
expr_stmt|;
name|image0
operator||=
name|SIG_MSB
expr_stmt|;
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|1
index|]
operator|=
name|image0
expr_stmt|;
block|}
else|else
block|{
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|1
index|]
operator|=
name|image0
expr_stmt|;
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|2
index|]
operator|=
name|image1
expr_stmt|;
name|lshift_significand
argument_list|(
name|r
argument_list|,
name|r
argument_list|,
literal|64
operator|-
literal|53
argument_list|)
expr_stmt|;
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|1
index|]
operator||=
name|SIG_MSB
expr_stmt|;
block|}
block|}
block|}
end_function

begin_decl_stmt
specifier|const
name|struct
name|real_format
name|vax_f_format
init|=
block|{
name|encode_vax_f
block|,
name|decode_vax_f
block|,
literal|2
block|,
literal|1
block|,
literal|24
block|,
literal|24
block|,
operator|-
literal|127
block|,
literal|127
block|,
literal|15
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|false
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|real_format
name|vax_d_format
init|=
block|{
name|encode_vax_d
block|,
name|decode_vax_d
block|,
literal|2
block|,
literal|1
block|,
literal|56
block|,
literal|56
block|,
operator|-
literal|127
block|,
literal|127
block|,
literal|15
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|false
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|real_format
name|vax_g_format
init|=
block|{
name|encode_vax_g
block|,
name|decode_vax_g
block|,
literal|2
block|,
literal|1
block|,
literal|53
block|,
literal|53
block|,
operator|-
literal|1023
block|,
literal|1023
block|,
literal|15
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|false
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* A good reference for these can be found in chapter 9 of    "ESA/390 Principles of Operation", IBM document number SA22-7201-01.    An on-line version can be found here:     http://publibz.boulder.ibm.com/cgi-bin/bookmgr_OS390/BOOKS/DZ9AR001/9.1?DT=19930923083613 */
end_comment

begin_function_decl
specifier|static
name|void
name|encode_i370_single
parameter_list|(
specifier|const
name|struct
name|real_format
modifier|*
name|fmt
parameter_list|,
name|long
modifier|*
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|decode_i370_single
parameter_list|(
specifier|const
name|struct
name|real_format
modifier|*
parameter_list|,
name|REAL_VALUE_TYPE
modifier|*
parameter_list|,
specifier|const
name|long
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|encode_i370_double
parameter_list|(
specifier|const
name|struct
name|real_format
modifier|*
name|fmt
parameter_list|,
name|long
modifier|*
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|decode_i370_double
parameter_list|(
specifier|const
name|struct
name|real_format
modifier|*
parameter_list|,
name|REAL_VALUE_TYPE
modifier|*
parameter_list|,
specifier|const
name|long
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|encode_i370_single
parameter_list|(
specifier|const
name|struct
name|real_format
modifier|*
name|fmt
name|ATTRIBUTE_UNUSED
parameter_list|,
name|long
modifier|*
name|buf
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|)
block|{
name|unsigned
name|long
name|sign
decl_stmt|,
name|exp
decl_stmt|,
name|sig
decl_stmt|,
name|image
decl_stmt|;
name|sign
operator|=
name|r
operator|->
name|sign
operator|<<
literal|31
expr_stmt|;
switch|switch
condition|(
name|r
operator|->
name|class
condition|)
block|{
case|case
name|rvc_zero
case|:
name|image
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|rvc_inf
case|:
case|case
name|rvc_nan
case|:
name|image
operator|=
literal|0x7fffffff
operator||
name|sign
expr_stmt|;
break|break;
case|case
name|rvc_normal
case|:
name|sig
operator|=
operator|(
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|1
index|]
operator|>>
operator|(
name|HOST_BITS_PER_LONG
operator|-
literal|24
operator|)
operator|)
operator|&
literal|0xffffff
expr_stmt|;
name|exp
operator|=
operator|(
operator|(
name|r
operator|->
name|exp
operator|/
literal|4
operator|)
operator|+
literal|64
operator|)
operator|<<
literal|24
expr_stmt|;
name|image
operator|=
name|sign
operator||
name|exp
operator||
name|sig
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|buf
index|[
literal|0
index|]
operator|=
name|image
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|decode_i370_single
parameter_list|(
specifier|const
name|struct
name|real_format
modifier|*
name|fmt
name|ATTRIBUTE_UNUSED
parameter_list|,
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|,
specifier|const
name|long
modifier|*
name|buf
parameter_list|)
block|{
name|unsigned
name|long
name|sign
decl_stmt|,
name|sig
decl_stmt|,
name|image
init|=
name|buf
index|[
literal|0
index|]
decl_stmt|;
name|int
name|exp
decl_stmt|;
name|sign
operator|=
operator|(
name|image
operator|>>
literal|31
operator|)
operator|&
literal|1
expr_stmt|;
name|exp
operator|=
operator|(
name|image
operator|>>
literal|24
operator|)
operator|&
literal|0x7f
expr_stmt|;
name|sig
operator|=
name|image
operator|&
literal|0xffffff
expr_stmt|;
name|memset
argument_list|(
name|r
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|r
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|||
name|sig
condition|)
block|{
name|r
operator|->
name|class
operator|=
name|rvc_normal
expr_stmt|;
name|r
operator|->
name|sign
operator|=
name|sign
expr_stmt|;
name|r
operator|->
name|exp
operator|=
operator|(
name|exp
operator|-
literal|64
operator|)
operator|*
literal|4
expr_stmt|;
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|1
index|]
operator|=
name|sig
operator|<<
operator|(
name|HOST_BITS_PER_LONG
operator|-
literal|24
operator|)
expr_stmt|;
name|normalize
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|encode_i370_double
parameter_list|(
specifier|const
name|struct
name|real_format
modifier|*
name|fmt
name|ATTRIBUTE_UNUSED
parameter_list|,
name|long
modifier|*
name|buf
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|)
block|{
name|unsigned
name|long
name|sign
decl_stmt|,
name|exp
decl_stmt|,
name|image_hi
decl_stmt|,
name|image_lo
decl_stmt|;
name|sign
operator|=
name|r
operator|->
name|sign
operator|<<
literal|31
expr_stmt|;
switch|switch
condition|(
name|r
operator|->
name|class
condition|)
block|{
case|case
name|rvc_zero
case|:
name|image_hi
operator|=
name|image_lo
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|rvc_inf
case|:
case|case
name|rvc_nan
case|:
name|image_hi
operator|=
literal|0x7fffffff
operator||
name|sign
expr_stmt|;
name|image_lo
operator|=
literal|0xffffffff
expr_stmt|;
break|break;
case|case
name|rvc_normal
case|:
if|if
condition|(
name|HOST_BITS_PER_LONG
operator|==
literal|64
condition|)
block|{
name|image_hi
operator|=
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|1
index|]
expr_stmt|;
name|image_lo
operator|=
operator|(
name|image_hi
operator|>>
operator|(
literal|64
operator|-
literal|56
operator|)
operator|)
operator|&
literal|0xffffffff
expr_stmt|;
name|image_hi
operator|=
operator|(
name|image_hi
operator|>>
operator|(
literal|64
operator|-
literal|56
operator|+
literal|1
operator|)
operator|>>
literal|31
operator|)
operator|&
literal|0xffffff
expr_stmt|;
block|}
else|else
block|{
name|image_hi
operator|=
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|1
index|]
expr_stmt|;
name|image_lo
operator|=
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|2
index|]
expr_stmt|;
name|image_lo
operator|=
operator|(
name|image_lo
operator|>>
literal|8
operator|)
operator||
operator|(
name|image_hi
operator|<<
literal|24
operator|)
expr_stmt|;
name|image_hi
operator|>>=
literal|8
expr_stmt|;
block|}
name|exp
operator|=
operator|(
operator|(
name|r
operator|->
name|exp
operator|/
literal|4
operator|)
operator|+
literal|64
operator|)
operator|<<
literal|24
expr_stmt|;
name|image_hi
operator||=
name|sign
operator||
name|exp
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|FLOAT_WORDS_BIG_ENDIAN
condition|)
name|buf
index|[
literal|0
index|]
operator|=
name|image_hi
operator|,
name|buf
index|[
literal|1
index|]
operator|=
name|image_lo
expr_stmt|;
else|else
name|buf
index|[
literal|0
index|]
operator|=
name|image_lo
operator|,
name|buf
index|[
literal|1
index|]
operator|=
name|image_hi
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|decode_i370_double
parameter_list|(
specifier|const
name|struct
name|real_format
modifier|*
name|fmt
name|ATTRIBUTE_UNUSED
parameter_list|,
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|,
specifier|const
name|long
modifier|*
name|buf
parameter_list|)
block|{
name|unsigned
name|long
name|sign
decl_stmt|,
name|image_hi
decl_stmt|,
name|image_lo
decl_stmt|;
name|int
name|exp
decl_stmt|;
if|if
condition|(
name|FLOAT_WORDS_BIG_ENDIAN
condition|)
name|image_hi
operator|=
name|buf
index|[
literal|0
index|]
operator|,
name|image_lo
operator|=
name|buf
index|[
literal|1
index|]
expr_stmt|;
else|else
name|image_lo
operator|=
name|buf
index|[
literal|0
index|]
operator|,
name|image_hi
operator|=
name|buf
index|[
literal|1
index|]
expr_stmt|;
name|sign
operator|=
operator|(
name|image_hi
operator|>>
literal|31
operator|)
operator|&
literal|1
expr_stmt|;
name|exp
operator|=
operator|(
name|image_hi
operator|>>
literal|24
operator|)
operator|&
literal|0x7f
expr_stmt|;
name|image_hi
operator|&=
literal|0xffffff
expr_stmt|;
name|image_lo
operator|&=
literal|0xffffffff
expr_stmt|;
name|memset
argument_list|(
name|r
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|r
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|||
name|image_hi
operator|||
name|image_lo
condition|)
block|{
name|r
operator|->
name|class
operator|=
name|rvc_normal
expr_stmt|;
name|r
operator|->
name|sign
operator|=
name|sign
expr_stmt|;
name|r
operator|->
name|exp
operator|=
operator|(
name|exp
operator|-
literal|64
operator|)
operator|*
literal|4
operator|+
operator|(
name|SIGNIFICAND_BITS
operator|-
literal|56
operator|)
expr_stmt|;
if|if
condition|(
name|HOST_BITS_PER_LONG
operator|==
literal|32
condition|)
block|{
name|r
operator|->
name|sig
index|[
literal|0
index|]
operator|=
name|image_lo
expr_stmt|;
name|r
operator|->
name|sig
index|[
literal|1
index|]
operator|=
name|image_hi
expr_stmt|;
block|}
else|else
name|r
operator|->
name|sig
index|[
literal|0
index|]
operator|=
name|image_lo
operator||
operator|(
name|image_hi
operator|<<
literal|31
operator|<<
literal|1
operator|)
expr_stmt|;
name|normalize
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|const
name|struct
name|real_format
name|i370_single_format
init|=
block|{
name|encode_i370_single
block|,
name|decode_i370_single
block|,
literal|16
block|,
literal|4
block|,
literal|6
block|,
literal|6
block|,
operator|-
literal|64
block|,
literal|63
block|,
literal|31
block|,
name|false
block|,
name|false
block|,
name|false
block|,
comment|/* ??? The encoding does allow for "unnormals".  */
name|false
block|,
comment|/* ??? The encoding does allow for "unnormals".  */
name|false
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|real_format
name|i370_double_format
init|=
block|{
name|encode_i370_double
block|,
name|decode_i370_double
block|,
literal|16
block|,
literal|4
block|,
literal|14
block|,
literal|14
block|,
operator|-
literal|64
block|,
literal|63
block|,
literal|63
block|,
name|false
block|,
name|false
block|,
name|false
block|,
comment|/* ??? The encoding does allow for "unnormals".  */
name|false
block|,
comment|/* ??? The encoding does allow for "unnormals".  */
name|false
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* The "twos-complement" c4x format is officially defined as  	x = s(~s).f * 2**e     This is rather misleading.  One must remember that F is signed.    A better description would be  	x = -1**s * ((s + 1 + .f) * 2**e     So if we have a (4 bit) fraction of .1000 with a sign bit of 1,    that's -1 * (1+1+(-.5)) == -1.5.  I think.     The constructions here are taken from Tables 5-1 and 5-2 of the    TMS320C4x User's Guide wherein step-by-step instructions for    conversion from IEEE are presented.  That's close enough to our    internal representation so as to make things easy.     See http://www-s.ti.com/sc/psheets/spru063c/spru063c.pdf  */
end_comment

begin_function_decl
specifier|static
name|void
name|encode_c4x_single
parameter_list|(
specifier|const
name|struct
name|real_format
modifier|*
name|fmt
parameter_list|,
name|long
modifier|*
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|decode_c4x_single
parameter_list|(
specifier|const
name|struct
name|real_format
modifier|*
parameter_list|,
name|REAL_VALUE_TYPE
modifier|*
parameter_list|,
specifier|const
name|long
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|encode_c4x_extended
parameter_list|(
specifier|const
name|struct
name|real_format
modifier|*
name|fmt
parameter_list|,
name|long
modifier|*
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|decode_c4x_extended
parameter_list|(
specifier|const
name|struct
name|real_format
modifier|*
parameter_list|,
name|REAL_VALUE_TYPE
modifier|*
parameter_list|,
specifier|const
name|long
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|encode_c4x_single
parameter_list|(
specifier|const
name|struct
name|real_format
modifier|*
name|fmt
name|ATTRIBUTE_UNUSED
parameter_list|,
name|long
modifier|*
name|buf
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|)
block|{
name|unsigned
name|long
name|image
decl_stmt|,
name|exp
decl_stmt|,
name|sig
decl_stmt|;
switch|switch
condition|(
name|r
operator|->
name|class
condition|)
block|{
case|case
name|rvc_zero
case|:
name|exp
operator|=
operator|-
literal|128
expr_stmt|;
name|sig
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|rvc_inf
case|:
case|case
name|rvc_nan
case|:
name|exp
operator|=
literal|127
expr_stmt|;
name|sig
operator|=
literal|0x800000
operator|-
name|r
operator|->
name|sign
expr_stmt|;
break|break;
case|case
name|rvc_normal
case|:
name|exp
operator|=
name|r
operator|->
name|exp
operator|-
literal|1
expr_stmt|;
name|sig
operator|=
operator|(
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|1
index|]
operator|>>
operator|(
name|HOST_BITS_PER_LONG
operator|-
literal|24
operator|)
operator|)
operator|&
literal|0x7fffff
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|sign
condition|)
block|{
if|if
condition|(
name|sig
condition|)
name|sig
operator|=
operator|-
name|sig
expr_stmt|;
else|else
name|exp
operator|--
expr_stmt|;
name|sig
operator||=
literal|0x800000
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|image
operator|=
operator|(
operator|(
name|exp
operator|&
literal|0xff
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
name|sig
operator|&
literal|0xffffff
operator|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|image
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|decode_c4x_single
parameter_list|(
specifier|const
name|struct
name|real_format
modifier|*
name|fmt
name|ATTRIBUTE_UNUSED
parameter_list|,
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|,
specifier|const
name|long
modifier|*
name|buf
parameter_list|)
block|{
name|unsigned
name|long
name|image
init|=
name|buf
index|[
literal|0
index|]
decl_stmt|;
name|unsigned
name|long
name|sig
decl_stmt|;
name|int
name|exp
decl_stmt|,
name|sf
decl_stmt|;
name|exp
operator|=
operator|(
operator|(
operator|(
name|image
operator|>>
literal|24
operator|)
operator|&
literal|0xff
operator|)
operator|^
literal|0x80
operator|)
operator|-
literal|0x80
expr_stmt|;
name|sf
operator|=
operator|(
operator|(
name|image
operator|&
literal|0xffffff
operator|)
operator|^
literal|0x800000
operator|)
operator|-
literal|0x800000
expr_stmt|;
name|memset
argument_list|(
name|r
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|r
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|!=
operator|-
literal|128
condition|)
block|{
name|r
operator|->
name|class
operator|=
name|rvc_normal
expr_stmt|;
name|sig
operator|=
name|sf
operator|&
literal|0x7fffff
expr_stmt|;
if|if
condition|(
name|sf
operator|<
literal|0
condition|)
block|{
name|r
operator|->
name|sign
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sig
condition|)
name|sig
operator|=
operator|-
name|sig
expr_stmt|;
else|else
name|exp
operator|++
expr_stmt|;
block|}
name|sig
operator|=
operator|(
name|sig
operator|<<
operator|(
name|HOST_BITS_PER_LONG
operator|-
literal|24
operator|)
operator|)
operator||
name|SIG_MSB
expr_stmt|;
name|r
operator|->
name|exp
operator|=
name|exp
operator|+
literal|1
expr_stmt|;
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|1
index|]
operator|=
name|sig
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|encode_c4x_extended
parameter_list|(
specifier|const
name|struct
name|real_format
modifier|*
name|fmt
name|ATTRIBUTE_UNUSED
parameter_list|,
name|long
modifier|*
name|buf
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|)
block|{
name|unsigned
name|long
name|exp
decl_stmt|,
name|sig
decl_stmt|;
switch|switch
condition|(
name|r
operator|->
name|class
condition|)
block|{
case|case
name|rvc_zero
case|:
name|exp
operator|=
operator|-
literal|128
expr_stmt|;
name|sig
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|rvc_inf
case|:
case|case
name|rvc_nan
case|:
name|exp
operator|=
literal|127
expr_stmt|;
name|sig
operator|=
literal|0x80000000
operator|-
name|r
operator|->
name|sign
expr_stmt|;
break|break;
case|case
name|rvc_normal
case|:
name|exp
operator|=
name|r
operator|->
name|exp
operator|-
literal|1
expr_stmt|;
name|sig
operator|=
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|HOST_BITS_PER_LONG
operator|==
literal|64
condition|)
name|sig
operator|=
name|sig
operator|>>
literal|1
operator|>>
literal|31
expr_stmt|;
name|sig
operator|&=
literal|0x7fffffff
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|sign
condition|)
block|{
if|if
condition|(
name|sig
condition|)
name|sig
operator|=
operator|-
name|sig
expr_stmt|;
else|else
name|exp
operator|--
expr_stmt|;
name|sig
operator||=
literal|0x80000000
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|exp
operator|=
operator|(
name|exp
operator|&
literal|0xff
operator|)
operator|<<
literal|24
expr_stmt|;
name|sig
operator|&=
literal|0xffffffff
expr_stmt|;
if|if
condition|(
name|FLOAT_WORDS_BIG_ENDIAN
condition|)
name|buf
index|[
literal|0
index|]
operator|=
name|exp
operator|,
name|buf
index|[
literal|1
index|]
operator|=
name|sig
expr_stmt|;
else|else
name|buf
index|[
literal|0
index|]
operator|=
name|sig
operator|,
name|buf
index|[
literal|0
index|]
operator|=
name|exp
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|decode_c4x_extended
parameter_list|(
specifier|const
name|struct
name|real_format
modifier|*
name|fmt
name|ATTRIBUTE_UNUSED
parameter_list|,
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|,
specifier|const
name|long
modifier|*
name|buf
parameter_list|)
block|{
name|unsigned
name|long
name|sig
decl_stmt|;
name|int
name|exp
decl_stmt|,
name|sf
decl_stmt|;
if|if
condition|(
name|FLOAT_WORDS_BIG_ENDIAN
condition|)
name|exp
operator|=
name|buf
index|[
literal|0
index|]
operator|,
name|sf
operator|=
name|buf
index|[
literal|1
index|]
expr_stmt|;
else|else
name|sf
operator|=
name|buf
index|[
literal|0
index|]
operator|,
name|exp
operator|=
name|buf
index|[
literal|1
index|]
expr_stmt|;
name|exp
operator|=
operator|(
operator|(
operator|(
name|exp
operator|>>
literal|24
operator|)
operator|&
literal|0xff
operator|)
operator|&
literal|0x80
operator|)
operator|-
literal|0x80
expr_stmt|;
name|sf
operator|=
operator|(
operator|(
name|sf
operator|&
literal|0xffffffff
operator|)
operator|^
literal|0x80000000
operator|)
operator|-
literal|0x80000000
expr_stmt|;
name|memset
argument_list|(
name|r
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|r
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|!=
operator|-
literal|128
condition|)
block|{
name|r
operator|->
name|class
operator|=
name|rvc_normal
expr_stmt|;
name|sig
operator|=
name|sf
operator|&
literal|0x7fffffff
expr_stmt|;
if|if
condition|(
name|sf
operator|<
literal|0
condition|)
block|{
name|r
operator|->
name|sign
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sig
condition|)
name|sig
operator|=
operator|-
name|sig
expr_stmt|;
else|else
name|exp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|HOST_BITS_PER_LONG
operator|==
literal|64
condition|)
name|sig
operator|=
name|sig
operator|<<
literal|1
operator|<<
literal|31
expr_stmt|;
name|sig
operator||=
name|SIG_MSB
expr_stmt|;
name|r
operator|->
name|exp
operator|=
name|exp
operator|+
literal|1
expr_stmt|;
name|r
operator|->
name|sig
index|[
name|SIGSZ
operator|-
literal|1
index|]
operator|=
name|sig
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|const
name|struct
name|real_format
name|c4x_single_format
init|=
block|{
name|encode_c4x_single
block|,
name|decode_c4x_single
block|,
literal|2
block|,
literal|1
block|,
literal|24
block|,
literal|24
block|,
operator|-
literal|126
block|,
literal|128
block|,
operator|-
literal|1
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|false
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|real_format
name|c4x_extended_format
init|=
block|{
name|encode_c4x_extended
block|,
name|decode_c4x_extended
block|,
literal|2
block|,
literal|1
block|,
literal|32
block|,
literal|32
block|,
operator|-
literal|126
block|,
literal|128
block|,
operator|-
literal|1
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|false
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* A synthetic "format" for internal arithmetic.  It's the size of the    internal significand minus the two bits needed for proper rounding.    The encode and decode routines exist only to satisfy our paranoia    harness.  */
end_comment

begin_function_decl
specifier|static
name|void
name|encode_internal
parameter_list|(
specifier|const
name|struct
name|real_format
modifier|*
name|fmt
parameter_list|,
name|long
modifier|*
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|decode_internal
parameter_list|(
specifier|const
name|struct
name|real_format
modifier|*
parameter_list|,
name|REAL_VALUE_TYPE
modifier|*
parameter_list|,
specifier|const
name|long
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|encode_internal
parameter_list|(
specifier|const
name|struct
name|real_format
modifier|*
name|fmt
name|ATTRIBUTE_UNUSED
parameter_list|,
name|long
modifier|*
name|buf
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|)
block|{
name|memcpy
argument_list|(
name|buf
argument_list|,
name|r
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|r
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|decode_internal
parameter_list|(
specifier|const
name|struct
name|real_format
modifier|*
name|fmt
name|ATTRIBUTE_UNUSED
parameter_list|,
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|,
specifier|const
name|long
modifier|*
name|buf
parameter_list|)
block|{
name|memcpy
argument_list|(
name|r
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|r
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|const
name|struct
name|real_format
name|real_internal_format
init|=
block|{
name|encode_internal
block|,
name|decode_internal
block|,
literal|2
block|,
literal|1
block|,
name|SIGNIFICAND_BITS
operator|-
literal|2
block|,
name|SIGNIFICAND_BITS
operator|-
literal|2
block|,
operator|-
name|MAX_EXP
block|,
name|MAX_EXP
block|,
operator|-
literal|1
block|,
name|true
block|,
name|true
block|,
name|false
block|,
name|true
block|,
name|true
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Calculate the square root of X in mode MODE, and store the result    in R.  Return TRUE if the operation does not raise an exception.    For details see "High Precision Division and Square Root",    Alan H. Karp and Peter Markstein, HP Lab Report 93-93-42, June    1993.  http://www.hpl.hp.com/techreports/93/HPL-93-42.pdf.  */
end_comment

begin_function
name|bool
name|real_sqrt
parameter_list|(
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|x
parameter_list|)
block|{
specifier|static
name|REAL_VALUE_TYPE
name|halfthree
decl_stmt|;
specifier|static
name|bool
name|init
init|=
name|false
decl_stmt|;
name|REAL_VALUE_TYPE
name|h
decl_stmt|,
name|t
decl_stmt|,
name|i
decl_stmt|;
name|int
name|iter
decl_stmt|,
name|exp
decl_stmt|;
comment|/* sqrt(-0.0) is -0.0.  */
if|if
condition|(
name|real_isnegzero
argument_list|(
name|x
argument_list|)
condition|)
block|{
operator|*
name|r
operator|=
operator|*
name|x
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Negative arguments return NaN.  */
if|if
condition|(
name|real_isneg
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|get_canonical_qnan
argument_list|(
name|r
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Infinity and NaN return themselves.  */
if|if
condition|(
name|real_isinf
argument_list|(
name|x
argument_list|)
operator|||
name|real_isnan
argument_list|(
name|x
argument_list|)
condition|)
block|{
operator|*
name|r
operator|=
operator|*
name|x
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|init
condition|)
block|{
name|do_add
argument_list|(
operator|&
name|halfthree
argument_list|,
operator|&
name|dconst1
argument_list|,
operator|&
name|dconsthalf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|init
operator|=
name|true
expr_stmt|;
block|}
comment|/* Initial guess for reciprocal sqrt, i.  */
name|exp
operator|=
name|real_exponent
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|real_ldexp
argument_list|(
operator|&
name|i
argument_list|,
operator|&
name|dconst1
argument_list|,
operator|-
name|exp
operator|/
literal|2
argument_list|)
expr_stmt|;
comment|/* Newton's iteration for reciprocal sqrt, i.  */
for|for
control|(
name|iter
operator|=
literal|0
init|;
name|iter
operator|<
literal|16
condition|;
name|iter
operator|++
control|)
block|{
comment|/* i(n+1) = i(n) * (1.5 - 0.5*i(n)*i(n)*x).  */
name|do_multiply
argument_list|(
operator|&
name|t
argument_list|,
name|x
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
name|do_multiply
argument_list|(
operator|&
name|h
argument_list|,
operator|&
name|t
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
name|do_multiply
argument_list|(
operator|&
name|t
argument_list|,
operator|&
name|h
argument_list|,
operator|&
name|dconsthalf
argument_list|)
expr_stmt|;
name|do_add
argument_list|(
operator|&
name|h
argument_list|,
operator|&
name|halfthree
argument_list|,
operator|&
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|do_multiply
argument_list|(
operator|&
name|t
argument_list|,
operator|&
name|i
argument_list|,
operator|&
name|h
argument_list|)
expr_stmt|;
comment|/* Check for early convergence.  */
if|if
condition|(
name|iter
operator|>=
literal|6
operator|&&
name|real_identical
argument_list|(
operator|&
name|i
argument_list|,
operator|&
name|t
argument_list|)
condition|)
break|break;
comment|/* ??? Unroll loop to avoid copying.  */
name|i
operator|=
name|t
expr_stmt|;
block|}
comment|/* Final iteration: r = i*x + 0.5*i*x*(1.0 - i*(i*x)).  */
name|do_multiply
argument_list|(
operator|&
name|t
argument_list|,
name|x
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
name|do_multiply
argument_list|(
operator|&
name|h
argument_list|,
operator|&
name|t
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
name|do_add
argument_list|(
operator|&
name|i
argument_list|,
operator|&
name|dconst1
argument_list|,
operator|&
name|h
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|do_multiply
argument_list|(
operator|&
name|h
argument_list|,
operator|&
name|t
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
name|do_multiply
argument_list|(
operator|&
name|i
argument_list|,
operator|&
name|dconsthalf
argument_list|,
operator|&
name|h
argument_list|)
expr_stmt|;
name|do_add
argument_list|(
operator|&
name|h
argument_list|,
operator|&
name|t
argument_list|,
operator|&
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* ??? We need a Tuckerman test to get the last bit.  */
name|real_convert
argument_list|(
name|r
argument_list|,
name|mode
argument_list|,
operator|&
name|h
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Calculate X raised to the integer exponent N in mode MODE and store    the result in R.  Return true if the result may be inexact due to    loss of precision.  The algorithm is the classic "left-to-right binary    method" described in section 4.6.3 of Donald Knuth's "Seminumerical    Algorithms", "The Art of Computer Programming", Volume 2.  */
end_comment

begin_function
name|bool
name|real_powi
parameter_list|(
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|x
parameter_list|,
name|HOST_WIDE_INT
name|n
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|bit
decl_stmt|;
name|REAL_VALUE_TYPE
name|t
decl_stmt|;
name|bool
name|inexact
init|=
name|false
decl_stmt|;
name|bool
name|init
init|=
name|false
decl_stmt|;
name|bool
name|neg
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
operator|*
name|r
operator|=
name|dconst1
expr_stmt|;
return|return
name|false
return|;
block|}
elseif|else
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
comment|/* Don't worry about overflow, from now on n is unsigned.  */
name|neg
operator|=
name|true
expr_stmt|;
name|n
operator|=
operator|-
name|n
expr_stmt|;
block|}
else|else
name|neg
operator|=
name|false
expr_stmt|;
name|t
operator|=
operator|*
name|x
expr_stmt|;
name|bit
operator|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|init
condition|)
block|{
name|inexact
operator||=
name|do_multiply
argument_list|(
operator|&
name|t
argument_list|,
operator|&
name|t
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|&
name|bit
condition|)
name|inexact
operator||=
name|do_multiply
argument_list|(
operator|&
name|t
argument_list|,
operator|&
name|t
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n
operator|&
name|bit
condition|)
name|init
operator|=
name|true
expr_stmt|;
name|bit
operator|>>=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|neg
condition|)
name|inexact
operator||=
name|do_divide
argument_list|(
operator|&
name|t
argument_list|,
operator|&
name|dconst1
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
name|real_convert
argument_list|(
name|r
argument_list|,
name|mode
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
return|return
name|inexact
return|;
block|}
end_function

begin_comment
comment|/* Round X to the nearest integer not larger in absolute value, i.e.    towards zero, placing the result in R in mode MODE.  */
end_comment

begin_function
name|void
name|real_trunc
parameter_list|(
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|x
parameter_list|)
block|{
name|do_fix_trunc
argument_list|(
name|r
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
condition|)
name|real_convert
argument_list|(
name|r
argument_list|,
name|mode
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Round X to the largest integer not greater in value, i.e. round    down, placing the result in R in mode MODE.  */
end_comment

begin_function
name|void
name|real_floor
parameter_list|(
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|x
parameter_list|)
block|{
name|do_fix_trunc
argument_list|(
name|r
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|real_identical
argument_list|(
name|r
argument_list|,
name|x
argument_list|)
operator|&&
name|r
operator|->
name|sign
condition|)
name|do_add
argument_list|(
name|r
argument_list|,
name|r
argument_list|,
operator|&
name|dconstm1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
condition|)
name|real_convert
argument_list|(
name|r
argument_list|,
name|mode
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Round X to the smallest integer not less then argument, i.e. round    up, placing the result in R in mode MODE.  */
end_comment

begin_function
name|void
name|real_ceil
parameter_list|(
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
specifier|const
name|REAL_VALUE_TYPE
modifier|*
name|x
parameter_list|)
block|{
name|do_fix_trunc
argument_list|(
name|r
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|real_identical
argument_list|(
name|r
argument_list|,
name|x
argument_list|)
operator|&&
operator|!
name|r
operator|->
name|sign
condition|)
name|do_add
argument_list|(
name|r
argument_list|,
name|r
argument_list|,
operator|&
name|dconst1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
condition|)
name|real_convert
argument_list|(
name|r
argument_list|,
name|mode
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

