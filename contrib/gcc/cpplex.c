begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* CPP Library - lexical analysis.    Copyright (C) 2000, 2001, 2002, 2003 Free Software Foundation, Inc.    Contributed by Per Bothner, 1994-95.    Based on CCCP program by Paul Rubin, June 1986    Adapted to ANSI C, Richard Stallman, Jan 1987    Broken out to separate file, Zack Weinberg, Mar 2000  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"cpplib.h"
end_include

begin_include
include|#
directive|include
file|"cpphash.h"
end_include

begin_enum
enum|enum
name|spell_type
block|{
name|SPELL_OPERATOR
init|=
literal|0
block|,
name|SPELL_IDENT
block|,
name|SPELL_LITERAL
block|,
name|SPELL_NONE
block|}
enum|;
end_enum

begin_struct
struct|struct
name|token_spelling
block|{
name|enum
name|spell_type
name|category
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|char
modifier|*
specifier|const
name|digraph_spellings
index|[]
init|=
block|{
literal|U"%:"
block|,
literal|U"%:%:"
block|,
literal|U"<:"
block|,
literal|U":>"
block|,
literal|U"<%"
block|,
literal|U"%>"
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|OP
parameter_list|(
name|e
parameter_list|,
name|s
parameter_list|)
value|{ SPELL_OPERATOR, U s           },
end_define

begin_define
define|#
directive|define
name|TK
parameter_list|(
name|e
parameter_list|,
name|s
parameter_list|)
value|{ s,              U #e },
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|token_spelling
name|token_spellings
index|[
name|N_TTYPES
index|]
init|=
block|{
name|TTYPE_TABLE
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|OP
end_undef

begin_undef
undef|#
directive|undef
name|TK
end_undef

begin_define
define|#
directive|define
name|TOKEN_SPELL
parameter_list|(
name|token
parameter_list|)
value|(token_spellings[(token)->type].category)
end_define

begin_define
define|#
directive|define
name|TOKEN_NAME
parameter_list|(
name|token
parameter_list|)
value|(token_spellings[(token)->type].name)
end_define

begin_function_decl
specifier|static
name|void
name|add_line_note
parameter_list|(
name|cpp_buffer
modifier|*
parameter_list|,
specifier|const
name|uchar
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|skip_line_comment
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|skip_whitespace
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
name|cppchar_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|cpp_hashnode
modifier|*
name|lex_identifier
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
specifier|const
name|uchar
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lex_number
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
name|cpp_string
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|forms_identifier_p
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lex_string
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
name|cpp_token
modifier|*
parameter_list|,
specifier|const
name|uchar
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|save_comment
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
name|cpp_token
modifier|*
parameter_list|,
specifier|const
name|uchar
modifier|*
parameter_list|,
name|cppchar_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|create_literal
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
name|cpp_token
modifier|*
parameter_list|,
specifier|const
name|uchar
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|enum
name|cpp_ttype
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|warn_in_comment
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
name|_cpp_line_note
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|name_p
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
specifier|const
name|cpp_string
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tokenrun
modifier|*
name|next_tokenrun
parameter_list|(
name|tokenrun
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|_cpp_buff
modifier|*
name|new_buff
parameter_list|(
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Utility routine:     Compares, the token TOKEN to the NUL-terminated string STRING.    TOKEN must be a CPP_NAME.  Returns 1 for equal, 0 for unequal.  */
end_comment

begin_function
name|int
name|cpp_ideq
parameter_list|(
specifier|const
name|cpp_token
modifier|*
name|token
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|CPP_NAME
condition|)
return|return
literal|0
return|;
return|return
operator|!
name|ustrcmp
argument_list|(
name|NODE_NAME
argument_list|(
name|token
operator|->
name|val
operator|.
name|node
argument_list|)
argument_list|,
operator|(
specifier|const
name|uchar
operator|*
operator|)
name|string
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Record a note TYPE at byte POS into the current cleaned logical    line.  */
end_comment

begin_function
specifier|static
name|void
name|add_line_note
parameter_list|(
name|cpp_buffer
modifier|*
name|buffer
parameter_list|,
specifier|const
name|uchar
modifier|*
name|pos
parameter_list|,
name|unsigned
name|int
name|type
parameter_list|)
block|{
if|if
condition|(
name|buffer
operator|->
name|notes_used
operator|==
name|buffer
operator|->
name|notes_cap
condition|)
block|{
name|buffer
operator|->
name|notes_cap
operator|=
name|buffer
operator|->
name|notes_cap
operator|*
literal|2
operator|+
literal|200
expr_stmt|;
name|buffer
operator|->
name|notes
operator|=
name|xrealloc
argument_list|(
name|buffer
operator|->
name|notes
argument_list|,
name|buffer
operator|->
name|notes_cap
operator|*
sizeof|sizeof
argument_list|(
name|_cpp_line_note
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|buffer
operator|->
name|notes
index|[
name|buffer
operator|->
name|notes_used
index|]
operator|.
name|pos
operator|=
name|pos
expr_stmt|;
name|buffer
operator|->
name|notes
index|[
name|buffer
operator|->
name|notes_used
index|]
operator|.
name|type
operator|=
name|type
expr_stmt|;
name|buffer
operator|->
name|notes_used
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns with a logical line that contains no escaped newlines or    trigraphs.  This is a time-critical inner loop.  */
end_comment

begin_function
name|void
name|_cpp_clean_line
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
name|cpp_buffer
modifier|*
name|buffer
decl_stmt|;
specifier|const
name|uchar
modifier|*
name|s
decl_stmt|;
name|uchar
name|c
decl_stmt|,
modifier|*
name|d
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|buffer
operator|=
name|pfile
operator|->
name|buffer
expr_stmt|;
name|buffer
operator|->
name|cur_note
operator|=
name|buffer
operator|->
name|notes_used
operator|=
literal|0
expr_stmt|;
name|buffer
operator|->
name|cur
operator|=
name|buffer
operator|->
name|line_base
operator|=
name|buffer
operator|->
name|next_line
expr_stmt|;
name|buffer
operator|->
name|need_line
operator|=
name|false
expr_stmt|;
name|s
operator|=
name|buffer
operator|->
name|next_line
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|buffer
operator|->
name|from_stage3
condition|)
block|{
comment|/* Short circuit for the common case of an un-escaped line with 	 no trigraphs.  The primary win here is by not writing any 	 data back to memory until we have to.  */
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
operator|*
operator|++
name|s
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'\r'
condition|)
block|{
name|d
operator|=
operator|(
name|uchar
operator|*
operator|)
name|s
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|buffer
operator|->
name|rlimit
condition|)
goto|goto
name|done
goto|;
comment|/* DOS line ending? */
if|if
condition|(
name|c
operator|==
literal|'\r'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|buffer
operator|->
name|rlimit
condition|)
goto|goto
name|done
goto|;
comment|/* check for escaped newline */
name|p
operator|=
name|d
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|buffer
operator|->
name|next_line
operator|&&
name|is_nvspace
argument_list|(
name|p
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
name|p
operator|--
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|buffer
operator|->
name|next_line
operator|||
name|p
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\\'
condition|)
goto|goto
name|done
goto|;
comment|/* Have an escaped newline; process it and proceed to 		 the slow path.  */
name|add_line_note
argument_list|(
name|buffer
argument_list|,
name|p
operator|-
literal|1
argument_list|,
name|p
operator|!=
name|d
condition|?
literal|' '
else|:
literal|'\\'
argument_list|)
expr_stmt|;
name|d
operator|=
name|p
operator|-
literal|2
expr_stmt|;
name|buffer
operator|->
name|next_line
operator|=
name|p
operator|-
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|==
literal|'?'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'?'
operator|&&
name|_cpp_trigraph_map
index|[
name|s
index|[
literal|2
index|]
index|]
condition|)
block|{
comment|/* Have a trigraph.  We may or may not have to convert 		 it.  Add a line note regardless, for -Wtrigraphs.  */
name|add_line_note
argument_list|(
name|buffer
argument_list|,
name|s
argument_list|,
name|s
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|trigraphs
argument_list|)
condition|)
block|{
comment|/* We do, and that means we have to switch to the 		     slow path.  */
name|d
operator|=
operator|(
name|uchar
operator|*
operator|)
name|s
expr_stmt|;
operator|*
name|d
operator|=
name|_cpp_trigraph_map
index|[
name|s
index|[
literal|2
index|]
index|]
expr_stmt|;
name|s
operator|+=
literal|2
expr_stmt|;
break|break;
block|}
block|}
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
operator|*
operator|++
name|s
expr_stmt|;
operator|*
operator|++
name|d
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'\r'
condition|)
block|{
comment|/* Handle DOS line endings.  */
if|if
condition|(
name|c
operator|==
literal|'\r'
operator|&&
name|s
operator|!=
name|buffer
operator|->
name|rlimit
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|buffer
operator|->
name|rlimit
condition|)
break|break;
comment|/* Escaped?  */
name|p
operator|=
name|d
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|buffer
operator|->
name|next_line
operator|&&
name|is_nvspace
argument_list|(
name|p
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
name|p
operator|--
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|buffer
operator|->
name|next_line
operator|||
name|p
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\\'
condition|)
break|break;
name|add_line_note
argument_list|(
name|buffer
argument_list|,
name|p
operator|-
literal|1
argument_list|,
name|p
operator|!=
name|d
condition|?
literal|' '
else|:
literal|'\\'
argument_list|)
expr_stmt|;
name|d
operator|=
name|p
operator|-
literal|2
expr_stmt|;
name|buffer
operator|->
name|next_line
operator|=
name|p
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'?'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'?'
operator|&&
name|_cpp_trigraph_map
index|[
name|s
index|[
literal|2
index|]
index|]
condition|)
block|{
comment|/* Add a note regardless, for the benefit of -Wtrigraphs.  */
name|add_line_note
argument_list|(
name|buffer
argument_list|,
name|d
argument_list|,
name|s
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|trigraphs
argument_list|)
condition|)
block|{
operator|*
name|d
operator|=
name|_cpp_trigraph_map
index|[
name|s
index|[
literal|2
index|]
index|]
expr_stmt|;
name|s
operator|+=
literal|2
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
do|do
name|s
operator|++
expr_stmt|;
do|while
condition|(
operator|*
name|s
operator|!=
literal|'\n'
operator|&&
operator|*
name|s
operator|!=
literal|'\r'
condition|)
do|;
name|d
operator|=
operator|(
name|uchar
operator|*
operator|)
name|s
expr_stmt|;
comment|/* Handle DOS line endings.  */
if|if
condition|(
operator|*
name|s
operator|==
literal|'\r'
operator|&&
name|s
operator|!=
name|buffer
operator|->
name|rlimit
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|s
operator|++
expr_stmt|;
block|}
name|done
label|:
operator|*
name|d
operator|=
literal|'\n'
expr_stmt|;
comment|/* A sentinel note that should never be processed.  */
name|add_line_note
argument_list|(
name|buffer
argument_list|,
name|d
operator|+
literal|1
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|buffer
operator|->
name|next_line
operator|=
name|s
operator|+
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true if the trigraph indicated by NOTE should be warned    about in a comment.  */
end_comment

begin_function
specifier|static
name|bool
name|warn_in_comment
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|_cpp_line_note
modifier|*
name|note
parameter_list|)
block|{
specifier|const
name|uchar
modifier|*
name|p
decl_stmt|;
comment|/* Within comments we don't warn about trigraphs, unless the      trigraph forms an escaped newline, as that may change      behavior.  */
if|if
condition|(
name|note
operator|->
name|type
operator|!=
literal|'/'
condition|)
return|return
name|false
return|;
comment|/* If -trigraphs, then this was an escaped newline iff the next note      is coincident.  */
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|trigraphs
argument_list|)
condition|)
return|return
name|note
index|[
literal|1
index|]
operator|.
name|pos
operator|==
name|note
operator|->
name|pos
return|;
comment|/* Otherwise, see if this forms an escaped newline.  */
name|p
operator|=
name|note
operator|->
name|pos
operator|+
literal|3
expr_stmt|;
while|while
condition|(
name|is_nvspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
comment|/* There might have been escaped newlines between the trigraph and the      newline we found.  Hence the position test.  */
return|return
operator|(
operator|*
name|p
operator|==
literal|'\n'
operator|&&
name|p
operator|<
name|note
index|[
literal|1
index|]
operator|.
name|pos
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Process the notes created by add_line_note as far as the current    location.  */
end_comment

begin_function
name|void
name|_cpp_process_line_notes
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|int
name|in_comment
parameter_list|)
block|{
name|cpp_buffer
modifier|*
name|buffer
init|=
name|pfile
operator|->
name|buffer
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|_cpp_line_note
modifier|*
name|note
init|=
operator|&
name|buffer
operator|->
name|notes
index|[
name|buffer
operator|->
name|cur_note
index|]
decl_stmt|;
name|unsigned
name|int
name|col
decl_stmt|;
if|if
condition|(
name|note
operator|->
name|pos
operator|>
name|buffer
operator|->
name|cur
condition|)
break|break;
name|buffer
operator|->
name|cur_note
operator|++
expr_stmt|;
name|col
operator|=
name|CPP_BUF_COLUMN
argument_list|(
name|buffer
argument_list|,
name|note
operator|->
name|pos
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
operator|->
name|type
operator|==
literal|'\\'
operator|||
name|note
operator|->
name|type
operator|==
literal|' '
condition|)
block|{
if|if
condition|(
name|note
operator|->
name|type
operator|==
literal|' '
operator|&&
operator|!
name|in_comment
condition|)
name|cpp_error_with_line
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_WARNING
argument_list|,
name|pfile
operator|->
name|line
argument_list|,
name|col
argument_list|,
literal|"backslash and newline separated by space"
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|->
name|next_line
operator|>
name|buffer
operator|->
name|rlimit
condition|)
block|{
name|cpp_error_with_line
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_PEDWARN
argument_list|,
name|pfile
operator|->
name|line
argument_list|,
name|col
argument_list|,
literal|"backslash-newline at end of file"
argument_list|)
expr_stmt|;
comment|/* Prevent "no newline at end of file" warning.  */
name|buffer
operator|->
name|next_line
operator|=
name|buffer
operator|->
name|rlimit
expr_stmt|;
block|}
name|buffer
operator|->
name|line_base
operator|=
name|note
operator|->
name|pos
expr_stmt|;
name|pfile
operator|->
name|line
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|_cpp_trigraph_map
index|[
name|note
operator|->
name|type
index|]
condition|)
block|{
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|warn_trigraphs
argument_list|)
operator|&&
operator|(
operator|!
name|in_comment
operator|||
name|warn_in_comment
argument_list|(
name|pfile
argument_list|,
name|note
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|trigraphs
argument_list|)
condition|)
name|cpp_error_with_line
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_WARNING
argument_list|,
name|pfile
operator|->
name|line
argument_list|,
name|col
argument_list|,
literal|"trigraph ??%c converted to %c"
argument_list|,
name|note
operator|->
name|type
argument_list|,
operator|(
name|int
operator|)
name|_cpp_trigraph_map
index|[
name|note
operator|->
name|type
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|cpp_error_with_line
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_WARNING
argument_list|,
name|pfile
operator|->
name|line
argument_list|,
name|col
argument_list|,
literal|"trigraph ??%c ignored, use -trigraphs to enable"
argument_list|,
name|note
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Skip a C-style block comment.  We find the end of the comment by    seeing if an asterisk is before every '/' we encounter.  Returns    nonzero if comment terminated by EOF, zero otherwise.     Buffer->cur points to the initial asterisk of the comment.  */
end_comment

begin_function
name|bool
name|_cpp_skip_block_comment
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
name|cpp_buffer
modifier|*
name|buffer
init|=
name|pfile
operator|->
name|buffer
decl_stmt|;
specifier|const
name|uchar
modifier|*
name|cur
init|=
name|buffer
operator|->
name|cur
decl_stmt|;
name|uchar
name|c
decl_stmt|;
name|cur
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cur
operator|==
literal|'/'
condition|)
name|cur
operator|++
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* People like decorating comments with '*', so check for '/' 	 instead for efficiency.  */
name|c
operator|=
operator|*
name|cur
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'/'
condition|)
block|{
if|if
condition|(
name|cur
index|[
operator|-
literal|2
index|]
operator|==
literal|'*'
condition|)
break|break;
comment|/* Warn about potential nested comments, but not if the '/' 	     comes immediately before the true comment delimiter. 	     Don't bother to get it right across escaped newlines.  */
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|warn_comments
argument_list|)
operator|&&
name|cur
index|[
literal|0
index|]
operator|==
literal|'*'
operator|&&
name|cur
index|[
literal|1
index|]
operator|!=
literal|'/'
condition|)
block|{
name|buffer
operator|->
name|cur
operator|=
name|cur
expr_stmt|;
name|cpp_error_with_line
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_WARNING
argument_list|,
name|pfile
operator|->
name|line
argument_list|,
name|CPP_BUF_COL
argument_list|(
name|buffer
argument_list|)
argument_list|,
literal|"\"/*\" within comment"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|buffer
operator|->
name|cur
operator|=
name|cur
operator|-
literal|1
expr_stmt|;
name|_cpp_process_line_notes
argument_list|(
name|pfile
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|->
name|next_line
operator|>=
name|buffer
operator|->
name|rlimit
condition|)
return|return
name|true
return|;
name|_cpp_clean_line
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|line
operator|++
expr_stmt|;
name|cur
operator|=
name|buffer
operator|->
name|cur
expr_stmt|;
block|}
block|}
name|buffer
operator|->
name|cur
operator|=
name|cur
expr_stmt|;
name|_cpp_process_line_notes
argument_list|(
name|pfile
argument_list|,
name|true
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Skip a C++ line comment, leaving buffer->cur pointing to the    terminating newline.  Handles escaped newlines.  Returns nonzero    if a multiline comment.  */
end_comment

begin_function
specifier|static
name|int
name|skip_line_comment
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
name|cpp_buffer
modifier|*
name|buffer
init|=
name|pfile
operator|->
name|buffer
decl_stmt|;
name|unsigned
name|int
name|orig_line
init|=
name|pfile
operator|->
name|line
decl_stmt|;
while|while
condition|(
operator|*
name|buffer
operator|->
name|cur
operator|!=
literal|'\n'
condition|)
name|buffer
operator|->
name|cur
operator|++
expr_stmt|;
name|_cpp_process_line_notes
argument_list|(
name|pfile
argument_list|,
name|true
argument_list|)
expr_stmt|;
return|return
name|orig_line
operator|!=
name|pfile
operator|->
name|line
return|;
block|}
end_function

begin_comment
comment|/* Skips whitespace, saving the next non-whitespace character.  */
end_comment

begin_function
specifier|static
name|void
name|skip_whitespace
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|cppchar_t
name|c
parameter_list|)
block|{
name|cpp_buffer
modifier|*
name|buffer
init|=
name|pfile
operator|->
name|buffer
decl_stmt|;
name|bool
name|saw_NUL
init|=
name|false
decl_stmt|;
do|do
block|{
comment|/* Horizontal space always OK.  */
if|if
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
empty_stmt|;
comment|/* Just \f \v or \0 left.  */
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
name|saw_NUL
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|pfile
operator|->
name|state
operator|.
name|in_directive
operator|&&
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
condition|)
name|cpp_error_with_line
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_PEDWARN
argument_list|,
name|pfile
operator|->
name|line
argument_list|,
name|CPP_BUF_COL
argument_list|(
name|buffer
argument_list|)
argument_list|,
literal|"%s in preprocessing directive"
argument_list|,
name|c
operator|==
literal|'\f'
condition|?
literal|"form feed"
else|:
literal|"vertical tab"
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
name|buffer
operator|->
name|cur
operator|++
expr_stmt|;
block|}
comment|/* We only want non-vertical space, i.e. ' ' \t \f \v \0.  */
do|while
condition|(
name|is_nvspace
argument_list|(
name|c
argument_list|)
condition|)
do|;
if|if
condition|(
name|saw_NUL
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_WARNING
argument_list|,
literal|"null character(s) ignored"
argument_list|)
expr_stmt|;
name|buffer
operator|->
name|cur
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/* See if the characters of a number token are valid in a name (no    '.', '+' or '-').  */
end_comment

begin_function
specifier|static
name|int
name|name_p
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
specifier|const
name|cpp_string
modifier|*
name|string
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|string
operator|->
name|len
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|is_idchar
argument_list|(
name|string
operator|->
name|text
index|[
name|i
index|]
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Returns TRUE if the sequence starting at buffer->cur is invalid in    an identifier.  FIRST is TRUE if this starts an identifier.  */
end_comment

begin_function
specifier|static
name|bool
name|forms_identifier_p
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|int
name|first
parameter_list|)
block|{
name|cpp_buffer
modifier|*
name|buffer
init|=
name|pfile
operator|->
name|buffer
decl_stmt|;
if|if
condition|(
operator|*
name|buffer
operator|->
name|cur
operator|==
literal|'$'
condition|)
block|{
if|if
condition|(
operator|!
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|dollars_in_ident
argument_list|)
condition|)
return|return
name|false
return|;
name|buffer
operator|->
name|cur
operator|++
expr_stmt|;
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|warn_dollars
argument_list|)
operator|&&
operator|!
name|pfile
operator|->
name|state
operator|.
name|skipping
condition|)
block|{
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|warn_dollars
argument_list|)
operator|=
literal|0
expr_stmt|;
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_PEDWARN
argument_list|,
literal|"'$' in identifier or number"
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
comment|/* Is this a syntactically valid UCN?  */
if|if
condition|(
literal|0
operator|&&
operator|*
name|buffer
operator|->
name|cur
operator|==
literal|'\\'
operator|&&
operator|(
name|buffer
operator|->
name|cur
index|[
literal|1
index|]
operator|==
literal|'u'
operator|||
name|buffer
operator|->
name|cur
index|[
literal|1
index|]
operator|==
literal|'U'
operator|)
condition|)
block|{
name|buffer
operator|->
name|cur
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|_cpp_valid_ucn
argument_list|(
name|pfile
argument_list|,
operator|&
name|buffer
operator|->
name|cur
argument_list|,
name|buffer
operator|->
name|rlimit
argument_list|,
literal|1
operator|+
operator|!
name|first
argument_list|)
condition|)
return|return
name|true
return|;
name|buffer
operator|->
name|cur
operator|-=
literal|2
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Lex an identifier starting at BUFFER->CUR - 1.  */
end_comment

begin_function
specifier|static
name|cpp_hashnode
modifier|*
name|lex_identifier
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
specifier|const
name|uchar
modifier|*
name|base
parameter_list|)
block|{
name|cpp_hashnode
modifier|*
name|result
decl_stmt|;
specifier|const
name|uchar
modifier|*
name|cur
decl_stmt|;
do|do
block|{
name|cur
operator|=
name|pfile
operator|->
name|buffer
operator|->
name|cur
expr_stmt|;
comment|/* N.B. ISIDNUM does not include $.  */
while|while
condition|(
name|ISIDNUM
argument_list|(
operator|*
name|cur
argument_list|)
condition|)
name|cur
operator|++
expr_stmt|;
name|pfile
operator|->
name|buffer
operator|->
name|cur
operator|=
name|cur
expr_stmt|;
block|}
do|while
condition|(
name|forms_identifier_p
argument_list|(
name|pfile
argument_list|,
name|false
argument_list|)
condition|)
do|;
name|result
operator|=
operator|(
name|cpp_hashnode
operator|*
operator|)
name|ht_lookup
argument_list|(
name|pfile
operator|->
name|hash_table
argument_list|,
name|base
argument_list|,
name|cur
operator|-
name|base
argument_list|,
name|HT_ALLOC
argument_list|)
expr_stmt|;
comment|/* Rarely, identifiers require diagnostics when lexed.  */
if|if
condition|(
name|__builtin_expect
argument_list|(
operator|(
name|result
operator|->
name|flags
operator|&
name|NODE_DIAGNOSTIC
operator|)
operator|&&
operator|!
name|pfile
operator|->
name|state
operator|.
name|skipping
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* It is allowed to poison the same identifier twice.  */
if|if
condition|(
operator|(
name|result
operator|->
name|flags
operator|&
name|NODE_POISONED
operator|)
operator|&&
operator|!
name|pfile
operator|->
name|state
operator|.
name|poisoned_ok
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"attempt to use poisoned \"%s\""
argument_list|,
name|NODE_NAME
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Constraint 6.10.3.5: __VA_ARGS__ should only appear in the 	 replacement list of a variadic macro.  */
if|if
condition|(
name|result
operator|==
name|pfile
operator|->
name|spec_nodes
operator|.
name|n__VA_ARGS__
operator|&&
operator|!
name|pfile
operator|->
name|state
operator|.
name|va_args_ok
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_PEDWARN
argument_list|,
literal|"__VA_ARGS__ can only appear in the expansion"
literal|" of a C99 variadic macro"
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Lex a number to NUMBER starting at BUFFER->CUR - 1.  */
end_comment

begin_function
specifier|static
name|void
name|lex_number
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|cpp_string
modifier|*
name|number
parameter_list|)
block|{
specifier|const
name|uchar
modifier|*
name|cur
decl_stmt|;
specifier|const
name|uchar
modifier|*
name|base
decl_stmt|;
name|uchar
modifier|*
name|dest
decl_stmt|;
name|base
operator|=
name|pfile
operator|->
name|buffer
operator|->
name|cur
operator|-
literal|1
expr_stmt|;
do|do
block|{
name|cur
operator|=
name|pfile
operator|->
name|buffer
operator|->
name|cur
expr_stmt|;
comment|/* N.B. ISIDNUM does not include $.  */
while|while
condition|(
name|ISIDNUM
argument_list|(
operator|*
name|cur
argument_list|)
operator|||
operator|*
name|cur
operator|==
literal|'.'
operator|||
name|VALID_SIGN
argument_list|(
operator|*
name|cur
argument_list|,
name|cur
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
name|cur
operator|++
expr_stmt|;
name|pfile
operator|->
name|buffer
operator|->
name|cur
operator|=
name|cur
expr_stmt|;
block|}
do|while
condition|(
name|forms_identifier_p
argument_list|(
name|pfile
argument_list|,
name|false
argument_list|)
condition|)
do|;
name|number
operator|->
name|len
operator|=
name|cur
operator|-
name|base
expr_stmt|;
name|dest
operator|=
name|_cpp_unaligned_alloc
argument_list|(
name|pfile
argument_list|,
name|number
operator|->
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dest
argument_list|,
name|base
argument_list|,
name|number
operator|->
name|len
argument_list|)
expr_stmt|;
name|dest
index|[
name|number
operator|->
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|number
operator|->
name|text
operator|=
name|dest
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create a token of type TYPE with a literal spelling.  */
end_comment

begin_function
specifier|static
name|void
name|create_literal
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|cpp_token
modifier|*
name|token
parameter_list|,
specifier|const
name|uchar
modifier|*
name|base
parameter_list|,
name|unsigned
name|int
name|len
parameter_list|,
name|enum
name|cpp_ttype
name|type
parameter_list|)
block|{
name|uchar
modifier|*
name|dest
init|=
name|_cpp_unaligned_alloc
argument_list|(
name|pfile
argument_list|,
name|len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|dest
argument_list|,
name|base
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|dest
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|token
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|text
operator|=
name|dest
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Lexes a string, character constant, or angle-bracketed header file    name.  The stored string contains the spelling, including opening    quote and leading any leading 'L'.  It returns the type of the    literal, or CPP_OTHER if it was not properly terminated.     The spelling is NUL-terminated, but it is not guaranteed that this    is the first NUL since embedded NULs are preserved.  */
end_comment

begin_function
specifier|static
name|void
name|lex_string
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|cpp_token
modifier|*
name|token
parameter_list|,
specifier|const
name|uchar
modifier|*
name|base
parameter_list|)
block|{
name|bool
name|saw_NUL
init|=
name|false
decl_stmt|;
specifier|const
name|uchar
modifier|*
name|cur
decl_stmt|;
name|cppchar_t
name|terminator
decl_stmt|;
name|enum
name|cpp_ttype
name|type
decl_stmt|;
name|cur
operator|=
name|base
expr_stmt|;
name|terminator
operator|=
operator|*
name|cur
operator|++
expr_stmt|;
if|if
condition|(
name|terminator
operator|==
literal|'L'
condition|)
name|terminator
operator|=
operator|*
name|cur
operator|++
expr_stmt|;
if|if
condition|(
name|terminator
operator|==
literal|'\"'
condition|)
name|type
operator|=
operator|*
name|base
operator|==
literal|'L'
condition|?
name|CPP_WSTRING
else|:
name|CPP_STRING
expr_stmt|;
elseif|else
if|if
condition|(
name|terminator
operator|==
literal|'\''
condition|)
name|type
operator|=
operator|*
name|base
operator|==
literal|'L'
condition|?
name|CPP_WCHAR
else|:
name|CPP_CHAR
expr_stmt|;
else|else
name|terminator
operator|=
literal|'>'
operator|,
name|type
operator|=
name|CPP_HEADER_NAME
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|cppchar_t
name|c
init|=
operator|*
name|cur
operator|++
decl_stmt|;
comment|/* In #include-style directives, terminators are not escapable.  */
if|if
condition|(
name|c
operator|==
literal|'\\'
operator|&&
operator|!
name|pfile
operator|->
name|state
operator|.
name|angled_headers
operator|&&
operator|*
name|cur
operator|!=
literal|'\n'
condition|)
name|cur
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
name|terminator
condition|)
break|break;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|cur
operator|--
expr_stmt|;
name|type
operator|=
name|CPP_OTHER
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
name|saw_NUL
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|saw_NUL
operator|&&
operator|!
name|pfile
operator|->
name|state
operator|.
name|skipping
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_WARNING
argument_list|,
literal|"null character(s) preserved in literal"
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|buffer
operator|->
name|cur
operator|=
name|cur
expr_stmt|;
name|create_literal
argument_list|(
name|pfile
argument_list|,
name|token
argument_list|,
name|base
argument_list|,
name|cur
operator|-
name|base
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The stored comment includes the comment start and any terminator.  */
end_comment

begin_function
specifier|static
name|void
name|save_comment
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|cpp_token
modifier|*
name|token
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|from
parameter_list|,
name|cppchar_t
name|type
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|buffer
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|,
name|clen
decl_stmt|;
name|len
operator|=
name|pfile
operator|->
name|buffer
operator|->
name|cur
operator|-
name|from
operator|+
literal|1
expr_stmt|;
comment|/* + 1 for the initial '/'.  */
comment|/* C++ comments probably (not definitely) have moved past a new      line, which we don't want to save in the comment.  */
if|if
condition|(
name|is_vspace
argument_list|(
name|pfile
operator|->
name|buffer
operator|->
name|cur
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
name|len
operator|--
expr_stmt|;
comment|/* If we are currently in a directive, then we need to store all      C++ comments as C comments internally, and so we need to      allocate a little extra space in that case.       Note that the only time we encounter a directive here is      when we are saving comments in a "#define".  */
name|clen
operator|=
operator|(
name|pfile
operator|->
name|state
operator|.
name|in_directive
operator|&&
name|type
operator|==
literal|'/'
operator|)
condition|?
name|len
operator|+
literal|2
else|:
name|len
expr_stmt|;
name|buffer
operator|=
name|_cpp_unaligned_alloc
argument_list|(
name|pfile
argument_list|,
name|clen
argument_list|)
expr_stmt|;
name|token
operator|->
name|type
operator|=
name|CPP_COMMENT
expr_stmt|;
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|len
operator|=
name|clen
expr_stmt|;
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|text
operator|=
name|buffer
expr_stmt|;
name|buffer
index|[
literal|0
index|]
operator|=
literal|'/'
expr_stmt|;
name|memcpy
argument_list|(
name|buffer
operator|+
literal|1
argument_list|,
name|from
argument_list|,
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Finish conversion to a C comment, if necessary.  */
if|if
condition|(
name|pfile
operator|->
name|state
operator|.
name|in_directive
operator|&&
name|type
operator|==
literal|'/'
condition|)
block|{
name|buffer
index|[
literal|1
index|]
operator|=
literal|'*'
expr_stmt|;
name|buffer
index|[
name|clen
operator|-
literal|2
index|]
operator|=
literal|'*'
expr_stmt|;
name|buffer
index|[
name|clen
operator|-
literal|1
index|]
operator|=
literal|'/'
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Allocate COUNT tokens for RUN.  */
end_comment

begin_function
name|void
name|_cpp_init_tokenrun
parameter_list|(
name|tokenrun
modifier|*
name|run
parameter_list|,
name|unsigned
name|int
name|count
parameter_list|)
block|{
name|run
operator|->
name|base
operator|=
name|xnewvec
argument_list|(
name|cpp_token
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|run
operator|->
name|limit
operator|=
name|run
operator|->
name|base
operator|+
name|count
expr_stmt|;
name|run
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns the next tokenrun, or creates one if there is none.  */
end_comment

begin_function
specifier|static
name|tokenrun
modifier|*
name|next_tokenrun
parameter_list|(
name|tokenrun
modifier|*
name|run
parameter_list|)
block|{
if|if
condition|(
name|run
operator|->
name|next
operator|==
name|NULL
condition|)
block|{
name|run
operator|->
name|next
operator|=
name|xnew
argument_list|(
name|tokenrun
argument_list|)
expr_stmt|;
name|run
operator|->
name|next
operator|->
name|prev
operator|=
name|run
expr_stmt|;
name|_cpp_init_tokenrun
argument_list|(
name|run
operator|->
name|next
argument_list|,
literal|250
argument_list|)
expr_stmt|;
block|}
return|return
name|run
operator|->
name|next
return|;
block|}
end_function

begin_comment
comment|/* Allocate a single token that is invalidated at the same time as the    rest of the tokens on the line.  Has its line and col set to the    same as the last lexed token, so that diagnostics appear in the    right place.  */
end_comment

begin_function
name|cpp_token
modifier|*
name|_cpp_temp_token
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
name|cpp_token
modifier|*
name|old
decl_stmt|,
modifier|*
name|result
decl_stmt|;
name|old
operator|=
name|pfile
operator|->
name|cur_token
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|pfile
operator|->
name|cur_token
operator|==
name|pfile
operator|->
name|cur_run
operator|->
name|limit
condition|)
block|{
name|pfile
operator|->
name|cur_run
operator|=
name|next_tokenrun
argument_list|(
name|pfile
operator|->
name|cur_run
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|cur_token
operator|=
name|pfile
operator|->
name|cur_run
operator|->
name|base
expr_stmt|;
block|}
name|result
operator|=
name|pfile
operator|->
name|cur_token
operator|++
expr_stmt|;
name|result
operator|->
name|line
operator|=
name|old
operator|->
name|line
expr_stmt|;
name|result
operator|->
name|col
operator|=
name|old
operator|->
name|col
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Lex a token into RESULT (external interface).  Takes care of issues    like directive handling, token lookahead, multiple include    optimization and skipping.  */
end_comment

begin_function
specifier|const
name|cpp_token
modifier|*
name|_cpp_lex_token
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
name|cpp_token
modifier|*
name|result
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|pfile
operator|->
name|cur_token
operator|==
name|pfile
operator|->
name|cur_run
operator|->
name|limit
condition|)
block|{
name|pfile
operator|->
name|cur_run
operator|=
name|next_tokenrun
argument_list|(
name|pfile
operator|->
name|cur_run
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|cur_token
operator|=
name|pfile
operator|->
name|cur_run
operator|->
name|base
expr_stmt|;
block|}
if|if
condition|(
name|pfile
operator|->
name|lookaheads
condition|)
block|{
name|pfile
operator|->
name|lookaheads
operator|--
expr_stmt|;
name|result
operator|=
name|pfile
operator|->
name|cur_token
operator|++
expr_stmt|;
block|}
else|else
name|result
operator|=
name|_cpp_lex_direct
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|->
name|flags
operator|&
name|BOL
condition|)
block|{
comment|/* Is this a directive.  If _cpp_handle_directive returns 	     false, it is an assembler #.  */
if|if
condition|(
name|result
operator|->
name|type
operator|==
name|CPP_HASH
comment|/* 6.10.3 p 11: Directives in a list of macro arguments 		 gives undefined behavior.  This implementation 		 handles the directive as normal.  */
operator|&&
name|pfile
operator|->
name|state
operator|.
name|parsing_args
operator|!=
literal|1
operator|&&
name|_cpp_handle_directive
argument_list|(
name|pfile
argument_list|,
name|result
operator|->
name|flags
operator|&
name|PREV_WHITE
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|pfile
operator|->
name|cb
operator|.
name|line_change
operator|&&
operator|!
name|pfile
operator|->
name|state
operator|.
name|skipping
condition|)
name|pfile
operator|->
name|cb
operator|.
name|line_change
argument_list|(
name|pfile
argument_list|,
name|result
argument_list|,
name|pfile
operator|->
name|state
operator|.
name|parsing_args
argument_list|)
expr_stmt|;
block|}
comment|/* We don't skip tokens in directives.  */
if|if
condition|(
name|pfile
operator|->
name|state
operator|.
name|in_directive
condition|)
break|break;
comment|/* Outside a directive, invalidate controlling macros.  At file 	 EOF, _cpp_lex_direct takes care of popping the buffer, so we never 	 get here and MI optimization works.  */
name|pfile
operator|->
name|mi_valid
operator|=
name|false
expr_stmt|;
if|if
condition|(
operator|!
name|pfile
operator|->
name|state
operator|.
name|skipping
operator|||
name|result
operator|->
name|type
operator|==
name|CPP_EOF
condition|)
break|break;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Returns true if a fresh line has been loaded.  */
end_comment

begin_function
name|bool
name|_cpp_get_fresh_line
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
name|int
name|return_at_eof
decl_stmt|;
comment|/* We can't get a new line until we leave the current directive.  */
if|if
condition|(
name|pfile
operator|->
name|state
operator|.
name|in_directive
condition|)
return|return
name|false
return|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|cpp_buffer
modifier|*
name|buffer
init|=
name|pfile
operator|->
name|buffer
decl_stmt|;
if|if
condition|(
operator|!
name|buffer
operator|->
name|need_line
condition|)
return|return
name|true
return|;
if|if
condition|(
name|buffer
operator|->
name|next_line
operator|<
name|buffer
operator|->
name|rlimit
condition|)
block|{
name|_cpp_clean_line
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* First, get out of parsing arguments state.  */
if|if
condition|(
name|pfile
operator|->
name|state
operator|.
name|parsing_args
condition|)
return|return
name|false
return|;
comment|/* End of buffer.  Non-empty files should end in a newline.  */
if|if
condition|(
name|buffer
operator|->
name|buf
operator|!=
name|buffer
operator|->
name|rlimit
operator|&&
name|buffer
operator|->
name|next_line
operator|>
name|buffer
operator|->
name|rlimit
operator|&&
operator|!
name|buffer
operator|->
name|from_stage3
condition|)
block|{
comment|/* Only warn once.  */
name|buffer
operator|->
name|next_line
operator|=
name|buffer
operator|->
name|rlimit
expr_stmt|;
name|cpp_error_with_line
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_PEDWARN
argument_list|,
name|pfile
operator|->
name|line
operator|-
literal|1
argument_list|,
name|CPP_BUF_COLUMN
argument_list|(
name|buffer
argument_list|,
name|buffer
operator|->
name|cur
argument_list|)
argument_list|,
literal|"no newline at end of file"
argument_list|)
expr_stmt|;
block|}
name|return_at_eof
operator|=
name|buffer
operator|->
name|return_at_eof
expr_stmt|;
name|_cpp_pop_buffer
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfile
operator|->
name|buffer
operator|==
name|NULL
operator|||
name|return_at_eof
condition|)
return|return
name|false
return|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|IF_NEXT_IS
parameter_list|(
name|CHAR
parameter_list|,
name|THEN_TYPE
parameter_list|,
name|ELSE_TYPE
parameter_list|)
define|\
value|do							\     {							\       result->type = ELSE_TYPE;				\       if (*buffer->cur == CHAR)				\ 	buffer->cur++, result->type = THEN_TYPE;	\     }							\   while (0)
end_define

begin_comment
comment|/* Lex a token into pfile->cur_token, which is also incremented, to    get diagnostics pointing to the correct location.     Does not handle issues such as token lookahead, multiple-include    optimization, directives, skipping etc.  This function is only    suitable for use by _cpp_lex_token, and in special cases like    lex_expansion_token which doesn't care for any of these issues.     When meeting a newline, returns CPP_EOF if parsing a directive,    otherwise returns to the start of the token buffer if permissible.    Returns the location of the lexed token.  */
end_comment

begin_function
name|cpp_token
modifier|*
name|_cpp_lex_direct
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
name|cppchar_t
name|c
decl_stmt|;
name|cpp_buffer
modifier|*
name|buffer
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|comment_start
decl_stmt|;
name|cpp_token
modifier|*
name|result
init|=
name|pfile
operator|->
name|cur_token
operator|++
decl_stmt|;
name|fresh_line
label|:
name|result
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|buffer
operator|=
name|pfile
operator|->
name|buffer
expr_stmt|;
if|if
condition|(
name|buffer
operator|->
name|need_line
condition|)
block|{
if|if
condition|(
operator|!
name|_cpp_get_fresh_line
argument_list|(
name|pfile
argument_list|)
condition|)
block|{
name|result
operator|->
name|type
operator|=
name|CPP_EOF
expr_stmt|;
if|if
condition|(
operator|!
name|pfile
operator|->
name|state
operator|.
name|in_directive
condition|)
block|{
comment|/* Tell the compiler the line number of the EOF token.  */
name|result
operator|->
name|line
operator|=
name|pfile
operator|->
name|line
expr_stmt|;
name|result
operator|->
name|flags
operator|=
name|BOL
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
if|if
condition|(
operator|!
name|pfile
operator|->
name|keep_tokens
condition|)
block|{
name|pfile
operator|->
name|cur_run
operator|=
operator|&
name|pfile
operator|->
name|base_run
expr_stmt|;
name|result
operator|=
name|pfile
operator|->
name|base_run
operator|.
name|base
expr_stmt|;
name|pfile
operator|->
name|cur_token
operator|=
name|result
operator|+
literal|1
expr_stmt|;
block|}
name|result
operator|->
name|flags
operator|=
name|BOL
expr_stmt|;
if|if
condition|(
name|pfile
operator|->
name|state
operator|.
name|parsing_args
operator|==
literal|2
condition|)
name|result
operator|->
name|flags
operator||=
name|PREV_WHITE
expr_stmt|;
block|}
name|buffer
operator|=
name|pfile
operator|->
name|buffer
expr_stmt|;
name|update_tokens_line
label|:
name|result
operator|->
name|line
operator|=
name|pfile
operator|->
name|line
expr_stmt|;
name|skipped_white
label|:
if|if
condition|(
name|buffer
operator|->
name|cur
operator|>=
name|buffer
operator|->
name|notes
index|[
name|buffer
operator|->
name|cur_note
index|]
operator|.
name|pos
operator|&&
operator|!
name|pfile
operator|->
name|overlaid_buffer
condition|)
block|{
name|_cpp_process_line_notes
argument_list|(
name|pfile
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|result
operator|->
name|line
operator|=
name|pfile
operator|->
name|line
expr_stmt|;
block|}
name|c
operator|=
operator|*
name|buffer
operator|->
name|cur
operator|++
expr_stmt|;
name|result
operator|->
name|col
operator|=
name|CPP_BUF_COLUMN
argument_list|(
name|buffer
argument_list|,
name|buffer
operator|->
name|cur
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\f'
case|:
case|case
literal|'\v'
case|:
case|case
literal|'\0'
case|:
name|result
operator|->
name|flags
operator||=
name|PREV_WHITE
expr_stmt|;
name|skip_whitespace
argument_list|(
name|pfile
argument_list|,
name|c
argument_list|)
expr_stmt|;
goto|goto
name|skipped_white
goto|;
case|case
literal|'\n'
case|:
name|pfile
operator|->
name|line
operator|++
expr_stmt|;
name|buffer
operator|->
name|need_line
operator|=
name|true
expr_stmt|;
goto|goto
name|fresh_line
goto|;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|result
operator|->
name|type
operator|=
name|CPP_NUMBER
expr_stmt|;
name|lex_number
argument_list|(
name|pfile
argument_list|,
operator|&
name|result
operator|->
name|val
operator|.
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
comment|/* 'L' may introduce wide characters or strings.  */
if|if
condition|(
operator|*
name|buffer
operator|->
name|cur
operator|==
literal|'\''
operator|||
operator|*
name|buffer
operator|->
name|cur
operator|==
literal|'"'
condition|)
block|{
name|lex_string
argument_list|(
name|pfile
argument_list|,
name|result
argument_list|,
name|buffer
operator|->
name|cur
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Fall through.  */
case|case
literal|'_'
case|:
case|case
literal|'a'
case|:
case|case
literal|'b'
case|:
case|case
literal|'c'
case|:
case|case
literal|'d'
case|:
case|case
literal|'e'
case|:
case|case
literal|'f'
case|:
case|case
literal|'g'
case|:
case|case
literal|'h'
case|:
case|case
literal|'i'
case|:
case|case
literal|'j'
case|:
case|case
literal|'k'
case|:
case|case
literal|'l'
case|:
case|case
literal|'m'
case|:
case|case
literal|'n'
case|:
case|case
literal|'o'
case|:
case|case
literal|'p'
case|:
case|case
literal|'q'
case|:
case|case
literal|'r'
case|:
case|case
literal|'s'
case|:
case|case
literal|'t'
case|:
case|case
literal|'u'
case|:
case|case
literal|'v'
case|:
case|case
literal|'w'
case|:
case|case
literal|'x'
case|:
case|case
literal|'y'
case|:
case|case
literal|'z'
case|:
case|case
literal|'A'
case|:
case|case
literal|'B'
case|:
case|case
literal|'C'
case|:
case|case
literal|'D'
case|:
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
case|case
literal|'G'
case|:
case|case
literal|'H'
case|:
case|case
literal|'I'
case|:
case|case
literal|'J'
case|:
case|case
literal|'K'
case|:
case|case
literal|'M'
case|:
case|case
literal|'N'
case|:
case|case
literal|'O'
case|:
case|case
literal|'P'
case|:
case|case
literal|'Q'
case|:
case|case
literal|'R'
case|:
case|case
literal|'S'
case|:
case|case
literal|'T'
case|:
case|case
literal|'U'
case|:
case|case
literal|'V'
case|:
case|case
literal|'W'
case|:
case|case
literal|'X'
case|:
case|case
literal|'Y'
case|:
case|case
literal|'Z'
case|:
name|result
operator|->
name|type
operator|=
name|CPP_NAME
expr_stmt|;
name|result
operator|->
name|val
operator|.
name|node
operator|=
name|lex_identifier
argument_list|(
name|pfile
argument_list|,
name|buffer
operator|->
name|cur
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Convert named operators to their proper types.  */
if|if
condition|(
name|result
operator|->
name|val
operator|.
name|node
operator|->
name|flags
operator|&
name|NODE_OPERATOR
condition|)
block|{
name|result
operator|->
name|flags
operator||=
name|NAMED_OP
expr_stmt|;
name|result
operator|->
name|type
operator|=
name|result
operator|->
name|val
operator|.
name|node
operator|->
name|directive_index
expr_stmt|;
block|}
break|break;
case|case
literal|'\''
case|:
case|case
literal|'"'
case|:
name|lex_string
argument_list|(
name|pfile
argument_list|,
name|result
argument_list|,
name|buffer
operator|->
name|cur
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
comment|/* A potential block or line comment.  */
name|comment_start
operator|=
name|buffer
operator|->
name|cur
expr_stmt|;
name|c
operator|=
operator|*
name|buffer
operator|->
name|cur
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'*'
condition|)
block|{
if|if
condition|(
name|_cpp_skip_block_comment
argument_list|(
name|pfile
argument_list|)
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"unterminated comment"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'/'
operator|&&
operator|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|cplusplus_comments
argument_list|)
operator|||
name|CPP_IN_SYSTEM_HEADER
argument_list|(
name|pfile
argument_list|)
operator|)
condition|)
block|{
comment|/* Warn about comments only if pedantically GNUC89, and not 	     in system headers.  */
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|lang
argument_list|)
operator|==
name|CLK_GNUC89
operator|&&
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
operator|&&
operator|!
name|buffer
operator|->
name|warned_cplusplus_comments
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_PEDWARN
argument_list|,
literal|"C++ style comments are not allowed in ISO C90"
argument_list|)
expr_stmt|;
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_PEDWARN
argument_list|,
literal|"(this will be reported only once per input file)"
argument_list|)
expr_stmt|;
name|buffer
operator|->
name|warned_cplusplus_comments
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|skip_line_comment
argument_list|(
name|pfile
argument_list|)
operator|&&
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|warn_comments
argument_list|)
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_WARNING
argument_list|,
literal|"multi-line comment"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'='
condition|)
block|{
name|buffer
operator|->
name|cur
operator|++
expr_stmt|;
name|result
operator|->
name|type
operator|=
name|CPP_DIV_EQ
expr_stmt|;
break|break;
block|}
else|else
block|{
name|result
operator|->
name|type
operator|=
name|CPP_DIV
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|pfile
operator|->
name|state
operator|.
name|save_comments
condition|)
block|{
name|result
operator|->
name|flags
operator||=
name|PREV_WHITE
expr_stmt|;
goto|goto
name|update_tokens_line
goto|;
block|}
comment|/* Save the comment as a token in its own right.  */
name|save_comment
argument_list|(
name|pfile
argument_list|,
name|result
argument_list|,
name|comment_start
argument_list|,
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
if|if
condition|(
name|pfile
operator|->
name|state
operator|.
name|angled_headers
condition|)
block|{
name|lex_string
argument_list|(
name|pfile
argument_list|,
name|result
argument_list|,
name|buffer
operator|->
name|cur
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
name|result
operator|->
name|type
operator|=
name|CPP_LESS
expr_stmt|;
if|if
condition|(
operator|*
name|buffer
operator|->
name|cur
operator|==
literal|'='
condition|)
name|buffer
operator|->
name|cur
operator|++
operator|,
name|result
operator|->
name|type
operator|=
name|CPP_LESS_EQ
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|buffer
operator|->
name|cur
operator|==
literal|'<'
condition|)
block|{
name|buffer
operator|->
name|cur
operator|++
expr_stmt|;
name|IF_NEXT_IS
argument_list|(
literal|'='
argument_list|,
name|CPP_LSHIFT_EQ
argument_list|,
name|CPP_LSHIFT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|buffer
operator|->
name|cur
operator|==
literal|'?'
operator|&&
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|cplusplus
argument_list|)
condition|)
block|{
name|buffer
operator|->
name|cur
operator|++
expr_stmt|;
name|IF_NEXT_IS
argument_list|(
literal|'='
argument_list|,
name|CPP_MIN_EQ
argument_list|,
name|CPP_MIN
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|digraphs
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|buffer
operator|->
name|cur
operator|==
literal|':'
condition|)
block|{
name|buffer
operator|->
name|cur
operator|++
expr_stmt|;
name|result
operator|->
name|flags
operator||=
name|DIGRAPH
expr_stmt|;
name|result
operator|->
name|type
operator|=
name|CPP_OPEN_SQUARE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|buffer
operator|->
name|cur
operator|==
literal|'%'
condition|)
block|{
name|buffer
operator|->
name|cur
operator|++
expr_stmt|;
name|result
operator|->
name|flags
operator||=
name|DIGRAPH
expr_stmt|;
name|result
operator|->
name|type
operator|=
name|CPP_OPEN_BRACE
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'>'
case|:
name|result
operator|->
name|type
operator|=
name|CPP_GREATER
expr_stmt|;
if|if
condition|(
operator|*
name|buffer
operator|->
name|cur
operator|==
literal|'='
condition|)
name|buffer
operator|->
name|cur
operator|++
operator|,
name|result
operator|->
name|type
operator|=
name|CPP_GREATER_EQ
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|buffer
operator|->
name|cur
operator|==
literal|'>'
condition|)
block|{
name|buffer
operator|->
name|cur
operator|++
expr_stmt|;
name|IF_NEXT_IS
argument_list|(
literal|'='
argument_list|,
name|CPP_RSHIFT_EQ
argument_list|,
name|CPP_RSHIFT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|buffer
operator|->
name|cur
operator|==
literal|'?'
operator|&&
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|cplusplus
argument_list|)
condition|)
block|{
name|buffer
operator|->
name|cur
operator|++
expr_stmt|;
name|IF_NEXT_IS
argument_list|(
literal|'='
argument_list|,
name|CPP_MAX_EQ
argument_list|,
name|CPP_MAX
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'%'
case|:
name|result
operator|->
name|type
operator|=
name|CPP_MOD
expr_stmt|;
if|if
condition|(
operator|*
name|buffer
operator|->
name|cur
operator|==
literal|'='
condition|)
name|buffer
operator|->
name|cur
operator|++
operator|,
name|result
operator|->
name|type
operator|=
name|CPP_MOD_EQ
expr_stmt|;
elseif|else
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|digraphs
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|buffer
operator|->
name|cur
operator|==
literal|':'
condition|)
block|{
name|buffer
operator|->
name|cur
operator|++
expr_stmt|;
name|result
operator|->
name|flags
operator||=
name|DIGRAPH
expr_stmt|;
name|result
operator|->
name|type
operator|=
name|CPP_HASH
expr_stmt|;
if|if
condition|(
operator|*
name|buffer
operator|->
name|cur
operator|==
literal|'%'
operator|&&
name|buffer
operator|->
name|cur
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
name|buffer
operator|->
name|cur
operator|+=
literal|2
operator|,
name|result
operator|->
name|type
operator|=
name|CPP_PASTE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|buffer
operator|->
name|cur
operator|==
literal|'>'
condition|)
block|{
name|buffer
operator|->
name|cur
operator|++
expr_stmt|;
name|result
operator|->
name|flags
operator||=
name|DIGRAPH
expr_stmt|;
name|result
operator|->
name|type
operator|=
name|CPP_CLOSE_BRACE
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'.'
case|:
name|result
operator|->
name|type
operator|=
name|CPP_DOT
expr_stmt|;
if|if
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|buffer
operator|->
name|cur
argument_list|)
condition|)
block|{
name|result
operator|->
name|type
operator|=
name|CPP_NUMBER
expr_stmt|;
name|lex_number
argument_list|(
name|pfile
argument_list|,
operator|&
name|result
operator|->
name|val
operator|.
name|str
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|buffer
operator|->
name|cur
operator|==
literal|'.'
operator|&&
name|buffer
operator|->
name|cur
index|[
literal|1
index|]
operator|==
literal|'.'
condition|)
name|buffer
operator|->
name|cur
operator|+=
literal|2
operator|,
name|result
operator|->
name|type
operator|=
name|CPP_ELLIPSIS
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|buffer
operator|->
name|cur
operator|==
literal|'*'
operator|&&
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|cplusplus
argument_list|)
condition|)
name|buffer
operator|->
name|cur
operator|++
operator|,
name|result
operator|->
name|type
operator|=
name|CPP_DOT_STAR
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
name|result
operator|->
name|type
operator|=
name|CPP_PLUS
expr_stmt|;
if|if
condition|(
operator|*
name|buffer
operator|->
name|cur
operator|==
literal|'+'
condition|)
name|buffer
operator|->
name|cur
operator|++
operator|,
name|result
operator|->
name|type
operator|=
name|CPP_PLUS_PLUS
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|buffer
operator|->
name|cur
operator|==
literal|'='
condition|)
name|buffer
operator|->
name|cur
operator|++
operator|,
name|result
operator|->
name|type
operator|=
name|CPP_PLUS_EQ
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|result
operator|->
name|type
operator|=
name|CPP_MINUS
expr_stmt|;
if|if
condition|(
operator|*
name|buffer
operator|->
name|cur
operator|==
literal|'>'
condition|)
block|{
name|buffer
operator|->
name|cur
operator|++
expr_stmt|;
name|result
operator|->
name|type
operator|=
name|CPP_DEREF
expr_stmt|;
if|if
condition|(
operator|*
name|buffer
operator|->
name|cur
operator|==
literal|'*'
operator|&&
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|cplusplus
argument_list|)
condition|)
name|buffer
operator|->
name|cur
operator|++
operator|,
name|result
operator|->
name|type
operator|=
name|CPP_DEREF_STAR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|buffer
operator|->
name|cur
operator|==
literal|'-'
condition|)
name|buffer
operator|->
name|cur
operator|++
operator|,
name|result
operator|->
name|type
operator|=
name|CPP_MINUS_MINUS
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|buffer
operator|->
name|cur
operator|==
literal|'='
condition|)
name|buffer
operator|->
name|cur
operator|++
operator|,
name|result
operator|->
name|type
operator|=
name|CPP_MINUS_EQ
expr_stmt|;
break|break;
case|case
literal|'&'
case|:
name|result
operator|->
name|type
operator|=
name|CPP_AND
expr_stmt|;
if|if
condition|(
operator|*
name|buffer
operator|->
name|cur
operator|==
literal|'&'
condition|)
name|buffer
operator|->
name|cur
operator|++
operator|,
name|result
operator|->
name|type
operator|=
name|CPP_AND_AND
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|buffer
operator|->
name|cur
operator|==
literal|'='
condition|)
name|buffer
operator|->
name|cur
operator|++
operator|,
name|result
operator|->
name|type
operator|=
name|CPP_AND_EQ
expr_stmt|;
break|break;
case|case
literal|'|'
case|:
name|result
operator|->
name|type
operator|=
name|CPP_OR
expr_stmt|;
if|if
condition|(
operator|*
name|buffer
operator|->
name|cur
operator|==
literal|'|'
condition|)
name|buffer
operator|->
name|cur
operator|++
operator|,
name|result
operator|->
name|type
operator|=
name|CPP_OR_OR
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|buffer
operator|->
name|cur
operator|==
literal|'='
condition|)
name|buffer
operator|->
name|cur
operator|++
operator|,
name|result
operator|->
name|type
operator|=
name|CPP_OR_EQ
expr_stmt|;
break|break;
case|case
literal|':'
case|:
name|result
operator|->
name|type
operator|=
name|CPP_COLON
expr_stmt|;
if|if
condition|(
operator|*
name|buffer
operator|->
name|cur
operator|==
literal|':'
operator|&&
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|cplusplus
argument_list|)
condition|)
name|buffer
operator|->
name|cur
operator|++
operator|,
name|result
operator|->
name|type
operator|=
name|CPP_SCOPE
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|buffer
operator|->
name|cur
operator|==
literal|'>'
operator|&&
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|digraphs
argument_list|)
condition|)
block|{
name|buffer
operator|->
name|cur
operator|++
expr_stmt|;
name|result
operator|->
name|flags
operator||=
name|DIGRAPH
expr_stmt|;
name|result
operator|->
name|type
operator|=
name|CPP_CLOSE_SQUARE
expr_stmt|;
block|}
break|break;
case|case
literal|'*'
case|:
name|IF_NEXT_IS
argument_list|(
literal|'='
argument_list|,
name|CPP_MULT_EQ
argument_list|,
name|CPP_MULT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'='
case|:
name|IF_NEXT_IS
argument_list|(
literal|'='
argument_list|,
name|CPP_EQ_EQ
argument_list|,
name|CPP_EQ
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
name|IF_NEXT_IS
argument_list|(
literal|'='
argument_list|,
name|CPP_NOT_EQ
argument_list|,
name|CPP_NOT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'^'
case|:
name|IF_NEXT_IS
argument_list|(
literal|'='
argument_list|,
name|CPP_XOR_EQ
argument_list|,
name|CPP_XOR
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
name|IF_NEXT_IS
argument_list|(
literal|'#'
argument_list|,
name|CPP_PASTE
argument_list|,
name|CPP_HASH
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
name|result
operator|->
name|type
operator|=
name|CPP_QUERY
expr_stmt|;
break|break;
case|case
literal|'~'
case|:
name|result
operator|->
name|type
operator|=
name|CPP_COMPL
expr_stmt|;
break|break;
case|case
literal|','
case|:
name|result
operator|->
name|type
operator|=
name|CPP_COMMA
expr_stmt|;
break|break;
case|case
literal|'('
case|:
name|result
operator|->
name|type
operator|=
name|CPP_OPEN_PAREN
expr_stmt|;
break|break;
case|case
literal|')'
case|:
name|result
operator|->
name|type
operator|=
name|CPP_CLOSE_PAREN
expr_stmt|;
break|break;
case|case
literal|'['
case|:
name|result
operator|->
name|type
operator|=
name|CPP_OPEN_SQUARE
expr_stmt|;
break|break;
case|case
literal|']'
case|:
name|result
operator|->
name|type
operator|=
name|CPP_CLOSE_SQUARE
expr_stmt|;
break|break;
case|case
literal|'{'
case|:
name|result
operator|->
name|type
operator|=
name|CPP_OPEN_BRACE
expr_stmt|;
break|break;
case|case
literal|'}'
case|:
name|result
operator|->
name|type
operator|=
name|CPP_CLOSE_BRACE
expr_stmt|;
break|break;
case|case
literal|';'
case|:
name|result
operator|->
name|type
operator|=
name|CPP_SEMICOLON
expr_stmt|;
break|break;
comment|/* @ is a punctuator in Objective-C.  */
case|case
literal|'@'
case|:
name|result
operator|->
name|type
operator|=
name|CPP_ATSIGN
expr_stmt|;
break|break;
case|case
literal|'$'
case|:
case|case
literal|'\\'
case|:
block|{
specifier|const
name|uchar
modifier|*
name|base
init|=
operator|--
name|buffer
operator|->
name|cur
decl_stmt|;
if|if
condition|(
name|forms_identifier_p
argument_list|(
name|pfile
argument_list|,
name|true
argument_list|)
condition|)
block|{
name|result
operator|->
name|type
operator|=
name|CPP_NAME
expr_stmt|;
name|result
operator|->
name|val
operator|.
name|node
operator|=
name|lex_identifier
argument_list|(
name|pfile
argument_list|,
name|base
argument_list|)
expr_stmt|;
break|break;
block|}
name|buffer
operator|->
name|cur
operator|++
expr_stmt|;
block|}
default|default:
name|create_literal
argument_list|(
name|pfile
argument_list|,
name|result
argument_list|,
name|buffer
operator|->
name|cur
operator|-
literal|1
argument_list|,
literal|1
argument_list|,
name|CPP_OTHER
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* An upper bound on the number of bytes needed to spell TOKEN.    Does not include preceding whitespace.  */
end_comment

begin_function
name|unsigned
name|int
name|cpp_token_len
parameter_list|(
specifier|const
name|cpp_token
modifier|*
name|token
parameter_list|)
block|{
name|unsigned
name|int
name|len
decl_stmt|;
switch|switch
condition|(
name|TOKEN_SPELL
argument_list|(
name|token
argument_list|)
condition|)
block|{
default|default:
name|len
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|SPELL_LITERAL
case|:
name|len
operator|=
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|len
expr_stmt|;
break|break;
case|case
name|SPELL_IDENT
case|:
name|len
operator|=
name|NODE_LEN
argument_list|(
name|token
operator|->
name|val
operator|.
name|node
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/* Write the spelling of a token TOKEN to BUFFER.  The buffer must    already contain the enough space to hold the token's spelling.    Returns a pointer to the character after the last character written.    FIXME: Would be nice if we didn't need the PFILE argument.  */
end_comment

begin_function
name|unsigned
name|char
modifier|*
name|cpp_spell_token
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
specifier|const
name|cpp_token
modifier|*
name|token
parameter_list|,
name|unsigned
name|char
modifier|*
name|buffer
parameter_list|)
block|{
switch|switch
condition|(
name|TOKEN_SPELL
argument_list|(
name|token
argument_list|)
condition|)
block|{
case|case
name|SPELL_OPERATOR
case|:
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|spelling
decl_stmt|;
name|unsigned
name|char
name|c
decl_stmt|;
if|if
condition|(
name|token
operator|->
name|flags
operator|&
name|DIGRAPH
condition|)
name|spelling
operator|=
name|digraph_spellings
index|[
operator|(
name|int
operator|)
name|token
operator|->
name|type
operator|-
operator|(
name|int
operator|)
name|CPP_FIRST_DIGRAPH
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|token
operator|->
name|flags
operator|&
name|NAMED_OP
condition|)
goto|goto
name|spell_ident
goto|;
else|else
name|spelling
operator|=
name|TOKEN_NAME
argument_list|(
name|token
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|spelling
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
operator|*
name|buffer
operator|++
operator|=
name|c
expr_stmt|;
block|}
break|break;
name|spell_ident
label|:
case|case
name|SPELL_IDENT
case|:
name|memcpy
argument_list|(
name|buffer
argument_list|,
name|NODE_NAME
argument_list|(
name|token
operator|->
name|val
operator|.
name|node
argument_list|)
argument_list|,
name|NODE_LEN
argument_list|(
name|token
operator|->
name|val
operator|.
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|buffer
operator|+=
name|NODE_LEN
argument_list|(
name|token
operator|->
name|val
operator|.
name|node
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPELL_LITERAL
case|:
name|memcpy
argument_list|(
name|buffer
argument_list|,
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|text
argument_list|,
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|len
argument_list|)
expr_stmt|;
name|buffer
operator|+=
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|len
expr_stmt|;
break|break;
case|case
name|SPELL_NONE
case|:
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ICE
argument_list|,
literal|"unspellable token %s"
argument_list|,
name|TOKEN_NAME
argument_list|(
name|token
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|buffer
return|;
block|}
end_function

begin_comment
comment|/* Returns TOKEN spelt as a null-terminated string.  The string is    freed when the reader is destroyed.  Useful for diagnostics.  */
end_comment

begin_function
name|unsigned
name|char
modifier|*
name|cpp_token_as_text
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
specifier|const
name|cpp_token
modifier|*
name|token
parameter_list|)
block|{
name|unsigned
name|int
name|len
init|=
name|cpp_token_len
argument_list|(
name|token
argument_list|)
operator|+
literal|1
decl_stmt|;
name|unsigned
name|char
modifier|*
name|start
init|=
name|_cpp_unaligned_alloc
argument_list|(
name|pfile
argument_list|,
name|len
argument_list|)
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|end
operator|=
name|cpp_spell_token
argument_list|(
name|pfile
argument_list|,
name|token
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|end
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|start
return|;
block|}
end_function

begin_comment
comment|/* Used by C front ends, which really should move to using    cpp_token_as_text.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|cpp_type2name
parameter_list|(
name|enum
name|cpp_ttype
name|type
parameter_list|)
block|{
return|return
operator|(
specifier|const
name|char
operator|*
operator|)
name|token_spellings
index|[
name|type
index|]
operator|.
name|name
return|;
block|}
end_function

begin_comment
comment|/* Writes the spelling of token to FP, without any preceding space.    Separated from cpp_spell_token for efficiency - to avoid stdio    double-buffering.  */
end_comment

begin_function
name|void
name|cpp_output_token
parameter_list|(
specifier|const
name|cpp_token
modifier|*
name|token
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
switch|switch
condition|(
name|TOKEN_SPELL
argument_list|(
name|token
argument_list|)
condition|)
block|{
case|case
name|SPELL_OPERATOR
case|:
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|spelling
decl_stmt|;
name|int
name|c
decl_stmt|;
if|if
condition|(
name|token
operator|->
name|flags
operator|&
name|DIGRAPH
condition|)
name|spelling
operator|=
name|digraph_spellings
index|[
operator|(
name|int
operator|)
name|token
operator|->
name|type
operator|-
operator|(
name|int
operator|)
name|CPP_FIRST_DIGRAPH
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|token
operator|->
name|flags
operator|&
name|NAMED_OP
condition|)
goto|goto
name|spell_ident
goto|;
else|else
name|spelling
operator|=
name|TOKEN_NAME
argument_list|(
name|token
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
name|spelling
expr_stmt|;
do|do
name|putc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
do|while
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|spelling
operator|)
operator|!=
literal|'\0'
condition|)
do|;
block|}
break|break;
name|spell_ident
label|:
case|case
name|SPELL_IDENT
case|:
name|fwrite
argument_list|(
name|NODE_NAME
argument_list|(
name|token
operator|->
name|val
operator|.
name|node
argument_list|)
argument_list|,
literal|1
argument_list|,
name|NODE_LEN
argument_list|(
name|token
operator|->
name|val
operator|.
name|node
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPELL_LITERAL
case|:
name|fwrite
argument_list|(
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|text
argument_list|,
literal|1
argument_list|,
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|len
argument_list|,
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPELL_NONE
case|:
comment|/* An error, most probably.  */
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Compare two tokens.  */
end_comment

begin_function
name|int
name|_cpp_equiv_tokens
parameter_list|(
specifier|const
name|cpp_token
modifier|*
name|a
parameter_list|,
specifier|const
name|cpp_token
modifier|*
name|b
parameter_list|)
block|{
if|if
condition|(
name|a
operator|->
name|type
operator|==
name|b
operator|->
name|type
operator|&&
name|a
operator|->
name|flags
operator|==
name|b
operator|->
name|flags
condition|)
switch|switch
condition|(
name|TOKEN_SPELL
argument_list|(
name|a
argument_list|)
condition|)
block|{
default|default:
comment|/* Keep compiler happy.  */
case|case
name|SPELL_OPERATOR
case|:
return|return
literal|1
return|;
case|case
name|SPELL_NONE
case|:
return|return
operator|(
name|a
operator|->
name|type
operator|!=
name|CPP_MACRO_ARG
operator|||
name|a
operator|->
name|val
operator|.
name|arg_no
operator|==
name|b
operator|->
name|val
operator|.
name|arg_no
operator|)
return|;
case|case
name|SPELL_IDENT
case|:
return|return
name|a
operator|->
name|val
operator|.
name|node
operator|==
name|b
operator|->
name|val
operator|.
name|node
return|;
case|case
name|SPELL_LITERAL
case|:
return|return
operator|(
name|a
operator|->
name|val
operator|.
name|str
operator|.
name|len
operator|==
name|b
operator|->
name|val
operator|.
name|str
operator|.
name|len
operator|&&
operator|!
name|memcmp
argument_list|(
name|a
operator|->
name|val
operator|.
name|str
operator|.
name|text
argument_list|,
name|b
operator|->
name|val
operator|.
name|str
operator|.
name|text
argument_list|,
name|a
operator|->
name|val
operator|.
name|str
operator|.
name|len
argument_list|)
operator|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if a space should be inserted to avoid an    accidental token paste for output.  For simplicity, it is    conservative, and occasionally advises a space where one is not    needed, e.g. "." and ".2".  */
end_comment

begin_function
name|int
name|cpp_avoid_paste
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
specifier|const
name|cpp_token
modifier|*
name|token1
parameter_list|,
specifier|const
name|cpp_token
modifier|*
name|token2
parameter_list|)
block|{
name|enum
name|cpp_ttype
name|a
init|=
name|token1
operator|->
name|type
decl_stmt|,
name|b
init|=
name|token2
operator|->
name|type
decl_stmt|;
name|cppchar_t
name|c
decl_stmt|;
if|if
condition|(
name|token1
operator|->
name|flags
operator|&
name|NAMED_OP
condition|)
name|a
operator|=
name|CPP_NAME
expr_stmt|;
if|if
condition|(
name|token2
operator|->
name|flags
operator|&
name|NAMED_OP
condition|)
name|b
operator|=
name|CPP_NAME
expr_stmt|;
name|c
operator|=
name|EOF
expr_stmt|;
if|if
condition|(
name|token2
operator|->
name|flags
operator|&
name|DIGRAPH
condition|)
name|c
operator|=
name|digraph_spellings
index|[
operator|(
name|int
operator|)
name|b
operator|-
operator|(
name|int
operator|)
name|CPP_FIRST_DIGRAPH
index|]
index|[
literal|0
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|token_spellings
index|[
name|b
index|]
operator|.
name|category
operator|==
name|SPELL_OPERATOR
condition|)
name|c
operator|=
name|token_spellings
index|[
name|b
index|]
operator|.
name|name
index|[
literal|0
index|]
expr_stmt|;
comment|/* Quickly get everything that can paste with an '='.  */
if|if
condition|(
operator|(
name|int
operator|)
name|a
operator|<=
operator|(
name|int
operator|)
name|CPP_LAST_EQ
operator|&&
name|c
operator|==
literal|'='
condition|)
return|return
literal|1
return|;
switch|switch
condition|(
name|a
condition|)
block|{
case|case
name|CPP_GREATER
case|:
return|return
name|c
operator|==
literal|'>'
operator|||
name|c
operator|==
literal|'?'
return|;
case|case
name|CPP_LESS
case|:
return|return
name|c
operator|==
literal|'<'
operator|||
name|c
operator|==
literal|'?'
operator|||
name|c
operator|==
literal|'%'
operator|||
name|c
operator|==
literal|':'
return|;
case|case
name|CPP_PLUS
case|:
return|return
name|c
operator|==
literal|'+'
return|;
case|case
name|CPP_MINUS
case|:
return|return
name|c
operator|==
literal|'-'
operator|||
name|c
operator|==
literal|'>'
return|;
case|case
name|CPP_DIV
case|:
return|return
name|c
operator|==
literal|'/'
operator|||
name|c
operator|==
literal|'*'
return|;
comment|/* Comments.  */
case|case
name|CPP_MOD
case|:
return|return
name|c
operator|==
literal|':'
operator|||
name|c
operator|==
literal|'>'
return|;
case|case
name|CPP_AND
case|:
return|return
name|c
operator|==
literal|'&'
return|;
case|case
name|CPP_OR
case|:
return|return
name|c
operator|==
literal|'|'
return|;
case|case
name|CPP_COLON
case|:
return|return
name|c
operator|==
literal|':'
operator|||
name|c
operator|==
literal|'>'
return|;
case|case
name|CPP_DEREF
case|:
return|return
name|c
operator|==
literal|'*'
return|;
case|case
name|CPP_DOT
case|:
return|return
name|c
operator|==
literal|'.'
operator|||
name|c
operator|==
literal|'%'
operator|||
name|b
operator|==
name|CPP_NUMBER
return|;
case|case
name|CPP_HASH
case|:
return|return
name|c
operator|==
literal|'#'
operator|||
name|c
operator|==
literal|'%'
return|;
comment|/* Digraph form.  */
case|case
name|CPP_NAME
case|:
return|return
operator|(
operator|(
name|b
operator|==
name|CPP_NUMBER
operator|&&
name|name_p
argument_list|(
name|pfile
argument_list|,
operator|&
name|token2
operator|->
name|val
operator|.
name|str
argument_list|)
operator|)
operator|||
name|b
operator|==
name|CPP_NAME
operator|||
name|b
operator|==
name|CPP_CHAR
operator|||
name|b
operator|==
name|CPP_STRING
operator|)
return|;
comment|/* L */
case|case
name|CPP_NUMBER
case|:
return|return
operator|(
name|b
operator|==
name|CPP_NUMBER
operator|||
name|b
operator|==
name|CPP_NAME
operator|||
name|c
operator|==
literal|'.'
operator|||
name|c
operator|==
literal|'+'
operator|||
name|c
operator|==
literal|'-'
operator|)
return|;
comment|/* UCNs */
case|case
name|CPP_OTHER
case|:
return|return
operator|(
operator|(
name|token1
operator|->
name|val
operator|.
name|str
operator|.
name|text
index|[
literal|0
index|]
operator|==
literal|'\\'
operator|&&
name|b
operator|==
name|CPP_NAME
operator|)
operator|||
operator|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|objc
argument_list|)
operator|&&
name|token1
operator|->
name|val
operator|.
name|str
operator|.
name|text
index|[
literal|0
index|]
operator|==
literal|'@'
operator|&&
operator|(
name|b
operator|==
name|CPP_NAME
operator|||
name|b
operator|==
name|CPP_STRING
operator|)
operator|)
operator|)
return|;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Output all the remaining tokens on the current line, and a newline    character, to FP.  Leading whitespace is removed.  If there are    macros, special token padding is not performed.  */
end_comment

begin_function
name|void
name|cpp_output_line
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
specifier|const
name|cpp_token
modifier|*
name|token
decl_stmt|;
name|token
operator|=
name|cpp_get_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
while|while
condition|(
name|token
operator|->
name|type
operator|!=
name|CPP_EOF
condition|)
block|{
name|cpp_output_token
argument_list|(
name|token
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|token
operator|=
name|cpp_get_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|flags
operator|&
name|PREV_WHITE
condition|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Memory buffers.  Changing these three constants can have a dramatic    effect on performance.  The values here are reasonable defaults,    but might be tuned.  If you adjust them, be sure to test across a    range of uses of cpplib, including heavy nested function-like macro    expansion.  Also check the change in peak memory usage (NJAMD is a    good tool for this).  */
end_comment

begin_define
define|#
directive|define
name|MIN_BUFF_SIZE
value|8000
end_define

begin_define
define|#
directive|define
name|BUFF_SIZE_UPPER_BOUND
parameter_list|(
name|MIN_SIZE
parameter_list|)
value|(MIN_BUFF_SIZE + (MIN_SIZE) * 3 / 2)
end_define

begin_define
define|#
directive|define
name|EXTENDED_BUFF_SIZE
parameter_list|(
name|BUFF
parameter_list|,
name|MIN_EXTRA
parameter_list|)
define|\
value|(MIN_EXTRA + ((BUFF)->limit - (BUFF)->cur) * 2)
end_define

begin_if
if|#
directive|if
name|MIN_BUFF_SIZE
operator|>
name|BUFF_SIZE_UPPER_BOUND
argument_list|(
literal|0
argument_list|)
end_if

begin_error
error|#
directive|error
error|BUFF_SIZE_UPPER_BOUND must be at least as large as MIN_BUFF_SIZE!
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Create a new allocation buffer.  Place the control block at the end    of the buffer, so that buffer overflows will cause immediate chaos.  */
end_comment

begin_function
specifier|static
name|_cpp_buff
modifier|*
name|new_buff
parameter_list|(
name|size_t
name|len
parameter_list|)
block|{
name|_cpp_buff
modifier|*
name|result
decl_stmt|;
name|unsigned
name|char
modifier|*
name|base
decl_stmt|;
if|if
condition|(
name|len
operator|<
name|MIN_BUFF_SIZE
condition|)
name|len
operator|=
name|MIN_BUFF_SIZE
expr_stmt|;
name|len
operator|=
name|CPP_ALIGN
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|base
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
sizeof|sizeof
argument_list|(
name|_cpp_buff
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
operator|(
name|_cpp_buff
operator|*
operator|)
operator|(
name|base
operator|+
name|len
operator|)
expr_stmt|;
name|result
operator|->
name|base
operator|=
name|base
expr_stmt|;
name|result
operator|->
name|cur
operator|=
name|base
expr_stmt|;
name|result
operator|->
name|limit
operator|=
name|base
operator|+
name|len
expr_stmt|;
name|result
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Place a chain of unwanted allocation buffers on the free list.  */
end_comment

begin_function
name|void
name|_cpp_release_buff
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|_cpp_buff
modifier|*
name|buff
parameter_list|)
block|{
name|_cpp_buff
modifier|*
name|end
init|=
name|buff
decl_stmt|;
while|while
condition|(
name|end
operator|->
name|next
condition|)
name|end
operator|=
name|end
operator|->
name|next
expr_stmt|;
name|end
operator|->
name|next
operator|=
name|pfile
operator|->
name|free_buffs
expr_stmt|;
name|pfile
operator|->
name|free_buffs
operator|=
name|buff
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a free buffer of size at least MIN_SIZE.  */
end_comment

begin_function
name|_cpp_buff
modifier|*
name|_cpp_get_buff
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|size_t
name|min_size
parameter_list|)
block|{
name|_cpp_buff
modifier|*
name|result
decl_stmt|,
modifier|*
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
operator|&
name|pfile
operator|->
name|free_buffs
init|;
condition|;
name|p
operator|=
operator|&
operator|(
operator|*
name|p
operator|)
operator|->
name|next
control|)
block|{
name|size_t
name|size
decl_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
name|NULL
condition|)
return|return
name|new_buff
argument_list|(
name|min_size
argument_list|)
return|;
name|result
operator|=
operator|*
name|p
expr_stmt|;
name|size
operator|=
name|result
operator|->
name|limit
operator|-
name|result
operator|->
name|base
expr_stmt|;
comment|/* Return a buffer that's big enough, but don't waste one that's          way too big.  */
if|if
condition|(
name|size
operator|>=
name|min_size
operator|&&
name|size
operator|<=
name|BUFF_SIZE_UPPER_BOUND
argument_list|(
name|min_size
argument_list|)
condition|)
break|break;
block|}
operator|*
name|p
operator|=
name|result
operator|->
name|next
expr_stmt|;
name|result
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|result
operator|->
name|cur
operator|=
name|result
operator|->
name|base
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Creates a new buffer with enough space to hold the uncommitted    remaining bytes of BUFF, and at least MIN_EXTRA more bytes.  Copies    the excess bytes to the new buffer.  Chains the new buffer after    BUFF, and returns the new buffer.  */
end_comment

begin_function
name|_cpp_buff
modifier|*
name|_cpp_append_extend_buff
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|_cpp_buff
modifier|*
name|buff
parameter_list|,
name|size_t
name|min_extra
parameter_list|)
block|{
name|size_t
name|size
init|=
name|EXTENDED_BUFF_SIZE
argument_list|(
name|buff
argument_list|,
name|min_extra
argument_list|)
decl_stmt|;
name|_cpp_buff
modifier|*
name|new_buff
init|=
name|_cpp_get_buff
argument_list|(
name|pfile
argument_list|,
name|size
argument_list|)
decl_stmt|;
name|buff
operator|->
name|next
operator|=
name|new_buff
expr_stmt|;
name|memcpy
argument_list|(
name|new_buff
operator|->
name|base
argument_list|,
name|buff
operator|->
name|cur
argument_list|,
name|BUFF_ROOM
argument_list|(
name|buff
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|new_buff
return|;
block|}
end_function

begin_comment
comment|/* Creates a new buffer with enough space to hold the uncommitted    remaining bytes of the buffer pointed to by BUFF, and at least    MIN_EXTRA more bytes.  Copies the excess bytes to the new buffer.    Chains the new buffer before the buffer pointed to by BUFF, and    updates the pointer to point to the new buffer.  */
end_comment

begin_function
name|void
name|_cpp_extend_buff
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|_cpp_buff
modifier|*
modifier|*
name|pbuff
parameter_list|,
name|size_t
name|min_extra
parameter_list|)
block|{
name|_cpp_buff
modifier|*
name|new_buff
decl_stmt|,
modifier|*
name|old_buff
init|=
operator|*
name|pbuff
decl_stmt|;
name|size_t
name|size
init|=
name|EXTENDED_BUFF_SIZE
argument_list|(
name|old_buff
argument_list|,
name|min_extra
argument_list|)
decl_stmt|;
name|new_buff
operator|=
name|_cpp_get_buff
argument_list|(
name|pfile
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|new_buff
operator|->
name|base
argument_list|,
name|old_buff
operator|->
name|cur
argument_list|,
name|BUFF_ROOM
argument_list|(
name|old_buff
argument_list|)
argument_list|)
expr_stmt|;
name|new_buff
operator|->
name|next
operator|=
name|old_buff
expr_stmt|;
operator|*
name|pbuff
operator|=
name|new_buff
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free a chain of buffers starting at BUFF.  */
end_comment

begin_function
name|void
name|_cpp_free_buff
parameter_list|(
name|_cpp_buff
modifier|*
name|buff
parameter_list|)
block|{
name|_cpp_buff
modifier|*
name|next
decl_stmt|;
for|for
control|(
init|;
name|buff
condition|;
name|buff
operator|=
name|next
control|)
block|{
name|next
operator|=
name|buff
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|buff
operator|->
name|base
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Allocate permanent, unaligned storage of length LEN.  */
end_comment

begin_function
name|unsigned
name|char
modifier|*
name|_cpp_unaligned_alloc
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|_cpp_buff
modifier|*
name|buff
init|=
name|pfile
operator|->
name|u_buff
decl_stmt|;
name|unsigned
name|char
modifier|*
name|result
init|=
name|buff
operator|->
name|cur
decl_stmt|;
if|if
condition|(
name|len
operator|>
call|(
name|size_t
call|)
argument_list|(
name|buff
operator|->
name|limit
operator|-
name|result
argument_list|)
condition|)
block|{
name|buff
operator|=
name|_cpp_get_buff
argument_list|(
name|pfile
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|buff
operator|->
name|next
operator|=
name|pfile
operator|->
name|u_buff
expr_stmt|;
name|pfile
operator|->
name|u_buff
operator|=
name|buff
expr_stmt|;
name|result
operator|=
name|buff
operator|->
name|cur
expr_stmt|;
block|}
name|buff
operator|->
name|cur
operator|=
name|result
operator|+
name|len
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Allocate permanent, unaligned storage of length LEN from a_buff.    That buffer is used for growing allocations when saving macro    replacement lists in a #define, and when parsing an answer to an    assertion in #assert, #unassert or #if (and therefore possibly    whilst expanding macros).  It therefore must not be used by any    code that they might call: specifically the lexer and the guts of    the macro expander.     All existing other uses clearly fit this restriction: storing    registered pragmas during initialization.  */
end_comment

begin_function
name|unsigned
name|char
modifier|*
name|_cpp_aligned_alloc
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|_cpp_buff
modifier|*
name|buff
init|=
name|pfile
operator|->
name|a_buff
decl_stmt|;
name|unsigned
name|char
modifier|*
name|result
init|=
name|buff
operator|->
name|cur
decl_stmt|;
if|if
condition|(
name|len
operator|>
call|(
name|size_t
call|)
argument_list|(
name|buff
operator|->
name|limit
operator|-
name|result
argument_list|)
condition|)
block|{
name|buff
operator|=
name|_cpp_get_buff
argument_list|(
name|pfile
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|buff
operator|->
name|next
operator|=
name|pfile
operator|->
name|a_buff
expr_stmt|;
name|pfile
operator|->
name|a_buff
operator|=
name|buff
expr_stmt|;
name|result
operator|=
name|buff
operator|->
name|cur
expr_stmt|;
block|}
name|buff
operator|->
name|cur
operator|=
name|result
operator|+
name|len
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

end_unit

